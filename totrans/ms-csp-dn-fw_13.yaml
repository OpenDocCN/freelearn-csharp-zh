- en: Chapter 13. Advanced Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。高级主题
- en: In [Chapter 12](part0078.xhtml#aid-2ACBS2 "Chapter 12. Performance"), *Performance*,
    we studied application's performance under several points of view and analyzed
    some of the most meaningful tools at our disposal in order to improve our software's
    response time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](part0078.xhtml#aid-2ACBS2 "第12章。性能")中，我们研究了从多个角度分析应用程序的性能，并分析了我们可以用来提高软件响应时间的最有意义的工具。
- en: This chapter covers advanced concepts, mainly related to three areas. So, you
    can consider it a miscellaneous chapter, addressing several topics that either
    do not fit directly within the context of any of the preceding chapters or are
    too new, such as what happens with .NET Core.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了高级概念，主要与三个领域相关。因此，你可以将其视为一个杂项章节，涉及几个主题，这些主题要么不适合任何前一章的上下文，要么太新，例如.NET Core会发生什么。
- en: Specifically, I will cover how an application can receive system's calls in
    its own functions and also explain how our code can integrate and communicate
    with the OS using its APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我将介绍应用程序如何在自身函数中接收系统调用，并解释我们的代码如何通过其API集成和与操作系统通信。
- en: Another topic we will cover is **Windows Management Instrumentation** (**WMI**)
    and how it allows the developer to access and modify critical aspects of the system,
    which are sometimes difficult to reach in other approaches.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖另一个主题：**Windows管理工具**（**WMI**），以及它如何允许开发者访问和修改系统的关键方面，这些方面在其他方法中有时难以触及。
- en: We'll also cover parallelism, analyzing some myths and misunderstandings of
    these topics and testing these approaches so that we can really evaluate the advantages
    of this type of programming.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖并行性，分析这些主题的一些神话和误解，并测试这些方法，以便我们真正评估这种编程类型的优势。
- en: The chapter ends with an introduction to .NET Core 1.0 and its derivative work,
    ASP.NET Core 1.0, and its implications and meaning in the open source programming
    world, along with some examples of how to use it. The availability of this technology
    was made public by the end of June, 2016, and some minor additions were included
    in version 1.1, mainly bug fixes and coverage for more operating systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以对.NET Core 1.0及其衍生作品ASP.NET Core 1.0的介绍结束，包括它们在开源编程世界中的影响和意义，以及一些如何使用它们的示例。这项技术的可用性于2016年6月底公开，并在版本1.1中包含了一些小的补充，主要是错误修复和对更多操作系统的支持。
- en: So, we're going to start with the mechanisms that allow communication between
    the OS and .NET in both directions. But first, it would be interesting to remember
    the basics of how the operating system works internally and, specifically, how
    it manages messages between windows if we really want to understand and take advantage
    of this feature in the .NET code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从允许操作系统和.NET之间双向通信的机制开始。但首先，如果我们真的想理解和利用.NET代码中的这个特性，记住操作系统内部工作的基础知识，特别是它如何管理窗口之间的消息，将会很有趣。
- en: 'To summarize, we will cover the following topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中我们将涵盖以下主题：
- en: Sub-classing and platform/invoke
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类化和平台/调用
- en: Windows Management Instrumentation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows管理工具
- en: Extended techniques in parallel programming
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行编程的扩展技术
- en: An introduction to .NET Core 1.0 and ASP.NET Core 1.0
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 1.0和ASP.NET Core 1.0简介
- en: The Windows messaging subsystem
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows消息子系统
- en: All Windows-based applications are event-driven. This means that they don't
    make explicit calls to functions in the OS APIs. Instead, they wait for the system
    to pass any input to them. So it's the system that's the one in charge of providing
    that input.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基于Windows的应用程序都是事件驱动的。这意味着它们不会明确调用操作系统API中的函数。相反，它们等待系统将任何输入传递给它们。因此，负责提供输入的是系统本身。
- en: 'The system''s kernel is in charge of converting hardware events (users'' clicks,
    keyboard entries, touch screen gestures, the arrival of bytes in a communication''s
    port, and so on) into software events, which take the form of messages addressed
    to a software target: a button in a window, a textbox in a form, and so on. After
    all, this is the soul of the Event-driven Programming paradigm.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的内核负责将硬件事件（用户的点击、键盘输入、触摸屏手势、通信端口中字节的到达等）转换为软件事件，这些事件以消息的形式指向软件目标：窗口中的按钮、表单中的文本框等。毕竟，这是事件驱动编程范式的灵魂。
- en: I'll start with a section that deals with how .NET can use low-level resources
    of the operating system, in other words, how our applications can communicate
    and use the core functionality of our operating system, despite being coded using
    distinct models, with distinct data types and calling conventions. This technique
    permits .NET applications to use resources in Windows that are not mapped directly
    to CLR classes and integrate that functionality into our applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从处理 .NET 如何使用操作系统的低级资源的部分开始，换句话说，我们的应用程序如何通过使用不同的模型、不同的数据类型和调用约定来编码，与操作系统的核心功能进行通信和使用。这种技术允许
    .NET 应用程序使用 Windows 中未直接映射到 CLR 类的资源，并将该功能集成到我们的应用程序中。
- en: The MSG structure
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MSG 结构
- en: 'A message is nothing but a numeric code that uniquely identifies a particular
    event. For example, for the previous case when the user presses the left mouse
    button, the window receives a message with this message code: `0x0201`. This number
    is previously defined in code in the following way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 消息不过是一个唯一标识特定事件的数字代码。例如，在用户按下左鼠标按钮的前一个案例中，窗口接收一个带有此消息代码的消息：`0x0201`。这个数字在代码中如下定义：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some messages have data associated with them. For example, in this case, the
    `WM_LBUTTONDOWN` message has to indicate the `x` coordinate and `y` coordinate
    of the mouse cursor to the programmer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些消息与数据相关联。例如，在这种情况下，`WM_LBUTTONDOWN` 消息必须向程序员指示鼠标光标的 `x` 坐标和 `y` 坐标。
- en: Whenever a message is passed to a window, the operating system calls a special
    function of that window, called the window procedure, which is registered for
    that window at creation time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当向窗口传递消息时，操作系统都会调用该窗口的一个特殊函数，称为窗口过程，该窗口过程在创建时注册为该窗口。
- en: This is because in Windows, everything is a window (well, almost), and every
    window procedure (called `WndProc`) takes care of the messages it receives as
    soon as the system sends some input for that window. Actually, the messages are
    queued, and the system has the ability to promote some messages in the queue thanks
    to a priority policy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在 Windows 中，一切几乎都是窗口，每个窗口过程（称为 `WndProc`）都会在系统为该窗口发送一些输入时立即处理它接收到的消息。实际上，消息是排队处理的，系统通过优先级策略有能力提升队列中的某些消息。
- en: All aspects of a window's appearance (and behavior) depend on the window procedure's
    response to these messages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的各个方面（包括行为）都取决于窗口过程对这些消息的响应。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Remember, a window is anything that the system distinguishes with a handler:
    a unique number that makes that component different from the rest. That is, buttons,
    icons, among others, are just windows embedded in other windows, each one with
    its own handler.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，窗口是系统通过处理程序区分的任何东西：一个使该组件与其他组件不同的唯一数字。也就是说，按钮、图标等，只是嵌入在其他窗口中的窗口，每个窗口都有自己的处理程序。
- en: So, every time you click on a button, pass the cursor over an icon or use *Ctrl*
    + *C* to copy the content, and system sends a message to the target window (the
    button, the icon, the clipboard, and so on).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次你点击一个按钮，将光标移过图标或使用 *Ctrl* + *C* 复制内容时，系统都会向目标窗口（按钮、图标、剪贴板等）发送消息。
- en: A message is received by the `wndproc` function associated with that target,
    which processes that message and returns control to the system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通过与目标相关联的 `wndproc` 函数接收，该函数处理该消息并将控制权返回给系统。
- en: 'The following figure shows this structure in more detail:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下图更详细地展示了这个结构：
- en: '![The MSG structure](img/image00673.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![MSG 结构](img/image00673.jpeg)'
- en: 'Note that according to the MSDN:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据 MSDN：
- en: '"If a top-level window stops responding to messages for more than several seconds,
    the system considers the window to be not responding. In this case, the system
    hides the window and replaces it with a ghost window that has the same Z order,
    location, size, and visual attributes. This allows the user to move it, resize
    it, or even close the application. However, these are the only actions available
    because the application is actually not responding. When in the debugger mode,
    the system does not generate a ghost window."'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果一个顶级窗口在几秒钟内停止响应消息，系统会认为该窗口没有响应。在这种情况下，系统会隐藏窗口，并用具有相同 Z 轴顺序、位置、大小和视觉属性的幽灵窗口替换它。这使用户可以移动它、调整它的大小，甚至关闭应用程序。然而，这些是唯一可用的操作，因为应用程序实际上没有响应。在调试模式下，系统不会生成幽灵窗口。”
- en: As mentioned earlier, either system messages or user messages are queued and
    the `wndproc` function processes them in a first-in-first-out fashion (with some
    exceptions).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，系统消息或用户消息都被排队，`wndproc`函数以先入先出的方式（有一些例外）处理它们。
- en: 'Actually, you can distinguish between two kinds of messages: those sent by
    user applications, which generally go to the FIFO queue, and others, sent by the
    OS which can have a distinct priority and, therefore, can be located before the
    rest in the queue (for example, error messages).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以区分两种类型的信息：那些由用户应用程序发送的信息，通常进入FIFO队列，以及其他由操作系统发送的信息，这些信息可以有独特的优先级，因此可以在队列中排在其他信息之前（例如，错误信息）。
- en: These messages can be sent via Post Message or Send Message APIs depending on
    the expected behavior, and although we're not going to cover these aspects in
    depth (since they go far beyond the scope of this chapter), we'll look at how
    we can send messages using these APIs and what we can obtain through this technique.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息可以通过Post Message或Send Message API发送，具体取决于预期的行为，尽管我们不会深入探讨这些方面（因为它们远远超出了本章的范围），但我们将探讨如何使用这些API发送消息以及我们可以通过这种技术获得什么。
- en: 'The next figure shows how all this happens from different threads in the system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了系统中的不同线程如何发生这一切：
- en: '![The MSG structure](img/image00674.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![MSG结构](img/image00674.jpeg)'
- en: Our applications, though managed, behave the same way, and the fact that we
    can access handles from our code makes it possible to capture events from the
    system and change behaviors at will.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序是受管理的，但它们的行为方式相同，并且我们可以从我们的代码中访问句柄，这使得我们可以捕获系统事件并随意更改行为。
- en: Among these techniques, the one that allows us to capture system or application
    events is called sub-classing. Let's explain how it works and how we can use it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些技术中，允许我们捕获系统或应用程序事件的技术被称为子类化。让我们解释它是如何工作的以及我们如何使用它。
- en: Sub-classing techniques
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类化技术
- en: 'Once we understand the previous architecture, it makes sense to use it in a
    variety of ways: avoiding predefined behaviors for controls or windows, adding
    specific elements to existing windows components, and many others.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了之前的架构，就有很多方式可以使用它：避免控件或窗口的预定义行为，向现有的窗口组件添加特定元素，等等。
- en: Let's try a basic example. Suppose that we want to change the way a window responds
    to the left button. Only that. So, we have a simple Windows Forms application,
    and we need to think of the elements we need in order to code that behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个基本的例子。假设我们想要改变窗口对左键的响应方式。仅此而已。因此，我们有一个简单的Windows Forms应用程序，我们需要考虑我们需要哪些元素来编写这种行为。
- en: First, we need to capture the specific messages addressed to the left button.
    Then, we have the override to `WndProc` associated with our window, determine
    what to do if the message is the one required, and finally, *always* return the
    control to the operating system correctly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要捕获针对左键的具体消息。然后，我们有与我们的窗口关联的`WndProc`重写，确定如果消息是我们需要的那个，应该做什么，最后，*始终*正确地将控制权返回给操作系统。
- en: 'This figure shows the process:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图显示了整个过程：
- en: '![Sub-classing techniques](img/image00675.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![子类化技术](img/image00675.jpeg)'
- en: 'Fortunately, in C#, that''s something pretty simple. Just look at this code,
    which we add to the `main`, default window code created by the IDE:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在C#中，这很简单。只需看看我们添加到IDE创建的`main`默认窗口代码中的这段代码：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A few things should be noted in this fragment: first and foremost, we''re overriding
    a method that is not defined in our code. Actually, `WndProc` is defined in the
    `Form` class, as you can see by selecting the **Go to Definition** option in the
    class declaration (over `Form`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，有几件事情应该注意：首先，我们正在重写一个在我们代码中未定义的方法。实际上，`WndProc`是在`Form`类中定义的，正如你在类声明（在`Form`之上）中选择**转到定义**选项所看到的那样：
- en: '![Sub-classing techniques](img/image00676.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![子类化技术](img/image00676.jpeg)'
- en: If you launch the application, it should run just fine, but any left click on
    it will respond with a message box, indicating the processed message number. There's
    no way to left-click on it; only right-click will work properly! (You might find
    difficult to even close the window, although you can always close the application
    from Visual Studio or right-click on the title's area).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动应用程序，它应该运行得很好，但任何左键点击都会弹出一个消息框，指示处理的消息编号。无法通过左键点击它；只有右键点击才能正常工作！（你可能发现甚至关闭窗口都很困难，尽管你始终可以从Visual
    Studio关闭应用程序或右键点击标题区域）。
- en: 'The output will be something like what is shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下截图所示：
- en: '![Sub-classing techniques](img/image00677.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![子类化技术](img/image00677.jpeg)'
- en: However, you might be wondering how in the world is the number 513 defined and
    where can we find information about it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能想知道数字 513 是如何定义的，以及我们可以在哪里找到有关它的信息。
- en: This might be the proper time to talk a bit about some tools (local or online)
    that you can use to find not only that information, but also any other system-related
    data you can use in these kind of .NET/OS interactions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是讨论一些工具（本地或在线）的合适时机，你可以使用这些工具来查找不仅这些信息，还可以用于这些类型 .NET/OS 交互的任何其他系统相关数据。
- en: Some useful tools
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些有用的工具
- en: 'If we deal with definitions and also with the distinct ways in which a system''s
    API should be called from .NET, there''s a reference website: [PInvoke.net](http://PInvoke.net)
    (available at [http://www.pinvoke.net/](http://www.pinvoke.net/)).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理定义，并且处理从 .NET 调用系统 API 的不同方式，有一个参考网站：[PInvoke.net](http://PInvoke.net)（可在
    [http://www.pinvoke.net/](http://www.pinvoke.net/) 访问）。
- en: You'll find the vast majority of the system's APIs clearly detailed, explaining
    the way they work, how they should be defined in our code (either from C# or VB.NET),
    and all other related information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现大多数系统 API 都有详细的说明，解释它们的工作方式，它们应该如何在我们的代码中定义（无论是从 C# 还是 VB.NET），以及所有其他相关信息。
- en: For example, knowing that all window messages are defined with the `WM_` prefix,
    we can expand it under the **Constants** topic to locate the one I used earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，知道所有窗口消息都是以 `WM_` 前缀定义的，我们可以在 **常量** 主题下展开它，以找到之前使用过的那个。
- en: 'Furthermore, we are shown a definition of the message and its purpose, along
    with the hexadecimal number associated with it, and at the end of that list, you''ll
    find the C# definitions, where it''s easy to locate those linked to the left button,
    as shown in the next screenshots:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还看到了消息的定义及其用途，以及与其相关的十六进制数，在列表的末尾，你会找到 C# 定义，其中很容易找到与左侧按钮相关联的链接，如下一张截图所示：
- en: '![Some useful tools](img/image00678.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![一些有用的工具](img/image00678.jpeg)'
- en: 'Following, you can see the definitions in C# code, ready to use in a program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到 C# 代码中的定义，这些定义可以在程序中使用：
- en: '![Some useful tools](img/image00679.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![一些有用的工具](img/image00679.jpeg)'
- en: In the code, as you already know, we can use the decimal equivalent (as I did)
    or the hexadecimal definition, with the same results. Actually, it's preferable
    to use these definitions to produce clearer and readable code instead of what
    I did in the first demo.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，正如你所知，我们可以使用十进制等效值（如我所做）或十六进制定义，结果相同。实际上，使用这些定义来生成更清晰、可读的代码比我在第一个演示中做的更可取。
- en: If, instead, you look for a function or scroll over some well-known system DLLs
    such as `user32.dll`, you will see that it contains lots of functions related
    to Windows, such as `FindWindowEx`. If you expand this function, you'll see the
    definition that we should use in our code in order to call that function, as we
    will do in the next section, *Platform/Invoke*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，相反，你寻找一个函数或滚动到一些众所周知的系统 DLL，例如 `user32.dll`，你会看到它包含许多与 Windows 相关的函数，如 `FindWindowEx`。如果你展开这个函数，你会看到我们应该在我们的代码中使用的定义，以便调用该函数，正如我们将在下一节
    *Platform/Invoke* 中所做的那样。
- en: A bit further down, we can even find a sample of how to use the function in
    practice (in this case, this is done in order to get a reference to the horizontal
    scroll bar of a window).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面一点，我们甚至可以找到一个如何在实际中（在这种情况下，这是为了获取窗口的水平滚动条的引用）使用该函数的示例。
- en: 'There''s also another interesting tool, created by Justin Van Patten, at **Microsoft:
    P/Invoke Interop Assistant**, which we can download and install from Codeplex,
    at [http://clrinterop.codeplex.com/releases/view/14120](http://clrinterop.codeplex.com/releases/view/14120).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个有趣的工具，由 Justin Van Patten 创建，在 **微软**：P/Invoke Interop Assistant，我们可以从
    Codeplex 下载并安装，地址为 [http://clrinterop.codeplex.com/releases/view/14120](http://clrinterop.codeplex.com/releases/view/14120)。
- en: Once downloaded and installed, you'll find several tools in the `Program Files
    (X86)/InteropSignatureToolkit` directory. Two of them are command-line tools to
    help you define the function's signatures from other libraries or DLLs (they might
    be TLBs as well).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装后，你将在 `Program Files (X86)/InteropSignatureToolkit` 目录下找到几个工具。其中两个是命令行工具，可以帮助你从其他库或
    DLL（它们也可能是 TLBs）中定义函数的签名。
- en: The last one is a Windows app that lets you do the work we previously did in
    the PInvoke.net site, only from a Windows application. It's called Windows Signature
    Generator (`winsiggen.exe`).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是 Windows 应用程序，它允许你执行我们在 PInvoke.net 网站上之前所做的操作，但仅从 Windows 应用程序中进行。它被称为
    Windows 签名生成器 (`winsiggen.exe`)。
- en: 'Within these tools, you can import DLLs from anywhere in the system, or you
    can even consult the previous definition without requiring any more work: by selecting
    the **SigImp Search** tag, you filter what you''re looking for and see the definitions
    in a list. Furthermore, by selecting the definitions you want to work with, you''ll
    have the choice to generate the C# or VB.NET code necessary, as the following
    screenshot shows, in which I searched for the definitions used in the previous
    demo:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些工具中，你可以从系统中的任何位置导入 DLLs，或者甚至可以咨询之前的定义，而无需做更多的工作：通过选择 **SigImp 搜索** 标签，你可以过滤你正在寻找的内容，并查看列表中的定义。此外，通过选择你想要工作的定义，你将可以选择生成必要的
    C# 或 VB.NET 代码，如下面的截图所示，其中我搜索了之前演示中使用的定义：
- en: '![Some useful tools](img/image00680.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![一些有用的工具](img/image00680.jpeg)'
- en: 'Besides this solution, there is another choice, which is pretty interesting
    for the developer in Visual Studio: under the **Extensions and Updates** menu;
    if you select **on-line** and filter **pinvoke** or similar, there''s a version
    of this tool called **PInvoke.net for Visual Studio Extension**, lately managed
    by Red Gate. You should find an entry like the one shown in the next screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个解决方案，还有一个选择，对于 Visual Studio 中的开发者来说非常有趣：在 **扩展和更新** 菜单下；如果你选择 **在线** 并过滤
    **pinvoke** 或类似的内容，将有一个名为 **PInvoke.net for Visual Studio Extension** 的工具版本，最近由
    Red Gate 管理。你应该能在下一个截图所示的条目中找到类似的内容：
- en: '![Some useful tools](img/image00681.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![一些有用的工具](img/image00681.jpeg)'
- en: Once installed (it takes a moment), it will create a new menu in the IDE after
    a restart of Visual Studio.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后（需要一点时间），在 Visual Studio 重启后，它将在 IDE 中创建一个新的菜单。
- en: What you will see is a window similar to the one in the previous tool, but highly
    simplified and with the option to search for any function or module or visit the
    [PInvoke.net](http://PInvoke.net) site if you need to look for a definition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个类似于上一个工具的窗口，但高度简化，并且可以选择搜索任何函数或模块，或者如果你需要查找定义，可以访问 [PInvoke.net](http://PInvoke.net)
    网站。
- en: 'Platform/Invoke: calling the OS from .NET'
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Platform/Invoke：从 .NET 调用操作系统
- en: Platform/Invoke allows the coder to use standard (unmanaged) C/C++ DLLs. If
    you need to have access to any function inside the extensive Windows APIs (which
    hold basically everything the operating system can perform) and there's no available
    wrapper to call the same functionality from the CLR, then this is the choice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Platform/Invoke 允许程序员使用标准的（非托管）C/C++ DLLs。如果你需要访问广泛 Windows APIs（基本上包含了操作系统能执行的所有功能）中的任何函数，并且没有可用的包装器可以从
    CLR 调用相同的功能，那么这就是你的选择。
- en: From the developer's perspective, by Platform/Invoke, we understand a feature
    of the CLR that allows a program to interact with the functionality that is unique
    to the system in which the application runs, thus allowing managed code to call
    native code and vice versa.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，通过 Platform/Invoke，我们理解 CLR 的一个特性，它允许程序与运行应用程序的系统中独特的功能进行交互，从而允许托管代码调用原生代码，反之亦然。
- en: The assembly responsible for calling the APIs will define how the native code
    is called and accessed, via metadata embedded inside, which usually requires attribute
    decorations. These attributes are defined inside the class containing the caller
    methods in order to indicate the compiler the correct way to do the marshaling
    between the two worlds (managed and unmanaged).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 负责调用 API 的程序集将定义如何调用和访问原生代码，通过嵌入在其中的元数据，这通常需要属性装饰。这些属性定义在包含调用方法的类中，以指示编译器在托管和非托管两个世界之间进行封送处理（Marshaling）的正确方式。
- en: The idea is that if I need to call an unmanaged function from the managed code,
    I should indicate the destination context how big the things that I'm passing
    are and what direction they are going. That is if I'm asking for data or if I'm
    passing data (or both).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，如果我从托管代码中调用非托管函数，我应该指示目标上下文我传递的东西有多大，以及它们的方向。也就是说，如果我在请求数据或传递数据（或两者都是）。
- en: The caveat is that there are many exceptions, and often, there's always a better
    way to do it, even if coded correctly. This is where the tools we just reviewed
    help the programmer to deal with these situations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个缺点是存在许多异常，而且通常，即使代码编写正确，也总有一种更好的方法来做。这就是我们刚刚审查的工具帮助程序员处理这些情况的地方。
- en: But let's first review the foundations of the platform invocation and how to
    use it from C# with a simple example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先让我们回顾一下平台调用的基础以及如何通过一个简单的示例从 C# 中使用它。
- en: The process of platform invocation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台调用的过程
- en: 'To achieve platform invocation, the CLR has to do several things:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现平台调用，CLR 必须执行几个步骤：
- en: Locate the DLL containing the function and load it in memory
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位包含函数的 DLL 并将其加载到内存中
- en: Locate the function's memory address and push its arguments onto the stack,
    marshaling data as required
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位函数的内存地址并将它的参数推入堆栈，按需封装数据
- en: Note, however, that operating in this way also has some pitfalls. For example,
    you no longer have the benefits of type safety or garbage collection, and you
    have to be careful when using them. The great advantage, on the other hand, is
    that the enormous amount of functionality provided by the system is available
    for us, and we're talking about functionality that has been fully tested and optimized.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以这种方式操作也有一些陷阱。例如，你不再有类型安全或垃圾回收的好处，并且在使用它们时必须小心。另一方面，巨大的优势是，系统提供的功能大量可用，而且我们谈论的是经过充分测试和优化的功能。
- en: It's easy to insert external APIs' definitions into our code. Let's look at
    this in an example. Imagine that our application uses the system's calculator
    (or any other system's tool) and we want to make sure that in certain circumstances,
    the calculator is located in a given position (such as the screen's origin) and
    also that we want to have the ability to close the calculator from our program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部 API 的定义插入到我们的代码中很容易。让我们通过一个例子来看看。想象一下，我们的应用程序使用系统的计算器（或任何其他系统工具），并且我们想确保在特定情况下，计算器位于给定的位置（例如屏幕的原点），并且我们还希望有能力从我们的程序中关闭计算器。
- en: We need three APIs here—`SetWindowPos` (to change the calculator's position),
    `SendMessage` (to close the calculator), and `FindWindow`—in order to get the
    calculator's handle that we need to use with other two.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要三个 API——`SetWindowPos`（用于更改计算器的位置）、`SendMessage`（用于关闭计算器）和 `FindWindow`——以便获取我们需要与其他两个一起使用的计算器句柄。
- en: 'So, we search for these functions in the Platform/Invoke Assistant to find
    their definitions, and we use the Insert button to have the translated definition
    inserted in our code. For every function search, we should see a window like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在平台/调用助手中搜索这些函数以找到它们的定义，并使用插入按钮将翻译后的定义插入到我们的代码中。对于每个函数搜索，我们都应该看到一个类似这样的窗口：
- en: '![The process of platform invocation](img/image00682.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![平台调用的过程](img/image00682.jpeg)'
- en: 'After finding the three functions, we should have the following code available:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这三个函数后，我们应该有以下代码可用：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is our bridge to the operating system's functionality, and we can call
    these functions from any accessible place just like if they were .NET functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的操作系统功能桥梁，我们可以从任何可访问的地方调用这些函数，就像它们是 .NET 函数一样。
- en: 'For this demo, I''ll create a basic Windows Forms app with a couple of buttons
    in order to implement the required functionality. The first button finds the calculator''s
    handler and locates the `Calculator` in the top-left position:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我将创建一个基本的 Windows Forms 应用程序，其中包含几个按钮，以便实现所需的功能。第一个按钮找到计算器的处理程序并将 `Calculator`
    定位到最左上角的位置：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, in another button, we have to send a message to the `Calculator` to close
    it. Again, we can check with the assistant, knowing that the message identifier
    is called `WM_CLOSE` and that we will find it searching for constants and going
    down to those starting with `WM_`. So we insert this definition and are ready
    to call the second button, which closes the calculator:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个按钮中，我们必须向 `Calculator` 发送一个消息来关闭它。同样，我们可以通过助手检查，知道消息标识符被称为 `WM_CLOSE`，并且我们将在搜索常量时找到它，向下到以
    `WM_` 开头的那些。因此，我们插入这个定义并准备好调用第二个按钮，该按钮关闭计算器：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember that when we are using the system APIs, some parameters have to be
    specifically **marshaled** (converted) into the destination types. This is why
    the last two parameters are expressed as `IntPrt.Zero`, which is the correct definition
    for this type in .NET.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们使用系统 API 时，一些参数必须被特别**封装**（转换）成目标类型。这就是为什么最后两个参数被表示为 `IntPrt.Zero`，这是
    .NET 中此类型的正确定义。
- en: Naturally, we can use this technique to close any window, including managed
    ones, although in this case, we have other (simpler) options, including the possibilities
    that we saw in relation to Reflection, if the holding assembly is external.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，我们可以使用这种技术来关闭任何窗口，包括受管理的窗口，尽管在这种情况下，我们还有其他（更简单）的选项，包括与反射相关的可能性，如果持有组件是外部的。
- en: 'Also, note that some solutions called *multiplatform* are based on calls to
    native code from managed code: in Silverlight; the runtime is based on **Platform
    Adaptation Layer** (**PAL**) based on these principles. This allows you to call
    native functions in different OSes.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，一些被称为*多平台*的解决方案是基于从托管代码调用本地代码的：在Silverlight中；运行时基于基于这些原则的**平台适配层**（**PAL**）。这允许你在不同的操作系统上调用本地函数。
- en: This can also be said for Platform/Invoke in Linux and MacOS, the most successful
    manifestation of this being the Xamarin initiative (more information about Platform/Invoke
    on these platforms is available at [http://www.mono-project.com/docs/advanced/pinvoke/](http://www.mono-project.com/docs/advanced/pinvoke/)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于Linux和MacOS中的平台/调用，其中最成功的体现是Xamarin倡议（有关这些平台上的Platform/Invoke的更多信息，请参阅[http://www.mono-project.com/docs/advanced/pinvoke/](http://www.mono-project.com/docs/advanced/pinvoke/)）。
- en: However, as we'll see at the end, the new .NET Core is a great promise in this
    respect since it is thought of to work on any platform and any operating system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们将在最后看到的，新的.NET Core在这方面是一个巨大的承诺，因为它被认为可以在任何平台和任何操作系统上运行。
- en: Nevertheless, if we're programming for Windows, there are situations where we
    need to know specific data about the configuration of our platform. That's where
    **Windows Management Instrumentation** (**WMI**), or its recent alternative Windows
    Management Infrastructure, can be very useful, not just for programmers, but for
    IT people as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们为Windows编程，有些情况下我们需要了解我们平台配置的特定数据。这就是**Windows管理规范**（**WMI**）或其最近的替代品**Windows管理基础设施**非常有用的地方，不仅对程序员，而且对IT人员也是如此。
- en: Windows Management Instrumentation
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows管理规范
- en: 'The official documentation defines WMI technology in this manner:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档以这种方式定义WMI技术：
- en: '"Windows Management Instrumentation (WMI) is the infrastructure for management
    data and operations on Windows-based operating systems. You can write WMI scripts
    or applications to automate administrative tasks on remote computers but WMI also
    supplies management data to other parts of the operating system and products,
    for example, System Center Operations Manager, formerly Microsoft Operations Manager
    (**MOM**), or **Windows Remote Management** (**WinRM**)."'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Windows管理规范（WMI）是Windows基于操作系统的管理数据和操作的基础设施。您可以使用WMI脚本或应用程序来自动化远程计算机上的管理任务，但WMI还向操作系统的其他部分和产品提供管理数据，例如，System
    Center Operations Manager，以前称为Microsoft Operations Manager（**MOM**），或**Windows远程管理**（**WinRM**）。”
- en: 'However, the same documentation adds:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，同样的文档还补充说：
- en: '"WMI is fully supported by Microsoft; however, the latest version of administrative
    scripting and control is available through the Windows **Management Infrastructure**
    (**MI**). MI is fully compatible with previous versions of WMI and provides a
    host of features and benefits that make designing and developing providers and
    clients easier than ever. For more information, see Windows Management Infrastructure
    (MI)."'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “WMI完全由Microsoft支持；然而，最新的管理脚本和控制版本可通过Windows **管理基础设施**（**MI**）获得。MI与WMI的先前版本完全兼容，并提供了一系列功能和好处，使得设计和开发提供者和客户端比以往任何时候都更容易。有关更多信息，请参阅Windows管理基础设施（MI）。”
- en: You can find more information on configuring MI at [https://msdn.microsoft.com/en-us/library/dn313131(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/dn313131(v=vs.85).aspx)
    if you want to dig into these features in depth.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解这些功能，可以在[https://msdn.microsoft.com/en-us/library/dn313131(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/dn313131(v=vs.85).aspx)找到更多关于配置MI的信息。
- en: So, with WMI, we query the system to get details on its implementation and the
    software and hardware installed. The reason for the query is that WMI stores the
    system's information in **Common Information Model** (**CIM**) databases, stored
    and updated by the system continuously.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用WMI，我们查询系统以获取其实施和安装的软件和硬件的详细信息。查询的原因是WMI将系统信息存储在**通用信息模型**（**CIM**）数据库中，这些数据库由系统持续存储和更新。
- en: 'And by the way, the CIM is not something exclusive to Windows operating systems.
    As Wikipedia states:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，CIM不是Windows操作系统的专属。正如维基百科所述：
- en: '"The **Common Information Model** (**CIM**) is an open standard that defines
    how managed elements in an IT environment are represented as a common set of objects
    and relationships between them.'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “**通用信息模型**（**CIM**）是一个开放标准，它定义了IT环境中管理元素如何表示为一组公共对象及其之间的关系。
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Distributed Management Task Force maintains the CIM to allow consistent
    management of these managed elements, independent of their manufacturer or provider."
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分布式管理任务组维护CIM，以允许独立于制造商或提供者的管理元素的一致管理。”
- en: The DMTF updates these documents frequently (sometimes, twice a year).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: DMTF频繁更新这些文档（有时一年两次）。
- en: CIM searchable tables
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CIM可搜索表
- en: There are many tables permanently updated by the system, which we can search.
    The complete list is published on MSDN, and you can find this information in the
    *Computer System Hardware Classes* section, available at [https://msdn.microsoft.com/en-us/library/aa389273(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa389273(v=vs.85).aspx).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中有许多表被永久更新，我们可以搜索。完整的列表发布在MSDN上，你可以在[https://msdn.microsoft.com/en-us/library/aa389273(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa389273(v=vs.85).aspx)的*计算机系统硬件类*部分找到这些信息。
- en: 'I''ll resume some of the most useful terms to search for programmers here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里总结一些对程序员最有用的搜索术语：
- en: Input device classes
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入设备类
- en: Mass storage classes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大容量存储类
- en: Motherboard, controller, and port classes
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主板、控制器和端口类
- en: Networking device classes
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备类
- en: Power classes
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源类
- en: Printing classes
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印类
- en: Telephony classes
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电信类
- en: Video and monitor classes
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频和显示器类
- en: Each one contains a set of distinct classes, holding a variety of information
    about the hardware and the software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都包含一组独特的类，包含有关硬件和软件的各种信息。
- en: For this brief review, we're just going to use the classical WMI and look at
    the type of data that can be revealed to us in a demo and how to query for it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次简要回顾中，我们只将使用经典的WMI，查看在演示中可以向我们揭示的数据类型以及如何查询它。
- en: Although there are several ways to access this information for the .NET programmer,
    .NET provides part of the WMI functionality through the `System.Management` namespace,
    which is filled with classes to search for system-related information, such as
    `ManagementObjectSearcher`, `SelectQuery`, `ManagementObject`, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几种方法可以访问.NET程序员的这些信息，但.NET通过`System.Management`命名空间提供了WMI功能的一部分，该命名空间包含用于搜索系统相关信息的类，例如`ManagementObjectSearcher`、`SelectQuery`、`ManagementObject`等。
- en: For a simple query about the system information, we first create a `ManagementObjectSearcher`
    object that defines the focus of our search (an information provider). This object
    should receive a SQL string, indicating the table we want to search for.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的系统信息查询，我们首先创建一个`ManagementObjectSearcher`对象，该对象定义了搜索的焦点（一个信息提供者）。此对象应接收一个SQL字符串，指示我们想要搜索的表。
- en: So, in our demo, we're going to start by creating a Windows Forms app, including
    a few buttons and a couple of Listbox controls to present the results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的演示中，我们将首先创建一个Windows窗体应用程序，包括几个按钮和一些Listbox控件来展示结果。
- en: 'We''ll start by coding a general query to obtain the list of tables available.
    The code for the button in charge of that is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个通用查询来获取可用表的列表。负责此操作的按钮的代码如下：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `meta_class` is a CIM object containing the complete list of
    classes available for searching. Note that the query might take a while since
    `ManagementObjectSearcher` has to go through all the information available in
    the system and registered in the CIM tables.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`meta_class`是一个包含可用于搜索的所有类的完整列表的CIM对象。请注意，查询可能需要一段时间，因为`ManagementObjectSearcher`必须遍历系统中所有可用并在CIM表中注册的信息。
- en: 'You should see output similar to the what is shown in the next screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于下一张截图的输出：
- en: '![CIM searchable tables](img/image00683.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![CIM可搜索表](img/image00683.jpeg)'
- en: Later on, we can query these tables to retrieve the required data. In this demo,
    we'll use several tables—**Win32_OperatingSystem**, **Win32_processor**, **Win32_bios**,
    **Win32_Environment**, and **Win32_Share**—to find some information about the
    running machine and related characteristics.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以查询这些表以检索所需数据。在这个演示中，我们将使用几个表——**Win32_OperatingSystem**、**Win32_processor**、**Win32_bios**、**Win32_Environment**和**Win32_Share**——来查找有关运行机器和相关特性的信息。
- en: 'The way it works is always the same: you create `ManagementObjectSearcher`
    and iterate over it, invoking the `Get()`method on every instance of the collection
    returned by the searcher. So, we have the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式始终相同：你创建`ManagementObjectSearcher`并遍历它，对搜索器返回的集合的每个实例调用`Get()`方法。因此，我们有以下代码：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you run the demo, depending on your machine, you''ll get some distinct values,
    but the structure of the information should be similar to what is shown in the
    next screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行演示，根据你的机器，你可能会得到一些不同的值，但信息的结构应该类似于下一张截图所示：
- en: '![CIM searchable tables](img/image00684.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![CIM可搜索表](img/image00684.jpeg)'
- en: To summarize, WMI offers a simple, managed way to access practically any relevant
    data related to the hardware and software on our machine and also in the network
    to which we are connected (as far as the query has the required permissions).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，WMI提供了一种简单、受管理的访问我们机器上硬件和软件以及我们连接的网络中几乎所有相关数据的方法（只要查询具有所需的权限）。
- en: 'As for the security concerns, Microsoft has published an exhaustive article
    on the subject on MSDN: *Maintaining WMI Security* ([https://msdn.microsoft.com/en-us/library/aa392291(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa392291(v=vs.85).aspx)),
    with all the critical information and guidelines about maintaining security while
    allowing access to these resources.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全方面的担忧，微软在MSDN上发布了一篇关于此主题的详尽文章：*维护WMI安全* ([https://msdn.microsoft.com/en-us/library/aa392291(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa392291(v=vs.85).aspx))，其中包含了关于在允许访问这些资源的同时维护安全性的所有关键信息和指南。
- en: There is much more functionality related to the `ManagementObject` class. For
    instance, you can get information related to processes or services by creating
    a new instance of the desired element and use the methods the object inherits.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ManagementObject`类相关的功能还有很多。例如，你可以通过创建所需元素的新实例来获取有关进程或服务的信息，并使用该对象继承的方法。
- en: 'For example, if you want to know which services are dependent on other services
    programmatically, you can use the `GetRelated` method of the object''s instance.
    Let''s imagine we want to know which services are related to the **LSM** (**Local
    Session Manager**) service. We could code the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想以编程方式知道哪些服务依赖于其他服务，你可以使用对象实例的`GetRelated`方法。让我们假设我们想知道与**LSM**（**本地会话管理器**）服务相关的服务。我们可以编写以下代码：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this way, we can get this (hard-to-find) information in a totally programmatic
    manner. This will help us configure some scenarios in which one of our application's
    procedures require the active presence of a certain service (remember that we
    can launch a service from code as well).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以以完全程序化的方式获取这些（难以找到的）信息。这将帮助我们配置一些场景，其中我们的应用程序的某个过程需要某个服务的活跃存在（记住，我们也可以从代码中启动服务）。
- en: 'Besides this, other actions are available, such as stopping, pausing, or resuming
    a given service. In the case of the LSM service, we should see information similar
    to what is shown in this screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有其他操作可用，例如停止、暂停或恢复指定的服务。在LSM服务的情况下，我们应该看到类似于以下截图所示的信息：
- en: '![CIM searchable tables](img/image00685.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![CIM可搜索表](img/image00685.jpeg)'
- en: And there is much more information that you will discover going through the
    class hierarchy related to `System.Management`. Practically every byte of system-related
    data that we should otherwise read via Registry or Windows APIs is available here
    in a totally programmatic fashion with no need for complex approaches.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有更多通过`System.Management`相关类层次结构发现的信息。实际上，我们应该通过注册表或Windows API读取的几乎所有与系统相关的数据，都可以在这里以完全程序化的方式获得，无需复杂的方案。
- en: The only caveat is that the documentation is very long. Consequently, Microsoft
    created a tool called WMI Code Creator, which analyzes the information available
    and generates code for all possible scenarios (often, this code is expressed in
    Windows Scripting Host), but a big part is perfectly translatable to C#.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是文档非常长。因此，微软创建了一个名为WMI Code Creator的工具，该工具分析可用的信息，并为所有可能的场景生成代码（通常，此代码以Windows
    Scripting Host的形式表达），但大部分可以完美地转换为C#。
- en: Besides, we have the advantage of a tool that joins much of the functionality
    available in a single user interface.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还拥有一个工具的优势，该工具将许多功能集成在一个用户界面中。
- en: You can download it from [https://www.microsoft.com/en-gb/download/details.aspx%3Fid%3D8572](https://www.microsoft.com/en-gb/download/details.aspx%3Fid%3D8572),
    getting a ZIP file that contains the executable and the source code, which is
    a valuable tip for coding in WMI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.microsoft.com/en-gb/download/details.aspx%3Fid%3D8572](https://www.microsoft.com/en-gb/download/details.aspx%3Fid%3D8572)下载它，得到一个包含可执行文件和源代码的
    ZIP 文件，这对于在 WMI 中编码是一个宝贵的提示。
- en: 'The tool includes several options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包括几个选项：
- en: Query data from a WMI class
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 WMI 类查询数据
- en: Executing a method
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个方法
- en: Receiving an event
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一个事件
- en: Browsing the namespaces on this computer
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览此计算机上的命名空间
- en: 'As you can see in the next screenshot, this tool is quite complete in possibilities
    and in the information it provides:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在下一张屏幕截图中所见，这个工具在可能性和提供的信息方面都非常全面：
- en: '![CIM searchable tables](img/image00686.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![CIM 可搜索表](img/image00686.jpeg)'
- en: Another typical usage of WMI is to check the state of a piece of hardware before
    performing an action that could provoke a system's failure, such as testing a
    hard drive before copying big chunks of data that could exceed the disk quota.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 的另一个典型用途是在执行可能引发系统故障的操作之前检查硬件的状态，例如在复制可能超过磁盘配额的大量数据之前测试硬盘。
- en: 'The code, in this case, is simple, and it gives us an idea about how to code
    other system-related queries. All we need is something like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码很简单，它给我们提供了一个关于如何编写其他系统相关查询的想法。我们需要的只是类似这样的东西：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Thus, after adding a new button and including the previous code to check the
    state of the `C:` drive, we should see output similar to this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在添加一个新按钮并包含之前的代码以检查 `C:` 驱动的状态后，我们应该看到类似以下输出：
- en: '![CIM searchable tables](img/image00687.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![CIM 可搜索表](img/image00687.jpeg)'
- en: To summarize, we've seen several ways of interacting with the operating system.
    We can analyze which messages are linked to a certain functionality and capture
    the related events to either change, cancel, or modify the default behaviors.
    In this case, the communication is in both directions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经看到了几种与操作系统交互的方式。我们可以分析哪些消息与特定的功能相关联，并捕获相关事件以更改、取消或修改默认行为。在这种情况下，通信是双向的。
- en: This also happens (bi-directional communications) when we use the system APIs
    to call functionalities through Platform/Invoke, which offers unlimited possibilities.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用系统 API 通过 Platform/Invoke 调用功能时，也会发生这种情况（双向通信），它提供了无限的可能性。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, the official Microsoft recommendation is that if they're available
    for the .NET programmer, it's always preferable to use the resources linked to
    .NET classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，官方微软建议，如果它们对 .NET 程序员可用，那么始终首选使用与 .NET 类关联的资源。
- en: Finally, Windows Management Instrumentation and its variant MI provide access
    to otherwise difficult-to-reach information, allowing our applications to configure
    and behave more suitably depending on the operating system's state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Windows Management Instrumentation 及其变体 MI 提供了对其他难以触及的信息的访问，允许我们的应用程序根据操作系统的状态进行配置和更合适的行为。
- en: Parallel programming
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行编程
- en: As you may remember, we've already talked about asynchronous programming, when
    we were dealing with the `async/await` keywords that appeared in .NET Framework
    4.5 as a solution to avoid performance bottlenecks and improve the overall responsiveness
    of our applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，我们已经讨论了异步编程，当时我们处理的是在 .NET Framework 4.5 中出现的 `async/await` 关键字，作为避免性能瓶颈和提高应用程序整体响应性的解决方案。
- en: 'Parallelism was present earlier, in version 4.0 of the framework, and it was
    programmatically related to the **Task Parallel Library** (**TPL**). But first,
    let''s define the concept of parallelism (at least according to Wikipedia):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程在框架的 4.0 版本中就已经存在，并且与 **任务并行库**（**TPL**）程序相关联。但首先，让我们定义一下并行性的概念（至少根据维基百科的定义）：
- en: '"Parallelism is a form of computation in which several operations can execute
    simultaneously. It''s based on the ''Divide and Conquer'' principle, fragmenting
    a task in smaller tasks, which are later solved in parallel."'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 并行计算是一种可以在同时执行多个操作的计算形式。它基于“分而治之”的原则，将任务分解成更小的任务，这些小任务随后并行解决。
- en: 'This is, obviously related to hardware, and we should be aware of the difference
    between multiple processors and multiple cores. As Rodney Ringler says in his
    excellent book *C# Multithreading and Parallel Programming* by *Packt Publishing*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然与硬件相关，我们应该意识到多处理器和多核心之间的区别。正如 Rodney Ringler 在他的优秀书籍《Packt Publishing》出版的
    *C# Multithreading and Parallel Programming* 中所说：
- en: '"A multiple core CPU has more than one physical processing unit. In essence,
    it acts like more than one CPU. The only difference is that all cores of a single
    CPU share the same memory cache instead of having their own memory cache. From
    the multithreaded parallel developer standpoint, there is very little difference
    between multiple CPUs and multiple cores in a CPU. The total number of cores across
    all of the CPUs of a system is the number of physical processing units that can
    be scheduled and run in parallel, that is, the number of different software threads
    that can truly execute in parallel."'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “多核CPU具有多个物理处理单元。本质上，它就像多个CPU一样工作。唯一的区别是，单个CPU的所有核心共享相同的内存缓存，而不是各自拥有自己的内存缓存。从多线程并行开发者的角度来看，多个CPU和CPU中的多个核心之间几乎没有区别。整个系统中CPU的核心总数是可以在并行调度和运行中的物理处理单元的数量，即真正可以并行执行的软件线程的数量。”
- en: 'Several types of parallelism can be distinguished: at bit level, at instruction
    level, data parallelism, and task parallelism. And this is at the software level.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可以区分几种并行类型：在位级别、指令级别、数据并行和任务并行。这是在软件层面。
- en: There's another type of parallelism, at the hardware level, in which distinct
    architectures can be implied, offering distinct solutions depending on the problem
    to be solved (there's a particularly exhaustive explanation published by Lawrence
    Livermore National Laboratory if you're interested in this topic, *Introduction
    to Parallel Computing* at [https://computing.llnl.gov/tutorials/parallel_comp/](https://computing.llnl.gov/tutorials/parallel_comp/).
    We'll stick to the software level, of course.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种在硬件层面的并行性，其中可以暗示不同的架构，根据要解决的问题提供不同的解决方案（如果你对这个主题感兴趣，劳伦斯利弗莫尔国家实验室发布了一个特别详尽的解释，*并行计算简介*，可在[https://computing.llnl.gov/tutorials/parallel_comp/](https://computing.llnl.gov/tutorials/parallel_comp/)找到。当然，我们将坚持软件层面）。
- en: Parallelism can be applied in many different areas of computing, such as the
    Monte-Carlo Algorithm, Combinational Logic, Graph Traversal and Modeling, Dynamic
    Programming, Branch and Bound methods, Finite-state Machines, and so on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性可以应用于计算的不同领域，例如蒙特卡洛算法、组合逻辑、图遍历和建模、动态规划、分支和界限方法、有限状态机等等。
- en: 'From a more practical perspective, this translates into solving problems related
    to a wide variety of areas in science and engineering: astronomy, weather, rush
    hour traffic, plate tectonics, civil engineering, finance, geophysics, information
    services, electronics, biology, consulting, and, in a more everyday approach,
    any process that takes certain time and that can be improved thanks to these techniques
    (downloading data, I/O operations, expensive queries, and so on).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从更实际的角度来看，这转化为解决与科学和工程广泛领域的相关问题：天文学、气象、高峰时段交通、板块构造、土木工程、金融、地球物理学、信息服务、电子学、生物学、咨询，以及在日常生活中的任何需要一定时间且可以通过这些技术改进的过程（如下载数据、I/O操作、昂贵的查询等等）。
- en: 'The process followed in computing in parallel is explained in the previously
    mentioned source in four steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 并行计算中遵循的过程在前面提到的源中用四个步骤进行了说明：
- en: A problem is broken into discrete parts that can be solved concurrently.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将问题分解成可以同时解决的离散部分。
- en: Each part is further broken down into a series of instructions.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一部分都被进一步分解成一系列指令。
- en: Instructions from each part execute on different processors simultaneously.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个部分的指令在不同的处理器上同时执行。
- en: An overall control/coordination mechanism is employed.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用了一种整体的控制/协调机制。
- en: 'Note that the computational problem has to be of a nature such that:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计算问题必须具有以下性质：
- en: It can be broken into discrete fragments of work that can later be solved simultaneously
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以分解成可以后来同时解决的工作的离散片段。
- en: It has to be possible to execute several instructions at any moment in time
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时刻都必须能够执行多个指令
- en: It should be solved in less time using multiple resources or the computer than
    would be with a single resource
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用多个资源或计算机在更短的时间内解决，而不是使用单个资源。
- en: 'The resulting architecture can be explained in a graphic schema, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的架构可以用以下图形方案来解释：
- en: '![Parallel programming](img/image00688.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![并行编程](img/image00688.jpeg)'
- en: Difference between multithreading and parallel programming
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程与并行编程之间的区别
- en: 'It''s also important to remember the difference between multithreading and
    parallel programming. When we create a new thread in a given process (review the
    discussion about this in the first chapter if you need more references), that
    thread is scheduled by the operating system, which associates it with some CPU
    time. The thread executes the code in an asynchronous manner: that is, it goes
    its way until it finishes, a moment in which it should be synchronized with the
    main thread in order to obtain the results (we''ve also talked about updating
    main threads earlier).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还重要的是要记住多线程和并行编程之间的区别。当我们在一个给定的进程中创建一个新的线程（如果你需要更多参考资料，请回顾第一章中的讨论），该线程由操作系统调度，并与一些CPU时间相关联。线程以异步方式执行代码：也就是说，它继续执行直到完成，此时它应该与主线程同步，以获得结果（我们之前也讨论过更新主线程）。
- en: However, at the same time, there are other applications in execution in our
    computer (think of services, among other things). And these applications are also
    given their corresponding CPU time; so, if our application uses more than one
    thread, it's also given more CPU time, and the results are obtained more rapidly
    without blocking the UI thread.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与此同时，在我们的计算机中还有其他正在执行的应用（比如服务之类的）。这些应用也分配了相应的CPU时间；因此，如果我们的应用使用了多个线程，它也会得到更多的CPU时间，从而更快地获得结果，而不会阻塞UI线程。
- en: Moreover, if all this is executed in one core, we're not talking about parallel
    programming. We can't talk about parallel programming if we don't have more than
    one core.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果所有这些都在一个核心上执行，那么我们就不在谈论并行编程。如果没有超过一个核心，我们就不能谈论并行编程。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A typical mistake that we see is when a program executes in a virtual machine,
    and the code uses parallel approaches because in a virtual machine we only use
    one core by default. You have to configure the VM to work with more than one core
    in order to take advantage of parallelism.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常见的一个错误是当程序在虚拟机上执行时，代码使用了并行方法，因为在虚拟机上我们默认只使用一个核心。你必须配置虚拟机以使用超过一个核心，才能利用并行性。
- en: 'Also, from the everyday programmer point of view, you can mainly divide the
    types of tasks subject to parallel programming into two principal areas: those
    that are CPU-bound and those that are I/O bound (we can also add another two,
    Memory Bound, the amount of memory available is limited with respect to a process,
    and Cache Bound, which happens when the process is limited by the amount and the
    speed of the available cache. Think of a task that processes more data than the
    cache space it has available).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从日常程序员的视角来看，你可以主要将受并行编程影响的任务类型分为两大类：那些CPU密集型的和那些I/O密集型的（我们还可以增加另外两种，内存密集型，即相对于一个进程，可用的内存量是有限的，以及缓存密集型，这发生在进程受可用缓存的数量和速度限制时。想想一个处理比可用缓存空间更多的数据的任务）。
- en: In the first case, we're dealing with code that would run faster if the CPU
    were faster, which is the case where the CPU spends the majority of time using
    the CPU cores (complex calculations being a typical example).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们处理的是如果CPU更快，代码就会运行得更快的情况，这是CPU大部分时间都在使用CPU核心的情况（复杂计算是一个典型的例子）。
- en: 'The second scenario, (I/O-bound) happens when something would run faster if
    the I/O subsystem could also run faster. This case might happen in different scenarios:
    downloading something, accessing disk drives or network resources, and so on.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种场景（I/O密集型）发生在如果I/O子系统也能更快地运行，某些事情会运行得更快的情况下。这种情况可能发生在不同的场景中：下载某些内容、访问磁盘驱动器或网络资源等。
- en: 'The first two cases are the most common, and this is where TPL comes into play.
    Task Parallel Library appeared as a solution to implement parallel coding in our
    applications linked to the first two scenarios: CPU-bound and I/O-bound.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种情况是最常见的，这也是TPL（任务并行库）发挥作用的地方。任务并行库作为解决方案出现，用于在我们的应用程序中实现与第一种和第二种场景（CPU密集型和I/O密集型）相关的并行编码。
- en: 'Programmatically, we can find it in three flavors: Parallel LINQ, the Parallel
    class, and the Task class. The first two are mainly used for CPU-bound processes,
    while the Task class is more suitable (always generally speaking) for I/O-bound
    scenarios.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度来看，我们可以找到三种形式：并行LINQ、Parallel类和Task类。前两者主要用于CPU密集型过程，而Task类更适合（通常来说）I/O密集型场景。
- en: We already saw the basics of working with the Task class, which also allows
    you to execute code asynchronously, and here, we'll see how it can also perform
    cancelations (with tokens), continuations, synchronization of contexts, and so
    on.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了与Task类一起工作的基础知识，它还允许你异步执行代码，在这里，我们将看到它如何执行取消（使用令牌）、继续、上下文同步等。
- en: So, let's review these three flavors to look at some typical solutions to coding
    problems in which these libraries have noticeable improvements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾这三种风味，看看一些典型的编码问题解决方案，在这些解决方案中，这些库有明显的改进。
- en: Parallel LINQ
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行LINQ
- en: As the name suggests, parallel LINQ is an extension of the previous LINQ capabilities
    provided in previous versions of .NET.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，并行LINQ是.NET先前版本中提供的先前LINQ功能的扩展。
- en: 'In the first solution (Parallel LINQ), Microsoft expert Stephen Toub explains
    the reasons for this approach in *Patterns Of Parallel Programming* (available
    at [https://www.microsoft.com/en-us/download/details.aspx?id=19222](https://www.microsoft.com/en-us/download/details.aspx?id=19222)):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个解决方案（并行LINQ）中，Microsoft专家Stephen Toub在*并行编程模式*（可在[https://www.microsoft.com/en-us/download/details.aspx?id=19222](https://www.microsoft.com/en-us/download/details.aspx?id=19222)找到）中解释了这种方法的理由：
- en: '"A significant majority of the work in many applications and algorithms is
    done through loop control constructs. Loops, after all, often enable the application
    to execute a set of instructions over and over, applying logic to discrete entities,
    whether those entities are integral values, such as in the case of a for loop,
    or sets of data, such as in the case of a for each loop.'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在许多应用和算法中，大部分工作是通过循环控制结构完成的。毕竟，循环通常使应用程序能够反复执行一系列指令，将逻辑应用于离散实体，无论这些实体是整数值，例如在for循环的情况下，还是数据集，例如在foreach循环的情况下。
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Many languages have built-in control constructs for these kinds of loops, Microsoft
    Visual C#® and Microsoft Visual Basic® being among them, the former with for and
    foreach keywords, and the latter with For and For Each keywords. For problems
    that may be considered delightfully parallel, the entities to be processed by
    individual iterations of the loops may execute concurrently: thus, we need a mechanism
    to enable such parallel processing."'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 许多语言都有内置的控制结构来处理这类循环，Microsoft Visual C#®和Microsoft Visual Basic®就是其中之一，前者使用for和foreach关键字，后者使用For和For
    Each关键字。对于可能被认为是令人愉快的并行问题，循环的每个迭代要处理的实体可以并发执行：因此，我们需要一个机制来启用这种并行处理。
- en: One of these mechanisms is the `AsParallel()` method, applicable to expressions
    that imply the resources we've seen in relation to LINQ and Generic collections.
    Let's explore this in detail in an example (in this case, the sample will be linked
    to CPU-bound code).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种机制是`AsParallel()`方法，适用于暗示LINQ和泛型集合相关资源的表达式。让我们通过一个示例详细探讨这一点（在这种情况下，示例将链接到CPU密集型代码）。
- en: Our demo will have a simple UI, and we're going to calculate prime numbers between
    1 and 3,000,000.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示将有一个简单的用户界面，我们将计算1到3,000,000之间的素数。
- en: 'I''ll start by creating the prime calculation algorithm as an extension method
    of the `int` type, with the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先创建一个素数计算算法，作为`int`类型的扩展方法，以下是其代码：
- en: '[PRE9]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we''ll use three buttons to compare different behaviors: without parallelism,
    with parallelism, and with parallelism using ordered results.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用三个按钮来比较不同的行为：无并行处理、有并行处理，以及使用有序结果的并行处理。
- en: 'Previously, we defined some basic values:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们定义了一些基本值：
- en: '[PRE10]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The two important elements here are `Stopwatch`, to measure the time elapsed,
    and the initial collection of numbers, which we are going to generate using the
    static `Range` method of the `Enumerable` class, from 1 to 3,000,000.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个重要元素是`Stopwatch`，用于测量经过的时间，以及初始的数字集合，我们将使用`Enumerable`类的静态`Range`方法生成这些数字，从1到3,000,000。
- en: 'The code in the first button is pretty straightforward:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮中的代码相当简单：
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But, in the second button, we're including the `AsParallel` construct we mentioned
    earlier. It's quite similar to the previous one, but we indicate that before getting
    any results, we want the `numbers` collection to be treated in parallel.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在第二个按钮中，我们包括了之前提到的`AsParallel`结构。它与上一个类似，但我们指出，在获取任何结果之前，我们希望`numbers`集合以并行方式处理。
- en: When you execute the sample (the elapsed time values will vary slightly depending
    on the machine you're using), this second method is considerably faster than the
    previous one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行示例（经过的时间值将根据你使用的机器略有不同）时，这种方法比前一种方法快得多。
- en: This means that the code has used all cores available in the machine to perform
    the task (the `where` method next to `AsParallel`).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着代码已经使用了机器上可用的所有核心来执行任务（紧挨着`AsParallel`的`where`方法）。
- en: 'You have a way to prove this immediately: just open the Task Manager and select
    the **Performance** tab. In there (if you''re using Windows 10 like me), you have
    to open **Resource Monitor** to view the activities of all the CPUs present in
    your machine.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一种方法可以立即证明这一点：只需打开任务管理器并选择**性能**选项卡。在那里（如果你像我一样使用Windows 10），你必须打开**资源监视器**来查看你机器上所有CPU的活动。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Just to make sure you only watch the activity related to this demo, observe
    that you can select the output process to view the list of processes (in this
    case, it will be **DEMOLINQ1.vshost.exe**).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你只关注与此演示相关的活动，请注意你可以选择输出进程来查看进程列表（在这种情况下，它将是**DEMOLINQ1.vshost.exe**）。
- en: 'At runtime, the difference becomes evident: in the first event handler, only
    one CPU appears to be working. If you do this with the parallel method, you''ll
    see that there is an activity (probably in all CPUs if it''s not configured in
    some other way).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，差异变得明显：在第一个事件处理器中，似乎只有一个CPU在工作。如果你使用并行方法做这件事，你会看到有活动（如果不是以某种其他方式配置，可能是在所有CPU上）。
- en: 'This happens with the third option as well, (more about it soon), which uses
    the `AsOrdered()` clause. In my box (with eight cores), the resulting window shows
    the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选项也是如此，(关于它的更多内容很快就会介绍)，它使用了`AsOrdered()`子句。在我的机器（八个核心）上，结果窗口显示以下输出：
- en: '![Parallel LINQ](img/image00689.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![并行LINQ](img/image00689.jpeg)'
- en: So, we're really using parallelism, with a very simple addition to our code!
    The difference in the results becomes evident (as an average, it's about one-third
    of the time with respect to the synchronous option).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实际上是在使用并行性，只是在我们的代码中添加了一个非常简单的功能！结果之间的差异变得明显（作为一个平均值，它大约是同步选项的三分之一）。
- en: But we still have a problem. If you take a look at the output of the second
    Listbox control, at some point, you'll see that the list is not ordered, as it
    happened in the first case. This is normal, since we're using several cores to
    run the results and the code adds these results in the order in which they are
    received from the eight cores (in my case).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然有问题。如果你查看第二个Listbox控制器的输出，在某个时候，你会看到列表没有排序，就像第一种情况一样。这是正常的，因为我们正在使用多个核心来运行结果，并且代码按照从八个核心接收到的顺序添加这些结果（在我的情况下）。
- en: This order will vary depending on the number of cores, the speed, and other
    factors difficult to foresee. So, if we really need the results ordered, just
    as in the first case, we can use the `AsOrdered()` method, applied right next
    to the `AsParallel()` indication.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此顺序将根据核心数量、速度和其他难以预见因素而变化。因此，如果我们确实需要按顺序排列的结果，就像第一种情况一样，我们可以使用紧挨着`AsParallel()`指示的`AsOrdered()`方法。
- en: In this way, the resulting code is fairly the same as in the second method,
    but the results are ordered now, just with a (usually negligible) delay.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，生成的代码与第二种方法几乎相同，但现在结果是排序的，只是有一个（通常可以忽略不计）的延迟。
- en: 'In the next screenshot, I''m moving to prime number **18973** just to show
    the different way in which Listboxes were filled:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张屏幕截图中，我正在将数字移动到**18973**这个质数，只是为了展示Listboxes填充的不同方式：
- en: '![Parallel LINQ](img/image00690.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![并行LINQ](img/image00690.jpeg)'
- en: If there are no other processes consuming CPU, successive executions of these
    methods will offer slightly different results, but the variations will be minimal
    (actually, sometimes, you'll see that the `AsOrdered()` method appears to run
    faster than the non ordered one, but that's only because of the CPU activity).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他进程消耗CPU，这些方法的连续执行将提供略微不同的结果，但变化将是微小的（实际上，有时你会看到`AsOrdered()`方法似乎比非排序的运行得更快，但这只是因为CPU活动）。
- en: In general, if you need to really evaluate the execution time, you should perform
    the benchmarks several times and vary some of the initial conditions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你需要真正评估执行时间，你应该多次进行基准测试并改变一些初始条件。
- en: Dealing with other issues
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理其他问题
- en: Dealing with other issues appears to be an excellent way to use all the resources
    available in our machine, but other considerations may lead us to modify this
    code. For example, if our application should behave correctly under stress conditions,
    or we should respect the possible execution of other applications and the process
    to parallelize is much heavier than this one, it could be wise to use a feature
    called Parallelization Degree.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 处理其他问题似乎是一种使用我们机器上所有可用资源的极好方式，但其他考虑可能使我们修改此代码。例如，如果我们的应用程序应在压力条件下正确运行，或者我们应该尊重其他应用程序的可能执行，并且要并行化的进程比这个重得多，那么使用称为并行化程度的特性可能很明智。
- en: With this feature, we can establish the number of cores to use in our application
    by code, leaving the rest for other machines' applications and services.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此特性，我们可以通过代码设置应用程序中要使用的核心数，其余的留给其他机器的应用程序和服务。
- en: We can use this code to include this feature in another button, which will use
    only a limited number of cores this time. But how do we determine the number of
    cores? A reasonable solution would be to use only half of the cores available
    in the system, leaving the other half free.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此代码在另一个按钮中包含此功能，这次将只使用有限数量的核心。但我们是如何确定核心数的呢？一个合理的解决方案是只使用系统可用的核心数的一半，另一半保持空闲。
- en: 'Fortunately, there''s an easy way to find out this number (no need to use Platform/Invoke,
    Registry values, or WMI): the `Environment` class has static properties that allow
    simple access to certain useful values directly: in this case, the `ProcessorCount`
    property returns the number of cores. So we can write the following (I''m showing
    only the modified line):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种简单的方法可以找到这个数字（无需使用平台/调用、注册表值或WMI）：`Environment`类具有静态属性，允许直接访问某些有用的值：在这种情况下，`ProcessorCount`属性返回核心数。因此，我们可以编写以下代码（这里只显示修改后的行）：
- en: '[PRE12]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, in my machine, I''ll be using only four cores, which should show
    a gain in the performance although not as much as when using all cores (I''ve
    changed the numbers collection to 5,000.000 in order to better appreciate these
    values. Refer to the screenshot):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在我的机器上，我将只使用四个核心，这应该会显示出性能的提升，尽管不如使用所有核心时那么明显（我已经将数字集合改为5,000.000，以便更好地欣赏这些值。请参考截图）：
- en: '![Dealing with other issues](img/image00691.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![处理其他问题](img/image00691.jpeg)'
- en: Canceling execution
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消执行
- en: Another case that we should consider in our code in when the user, for whatever
    reason, wants to have the ability to cancel the process at a given moment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们还应该考虑另一种情况，即用户出于任何原因希望在某个时刻取消进程。
- en: The solution for this, as mentioned earlier in this section, is the cancellation
    feature. It is performed using `token`, which you pass to the process in its definition,
    and can be later used to force the cancelation (and the subsequent detention of
    the process).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，此问题的解决方案是取消功能。它使用`token`执行，你在其定义中将它传递给进程，并且可以稍后用于强制取消（以及随后进程的终止）。
- en: 'For code brevity, we''ll use a trick: extend again the `int` type so that it
    admits this token feature. We can write simple extension code, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了代码简洁，我们将使用一个技巧：再次扩展`int`类型，使其接受此令牌功能。我们可以编写简单的扩展代码，如下所示：
- en: '[PRE13]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we now have an overload of `IsPrime`, which calls the basic
    implementation only while `n` is distinct to `1000`. As we reach the thousandth
    integer, the Cancel method of the `CancellationTokenSource` instance is called.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们现在有一个`IsPrime`的重载，它仅在`n`与`1000`不同时调用基本实现。当我们达到第1000个整数时，`CancellationTokenSource`实例的`Cancel`方法被调用。
- en: The behavior of this depends on the possible previous configuration values of
    this class. As shown in the next screenshot, several values allow us to manipulate
    and find out related information, such as whether it can be really canceled, whether
    the cancelation has been requested, and even a low-level value `WaitHandle`, which
    is signaled when the token is canceled.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为取决于此类可能的先前配置值。如图所示，几个值允许我们操作并获取相关信息，例如是否可以真正取消，是否已请求取消，甚至是一个低级值`WaitHandle`，当令牌被取消时发出信号。
- en: 'This `WaitHandle` property is another object that provides access to the native
    operating system handle for this thread and has properties and methods to release
    all resources held by the current `WaitHandle` property (the `Close` method) or
    to block the current thread until `WaitHandle` receives a signal:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `WaitHandle` 属性是另一个对象，它提供了对这个线程的本地操作系统句柄的访问权限，并具有属性和方法来释放当前 `WaitHandle`
    属性（`Close` 方法）所持有的所有资源，或者阻塞当前线程，直到 `WaitHandle` 接收到信号：
- en: '![Canceling execution](img/image00692.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![取消执行](img/image00692.jpeg)'
- en: 'Obviously, in this case, the process is a bit more complex, since we need to
    catch the exception launched by the token and act accordingly:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这种情况下，过程要复杂一些，因为我们需要捕获令牌抛出的异常并相应地处理：
- en: '[PRE14]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note the use of `WithCancellation(cs.Token)` inside the query and also that
    the entire process in embedded in a `using` structure in order to guarantee the
    release of resources after the process ends.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意查询中使用了 `WithCancellation(cs.Token)`，以及整个过程都嵌入在 `using` 结构中，以确保在过程结束后释放资源。
- en: 'Besides, instead of using another mechanism, we add a cancelation message to
    the corresponding Listbox control, indicating whether the token was really canceled.
    You can see this in the next screenshot (also, note that the time elapsed is considerably
    less than the rest of cases):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，而不是使用另一种机制，我们在相应的 Listbox 控件中添加了一个取消消息，指示令牌是否真的被取消。您可以在下一张截图（注意，所花费的时间明显少于其他情况）中看到这一点：
- en: '![Canceling execution](img/image00693.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![取消执行](img/image00693.jpeg)'
- en: Nevertheless, there are some occasions in which the use of parallelism in this
    form might not be recommendable or is limited, such as when using operators, such
    as `Take` or `SkipWhile`, and also for the indexed versions of `Select` or `ElementAt`.
    In other circumstances, the overhead generated might be big, such as when using
    `Join`, `Union`, or `GroupBy`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，使用这种形式的并行可能不推荐或有限制，例如使用 `Take` 或 `SkipWhile` 等操作符，以及 `Select` 或 `ElementAt`
    的索引版本。在其他情况下，产生的开销可能很大，例如使用 `Join`、`Union` 或 `GroupBy`。
- en: The Parallel class
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行类
- en: The Parallel class is optimized for iterations and its behavior is even better—in
    loops—than PLINQ, although the difference is not meaningful. However, there are
    situations in which a fine-tuning of loops can noticeably increase the user experience.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 并行类针对迭代进行了优化，其行为甚至比 PLINQ 更好——尤其是在循环中——尽管这种差异并不明显。然而，在某些情况下，对循环的微调可以显著提高用户体验。
- en: The class has variants of the `for` and `foreach` methods (also `invoke`, but
    it is rare to see this in practice), which can be used in loops when we think
    the performance can be clearly slowed down using the nonparallel versions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有 `for` 和 `foreach` 方法的变体（也 `invoke`，但在实践中很少看到），当我们认为使用非并行版本可能会明显降低性能时，可以在循环中使用。
- en: If we take a look at the definition of the `Parallel.For` version, we'll see
    that it receives a couple of numbers (`int` or `long`) to define the scope of
    the loop and an `Action`, which relates to the functionality to be executed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `Parallel.For` 版本的定义，我们会看到它接收一对数字（`int` 或 `long`）来定义循环的范围，以及一个 `Action`，它关联到要执行的功能。
- en: Let's test this with a example that is similar, but not exact, to the previous
    one. We'll use the same `IsPrime` algorithm, but this time, we'll write the results
    checking one by one inside a `for` loop. So, we start with a simple loop that
    checks the first 1000 numbers and loads the result in RichTextbox.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个与之前类似但不完全相同的例子来测试这个方法。我们将使用相同的 `IsPrime` 算法，但这次，我们将在 `for` 循环中逐个检查结果。因此，我们从检查前
    1000 个数字的简单循环开始，并将结果加载到 RichTextbox 中。
- en: 'Our initial code for the nonparallel version will be as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的非并行版本的初始代码如下：
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The problem here is knowing how to transform the previous code into a `Parallel.For`.
    Now, the action to perform by the loop is indicated by a lambda expression that
    is in charge of checking each value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是知道如何将之前的代码转换为 `Parallel.For`。现在，循环要执行的操作由一个 lambda 表达式指示，该表达式负责检查每个值。
- en: However, we find an extra problem. Since this is parallel and new threads will
    be created, we can't update the user interface directly, or we will get `InvalidOperationException`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们发现了一个额外的问题。由于这是并行操作，并且将创建新的线程，我们无法直接更新用户界面，否则会得到 `InvalidOperationException`。
- en: There are several solutions for this, but one of most used solutions is in the
    `SynchronizationContext` object. As Joydip Kanjilal states in *Learning Synchronization
    Context, async, and await* (refer to [http://www.infoworld.com/article/2960463/application-development/my-two-cents-on-synchronizationcontext-async-and-await.html](http://www.infoworld.com/article/2960463/application-development/my-two-cents-on-synchronizationcontext-async-and-await.html)),
    The `SynchronizationContext` object represents an abstraction it denotes the location
    where your application's code is executed and enables you to queue a task onto
    another context (every thread can have its own `SynchronizatonContext` object).
    The `SynchronizationContext` object was added to the `System.Threading` namespace
    to facilitate communication between threads.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，有几种解决方案，但最常用的解决方案之一是在 `SynchronizationContext` 对象中。正如 Joydip Kanjilal
    在 *学习同步上下文、async 和 await*（参考 [http://www.infoworld.com/article/2960463/application-development/my-two-cents-on-synchronizationcontext-async-and-await.html](http://www.infoworld.com/article/2960463/application-development/my-two-cents-on-synchronizationcontext-async-and-await.html)）中所说的，`SynchronizationContext`
    对象代表了一个抽象，它表示应用程序代码执行的位置，并允许您将任务排队到另一个上下文（每个线程都可以有自己的 `SynchronizatonContext`
    对象）。`SynchronizationContext` 对象被添加到 `System.Threading` 命名空间中，以促进线程之间的通信。
- en: 'The resulting code for our Parallel. For that will look like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 Parallel.For 的结果代码将看起来像这样：
- en: '[PRE16]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this approach, we send a synchronization order from the thread in execution
    (whichever it is) to the main thread (the UI Thread). To do this, we first cache
    the `SynchronizationContext` object of the current thread at definition time,
    and later, we use it to call the `Post` method on the context which will invoke
    a new action to update the user interface.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们从正在执行线程（无论哪个）发送一个同步命令到主线程（UI 线程）。为此，我们在定义时首先缓存当前线程的 `SynchronizationContext`
    对象，然后稍后使用它来在上下文中调用 `Post` 方法，这将调用一个新动作来更新用户界面。
- en: Note that this solution is coded in this way to show that `Parallel.For` can
    also be used in processes that (one at a time) manipulate the user interface.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个解决方案是这样编写的，以表明 `Parallel.For` 也可以用于（一次一个）操作用户界面的过程中。
- en: 'We can appreciate the difference between both approaches calculating the same
    primes, as shown in the next screenshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过下一个截图所示的相同素数的计算来欣赏两种方法之间的差异：
- en: '![The Parallel class](img/image00694.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Parallel 类](img/image00694.jpeg)'
- en: The Parallel.ForEach version
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Parallel.ForEach 版本
- en: Another variant of the same idea is `Parallel.ForEach`. It's practically the
    same except that we don't have a starting or ending number in the definition.
    It's better to use a sequence of information and a unique variable that we'll
    use to iterate over each element of the sequence.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 同样想法的另一个变体是 `Parallel.ForEach`。实际上它与它几乎相同，只是我们在定义中没有起始或结束数字。使用信息序列和唯一变量来迭代序列的每个元素会更好。
- en: However, I'm going to change the type of process for this demo so that you can
    compare and get your own conclusions. I will go through a list of small `.png`
    files (icons128 x 128), and I'll create a new version of these icons (transparent),
    saving the new modified icon in another directory.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我将改变这个演示中处理过程的类型，以便您可以进行比较并得出自己的结论。我将遍历一系列小的 `.png` 文件（图标128 x 128），并为这些图标创建一个新的版本（透明），将修改后的新图标保存在另一个目录中。
- en: We're using an IO-bound process in this case. The slow method will be linked
    to the disk drive, not to the CPU. Other possible IO-bound processes you could
    try include downloading files or images from a website or blog posts from any
    social network.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用的是 I/O 密集型过程。慢速方法将链接到磁盘驱动器，而不是 CPU。您可以尝试的其他可能的 I/O 密集型过程包括从网站或任何社交网络下载文件或博客文章。
- en: 'Since the most important thing here is time gain, we''ll process the files
    one after the other and compare the resulting elapsed times, showing the output
    in a window. I''ll use a button to launch the process with the following code
    (please, note that `Directory.GetFiles` should point to a directory of your own
    where some `.png` files are present):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里最重要的目标是节省时间，我们将依次处理文件并比较所花费的时间，将在窗口中显示输出。我将使用一个按钮来启动以下代码所示的过程（请注意，`Directory.GetFiles`
    应指向一个包含一些 `.png` 文件的目录）：
- en: '[PRE17]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, there are two loops. The second one also uses a `file` variable
    to iterate over the collection of files retrieved by the `Directory.GetFiles()`
    call, but the second argument of the `Parallel.ForEach` loop is a lambda expression,
    containing exactly the same code as the first `foreach` method (well, with the
    slight difference that I'm appending a `T_` prefix to the name before saving it).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有两个循环。第二个循环也使用一个 `file` 变量来遍历 `Directory.GetFiles()` 调用检索到的文件集合，但 `Parallel.ForEach`
    循环的第二个参数是一个 lambda 表达式，包含与第一个 `foreach` 方法完全相同的代码（好吧，有一点细微的区别，那就是我在保存之前将 `T_`
    前缀附加到名称上）。
- en: However, the difference in the processing time is meaningful, even in this case
    where just a handful of files were available (around a hundred).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在只有少量文件可用的情况下（大约一百个），处理时间的差异也是有意义的。
- en: 'You can see the difference in the next screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下一张截图中看到差异：
- en: '![The Parallel.ForEach version](img/image00695.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Parallel.ForEach 版本](img/image00695.jpeg)'
- en: So, in both samples, either CPU- or IO-bound, the gain is important, and other
    considerations apart (there's always some), we have a nice solution here, with
    these two options for parallelism (Remember that you should change the program's
    entry point, depending on the demo to execute, in the `Program.cs` file).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这两个示例中，无论是 CPU 密集型还是 IO 密集型，这种提升都是重要的，而且除了其他考虑因素之外（总是有一些），我们在这里有一个很好的解决方案，提供了这两种并行选项（记住，您应该根据要执行的演示更改程序入口点，在
    `Program.cs` 文件中）。
- en: Task Parallel
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务并行
- en: While all this is important, there are cases where this solution lacks enough
    flexibility, and that's why we include **Task Parallel Library** in the set of
    the software tools available.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些都很重要，但有些情况下这种解决方案缺乏足够的灵活性，这就是为什么我们将 **任务并行库** 包含在可用的软件工具集中。
- en: We've seen the basics of the `Task` object in [Chapter 3](part0023.xhtml#aid-LTSU2
    "Chapter 3. Advanced Concepts of C# and .NET"), *Advanced Concepts of C# and .NET*,
    and [Chapter 12](part0078.xhtml#aid-2ACBS2 "Chapter 12. Performance"), *Performance*,
    but now it's time to look at some more advanced aspects that make this object
    one of the most interesting in .NET Framework regarding parallel programming.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 3 章](part0023.xhtml#aid-LTSU2 "第 3 章。C# 和 .NET 的高级概念")，*C# 和 .NET 的高级概念*
    和 [第 12 章](part0078.xhtml#aid-2ACBS2 "第 12 章。性能")，*性能* 中看到了 `Task` 对象的基础，但现在我们需要看看一些更高级的方面，这些方面使这个对象成为
    .NET Framework 中并行编程中最有趣的对象之一。
- en: Communication between threads
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程间的通信
- en: As you know, the results obtained after task completions can be of any type
    (Generics included).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，任务完成后获得的结果可以是任何类型（包括泛型）。
- en: When you create a new `Task<T>` object, you inherit several methods and properties
    to facilitate data manipulation and retrieval. For example, you have properties
    such as `Id`, `IsCancelled`, `IsCompleted`, `IsFaulted`, and `Status` to determine
    the state of the task and a `Result` property, which contains the returning value
    of the task.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个新的 `Task<T>` 对象时，您继承了一些方法和属性，以方便数据操作和检索。例如，您有 `Id`、`IsCancelled`、`IsCompleted`、`IsFaulted`
    和 `Status` 等属性来确定任务的状态，以及一个 `Result` 属性，它包含任务的返回值。
- en: As for the methods available, you have a `Wait` method to force the `Task` object
    to wait until completion, and another very useful method called `ContinueWith`.
    With this method, you can code what to do when the task is finished, knowing that
    the results are obtainable from the `Result` property.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可用的方法，您有一个 `Wait` 方法来强制 `Task` 对象等待直到完成，还有一个非常有用的方法叫做 `ContinueWith`。使用这个方法，您可以在知道可以从
    `Result` 属性获取结果的情况下，编写任务完成时要执行的操作。
- en: So, let's imagine a situation like we did in the earlier demo about reading
    and manipulating files in a directory – only this time, we're just reading the
    names and using a `Task` object.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们想象一个类似于我们在早期演示中关于在目录中读取和操作文件的情况——只是这次，我们只是读取名称并使用一个 `Task` 对象。
- en: 'With all this functionality, we might think that the following code should
    work correctly:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些功能的基础上，我们可能会认为以下代码应该可以正确工作：
- en: '[PRE18]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we create a new `Task<List<string>>` object instance; so, we
    can take advantage of its functionality and invoke `ContinueWith` to update the
    user interface with the results.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个新的 `Task<List<string>>` 对象实例；因此，我们可以利用其功能并调用 `ContinueWith` 来更新用户界面并显示结果。
- en: 'However, we get `InvalidOperationException` in the `UpdateUI` method because
    it''s still the Task (another thread) that is trying to access a different thread.
    And it does not matter that the results have been obtained correctly, as you can
    see in this screenshot, showing the value of `Result`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在`UpdateUI`方法中得到了`InvalidOperationException`，因为它仍然是任务（另一个线程）试图访问不同的线程。尽管你可以从下面的截图看到结果已经被正确获得，但这并不重要：
- en: '![Communication between threads](img/image00696.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![线程间通信](img/image00696.jpeg)'
- en: Fortunately, we have a solution linked to the `TaskScheduler` object, which
    is part of this set of tools. We just have to pass another argument to the `ContinueWith`
    method, indicating the `FromCurrentSynchronizationContext` property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一个与`TaskScheduler`对象相关的解决方案，它是这个工具集的一部分。我们只需要将另一个参数传递给`ContinueWith`方法，指明`FromCurrentSynchronizationContext`属性。
- en: 'So, we''ll modify the previous call as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将之前的调用修改如下：
- en: '[PRE19]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now everything works perfectly, as you can see in the final screenshot of the
    execution:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切工作得非常完美，正如你在执行的最后一张截图中所看到的：
- en: '![Communication between threads](img/image00697.jpeg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![线程间通信](img/image00697.jpeg)'
- en: And there it is! A very simple form of updating the user interface from a task
    without needing complex constructions or other specific objects.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这是一种非常简单的从任务更新用户界面的形式，而不需要复杂的构造或其他特定对象。
- en: 'Also, note that this method has up to 40 overloads in order to allow us the
    behavior configuration in many different ways:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这个方法有高达40个重载，以便我们以许多不同的方式配置行为：
- en: '![Communication between threads](img/image00698.jpeg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![线程间通信](img/image00698.jpeg)'
- en: 'Other interesting possibilities linked to the `Task` object are related to
    some of its static methods, especially `WaitAll`, `WaitAny`, `WhenAll`, and `WhenAny`.
    Let''s look at what they do:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Task`对象相关的其他有趣的可能性与它的一些静态方法有关，特别是`WaitAll`、`WaitAny`、`WhenAll`和`WhenAny`。让我们看看它们的作用：
- en: '`WaitAll`: Waits for all the provided `Task` objects to complete the execution
    (it receives a collection of the `Task` objects)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAll`：等待所有提供的`Task`对象完成执行（它接收一个`Task`对象的集合）'
- en: '`WaitAny`: It has the same structure as `WaitAll`, but it waits for the first
    task to finish'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAny`：它与`WaitAll`具有相同的结构，但它等待第一个任务完成'
- en: '`WhenAll`: Creates a new task that executes only when all the provided tasks
    are completed'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WhenAll`：创建一个新的任务，只有当所有提供的任务都完成后才会执行'
- en: '`WhenAny`: The same structure as the earlier one, but it waits for the first
    task to finish'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WhenAny`：与之前相同的结构，但它等待第一个任务完成'
- en: 'And there''s still another interesting feature: `ContinueWhenAll`, which guarantees
    that something is done only when all tasks passed as arguments are finished.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 并且还有一个有趣的特性：`ContinueWhenAll`，它保证只有在所有作为参数传递的任务都完成后才会执行某些操作。
- en: 'Let''s take an example to see how this works. We have three algorithms for
    image manipulation: the three receive a `Bitmap` object and return another bitmap,
    transformed. You can read the algorithms in the demo code (they are named `BitmapInvertColors`,
    `MakeGrayscale`, and `CorrectGamma`).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看它是如何工作的。我们有三种图像处理算法：它们都接收一个`Bitmap`对象并返回另一个转换后的位图。你可以在演示代码中阅读这些算法（它们被命名为`BitmapInvertColors`、`MakeGrayscale`和`CorrectGamma`）。
- en: 'When the button is clicked on, four tasks are created: each one calling to
    a method in charge of transforming a bitmap and presenting the result in a different
    `pictureBox` control. And we use the previous `ContinueWith` method to update
    a label''s text in the user interface so that we know the order in which they
    execute.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，会创建四个任务：每个任务都调用负责转换位图并在不同的`pictureBox`控件中显示结果的函数。我们使用之前的`ContinueWith`方法来更新用户界面上的标签文本，以便我们知道它们的执行顺序。
- en: 'The code is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE20]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we want the `All finished` label to update the last one, we need a way to
    make sure that the fifth Task is executed as the latest in the sequence (of course,
    if we don't use a Task, it would be updated as the first).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让`All finished`标签更新最后一个任务，我们需要确保第五个任务作为序列中的最后一个执行（当然，如果我们不使用任务，它将作为第一个更新）。
- en: 'As you can see in the next screenshot, the order of the second, third, and
    fourth tasks will be random, but the first one (because it doesn''t do any heavy
    work; it only loads the original image) will always appear heading the sequence
    and the fifth one will appear the latest:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在下一张截图中所见，第二、第三和第四个任务的顺序将是随机的，但第一个（因为它不做任何重工作；它只加载原始图像）将始终出现在序列的开头，而第五个将出现在最后：
- en: '![Communication between threads](img/image00699.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![线程间的通信](img/image00699.jpeg)'
- en: There are other interesting features still, similar to the ones we saw earlier
    in the parallel demos in relation to cancellation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些有趣的功能，与我们在之前的并行演示中看到的取消功能类似。
- en: 'To cancel a task, we will use a similar procedure—only in this case, it is
    simpler. I''ll use a Console application to show it in a couple of simple methods:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消任务，我们将使用类似的程序——但在这个情况下，它更简单。我将使用控制台应用程序通过几个简单的方法来展示它：
- en: '[PRE21]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we generate a Task over a `DoALongWork` method, which includes
    a delay of a tenth of a second in a 100-iteration loop. However, in every iteration,
    we check the value of the `ThrowIfCancellationRequested` method, which belongs
    to the `CancellationTokenSource` method previously generated at task creation,
    and passes it to the slow method.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在一个100次迭代的循环中，对`DoALongWork`方法生成一个包含十分之一秒延迟的Task。然而，在每次迭代中，我们都会检查`ThrowIfCancellationRequested`方法的值，这个方法属于在任务创建时之前生成的`CancellationTokenSource`方法，并将其传递给慢速方法。
- en: After 500 milliseconds, `cs.Cancel()` is called in the main thread, thread execution
    stops, and `Exception` is launched and recovered on the `catch` side in order
    to present the output in the Console as a message, showing whether the cancellation
    was really requested.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在500毫秒后，在主线程中调用`cs.Cancel()`，线程执行停止，并在`catch`侧启动和恢复`Exception`，以便在控制台以消息的形式展示输出，显示是否真的请求了取消。
- en: 'The next screenshot shows what you should see when executing this code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了执行此代码时应看到的内容：
- en: '![Communication between threads](img/image00700.jpeg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![线程间的通信](img/image00700.jpeg)'
- en: Up until here, this was a review of Task Parallel Library and some of its most
    interesting possibilities.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这只是一个关于Task并行库及其一些最有趣可能性的回顾。
- en: 'We''ll move toward the end of this book by talking about the latest innovations
    in .NET now: the so-called NET Core 1.0, which is intended to execute on all platforms,
    including Linux and MacOS.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论这本书的结尾部分，现在关于.NET的最新创新：所谓的NET Core 1.0，它旨在在所有平台上执行，包括Linux和MacOS。
- en: .NET Core 1.0
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 1.0
- en: '.NET Core is a version of .NET Framework (first versions were released in the
    summer of 2016) that denotes a major breakthrough in the Microsoft Development
    Technologies ecosystem, the greatest promise being its ability to execute cross-platform:
    Windows, MacOS, and Linux.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 是 .NET Framework 的一个版本（最初版本于2016年夏季发布），标志着微软开发技术生态系统中的一次重大突破，其最大的承诺是能够跨平台执行：Windows、MacOS
    和 Linux。
- en: Besides, .NET Core is modular, open source, and cloud-ready. It can be deployed
    along with the application itself, minimizing installation issues.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，.NET Core 是模块化的、开源的，并且为云做好了准备。它可以与应用程序本身一起部署，最小化安装问题。
- en: 'Although the number was consecutive to previous versions initially, Microsoft
    decided to restart the numbering, reinforcing the idea that this is a totally
    new concept with respect to classical versions, as a better way to avoid ambiguities.
    For those who were already aware of the initial versions, let''s remember that
    the equivalence is as follows (refer to the screenshot):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初这个数字是连续的，但微软决定重新开始编号，强化了这样一个观点：这与经典版本相比是一个全新的概念，是一个更好的避免歧义的方法。对于那些已经了解初始版本的人来说，让我们记住以下等价关系（参考截图）：
- en: '![.NET Core 1.0](img/image00701.jpeg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![.NET Core 1.0](img/image00701.jpeg)'
- en: The screenshot shows the equivalence between the new names and how some technologies
    go beyond platforms and (as it happens in ASP.NET Core or MVC Core) can even execute
    over the classic platform (.NET Framework 4.6).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了新名称之间的等价性以及一些技术如何超越平台（正如在ASP.NET Core或MVC Core中发生的那样），甚至可以在经典平台（.NET Framework
    4.6）上执行。
- en: .NET Core is based on CoreCLR, which is a lightweight runtime, providing the
    basic services. This includes automatic memory management, garbage collection,
    and the basic type libraries.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 基于CoreCLR，这是一个轻量级的运行时环境，提供基本服务。这包括自动内存管理、垃圾回收以及基本类型库。
- en: .NET Core, as with many other projects now, is part of the .NET foundation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 与现在许多其他项目一样，.NET Core 是 .NET 基金会的一部分。
- en: It also includes CoreFx, which is a set of modular assemblies. These assemblies
    can be added to your project as per your demand (remember that in .NET 4.x, we
    always had to make the entire BCL available). Now, you select only the assemblies
    that you need.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括 CoreFx，这是一个模块化程序集的集合。根据你的需求，可以将这些程序集添加到你的项目中（记住，在.NET 4.x中，我们总是必须提供整个BCL）。现在，你只需选择你需要的程序集即可。
- en: The list of supported environments
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的环境列表
- en: 'According to C# Corner''s *.NET Core - Fork In The Road* ([http://www.c-sharpcorner.com/article/net-core-fork-in-the-road/](http://www.c-sharpcorner.com/article/net-core-fork-in-the-road/)),
    the following table explains availability for distinct platforms, although the
    list is continuously growing:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[C# Corner的*.NET Core - Fork In The Road*](http://www.c-sharpcorner.com/article/net-core-fork-in-the-road/)，以下表格解释了不同平台上的可用性，尽管列表仍在不断增长：
- en: '![The list of supported environments](img/image00702.jpeg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![支持的环境列表](img/image00702.jpeg)'
- en: Another target of .NET Core is to achieve project unification by means of a
    unique `project.json` file, in which all configuration features will appear independently
    of the type of project being built (no more `app.config`, `web.config`, and so
    on). However, in Visual Studio 2017, the dependencies declared in the `project.json`
    file have been moved to the `.sln` file for unification.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core的另一个目标是通过对一个独特的`project.json`文件进行项目统一，其中所有配置功能将独立于正在构建的项目类型出现（不再需要`app.config`、`web.config`等）。然而，在Visual
    Studio 2017中，`project.json`文件中声明的依赖项已经被移动到`.sln`文件中进行统一。
- en: .NET Core is supposed to be built on four parts, including Core FX, Core CLR,
    Core RT, and Core CLI. Let's take a quick look these parts, one by one.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core应该建立在四个部分之上，包括Core FX、Core CLR、Core RT和Core CLI。让我们逐一快速查看这些部分。
- en: Core FX
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Core FX
- en: 'Core FX contains the implementation of the foundational libraries, including
    the classic namespaces: `System.Collections`, `System.IO`, `System.Xml`, and so
    on. However, it doesn''t include the base types, which are part of `mscorlib`,
    in a different repo, `CoreCLR`.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Core FX包含基础库的实现，包括经典命名空间：`System.Collections`、`System.IO`、`System.Xml`等。然而，它不包括`mscorlib`中的基类型，这些类型位于不同的仓库`CoreCLR`中。
- en: You can access these repos in GitHub at [https://github.com/dotnet/corefx](https://github.com/dotnet/corefx).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上访问这些仓库：[https://github.com/dotnet/corefx](https://github.com/dotnet/corefx)。
- en: Core CLR
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Core CLR
- en: Core CLR is actually the .NET virtual machine (the runtime). It includes RyuJIT
    (or CLR JIT), which is a new generation 64-bit compiler, the .NET Garbage Collector,
    the `mscorlib.dll` previously mentioned, and a bunch of libraries.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Core CLR实际上是.NET虚拟机（运行时）。它包括RyuJIT（或CLR JIT），这是一个新一代64位编译器，.NET垃圾回收器，之前提到的`mscorlib.dll`以及一系列库。
- en: The repo is available at [https://github.com/dotnet/coreclr](https://github.com/dotnet/coreclr),
    and you'll also find all the related documentation there.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库可在[https://github.com/dotnet/coreclr](https://github.com/dotnet/coreclr)找到，你也会在那里找到所有相关文档。
- en: It is deployed along with your application (so no more `.NET Framework x.x version
    required` messages) and allows side-by-side execution; therefore, it guarantees
    the integrity of other existing applications.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 它与你的应用程序一起部署（因此不再需要`.NET Framework x.x版本`消息），并允许并行执行；因此，它保证了其他现有应用程序的完整性。
- en: Core RT
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Core RT
- en: Core RT is an alternative to Core CLR, optimized for **AoT** (**Ahead of Time**)
    scenarios. It's available at the repo at [https://github.com/dotnet/corert](https://github.com/dotnet/corert).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Core RT是Core CLR的替代品，针对**AoT**（**提前编译**）场景进行了优化。它可在[https://github.com/dotnet/corert](https://github.com/dotnet/corert)的仓库中找到。
- en: Obviously, you might be wondering about this term (AoT) and the difference with
    respect to the JIT compilation that we've been using.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可能想知道这个术语（AoT）以及与我们一直使用的JIT编译相比的区别。
- en: Let's remember that a JIT compiler is responsible for converting MSIL code into
    native code. And this is done at runtime; so, every time a method is called for
    the first time, it is compiled and executed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，JIT编译器负责将MSIL代码转换为原生代码。这是在运行时完成的；因此，每次第一次调用方法时，它都会被编译并执行。
- en: In this manner, the application can be executed in distinct CPUs and OSes with
    the runtime installed, but the caveat is that it's a process that takes time and
    has an impact on the application's performance.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，应用程序可以在安装了运行时的不同CPU和OS上执行，但缺点是这是一个耗时且会影响应用程序性能的过程。
- en: On the other hand, AoT compilers also compile MSIL to native code, but Wikipedia
    says that they do it, reducing the runtime overhead, into a native (system-dependent)
    machine code with the intention of executing the resulting binary file natively.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，AoT编译器也将MSIL编译成原生代码，但维基百科说，它们这样做是为了减少运行时开销，将结果二进制文件编译成原生（系统依赖）机器代码，目的是原生执行。
- en: 'Wikipedia also adds this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科还补充说：
- en: '"In most situations with fully AOT compiled programs and libraries it is possible
    to drop a considerable fraction of theruntime environment, thus saving disk space,
    memory, battery and startup times (no JIT warmup phase), etc. Because of this,
    it can be useful in embedded or mobile devices."'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在大多数情况下，对于完全 AOT 编译的程序和库，可以删除相当一部分运行时环境，从而节省磁盘空间、内存、电池和启动时间（没有 JIT 预热阶段）等。因此，它对于嵌入式或移动设备非常有用。”
- en: 'As RobJb points out in StackOverflow:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如 RobJb 在 StackOverflow 中指出：
- en: '"AOT compilers can also spend as much time optimizing as they like, whereas
    JIT compilation is bound by time requirements (to maintain responsiveness) and
    the resources of the client machine. For this reason, AOT compilers can perform
    a complex optimization that would be too costly during JIT."'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “AOT 编译器可以花费尽可能多的时间进行优化，而 JIT 编译受限于时间要求（以保持响应性）和客户端机器的资源。因此，AOT 编译器可以执行在 JIT
    中过于昂贵的复杂优化。”
- en: To summarize, the emphasis of CoreRT is on code optimization and conversion
    into a specific native platform. The generated executable will greater in size,
    but it contains the application, all its dependencies, plus the CoreRT.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，CoreRT 的重点是代码优化和转换为特定的本地平台。生成的可执行文件将更大，但它包含了应用程序、所有依赖项以及 CoreRT。
- en: Applications that use CoreRT execute faster and can use the proper optimizations
    of a native compiler, favoring better performance and code quality improvement.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CoreRT 的应用程序执行速度更快，并且可以使用本地编译器的适当优化，从而提高性能和代码质量。
- en: Core CLI
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Core CLI
- en: Core CLI is a command line interface, independent from other libraries, providing
    an easy way to install a basic framework where we can test .NET Core code on any
    platform in only a few steps.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Core CLI 是一个命令行界面，独立于其他库，提供了一种简单的方法来安装一个基本框架，我们可以在几步之内测试任何平台上的 .NET Core 代码。
- en: 'The installation is simple: files of types MSI in Windows, PKG in MacOS, or
    and `apt-get` in Linux; or they may even use a `curl` script.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 安装很简单：Windows 中的 MSI 类型文件、MacOS 中的 PKG 类型文件或 Linux 中的 `apt-get`；或者甚至可以使用 `curl`
    脚本。
- en: Besides, a re-platform of ASP.NET over .NET Core 1.0 has been created, as we'll
    see later. The project file will be a `.xproj` file, with no differences between
    flavors or languages.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，已经创建了一个基于 .NET Core 1.0 的 ASP.NET 重构，我们稍后会看到。项目文件将是一个 `.xproj` 文件，不同版本或语言之间没有差异。
- en: Once installed, you can emit commands such as `dotnetbuild`, for example, and
    generate the results and see the execution. One point to note is that the Core
    CLI itself is made using Core RT; so it uses optimized native technology as well.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以发出如 `dotnetbuild` 这样的命令，例如，并生成结果并查看执行情况。需要注意的是，Core CLI 本身是使用 Core
    RT 制作的；因此，它也使用了优化的本地技术。
- en: Installation of .NET Core
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 安装
- en: 'The .NET Core installation has changed since the first release candidates,
    and now the previous location at GitHub will lead us to the [https://www.microsoft.com/net/core](https://www.microsoft.com/net/core)
    site, where we''ll find instructions to download .NET Core in four different contexts:
    Windows, Linux, MacOS, and Docker.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 自从第一个候选版本发布以来，.NET Core 的安装已经发生了变化，现在之前的 GitHub 位置将引导我们到 [https://www.microsoft.com/net/core](https://www.microsoft.com/net/core)
    网站，在那里我们可以找到在四个不同环境中下载 .NET Core 的说明：Windows、Linux、MacOS 和 Docker。
- en: Note
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also, note that in order to work with .NET Core from Visual Studio 2015, you
    need to have Upgrade 3 installed. It will appear as an option under the **Extensions
    and Updates** in the **Updates** section.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，要从 Visual Studio 2015 中使用 .NET Core，你需要安装升级 3。它将出现在 **更新** 部分的 **扩展和更新**
    选项下。
- en: 'Besides this installation, you can use .NET Core inside Visual Studio 2015
    and higher versions if you additionally install NET Core 1.0.0 – VS 2015 Tooling,
    available at the same page. It takes a few minutes and asks for a confirmation
    (refer to the screenshot):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个安装之外，如果你额外安装了 NET Core 1.0.0 – VS 2015 Tooling，你可以在同一页面上使用 .NET Core 在 Visual
    Studio 2015 及更高版本中。这需要几分钟时间，并会要求确认（参考截图）：
- en: '![Installation of .NET Core](img/image00703.jpeg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![.NET Core 安装](img/image00703.jpeg)'
- en: Note that, at the time of writing this, the VS 2015 Tooling is available as
    a preview version and will probably be in its final version by the time you read
    this. Additionally, you can install the Core CLI from the same page mentioned
    earlier or go directly to the [https://github.com/dotnet/cli](https://github.com/dotnet/cli)
    page.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在撰写本文时，VS 2015 Tooling 以预览版的形式提供，你阅读本文时可能已经是最终版本。此外，你可以从前面提到的同一页面上安装 Core
    CLI，或者直接访问 [https://github.com/dotnet/cli](https://github.com/dotnet/cli) 页面。
- en: 'Once the installation is complete, if we go to Visual Studio and select **New
    Project**, we''ll see a new section called **NET Core**, offering three types
    of applications: Class Library, Console Application, and ASP.NET Core Web Application:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，如果我们打开 Visual Studio 并选择 **新建项目**，我们会看到一个名为 **NET Core** 的新部分，提供三种应用程序类型：类库、控制台应用程序和
    ASP.NET Core 网络应用程序：
- en: '![Installation of .NET Core](img/image00704.jpeg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![.NET Core 安装](img/image00704.jpeg)'
- en: As you can imagine, in the fist case, we can create a DLL to be used by other
    projects, and the two latest options are the ones that make sense (for the moment)
    with this initial version of .NET Core.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，在第一种情况下，我们可以创建一个 DLL 供其他项目使用，而最后两个选项（对于这个 .NET Core 的初始版本）是有意义的。
- en: If we take a look at the files created with the **Console Application** option,
    the Solution Explorer will show us a familiar structure with some differences,
    though.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看使用 **控制台应用程序** 选项创建的文件，解决方案资源管理器将显示一个熟悉的结构，尽管有一些不同。
- en: 'To start with, we see the presence of two main directories: one for the solution
    (which includes a `global.json` file) and another called `src`, where we find
    the rest of the assets of our application.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到存在两个主要目录：一个用于解决方案（包括一个 `global.json` 文件）和另一个名为 `src` 的目录，其中包含我们应用程序的其余资产。
- en: The `global.json` file contains the folders that should be searched at compile-time
    when resolving dependencies for projects. The build system will only search top-level
    child folders.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`global.json` 文件包含在编译时解决项目依赖项时应搜索的文件夹。构建系统将只搜索顶级子文件夹。'
- en: 'By default, the following content is included:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，以下内容被包含：
- en: '[PRE22]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This defines two projects in our solution: the standard one and another for
    testing. Besides this, the `sdk` key indicates the version to be used (`1.0.0-preview-003121`),
    and we can add or change that at will.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们解决方案中的两个项目：标准项目和另一个用于测试的项目。除此之外，`sdk` 键指示要使用的版本（`1.0.0-preview-003121`），我们可以随意添加或更改它。
- en: Note
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A very interesting aspect of the tooling in Visual Studio 2015, when dealing
    with `.json` files for configuration is that if we change any value, the corresponding
    reference will be searched online automatically and downloaded to our project.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015 工具的一个非常有趣的方面是处理配置文件 `.json` 时，如果我们更改任何值，相应的引用将会自动在线搜索并下载到我们的项目中。
- en: 'There are other options available, such as the architecture to be used (x64
    / x86) or the target runtime, as shown in the next screenshot:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他选项可用，例如要使用的架构（x64 / x86）或目标运行时，如下一张截图所示：
- en: '![Installation of .NET Core](img/image00705.jpeg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![.NET Core 安装](img/image00705.jpeg)'
- en: Within the `src` directory, the typical console structure can be found, only
    that all references included in the **References** section point to **Microsoft.NETCore.App
    (1.0.0)** and include a long list of components available, all of them in a hierarchical
    structure of dependencies.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 目录中，可以找到典型的控制台结构，只是所有包含在 **引用** 部分的引用都指向 **Microsoft.NETCore.App (1.0.0)**，并包含一个长列表的组件，所有这些组件都按照依赖关系的层次结构排列。
- en: The aspect of the main `Program.cs` file is just the usual in these projects
    (no changes), and this is true for `AssemblyInfo.cs` (although some values would
    be ignored on other platforms).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些项目中，主 `Program.cs` 文件的特点只是通常的（没有更改），对于 `AssemblyInfo.cs` 也是如此（尽管在其他平台上一些值会被忽略）。
- en: However, there's no `app.config` file. This file has been replaced with another
    `.json` file, `project.json`, which will be in charge of the definitions of the
    application's configuration from now on (remember that this has changed in Visual
    Studio 2017, where the `.sln` file is used to declare dependencies).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有 `app.config` 文件。这个文件已经被另一个 `.json` 文件 `project.json` 替换，从现在起它将负责定义应用程序的配置（记住，在
    Visual Studio 2017 中，`.sln` 文件用于声明依赖项）。
- en: 'And, as it happens with the `global.json` file, the editor recognizes the values
    assigned to the keys and provides Intellisense here as well, with interesting
    hints about the possible values to configure (the next screenshot includes the
    initial list of references and Intellisense in action within the `project.json`
    file):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，就像 `global.json` 文件一样，编辑器识别分配给键的值，并在这里也提供智能感知，提供有关可配置的可能值的有趣提示（下一张截图包括初始引用列表和
    `project.json` 文件中的智能感知操作）：
- en: '![Installation of .NET Core](img/image00706.jpeg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![.NET Core 安装](img/image00706.jpeg)'
- en: Now, I'm going to use a simple code snippet to explore how some of the common
    namespaces are implemented in .NET Core. In this case, we have three text files
    located in the same directory as the application (could be any directory, of course),
    and we're going to search for them, read their content, and present it in the
    console.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将使用一个简单的代码片段来探索一些常见命名空间在.NET Core中的实现方式。在这种情况下，我们有三个与应用程序位于同一目录中的文本文件（当然，可以是任何目录），我们将搜索它们，读取它们的内容，并在控制台显示。
- en: 'So we have some very simple code in the `program.cs` file, which serves as
    the entry point of the application:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`program.cs`文件中有一些非常简单的代码，它作为应用程序的入口点：
- en: '[PRE23]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can compile the program as always, and at runtime, we should see the output,
    only working on the .NET Core infrastructure (refer to the next screenshot):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像往常一样编译程序，在运行时，我们应该看到输出，只在工作在.NET Core基础设施上（参考下一张截图）：
- en: '![Installation of .NET Core](img/image00707.jpeg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![.NET Core的安装](img/image00707.jpeg)'
- en: As you can see, the functionalities, code, libraries, and namespaces used are
    just the same as the ones we would use in a standard Console application—only
    now, we're using the .NET Core 1.0 libraries and architecture.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用的功能、代码、库和命名空间与我们在标准控制台应用程序中使用的完全相同——只是现在，我们使用的是.NET Core 1.0库和架构。
- en: However, a look at the code (and the output) will probably call your attention,
    since the name of the executable that we see in the output window is `dotnet.exe`
    and not `NETCoreConsoleApp1` (the name we gave to our solution).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看一下代码（和输出）可能会引起你的注意，因为我们在输出窗口中看到的可执行文件名是`dotnet.exe`而不是我们给解决方案起的名字`NETCoreConsoleApp1`。
- en: The reason for this has to do with the complexity linked to this model. The
    application is thought to be executable on distinct platforms. The default option
    allows the deployment architecture to determine the best way to configure the
    JIT compilers depending on the target. This is why the execution is undertaken
    by the dotnet runtime (named `dotnet.exe`).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的原因与这种模型相关的复杂性有关。该应用程序被认为可以在不同的平台上执行。默认选项允许部署架构根据目标确定配置JIT编译器的最佳方式。这就是为什么执行是由dotnet运行时（命名为`dotnet.exe`）来完成的。
- en: 'In NET Core, two types of applications are defined: portable and self-contained.
    As the official documentation states:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core中，定义了两种类型的应用程序：可移植的和自包含的。正如官方文档所述：
- en: '"Portable applications are the default type in .NET Core. They require .NET
    Core to be installed on the targeted machine in order for them to run. To you
    as a developer, this means that your application is portable between installations
    of .NET Core.'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “可移植应用程序是.NET Core的默认类型。为了使它们能够运行，需要在目标机器上安装.NET Core。对你作为开发者来说，这意味着你的应用程序可以在.NET
    Core的不同安装之间移植。”
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A self-contained application does not rely on any shared component to be present
    on the machine where you want to deploy the application. As its name implies,
    it means that the entire dependency closure, including the runtime, is packaged
    with the application. This makes it larger, but also makes it capable of running
    on any .NET Core supported platforms with the correct native dependencies, whether
    it has .NET Core installed or not. This makes it that much easier to deploy to
    the target machine since you only deploy your application."
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自包含应用程序不依赖于任何共享组件存在于你想要部署应用程序的机器上。正如其名所示，这意味着整个依赖项封闭，包括运行时，都与应用程序打包在一起。这使得它更大，但同时也使得它能够在任何.NET
    Core支持的平台上运行，只要有正确的本地依赖项，无论是否安装了.NET Core。这使得将其部署到目标机器变得容易得多，因为你只需部署你的应用程序。”
- en: The default configuration we're using is the portable one. Where is this configuration
    established? In the `project.json` dependencies section, you'll see that there
    is a `"type":"Platform"` entry. That's what indicates this execution model.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的默认配置是可移植的。这个配置在哪里设置的？在`project.json`依赖项部分，你会看到有一个`"type":"Platform"`条目。这就是指示这种执行模型的原因。
- en: Actually, the resulting assembly is a DLL, as you can see by watching the `bin/debug`
    directory after compilation. In our case, this DLL is only 6 Kb long.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，生成的程序集是一个DLL，正如你在编译后查看`bin/debug`目录时可以看到的。在我们的例子中，这个DLL只有6 Kb长。
- en: What about the other choice? Well, if you know that you're going to target a
    certain platform, you can eliminate the previously mentioned entry in the `project.json`
    file (that's first). Second, you should leave the `Microsoft.NET Core.App` dependency,
    since it will retrieve all of the rest of the required components. Finally, it
    will be necessary to indicate (in the runtimes node) those that you want to use.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，其他选择呢？好吧，如果你知道你将要针对某个平台，你可以在`project.json`文件中删除之前提到的条目（即第一个）。其次，你应该保留`Microsoft.NET
    Core.App`依赖项，因为它将检索所有其他所需组件。最后，你需要在（运行时节点中）指出你想要使用的那些。
- en: 'So, I changed the `project.json` file to appear with this configuration:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将`project.json`文件更改为以下配置：
- en: '[PRE24]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the compiler behaves differently: it generates a new folder (dependent
    on the debug folder), containing a real native executable, which contains all
    the required elements to run in any platform of that type (`win10-x64`, in our
    demo).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器的行为有所不同：它生成一个新的文件夹（依赖于调试文件夹），包含一个真正的本地可执行文件，其中包含在那种类型的任何平台上运行所需的所有元素（在我们的演示中是`win10-x64`）。
- en: 'After compilation, you''ll see new files appearing, and one of them will be
    an executable file now. If you move to that folder in the Explorer, you''ll see
    that there''s a new file named `NETCoreConsoleApp1.exe`, which is the standalone
    executable. Also, this new file is larger than the DLL since it contains all the
    requirements (refer to the screenshot):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，你会看到出现新文件，其中之一现在将是一个可执行文件。如果你在资源管理器中移动到那个文件夹，你会看到一个新的名为`NETCoreConsoleApp1.exe`的文件，这是一个独立的可执行文件。此外，这个新文件比DLL大，因为它包含了所有需求（参见图表）：
- en: '![Installation of .NET Core](img/image00708.jpeg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![.NET Core的安装](img/image00708.jpeg)'
- en: Note
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is an exhaustive explanation of all possible configuration options at
    [https://docs.microsoft.com/es-es/dotnet/articles/core/tools/project-json](https://docs.microsoft.com/es-es/dotnet/articles/core/tools/project-json).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://docs.microsoft.com/es-es/dotnet/articles/core/tools/project-json](https://docs.microsoft.com/es-es/dotnet/articles/core/tools/project-json)中，对所有可能的配置选项进行了详尽的解释。
- en: The CLI interface
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLI界面
- en: As we mentioned earlier, another choice available to develop these type of applications
    is now a command-line interface offered by the standalone installation of Core
    CLI or by the previous installation I made (the `DotNetCore.1.0.0 - VS2015Tools.Preview2.0.1`
    file).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，现在可供开发此类应用程序的另一种选择是Core CLI的独立安装或之前安装的（`DotNetCore.1.0.0 - VS2015Tools.Preview2.0.1`文件）提供的命令行界面。
- en: Several preconfigured command-line windows are made available depending on the
    platform to target under the generic name of Cross Tools Command Prompt. Just
    open the one that corresponds to your target platform and proceed as follows.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目标平台，提供了几个预配置的命令行窗口，统称为跨工具命令提示符。只需打开与你的目标平台相对应的一个，然后按照以下步骤进行操作。
- en: You can use the initial, basic demo mode that Microsoft has prepared as a start
    up with this tool. After opening Command Prompt, create a new directory that will
    serve as the root for a new project. In my case, I do it in a new `C:\dev\hello_world`
    directory (among other things, to avoid some security issues that might arise
    when using the `C:\` root directory).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用微软准备好的初始基本演示模式作为此工具的启动。在打开命令提示符后，创建一个新目录，该目录将作为新项目的根目录。在我的例子中，我在新的`C:\dev\hello_world`目录中这样做（避免使用`C:\`根目录可能引起的一些安全问题）。
- en: 'At this point, you can ask for help by just typing `dotnet –help`, as shown
    in the following screenshot:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只需输入`dotnet –help`即可请求帮助，如下面的截图所示：
- en: '![The CLI interface](img/image00709.jpeg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![CLI界面](img/image00709.jpeg)'
- en: To create a new project over this location, type `dotnet` new. Core CLI will
    download all the required components to your directories, including a basic application
    template, which holds a `program.cs` file with the classic `Hello World` console
    application, along with the default `project.json` file.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此位置创建一个新项目，请输入`dotnet new`。Core CLI将下载所有必需的组件到你的目录中，包括一个基本的应用程序模板，其中包含一个`program.cs`文件，它包含经典的`Hello
    World`控制台应用程序，以及默认的`project.json`文件。
- en: From this point, you can also open the project with Visual Studio Code (any
    platform, remember) and make the desired changes. The dot (`.`) indicates the
    IDE to use the current directory as the solution's directory.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，你也可以使用Visual Studio Code（任何平台，记住）打开项目并做出所需更改。点（`.`）表示IDE使用当前目录作为解决方案目录。
- en: The next step is to call `dotnet` restore. The result is that NuGet gets called
    in order to restore the tree dependencies defined in `project.json` and creates
    a variant of this file called `project.lock.json`, which is required if you want
    to be able to compile and run (if you open this file, you'll see that it is pretty
    large).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是调用 `dotnet restore`。结果是 NuGet 被调用以恢复 `project.json` 中定义的树形依赖关系，并创建一个名为 `project.lock.json`
    的此文件变体，如果你想要能够编译和运行（如果你打开此文件，你会看到它相当大）。
- en: 'The official documentation defines this file as:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档将此文件定义为：
- en: '"A persisted and complete set of the graph of NuGet dependencies and other
    information describing an app. This file is read by other tools, such as dotnet
    build and dotnet run, enabling them to process the source code with a correct
    set of NuGet dependencies and binding resolutions."'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一个持久且完整的 NuGet 依赖关系图集和描述应用程序的其他信息的集合。此文件由其他工具读取，例如 dotnet build 和 dotnet run，使它们能够使用正确的
    NuGet 依赖关系集和绑定解析来处理源代码。”
- en: From here, several options are available. You can launch a `dotnet build` command,
    which will build the application and generate a directory structure similar to
    the one we saw in Visual Studio. It will not run; it will only generate the resulting
    files.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，有几个选项可供选择。你可以启动 `dotnet build` 命令，这将构建应用程序并生成类似于我们在 Visual Studio 中看到的目录结构。它不会运行；它只会生成结果文件。
- en: 'The alternative option is to call `dotnet run`. With this command, the `build`
    option is called, and next, it launches execution; so, you should see something
    like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 替代选项是调用 `dotnet run`。使用此命令，将调用 `build` 选项，然后启动执行；因此，你应该会看到类似以下内容：
- en: '![The CLI interface](img/image00710.jpeg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![CLI 接口](img/image00710.jpeg)'
- en: 'And, of course, it''s a good practice to take a look at the resulting files,
    which will be located in a subdirectory of the debug file, just like in our Visual
    Studio app:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，查看生成的文件是一个好习惯，这些文件将位于调试文件的一个子目录中，就像我们的 Visual Studio 应用程序一样：
- en: '![The CLI interface](img/image00711.jpeg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![CLI 接口](img/image00711.jpeg)'
- en: If you're curious, you can change the `project.json` file to generate the standalone
    executable, just like we did earlier, and the results should be equivalent.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，可以将 `project.json` 文件更改为生成独立的可执行文件，就像我们之前做的那样，结果应该是等效的。
- en: Well, up until this point, we've seen an introduction to the .NET Core 1.0,
    but that's not the only development model .NET Core supports. Let's take a look
    at the—very interesting—ASP.NET Core 1.0.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止，我们已经看到了 .NET Core 1.0 的介绍，但这不是 .NET Core 支持的唯一开发模型。让我们看看——非常有趣的——ASP.NET
    Core 1.0。
- en: ASP.NET Core 1.0
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 1.0
- en: The model adopted for ASP.NET applications that use .NET Core is totally based
    on the previous MVC model. But it's built from scratch, with the target on cross-platform
    execution, the elimination of some features (no longer necessary), and the unification
    of the previous MVC with the web API variant; so, they work with the same controller
    type.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于使用 .NET Core 的 ASP.NET 应用程序所采用的模型完全基于之前的 MVC 模型。但它是从零开始构建的，目标是跨平台执行，消除一些功能（不再必要），以及将之前的
    MVC 与 Web API 变体统一；因此，它们使用相同的控制器类型。
- en: Besides this, the code doesn't need to be compiled prior to execution while
    you're developing. You change the code on the fly and Roselyn services take care
    of updating; so, you just have to refresh your page to see the changes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在开发过程中，代码不需要在执行前编译。你可以即时更改代码，Roselyn 服务会负责更新；因此，你只需刷新页面即可看到更改。
- en: 'If we take a look at the new list of templates, after installing .NET Core
    in the "Web" development section, we''re offered a classic version of ASP.NET,
    where we have the typical templates you already know (including Web Forms applications)
    and two new options: ASP.Core Web Application (.NET Core) and ASP.NET Core Web
    Application (.NET Framework) (Review the first image at the beginning of the *.NET
    Core 1.0* section to remember the architecture).'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看新的模板列表，在“Web”开发部分安装 .NET Core 后，我们将获得一个经典的 ASP.NET 版本，其中包含你已知的典型模板（包括
    Web 表单应用程序）和两个新选项：ASP.Core Web Application (.NET Core) 和 ASP.NET Core Web Application
    (.NET Framework)（回顾 *.NET Core 1.0* 部分开头的第一张图像以记住架构）。
- en: What's new
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新增功能
- en: Many new things show up in this version of ASP.NET Core. First, there's a new
    hosting model because ASP.NET is completely decoupled from the web server environment
    that hosts the application. It supports IIS versions and also self-hosting contexts
    via Kestrel (cross-platform, extremely optimized, built on top of LibUv, the same
    component that Node.js uses) and WebListener HTTP (Windows-only) servers.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的ASP.NET Core中出现了许多新事物。首先，有一个新的托管模型，因为ASP.NET已经完全从托管应用程序的Web服务器环境中解耦。它支持IIS版本，也支持通过Kestrel（跨平台、极致优化、基于LibUv，这是Node.js使用的相同组件）和WebListener
    HTTP（仅限Windows）服务器进行自托管。
- en: We also count on a new generation of middleware that are asynchronous, very
    modular, lightweight, and totally configurable, where we define things such as
    routing, authentication, static files, diagnostics, error handling, session, CORS,
    localization, and even you can write and include your own middleware.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还依赖于新一代的中间件，它们是异步的、非常模块化的、轻量级的，并且完全可配置的，其中我们定义了诸如路由、身份验证、静态文件、诊断、错误处理、会话、CORS、本地化和甚至你可以编写和包含你自己的中间件。
- en: Note
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those who don't know, middleware is a pipeline element that is run before
    and after the user code. The components of a pipeline are executed in a sequence
    and they call the next one in the pipeline. In this way, we can execute pre/post
    code. When a piece of middleware generates a `Response` object, the pipeline returns.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不知道的人来说，中间件是在用户代码之前和之后运行的管道元素。管道的组件按顺序执行，并调用管道中的下一个组件。这样，我们可以执行预/后代码。当一个中间件生成`Response`对象时，管道返回。
- en: 'Refer to the following schema:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下架构：
- en: '![What''s new](img/image00712.jpeg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![有什么新变化](img/image00712.jpeg)'
- en: In addition, a new built-in IoC container for dependency injection is responsible
    for bootstrapping the system, and we also find a new configuration system, which
    we'll discuss in more detail a bit later.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个新的内置IoC容器用于依赖注入负责启动系统，我们还发现了一个新的配置系统，我们将在稍后更详细地讨论。
- en: ASP.NET Core joins many things that were separate earlier. No more distinctions
    between MVC and Web API, and a complete set of new Tag Helpers is available. And
    if you target .NET Core, or if you prefer to target any of the other versions
    of .NET, the architectural model is going to be MVC with this rebuilt architecture.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core将许多之前分离的事物结合在一起。不再区分MVC和Web API，并提供了一套完整的新Tag Helpers。如果你针对.NET
    Core，或者如果你更喜欢针对.NET的其他版本，那么架构模型将是MVC，这是重建的架构。
- en: A first approach
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次尝试
- en: 'Let''s look at the structure of a project made up of the default templates
    available in Visual Studio 2015\. You just have to select **New Project** | **Web**
    in Visual Studio to see these alternatives in action:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看由Visual Studio 2015中可用的默认模板组成的项目结构。你只需在Visual Studio中选择**新建项目** | **Web**，就可以看到这些替代方案的实际效果：
- en: '![A first approach](img/image00713.jpeg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![第一次尝试](img/image00713.jpeg)'
- en: 'I think it''s a good idea to start with the simplest possible template and
    start digging into the programming architecture that lies behind this new proposal.
    So, I''ll start with one of these new projects and select the **Empty** option.
    I''m offered the three initial choices: **Empty**, **Web API**, and **Web Application**.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为从最简单的模板开始，并开始挖掘背后这个新提案的编程架构是一个好主意。所以，我会从这些新项目中的一个开始，并选择**空**选项。我得到了三个初始选择：**空**、**Web
    API**和**Web 应用程序**。
- en: A basic directory structure will be created for us, where we'll easily find
    some of the elements we previously saw in the introduction to .NET Core (including
    the separated `global.json` file used to define directories, projects, and packages).
    I named this demo `ASPNETCoreEmpty` (refer to the next screenshot for the solution
    structure).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 将为我们创建一个基本的目录结构，其中我们可以轻松地找到在.NET Core简介中之前看到的一些元素（包括用于定义目录、项目和包的分离的`global.json`文件）。我给这个演示命名为`ASPNETCoreEmpty`（参考下一张截图以了解解决方案结构）。
- en: You might be surprised to notice the absence (and also the presence) of certain
    files at first.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地注意到某些文件最初缺失（以及存在）。
- en: 'For instance, there''s a new folder named `wwwroot`, which you surely know
    from other applications hosted in IIS. In this case, that hasn''t to do with IIS:
    it only means that it is the root directory of our site. Actually, you''ll also
    see a `web.config` file, but that''s only to be used if you want the website to
    be hosted in IIS precisely.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个名为 `wwwroot` 的新文件夹，您可能从其他托管在 IIS 中的应用程序中很熟悉。在这种情况下，这与 IIS 没有关系：它仅仅意味着它是我们站点的根目录。实际上，您也会看到一个
    `web.config` 文件，但只有在您确切希望网站托管在 IIS 上时才使用它。
- en: 'You will also see the presence of a `project.json` file, but be careful with
    this. As the official documentation states:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会看到 `project.json` 文件的存在，但请注意这一点。正如官方文档所述：
- en: '"ASP.NET Core''s configuration system has been re-architected from previous
    versions of ASP.NET, which relied on System.Configuration and XML configuration
    files like web.config. The new configuration model provides streamlined access
    to key/value based settings that can be retrieved from a variety of sources. Applications
    and frameworks can then access configured settings in a strongly typed fashion
    using the new Options pattern."'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"ASP.NET Core 的配置系统已经从之前版本的 ASP.NET 中重新架构，之前版本的 ASP.NET 依赖于 System.Configuration
    和像 web.config 这样的 XML 配置文件。新的配置模型提供了对基于键/值设置的流畅访问，这些设置可以从各种来源检索。然后应用程序和框架可以使用新的
    Options 模式以强类型方式访问配置设置。"'
- en: 'The next capture remarks the two main `.cs` files created by the project:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图说明了项目创建的两个主要 `.cs` 文件：
- en: '![A first approach](img/image00714.jpeg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![第一次尝试](img/image00714.jpeg)'
- en: Furthermore, the official recommendation is that you use a configuration written
    in C#, which is linked to the `Startup.cs` file that you see in the file structure.
    Once there, you should use Options pattern to access any individual setting.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，官方建议您使用 C# 编写的配置，它与文件结构中看到的 `Startup.cs` 文件相关联。一旦到达那里，您应该使用 Options 模式来访问任何单个设置。
- en: 'So we now have two initial points: one related to the host and another that
    configures our application.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有两个初始点：一个与宿主相关，另一个配置我们的应用程序。
- en: Configuration and Startup settings
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和启动设置
- en: 'Let''s briefly analyze the file''s contents:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要分析一下文件的内容：
- en: '[PRE25]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see, there are only two methods: `ConfigureServices` and `Configure`.
    The former permits (you guessed it) to configure services. The `IServiceCollection`
    element it receives allows you to configure logins, options, and two flavors of
    services: `scoped` and `transient`.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这里只有两种方法：`ConfigureServices` 和 `Configure`。前者允许（您猜对了）配置服务。它接收的 `IServiceCollection`
    元素允许您配置登录、选项以及两种服务类型：`scoped` 和 `transient`。
- en: The latter is the initial entry point of our application, and it receives three
    arguments that permit the developer all types of configuration and initial settings.
    The first one, `loggerFactory`, lets you add `ILoggerProvider` to the login system
    (refer to [https://docs.asp.net/en/latest/fundamentals/logging.html](https://docs.asp.net/en/latest/fundamentals/logging.html)
    for more details), and in this case, it adds the `Console` provider.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是我们的应用程序的初始入口点，它接收三个参数，允许开发者进行所有类型的配置和初始设置。第一个参数 `loggerFactory` 允许您向登录系统添加
    `ILoggerProvider`（有关更多详细信息，请参阅 [https://docs.asp.net/en/latest/fundamentals/logging.html](https://docs.asp.net/en/latest/fundamentals/logging.html)），在这种情况下，它添加了
    `Console` 提供者。
- en: Note
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Observe that these two method's arguments are received automatically. Behind
    the scenes,the Dependency Injection engine provides these and other instances'
    elements.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个方法的参数是自动接收的。在幕后，依赖注入引擎提供了这些和其他实例的元素。
- en: 'We can add as many logging providers as we want: each time we write a log entry,
    that entry will be forwarded to each logging provider. The default provider writes
    to the Console window (if available).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加任意多的日志提供者：每次我们写入日志条目时，该条目将被转发到每个日志提供者。默认提供者将写入控制台窗口（如果可用）。
- en: 'The following lines also explain some important things about the way this pipeline
    works. The second argument (of type `IHosting Environment`) lets you configure
    two different working environments: development and production, so we can, like
    in this case, activate error pages proper for development, or we can configure
    these errors in a customized manner. This argument also contains some utility
    properties for developers.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行还解释了有关此管道工作方式的一些重要内容。第二个参数（类型为 `IHosting Environment`）允许您配置两个不同的工作环境：开发和生产，因此我们可以像在这种情况下一样激活适合开发的错误页面，或者我们可以以定制的方式配置这些错误。此参数还包含一些对开发者有用的属性。
- en: 'The third argument (of type `IApplication Builder`) is the one that really
    launches the application. As you can see, it calls the `Run` method of another
    object received by injection: the `context` variable (of type `HttpContext`),
    which holds all the required information and methods to manipulate the dialog
    process.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数（类型为`IApplication Builder`）是真正启动应用程序的那个。正如你所见，它调用通过注入接收到的另一个对象的`Run`方法：`context`变量（类型为`HttpContext`），它包含所有必需的信息和方法来操作对话框过程。
- en: If you take a look, you'll see that it has properties such as `Connection`,
    `Request`, `Response`, `Session`, `User`, among others and an `Abort` method to
    cancel the connection at any time.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看看，你会发现它具有诸如`Connection`、`Request`、`Response`、`Session`、`User`等属性，以及一个可以在任何时间取消连接的`Abort`方法。
- en: Actually, the code calls the `Run` method asynchronously (with `async/await`),
    and it writes content that is addressed to the clients. Note that no HTML is implied
    here yet. If you run the project, you will see the `Hello World` text as expected
    every time a request to a port is made over localhost. (The IDE randomly assigns
    a different port for each application and you can change that, of course).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，代码以异步方式（使用`async/await`）调用`Run`方法，并写入面向客户端的内容。请注意，这里还没有隐含HTML。如果你运行项目，你将看到每次在本地主机上对端口的请求时，都会如预期地看到`Hello
    World`文本。（IDE为每个应用程序随机分配不同的端口，你当然可以更改它）。
- en: 'So, you can change the `Response` object, adding some more information to the
    initial response. A look at the `context` object shows several properties related
    to the process, such as the `Connection` object, which has a `Local Port` property
    whose value we can add to `Response` by just modifying the code in this way:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以更改`Response`对象，向初始响应中添加更多信息。查看`context`对象会显示与进程相关的几个属性，例如具有`Local Port`属性的`Connection`对象，我们可以通过仅修改此方式中的代码将其添加到`Response`中：
- en: '[PRE26]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, we said we can change the hosting context. If we select the running
    host to be the name of our application instead of IIS Express, then we''re opting
    for the self-hosting option, and two windows will open at runtime: a Console window
    (corresponding to the host) and the browser we select, sending a request over
    the application.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们说过我们可以更改托管上下文。如果我们选择运行的主机是我们的应用程序名称而不是IIS Express，那么我们就是在选择自托管选项，在运行时将打开两个窗口：一个控制台窗口（对应于主机）和选定的浏览器，通过应用程序发送请求。
- en: 'So, we should see one console with the data related to the hosting, as shown
    in the next screenshot:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该看到一个控制台，显示与托管相关的数据，如图中所示：
- en: '![Configuration and Startup settings](img/image00715.jpeg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![配置和启动设置](img/image00715.jpeg)'
- en: 'Simultaneously, the selected browser will open, showing the initial message
    plus the modified information, including the port number:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，选定的浏览器将打开，显示初始消息以及修改后的信息，包括端口号：
- en: '![Configuration and Startup settings](img/image00716.jpeg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![配置和启动设置](img/image00716.jpeg)'
- en: Note that although a look at the code seems to have some markup, this is included
    in the browsers because when they receive plain text, they wrap it around some
    basic markup instead of just presenting the text without any HTML. But we still
    didn't activate the option to serve static files.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管查看代码似乎有一些标记，但这被包含在浏览器中，因为当它们接收到纯文本时，它们会将其包裹在一些基本标记中，而不是简单地显示没有HTML的文本。但我们还没有激活提供静态文件的功能。
- en: Also, observe that there's no checking of resources; so, no matter what you
    put next to the `localhost:5000` address, you'll get the same result.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意没有检查资源；因此，无论你在`localhost:5000`地址旁边放置什么，你都会得到相同的结果。
- en: 'On the other hand, the host construction is made in the `Program.cs` file,
    where we find the entry point, which only creates a new host that calls the constructor
    of `WebHost Builder` and configures some default behavior:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，主机构建是在`Program.cs`文件中进行的，在那里我们找到入口点，它仅创建一个新的主机，调用`WebHost Builder`的构造函数并配置一些默认行为：
- en: '[PRE27]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you take a look at the `WebHost Builder` class (which follows the builder
    pattern), you''ll see that it is full of `Use*` like methods, which allow the
    programmer to configure this behavior:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`WebHost Builder`类（它遵循构建器模式），你会发现它充满了`Use*`之类的函数，这些函数允许程序员配置这种行为：
- en: '![Configuration and Startup settings](img/image00717.jpeg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![配置和启动设置](img/image00717.jpeg)'
- en: In the preceding example, the Kestrel web server is used, but other web servers
    can be specified. The code also indicates that you use the current directory as
    the content root to integrate with IIS (that's why this is optional) and to use
    the `Startup` instance available in order to finish its configuration before actually
    building the server.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用了Kestrel web服务器，但也可以指定其他web服务器。代码还表明，你使用当前目录作为内容根来与IIS集成（这就是为什么这是可选的），并使用可用的`Startup`实例来完成其配置，在实际上构建服务器之前。
- en: Once built, the server is launched, and that's the reason for the information
    we see in the console if we select self-hosting instead of IIS.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，服务器就会启动，这就是为什么如果我们选择自托管而不是IIS，我们会在控制台中看到这些信息的原因。
- en: Self-hosted applications
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自托管应用程序
- en: 'Self-hosted applications have a number of benefits, as we said: the application
    carries out anything it needs to run. That is, there''s no need to have .NET Core
    preinstalled, which makes this option pretty useful for constrained environments.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所言，自托管应用程序有许多好处：应用程序执行它运行所需的一切。也就是说，不需要预先安装.NET Core，这使得这个选项在受限环境中非常有用。
- en: Operationally, it works like a normal native executable, and we can build it
    for any of the supported platforms. Future plans are to convert this executable
    into pure native executables depending on the platform to be used.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作上，它就像一个正常的本地可执行文件一样工作，我们可以为任何支持的平台构建它。未来的计划是将这个可执行文件转换为纯本地可执行文件，具体取决于要使用的平台。
- en: 'Before digging into MVC, if you want to serve a static file, you''ll have to
    ensure that the `UseContentRoot` method has been configured, and you have to add
    another piece of middleware indicating that. Just add the following to your `Configure`
    method and add some static content that you can invoke:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究MVC之前，如果你想要服务静态文件，你必须确保已经配置了`UseContentRoot`方法，并且你需要添加另一段中间件来指示这一点。只需将以下内容添加到你的`Configure`方法中，并添加一些你可以调用的静态内容：
- en: '[PRE28]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In my case, I''ve created a very simple `index.html` file with a couple of
    HTML text tags and an `img` tag to make a dynamic call to the `http://lorempixel.com`
    site in order to serve an image file of size 200 x 100:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我创建了一个非常简单的`index.html`文件，包含几个HTML文本标签和一个`img`标签，以便动态调用`http://lorempixel.com`网站以提供200
    x 100大小的图像文件：
- en: '[PRE29]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you leave this file in the `wwwroot` directory, you can now invoke the `http://localhost:<port>/index.html`
    address, and you should see the page just as well:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此文件留在`wwwroot`目录中，你现在可以调用`http://localhost:<端口>/index.html`地址，你应该能看到页面效果一样：
- en: '![Self-hosted applications](img/image00718.jpeg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![自托管应用程序](img/image00718.jpeg)'
- en: Consequently, nothing prevents you from using ASP.NET Core technologies to build
    and deploy static sites or even sites that perform a functionality depending on
    the input without the need to use MVC, Web Pages, Web Forms, or other classic
    ASP.NET elements.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，没有任何阻止你使用ASP.NET Core技术来构建和部署静态站点，甚至不需要使用MVC、Web Pages、Web Forms或其他经典ASP.NET元素的功能性站点。
- en: Once we understand the basic structure of ASP.NET Core, it's time to look at
    a more complex project, (MVC type), similar to the typical initial solution that
    Microsoft used to include in previous templates, including controllers, views,
    use of Razor, and third-party resources, such as BootStrap and jQuery, among others.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了ASP.NET Core的基本结构，就到了查看更复杂的项目的时候了，（MVC类型），类似于微软以前在模板中包含的典型初始解决方案，包括控制器、视图、Razor的使用，以及第三方资源，如BootStrap和jQuery等。
- en: 'But before we get into that, let me just indicate some surprising results obtained
    recently in benchmarks published by the ASP.NET Core development team: the performance
    gains using ASP.NET Core are meaningful.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入之前，让我先指出最近在ASP.NET Core开发团队发布的基准测试中获得的一些令人惊讶的结果：使用ASP.NET Core的性能提升是有意义的。
- en: 'The benchmark was made to compare classic ASP.NET 4.6, Node.js, ASP.NET Core
    (Weblist), ASP.NET Core on Mono, ASP.NET Core (CLR), ASP.NET Core (on Linux),
    and ASP.NET Core (Windows), resulting in the last case 1,150,000 requests per
    second in fine-grained requests (highly superior to Node.js). Refer to the following
    figure:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 该基准测试是为了比较经典ASP.NET 4.6、Node.js、ASP.NET Core (Weblist)、ASP.NET Core on Mono、ASP.NET
    Core (CLR)、ASP.NET Core (on Linux)和ASP.NET Core (Windows)，在最后一种情况下，在细粒度请求中每秒达到1,150,000个请求（远优于Node.js）。请参考以下图表：
- en: '![Self-hosted applications](img/image00719.jpeg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![自托管应用程序](img/image00719.jpeg)'
- en: ASP.NET Core 1.0 MVC
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core 1.0 MVC
- en: If we opt for a complete template when creating a new ASP.NET Core application,
    we'll find some meaningful changes and extended functionality.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建新的ASP.NET Core应用程序时选择完整模板，我们会发现一些有意义的更改和扩展功能。
- en: I think it's interesting to compare both approaches in order to see exactly
    which elements are added or modified to permit these type of applications. First,
    pay attention to the new file structure.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为比较这两种方法以确切了解允许这些类型应用程序的哪些元素被添加或修改是有趣的。首先，注意新的文件结构。
- en: 'Now, we recognize the typical elements that we already know from ASP.NET MVC
    applications: Controllers, Views, (no `Model` folder in this case because there''s
    no need for it in the basic template), and another four folders with static resources
    pending from `wwwroot`.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们认识到我们从ASP.NET MVC应用程序中已经知道的典型元素：控制器、视图（在这种情况下没有`Model`文件夹，因为基本模板中不需要它），以及来自`wwwroot`的四个静态资源文件夹。
- en: They contain the recommended location folders for the CSS used in the application,
    static images, JavaScript files (for instance, to access the new ECMA Script2015
    APIs), plus versions 3.3.6 of Bootstrap, version 2.2 of jQuery, and version 1.14
    of the jQuery Validation plugin (of course, the version number will vary with
    time).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 它们包含应用程序中使用的CSS推荐位置文件夹、静态图像、JavaScript文件（例如，访问新的ECMA Script2015 API），以及Bootstrap的3.3.6版本、jQuery的2.2版本和jQuery
    Validation插件的1.14版本（当然，版本号会随时间变化）。
- en: These files are loaded into the project via `Bower`. Under the dependencies
    section, you'll find a `Bower` folder that you can use—even dynamically—to change
    versions, update to higher ones, and so on.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件通过`Bower`加载到项目中。在依赖关系部分，您会找到一个`Bower`文件夹，您可以使用它——甚至是动态地——来更改版本、更新到更高版本等。
- en: Tip
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you right-click on any of the `Bower` entries, a contextual menu will offer
    to update the package, uninstall it, or manage other packages so that you can
    add new missing packages.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在任何一个`Bower`条目上右键单击，上下文菜单将提供更新包、卸载它或管理其他包的选项，以便您可以添加新的缺失包。
- en: 'All this is under the **wwwroot** section. But taking a look at the **Controllers**
    and **Views** folders, you''ll discover a—somehow—familiar structure and content:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在**wwwroot**部分下。但是，查看**Controllers**和**Views**文件夹，您会发现某种程度上的熟悉结构和内容：
- en: '![ASP.NET Core 1.0 MVC](img/image00720.jpeg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![ASP.NET Core 1.0 MVC](img/image00720.jpeg)'
- en: Of course, if you execute the application, the main page launches, similar to
    the previous versions of ASP.NET MVC—only, the structure has changed. Let's see
    how, starting with a review of the `Startup.cs` and `Program.cs` files.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您运行应用程序，主页面将启动，类似于之前的ASP.NET MVC版本——只是结构已经改变。让我们看看如何，从回顾`Startup.cs`和`Program.cs`文件开始。
- en: The first thing to notice in the `Startup` content is that now, the class has
    a constructor. This constructor uses an object of type `IConfigurationRoot`, named
    `Configuration`, defined as public; so, whatever it contains is accessible all
    over the application.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Startup`内容中首先要注意的是，现在，类有一个构造函数。这个构造函数使用类型为`IConfigurationRoot`的对象，命名为`Configuration`，定义为公共的；因此，它包含的内容可以在整个应用程序中访问。
- en: 'As the documentation states:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档所述：
- en: '"Configuration is just a collection of sources, which provide the ability to
    read and write name/value pairs. If a name/value pair is written to Configuration,
    it is not persisted. This means that the written value will be lost when the sources
    are read again."'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “配置只是一个源集合，它提供了读取和写入名称/值对的能力。如果将名称/值对写入配置，则不会持久化。这意味着当再次读取源时，写入的值将丢失。”
- en: 'For the project to work properly, you must configure at least one source. Actually,
    the current implementation does something else:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目正常运行，您必须配置至少一个源。实际上，当前实现做了其他事情：
- en: '[PRE30]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The process goes in two phases. First, a `Configuration Builder` object is
    created and configured to read from distinct sources (JSON files). In this manner,
    when the runtime creates the `Startup` instance, all the required values are already
    read, as shown in the next screenshot:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程分为两个阶段。首先，创建一个`Configuration Builder`对象，并配置它从不同的源（JSON文件）读取。以这种方式，当运行时创建`Startup`实例时，所有必需的值已经读取，如下一张截图所示：
- en: '![ASP.NET Core 1.0 MVC](img/image00721.jpeg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![ASP.NET Core 1.0 MVC](img/image00721.jpeg)'
- en: The next important change from the original demo is that MVC is an optional
    service that requires to be explicitly registered. This is done in the `ConfigureServices`
    method.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始演示相比，下一个重要更改是MVC是一个可选服务，需要显式注册。这是在`ConfigureServices`方法中完成的。
- en: Finally, the runtime calls `Configure` in the `Startup` object. This time, we
    see that `Add Debug()`is called, and depending on the application's environment
    (development or production), distinct error pages are configured. (By the way,
    also note the call to `Add StaticFiles()`, which we added in the previous demo.)
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行时在`Startup`对象中调用`Configure`。这次，我们看到调用了`Add Debug()`，并且根据应用程序的环境（开发或生产），配置了不同的错误页面。（顺便说一下，也请注意对`Add
    StaticFiles()`的调用，这是我们之前在演示中添加的。）
- en: The last step in this middleware configuration process is to configure routes.
    Those of you who are experienced and who already know ASP.NET MVC will easily
    recognize the similar code structure that we used in the classic version, although
    here, the default configuration has been simplified.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个中间件配置过程的最后一步是配置路由。那些经验丰富并且已经熟悉ASP.NET MVC的人会很容易地认出我们在这里使用的与经典版本中相似的代码结构，尽管这里的默认配置已经简化了。
- en: This also explains why `Configure Services` should be called prior to `Configure`
    because it's using the MVC service this latter call adds.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么应该在`Configure`之前调用`Configure Services`，因为后者调用添加了MVC服务。
- en: With all this, the application is ready to start; so, the runtime goes to the
    entry point (the `Main` method in `Program.cs`).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些准备就绪后，应用程序就可以启动了；因此，运行时将转到入口点（`Program.cs`中的`Main`方法）。
- en: 'Another interesting behavior is shown here: the web host is built. And `WebHost
    Builder` is in charge of it. Only when this builder is instantiated and configured
    does the process end, calling the `Build()`method. This method generates a working
    and tuned server, which is finally launched. A look at the code also tells us
    more about the structure:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个有趣的行为：构建了Web宿主。`WebHost Builder`负责构建。只有当这个构建器被实例化和配置后，过程才会结束，调用`Build()`方法。这个方法生成一个工作并调整过的服务器，最终启动。查看代码也告诉我们更多关于结构的信息：
- en: '[PRE31]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note how the `UseStartup` method connects the main program with the previously
    defined `Startup` object.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`UseStartup`方法是如何将主程序与之前定义的`Startup`对象连接起来的。
- en: Naturally, if you want to check the properties of the final, running server,
    a breakpoint in the `host.Run()`call will inform you about that in the `Services`
    and `Server Features` properties.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，如果你想检查最终运行服务器的属性，在`host.Run()`调用中的断点会告诉你关于`Services`和`Server Features`属性的信息。
- en: Of course, there is much more about the runtime and the classes it uses to configure
    and execute the server, which you'll find in the documentation, and that goes
    far beyond the scope of this introduction.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于运行时及其用于配置和执行服务器所使用的类还有很多内容，你可以在文档中找到这些内容，而且这些内容远远超出了本介绍的范畴。
- en: As for the rest of the code (the business logic), it's pretty similar to what
    we had in classic MVC, but we'll find many additions and modifications in order
    to make the architecture cross-platform, besides certain native support for common
    developer tools, such as Bower, NPM, Gulp, Grunt, and so on.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 至于其余的代码（业务逻辑），它与经典MVC中的代码非常相似，但我们会在为了使架构跨平台以及提供对常见开发者工具（如Bower、NPM、Gulp、Grunt等）的原生支持之外，找到许多新增和修改。
- en: 'A look at the `HomeController` class shows basically the same structure, with
    the exception that now the action methods are defined as being of type `IActionResult`
    instead of `ActionResult`:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`HomeController`类，基本上结构相同，只是现在动作方法被定义为`IActionResult`类型，而不是`ActionResult`类型：
- en: '[PRE32]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, we can add another action method by following exactly the same pattern.
    This happens to the **Models** section (not present here). A model should be defined
    as a **POCO** (**Plain Old CLR Object**) class, with little or no behavior. In
    this way, business logic is encapsulated and can be accessed wherever it's needed
    in the app.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过完全相同的模式添加另一个动作方法。这发生在**模型**部分（此处未显示）。模型应该被定义为一个**POCO**（**Plain Old
    CLR Object**）类，具有很少或没有行为。这样，业务逻辑就被封装起来，可以在应用程序需要的地方访问。
- en: Let's create a `Model` and an `Action` method and its corresponding view so
    that we can see how similar it is with respect to the previous version.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Model`和一个`Action`方法及其相应的视图，这样我们就可以看到它与之前版本有多么相似。
- en: 'We''ll create a new `Model` folder, and inside it, we''ll add a class named
    `PACKTAddress`, where we''ll define a few properties:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`Model`文件夹，并在其中添加一个名为`PACKTAddress`的类，我们将定义一些属性：
- en: '[PRE33]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once compiled, we can create a new action method inside `HomeController`. We
    need to create an instance of the `PACKTAddress` class, fill its properties with
    the required information, and pass it to the corresponding view, which will receive
    and present the data:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译完成，我们就可以在 `HomeController` 中创建一个新的操作方法。我们需要创建一个 `PACKTAddress` 类的实例，用所需的信息填充其属性，并将其传递给相应的视图，该视图将接收并展示数据：
- en: '[PRE34]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this, the business logic for our new view is almost ready. The next step
    is to add a new view file of the same name as the action method, that will sit
    next to its siblings in the `Views/Home` folder.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们新视图的业务逻辑几乎就准备好了。下一步是添加一个与操作方法同名的视图文件，它将位于 `Views/Home` 文件夹中其兄弟文件的旁边。
- en: In the view, we need to add a reference to the model we just passed and later
    use Tag Helpers in order to recover the data, presenting its results in the page.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们需要添加对刚刚传递的模型的引用，并使用 Tag Helpers 来恢复数据，以便在页面上展示其结果。
- en: 'This is quite easy and straightforward:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单直接：
- en: '[PRE35]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A few things should be noticed when building this view. First, we have plain
    Intellisense in the view's editor, just like we did with the classic MVC. This
    is important so that we can always make sure that the context recognizes value
    models appropriately.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建此视图时，应该注意以下几点。首先，我们在视图编辑器中具有与经典 MVC 一样的普通 Intellisense。这很重要，这样我们就可以始终确保上下文正确识别值模型。
- en: 'Thus, if we have compiled the code and everything is correct, we should see
    these helping features as we proceed with the creation of the view:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们已经编译了代码并且一切正常，我们应该在创建视图的过程中看到这些辅助功能：
- en: '![ASP.NET Core 1.0 MVC](img/image00722.jpeg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![ASP.NET Core 1.0 MVC](img/image00722.jpeg)'
- en: 'Finally, we have to integrate our new view with the main page (`_Layout.cshtml`)
    by including a new menu entry to point to the view in the same way as the previous
    entries. So, the modified menu will be as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须通过在 `_Layout.cshtml` 主页中包含一个新的菜单项来指向视图，就像之前的条目一样，将我们的新视图集成到主页中。因此，修改后的菜单将如下所示：
- en: '[PRE36]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, you''ll notice the presence of new customized attributes related to ASP.NET:
    `asp-controller`, `asp-action`, and so on. This is similar to the way we work
    with controllers when building AngularJS applications.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会注意到与 ASP.NET 相关的新自定义属性的存在：`asp-controller`、`asp-action` 等等。这与我们在构建 AngularJS
    应用程序时处理控制器的方式类似。
- en: Also, note that we pass some extra information using the `ViewData` object,
    which has been recovered for preferable use instead of the previous `ViewBag`
    object.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们使用 `ViewData` 对象传递了一些额外的信息，该对象已被恢复以供首选使用，而不是之前的 `ViewBag` 对象。
- en: 'Finally, I''ve added a link to this book''s cover in a standard image (no problems
    or configuration features for that). When we launch the application, a new menu
    element will appear, and if we go to that link, we should see the new page inside
    the main application page, just like we expected:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在标准图像（没有问题或配置功能）中添加了一个指向这本书封面的链接。当我们启动应用程序时，将出现一个新的菜单元素，如果我们点击该链接，我们应该在主应用程序页面内看到新的页面，就像我们预期的那样：
- en: '![ASP.NET Core 1.0 MVC](img/image00723.jpeg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![ASP.NET Core 1.0 MVC](img/image00723.jpeg)'
- en: Managing scripts
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理脚本
- en: 'As you''ve probably seen after a review of the folder''s contents, there are
    more `.json` files related to configuration options. Actually, in this project,
    we see several files, each one in charge of some part of the configuration. Their
    purpose is the following:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在查看文件夹内容后可能看到的，与配置选项相关的 `.json` 文件更多。实际上，在这个项目中，我们看到有几个文件，每个文件负责配置的一部分。它们的作用如下：
- en: '`launch Settings.json`: It is located under `Properties`. It configures ports,
    browsers, basic URLs, and environment variables.'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch Settings.json`：它位于 `Properties` 目录下。它配置端口、浏览器、基本 URL 和环境变量。'
- en: '`app Settings.json`: It is located at root level, and not wwwroot. It defines
    logging values and is also the place to locate other application-related data,
    such as connection strings.'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app Settings.json`：它位于根级别，而不是 wwwroot。它定义了日志值，也是放置其他应用程序相关数据的地方，例如连接字符串。'
- en: '`bower.json`: It is located at root level, and not wwwroot). It defines which
    external components have to be updated in the application, utilizing Bower services:
    Bootstrap, jQuery, and so on.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bower.json`：它位于根级别，而不是 wwwroot。它定义了应用程序中必须使用 Bower 服务更新的外部组件，例如 Bootstrap、jQuery
    等。'
- en: '`bundle Config.json`: It is located at root level, and not wwwroot. This is
    where you define which files are to be bundled and minified, indicating the original
    and final filenames in each case.'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bundle Config.json`：它位于根目录，而不是 wwwroot。这是你定义要捆绑和压缩哪些文件的地方，同时指定每种情况下的原始和最终文件名。'
- en: So, we've seen how the programming model has been improved, and there's much
    more to deal with in relation to the new Tag Helpers, other improvements in the
    modeling, data access, and so many other features that we cannot cover here, but
    I hope this has served as an introduction to the new architecture.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了编程模型的改进，还有许多与新的 Tag Helpers、建模、数据访问和其他许多我们无法在此涵盖的功能相关的改进，但我希望这已经为新的架构提供了一个介绍。
- en: NET Core 1.1
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 1.1
- en: 'A few days before closing this book''s editing process, Microsoft announced
    in the Connect() event the availability of this new version of .NET Core. This
    update also affects the related versions of the "Core" family: ASP.NET Core 1.1
    and EF Core 1.1.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭本书编辑过程的前几天，微软在 Connect() 事件中宣布了 .NET Core 新版本的可用性。这次更新也影响了“Core”系列的相关版本：ASP.NET
    Core 1.1 和 EF Core 1.1。
- en: Obviously, it's not a version with many foundational changes, nor breaking changes,
    either. The focus of the development team was to broaden the OS targets, improve
    performance, and fix bugs, fundamentally.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是一个有很多基础性变化或破坏性变化的版本。开发团队的重点是扩大操作系统目标，提高性能，并修复错误，从根本上讲。
- en: 'Thus, and according to the official page in Github ([https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.md](https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.md))
    and the team''s blog, the changes are mainly located around four different areas:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据 Github 官方页面 ([https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.md](https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.md))
    和团队博客，更改主要集中在以下四个不同领域：
- en: 'Support for the following distributions:'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持以下发行版：
- en: Red Hat Enterprise Linux 7.2
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat Enterprise Linux 7.2
- en: CentOS 7.1+
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.1+
- en: Debian 8.2+
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debian 8.2+
- en: Fedora 23, 24*
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora 23, 24*
- en: Linux Mint 17.1, 18*
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Mint 17.1, 18*
- en: Oracle Linux 7.1
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux 7.1
- en: Ubuntu 14.04 & 16.04
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 14.04 & 16.04
- en: Mac OS X 10.11, and 10.12
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac OS X 10.11, 和 10.12
- en: Windows 7+ / Server 2012 R2+
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 7+ / Server 2012 R2+
- en: Windows Nano Server TP5 Linux Mint 18
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Nano Server TP5 Linux Mint 18
- en: OpenSUSE 42.1
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSUSE 42.1
- en: MacOS 10.12 (also added to .NET Core 1.0)
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MacOS 10.12（也添加到 .NET Core 1.0）
- en: Windows Server 2016 (also added to .NET Core 1.0)
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Server 2016（也添加到 .NET Core 1.0）
- en: Performance improvements, which had led to surpass the benchmarks obtained by
    Node and Nginx (reaching in ASP.NET Core 1,15 million requests/second)
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能改进，这导致了超过 Node 和 Nginx 获得的基准测试（达到 ASP.NET Core 1,15百万请求/秒）
- en: Several new features added to the API's and hundreds of bug fixes
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 中添加了几个新功能，以及数百个错误修复
- en: A serious update to the documentation, now, more accessible and comprehensive
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在的文档进行了重大更新，现在更加易于访问和全面
- en: 'As for ASP.NET Core 1.1, the documentation states that this release was designed
    around the following feature themes in order to help developers:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ASP.NET Core 1.1，文档指出，这个版本的设计围绕以下功能主题，以帮助开发者：
- en: Improved and cross-platform compatible site hosting capabilities when using
    a host other than Windows Internet Information Server (IIS)
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用除 Windows Internet Information Server (IIS) 以外的主机时，改进了和跨平台兼容的网站托管能力
- en: Support for developing with native Windows capabilities
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用原生 Windows 功能进行开发
- en: Compatibility, portability and performance of middleware and other MVC features
    throughout the UI framework
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个 UI 框架中，中间件和其他 MVC 功能的兼容性、可移植性和性能
- en: Improved deployment and management experience of ASP.NET Core applications on
    Microsoft Azure
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善了在 Microsoft Azure 上部署和管理 ASP.NET Core 应用程序的经验
- en: For additional details on the news offered by this version, you can read the
    article *Announcing the Fastest ASP.NET Yet, ASP.NET Core 1.1 RTM*, at [https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/](https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此版本提供的新闻的更多详细信息，您可以阅读文章 *Announcing the Fastest ASP.NET Yet, ASP.NET Core
    1.1 RTM*，在 [https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/](https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/)。
- en: Summary
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we saw three not-well-known aspects for distinct reasons,
    and that included a brief introduction to the new .NET Core and ASP.NET Core proposals
    that Microsoft presented officially this year.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后一部分，我们看到了三个不太为人所知的方面，其中包括对微软今年正式提出的新的 .NET Core 和 ASP.NET Core 方案的简要介绍。
- en: This is the last chapter of this book in which I've reviewed the state of .NET
    Programming using (mainly, but not exclusively), the C# language.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，我在其中回顾了使用（主要是，但不仅限于）C# 语言来进行的 .NET 编程状态。
- en: We made a historic tour of the language in its different versions, including
    the latest stable, C# 7, and we've seen with a bunch of examples the way it behaves
    and how we can use it in distinct contexts and application scenarios.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对语言的不同版本进行了历史性的回顾，包括最新的稳定版 C# 7，并通过一系列示例展示了它在不同上下文和应用场景中的行为以及如何使用它。
- en: We've also compared languages taking a sneak peek at other proposals, like the
    functional language F# and the popular TypeScript.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还比较了其他提案，如功能型语言 F# 和流行的 TypeScript。
- en: Data management has been another important topic, covering the two most popular
    models today (SQL and NoSQL), sampling how to use both, their advantages and caveats.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 数据管理也是一个重要的主题，涵盖了当今最流行的两种模型（SQL 和 NoSQL），展示了如何使用这两种模型，它们的优点和注意事项。
- en: Finally, we've dedicated several chapters to traversal techniques which imply
    the whole application, like architecture, good practices, security and performance,
    to end with this miscellaneous chapter.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们专门用几章内容介绍了遍历技术，这些技术涉及到整个应用程序，如架构、良好实践、安全性和性能，并以这一杂项章节结束。
- en: I, sincerely, expect this text serves you as a reference on the many possibilities
    that a .NET programmer has today, and, possibly opens new paths and channels of
    development for your needs.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望这篇文章能作为您参考，了解 .NET 程序员今天所拥有的许多可能性，并可能为您的需求开辟新的路径和渠道。
