- en: Chapter 9. Enter Sound – Adding Sound and Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will talk a bit about the concept of sound in creative coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to load and play sound in Cinder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to modify sound in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use audio data to draw and animate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make use of live sound input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and playing a sound file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways of using sound in creative coding. One way is to use
    audio samples, another one is to use live input, and then there is the possibility
    of generating sound from scratch. Nevertheless, a lot more possibilities emerge
    when you start to combine all of these approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn to load, play, and visualize audio files and
    capture live input. To get started, open TinderBox and make another project with
    the name `BasicAudio`. Open `xcode/BasicAudio.xcodeproj` (`vc10\BasicAudio.sln`
    on Windows). Open `BasicAudioApp.cpp` in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the basic audio features of Cinder, we have to import the appropriate
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This particular one contains all the code that is needed to load and play back
    an audio file. Go and find your own audio file (`mp3` or `wav` will work), and
    place it in the project's `assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need an `audio::SourceRef` object for storing the reference to the
    audio source that we will use in our code. Add the following line to your class
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet into the `setup()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will load the audio file into the computer memory as the `audio::Source`
    object and save a reference in the `src` variable. Then, we can play the sound
    by using the `audio::Output::play()` class method.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run our application. You should hear the sound. There are some limitations
    with this way of playing the sound back. It is not possible to apply the loop
    control to it in any other way (except for setting and getting the volume).
  prefs: []
  type: TYPE_NORMAL
- en: Using tracks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cinder `Track` class provides more control over a sound file. Let's go over
    a couple of features of the `Track` class that we might use most often.
  prefs: []
  type: TYPE_NORMAL
- en: 'To loop the loaded audio file, we will need to add a `Track` object to the
    `Output` object and save the returned track reference so that we can use it to
    control the sound later. Add a variable for storing the track reference in the
    class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code in the `setup()` method implementation with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will basically do the same as before for now, except that it will store
    the `audio::Source` pointer as a separate track in the `audio::Output` object.
    The `addTrack()` function has another parameter, `autoplay`, which is automatically
    set to `true` if we don''t provide the other value. Let''s try to set it to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we set the `autoplay` parameter to `false`, audio file is not played after
    it is loaded. We can use this approach if we want the audio file to be played
    at some other point of the application flow. Use the following code to play it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We used the arrow syntax here because the track reference is just a C++ pointer
    to the actual `Track` object. All other properties of the track are accessed in
    the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: We can add more than one track to the `Output` object by creating a new audio
    source object and adding it to the `audio::Output` pointer. We won't do it now,
    but keep in mind that this is possible in case we want to create some kind of
    multilayer audio application.
  prefs: []
  type: TYPE_NORMAL
- en: Changing track parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next thing that we want to do is to make the audio file play again after it
    has finished playing. It is possible by setting the looping of the track to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will make the track loop infinite.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that we might want to do is to change the track volume. You can
    think of the `Output` volume as the master volume and the `Track` volumes as individual
    track volumes of a mixer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the volume, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can use variables to dynamically change the volume of the sound. Let's do
    that for both master and track volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the class declaration of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With these lines of code, we declare two floats that will store the master and
    track volumes and a `mouseMove` method override of the `AppBasic` class that will
    let us respond to mouse movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to the `setup()` method implementation and initialize the `masterVol`
    and `trackVol` variables, additionally change the raw values of `trackRef->setVolume()`
    and `audio::Output::setVolume()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation of the `mouseMove` method at the end of the file, before
    the `CINDER_APP_BASIC()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: An `event` object of the type `MouseEvent` is passed to this method. We can
    get the current location of the mouse cursor at the time of the event as well
    as many other parameters that the `event` object holds. We will stick to the mouse
    `x` and `y` coordinates for now and use them for changing the volume.
  prefs: []
  type: TYPE_NORMAL
- en: For changing the master volume, we are using the `x` coordinate. We are using
    the `y` coordinate for the track volume.
  prefs: []
  type: TYPE_NORMAL
- en: As volume of the sound in Cinder is defined in a range from `0.0f` to `1.0f`,
    we need to transform the mouse positions in this kind of form. To do that, we
    need to divide the actual mouse position with its maximum range that is the width
    and height of the window. So, if the mouse `x` position is `0` and window width
    is `100`, after dividing the coordinate with the window width (0/100) we get `0`.
    If the mouse `x` position is `100`, we get `1`. Additionally, if the mouse `x`
    position is `50`, we get `0.5` (50/100).
  prefs: []
  type: TYPE_NORMAL
- en: As the mouse positions and window dimensions are returned as `int` values, we
    will need to cast one of the values to `float` for a successful floating point
    number operation. That is why there is `(float)` before the `event.getX()/getWindowWidth()`
    and `event.getY()/getWindowHeight()` parts of the code, it casts the `int` value
    returned by `event.getX()` to `float`. Finally, we set the master volume and track
    volume with `audio::Output::setVolume(masterVol);` and `trackRef->setVolume(trackVol);`.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run our application. Move the mouse, you should hear how the volume
    of the sound is changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next useful feature that we might want to learn is jumping to a certain position
    of the time of the track. To do that, we will use the `mouseDrag` method of the
    `AppBasic` class. Let''s declare an override of it by adding the following line
    to the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement that. Add the following code at the end of the file, before
    the `CINDER_APP_BASIC()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the application window's width is being mapped to the duration
    of the track. The `x` position of the mouse is being transformed to a specific
    time in the audio track. The `trackRef->setTime(time)` part of the code sets the
    position of the track playhead.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run our application. You should be able to do live seeking now.
    Click and drag to try that out.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one important thing missing in our creative sound application—the visual
    side of it. Let's create a simple equalizer.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will need to enable the PCM buffering of the audio track.
  prefs: []
  type: TYPE_NORMAL
- en: '**PCM** stands for **pulse code modulation** and it is a method for digitally
    representing sampled analog signals. An analog audio signal is the fluctuation
    of voltage inside a conductor. A digital representation of that are samples or
    bytes with floating point values usually from `-1` to `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the world of audio sampling there is a term, sampling rate, which represents
    the amount of samples or values being sampled each second. The PCM values and
    sampling rate of an audio file determine its playback speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable PCM buffering and be able to read PCM values during application runtime,
    add the following code in the `setup()` method''s declaration before `trackRef->play()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Second, we need a variable that will serve as a pointer to the track's PCM buffer.
  prefs: []
  type: TYPE_NORMAL
- en: A PCM buffer is the secret place in computer memory where the raw values of
    the sound wave coming out from our speakers reside. Before any sound is sent to
    the audio output, it is kept in the buffer for some time. When the sound is played,
    the buffer is cleared and filled again with new audio data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to access the PCM buffer to read the raw waveform values from
    it. Add the following line to the class declaration to add a variable that will
    serve as a reference to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we need to get a copy of the most recent buffer in each frame. Add the
    following code to the `update()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the `draw()` method implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run our application, you should see an image as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing audio](img/9564_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using audio input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How about using a microphone or line-in as the audio source? No problem. To
    make this possible, we will need to import the audio `Input` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to extend our current application so that we can switch between
    live input and playback of the loaded file. We will need to declare two new variables
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first variable represents our sound input, and we will use the second one
    as a switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to initialize the `input` variable, so go to the `setup()` method
    implementation and add the following line there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This assigns the default audio input to the `input` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `mouseDown` method override and fill it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These lines of code handle the switching between live and loaded input. Every
    time the mouse is clicked, the `useInput` variable is inverted from `false` to
    `true` or vice versa. Depending on the value we get, we enable the live or loaded
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, replace the code in the `update()` method implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These lines of code get the current PCM buffer. If the `useInput` variable is
    set to `true`, we use the PCM buffer of the live input, if not, we use the PCM
    buffer of the loaded track.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run the application. Click on the window to enable live input. Click
    again to return to the loaded sound.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned the basics of audio in Cinder. We learned how to
    load and play back an audio file, how to change its volume, and seek and visualize
    the PCM buffer. We also learned how to use live input audio data.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, now we are able to create audio-reactive applications that
    are capable of analyzing almost any kind of sound in real time and provide high
    performance visual feedback. Audio analysis is a broad topic and you may want
    to study it further. Try to Google "FFT", "octave analysis", or "beat tracking",
    for example. It is also possible to use some kind of third-party audio processing
    library, if the features that Cinder provides in terms of audio processing are
    not enough for you.
  prefs: []
  type: TYPE_NORMAL
