<html><head></head><body>
<div id="_idContainer188">
<h1 class="chapterNumber"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 class="chapterTitle" id="_idParaDest-148"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.2.1">Practical Microservices Organization with Kubernetes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter is dedicated to a fundamental building block of microservice applications: orchestrators! </span><span class="koboSpan" id="kobo.3.2">The focus </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.4.1">is on </span><strong class="keyWord"><span class="koboSpan" id="kobo.5.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.6.1">, but the concepts learned here are fundamental for understanding other orchestration options. </span><span class="koboSpan" id="kobo.6.2">In particular, </span><strong class="keyWord"><span class="koboSpan" id="kobo.7.1">Azure Container Apps</span></strong><span class="koboSpan" id="kobo.8.1"> is a serverless </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.9.1">alternative to Kubernetes, implemented with Kubernetes itself, and uses simplified configuration options, but the objects to configure and concepts involved are exactly the same. </span><span class="koboSpan" id="kobo.9.2">Azure Container Apps is described in </span><a href="Chapter_9.xhtml#_idTextAnchor261"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Simplifying Containers and Kubernetes: Azure Container Apps</span></em><em class="italic"><span class="koboSpan" id="kobo.12.1"> and other Tools</span></em><span class="koboSpan" id="kobo.13.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.14.1">All concepts will be exemplified with small examples and with the car-sharing book case study applicati</span><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.15.1">on. </span><span class="koboSpan" id="kobo.15.2">After a general description of orchestrators’ role and functionalities, we will describe how to configure and interact in practice with a Kubernetes cluster. </span><span class="koboSpan" id="kobo.15.3">We will use </span><strong class="keyWord"><span class="koboSpan" id="kobo.16.1">Minikube</span></strong><span class="koboSpan" id="kobo.17.1">, which is a local </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.18.1">simulator of a Kubernetes cluster, throughout the chapter. </span><span class="koboSpan" id="kobo.18.2">However, we will also explain how to create and use a Kubernetes Azure cluster.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">We will also describe how to test and debug the interaction of some microservices during development with </span><strong class="keyWord"><span class="koboSpan" id="kobo.20.1">Docker </span></strong><span class="koboSpan" id="kobo.21.1">first, and then </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.22.1">the complete application running in a Kubernetes </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.23.1">cluster. </span><span class="koboSpan" id="kobo.23.2">A .NET-specific alternative for testing a microservices application in the development stage is </span><strong class="keyWord"><span class="koboSpan" id="kobo.24.1">.NET Aspire</span></strong><span class="koboSpan" id="kobo.25.1">, which will be described in </span><a href="Chapter_12.xhtml#_idTextAnchor345"><em class="italic"><span class="koboSpan" id="kobo.26.1">Chapter 12</span></em></a><em class="italic"><span class="koboSpan" id="kobo.27.1">, Simplifying Microservices with .NET Aspire</span></em><span class="koboSpan" id="kobo.28.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.29.1">More specifically, this chapter cov</span><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.30.1">ers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Introduc</span><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.32.1">tion to orchestrators and their configuration</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.33.1">Kubernetes basics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.34.1">Interacting with Kubernetes: Kubectl and Minikube</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.35.1">Configuring your application in Kubern</span><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.36.1">etes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.37.1">Running your microservices on Kubernetes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.38.1">Advanced Kubernetes configuration</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-149"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.39.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.40.1">This chapter requires:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.41.1">At least the Visual Studio 2022 free </span><em class="italic"><span class="koboSpan" id="kobo.42.1">community edition</span></em><span class="koboSpan" id="kobo.43.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.44.1">An SQL instance accepting TCP/IP requests and user/password authentication, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">Docker Desktop</span></strong><span class="koboSpan" id="kobo.46.1"> for Windows, the installation for which was explained in the </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Technical requirements</span></em><span class="koboSpan" id="kobo.48.1"> section of </span><a href="Chapter_7.xhtml#_idTextAnchor151"><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.50.1">, Microservices in Practice</span></em><span class="koboSpan" id="kobo.51.1">.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.52.1">If you would like to interact with a Kubernetes cluster on Azure, you need Azure CLI. </span><span class="koboSpan" id="kobo.52.2">The page at </span></strong><a href="https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli"><span class="url"><span class="koboSpan" id="kobo.53.1">https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli</span></span></a><strong class="keyWord"><span class="koboSpan" id="kobo.54.1"> contains the links to both the 32-bit and 64-bit Windows installers.</span></strong></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.55.1">Minikube</span></strong><span class="koboSpan" id="kobo.56.1">: The easiest way to install Minikube is by using the Windows installer you can find on the official installation page: </span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="url"><span class="koboSpan" id="kobo.57.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">During the installation, you will be prompted on the kind of virtualization tool to use – please specify Docker. </span><span class="koboSpan" id="kobo.58.3">The previous link also gives a PowerShell command for adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">minicube.exe</span></code><span class="koboSpan" id="kobo.60.1"> to the Windows path.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.61.1">Kubectl</span></strong><span class="koboSpan" id="kobo.62.1">: First of all, verify if it is already installed by opening a Windows console and issuing this command: </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">Kubectl -h</span></code><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">If the response is the list of all Kubectl commands, it is already installed. </span><span class="koboSpan" id="kobo.64.3">Otherwise, the simplest way to install it is through the </span><strong class="keyWord"><span class="koboSpan" id="kobo.65.1">Chocolatey</span></strong><span class="koboSpan" id="kobo.66.1"> package installer:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.67.1">choco install kubernetes-cli
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.68.1">If Chocolatey is not already installed, you can install it by launching </span><strong class="keyWord"><span class="koboSpan" id="kobo.69.1">PowerShell</span></strong><span class="koboSpan" id="kobo.70.1"> in administrative mode and then issuing the PowerShell command suggested on the official Chocolatey page: </span><a href="https://chocolatey.org/install#individual"><span class="url"><span class="koboSpan" id="kobo.71.1">https://chocolatey.org/install#individual</span></span></a><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">You can launch PowerShell</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.73.1">in administrative mode as follows:</span><ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1"><span class="koboSpan" id="kobo.74.1">Search </span><strong class="keyWord"><span class="koboSpan" id="kobo.75.1">PowerShell</span></strong><span class="koboSpan" id="kobo.76.1"> in the Windows search box.</span></li>
<li class="alphabeticList level-2"><span class="koboSpan" id="kobo.77.1">Right-click on the </span><strong class="keyWord"><span class="koboSpan" id="kobo.78.1">PowerShell</span></strong><span class="koboSpan" id="kobo.79.1"> link and select to execute it as an administrator.</span></li>
</ol>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.80.1">You can find the sample code for this chapter at </span><a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp"><span class="url"><span class="koboSpan" id="kobo.81.1">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</span></span></a><span class="koboSpan" id="kobo.82.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-150"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.83.1">Introduction to orchestrators and their configuration</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.84.1">Orchestrators were mainly conceived for balancing microservices’ load. </span><span class="koboSpan" id="kobo.84.2">Therefore, one might ask if they are necessary for all applications. </span><span class="koboSpan" id="kobo.84.3">I can’t say they are necessary, but, for sure, renouncing them </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.85.1">doesn’t mean just manually configuring where to place each replica of each microservice. </span><span class="koboSpan" id="kobo.85.2">We should also find efficacious solutions for dynamically reconfiguring the number of replicas and their locations, for balancing the load among several replicas allocated on different servers, and for balancing the traffic among the various replicas of each microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">The above </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.87.1">simple considerations show that an efficacious orchestrator should offer at least the following services:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.88.1">Accepting high-level specifications and translating them into actual allocations of microservice replicas on different servers of a given cluster.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.89.1">Providing a unique virtual address for all replicas of the same microservices and automatically splitting the traffic among them. </span><span class="koboSpan" id="kobo.89.2">This way, the code of each microservice can reference just this unique virtual address without caring where each replica is.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.90.1">Recognizing faulty replicas, killing them, and replacing them with newly created replicas.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.91.1">Downloading microservices container images from container registries.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.92.1">Moreover, since microservice replicas are ephemeral and can be destroyed and moved from one server to another, they can’t use the disk storage of the servers that host them. </span><span class="koboSpan" id="kobo.92.2">Instead, they must use network storage. </span><span class="koboSpan" id="kobo.92.3">Orchestrators must also provide simple ways to allocate disk storage and mount it inside the containers where the microservices run. </span><span class="koboSpan" id="kobo.92.4">In general, they must provide easy ways of projecting everything that can be projected inside a container, namely:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.93.1">Disk storage</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.94.1">Environment variables</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.95.1">Communication ports</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.96.1">As a matter of fact, each orchestrator also offers other services, but the seven services listed above are the starting point for learning and assessing any orchestrator.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.97.1">The behavior of an orchestrator is controlled with tree-like settings coming from various sources: configuration files, command arguments, and so on. </span><span class="koboSpan" id="kobo.97.2">Behind the curtain, all sources are packaged by a </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.98.1">client that communicates with an orchestrator web API.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.99.1">All possible orchestrator settings are organized like .NET configuration settings in a tree data structure. </span><span class="koboSpan" id="kobo.99.2">Therefore, analogously to .NET settings, they can be provided in JSON format or other equivalent formats. </span><span class="koboSpan" id="kobo.99.3">As a matter of fact, all orchestrators accept settings either in JSON or in another equivalent format called </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">.yaml</span></code><span class="koboSpan" id="kobo.101.1">. </span><span class="koboSpan" id="kobo.101.2">Some orchestrators accept both formats; others might accept just one of them. </span><span class="koboSpan" id="kobo.101.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">.yaml</span></code><span class="koboSpan" id="kobo.103.1"> format is described in the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-151"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.104.1">.yaml files</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">.yaml</span></code><span class="koboSpan" id="kobo.106.1"> files, like JSON files, can be used to describe nested objects and collections in a human-readable way, but they do it with a different syntax. </span><span class="koboSpan" id="kobo.106.2">You have objects and lists, but object properties are </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.107.1">not surrounded by </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">{}</span></code><span class="koboSpan" id="kobo.109.1">, and lists are not surrounded by </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">[]</span></code><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">Instead, nested objects are declared by simply indenting their content with spaces. </span><span class="koboSpan" id="kobo.111.3">The number </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.112.1">of spaces can be freely chosen, but once they’ve been chosen, they must be used consistently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.113.1">List items can be distinguished from object properties by preceding them with a hyphen (-). </span><span class="koboSpan" id="kobo.113.2">Below, there is an example involving nested objects and collections:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.114.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.115.1">John</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.116.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.117.1">Smith</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.118.1">Spouse:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.119.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.120.1">Mary</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.121.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.122.1">Smith</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.123.1">Addresses:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.124.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.125.1">Type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.126.1">home</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.127.1">Country:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.128.1">England</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.129.1"># I am a comment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.130.1">Town:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.131.1">London</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.132.1">Street:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.133.1">My</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.134.1">home</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.135.1">street</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.136.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.137.1">Type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.138.1">office</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.139.1">Country:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.140.1">England</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.141.1">Town:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.142.1">London</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.143.1">Street:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.144.1">My</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.145.1">home</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.146.1">street</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.147.1">In each line, all characters following a </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">#</span></code><span class="koboSpan" id="kobo.149.1"> character are considered comments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.150.1">The previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">Person</span></code><span class="koboSpan" id="kobo.152.1"> object has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.153.1">Spouse</span></code><span class="koboSpan" id="kobo.154.1"> nested object and a nested collection of addresses. </span><span class="koboSpan" id="kobo.154.2">The same example in JSON would be:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation"><span class="koboSpan" id="kobo.155.1">{</span></span><span class="koboSpan" id="kobo.156.1">
Name</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.157.1">:</span></span><span class="koboSpan" id="kobo.158.1"> John
Surname</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.159.1">:</span></span><span class="koboSpan" id="kobo.160.1"> Smith
Spouse</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.161.1">:</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.162.1">{</span></span><span class="koboSpan" id="kobo.163.1">
  Name</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.164.1">:</span></span><span class="koboSpan" id="kobo.165.1"> Mary
  Surname</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.166.1">:</span></span><span class="koboSpan" id="kobo.167.1"> Smith
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.168.1">}</span></span><span class="koboSpan" id="kobo.169.1">
Addresses</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.170.1">:</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.171.1">[</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.172.1">{</span></span><span class="koboSpan" id="kobo.173.1">
  Type</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.174.1">:</span></span><span class="koboSpan" id="kobo.175.1"> home
  Country</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.176.1">:</span></span><span class="koboSpan" id="kobo.177.1"> England
  Town</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.178.1">:</span></span><span class="koboSpan" id="kobo.179.1"> London
  Street</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.180.1">:</span></span><span class="koboSpan" id="kobo.181.1"> My home street
 </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.182.1">},</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.183.1">{</span></span><span class="koboSpan" id="kobo.184.1">
  Type</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.185.1">:</span></span><span class="koboSpan" id="kobo.186.1"> office
  Country</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.187.1">:</span></span><span class="koboSpan" id="kobo.188.1"> England
  Town</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.189.1">:</span></span><span class="koboSpan" id="kobo.190.1"> London
  Street</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.191.1">:</span></span><span class="koboSpan" id="kobo.192.1"> My home street
 </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.193.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.194.1">]</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.195.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.196.1">As you can see, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">.yaml</span></code><span class="koboSpan" id="kobo.198.1"> syntax is more readable, since it avoids the overhead of parentheses.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">.yaml</span></code><span class="koboSpan" id="kobo.200.1"> files can contain </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.201.1">several sections, each defining a different object, that are </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.202.1">separated by a line containing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">---</span></code><span class="koboSpan" id="kobo.204.1"> string. </span><span class="koboSpan" id="kobo.204.2">Comments are preceded by a # symbol, which must be repeated on each comment line.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.205.1">Since spaces/tabs contribute to object semantics, YAML is space/tabs sensitive, so attention must be paid to add the right number of spaces. </span></p>
</div>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.206.1">Small collections or small objects can also be specified in-line with the usual </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">[]</span></code><span class="koboSpan" id="kobo.208.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">{}</span></code><span class="koboSpan" id="kobo.210.1"> syntax, that is, after the colon in the same line of the property they are the value of.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.211.1">With the basics of orchestrators and </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">.yaml</span></code><span class="koboSpan" id="kobo.213.1"> files, we are ready to learn about the most widespread orchestrator: </span><strong class="keyWord"><span class="koboSpan" id="kobo.214.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.215.1">. </span><span class="koboSpan" id="kobo.215.2">At the moment, it is also the most complete. </span><span class="koboSpan" id="kobo.215.3">So, once you’ve learned about it, learning about other orchestrators should be very easy.</span></p>
<h1 class="heading-1" id="_idParaDest-152"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.216.1">Kubernetes basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.217.1">The Kubernetes </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.218.1">orchestrator is distributed software that must be installed on all virtual servers of a network. </span><span class="koboSpan" id="kobo.218.2">Most of the Kubernetes software is installed on just some machines that are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.219.1">master nodes</span></strong><span class="koboSpan" id="kobo.220.1">, while all </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.221.1">other machines run just interface software </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.222.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.223.1">Kubelet</span></strong><span class="koboSpan" id="kobo.224.1"> that connects with the software running on the master nodes and locally executes tasks decided on by the master nodes. </span><span class="koboSpan" id="kobo.224.2">All machines in a Kubernetes </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.225.1">cluster are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.226.1">nodes</span></strong><span class="koboSpan" id="kobo.227.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">Actually, all nodes must also run a container runtime in order to be able to run containers. </span><span class="koboSpan" id="kobo.228.2">As we will see later on, all nodes also run software that handles virtual addressing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.229.1">Kubernetes configuration units are abstract objects with properties, subparts, and references to other objects. </span><span class="koboSpan" id="kobo.229.2">They are </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.230.1">referred to as </span><strong class="keyWord"><span class="koboSpan" id="kobo.231.1">Kubernetes resources</span></strong><span class="koboSpan" id="kobo.232.1">. </span><span class="koboSpan" id="kobo.232.2">We have resources that describe a single microservice replica and other resources that describe a set of replicas. </span><span class="koboSpan" id="kobo.232.3">Resources describe communication settings, disk storage, users, roles, and various kinds of security constraints.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.233.1">Cluster nodes and </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.234.1">all resources they host are managed by master nodes that communicate with human cluster administrators through an API server, as shown in the following diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.235.1"><img alt="Figure 8.1: Kubernetes cluster" src="../Images/B31916_08_1.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.236.1">Figure 8.1: Kubernetes cluster</span></p>
<p class="normal"><span class="koboSpan" id="kobo.237.1">Kubectl is the client typically used to send commands and configuration data to the API server. </span><span class="koboSpan" id="kobo.237.2">The scheduler allocates resources to nodes according to the administrator constraints, while the controller manager groups several daemons that monitor the cluster’s actual state and try to move it toward the desired state declared through the API server. </span><span class="koboSpan" id="kobo.237.3">There are controllers for several Kubernetes resources, from Microservices replicas to communication facilities. </span><span class="koboSpan" id="kobo.237.4">In fact, each resource has some target objectives to be maintained while the application runs, and the controller verifies these objectives are actually achieved, possibly triggering corrective actions, such as moving </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.238.1">some pods running too slowly onto less crowded nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.239.1">The deployment unit, that is, the unit that can be deployed on a server, started, killed, and/or moved to another server, is not a single </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.240.1">container, but a set of containers called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.241.1">Pod</span></strong></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.242.1">A Pod is a set of containers that are constrained to run all together on the same server..</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.243.1">The concept of the Pod is fundamental since it enables very useful, strong cooperation patterns. </span><span class="koboSpan" id="kobo.243.2">For instance, we may attach another container to our main container whose unique purpose is to read the log files created by the main container and send them to a centralized log service.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.244.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.245.1">Sidecar</span></strong><span class="koboSpan" id="kobo.246.1"> pattern consists </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.247.1">of enhancing a main container with a secondary container deployed on the same Pod and whose only purpose is to offer some services to the main container.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.248.1">In general, we put several containers together inside the same Pod when we need them to communicate through their node file system, or when we need each container replica to be somehow associated with a specific replica of other containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.249.1">In Kubernetes, communication between </span><strong class="keyWord"><span class="koboSpan" id="kobo.250.1">Pods</span></strong><span class="koboSpan" id="kobo.251.1"> is handled by </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.252.1">resources called </span><strong class="keyWord"><span class="koboSpan" id="kobo.253.1">Services </span></strong><span class="koboSpan" id="kobo.254.1">that are assigned virtual addresses by the Kubernetes infrastructure and that forward their communications to sets of pods that satisfy some constraints. </span><span class="koboSpan" id="kobo.254.2">In short, Services are Kubernetes’ way to assign constant virtual addresses to sets of </span><strong class="keyWord"><span class="koboSpan" id="kobo.255.1">Pods</span></strong><span class="koboSpan" id="kobo.256.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">All Kubernetes resources </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.258.1">may be assigned name-value pairs called </span><strong class="keyWord"><span class="koboSpan" id="kobo.259.1">labels</span></strong><span class="koboSpan" id="kobo.260.1"> that are used to reference them through a pattern-matching mechanism. </span><span class="koboSpan" id="kobo.260.2">Thus, for instance, all </span><strong class="keyWord"><span class="koboSpan" id="kobo.261.1">Pods</span></strong><span class="koboSpan" id="kobo.262.1"> that receive traffic from the same </span><strong class="keyWord"><span class="koboSpan" id="kobo.263.1">Service </span></strong><span class="koboSpan" id="kobo.264.1">are selected by specifying labels that they must have in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.265.1">Service</span></strong><span class="koboSpan" id="kobo.266.1"> definition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.267.1">Kubernetes clusters </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.268.1">can be on-premises, that is, Kubernetes may be installed on any private network. </span><span class="koboSpan" id="kobo.268.2">But, more often, they are offered as cloud services. </span><span class="koboSpan" id="kobo.268.3">For instance, Azure offers </span><strong class="keyWord"><span class="koboSpan" id="kobo.269.1">Azure Kubernetes Service (AKS)</span></strong><span class="koboSpan" id="kobo.270.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.271.1">In the remainder of the book, we will </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.272.1">use the </span><strong class="keyWord"><span class="koboSpan" id="kobo.273.1">Minikube</span></strong><span class="koboSpan" id="kobo.274.1"> Kubernetes simulator running on your development machine, since an actual AKS service might quickly exhaust all your Azure free credits. </span><span class="koboSpan" id="kobo.274.2">However, all operations in our examples can be replicated on an actual cluster, and whenever there are differences, we will also describe how to perform operations on AKS.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.275.1">Let’s start by interacting with a Kubernetes cluster.</span></p>
<h1 class="heading-1" id="_idParaDest-153"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.276.1">Interacting with Kubernetes: Kubectl, Minikube, and AKS</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.277.1">Before interacting with a Kubernetes cluster with the Kubectl client, we must configure Kubectl and furnish </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.278.1">it with both the cluster URL and the necessary credentials.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.279.1">Once installed, Kubectl creates </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.280.1">a different JSON configuration file for each computer user, which will contain configuration info for all Kubernetes clusters and their users. </span><span class="koboSpan" id="kobo.280.2">Kubectl has commands for inserting new Kubernetes cluster configurations and for making a cluster configuration the current one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.281.1">Each pair made of a </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.282.1">Kubernetes cluster API URL plus a user credential is called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.283.1">context</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">Contexts, credentials, and cluster connections can be defined with various </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">kubectl config</span></code><span class="koboSpan" id="kobo.286.1"> subcommands. </span><span class="koboSpan" id="kobo.286.2">Below are the most useful ones:</span></p>
<ol>
<li class="alphabeticList" value="1"><span class="koboSpan" id="kobo.287.1">Viewing the overall configuration file:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.288.1">kubectl config view
</span></code></pre>
</li>
<li class="alphabeticList"><span class="koboSpan" id="kobo.289.1">Adding a new Kubernetes cluster:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.290.1">kubectl config set-cluster my-cluster --server=https://&lt;your cluster API server URL&gt;
</span></code></pre>
</li>
<li class="alphabeticList"><span class="koboSpan" id="kobo.291.1">User credentials are based on client certificates. </span><span class="koboSpan" id="kobo.291.2">A valid certificate can be obtained by creating a certificate request and submitting it to the Kubernetes cluster, which will create an approved certificate. </span><span class="koboSpan" id="kobo.291.3">The detailed procedure will be shown in </span><a href="Chapter_10.xhtml#_idTextAnchor297"><em class="italic"><span class="koboSpan" id="kobo.292.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.293.1">, Security and Observability for Serverless and Microservices Applications</span></em><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">Once you get an approved certificate, the user can be created with:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.295.1">Kube</span><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.296.1">ctl config set-credentials newusername --client-key= newusername.key --client-certificate=poweruser.crt --embed-certs=true
</span></code></pre>
</li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.297.1">Where </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">newusername.key</span></code><span class="koboSpan" id="kobo.299.1"> is the complete path to the private key you used to create the certificate request, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">newusername.crt</span></code><span class="koboSpan" id="kobo.301.1"> is the complete path of the approved certificate file.</span></p>
<ol>
<li class="alphabeticList" value="4"><span class="koboSpan" id="kobo.302.1">Once you have both a server and a user, you can create a context for the connection of that user to that server, with:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.303.1">kubectl config set-context newcontext --cluster= my-cluster --user= newusername
</span></code></pre>
</li>
<li class="alphabeticList"><span class="koboSpan" id="kobo.304.1">Once all the contexts you need have been properly defined, you can switch to a given context with:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.305.1">kubectl config use-context newcontext
</span></code></pre>
</li>
<li class="alphabeticList"><span class="koboSpan" id="kobo.306.1">After having set a new current context, all Kubectl commands will use both the cluster and the user defined in that context.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.307.1">If you are the cluster </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.308.1">administrator, your user already exists in the system, so you don’t need to create it. </span><span class="koboSpan" id="kobo.308.2">However, you need to get the administrator user credentials and add them to your configuration file. </span><span class="koboSpan" id="kobo.308.3">Each cloud service has a login procedure that does this job. </span><span class="koboSpan" id="kobo.308.4">For instance, in the case of AKS, the procedure is:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.309.1">Log in to Azure with Azure CLI:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.310.1">az login
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.311.1">The default browser should open, and you should be prompted for your Azure credentials.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.312.1">If not already installed, install the package for interacting with AKS:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.313.1">az aks install-cli
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.314.1">Ask to add your AKS credentials to your Kubectl configuration file:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.315.1">az aks get-credentials --resource-group &lt;your AKS resource group name&gt; --name &lt;your AKS name&gt;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.316.1">If the command is successful, a new cluster, new user, and new context will be added to your Kubectl configuration, and the new context will be made the current one. </span><span class="koboSpan" id="kobo.316.2">Please run </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">kubectl config view</span></code><span class="koboSpan" id="kobo.318.1"> to see all configuration file modifications.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.319.1">Minikube comes with a default user, a default cluster name, and a default context, which are all called </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">minikube</span></code><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">When you start your Minikube cluster with </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">minikube start</span></code><span class="koboSpan" id="kobo.323.1">, if not already defined, all the above entities will be added to your Kubectl configuration file. </span><span class="koboSpan" id="kobo.323.2">Moreover, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">minikube</span></code><span class="koboSpan" id="kobo.325.1"> context will be automatically made the current one, so no extra actions are needed after you start your cluster. </span><span class="koboSpan" id="kobo.325.2">Of course, you may define other users and other contexts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.326.1">Minikube can be stopped with </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">minikube stop</span></code><span class="koboSpan" id="kobo.328.1">, and paused with </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">minikube pause</span></code><span class="koboSpan" id="kobo.330.1">. </span><span class="koboSpan" id="kobo.330.2">Both stopping and pausing do not delete the cluster data and configuration. </span><span class="koboSpan" id="kobo.330.3">Other useful commands will be shown later on while using Minikube in our examples.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.331.1">Let’s try some Kubectl commands on Minikube (ensure Minikube has been started):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.332.1">kubectl get nodes
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.333.1">It should show </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.334.1">all virtual network Kubernetes nodes. </span><span class="koboSpan" id="kobo.334.2">As the default, Minikube creates a cluster with a single node called </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">minikube</span></code><span class="koboSpan" id="kobo.336.1">, so you should see something like:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.337.1">NAME       STATUS            ROLES               AGE   VERSION
minikube   Ready    control-plane,master   35m   v1.22.3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.338.1">Since we specified Docker as the virtualization tool, the whole cluster will be embedded in a Docker container, as you can verify by listing all running containers with </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">docker ps</span></code><span class="koboSpan" id="kobo.340.1"> (remember that all Docker commands must be issued in a Linux shell).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.341.1">As the default, this unique node contains 2 CPUs and 4 gigabytes of RAM, but we can modify all these parameters, and we can also create clusters with several nodes by passing some options to </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">minikube start</span></code><span class="koboSpan" id="kobo.343.1">:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">--nodes &lt;n&gt;</span></code><span class="koboSpan" id="kobo.345.1">: Specifies the number of nodes in the cluster. </span><span class="koboSpan" id="kobo.345.2">Please consider that nodes are virtual machines that will run simultaneously, so a large number of nodes can be set only on a powerful workstation with several cores and say 32-64 gigabytes of RAM. </span><span class="koboSpan" id="kobo.345.3">The default is 1.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">--cpus &lt;n or no-limits&gt;</span></code><span class="koboSpan" id="kobo.347.1">: The number of CPUs allocated to Kubernetes, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">no-limits</span></code><span class="koboSpan" id="kobo.349.1">, to let Minikube allocate as many CPUs as needed. </span><span class="koboSpan" id="kobo.349.2">The default is 2.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">--memory &lt;string&gt;</span></code><span class="koboSpan" id="kobo.351.1">: The amount of RAM to be allocated to Kubernetes (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m, or g). </span><span class="koboSpan" id="kobo.351.2">Use “max” to use the maximum amount of memory. </span><span class="koboSpan" id="kobo.351.3">Use “no-limit” to not specify a limit.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">--profile &lt;string&gt;</span></code><span class="koboSpan" id="kobo.353.1">: The name of the Minikube virtual machine (defaults to </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">minikube</span></code><span class="koboSpan" id="kobo.355.1">). </span><span class="koboSpan" id="kobo.355.2">Useful for having more than one Minikube virtual machine – for instance, one with one node and another with two nodes.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">--disk-size &lt;string&gt;</span></code><span class="koboSpan" id="kobo.357.1">: The disk size allocated to the Minikube VM (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m, or g). </span><span class="koboSpan" id="kobo.357.2">The default is “20000mb”.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.358.1">If you want to change one of the above settings after having created the Minikube container with your first </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">minikube start</span></code><span class="koboSpan" id="kobo.360.1">, you need either to delete the previous container with </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">minikube delete</span></code><span class="koboSpan" id="kobo.362.1"> or create a new Minikube container with a custom name with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">--profile</span></code><span class="koboSpan" id="kobo.364.1"> option.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.365.1">After this short parenthesis, let’s re</span><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.366.1">turn to Kubectl! </span><span class="koboSpan" id="kobo.366.2">Let’s type:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.367.1">kubectl get all
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.368.1">It lists all Kubernetes resources. </span><span class="koboSpan" id="kobo.368.2">If you have not created any resources, the cluster should contain just a </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.369.1">single resource of type ClusterIP, as shown below:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.370.1">NAME                        TYPE     CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   87m
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.371.1">It is part of the Kubernetes infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.372.1">In general, </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">kubectl get &lt;resource type&gt;</span></code><span class="koboSpan" id="kobo.374.1"> lists all resources of a gi</span><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.375.1">ven type. </span><span class="koboSpan" id="kobo.375.2">Thus, for instance, </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">kubectl get pods</span></code><span class="koboSpan" id="kobo.377.1"> lists all Pods, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">kubectl get services</span></code><span class="koboSpan" id="kobo.379.1"> lists all services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1"> If, instead, we need more detailed information on a given object, we may use </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">kubectl describe &lt;object type&gt; &lt;object name&gt;</span></code><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">Thus, for instance, if we need more information on the Minikube single node called </span><code class="inlineCode"><span class="koboSpan" id="kobo.383.1">minikube</span></code><span class="koboSpan" id="kobo.384.1">, we may issue the command below:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.385.1">kubectl describe node minikube
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.386.1">Please try it!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.387.1">You will see other Kubectl commands when learning how to define Pods, Services, and other Kubernetes resources in other sections of this chapter. </span><span class="koboSpan" id="kobo.387.2">The next subsection explains how to create an Azure Kubernetes cluster, so if at the moment you don’t plan to use Azure Kubernetes, feel free to skip it. </span><span class="koboSpan" id="kobo.387.3">You can return to it</span><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.388.1"> when you need to create one.</span></p>
<h2 class="heading-2" id="_idParaDest-154"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.389.1">Creating an Azure Kubernetes cluster</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.390.1">To create </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.391.1">an AKS cluster, do the following:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.392.1">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">AKS</span></code><span class="koboSpan" id="kobo.394.1"> into the Azure search box.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.395.1">Select </span><strong class="screenText"><span class="koboSpan" id="kobo.396.1">Kubernetes services</span></strong><span class="koboSpan" id="kobo.397.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.398.1">Then click the </span><strong class="screenText"><span class="koboSpan" id="kobo.399.1">Create</span></strong><span class="koboSpan" id="kobo.400.1"> button.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.401.1">Select </span><strong class="screenText"><span class="koboSpan" id="kobo.402.1">Kubernetes Cluster</span></strong><span class="koboSpan" id="kobo.403.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.404.1">After that, the following form will appear:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.405.1"><img alt="Figure 8.2: AKS creation first form" src="../Images/B31916_08_2.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.406.1">Figure 8.2: AKS creation first form</span></p>
<p class="normal"><span class="koboSpan" id="kobo.407.1">Here, as usual, you can </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.408.1">select one of your Azure subscriptions, an existing resource group, or you can create a new one. </span><span class="koboSpan" id="kobo.408.2">Let’s move on to the AKS-specific configuration:</span></p>
<ol>
<li class="numberedList" value="1"><strong class="screenText"><span class="koboSpan" id="kobo.409.1">Cluster preset configuration</span></strong><span class="koboSpan" id="kobo.410.1">: Here, you can choose among various preconfigured settings that are a good starting point for various situations. </span><span class="koboSpan" id="kobo.410.2">In the preceding screenshot, I have chosen </span><strong class="screenText"><span class="koboSpan" id="kobo.411.1">Dev/Test</span></strong><span class="koboSpan" id="kobo.412.1">, which is specific for development and learning, so it proposes the cheapest options. </span><span class="koboSpan" id="kobo.412.2">However, you can also select a standard production or an economic production initial setting.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.413.1">Kubernetes cluster name</span></strong><span class="koboSpan" id="kobo.414.1">: Here, you must select a unique name for your cluster. </span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.415.1">For all other settings, you can choose the proposed defaults. </span><span class="koboSpan" id="kobo.415.2">In particular, the </span><strong class="screenText"><span class="koboSpan" id="kobo.416.1">Region</span></strong><span class="koboSpan" id="kobo.417.1"> field should propose the most adequate region for you. </span><strong class="screenText"><span class="koboSpan" id="kobo.418.1">AKS pricing tier</span></strong><span class="koboSpan" id="kobo.419.1"> should be set to </span><strong class="screenText"><span class="koboSpan" id="kobo.420.1">Free</span></strong><span class="koboSpan" id="kobo.421.1">, meaning you will pay just for the virtual machines that make up the cluster. </span><span class="koboSpan" id="kobo.421.2">However, you can also select paying options that include support and super-big clusters with up to 5,000 nodes. </span><span class="koboSpan" id="kobo.421.3">The </span><strong class="screenText"><span class="koboSpan" id="kobo.422.1">Availability zones</span></strong><span class="koboSpan" id="kobo.423.1"> field enables geographic redundancy in up to 3 different geographic zones.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.424.1">If you selected </span><strong class="screenText"><span class="koboSpan" id="kobo.425.1">Dev/Test</span></strong><span class="koboSpan" id="kobo.426.1">, the cluster will include from 2 to 5 nodes with automatic scaling. </span><span class="koboSpan" id="kobo.426.2">That is, the number </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.427.1">of starting nodes is 2, but it can automatically increase up to 5 if the workload increases. </span><span class="koboSpan" id="kobo.427.2">Let’s go to the </span><strong class="screenText"><span class="koboSpan" id="kobo.428.1">node pools</span></strong><span class="koboSpan" id="kobo.429.1"> tab to customize both the node number and type:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.430.1"><img alt="Figure 8.3: AKS node pool configuration" src="../Images/B31916_08_3.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.431.1">Figure 8.3: AKS node pool configuration</span></p>
<p class="normal"><span class="koboSpan" id="kobo.432.1">If you selected </span><strong class="screenText"><span class="koboSpan" id="kobo.433.1">Dev/Test</span></strong><span class="koboSpan" id="kobo.434.1">, there should be a unique node pool that will be used for both Kubernetes master nodes and standard nodes. </span><span class="koboSpan" id="kobo.434.2">Pay attention that the </span><strong class="screenText"><span class="koboSpan" id="kobo.435.1">Dev/Test</span></strong><span class="koboSpan" id="kobo.436.1"> server type (D4ds-v5) has a high monthly price, so please use the price calculator (</span><a href="https://azure.microsoft.com/en-us/pricing/details/virtual-machines/linux/#pricing"><span class="url"><span class="koboSpan" id="kobo.437.1">https://azure.microsoft.com/en-us/pricing/details/virtual-machines/linux/#pricing</span></span></a><span class="koboSpan" id="kobo.438.1">) to verify the cost of a machine before choosing it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.439.1">The standard production selection, instead, would create two node pools – one for master nodes and the other for standard nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.440.1">Anyway, you can change the node pools and edit each of them. </span><span class="koboSpan" id="kobo.440.2">In the case of the preceding screenshot, let’s click on </span><strong class="screenText"><span class="koboSpan" id="kobo.441.1">agentpool</span></strong><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">A new form will open. </span><span class="koboSpan" id="kobo.442.3">Here, you can change both the machine type and the maximum number of nodes. </span><span class="koboSpan" id="kobo.442.4">A good option for experimenting without wasting too much credit is choosing 3 nodes and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">A</span></code><span class="koboSpan" id="kobo.444.1"> family machine. </span><span class="koboSpan" id="kobo.444.2">When you have done either, click on update or on cancel to return to the previous form.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.445.1">Finally, you can associate Azure Container Registry with the cluster by going to the </span><strong class="screenText"><span class="koboSpan" id="kobo.446.1">Integrations</span></strong><span class="koboSpan" id="kobo.447.1"> tab:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.448.1"><img alt="Figure 8.4: Connect your cluster to ACR" src="../Images/B31916_08_4.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.449.1">Figure 8.4: Connect your cluster to ACR</span></p>
<p class="normal"><span class="koboSpan" id="kobo.450.1">If you already </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.451.1">defined an Azure Container Registry for experimenting in the </span><em class="italic"><span class="koboSpan" id="kobo.452.1">A few more Docker commands and options</span></em><span class="koboSpan" id="kobo.453.1"> subsection of </span><a href="Chapter_3.xhtml#_idTextAnchor067"><em class="italic"><span class="koboSpan" id="kobo.454.1">Chapter 3</span></em></a><em class="italic"><span class="koboSpan" id="kobo.455.1">, Setup and Theory: Docker and Onion Architecture</span></em><span class="koboSpan" id="kobo.456.1">, select that registry; otherwise, you can create a new one in a new browser window and select it, or you can associate a registry to your cluster at a later time.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.457.1">When you associate a registry to your cluster, you enable the cluster to access and download all its Docker images.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.458.1">When you’ve finished, select </span><strong class="screenText"><span class="koboSpan" id="kobo.459.1">Review + Create</span></strong><span class="koboSpan" id="kobo.460.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.461.1">Once you’ve created your cluster, you can connect to it with the login procedure we explained earlier in this section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.462.1">Now that you have learned how to connect with both Minikube and AKS, let’s move on to experimenting with Kubernetes resources.</span></p>
<h1 class="heading-1" id="_idParaDest-155"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.463.1">Configuring your application in Kubernetes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.464.1">As already mentioned, the simplest Kubernetes resource is the Pod. </span><span class="koboSpan" id="kobo.464.2">We will never create a single Pod </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.465.1">since we will always create several replicas of each microservice, but being able to configure a Pod is also fundamental for creating more complex resources, so let’s start creating a single Pod.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.466.1">A Pod can be defined through a </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">.yaml</span></code><span class="koboSpan" id="kobo.468.1"> file with the content below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.469.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.470.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.471.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.472.1">Pod</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.473.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.474.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.475.1">my-podname</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.476.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.477.1">mypodnamespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.478.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.479.1">labenname1:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.480.1">labelvalue1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.481.1">labelname2:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.482.1">labelvalue2</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.483.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.484.1">restartPolicy:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.485.1">Always</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.486.1">#Optional. </span><span class="koboSpan" id="kobo.486.2">Possible values: Always (default), OnFailure. </span><span class="koboSpan" id="kobo.486.3">Never.</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.487.1">containers:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.488.1">…</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.489.1">initContainers:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.490.1">…</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.491.1">All Kubernetes configuration files start with the name of the API where the resources being configured are defined, and its version. </span><span class="koboSpan" id="kobo.491.2">In the case of Pods, we have just the version since they are defined in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.492.1">core API</span></strong><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">Then, </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">kind</span></code><span class="koboSpan" id="kobo.495.1"> defines the type of resource to be configured – in our case, a Pod.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.496.1">Like types in C#, Kubernetes resources are also organized in namespaces. </span><span class="koboSpan" id="kobo.496.2">Therefore, together with any resource name, we must also specify a namespace. </span><span class="koboSpan" id="kobo.496.3">If no namespace is specified, a namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">default</span></code><span class="koboSpan" id="kobo.498.1"> is assumed.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.499.1"> Pay attention! </span><span class="koboSpan" id="kobo.499.2">While the intent of Kubernetes and C# namespaces is the same, there are substantial differences between them. </span><span class="koboSpan" id="kobo.499.3">Namely, C# namespaces are hierarchical, while Kubernetes namespaces are not. </span><span class="koboSpan" id="kobo.499.4">Moreover, namespaces are not applicable to all Kubernetes resources since there are cluster-wide resources that belong to no specific namespace.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.500.1">If the namespace </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.501.1">used in a resource definition doesn’t exist yet, it must be defined with the snippet below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.502.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.503.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.504.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.505.1">Namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.506.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.507.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.508.1">my-namespace</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.509.1">The above snippet can be placed in a separate file, or in the same file before the resource definition and separated by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">---</span></code><span class="koboSpan" id="kobo.511.1"> row.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.512.1">Name and namespace are specified as sub-properties of </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">metadata</span></code><span class="koboSpan" id="kobo.514.1">, together with optional l</span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">abels</span></code><span class="koboSpan" id="kobo.516.1">. </span><span class="koboSpan" id="kobo.516.2">Labels are free name-value pairs we can use to classify the object. </span><span class="koboSpan" id="kobo.516.3">Typically, they specify information such as the role of the resource in the application and the tier or module it belongs to.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.517.1">As already mentioned in the previous section, other resources can use labels to select a set of resources.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.518.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">spec</span></code><span class="koboSpan" id="kobo.520.1"> property specifies the actual content of the Pod, that is, its containers and its restart policy (</span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">restartPolicy</span></code><span class="koboSpan" id="kobo.522.1">). </span><span class="koboSpan" id="kobo.522.2">The restart policy specifies when to restart a Pod:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">restartPolicy: Always</span></code><span class="koboSpan" id="kobo.524.1">: This is the default. </span><span class="koboSpan" id="kobo.524.2">The Pod is restarted whenever all containers terminate or a container terminates with a failure.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">restartPolicy: OnFailure</span></code><span class="koboSpan" id="kobo.526.1">: The Pod is restarted when at least one container exits with a failure</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">restartPolicy: Never</span></code><span class="koboSpan" id="kobo.528.1">: The Pod is never restarted.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.529.1">Containers are </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.530.1">spl</span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.531.1">it into two lists: </span><code class="inlineCode"><span class="koboSpan" id="kobo.532.1">containers</span></code><span class="koboSpan" id="kobo.533.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.534.1">initContainers</span></code><span class="koboSpan" id="kobo.535.1">. </span><span class="koboSpan" id="kobo.535.2">The containers in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.536.1">containers</span></code><span class="koboSpan" id="kobo.537.1"> list are started only after all containers in </span><code class="inlineCode"><span class="koboSpan" id="kobo.538.1">initContainers</span></code><span class="koboSpan" id="kobo.539.1"> are </span><strong class="keyWord"><span class="koboSpan" id="kobo.540.1">successful</span></strong><span class="koboSpan" id="kobo.541.1">, and each container in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.542.1">initContainers</span></code><span class="koboSpan" id="kobo.543.1"> list is started only after the previous container is </span><strong class="keyWord"><span class="koboSpan" id="kobo.544.1">successful</span></strong><span class="koboSpan" id="kobo.545.1">. </span><span class="koboSpan" id="kobo.545.2">In turn, a container in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">initContainers</span></code><span class="koboSpan" id="kobo.547.1"> list is considered </span><strong class="keyWord"><span class="koboSpan" id="kobo.548.1">successful</span></strong><span class="koboSpan" id="kobo.549.1"> in the two circumstances:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.550.1">If a container configuration has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.551.1">restartPolicy</span></code><span class="koboSpan" id="kobo.552.1"> property set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">Always</span></code><span class="koboSpan" id="kobo.554.1">, then the container is considered successful if it has been successfully started. </span><span class="koboSpan" id="kobo.554.2">This option is useful for implementing </span><strong class="keyWord"><span class="koboSpan" id="kobo.555.1">sidecar</span></strong><span class="koboSpan" id="kobo.556.1"> containers. </span><span class="koboSpan" id="kobo.556.2">This way, we ensure that </span><strong class="keyWord"><span class="koboSpan" id="kobo.557.1">sidecars</span></strong><span class="koboSpan" id="kobo.558.1"> are ready before the containers they enhance are started. </span><span class="koboSpan" id="kobo.558.2">Please refer to the Pod definition at the beginning of the </span><em class="italic"><span class="koboSpan" id="kobo.559.1">Kubernetes basics</span></em><span class="koboSpan" id="kobo.560.1"> section for an explanation of what a </span><strong class="keyWord"><span class="koboSpan" id="kobo.561.1">sidecar</span></strong><span class="koboSpan" id="kobo.562.1"> is.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.563.1">If a container configuration doesn’t have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">restartPolicy</span></code><span class="koboSpan" id="kobo.565.1"> property set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">Always</span></code><span class="koboSpan" id="kobo.567.1">, then the container is considered successful if it is successfully terminated. </span><span class="koboSpan" id="kobo.567.2">This option is useful for performing some startup initialization – for instance, for waiting for a database or a message broker to be ready. </span><span class="koboSpan" id="kobo.567.3">In a similar situation, the container code is a loop that continuously tries a connection with the database/message broker, and terminates as soon as it succeeds.</span></li>
</ol>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.568.1">A failed </span><code class="inlineCode"><span class="koboSpan" id="kobo.569.1">initContainers</span></code><span class="koboSpan" id="kobo.570.1"> doesn’t cause a whole Pod restart. </span><span class="koboSpan" id="kobo.570.2">Instead, it is retried with an exponential retry several times before causing a whole Pod failure. </span><span class="koboSpan" id="kobo.570.3">For this reason, they should be designed as idempotent since their actions might be executed more than once.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.571.1">Each container in any of the two above lists is something like:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-bullet"><span class="koboSpan" id="kobo.572.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.573.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.574.1">&lt;container</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.575.1">name&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.576.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.577.1">&lt;container</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.578.1">image</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.579.1">URL&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.580.1">command:</span></span><span class="koboSpan" id="kobo.581.1"> [</span><span class="hljs-string"><span class="koboSpan" id="kobo.582.1">…</span></span><span class="koboSpan" id="kobo.583.1">] </span><span class="hljs-comment"><span class="koboSpan" id="kobo.584.1"># square bracket contains all strings that compose the OS command</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.585.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.586.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.587.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.588.1">100m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.589.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.590.1">128Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.591.1">limits:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.592.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.593.1">250m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.594.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.595.1">256Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.596.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.597.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.598.1">containerPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.599.1">80</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.600.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.601.1">containerPort:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.602.1">…</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.603.1">…</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.604.1">env:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.605.1">-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.606.1">env-name1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.607.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.608.1">env-value1</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.609.1">…</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.610.1">volumeMounts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.611.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.612.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.613.1">data</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.614.1">mountPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.615.1">/mypath/mysubpath….</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.616.1">subPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.617.1">/vsubpath</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.618.1">#optional. </span><span class="koboSpan" id="kobo.618.2">If provided the path of data mounted in mountPath</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.619.1">…</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.620.1">We specify both a name for the container and the URL of its image in a container reg</span><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.621.1">istry, which accounts for point 4 of the minimal services any orchestrator should offer (see the beginning of the </span><em class="italic"><span class="koboSpan" id="kobo.622.1">Introduction to orchestrators and their configuration</span></em><span class="koboSpan" id="kobo.623.1"> section). </span><span class="koboSpan" id="kobo.623.2">These two properties are obligatory, while all other properties are optional. </span><span class="koboSpan" id="kobo.623.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">command</span></code><span class="koboSpan" id="kobo.625.1"> property, when provided, overwrites the </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">CMD</span></code><span class="koboSpan" id="kobo.627.1"> instruction of the image Docker file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.628.1">Then, we also </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.629.1">account for points 5, 6, and 7 of the minimal services any orchestrator should offer, that is, disk storage, environment variables, and communication ports. </span><span class="koboSpan" id="kobo.629.2">More specifically, we have:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">volumeMount</span></code><span class="koboSpan" id="kobo.631.1"> specifies how a virtual storage volume specified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.632.1">name</span></code><span class="koboSpan" id="kobo.633.1"> is mapped to the path specified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.634.1">mountPath</span></code><span class="koboSpan" id="kobo.635.1"> in the container file system. </span><span class="koboSpan" id="kobo.635.2">If the optional </span><code class="inlineCode"><span class="koboSpan" id="kobo.636.1">subPath</span></code><span class="koboSpan" id="kobo.637.1"> is provided, just that </span><code class="inlineCode"><span class="koboSpan" id="kobo.638.1">subpath</span></code><span class="koboSpan" id="kobo.639.1"> of the volume specified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">name</span></code><span class="koboSpan" id="kobo.641.1"> is mounted. </span><span class="koboSpan" id="kobo.641.2">Virtual storage volumes are described later on in this chapter (in the </span><em class="italic"><span class="koboSpan" id="kobo.642.1">Dynamic provisioning of permanent disk space</span></em><span class="koboSpan" id="kobo.643.1"> subsection), together with other </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">volumeMounts</span></code><span class="koboSpan" id="kobo.645.1"> properties.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">env</span></code><span class="koboSpan" id="kobo.647.1"> specifies all container’s environment variables as a list of </span><code class="inlineCode"><span class="koboSpan" id="kobo.648.1">name-value</span></code><span class="koboSpan" id="kobo.649.1"> pairs.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.650.1">ports</span></code><span class="koboSpan" id="kobo.651.1"> specifies the list of all ports exposed by the container we would like to use in our application. </span><span class="koboSpan" id="kobo.651.2">These ports may be mapped to other ports in the actual communication between Pods. </span><span class="koboSpan" id="kobo.651.3">However, the port mapping is specified in other resources called </span><code class="inlineCode"><span class="koboSpan" id="kobo.652.1">services</span></code><span class="koboSpan" id="kobo.653.1"> that provide virtual Pod addresses and other communication-related options.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.654.1">Finally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">resource</span></code><span class="koboSpan" id="kobo.656.1">s section specifies both the minimal computational resources needed for starting the container (</span><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">requests</span></code><span class="koboSpan" id="kobo.658.1">) and the maximum computational resources it can waste (</span><code class="inlineCode"><span class="koboSpan" id="kobo.659.1">limits</span></code><span class="koboSpan" id="kobo.660.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.661.1">The constraints in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">requests</span></code><span class="koboSpan" id="kobo.663.1"> property are used to choose the virtual machine to place a Pod. </span><code class="inlineCode"><span class="koboSpan" id="kobo.664.1">limits</span></code><span class="koboSpan" id="kobo.665.1">, instead, are enforced by the operating system kernel as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.666.1">CPU limits are enforced with throttling. </span><span class="koboSpan" id="kobo.666.2">That is, containers exceeding the CPU limit are delayed, putting them in sleeping mode for enough time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.667.1">Memory limits are enforced by throwing an exception when they are exceeded. </span><span class="koboSpan" id="kobo.667.2">In turn, the exception causes the application of the Pod restart policy, which usually causes a Pod restart.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.668.1">With regard to units </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.669.1">of measure, typical memory units of measure are </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">Ti</span></code><span class="koboSpan" id="kobo.671.1"> (terabytes), </span><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">Gi</span></code><span class="koboSpan" id="kobo.673.1"> (gigabytes), </span><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">Mi</span></code><span class="koboSpan" id="kobo.675.1"> (megabytes), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">Ki</span></code><span class="koboSpan" id="kobo.677.1"> (kilobytes). </span><span class="koboSpan" id="kobo.677.2">CPU time, instead, can be measured either in millicores (</span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">mi</span></code><span class="koboSpan" id="kobo.679.1">) or as a fractional number of cores (no unit of measure after the value).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.680.1">Let’s try a Pod with a sidecar container, which shows both the practical usage of the described syntax and how a sidecar can help in building application-level monitoring. </span><span class="koboSpan" id="kobo.680.2">The main container will be a fake microservice based on the Alpine Linux distribution Docker image, which just puts log messages in a file located in a directory shared with the sidecar. </span><span class="koboSpan" id="kobo.680.3">In an actual application, the log would be organized in several files (for instance, one for each day), and old files would be periodically deleted. </span><span class="koboSpan" id="kobo.680.4">Moreover, the sidecar would read these files and send their content to a log API. </span><span class="koboSpan" id="kobo.680.5">Our didactical sidecar, instead, will just periodically read the last 10 rows of the file and will display them in its console.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.681.1">The code is quite simple. </span><span class="koboSpan" id="kobo.681.2">First of all, we define a namespace that encloses our example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.682.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.683.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.684.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.685.1">Namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.686.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.687.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.688.1">basic-examples</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.689.1">Then, after a </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">---</span></code><span class="koboSpan" id="kobo.691.1"> row, we place the actual Pod definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.692.1">---</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.693.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.694.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.695.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.696.1">Pod</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.697.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.698.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.699.1">pod-demo</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.700.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.701.1">basic-examples</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.702.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.703.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.704.1">myapp</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.705.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.706.1">containers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.707.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.708.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.709.1">myapp</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.710.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.711.1">alpine:latest</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.712.1">command:</span></span><span class="koboSpan" id="kobo.713.1"> [</span><span class="hljs-string"><span class="koboSpan" id="kobo.714.1">'sh'</span></span><span class="koboSpan" id="kobo.715.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.716.1">'-c'</span></span><span class="koboSpan" id="kobo.717.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.718.1">'while true; do echo $(date) &gt;&gt; /opt/logs.txt; sleep 1; done'</span></span><span class="koboSpan" id="kobo.719.1">]
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.720.1">volumeMounts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.721.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.722.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.723.1">data</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.724.1">mountPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.725.1">/opt</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.726.1">initContainers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.727.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.728.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.729.1">logshipper</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.730.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.731.1">alpine:latest</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.732.1">restartPolicy:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.733.1">Always</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.734.1">command:</span></span><span class="koboSpan" id="kobo.735.1"> [</span><span class="hljs-string"><span class="koboSpan" id="kobo.736.1">'sh'</span></span><span class="koboSpan" id="kobo.737.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.738.1">'-c'</span></span><span class="koboSpan" id="kobo.739.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.740.1">'tail -F /opt/logs.txt'</span></span><span class="koboSpan" id="kobo.741.1">]
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.742.1">volumeMounts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.743.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.744.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.745.1">data</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.746.1">mountPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.747.1">/opt</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.748.1">volumes:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.749.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.750.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.751.1">data</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.752.1">emptyDir:</span></span><span class="koboSpan" id="kobo.753.1"> {}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.754.1">Both containers use a simple Alpine Linux distribution Docker image and confine the application-specific code in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">command</span></code><span class="koboSpan" id="kobo.756.1">, which is a Linux script. </span><span class="koboSpan" id="kobo.756.2">This technique is used for adapting preexisting images or for very simple tasks such as the ones often performed by a sidecar. </span><span class="koboSpan" id="kobo.756.3">We also used </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.757.1">the same technique for the main container because the main container does nothing and has a purely didactical purpose.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.758.1">Accordingly, with the previously exposed syntax, the sidecar is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">initContaines</span></code><span class="koboSpan" id="kobo.760.1"> list with </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">restartPolicy: Always</span></code><span class="koboSpan" id="kobo.762.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.763.1">The main container command executes an endless loop where it just writes the current date and time in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">/opt/logs.txt</span></code><span class="koboSpan" id="kobo.765.1"> file and then sleeps for one second.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.766.1">The sidecar container command uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.767.1">sh -c</span></code><span class="koboSpan" id="kobo.768.1"> to execute a single shell command, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.769.1">tail</span></code><span class="koboSpan" id="kobo.770.1"> command with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.771.1">-f</span></code><span class="koboSpan" id="kobo.772.1"> option on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.773.1">/opt/logs.txt</span></code><span class="koboSpan" id="kobo.774.1"> file. </span><span class="koboSpan" id="kobo.774.2">This command shows the last 10 rows of the file in the container console and updates them whenever new rows are added, so that the console always contains the current last 10 rows of the file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.775.1">The file processed by both containers is the same because both containers mount the same data volume in the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">/opt</span></code><span class="koboSpan" id="kobo.777.1"> directory on their filesystems with:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.778.1">volumeMounts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.779.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.780.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.781.1">data</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.782.1">mountPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.783.1">/opt</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.784.1">The data volume is defined in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.785.1">volumes</span></code><span class="koboSpan" id="kobo.786.1"> list that is a direct descendant of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.787.1">spec</span></code><span class="koboSpan" id="kobo.788.1"> property, as:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet"><span class="koboSpan" id="kobo.789.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.790.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.791.1">data</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.792.1">emptyDir:</span></span><span class="koboSpan" id="kobo.793.1"> {}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.794.1">emptyDir</span></code><span class="koboSpan" id="kobo.795.1"> defines and allocates </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.796.1">a volume that is specific to the Pod where it is defined. </span><span class="koboSpan" id="kobo.796.2">This means that it can’t be accessed by any other Pod. </span><span class="koboSpan" id="kobo.796.3">The volume is implemented with the disk memory of the node that hosts the Pod. </span><span class="koboSpan" id="kobo.796.4">This means that if the Pod is deleted or moved to a different node, the volume is destroyed and its content is lost. </span><code class="inlineCode"><span class="koboSpan" id="kobo.797.1">EmptyDir</span></code><span class="koboSpan" id="kobo.798.1"> is the preferred way to provide temporary disk storage that’s used somehow in the Pod computations. </span><span class="koboSpan" id="kobo.798.2">It has </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.799.1">an optional </span><code class="inlineCode"><span class="koboSpan" id="kobo.800.1">sizeLimit</span></code><span class="koboSpan" id="kobo.801.1"> property that specifies a maximum disk space the Pod can use. </span><span class="koboSpan" id="kobo.801.2">For instance, we can set </span><code class="inlineCode"><span class="koboSpan" id="kobo.802.1">sizeLimit: 500Mi</span></code><span class="koboSpan" id="kobo.803.1"> to specify 500 mega of maximum disk space.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.804.1">Since we have not specified any size limit, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">emptyDir</span></code><span class="koboSpan" id="kobo.806.1"> object has no properties, so we are forced to add the empty object value </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">{}</span></code><span class="koboSpan" id="kobo.808.1"> to get a correct </span><code class="inlineCode"><span class="koboSpan" id="kobo.809.1">.yaml</span></code><span class="koboSpan" id="kobo.810.1"> syntax (we can’t have a colon followed by nothing).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.811.1">Let’s create a folder for experimenting with </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">.yaml</span></code><span class="koboSpan" id="kobo.813.1"> files in Minikube, and let’s place the whole example code in a file called </span><code class="inlineCode"><span class="koboSpan" id="kobo.814.1">SimplePOD.yaml</span></code><span class="koboSpan" id="kobo.815.1"> inside that folder. </span><span class="koboSpan" id="kobo.815.2">This file is also available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.816.1">ch08</span></code><span class="koboSpan" id="kobo.817.1"> folder of the book’s GitHub repository.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.818.1">Now, right-click on the newly created folder and open a Windows console in that directory. </span><span class="koboSpan" id="kobo.818.2">After having verified that Minikube is started by issuing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.819.1">kubectl get all</span></code><span class="koboSpan" id="kobo.820.1"> command, we can apply all our definitions with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.821.1">kubectl apply</span></code><span class="koboSpan" id="kobo.822.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.823.1">kubectl apply </span><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.824.1">-f SimplePOD.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.825.1">Now, if we issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.826.1">kubectl get pods</span></code><span class="koboSpan" id="kobo.827.1"> command, we don’t see a new Pod! </span><span class="koboSpan" id="kobo.827.2">This is right because that command just lists resources defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.828.1">default</span></code><span class="koboSpan" id="kobo.829.1"> namespace, while our Pod has been defined in a new namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.830.1">basic-examples</span></code><span class="koboSpan" id="kobo.831.1">, so if we would like to operate on a resource in this namespace, we must add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.832.1">-n basic-examples</span></code><span class="koboSpan" id="kobo.833.1"> option to our commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.834.1">kubectl get pods -n basic-examples
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.835.1">In order to access our sidecar console, we can use the Kubectl </span><code class="inlineCode"><span class="koboSpan" id="kobo.836.1">logs</span></code><span class="koboSpan" id="kobo.837.1"> command. </span><span class="koboSpan" id="kobo.837.2">In fact, all console output of all container Pods is automatically collected by Kubernetes and can be inspected with this command. </span><span class="koboSpan" id="kobo.837.3">The command needs the Pod name and its namespace if different from </span><code class="inlineCode"><span class="koboSpan" id="kobo.838.1">default</span></code><span class="koboSpan" id="kobo.839.1">. </span><span class="koboSpan" id="kobo.839.2">Moreover, if the Pod contains several containers, it also needs the name of the container we would like to inspect, which can be provided with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.840.1">-c</span></code><span class="koboSpan" id="kobo.841.1"> option. </span><span class="koboSpan" id="kobo.841.2">Summing up, our command is:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.842.1">kubectl logs -n basic-examples  pod-demo -c logshipper
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.843.1">The command above will show just the current console content and then it will exit. </span><span class="koboSpan" id="kobo.843.2">If we would like the content to update automatically as the console content changes, we must add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.844.1">-f</span></code><span class="koboSpan" id="kobo.845.1"> option:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.846.1">kubectl logs -f -n basic-examples  pod-demo -c logshipper
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.847.1">This way, our window </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.848.1">freezes on the command and automatically updates. </span><span class="koboSpan" id="kobo.848.2">The command can be exited with </span><code class="inlineCode"><span class="koboSpan" id="kobo.849.1">ctrl-c</span></code><span class="koboSpan" id="kobo.850.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.851.1">We can also have a console into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.852.1">logshipper</span></code><span class="koboSpan" id="kobo.853.1"> container with the Kubectl </span><code class="inlineCode"><span class="koboSpan" id="kobo.854.1">exec</span></code><span class="koboSpan" id="kobo.855.1"> command. </span><span class="koboSpan" id="kobo.855.2">It needs namespace, Pod, and container names, and after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.856.1">–</span></code><span class="koboSpan" id="kobo.857.1"> characters, the Linux command to execute in the container file system. </span><span class="koboSpan" id="kobo.857.2">If you need a console, the Linux command is </span><code class="inlineCode"><span class="koboSpan" id="kobo.858.1">sh</span></code><span class="koboSpan" id="kobo.859.1">, and if we would like to interact with that console, we need to also specify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.860.1">-it</span></code><span class="koboSpan" id="kobo.861.1"> options that stand for “interactive tty.” </span><span class="koboSpan" id="kobo.861.2">Summing up, we have:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.862.1">kubectl exec -it -n basic-examples pod-demo -c logshipper -- sh
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.863.1">Once in the container, we can move into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">/opt</span></code><span class="koboSpan" id="kobo.865.1"> directory with </span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">cd /opt</span></code><span class="koboSpan" id="kobo.867.1">, and verify if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.868.1">logs.txt</span></code><span class="koboSpan" id="kobo.869.1"> file is there, with </span><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">ls</span></code><span class="koboSpan" id="kobo.871.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.872.1">Once finished, you can exit the container console by issuing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.873.1">exit</span></code><span class="koboSpan" id="kobo.874.1"> command.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.875.1"> The </span><code class="inlineCode"><span class="koboSpan" id="kobo.876.1">kubectl exec</span></code><span class="koboSpan" id="kobo.877.1"> command is </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.878.1">very useful for debugging applications, especially when they are already in production or staging.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.879.1">When you have finished with all resources created by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.880.1">.yaml</span></code><span class="koboSpan" id="kobo.881.1"> file, you can delete all of them with </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">kubectl deleted &lt;file name&gt;.yaml</span></code><span class="koboSpan" id="kobo.883.1">. </span><span class="koboSpan" id="kobo.883.2">Thus, in our case, we can destroy all our example entities with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.884.1">kubectl delete -f SimplePOD.yaml
</span></code></pre>
<div class="note">
<p class="normal"> <code class="inlineCode"><span class="koboSpan" id="kobo.885.1">kubectl apply</span></code><span class="koboSpan" id="kobo.886.1"> can also be used for modifying previously created resources. </span><span class="koboSpan" id="kobo.886.2">It is enough to edit the </span><code class="inlineCode"><span class="koboSpan" id="kobo.887.1">.yaml</span></code><span class="koboSpan" id="kobo.888.1"> file used to create the resources and then repeat the </span><code class="inlineCode"><span class="koboSpan" id="kobo.889.1">apply</span></code><span class="koboSpan" id="kobo.890.1"> command on it.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.891.1">We have seen how to create temporary disk space with </span><code class="inlineCode"><span class="koboSpan" id="kobo.892.1">emptyDir</span></code><span class="koboSpan" id="kobo.893.1">. </span><span class="koboSpan" id="kobo.893.2">Now let’s see the typical way of allocating permanent network disk space and sharing it between various Pods.</span></p>
<h2 class="heading-2" id="_idParaDest-156"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.894.1">Dynamic provisioning of permanent disk space</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.895.1">Volume definitions similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.896.1">emptyDir</span></code><span class="koboSpan" id="kobo.897.1"> are called in-tree definitions because the instruction that </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.898.1">creates the volume is inserted directly into the Pod definition. </span><span class="koboSpan" id="kobo.898.2">There is no way to share an in-tree definition with other Pod definitions, so it is not easy to share in-tree volumes between different Pods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.899.1">Actually, disk space sharing can also be achieved with in-tree definitions by adequately configuring the device that provides the disk space. </span><span class="koboSpan" id="kobo.899.2">For instance, suppose we are using an NFS server connected to our Kubernetes cluster to furnish network disk space. </span><span class="koboSpan" id="kobo.899.3">We can connect a Pod with it with the instruction below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.900.1">volumes</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.901.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.902.1">nfs:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.903.1">server:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.904.1">my-nfs-server.example.com</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.905.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.906.1">/my-nfs-volume</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.907.1">readOnly:</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.908.1">true</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.909.1"># optional. </span><span class="koboSpan" id="kobo.909.2">If provided the volume is accessible as read-only</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.910.1">Where </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">server</span></code><span class="koboSpan" id="kobo.912.1"> is a server name or an IP address, and path is the directory to share. </span><span class="koboSpan" id="kobo.912.2">In order to share the same disk space between PodS, it is enough that they specify the same server and path.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.913.1">However, this technique has two cons:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.914.1">The share is not explicitly declared, but it is indirect, thus it undermines code maintainability and readability.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.915.1">Kubernetes is not informed about the Pods that are using a share, so it can’t be instructed to release the share when it is not needed anymore.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.916.1">Therefore, in-tree </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.917.1">definitions are more adequate for temporary disk space that is not shared among Pods. </span><span class="koboSpan" id="kobo.917.2">Luckily, the problem is not the NFS protocol itself, but just the in-tree syntax. </span><span class="koboSpan" id="kobo.917.3">For this reason, Kubernetes also offers an out-of-tree syntax </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.918.1">based on two separate objects: </span><strong class="keyWord"><span class="koboSpan" id="kobo.919.1">Persistent Volume Claims</span></strong><span class="koboSpan" id="kobo.920.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.921.1">PVCs</span></strong><span class="koboSpan" id="kobo.922.1">), which represent disk space needs, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.923.1">Persistent Volumes</span></strong><span class="koboSpan" id="kobo.924.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.925.1">PVs</span></strong><span class="koboSpan" id="kobo.926.1">), which represent actual disk space.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.927.1">The whole technique works this way:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.928.1">We define the disk space specification in a PVC.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.929.1">All Pods that need to share the same disk space reference the same PVC.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.930.1">Kubernetes, somehow, tries to satisfy each PVC with a compatible PV that is then mounted on all Pods sharing that PVC.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.931.1">When all Pods that share the same PV are destroyed, we can instruct Kubernetes to keep the allocated disk space or delete it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.932.1">The way a PVC catches the needed disk and returns a PV depends on the driver used to serve the PVC. </span><span class="koboSpan" id="kobo.932.2">Drivers must be installed in the Kubernetes cluster, but all cloud providers furnish predefined drivers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.933.1">Driver names </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.934.1">and related settings are organized in resources called </span><strong class="keyWord"><span class="koboSpan" id="kobo.935.1">Storage Classes</span></strong><span class="koboSpan" id="kobo.936.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">kind: StorageClass</span></code><span class="koboSpan" id="kobo.938.1">). </span><span class="koboSpan" id="kobo.938.2">Together with </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.939.1">predefined drivers, all cloud providers also offer predefined storage classes based on those drivers. </span><span class="koboSpan" id="kobo.939.2">However, you can define new storage classes based on the same driver but with different settings.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.940.1">You can also install drivers and storage classes based on those drivers on on-premises Kubernetes clusters (there are a lot of open-source drivers). </span><span class="koboSpan" id="kobo.940.2">Minikube has addons that install various storage drivers and related storage classes, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.941.1">Drivers that simply match PVCs with PVs that are manually predefined by the user are called static. </span><span class="koboSpan" id="kobo.941.2">While drivers that dynamically create PV resources, taking the needed disk space from a common pool of available disk space, are called dynamic.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.942.1">In this section, we will focus just on dynamic storage allocation since it is the most relevant in actual microservices applications. </span><span class="koboSpan" id="kobo.942.2">You may find more details on storage classes and how to define them in the official Kubernetes documentation: </span><a href="https://kubernetes.io/docs/concepts/storage/storage-classes/"><span class="url"><span class="koboSpan" id="kobo.943.1">https://kubernetes.io/docs/concepts/storage/storage-classes/</span></span></a><span class="koboSpan" id="kobo.944.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.945.1">The first step in creating a PVC is the verification of the available storage classes:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.946.1">Kubectl get storageclasses
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.947.1">Then the details of a specific class can be obtained with </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">kubectl describe</span></code><span class="koboSpan" id="kobo.949.1">. </span><span class="koboSpan" id="kobo.949.2">In Minikube, we obtain:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.950.1">NAME               PROVISIONER            RECLAIMPOLICY   VOLUMEBINDINGMODE ...  
</span><span class="koboSpan" id="kobo.950.2">standard (default) k8s.io/minikube-hostpath   Delete          Immediate      ...   
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.951.1">The “default” after the class name informs us that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.952.1">standard</span></code><span class="koboSpan" id="kobo.953.1"> class is the default storage class, that is, the one used when no storage class is specified.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.954.1">When using dynamic provisioning, a PVC needs to specify just:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.955.1">The storage needed</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.956.1">The storage class</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.957.1">The access modality: </span><code class="inlineCode"><span class="koboSpan" id="kobo.958.1">ReadWriteOnce</span></code><span class="koboSpan" id="kobo.959.1"> (only a si</span><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.960.1">ngle node can read and write on the storage), </span><code class="inlineCode"><span class="koboSpan" id="kobo.961.1">ReadOnlyMany</span></code><span class="koboSpan" id="kobo.962.1"> (several nodes can read), </span><code class="inlineCode"><span class="koboSpan" id="kobo.963.1">ReadWriteMany</span></code><span class="koboSpan" id="kobo.964.1"> (several nodes can both read and write), </span><code class="inlineCode"><span class="koboSpan" id="kobo.965.1">ReadWriteOncePod</span></code><span class="koboSpan" id="kobo.966.1"> (only a single Pod can read and write on the storage)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.967.1">In fact, all the information needed to get a PV is contained in the storage class. </span><span class="koboSpan" id="kobo.967.2">Since a PVC describes a Pod need and not a specific PV, the provisioned storage will provide at least the required access mode, but it can support more accesses, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.968.1">If the </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.969.1">driver used by the storage class doesn’t support the required modality, the operation fails. </span><span class="koboSpan" id="kobo.969.2">Therefore, before using a storage class, you must verify the operations supported by its driver. </span><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">ReadOnlyMany</span></code><span class="koboSpan" id="kobo.971.1"> doesn’t make sense with dynamic provisioning, since allocated storage always comes clean, so there is nothing to read.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.972.1">In practice, drivers th</span><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.973.1">at support dynamic provisioning always support </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">ReadWriteOnce</span></code><span class="koboSpan" id="kobo.975.1">, and some of them also support </span><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">ReadWriteMany</span></code><span class="koboSpan" id="kobo.977.1">. </span><span class="koboSpan" id="kobo.977.2">Therefore, if you need a volume that is shared among several Pods, you must verify that the chosen driver supports </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">ReadWriteMany</span></code><span class="koboSpan" id="kobo.979.1">; otherwise, all Pods that share the volume will be allocated on the same node to ensure that all of them can access the claimed </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">ReadWriteOnce</span></code><span class="koboSpan" id="kobo.981.1"> storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.982.1">A PVC is defined as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.983.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.984.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.985.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.986.1">PersistentVolumeClaim</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.987.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.988.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.989.1">myclaim</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.990.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.991.1">a-namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.992.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.993.1">accessModes:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.994.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.995.1">ReadWriteOnce</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.996.1"># ReadWriteOnce, ReadOnlyMany, ReadWriteMany, ReadWriteOncePod</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.997.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.998.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.999.1">storage:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1000.1">8Gi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1001.1">storageClassName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1002.1">&lt;my</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1003.1">storage</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1004.1">classname&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1005.1">The needed storage is specified with the same syntax as the RAM required by a container. </span><span class="koboSpan" id="kobo.1005.2">If the storage class is not provided, Kubernetes uses a storage class that has been marked as the default storage class, if any.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1006.1">Once you’ve defined a PVC, the volume property of the Pod needs to reference it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1007.1">volumes:
- name: myvolume
   persistentVolumeClaim:
     claimName: myclaim
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1008.1">However, the PVC and Pod must belong to the same namespace; otherwise, the operation fails.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1009.1">Now that </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.1010.1">we have all the building blocks, we can move on to more complex resources built on top of these blocks. </span><span class="koboSpan" id="kobo.1010.2">Single Pods are not useful since we always need several replicas of each microservice, but luckily, Kubernetes already has built-in resources for handling both undistinguishable replicas and indexed replicas useful for implementing sharding strategies.</span></p>
<h2 class="heading-2" id="_idParaDest-157"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.1011.1">ReplicaSets, Deployments, and their services</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1012.1">ReplicaSets</span></strong><span class="koboSpan" id="kobo.1013.1"> are resources </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.1014.1">that automatically create N replicas of a Pod. </span><span class="koboSpan" id="kobo.1014.2">However, they are rarely used because it is </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.1015.1">more convenient to use </span><strong class="keyWord"><span class="koboSpan" id="kobo.1016.1">Deployments</span></strong><span class="koboSpan" id="kobo.1017.1">, which are </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.1018.1">built on top of ReplicaSets </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.1019.1">and automatically handle a smooth transition when the number of replicas or other parameters are modified.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1020.1">The definition of a Deployment is:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1021.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1022.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1023.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1024.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1025.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1026.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1027.1">my-deployment-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1028.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1029.1">my-namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1030.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1031.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1032.1">my-app</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1033.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1034.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1035.1">3</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1036.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1037.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1038.1">my-pod-label-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1039.1">my-pod-label-value</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1040.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1041.1">template:</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1042.1">Deployments are not contained in the API core, so their API name (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1043.1">apps</span></code><span class="koboSpan" id="kobo.1044.1">) must be specified. </span><span class="koboSpan" id="kobo.1044.2">The metadata section is identical to that of a Pod. </span><span class="koboSpan" id="kobo.1044.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1045.1">spec</span></code><span class="koboSpan" id="kobo.1046.1"> section contains the desired number of replicas (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1047.1">replicas</span></code><span class="koboSpan" id="kobo.1048.1">) and a selector that specifies a condition for a Pod to belong to the deployment: it must have all labels with the specified values.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1049.1">template</span></code><span class="koboSpan" id="kobo.1050.1"> specifies how to create a Pod for the Deployment. </span><span class="koboSpan" id="kobo.1050.2">If the cluster already contains some Pods that satisfy the selector conditions, then the template is used to create just the Pods needed to reach the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1051.1">replicas</span></code><span class="koboSpan" id="kobo.1052.1"> target number.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1053.1">The template is a complete Pod definition whose syntax is identical to the one we use for specifying a single Pod. </span><span class="koboSpan" id="kobo.1053.2">The only differences being:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1054.1">The Pod </span><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.1055.1">definition is not preceded by any API specification</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1056.1">The Pod metadata section doesn’t contain a Pod name, since we are providing a template for creating </span><code class="inlineCode"><span class="koboSpan" id="kobo.1057.1">replica</span></code><span class="koboSpan" id="kobo.1058.1"> Pods. </span><span class="koboSpan" id="kobo.1058.2">Pod names are automatically created by the Deployment.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1059.1">The Pod metadata section doesn’t contain a Pod namespace since Pods inherit the same namespace as the Deployment.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1060.1">Needless to say, the Pod </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.1061.1">template must specify labels that </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.1062.1">match the selector </span><code class="inlineCode"><span class="koboSpan" id="kobo.1063.1">conditions</span></code><span class="koboSpan" id="kobo.1064.1">. </span><span class="koboSpan" id="kobo.1064.2">Below is a complete example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1065.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1066.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1067.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1068.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1069.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1070.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1071.1">nginx</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1072.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1073.1">basic-examples</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1074.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1075.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1076.1">webservers</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1077.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1078.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1079.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1080.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1081.1">webservers</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1082.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1083.1">2</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1084.1">template:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1085.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1086.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1087.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1088.1">webservers</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1089.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1090.1">containers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1091.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1092.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1093.1">nginx</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1094.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1095.1">nginx</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1096.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1097.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1098.1">containerPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1099.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1100.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1101.1">web</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1102.1">volumeMounts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1103.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1104.1">mountPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1105.1">/usr/share/nginx/html</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1106.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1107.1">website</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1108.1">volumes:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1109.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1110.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1111.1">website</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1112.1">persistentVolumeClaim:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1113.1">claimName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1114.1">website</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1115.1">The Deployment creates </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.1116.1">two replicas of an </span><strong class="keyWord"><span class="koboSpan" id="kobo.1117.1">nginx</span></strong><span class="koboSpan" id="kobo.1118.1"> web server that share </span><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.1119.1">a common disk space. </span><span class="koboSpan" id="kobo.1119.2">More specifically, they share the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1120.1">/usr/share/nginx/html</span></code><span class="koboSpan" id="kobo.1121.1"> path that is mapped to a common PVC. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1122.1">/usr/share/nginx/html</span></code><span class="koboSpan" id="kobo.1123.1"> is the folder where </span><strong class="keyWord"><span class="koboSpan" id="kobo.1124.1">nginx</span></strong><span class="koboSpan" id="kobo.1125.1"> looks for static web content, so if we place an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1126.1">index.html</span></code><span class="koboSpan" id="kobo.1127.1"> file there, it should be accessible by both web servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1128.1">The code above implements two load-balanced web servers that s</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.1129.1">erve the same content. </span><span class="koboSpan" id="kobo.1129.2">Let’s place the Deployment in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1130.1">WebServers.yaml</span></code><span class="koboSpan" id="kobo.1131.1"> file. </span><span class="koboSpan" id="kobo.1131.2">We will use it in a short while, after having added the </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.1132.1">missing code, that is, the PVC definition </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.1133.1">and a Service that forwards traffic from outside of the Kubernetes cluster and load-balances it among the replicas.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1134.1">Deployments can be connected to three kinds of services:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1135.1">ClusterIP</span></strong><span class="koboSpan" id="kobo.1136.1">, which forwards </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.1137.1">traffic from inside the network to the Deployment</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1138.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.1139.1">, which </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.1140.1">forwards traffic from outside of the cluster to the Deployment</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1141.1">NodePort, </span></strong><span class="koboSpan" id="kobo.1142.1">which is not </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.1143.1">fundamental for application developers and will not be described</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1144.1">The definition of a </span><strong class="keyWord"><span class="koboSpan" id="kobo.1145.1">ClusterIP</span></strong><span class="koboSpan" id="kobo.1146.1"> is:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1147.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1148.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1149.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1150.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1151.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1152.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1153.1">my-service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1154.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1155.1">my-namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1156.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1157.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1158.1">my-selector-label:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1159.1">my-selector-value</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1160.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1161.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1162.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1163.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1164.1">http</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1165.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1166.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1167.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1168.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1169.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1170.1">80</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1171.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1172.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1173.1">https</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1174.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1175.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1176.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1177.1">443</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1178.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1179.1">443</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1180.1">selector</span></code><span class="koboSpan" id="kobo.1181.1"> defines the Pods that will receive the traffic from the service. </span><span class="koboSpan" id="kobo.1181.2">The Pods must belong to the same namespace as the service. </span><span class="koboSpan" id="kobo.1181.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1182.1">ports</span></code><span class="koboSpan" id="kobo.1183.1"> list defines the mapping from external ports (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1184.1">port</span></code><span class="koboSpan" id="kobo.1185.1">) to the ports inside the Pod containers (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1186.1">targetPort</span></code><span class="koboSpan" id="kobo.1187.1">). </span><span class="koboSpan" id="kobo.1187.2">Each map can also specify an optional name </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.1188.1">and an optional protocol. </span><span class="koboSpan" id="kobo.1188.2">If no protocol is specified, all protocols </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.1189.1">will be forwarded to the Pods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1190.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.1191.1">ClusterIP</span></strong><span class="koboSpan" id="kobo.1192.1"> service is </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.1193.1">assigned the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1194.1">&lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local</span></code><span class="koboSpan" id="kobo.1195.1"> domain name, but it can also be accessed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1196.1">&lt;service name&gt;.&lt;namespace&gt;</span></code><span class="koboSpan" id="kobo.1197.1"> (or simply </span><code class="inlineCode"><span class="koboSpan" id="kobo.1198.1">&lt;service name&gt;</span></code><span class="koboSpan" id="kobo.1199.1"> if the namespace is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1200.1">default</span></code><span class="koboSpan" id="kobo.1201.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1202.1">Summing up, all traffic sent to either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1203.1">&lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local</span></code><span class="koboSpan" id="kobo.1204.1"> or to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1205.1">&lt;service name&gt;.&lt;namespace&gt;</span></code><span class="koboSpan" id="kobo.1206.1"> is forwarded to the Pods selected by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1207.1">selector</span></code><span class="koboSpan" id="kobo.1208.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1209.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.1210.1">LoadBalance</span></strong><span class="koboSpan" id="kobo.1211.1">r service is </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.1212.1">completely analogous, the only difference being the two sub-properties of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1213.1">spec</span></code><span class="koboSpan" id="kobo.1214.1"> below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1215.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1216.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1217.1">LoadBalancer</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1218.1">loadBalancerIP:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1219.1">&lt;yourpublic</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1220.1">ip&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1221.1">selector:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1222.1">…</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1223.1">If you specify an IP address, that IP address must be a static IP address you bought somehow; otherwise, in the case of cloud Kubernetes clusters, you can omit the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1224.1">loadBalancerIP</span></code><span class="koboSpan" id="kobo.1225.1"> property and a dynamic IP address is automatically assigned to the service by the infrastructure. </span><span class="koboSpan" id="kobo.1225.2">In AKS, you must also specify the resource group where the IP address has been allocated in an annotation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1226.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1227.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1228.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1229.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1230.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1231.1">annotations:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1232.1">service.beta.kubernetes.io/azure-load-balancer-resource-group:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1233.1">&lt;IP</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1234.1">resource</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1235.1">group</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1236.1">name&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1237.1">Moreover, you must give the “Network Contributor” role on the resource group where you defined the static IP address to the managed identity associated to the AKS cluster (as a default, a managed identity is automatically assigned to any newly created AKS cluster). </span><span class="koboSpan" id="kobo.1237.2">See the detailed procedure for performing this operation here: </span><a href="https://learn.microsoft.com/en-us/azure/aks/static-ip"><span class="url"><span class="koboSpan" id="kobo.1238.1">https://learn.microsoft.com/en-us/azure/aks/static-ip</span></span></a><span class="koboSpan" id="kobo.1239.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1240.1">You can also specify an annotation with a label:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1241.1">service.beta.kubernetes.io/azure-dns-label-name: &lt;label &gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1242.1">In which case, Azure will automatically associate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1243.1">&lt;label&gt;.&lt;location&gt;.cloudapp.azure.com</span></code><span class="koboSpan" id="kobo.1244.1"> domain name to the LoadBalancer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1245.1">If you want to publish the service on a custom domain name, you need to buy a domain name, and then </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.1246.1">you need to create an Azure DNS zone with appropriate </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.1247.1">DNS records. </span><span class="koboSpan" id="kobo.1247.2">However, in this case, it is better to use an Ingress instead of a simple LoadBalancer (see the </span><em class="italic"><span class="koboSpan" id="kobo.1248.1">Ingresses</span></em><span class="koboSpan" id="kobo.1249.1"> subsection).</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1250.1"> The loadBalancerIP property has been declared obsolete and will be removed in future Kubernetes versions. </span><span class="koboSpan" id="kobo.1250.2">It should be replaced by a platform-dependent annotation. </span><span class="koboSpan" id="kobo.1250.3">In the case of AKS, the annotation is: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1251.1">service.beta.kubernetes.io/azure-pip-name: &lt;your static IP address&gt;</span></code></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1252.1">Let’s go back to our nginx example and let’s create a LoadBalancer Service to expose our load-balanced web servers on the internet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1253.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1254.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1255.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1256.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1257.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1258.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1259.1">webservers-service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1260.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1261.1">basic-examples</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1262.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1263.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1264.1">LoadBalancer</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1265.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1266.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1267.1">webservers</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1268.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1269.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1270.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1271.1">http</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1272.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1273.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1274.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1275.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1276.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1277.1">80</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1278.1">We don’t specify an IP address since we are going to test the example in Minikube, a simulator that uses a particular procedure to expose LoadBalancer Services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1279.1">Let’s place the Service definition in a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1280.1">WebServersService.yaml</span></code><span class="koboSpan" id="kobo.1281.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1282.1">In a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1283.1">WebServersPVC.yaml</span></code><span class="koboSpan" id="kobo.1284.1"> file, let’s also place the missing PVC:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1285.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1286.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1287.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1288.1">PersistentVolumeClaim</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1289.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1290.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1291.1">website</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1292.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1293.1">basic-examples</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1294.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1295.1">accessModes:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1296.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1297.1">ReadWriteMany</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1298.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1299.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1300.1">storage:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1301.1">1Gi</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1302.1">We have not specified a storage class because we will use the default one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1303.1">Let’s also create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1304.1">BasicExamples.yaml</span></code><span class="koboSpan" id="kobo.1305.1"> file for defining the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1306.1">basic-examples</span></code><span class="koboSpan" id="kobo.1307.1"> namespace:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1308.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1309.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1310.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1311.1">Namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1312.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1313.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1314.1">basic-examples</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1315.1">Now let’s copy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1316.1">index.html</span></code><span class="koboSpan" id="kobo.1317.1"> file contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1318.1">ch08</span></code><span class="koboSpan" id="kobo.1319.1"> folder of the book’s GitHub repository, or any </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.1320.1">other self-contained HTML page with no </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.1321.1">external references to other images/content, in the same folder containing all the above </span><code class="inlineCode"><span class="koboSpan" id="kobo.1322.1">.yaml</span></code><span class="koboSpan" id="kobo.1323.1"> files. </span><span class="koboSpan" id="kobo.1323.2">We will use that page as experimental content to be shown by the web servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1324.1">Let’s start our experiment:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1325.1">Open a console on the folder containing all </span><code class="inlineCode"><span class="koboSpan" id="kobo.1326.1">.yaml</span></code><span class="koboSpan" id="kobo.1327.1"> files (right-click on the folder and select the console option).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1328.1">Ensure Minikube is running, and if not, start it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1329.1">minikube start</span></code><span class="koboSpan" id="kobo.1330.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1331.1">Deploy all files in the right sequence, that is, ensuring that all resources referenced in a file have already been created.
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.1332.1">kubectl apply -f BasicExamples.yaml
kubectl apply -f WebServersPVC.yaml
kubectl apply -f WebServers.yaml
kubectl apply -f WebServersService.yaml
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1333.1">Now we need to copy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">index.html</span></code><span class="koboSpan" id="kobo.1335.1"> files in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1336.1">/usr/share/nginx/html</span></code><span class="koboSpan" id="kobo.1337.1"> folder of either of the two created Pods. </span><span class="koboSpan" id="kobo.1337.2">It will also be seen by the other Pod, since they share the same disk storage. </span><span class="koboSpan" id="kobo.1337.3">For this operation, we need a Pod name. </span><span class="koboSpan" id="kobo.1337.4">Let’s get it with:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.1338.1">kubectl get pods -n Basic-Examples
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1339.1">A file can be copied in a Kubernetes Pod with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1340.1">kubectl cp</span></code><span class="koboSpan" id="kobo.1341.1"> command:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.1342.1">kubectl cp  &lt;source path&gt; &lt;namesapace&gt;/&lt;pod name&gt;:&lt;destination folder&gt;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1343.1">In our case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1344.1">cp</span></code><span class="koboSpan" id="kobo.1345.1"> command becomes:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.1346.1">kubectl cp Index.html basic-examples/&lt;pod name&gt;:/usr/share/nginx/html
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1347.1">In Minikube, you can </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.1348.1">access the cluster </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.1349.1">through a LoadBalancer service by creating a tunnel. </span><span class="koboSpan" id="kobo.1349.2">Do the following:</span><ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1"><span class="koboSpan" id="kobo.1350.1">Open a new console window</span></li>
<li class="alphabeticList level-2"><span class="koboSpan" id="kobo.1351.1">In this new window, issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1352.1">minikube tunnel</span></code><span class="koboSpan" id="kobo.1353.1"> command</span></li>
<li class="alphabeticList level-2"><span class="koboSpan" id="kobo.1354.1">The window will freeze on the command. </span><span class="koboSpan" id="kobo.1354.2">As long as the window remains open, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1355.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.1356.1"> is accessible through </span><code class="inlineCode"><span class="koboSpan" id="kobo.1357.1">localhost</span></code><span class="koboSpan" id="kobo.1358.1">. </span><span class="koboSpan" id="kobo.1358.2">Anyway, you can verify the external IP assigned to the LoadBalancer by issuing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1359.1">kubectl get services -n Basic-Examples</span></code><span class="koboSpan" id="kobo.1360.1"> in the previous window.</span></li>
</ol>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1361.1">Open your favourite browser and go to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1362.1">http://localhost</span></code><span class="koboSpan" id="kobo.1363.1">. </span><span class="koboSpan" id="kobo.1363.2">You should see the content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1364.1">index.html</span></code><span class="koboSpan" id="kobo.1365.1"> page.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1366.1">Once you’ve finished experimenting, let’s destroy all resources in reverse order (the opposite order in which you created them):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1367.1">kubectl delete -f WebServersService.yaml
kubectl delete -f WebServers.yaml
kubectl delete -f WebServersPVC.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1368.1">You can keep the namespace definition since we will use it in the next example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1369.1">All Deployment replicas are identical; they have no identity, so there is no way to refer to a specific replica from your code. </span><span class="koboSpan" id="kobo.1369.2">If a replica goes down, for instance, because of a node crash, the system might have a small performance issue, but will continue working properly since replicas are just a way to improve performance, so no replica is indispensable.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1370.1"> It is worth pointing out that as soon as Kubernetes detects a node fault, it recreates all Pods hosted on that node elsewhere. </span><span class="koboSpan" id="kobo.1370.2">However, this operation might take time since the fault might not be detected as soon as it takes place. </span><span class="koboSpan" id="kobo.1370.3">In the meantime, applications might have malfunctions if a Pod hosted by the faulty node is indispensable, which is why Deployments must be preferred whenever possible.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1371.1">Unfortunately, there are </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.1372.1">situations where identical copies can’t </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.1373.1">achieve the needed parallelism, but we need non-identical sharded copies. </span><span class="koboSpan" id="kobo.1373.2">If you don’t remember what sharding is and why it is necessary in some situations, please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1374.1">Ensuring that messages are processed in proper order</span></em><span class="koboSpan" id="kobo.1375.1"> section of </span><a href="Chapter_7.xhtml#_idTextAnchor151"><em class="italic"><span class="koboSpan" id="kobo.1376.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.1377.1">, Microservices in Practice</span></em><span class="koboSpan" id="kobo.1378.1">. </span><strong class="keyWord"><span class="koboSpan" id="kobo.1379.1">StatefulSets</span></strong><span class="koboSpan" id="kobo.1380.1"> furnish the kind of replication needed for sharding.</span></p>
<h2 class="heading-2" id="_idParaDest-158"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.1381.1">StatefulSets and Headless Services</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1382.1">All replicas of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1383.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1384.1"> are assigned indexes that go from 0 to N-1, where N is the number of replicas. </span><span class="koboSpan" id="kobo.1384.2">Their Pod names are predictable, too, since they are built as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1385.1">&lt;StatefulSet name&gt;-&lt;replica index&gt;</span></code><span class="koboSpan" id="kobo.1386.1">. </span><span class="koboSpan" id="kobo.1386.2">Their domain names also contain the Pod names, so that each Pod has its own domain name: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1387.1">&lt;POD name&gt;.&lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local</span></code><span class="koboSpan" id="kobo.1388.1">, or simply </span><code class="inlineCode"><span class="koboSpan" id="kobo.1389.1">&lt;POD name&gt;.&lt;service name&gt;.&lt;namespace&gt;</span></code><span class="koboSpan" id="kobo.1390.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1391.1">When a </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.1392.1">StatefulSet is created, all replicas are created in order </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.1393.1">of increasing index; while when it is destroyed, all replicas are destroyed in decreasing index order. </span><span class="koboSpan" id="kobo.1393.2">The same happens when the number of replicas is changed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1394.1">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.1395.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1396.1"> must have an associated Service that must be declared in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1397.1">serviceName</span></code><span class="koboSpan" id="kobo.1398.1"> property of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1400.1">. </span><span class="koboSpan" id="kobo.1400.2">The definition of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1402.1"> is almost identical to that of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">Deployment</span></code><span class="koboSpan" id="kobo.1404.1">; the only </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.1405.1">difference being that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1406.1">kind</span></code><span class="koboSpan" id="kobo.1407.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1408.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1409.1"> and there is </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.1410.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1411.1">serviceName:”&lt;service name&gt;“</span></code><span class="koboSpan" id="kobo.1412.1"> property immediately under the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1413.1">spec</span></code><span class="koboSpan" id="kobo.1414.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1415.1">The service associated to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1416.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1417.1"> must be a so-called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1418.1">Headless</span></code><span class="koboSpan" id="kobo.1419.1"> service, which is defined as a ClusterIP service but with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1420.1">ClusterIP: None</span></code><span class="koboSpan" id="kobo.1421.1"> property under </span><code class="inlineCode"><span class="koboSpan" id="kobo.1422.1">spec</span></code><span class="koboSpan" id="kobo.1423.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1424.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1425.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1426.1">clusterIP:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1427.1">None</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1428.1">selector:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1429.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1430.1">It is also worth pointing out that, typically, each replica has its own private storage, so, usually, StatefulSet definitions do not have a reference to a PVC, but instead use a PVC template that attaches a different PVC to each created Pod:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1431.1">volumeClaimTemplates:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1432.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1433.1">metadata</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1434.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1435.1">spec:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1436.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1437.1">Where both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1438.1">metadata</span></code><span class="koboSpan" id="kobo.1439.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1440.1">spec</span></code><span class="koboSpan" id="kobo.1441.1"> properties are identical to those of a PVC resource.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1442.1">Below is an </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.1443.1">example of a StatefulSet with its associated </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.1444.1">Headless Service. </span><span class="koboSpan" id="kobo.1444.2">The Pod name is passed to </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.1445.1">each container through an environment variable, so that the </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.1446.1">code is aware of its index and its possible role in a sharding algorithm:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1447.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1448.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1449.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1450.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1451.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1452.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1453.1">podname</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1454.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1455.1">basic-examples</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1456.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1457.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1458.1">podname</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1459.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1460.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1461.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1462.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1463.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1464.1">clusterIP:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1465.1">None</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1466.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1467.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1468.1">podname</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1469.1">---</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1470.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1471.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1472.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1473.1">StatefulSet</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1474.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1475.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1476.1">podname</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1477.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1478.1">basic-examples</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1479.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1480.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1481.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1482.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1483.1">podname</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1484.1">serviceName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1485.1">"podname"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1486.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1487.1">3</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1488.1">template:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1489.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1490.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1491.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1492.1">podname</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1493.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1494.1">containers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1495.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1496.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1497.1">test</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1498.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1499.1">alpine:latest</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1500.1">command:</span></span><span class="koboSpan" id="kobo.1501.1"> [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1502.1">'sh'</span></span><span class="koboSpan" id="kobo.1503.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1504.1">'-c'</span></span><span class="koboSpan" id="kobo.1505.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1506.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1507.1">while true; do echo $(MY_POD_NAME); sleep 3; done'</span></span><span class="koboSpan" id="kobo.1508.1">]
        </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1509.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1510.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1511.1">containerPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1512.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1513.1">env:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1514.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1515.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1516.1">MY_POD_NAME</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1517.1">valueFrom:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1518.1">fieldRef:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1519.1">fieldPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1520.1">metadata.name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1521.1">volumeClaimTemplates:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1522.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1523.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1524.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1525.1">volumetest</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1526.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1527.1">accessModes:</span></span><span class="koboSpan" id="kobo.1528.1"> [ </span><span class="hljs-string"><span class="koboSpan" id="kobo.1529.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1530.1">ReadWriteOnce"</span></span><span class="koboSpan" id="kobo.1531.1"> ]
      </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1532.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1533.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1534.1">storage:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1535.1">1Gi</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1536.1">Each Pod </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.1537.1">contains just the Alpine Linux distribution, and the </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.1538.1">actual code is provided in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1539.1">command</span></code><span class="koboSpan" id="kobo.1540.1">, which just prints </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.1541.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1542.1">MY_POD_NAME</span></code><span class="koboSpan" id="kobo.1543.1"> environment variable in </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.1544.1">an endless loop. </span><span class="koboSpan" id="kobo.1544.2">In turn, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1545.1">MY_POD_NAME</span></code><span class="koboSpan" id="kobo.1546.1"> environment variable is set with:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet"><span class="koboSpan" id="kobo.1547.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1548.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1549.1">MY_POD_NAME</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1550.1">valueFrom:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1551.1">fieldRef:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1552.1">fieldPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1553.1">metadata.name</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1554.1">This code takes the value from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1555.1">metadata.name</span></code><span class="koboSpan" id="kobo.1556.1"> field of the Pod. </span><span class="koboSpan" id="kobo.1556.2">In fact, if we did not specify a name in the Pod template metadata section, a name would automatically be created by the StatefulSet and added to the resource internal representation of the Pod. </span><span class="koboSpan" id="kobo.1556.3">The Kubernetes component that makes the Pod fields available to environment variables definition is </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.1557.1">called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1558.1">downward API</span></strong><span class="koboSpan" id="kobo.1559.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1560.1">The above StatefulSet does nothing useful but just shows how to pass the Pod name to your containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1561.1">Put the above code in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1562.1">StateFulSetExample.yaml</span></code><span class="koboSpan" id="kobo.1563.1"> file and apply it!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1564.1">If you issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1565.1">kubectl get pods -n basic-examples</span></code><span class="koboSpan" id="kobo.1566.1"> command, you can verify that all 3 replicas were </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.1567.1">created with the right names based on the StatefulSet name and </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.1568.1">on your indexes. </span><span class="koboSpan" id="kobo.1568.2">Now let’s verify that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1569.1">podname-1</span></code><span class="koboSpan" id="kobo.1570.1"> correctly received its name, by displaying its log:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1571.1">kubectl logs podname-1 -n basic-examples
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1572.1">You should </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.1573.1">see several lines with the right Pod name. </span><span class="koboSpan" id="kobo.1573.2">Great!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1574.1">Now let’s </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.1575.1">verify that our code created 3 different PVCs:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1576.1">kubectl get persistentvolume -n basic-examples
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1577.1">You should see three different claims.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1578.1">When you finish experimenting with the example, you can delete everything with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1579.1">kubectl delete -f StateFulSetExample.yaml</span></code><span class="koboSpan" id="kobo.1580.1">. </span><span class="koboSpan" id="kobo.1580.2">Unluckily, deleting everything does not also delete the PVC created by templates, as you can verify at this point. </span><span class="koboSpan" id="kobo.1580.3">The simplest way to delete them is by deleting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1581.1">basic-examples</span></code><span class="koboSpan" id="kobo.1582.1"> namespace with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1583.1">kubectl delete namespace basic-exampleswhole
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1584.1">Then, if you want, you can recreate it with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1585.1">kubectl create namespace basic-examples
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1586.1">Statefulsets are used to deploy RabbitMQ clusters and database clusters in Kubernetes. </span><span class="koboSpan" id="kobo.1586.2">If a master node is needed, then one with a specific index (usually 0) elects itself as a master. </span><span class="koboSpan" id="kobo.1586.3">Each replica uses its own disk storage so that both data sharding and data replication strategies can be enforced. </span><span class="koboSpan" id="kobo.1586.4">It’s likely that you won’t need to do this yourself, since the code for deploying clusters of the most famous message-broker and database clusters is already available on the web.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1587.1">Having learned how to create and maintain several replicas of a microservice, we have to learn how to set and update the number of replicas, that is, how to scale our microservices.</span></p>
<h2 class="heading-2" id="_idParaDest-159"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.1588.1">Scaling and autoscaling</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1589.1">Scaling is fundamental for application performance tuning. </span><span class="koboSpan" id="kobo.1589.2">We must distinguish between scaling the </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.1590.1">number of replicas of each microservice and scaling the number of nodes of the whole Kubernetes cluster.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1591.1">The number </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.1592.1">of nodes is usually tuned according to the average CPU busy percentage. </span><span class="koboSpan" id="kobo.1592.2">For instance, one might start with a 50% percentage when the initial application traffic is low. </span><span class="koboSpan" id="kobo.1592.3">Then, as the application traffic increases, we maintain the same number of nodes till we are able to keep a good response time, possibly tuning the number of microservice replicas. </span><span class="koboSpan" id="kobo.1592.4">Suppose that performance starts to decrease when the CPU busy percentage is 80%. </span><span class="koboSpan" id="kobo.1592.5">Then, we can target, say, a 75% CPU busy time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1593.1">Automatic cluster scaling is possible just with cloud clusters, and each cloud provider offers some kind of autoscaling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1594.1">With regard to AKS, in the </span><em class="italic"><span class="koboSpan" id="kobo.1595.1">Creating an Azure Kubernetes cluster</span></em><span class="koboSpan" id="kobo.1596.1"> section, we saw that we can specify both a minimum and a maximum number of nodes, and AKS tries to optimize performance for us. </span><span class="koboSpan" id="kobo.1596.2">You can also fine-tune how AKS decides the number of nodes. </span><span class="koboSpan" id="kobo.1596.3">More details on this customization are given in the references in the </span><em class="italic"><span class="koboSpan" id="kobo.1597.1">Further reading</span></em><span class="koboSpan" id="kobo.1598.1"> section. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1599.1">There are also automatic auto-scalers that integrate with various cloud providers (</span><a href="https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/"><span class="url"><span class="koboSpan" id="kobo.1600.1">https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/</span></span></a><span class="koboSpan" id="kobo.1601.1">). </span><span class="koboSpan" id="kobo.1601.2">As a default, auto-scalers increase the number of nodes when Kubernetes is not able to satisfy the resources required by a Pod, which is the sum of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1602.1">resource-&gt;request</span></code><span class="koboSpan" id="kobo.1603.1"> fields of all Pod containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1604.1">Scaling microservice replicas, instead, is a more difficult task. </span><span class="koboSpan" id="kobo.1604.2">You may calculate it by measuring the average replica response time and then calculating:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1605.1">&lt;number</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1606.1">of</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1607.1">replicas&gt;</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1608.1">=</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1609.1">&lt;target</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1610.1">throughput</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1611.1">(requests</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1612.1">per</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1613.1">second)&gt;&lt;average</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1614.1">response</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1615.1">time</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1616.1">in</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1617.1">seconds&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1618.1">Where the target throughput should be a raw estimate calculated with simple calculations. </span><span class="koboSpan" id="kobo.1618.2">For frontend microservices, it is just the number of requests you expect your application will receive for each API call. </span><span class="koboSpan" id="kobo.1618.3">For Worker services, it can depend on the number of requests expected on several frontend services, but there is no standard way to compute it. </span><span class="koboSpan" id="kobo.1618.4">Instead, you need to reason about how the application works and how the requests directed to that Worker microservice are created.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1619.1">Then, you should monitor the system performance, looking for bottlenecks, according to the following procedure:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1620.1">Look for a microservice that is a bottleneck</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1621.1">Increase its number of replicas till it stops being a bottleneck</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1622.1">Repeat point 1 till there are no evident bottlenecks</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1623.1">Then optimize the number of cluster nodes to achieve good performance</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1624.1">Store the average CPU utilization memory occupation of all Deployments and StatefulSets, and the average number of requests reaching the whole application. </span><span class="koboSpan" id="kobo.1624.2">You may use this data for setting auto-scalers. </span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1625.1">While StatefulSets are difficult to scale automatically, Deployments can be automatically scaled without causing problems. </span><span class="koboSpan" id="kobo.1625.2">Therefore, you may use a Kubernetes Pod auto-scaler to scale them automatically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1626.1">Pod auto-scaler </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.1627.1">targets are either average per Pod resource consumption or metrics somehow connected with the traffic. </span><span class="koboSpan" id="kobo.1627.2">In the first case, the auto-scaler chooses the number of </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.1628.1">replicas that makes the resource consumption closest to a specified target. </span><span class="koboSpan" id="kobo.1628.2">In the second case, the number of replicas is set to the actual value of the traffic metric divided by the target value of the metric, that is, the traffic target is interpreted as the target traffic sustained by each Deployment Pod.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1629.1">If several target types are specified, the maximum number of replicas proposed by each of them is taken.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1630.1">An auto-scaler can be defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1631.1">apiVersion</span></span><span class="koboSpan" id="kobo.1632.1">: autoscaling/v2
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.1633.1">kind</span></span><span class="koboSpan" id="kobo.1634.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.1635.1">HorizontalPodAutoscaler</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1636.1">metadata</span></span><span class="koboSpan" id="kobo.1637.1">:
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1638.1">name</span></span><span class="koboSpan" id="kobo.1639.1">: myautoscalername
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1640.1">namespace</span></span><span class="koboSpan" id="kobo.1641.1">: mynamespace
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.1642.1">spec</span></span><span class="koboSpan" id="kobo.1643.1">:
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1644.1">scaleTargetRef</span></span><span class="koboSpan" id="kobo.1645.1">:
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1646.1">apiVersion</span></span><span class="koboSpan" id="kobo.1647.1">: apps/v1
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1648.1">kind</span></span><span class="koboSpan" id="kobo.1649.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.1650.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1651.1">name</span></span><span class="koboSpan" id="kobo.1652.1">: mydeploymentname
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1653.1">minReplicas</span></span><span class="koboSpan" id="kobo.1654.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1655.1">1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1656.1">maxReplicas</span></span><span class="koboSpan" id="kobo.1657.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1658.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1659.1">metrics</span></span><span class="koboSpan" id="kobo.1660.1">:
  - </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1661.1">type</span></span><span class="koboSpan" id="kobo.1662.1">: </span><span class="hljs-tag"><span class="koboSpan" id="kobo.1663.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.1664.1">resource</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1665.1">or</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1666.1">pod</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1667.1">or</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1668.1">object</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.1669.1">&gt;</span></span><span class="koboSpan" id="kobo.1670.1">
    …
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1671.1">We specify the type of resource to control and the API where it is defined, and its name. </span><span class="koboSpan" id="kobo.1671.2">Both the controlled resource and the auto-scaler must be defined in the same namespace. </span><span class="koboSpan" id="kobo.1671.3">You can set </span><code class="inlineCode"><span class="koboSpan" id="kobo.1672.1">scaleTargetRef-&gt;kind</span></code><span class="koboSpan" id="kobo.1673.1"> also to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1674.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1675.1">, but you need to verify that the change in the number </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.1676.1">of replicas doesn’t break your sharding algorithm, both in the long run and during transitions between different numbers of replicas.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1677.1">Then, we specify the </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.1678.1">maximum and minimum number of replicas. </span><span class="koboSpan" id="kobo.1678.2">If the computed number of replicas exceeds this interval, it is cut to either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1679.1">minReplicas</span></code><span class="koboSpan" id="kobo.1680.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1681.1">maxReplicas</span></code><span class="koboSpan" id="kobo.1682.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1683.1">Finally, we have the list of criteria, where each criterion may refer to three types of </span><strong class="keyWord"><span class="koboSpan" id="kobo.1684.1">metrics</span></strong><span class="koboSpan" id="kobo.1685.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1686.1">resource</span></code><span class="koboSpan" id="kobo.1687.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1688.1">pod</span></code><span class="koboSpan" id="kobo.1689.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1690.1">object</span></code><span class="koboSpan" id="kobo.1691.1">. </span><span class="koboSpan" id="kobo.1691.2">We will describe each of them in a separate subsection.</span></p>
<h3 class="heading-3" id="_idParaDest-160"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.1692.1">Resource metrics</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1693.1">Resource metrics are based on the average memory and CPU resources wasted by each Pod. </span><span class="koboSpan" id="kobo.1693.2">The target </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.1694.1">consumption may be an absolute value such as 100Mb, or 20mi (millicores), in which </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.1695.1">case the number of replicas is computed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1696.1">&lt;actual average consumption&gt;/&lt;target consumption&gt;</span></code><span class="koboSpan" id="kobo.1697.1">. </span><span class="koboSpan" id="kobo.1697.2">Resource metrics based on absolute values are declared as:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet"><span class="koboSpan" id="kobo.1698.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1699.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1700.1">Resource</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1701.1">resource:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1702.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1703.1">&lt;memory</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1704.1">or</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1705.1">cpu&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1706.1">target:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1707.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1708.1">AverageValue</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1709.1">averageValue:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1710.1">&lt;target</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1711.1">memory</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1712.1">or</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1713.1">cpu&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1714.1">The target can also be specified as a percentage of the total Pod </span><code class="inlineCode"><span class="koboSpan" id="kobo.1715.1">resource-&gt;request</span></code><span class="koboSpan" id="kobo.1716.1"> declared (sum of all Pod containers). </span><span class="koboSpan" id="kobo.1716.2">In this case, Kubernetes first computes:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag"><span class="koboSpan" id="kobo.1717.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.1718.1">utilization</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.1719.1">&gt;</span></span><span class="koboSpan" id="kobo.1720.1"> = 100*</span><span class="hljs-tag"><span class="koboSpan" id="kobo.1721.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.1722.1">actual</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1723.1">average</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1724.1">consumption</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.1725.1">&gt;</span></span><span class="koboSpan" id="kobo.1726.1">/</span><span class="hljs-tag"><span class="koboSpan" id="kobo.1727.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.1728.1">declared</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1729.1">resource</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1730.1">request</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.1731.1">&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1732.1">Then, the number of replicas is computed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1733.1">&lt;utilization&gt;/&lt;target utilization&gt;</span></code><span class="koboSpan" id="kobo.1734.1">. </span><span class="koboSpan" id="kobo.1734.2">For instance, if the target CPU utilization is 50 on average, each Pod must waste 50% of the CPU millicores declared in the request. </span><span class="koboSpan" id="kobo.1734.3">Therefore, if the average CPU wasted by all Pods of a Deployment is 30Mi, while the CPU required by each Pod is 20mi, we compute the utilization as 100*30/20= 150. </span><span class="koboSpan" id="kobo.1734.4">So, the number of replicas is 150/50 = 3.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1735.1">In this case, the code is:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet"><span class="koboSpan" id="kobo.1736.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1737.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1738.1">Resource</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1739.1">resource:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1740.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1741.1">&lt;memory</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1742.1">or</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1743.1">cpu&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1744.1">target:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1745.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1746.1">Utilization</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1747.1">averageUtilization:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1748.1">&lt;target</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1749.1">memory</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1750.1">or</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1751.1">cpu</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1752.1">utilization&gt;</span></span>
</code></pre>
<h3 class="heading-3" id="_idParaDest-161"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.1753.1">Pod metrics</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1754.1">Pod metrics </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.1755.1">are not standard but depend on the metrics actually computed </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.1756.1">by each specific cloud platform or on-premise installation. </span><span class="koboSpan" id="kobo.1756.2">Pod metric constraints are declared as:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet"><span class="koboSpan" id="kobo.1757.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1758.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1759.1">Pods</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1760.1">pods:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1761.1">metric:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1762.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1763.1">packets-per-second</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1764.1">target:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1765.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1766.1">AverageValue</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1767.1">averageValue:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1768.1">1k</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1769.1">Where we suppose that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1770.1">packets-per-second</span></code><span class="koboSpan" id="kobo.1771.1"> metric exists in the platform and computes the average communication packets received per second by a Pod. </span><span class="koboSpan" id="kobo.1771.2">The calculation of the number of replicas is done as in the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1772.1">averageValue</span></code><span class="koboSpan" id="kobo.1773.1"> for resource metrics.</span></p>
<h3 class="heading-3" id="_idParaDest-162"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.1774.1">Object metrics</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1775.1">Object metrics refer to metrics computed on objects outside of the controlled Pods but inside the Kubernetes </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.1776.1">cluster. </span><span class="koboSpan" id="kobo.1776.2">Like Pod metrics, object metrics are also not </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.1777.1">standard but depend on the metrics actually computed by each specific platform.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1778.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.1779.1">Advanced Kubernetes configuration</span></em><span class="koboSpan" id="kobo.1780.1"> section, we will describe Kubernetes resources called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1781.1">Ingresses</span></strong><span class="koboSpan" id="kobo.1782.1"> that interface </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.1783.1">the Kubernetes cluster with the external world. </span><span class="koboSpan" id="kobo.1783.2">Typically, all Kubernetes input traffic transits through a single Ingress, so we can measure the total input traffic by measuring the traffic inside that Ingress. </span><span class="koboSpan" id="kobo.1783.3">Once a cluster has been empirically optimized, and we need to just adapt it to temporary peaks, the easiest way to do it is by connecting the number of replicas of each frontend microservice and also of some Worker microservice to the total application input traffic. </span><span class="koboSpan" id="kobo.1783.4">This can be done with Object metric constraints that reference the unique application Ingress:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet"><span class="koboSpan" id="kobo.1784.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1785.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1786.1">Object</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1787.1">object:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1788.1">metric:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1789.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1790.1">requests-per-second</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1791.1">describedObject:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1792.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1793.1">networking.k8s.io/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1794.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1795.1">Ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1796.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1797.1">application-ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1798.1">target:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1799.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1800.1">Value</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1801.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1802.1">10k</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1803.1">In this case, we have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1804.1">value</span></code><span class="koboSpan" id="kobo.1805.1"> since we don’t average on several objects, but the number of replicas is computed as for the Pod metrics. </span><span class="koboSpan" id="kobo.1805.2">Moreover, in this case, we must be sure that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1806.1">requests-per-second</span></code><span class="koboSpan" id="kobo.1807.1"> metric is actually computed by the infrastructure on all Ingresses.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1808.1">Personally, I always use CPU and memory metrics since they are available on all platforms, and since using </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.1809.1">the procedure sketched in this subsection, it is reasonably easy to find good target values for them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1810.1">Though all </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.1811.1">cloud providers offer useful Kubernetes metrics, there are open-source metric servers that can also be installed on on-premises Kubernetes clusters through </span><code class="inlineCode"><span class="koboSpan" id="kobo.1812.1">.yaml</span></code><span class="koboSpan" id="kobo.1813.1"> files. </span><span class="koboSpan" id="kobo.1813.2">See the </span><em class="italic"><span class="koboSpan" id="kobo.1814.1">Further reading</span></em><span class="koboSpan" id="kobo.1815.1"> section for an example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1816.1">Minikube has a metrics-server addon that can be installed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1817.1">minikube addons enable metrics-server</span></code><span class="koboSpan" id="kobo.1818.1">. </span><span class="koboSpan" id="kobo.1818.2">You also need it to use standard resource metrics like CPU and memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1819.1">In the next section, we will analyze how to test and deploy a microservice application and will put these concepts into practice by running and debugging the Worker microservice we implemented in </span><a href="Chapter_7.xhtml#_idTextAnchor151"><em class="italic"><span class="koboSpan" id="kobo.1820.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.1821.1">, Microservices in Practice</span></em><span class="koboSpan" id="kobo.1822.1">, on Minikube.</span></p>
<h1 class="heading-1" id="_idParaDest-163"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.1823.1">Running your microservices on Kubernetes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1824.1">In this section, we will test the routes-matching worker microservice in Minikube, but we will also </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.1825.1">describe how to organize the various environments your microservices application will be deployed to: development, staging, and production. </span><span class="koboSpan" id="kobo.1825.2">Each environment has its own peculiarities, such as an easy way to test each change in development and maximizing performance in production.</span></p>
<h2 class="heading-2" id="_idParaDest-164"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.1826.1">Organizing all deployment environments</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1827.1">It is also </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.1828.1">worth pointing out that the simplest test in Minikube requires a not-negligible setup time. </span><span class="koboSpan" id="kobo.1828.2">Therefore, most development simply uses Docker, that is, a few containerized microservices organized into a unique Visual Studio solution that starts all of them when you launch the solution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1829.1">At this stage, we don’t test the whole application but just a few tightly interacting microservices, possibly simulating the remainder of the application with stubs. </span><span class="koboSpan" id="kobo.1829.2">If communication is handled through a message broker, it is enough to launch all microservices and the message broker to test everything; otherwise, if we rely on direct communication between microservices, we must connect all microservices in a virtual network.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1830.1">Docker offers the possibility to both create a virtual network and connect running containers to it. </span><span class="koboSpan" id="kobo.1830.2">The virtual network created by Docker also includes your development machine, which gets the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1831.1">host.docker.internal</span></strong><span class="koboSpan" id="kobo.1832.1"> hostname. </span><span class="koboSpan" id="kobo.1832.2">Therefore, all microservices can use various services running on the development machine, such as RabbitMQ, SQL Server, and Redis.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1833.1">You can create a test virtual network in Docker with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1834.1">docker network create myvirtualnet
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1835.1">Then, attaching </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.1836.1">all running microservices to this network is super easy. </span><span class="koboSpan" id="kobo.1836.2">It is enough to modify their project files as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1837.1">&lt;PropertyGroup&gt;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1838.1">&lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1839.1">…</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1840.1">&lt;DockerfileRunArguments&gt;--net</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1841.1">myvirtualnet</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1842.1">--name</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1843.1">myhostname&lt;/DockerfileRunArguments&gt;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1844.1">&lt;/PropertyGroup&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1845.1">Then, you can also </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.1846.1">add other </span><code class="inlineCode"><span class="koboSpan" id="kobo.1847.1">docker run</span></code><span class="koboSpan" id="kobo.1848.1"> arguments, such as a volume mount.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1849.1">Testing on Minikube can be performed at the end of the working day or simply after the complete implementation of a feature.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1850.1">In the next subsections, we will compare all deployment environments on the following axes:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1851.1">Database engine and database installation</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1852.1">Container registries</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1853.1">Message broker installation</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1854.1">Debugging techniques</span></li>
</ol>
<h3 class="heading-3" id="_idParaDest-165"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.1855.1">Database engine and database installation</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1856.1">Development tests with Docker or Minikube may all use a database engine running directly on the </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.1857.1">development machine. </span><span class="koboSpan" id="kobo.1857.2">You may use </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.1858.1">either an actual installation or an engine running as a Docker container. </span><span class="koboSpan" id="kobo.1858.2">The advantage is that the database is also accessible from Visual Studio, so you can pass all migrations while you develop them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1859.1">You can also use fresh Docker containers running the database engine to start databases from scratch and perform unit tests, or to test the overall migration set.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.1860.1"> If you installed Minikube with the Docker driver, a database running on your development machine can be reached from inside your Minikube containers by using either the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1861.1">host.minikube.internal</span></strong><span class="koboSpan" id="kobo.1862.1"> or </span><strong class="keyWord"><span class="koboSpan" id="kobo.1863.1">host.docker.internal</span></strong><span class="koboSpan" id="kobo.1864.1"> hostnames. </span><span class="koboSpan" id="kobo.1864.2">Therefore, if you use </span><strong class="keyWord"><span class="koboSpan" id="kobo.1865.1">host.docker.internal</span></strong><span class="koboSpan" id="kobo.1866.1">, you will be able to reach your host machine from both Minikube and from your containerized applications directly launched by Visual Studio.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1867.1">On both staging and production, you can use database cloud services that ensure good performance, are scalable, and offer clustering, replication, geographic redundancy, and so on. </span><span class="koboSpan" id="kobo.1867.2">It’s also possible to deploy the database inside your Kubernetes cluster, but in this case, you must buy a license, you should dedicate ad hoc Kubernetes nodes for the database (virtual machines that </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.1868.1">ensure optimal database performance), and you should fine-tune the database configuration. </span><span class="koboSpan" id="kobo.1868.2">Therefore, if there are no compelling </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.1869.1">reasons for a different choice, it is more convenient to opt for cloud services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1870.1">Moreover, both in production and staging, you can’t configure your Deployments to automatically apply migrations when they start; otherwise, all replicas will attempt to apply them. </span><span class="koboSpan" id="kobo.1870.2">It’s better to extract a database script from your migrations and apply it with a database DBO user privilege, while leaving the microservice replicas with a less privileged database user.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1871.1">A database script can be extracted from all migrations with the migration command below:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1872.1">Script-Migration -From</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.1873.1"> &lt;initial migration&gt; -To &lt;final migration&gt; -Output &lt;name
of output file&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1874.1">Let’s move on to container registries.</span></p>
<h3 class="heading-3" id="_idParaDest-166"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.1875.1">Container registries</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1876.1">As far as staging and production are concerned, they can both use the same container registry since containers </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.1877.1">are versioned. </span><span class="koboSpan" id="kobo.1877.2">So, for instance, production can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1878.1">v1.0</span></code><span class="koboSpan" id="kobo.1879.1">, while staging can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1880.1">v2.0-beta1</span></code><span class="koboSpan" id="kobo.1881.1">. </span><span class="koboSpan" id="kobo.1881.2">It is better if registries belong to the </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.1882.1">same cloud subscription of the Kubernetes cluster to simplify credential handling. </span><span class="koboSpan" id="kobo.1882.2">For instance, in the case of AKS, it is enough to associate a registry to an AKS cluster once and for all to grant access to the cluster to the registry (see the </span><em class="italic"><span class="koboSpan" id="kobo.1883.1">Creating an Azure Kubernetes cluster</span></em><span class="koboSpan" id="kobo.1884.1"> subsection of this chapter).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1885.1">As far as development is concerned, each developer can use the same registry used by the staging environment for the containers they are not working on, but each developer should have a private registry for the containers they are working on, so they can experiment with no risk of dirtying the “official image” registries. </span><span class="koboSpan" id="kobo.1885.2">Therefore, the simplest solution is to install a local registry in your Docker Desktop. </span><span class="koboSpan" id="kobo.1885.3">You can do this with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1886.1">docker run -d -p 5000:5000 --name registry registry:2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1887.1">Once the container has been created with the instruction above, you can stop and restart it from the Docker Desktop graphical user interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1888.1">Unluckily, as a default, both Docker and Minikube do not accept interacting with insecure registries, that is, with registries that do not support HTTPS with a certificate signed by a public authority, so we must </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.1889.1">instruct both Docker and Minikube to accept insecure interaction with the local registry.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1890.1">Let’s open the </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.1891.1">Docker Desktop graphical user interface and click on the settings image in the top-right corner:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1892.1"><img alt="Figure 8.5: Docker settings" src="../Images/B31916_08_5.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1893.1">Figure 8.5: Docker settings</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1894.1">Then, select </span><strong class="screenText"><span class="koboSpan" id="kobo.1895.1">Docker Engine</span></strong><span class="koboSpan" id="kobo.1896.1"> from the left menu, and edit the big text box that contains Docker configuration information, and add the entry shown below to the existing JSON content:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1897.1">…….,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1898.1">"insecure-registries":</span></span><span class="koboSpan" id="kobo.1899.1"> [
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1900.1">"host.docker.internal:5000"</span></span><span class="koboSpan" id="kobo.1901.1">,
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1902.1">"host.minikube.internal:5000"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1903.1">The above settings add the 5000 ports of both hostnames that point to your host computer to the allowed insecure registries. </span><span class="koboSpan" id="kobo.1903.2">The result should be something like:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1904.1"><img alt="Figure 8.6: Adding a local registry to Docker allowed insecure registries" src="../Images/B31916_08_6.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1905.1">Figure 8.6: Adding a local registry to Docker allowed insecure registries</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1906.1">As far as Minikube is concerned, you have to destroy your current Minikube VM with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1907.1">minikube delete
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1908.1">Then, you need </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.1909.1">to create a new VM image with </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.1910.1">the right insecure registry settings:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1911.1">minikube start --insecure-registry="host.docker.internal:5000" --insecure-registry="host.minikube.internal:5000"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1912.1">Please execute all the above steps because we will need a local registry for testing the route-planning microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1913.1">If Minikube also needs to access other password-protected registries, you must configure and enable the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1914.1">registry-creds</span></strong><span class="koboSpan" id="kobo.1915.1"> addon:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1916.1">minikube addons configure registry-creds
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1917.1">Once you issue the above command, you will be asked to configure Google, AWS, Azure, or Docker private registries and enter your credentials.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1918.1">After a successful configuration, you can enable the credential usage with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1919.1">minikube addons enable registry-creds
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1920.1">Let’s move on to the message broker.</span></p>
<h3 class="heading-3" id="_idParaDest-167"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.1921.1">Message broker installation</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1922.1">RabbitMQ can be installed both locally and in the cloud, and works on all clouds, so it really is a good option. </span><span class="koboSpan" id="kobo.1922.2">You can run a single RabbitMQ server or a server cluster. </span><span class="koboSpan" id="kobo.1922.3">A RabbitMQ cluster can also be </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.1923.1">installed on the Kubernetes cluster itself. </span><span class="koboSpan" id="kobo.1923.2">During development, you may install it on Minikube, but it is more convenient to run it outside of Minikube, so it can also be easily reached by applications running outside of Minikube, which, in turn, facilitates application debugging, as we will see in the next subsection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1924.1">In staging </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.1925.1">and production, the simplest way to install a RabbitMQ cluster is by installing the so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1926.1">RabbitMQ Cluster Operator</span></strong><span class="koboSpan" id="kobo.1927.1"> with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1928.1">kubectl apply -f https://raw.githubusercontent.com/rabbitmq/cluster-operator/main/docs/examples/hello-world/rabbitmq.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1929.1">The RabbitMQ operator </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.1930.1">defines the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1931.1">RabbitmqCluster</span></strong><span class="koboSpan" id="kobo.1932.1"> custom resource that represents a RabbitMQ Cluster. </span><span class="koboSpan" id="kobo.1932.2">You can create and configure </span><strong class="keyWord"><span class="koboSpan" id="kobo.1933.1">RabbitmqCluster</span></strong><span class="koboSpan" id="kobo.1934.1"> as you configure any other Kubernetes resource:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1935.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1936.1">rabbitmq.com/v1beta1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1937.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1938.1">RabbitmqCluster</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1939.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1940.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1941.1">&lt;cluster</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1942.1">name&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1943.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1944.1">&lt;cluster</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1945.1">namespace&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1946.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1947.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1948.1">3</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1949.1"># default is 1. </span><span class="koboSpan" id="kobo.1949.2">Replicas should be odd.</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1950.1">persistence:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1951.1">storageClassName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1952.1">&lt;storage</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1953.1">class</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1954.1">name&gt;</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1955.1"># default is the default storage class</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1956.1">storage:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1957.1">20Gi</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1958.1"># default 10Gi</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1959.1">The persistence section specifies the options for persisting queues on persistent storage. </span><span class="koboSpan" id="kobo.1959.2">If you omit it, all default values will be taken. </span><span class="koboSpan" id="kobo.1959.3">If you omit the number of replicas, a cluster with a single server will be created. </span><span class="koboSpan" id="kobo.1959.4">More options are available in the official documentation: </span><a href="https://www.rabbitmq.com/kubernetes/operator/using-operator"><span class="url"><span class="koboSpan" id="kobo.1960.1">https://www.rabbitmq.com/kubernetes/operator/using-operator</span></span></a><span class="koboSpan" id="kobo.1961.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1962.1">You can get the username and password of your RabbitMQ cluster default user by printing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1963.1">&lt;cluster name&gt;-default-user</span></code><span class="koboSpan" id="kobo.1964.1"> secret where they are stored, as shown below:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1965.1">kubectl get secret &lt;cluster name&gt;-default-user -n &lt;cluster namespace&gt; -o yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1966.1">Both username and password are base-64 encoded. </span><span class="koboSpan" id="kobo.1966.2">The simplest way to decode them is by copying each of them from the console output, opening a Linux console, and using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1967.1">base64</span></code><span class="koboSpan" id="kobo.1968.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1969.1">echo &lt;string to decode&gt; | base64 -d
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1970.1">If you want, you may also install the RabbitMQ cluster operator in Minikube, but in this case, it is better to start Minikube with at least 4 CPUs and 6-8 gigabytes of run.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1971.1">If you need to connect to the RabbitMQ cluster from outside of the Kubernetes cluster for debugging purposes, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">kubectl port-forward</span></code><span class="koboSpan" id="kobo.1973.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1974.1">kubectl port-forward service/&lt;cluster name&gt; 5672:5672
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1975.1">The above instruction </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.1976.1">freezes the console and forwards port 5672 of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1977.1">service/&lt;cluster name&gt;</span></code><span class="koboSpan" id="kobo.1978.1"> ClusterIP service that is part of the RabbitMQ cluster to port 5672 of localhost. </span><span class="koboSpan" id="kobo.1978.2">The port-forwarding remains active while the console window is open or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1979.1">ctrl-c</span></code><span class="koboSpan" id="kobo.1980.1"> is issued to abort the instruction.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1981.1">The general </span><code class="inlineCode"><span class="koboSpan" id="kobo.1982.1">kubectl port-forward</span></code><span class="koboSpan" id="kobo.1983.1"> syntax is:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1984.1">kubectl port-forward service/&lt;service name&gt; &lt;local host port&gt;:&lt;service port&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1985.1">In our case, the service name is equal to the cluster name.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1986.1"> The service &lt;cluster name&gt; is the ClusterIP service you must use to access the RabbitMQ cluster from inside the Kubernetes cluster. </span><span class="koboSpan" id="kobo.1986.2">Therefore, the RabbitMQ hostname to specify in the connection is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1987.1">&lt;cluster name&gt;.&lt;cluster namespace&gt;</span></code><span class="koboSpan" id="kobo.1988.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1989.1">You can also access the RabbitMQ management UI with your browser by forwarding the 15672 port:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1990.1">kubectl port-forward service/&lt;cluster name&gt; 15672:15672
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1991.1">Then, the UI will be available at </span><code class="inlineCode"><span class="koboSpan" id="kobo.1992.1">localhost:15672</span></code><span class="koboSpan" id="kobo.1993.1">. </span><span class="koboSpan" id="kobo.1993.2">There, you must use the credentials you previously extracted from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1994.1">cluster name&gt;-default-user</span></code><span class="koboSpan" id="kobo.1995.1"> secret.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1996.1">The port forwarding is safe and doesn’t expose RabbitMQ to the outside world since the connection between localhost and the service is mediated by the Kubernetes API server. </span><span class="koboSpan" id="kobo.1996.2">It can be safely used to connect test code running on the development machine with the RabbitMQ cluster, as we will see in more detail in the next subsection.</span></p>
<h3 class="heading-3" id="_idParaDest-168"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.1997.1">Debugging techniques</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1998.1">When you launch all containers from Visual Studio, you can debug your code without performing </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.1999.1">any further configuration. </span><span class="koboSpan" id="kobo.1999.2">However, if you need to debug some microservices running either in Minikube, in staging, or in production, you need some supplementary configuration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2000.1">Instead of trying to attach the debugger inside of your Kubernetes cluster, a simpler approach is to use the so-called bridge: you select a specific microservice to debug, and instead of debugging it in Kubernetes, you redirect its traffic to a replica of your microservice running in Visual Studio, then you redirect all local microservice output traffic again inside the cluster. </span><span class="koboSpan" id="kobo.2000.2">This way, you debug just a local copy that has been compiled in debug mode, overcoming both the need to replace the release code with debug code, and the difficulty of attaching a debugger inside of your Kubernetes cluster.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2001.1">The image below exemplifies the bridge idea:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2002.1"><img alt="Figure 8.7: Bridging" src="../Images/B31916_08_7.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2003.1">Figure 8.7: Bridging</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2004.1">If both inputs and outputs are handled by a message broker, bridging is easy: it is enough to connect the local copy to the same RabbitMQ queues of the in-cluster replicas. </span><span class="koboSpan" id="kobo.2004.2">This way, part of the traffic will be automatically forwarded to the local copy. </span><span class="koboSpan" id="kobo.2004.3">If the RabbitMQ cluster runs inside the Kubernetes cluster, you need to forward its ports on localhost as explained in the previous section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2005.1">Moreover, if the microservice is connected to a database, we must also connect the local copy to the same database. </span><span class="koboSpan" id="kobo.2005.2">If you are in production, this might require the definition of a firewall rule to enable access of your development machine to the database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2006.1">If some input and output are handled by services instead of message brokers, bridging becomes more complex. </span><span class="koboSpan" id="kobo.2006.2">More specifically, forwarding the output to a service inside the Kubernetes cluster is quite easy since it requires just port-forwarding the target service on localhost with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2007.1">kubectl port-forward</span></code><span class="koboSpan" id="kobo.2008.1">. </span><span class="koboSpan" id="kobo.2008.2">However, forwarding traffic from a service to the local microservice copy requires some kind of hack on the service.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2009.1">Services compute </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.2010.1">the Pods they must route the traffic to and then create resources called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2011.1">EndpointSlice </span></code><span class="koboSpan" id="kobo.2012.1">containing the IP addresses where they must route the traffic. </span><span class="koboSpan" id="kobo.2012.2">Therefore, in order to route all service traffic to your local machine, you need to override the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2013.1">EndpointSlices</span></code><span class="koboSpan" id="kobo.2014.1"> of that service. </span><span class="koboSpan" id="kobo.2014.2">This can be done by removing the selector of the target service so that all </span><code class="inlineCode"><span class="koboSpan" id="kobo.2015.1">EndpointSlices</span></code><span class="koboSpan" id="kobo.2016.1"> will be deleted, and then manually adding an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2017.1">EndpointSlice</span></code><span class="koboSpan" id="kobo.2018.1"> that points to your development machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2019.1">You can do this as follows:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2020.1">Get the target service definition with:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.2021.1">kubectl get service &lt;service name&gt; -n &lt;service namespace&gt; -o yaml
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2022.1">Remove the selector, and apply the new definition.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2023.1">If you are working on a remote cluster, add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2024.1">EndpointSlice</span></code><span class="koboSpan" id="kobo.2025.1"> below:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2026.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2027.1">discovery.k8s.io/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2028.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2029.1">EndpointSlice</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2030.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2031.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2032.1">&lt;service</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2033.1">name&gt;-1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2034.1">namespaces:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2035.1">&lt;service</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2036.1">namespace&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2037.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2038.1">kubernetes.io/service-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2039.1">&lt;service</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2040.1">name&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2041.1">addressType:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2042.1">IPv4</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2043.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2044.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2045.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2046.1">http</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.2047.1"># should match with the name of the service port</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2048.1">appProtocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2049.1">http</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2050.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2051.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2052.1">port:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2053.1">&lt;target</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2054.1">port&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2055.1">endpoints:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2056.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2057.1">addresses:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2058.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2059.1">"&lt;your development machine IP address&gt;"</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2060.1">If, instead, you are working on a Minikube local cluster, add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2061.1">EndpointSlice</span></code><span class="koboSpan" id="kobo.2062.1"> below:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2063.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2064.1">discovery.k8s.io/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2065.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2066.1">EndpointSlice</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2067.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2068.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2069.1">&lt;service</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2070.1">name&gt;-1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2071.1">namespaces:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2072.1">&lt;service</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2073.1">namespace&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2074.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2075.1">kubernetes.io/service-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2076.1">&lt;service</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2077.1">name&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2078.1">addressType:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2079.1">FQDN</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2080.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2081.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2082.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2083.1">http</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.2084.1"># should match with the name of the service port</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2085.1">appProtocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2086.1">http</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2087.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2088.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2089.1">port:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2090.1">&lt;target</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2091.1">port&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2092.1">endpoints:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2093.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2094.1">addresses:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2095.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2096.1">"host.minikube.local"</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2097.1">When you finish debugging, reapply the original service definition. </span><span class="koboSpan" id="kobo.2097.2">Your custom </span><code class="inlineCode"><span class="koboSpan" id="kobo.2098.1">EndpointSlice</span></code><span class="koboSpan" id="kobo.2099.1"> will be automatically destroyed.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2100.1">As you can see, using message brokers simplifies a lot of the debugging. </span><span class="koboSpan" id="kobo.2100.2">It is the advised option when implementing applications. </span><span class="koboSpan" id="kobo.2100.3">Services are a better option when implementing tools, such as database </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.2101.1">clusters, or message brokers that run inside your cluster.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2102.1">There are </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.2103.1">tools that automatically handle all needed service hacking, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.2104.1">Bridge to Kubernetes</span></strong><span class="koboSpan" id="kobo.2105.1"> (</span><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/bridge-to-kubernetes-vs"><span class="url"><span class="koboSpan" id="kobo.2106.1">https://learn.microsoft.com/en-us/visualstudio/bridge/bridge-to-kubernetes-vs</span></span></a><span class="koboSpan" id="kobo.2107.1">), but unluckily, Microsoft announced that it will stop supporting it. </span><span class="koboSpan" id="kobo.2107.2">Microsoft will advise a valid alternative.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2108.1">Now we are</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.2109.1"> finally ready to test an actual Microservice on Minikube.</span></p>
<h2 class="heading-2" id="_idParaDest-169"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.2110.1">Testing the route-matching worker microservice</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2111.1">We will </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.2112.1">test the route-matching worker microservice implemented in </span><a href="Chapter_7.xhtml#_idTextAnchor151"><em class="italic"><span class="koboSpan" id="kobo.2113.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.2114.1">, Microservices in Practice</span></em><span class="koboSpan" id="kobo.2115.1">, together with two stub microservices. </span><span class="koboSpan" id="kobo.2115.2">The first one will send test input to it, while </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.2116.1">the other will collect all its output and will write it in its console, so that we may access this output with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2117.1">kubectl logs</span></code><span class="koboSpan" id="kobo.2118.1"> command. </span><span class="koboSpan" id="kobo.2118.2">This is a typical way to perform a preliminary test. </span><span class="koboSpan" id="kobo.2118.3">Then, more complex tests may also involve other application services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2119.1">Let’s create a copy of our route-matching worker microservice solution, then add two more </span><strong class="keyWord"><span class="koboSpan" id="kobo.2120.1">Worker service</span></strong><span class="koboSpan" id="kobo.2121.1"> projects, and call them respectively </span><code class="inlineCode"><span class="koboSpan" id="kobo.2122.1">FakeSource </span></code><span class="koboSpan" id="kobo.2123.1">and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2124.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2125.1">. </span><span class="koboSpan" id="kobo.2125.2">For each of them, enable container support for Linux as shown in the following screenshot:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2126.1"><img alt="Figure 8.8: Worker services project settings" src="../Images/B31916_08_8.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2127.1">Figure 8.8: Worker services project settings</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2128.1">Then, let’s </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.2129.1">also add all needed EasyNetQ packages to enable both services to interact with a RabbitMQ cluster:</span></p>
<ol>
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.2130.1">EasyNetQ</span></code></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2131.1">EasyNetQ.Serialization.NewtonsoftJson</span></code></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2132.1">EasyNetQ.Serialization.SystemTextJson</span></code></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2133.1">Select </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.2134.1">at least version 8, also if it is still a prerelease.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2135.1">Then you must add RabbitMQ to the services in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2136.1">Program.cs</span></code><span class="koboSpan" id="kobo.2137.1"> of both projects:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2138.1">builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.2139.1">Services</span></span><span class="koboSpan" id="kobo.2140.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2141.1">AddEasyNetQ</span></span><span class="koboSpan" id="kobo.2142.1">(
    builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.2143.1">Configuration</span></span><span class="koboSpan" id="kobo.2144.1">?.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2145.1">GetConnectionString</span></span><span class="koboSpan" id="kobo.2146.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2147.1">"RabbitMQConnection"</span></span><span class="koboSpan" id="kobo.2148.1">) ?? 
        </span><span class="koboSpan" id="kobo.2148.2">string.</span><span class="hljs-property"><span class="koboSpan" id="kobo.2149.1">Empty</span></span><span class="koboSpan" id="kobo.2150.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2151.1">The RabbitMQ connection string must be added in the environment variables defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2152.1">Properties-&gt;launchSettings.json</span></code><span class="koboSpan" id="kobo.2153.1">, as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2154.1">"Container (Dockerfile)"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.2155.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.2156.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2157.1">"commandName"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.2158.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2159.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2160.1">Docker"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.2161.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2162.1">"environmentVariables"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.2163.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.2164.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2165.1">"ConnectionStrings__RabbitMQConnection"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.2166.1">:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2167.1">        "host=host.docker.internal:5672;username=guest;password=_myguest;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2168.1">        publisherConfirms=true;timeout=10"</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.2169.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2170.1">Finally, refer to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2171.1">SharedMessages</span></code><span class="koboSpan" id="kobo.2172.1"> project from both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2173.1">FakeSource </span></code><span class="koboSpan" id="kobo.2174.1">and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2175.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2176.1">, so they </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.2177.1">can use all application communication messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2178.1">At this </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.2179.1">point, we are ready to code our stub services. </span><span class="koboSpan" id="kobo.2179.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2180.1">Worker.cs</span></code><span class="koboSpan" id="kobo.2181.1"> file scaffolded by Visual Studio in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2182.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2183.1"> project, replace the existing class with:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2184.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2185.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2186.1">Worker</span></span><span class="koboSpan" id="kobo.2187.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.2188.1">BackgroundService</span></span><span class="koboSpan" id="kobo.2189.1">
{
    private readonly </span><span class="hljs-title"><span class="koboSpan" id="kobo.2190.1">ILogger</span></span><span class="koboSpan" id="kobo.2191.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.2192.1">Worker</span></span><span class="koboSpan" id="kobo.2193.1">&gt; _logger;
    private readonly </span><span class="hljs-title"><span class="koboSpan" id="kobo.2194.1">IBus</span></span><span class="koboSpan" id="kobo.2195.1"> _bus;
    public </span><span class="hljs-title"><span class="koboSpan" id="kobo.2196.1">Worker</span></span><span class="koboSpan" id="kobo.2197.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.2198.1">ILogger</span></span><span class="koboSpan" id="kobo.2199.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.2200.1">Worker</span></span><span class="koboSpan" id="kobo.2201.1">&gt; logger, </span><span class="hljs-title"><span class="koboSpan" id="kobo.2202.1">IBus</span></span><span class="koboSpan" id="kobo.2203.1"> bus)
    {
        _logger = logger;
        _bus= bus;
    }
    protected override </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2204.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2205.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2206.1">ExecuteAsync</span></span><span class="koboSpan" id="kobo.2207.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.2208.1">CancellationToken</span></span><span class="koboSpan" id="kobo.2209.1"> 
        stoppingToken)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2210.1">var</span></span><span class="koboSpan" id="kobo.2211.1"> routeExtensionProposalSubscription = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2212.1">await</span></span><span class="koboSpan" id="kobo.2213.1"> _bus.</span><span class="hljs-property"><span class="koboSpan" id="kobo.2214.1">PubSub</span></span><span class="koboSpan" id="kobo.2215.1">.
        </span><span class="hljs-property"><span class="koboSpan" id="kobo.2216.1">SubscribeAsync</span></span><span class="koboSpan" id="kobo.2217.1">&lt;
</span><span class="hljs-title"><span class="koboSpan" id="kobo.2218.1">            RouteExtensionProposalsMessage</span></span><span class="koboSpan" id="kobo.2219.1">&gt;(
               </span><span class="hljs-string"><span class="koboSpan" id="kobo.2220.1">"FakeDestination"</span></span><span class="koboSpan" id="kobo.2221.1">,
                </span><span class="hljs-params"><span class="koboSpan" id="kobo.2222.1">m</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2223.1"> =&gt;</span></span><span class="koboSpan" id="kobo.2224.1">
                {
                    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2225.1">var</span></span><span class="koboSpan" id="kobo.2226.1"> toPrint=</span><span class="hljs-title"><span class="koboSpan" id="kobo.2227.1">JsonSerializer</span></span><span class="koboSpan" id="kobo.2228.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2229.1">Serialize</span></span><span class="koboSpan" id="kobo.2230.1">(m);
                    _logger.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2231.1">LogInformation</span></span><span class="koboSpan" id="kobo.2232.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2233.1">"Message received: {0}"</span></span><span class="koboSpan" id="kobo.2234.1">, 
                                            toPrint);
                },
            stoppingToken);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2235.1">await</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2236.1">Task</span></span><span class="koboSpan" id="kobo.2237.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2238.1">Delay</span></span><span class="koboSpan" id="kobo.2239.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.2240.1">Timeout</span></span><span class="koboSpan" id="kobo.2241.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.2242.1">Infinite</span></span><span class="koboSpan" id="kobo.2243.1">, stoppingToken);
        routeExtensionProposalSubscription.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2244.1">Dispose</span></span><span class="koboSpan" id="kobo.2245.1">();
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2246.1">The hosted service adds a subscription named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2247.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2248.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2249.1">RouteExtensionProposalsMessage</span></code><span class="koboSpan" id="kobo.2250.1"> event. </span><span class="koboSpan" id="kobo.2250.2">This way, it receives all matching proposals between an existing route and some requests. </span><span class="koboSpan" id="kobo.2250.3">Once the subscription handler receives a proposal, it just logs the message in JSON format, so we can verify that the right match proposal events are generated by exploring the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2251.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2252.1"> logs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2253.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2254.1">Worker.cs</span></code><span class="koboSpan" id="kobo.2255.1"> file scaffolded by Visual Studio in the FakeSource project, we will replace the existing class with simple code that does the following:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2256.1">Creates </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.2257.1">three town messages: Phoenix, Santa Fe,</span><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.2258.1"> and Cheyenne.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2259.1">Sends a request going from Phoenix to Santa Fe.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2260.1">Sends </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.2261.1">a route offer passing from Phoenix, Santa Fe, and Cheyenne. </span><span class="koboSpan" id="kobo.2261.2">As soon as this message is received by the route planning wo</span><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.2262.1">rker microservice, it should create a proposal to match this offer with the previous request. </span><span class="koboSpan" id="kobo.2262.2">This proposal should be received by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2263.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2264.1"> and logged.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2265.1">Sends a request going from Santa Fe to Cheyenne. </span><span class="koboSpan" id="kobo.2265.2">As soon as this message is received by the routes planning worker microservice, it should create a proposal to match this request with the previous offer. </span><span class="koboSpan" id="kobo.2265.3">This proposal should be received by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2266.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2267.1"> and logged.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2268.1">After 10 seconds, it simulates that both previous proposals have been accepted and creates a route extension event based on the previous offer and containing both the matched requests. </span><span class="koboSpan" id="kobo.2268.2">As soon as this message is received by the route planning worker microservice, it should both update the offer and should add the two requests to the offer. </span><span class="koboSpan" id="kobo.2268.3">As a result, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2269.1">RouteId</span></code><span class="koboSpan" id="kobo.2270.1"> field of both requests should point to the offer </span><code class="inlineCode"><span class="koboSpan" id="kobo.2271.1">Id</span></code><span class="koboSpan" id="kobo.2272.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2273.1">The code of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2274.1">Worker.cs</span></code><span class="koboSpan" id="kobo.2275.1"> class is:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2276.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2277.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2278.1">Worker</span></span><span class="koboSpan" id="kobo.2279.1"> : BackgroundService
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2280.1">private</span></span><span class="koboSpan" id="kobo.2281.1"> readonly ILogger&lt;Worker&gt; _logger;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2282.1">private</span></span><span class="koboSpan" id="kobo.2283.1"> readonly IBus _bus;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2284.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2285.1">Worker</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2286.1">(ILogger&lt;Worker&gt; logger, IBus bus)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2287.1">{
        _logger = logger;
        _bus = bus;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2288.1">protected</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2289.1">override</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2290.1"> async Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2291.1">ExecuteAsync</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2292.1">(CancellationToken </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.2293.1">        stoppingToken)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2294.1">{
        …
        …
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2295.1">/* The code that defines all messages has been omitted */</span></span><span class="koboSpan" id="kobo.2296.1">
        var delayInterval = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2297.1">5000</span></span><span class="koboSpan" id="kobo.2298.1">;
        await Task.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2299.1">Delay</span></span><span class="koboSpan" id="kobo.2300.1">(delayInterval, stoppingToken);
        await _bus.PubSub.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2301.1">PublishAsync</span></span><span class="koboSpan" id="kobo.2302.1">&lt;RouteRequestMessage&gt;(request1);
        await Task.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2303.1">Delay</span></span><span class="koboSpan" id="kobo.2304.1">(delayInterval, stoppingToken);
        await _bus.PubSub.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2305.1">PublishAsync</span></span><span class="koboSpan" id="kobo.2306.1">&lt;RouteOfferMessage&gt;(offerMessage);
        await Task.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2307.1">Delay</span></span><span class="koboSpan" id="kobo.2308.1">(delayInterval, stoppingToken);
        await _bus.PubSub.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2309.1">PublishAsync</span></span><span class="koboSpan" id="kobo.2310.1">&lt;RouteRequestMessage&gt;(request2);
        await Task.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2311.1">Delay</span></span><span class="koboSpan" id="kobo.2312.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2313.1">2</span></span><span class="koboSpan" id="kobo.2314.1">*delayInterval, stoppingToken);
        await _bus.PubSub.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2315.1">PublishAsync</span></span><span class="koboSpan" id="kobo.2316.1">&lt;
RouteExtendedMessage&gt;(extendedMessage);
        await Task.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2317.1">Delay</span></span><span class="koboSpan" id="kobo.2318.1">(Timeout.Infinite, stoppingToken);
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2319.1">The code </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.2320.1">that defines all messages has been omitted. </span><span class="koboSpan" id="kobo.2320.2">You can find the full code in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2321.1">ch08-&gt;CarSharing-&gt;FakeSource-&gt;Worker.cs</span></code><span class="koboSpan" id="kobo.2322.1"> file of the GitHub repository associated with the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2323.1">Now let’s </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.2324.1">prepare to execute all microservices in Docker by performing the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2325.1">Right-click on the solution line in Visual Studio Solution Explorer and select </span><strong class="screenText"><span class="koboSpan" id="kobo.2326.1">Configure Startup Projects…</span></strong><span class="koboSpan" id="kobo.2327.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2328.1">Then select </span><strong class="screenText"><span class="koboSpan" id="kobo.2329.1">Multiple startup projects</span></strong><span class="koboSpan" id="kobo.2330.1">, and change the name of the launch option to </span><strong class="screenText"><span class="koboSpan" id="kobo.2331.1">AllMicroservices</span></strong><span class="koboSpan" id="kobo.2332.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2333.1">Then, select all three </span><code class="inlineCode"><span class="koboSpan" id="kobo.2334.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2335.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2336.1">FakeSource</span></code><span class="koboSpan" id="kobo.2337.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2338.1">RoutesPlanning</span></code><span class="koboSpan" id="kobo.2339.1"> projects, and for each of them, choose </span><strong class="screenText"><span class="koboSpan" id="kobo.2340.1">Start</span></strong><span class="koboSpan" id="kobo.2341.1"> for </span><strong class="screenText"><span class="koboSpan" id="kobo.2342.1">Action</span></strong><span class="koboSpan" id="kobo.2343.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.2344.1">Container (Docker file)</span></strong><span class="koboSpan" id="kobo.2345.1"> for </span><strong class="screenText"><span class="koboSpan" id="kobo.2346.1">Debug Target</span></strong><span class="koboSpan" id="kobo.2347.1">, as shown below:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2348.1"><img alt="Figure 8.9: Launch settings" src="../Images/B31916_08_9.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2349.1">Figure 8.9: Launch settings</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2350.1">Now you </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.2351.1">can launch all projects simultaneously by choosing </span><strong class="screenText"><span class="koboSpan" id="kobo.2352.1">AllMicroservices</span></strong><span class="koboSpan" id="kobo.2353.1"> in Visual Studio Debug Launcher.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2354.1">Ensure </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.2355.1">that both the application’s SQL Server and the RabbitMQ server are running. </span><span class="koboSpan" id="kobo.2355.2">Then, build the project and launch it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2356.1">In the Containers tab that appears, select </span><code class="inlineCode"><span class="koboSpan" id="kobo.2357.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2358.1">, so you can inspect its logs. </span><span class="koboSpan" id="kobo.2358.2">After a few seconds, you should see the two match proposal messages, as shown below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2359.1"><img alt="Figure 8.10: FakeDestination logs" src="../Images/B31916_08_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2360.1">Figure 8.10: FakeDestination logs</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2361.1">Then, in the SQL Server Object Explorer pane, select the application database, if already there; otherwise, connect to it, and then show its tables:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2362.1"><img alt="Figure 8.11: Application database" src="../Images/B31916_08_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2363.1">Figure 8.11: Application database</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2364.1">Right-click </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.2365.1">on both </span><strong class="screenText"><span class="koboSpan" id="kobo.2366.1">dbo.RouteOffers</span></strong><span class="koboSpan" id="kobo.2367.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.2368.1">dbo.RouteRequests</span></strong><span class="koboSpan" id="kobo.2369.1"> and select </span><strong class="screenText"><span class="koboSpan" id="kobo.2370.1">View Data</span></strong><span class="koboSpan" id="kobo.2371.1"> to see all their data. </span><span class="koboSpan" id="kobo.2371.2">You should see that the offer’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.2372.1">Timestamp</span></code><span class="koboSpan" id="kobo.2373.1"> changed to 2 because the offer </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.2374.1">was updated once the two matching proposals were accepted:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2375.1"><img alt="Figure 8.12: Updated offer" src="../Images/B31916_08_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2376.1">Figure 8.12: Updated offer</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2377.1">Moreover, you should see that the two requests have been associated with the offer:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2378.1"><img alt="Figure 8.13: Updated requests" src="../Images/B31916_08_13.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2379.1">Figure 8.13: Updated requests</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2380.1">Now let’s stop debugging and delete all records in the </span><strong class="screenText"><span class="koboSpan" id="kobo.2381.1">dbo.RouteOffers</span></strong><span class="koboSpan" id="kobo.2382.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.2383.1">dbo.RouteRequests</span></strong><span class="koboSpan" id="kobo.2384.1"> tables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2385.1">It’s time to deploy our Microservices in Minikube!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2386.1">We will use the same RabbitMQ and SQL Servers running on the development machine. </span><span class="koboSpan" id="kobo.2386.2">However, there are some preliminary steps to perform before we start deploying our </span><code class="inlineCode"><span class="koboSpan" id="kobo.2387.1">.yaml</span></code><span class="koboSpan" id="kobo.2388.1"> files in Minikube:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2389.1">We must create adequate Docker images, since the debug images created by Visual Studio can’t run outside of Visual Studio. </span><span class="koboSpan" id="kobo.2389.2">They all have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2390.1">dev</span></code><span class="koboSpan" id="kobo.2391.1"> version. </span><span class="koboSpan" id="kobo.2391.2">Go to the Docker files of the three </span><code class="inlineCode"><span class="koboSpan" id="kobo.2392.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2393.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2394.1">FakeSource</span></code><span class="koboSpan" id="kobo.2395.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2396.1">RoutesPlanning</span></code><span class="koboSpan" id="kobo.2397.1"> projects in Visual Studio Explorer, right-click on them, and select </span><strong class="screenText"><span class="koboSpan" id="kobo.2398.1">Build Docker Image</span></strong><span class="koboSpan" id="kobo.2399.1">. </span><span class="koboSpan" id="kobo.2399.2">These actions will create three Docker images with the latest version.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2400.1">Launch the local registry container from inside the Docker UI. </span><span class="koboSpan" id="kobo.2400.2">If you have not yet created a registry container, please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.2401.1">Container registries</span></em><span class="koboSpan" id="kobo.2402.1"> subsection for installation instructions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2403.1">Push our </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.2404.1">newly created images in this registry so they can be downloaded </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.2405.1">by Minikube (remember that you need a Linux console to issue the commands below):
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.2406.1">docker tag fakesource:latest localhost:5000/fakesource:latest
docker push localhost:5000/fakesource:latest
docker tag fakedestination:latest localhost:5000/fakedestination:latest
docker push localhost:5000/fakedestination:latest
docker tag routesplanning:latest localhost:5000/routesplanning:latest
docker push localhost:5000/routesplanning:latest
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2407.1">We need to create 3 deployments, one for each of our three microservices. </span><span class="koboSpan" id="kobo.2407.2">Let’s create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2408.1">Kubernetes</span></code><span class="koboSpan" id="kobo.2409.1"> folder in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2410.1">CarSharing</span></code><span class="koboSpan" id="kobo.2411.1"> solution folder. </span><span class="koboSpan" id="kobo.2411.2">We will place our deployment definitions there.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2412.1">Below </span><code class="inlineCode"><span class="koboSpan" id="kobo.2413.1">FakeSource.yaml</span></code><span class="koboSpan" id="kobo.2414.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2415.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2416.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2417.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2418.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2419.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2420.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2421.1">fakesource</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2422.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2423.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2424.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2425.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2426.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2427.1">classification:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2428.1">stub</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2429.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2430.1">fake-source</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2431.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2432.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2433.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2434.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2435.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2436.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2437.1">fake-source</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2438.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2439.1">1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2440.1">template:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2441.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2442.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2443.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2444.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2445.1">classification:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2446.1">stub</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2447.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2448.1">fake-source</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2449.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2450.1">containers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2451.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2452.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2453.1">host.docker.internal:5000/fakesource:latest</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2454.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2455.1">fakesource</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2456.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2457.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2458.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2459.1">10m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2460.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2461.1">10Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2462.1">env:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2463.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2464.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2465.1">ConnectionStrings__RabbitMQConnection</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2466.1">value:</span></span>
<span class="hljs-attr"> </span> <span class="hljs-string"><span class="koboSpan" id="kobo.2467.1">"host=host.docker.internal:5672;username=guest;password=_myguest;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2468.1">              publisherConfirms=true;timeout=10"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2469.1">It contains </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.2470.1">just a single environment variable for the RabbitMQ connection string – the same one we defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2471.1">launchSettings.json</span></code><span class="koboSpan" id="kobo.2472.1">. </span><span class="koboSpan" id="kobo.2472.2">The resource request is minimal. </span><span class="koboSpan" id="kobo.2472.3">Labels are a </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.2473.1">documentation tool, too. </span><span class="koboSpan" id="kobo.2473.2">Therefore, they define both the application name, the role in the application, and the fact that this microservice is a stub.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2474.1">We designed the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2475.1">car-sharing</span></code><span class="koboSpan" id="kobo.2476.1"> namespace to host the whole application.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2477.1">host.docker.internal:5000</span></code><span class="koboSpan" id="kobo.2478.1"> is the hostname of our local registry as seen from inside Minikube.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2479.1">Our deployments don’t need services since they communicate through RabbitMQ.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2480.1">FakeDestination.yaml</span></code><span class="koboSpan" id="kobo.2481.1"> is completely analogous:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2482.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2483.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2484.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2485.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2486.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2487.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2488.1">fakedestination</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2489.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2490.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2491.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2492.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2493.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2494.1">classification:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2495.1">stub</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2496.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2497.1">fake-destination</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2498.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2499.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2500.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2501.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2502.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2503.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2504.1">fake-destination</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2505.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2506.1">1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2507.1">template:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2508.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2509.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2510.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2511.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2512.1">classification:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2513.1">stub</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2514.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2515.1">fake-destination</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2516.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2517.1">containers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2518.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2519.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2520.1">host.docker.internal:5000/fakedestination:latest</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2521.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2522.1">fakedestination</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2523.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2524.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2525.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2526.1">10m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2527.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2528.1">10Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2529.1">env:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2530.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2531.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2532.1">ConnectionStrings__RabbitMQConnection</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2533.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2534.1">"host=host.docker.internal:5672;username=guest;password=_myguest;publisherConfirms=true;timeout=10"</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2535.1">RoutesPlanning.yaml</span></code><span class="koboSpan" id="kobo.2536.1"> differs from the other just because it contains a lot more environment variables </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.2537.1">and because it exposes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2538.1">8080</span></code><span class="koboSpan" id="kobo.2539.1"> port, which we might exploit to check the service’s health </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.2540.1">state (see the </span><em class="italic"><span class="koboSpan" id="kobo.2541.1">Readiness, liveness, and startup probes</span></em><span class="koboSpan" id="kobo.2542.1"> subsection in the next section).</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2543.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2544.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2545.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2546.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2547.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2548.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2549.1">routesplanning</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2550.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2551.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2552.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2553.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2554.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2555.1">classification:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2556.1">worker</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2557.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2558.1">routes-planning</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2559.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2560.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2561.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2562.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2563.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2564.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2565.1">routes-planning</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2566.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2567.1">1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2568.1">template:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2569.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2570.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2571.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2572.1">car-sharing</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2573.1">classification:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2574.1">worker</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2575.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2576.1">routes-planning</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2577.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2578.1">containers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2579.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2580.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2581.1">host.docker.internal:5000/routesplanning:latest</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2582.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2583.1">routesplanning</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2584.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2585.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2586.1">containerPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2587.1">8080</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2588.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2589.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2590.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2591.1">10m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2592.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2593.1">10Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2594.1">env:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2595.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2596.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2597.1">ASPNETCORE_HTTP_PORTS</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2598.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2599.1">"8080"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2600.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2601.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2602.1">ConnectionStrings__DefaultConnection</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2603.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2604.1">"Server=host.docker.internal;Database=RoutesPlanning;User </span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2605.1">                  Id=sa;Password=Passw0rd_;Trust Server </span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2606.1">                  Certificate=True;MultipleActiveResultSets=true"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2607.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2608.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2609.1">ConnectionStrings__RabbitMQConnection</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2610.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2611.1">"host=host.docker.internal:5672;username=guest;password=_</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2612.1">                  myguest;publisherConfirms=true;timeout=10"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2613.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2614.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2615.1">Messages__SubscriptionIdPrefix</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2616.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2617.1">"routesPlanning"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2618.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2619.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2620.1">Topology__MaxDistanceKm</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2621.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2622.1">"50"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2623.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2624.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2625.1">Topology__MaxMatches</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2626.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2627.1">"5"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2628.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2629.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2630.1">Timing__HousekeepingIntervalHours</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2631.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2632.1">"48"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2633.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2634.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2635.1">Timing__HousekeepingDelayDays</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2636.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2637.1">"10"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2638.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2639.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2640.1">Timing__OutputEmptyDelayMS</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2641.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2642.1">"500"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2643.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2644.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2645.1">Timing__OutputBatchCount</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2646.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2647.1">"10"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2648.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2649.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2650.1">Timing__OutputRequeueDelayMin</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2651.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2652.1">"5"</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2653.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2654.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2655.1">Timing__OutputCircuitBreakMin</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2656.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2657.1">"4"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2658.1">Let’s open </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.2659.1">a Windows console on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2660.1">Kubernetes</span></code><span class="koboSpan" id="kobo.2661.1"> folder, and start deploying our application:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2662.1">Let’s start Minikube with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2663.1">minikube start</span></code><span class="koboSpan" id="kobo.2664.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2665.1">Let’s create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2666.1">car-sharing</span></code><span class="koboSpan" id="kobo.2667.1"> namespace with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2668.1">kubectl create namespace car-sharing</span></code><span class="koboSpan" id="kobo.2669.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2670.1">Let’s deploy </span><code class="inlineCode"><span class="koboSpan" id="kobo.2671.1">FakeDestination.yaml</span></code><span class="koboSpan" id="kobo.2672.1"> first: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2673.1">kubectl apply -f FakeDestination.yaml</span></code><span class="koboSpan" id="kobo.2674.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2675.1">Now let’s </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.2676.1">verify all Pods are okay and ready with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2677.1">kubectl get all -n car-sharing</span></code><span class="koboSpan" id="kobo.2678.1">. </span><span class="koboSpan" id="kobo.2678.2">If they’re not ready, please repeat the command until they are ready.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2679.1">Let’s copy the name of the created Pod. </span><span class="koboSpan" id="kobo.2679.2">We need it to access its logs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2680.1">Then, let’s deploy </span><code class="inlineCode"><span class="koboSpan" id="kobo.2681.1">RoutesPlanning.yaml</span></code><span class="koboSpan" id="kobo.2682.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2683.1">kubectl apply -f RoutesPlanning.yaml</span></code><span class="koboSpan" id="kobo.2684.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2685.1">Again, let’s verify all Pods are okay and ready with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2686.1">kubectl get all -n car-sharing</span></code><span class="koboSpan" id="kobo.2687.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2688.1">Then, let’s deploy </span><code class="inlineCode"><span class="koboSpan" id="kobo.2689.1">FakeSource.yaml</span></code><span class="koboSpan" id="kobo.2690.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2691.1">kubectl apply -f FakeSource.yaml</span></code><span class="koboSpan" id="kobo.2692.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2693.1">Again, let’s verify all Pods are okay and ready with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2694.1">kubectl get all -n car-sharing</span></code><span class="koboSpan" id="kobo.2695.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2696.1">Now let’s check the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2697.1">FakeDestination</span></code><span class="koboSpan" id="kobo.2698.1"> logs to verify it received the match proposals with: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2699.1">kubectl logs &lt;FakeDestination POD name&gt; -n car-sharing</span></code><span class="koboSpan" id="kobo.2700.1">. </span><span class="koboSpan" id="kobo.2700.2">Where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2701.1">&lt;FakeDestination POD name&gt;</span></code><span class="koboSpan" id="kobo.2702.1"> is the name that we got in </span><em class="italic"><span class="koboSpan" id="kobo.2703.1">step5.</span></em></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2704.1">Also check the database table to verify that the applications work properly.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2705.1">When you’ve finished experimenting, delete everything by simply deleting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2706.1">car-sharing</span></code><span class="koboSpan" id="kobo.2707.1"> namespace: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2708.1">kubectl delete namespace car-sharing</span></code><span class="koboSpan" id="kobo.2709.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2710.1">Also delete the records in the </span><strong class="screenText"><span class="koboSpan" id="kobo.2711.1">dbo.RouteOffers</span></strong><span class="koboSpan" id="kobo.2712.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.2713.1">dbo.RouteRequests</span></strong><span class="koboSpan" id="kobo.2714.1"> database tables.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2715.1">Stop Minikube with: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2716.1">minikube stop</span></code><span class="koboSpan" id="kobo.2717.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2718.1">Now, if you would like to experiment with debugging with the bridge technique, repeat the above steps, but replace points 6 and 7, which deploy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2719.1">RoutePlanning</span></code><span class="koboSpan" id="kobo.2720.1"> microservice with the launch of the single </span><code class="inlineCode"><span class="koboSpan" id="kobo.2721.1">RoutePlanning</span></code><span class="koboSpan" id="kobo.2722.1"> project inside of Visual Studio (just replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.2723.1">AllMicroservices</span></code><span class="koboSpan" id="kobo.2724.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2725.1">RoutePlanning</span></code><span class="koboSpan" id="kobo.2726.1"> in the Visual Studio debug widget, and then start the debugger).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2727.1">Since all </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.2728.1">containers are attached to the same RabbitMQ server, the container running in Visual </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.2729.1">Studio will receive all input messages created from within Minikube, and all its output messages will be routed inside of Minikube. </span><span class="koboSpan" id="kobo.2729.2">Let’s place a breakpoint wherever you would like to analyze the cod</span><a id="_idTextAnchor248"/><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.2730.1">e before continuing the Kubernetes deployment. </span><span class="koboSpan" id="kobo.2730.2">A few seconds after the deployment of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2731.1">FakeSource.yaml</span></code><span class="koboSpan" id="kobo.2732.1"> file, the breakpoint should be hit!</span></p>
<h1 class="heading-1" id="_idParaDest-170"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.2733.1">Advanced Kubernetes configuration</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2734.1">This section </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.2735.1">describes advanced Kubernetes resources that play a fundamental role in application design. </span><span class="koboSpan" id="kobo.2735.2">Other advanced resources and configurations related specifically to security and observability will be described in </span><a href="Chapter_10.xhtml#_idTextAnchor297"><em class="italic"><span class="koboSpan" id="kobo.2736.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.2737.1">, Security and Observability for Serverless and Microservices Applications</span></em><span class="koboSpan" id="kobo.2738.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2739.1">Let’s start with secrets.</span></p>
<h2 class="heading-2" id="_idParaDest-171"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.2740.1">Secrets</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2741.1">Kubernetes allows various kinds of Secrets. </span><span class="koboSpan" id="kobo.2741.2">Here, we will describe just </span><code class="inlineCode"><span class="koboSpan" id="kobo.2742.1">generic</span></code><span class="koboSpan" id="kobo.2743.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2744.1">tls</span></code><span class="koboSpan" id="kobo.2745.1"> secrets, which are </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.2746.1">the ones used in the practical development of applications based on microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2747.1">Each generic </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.2748.1">Secret contains a collection of entry-name/entry-value pairs. </span><span class="koboSpan" id="kobo.2748.2">Secrets can be defined with .</span><code class="inlineCode"><span class="koboSpan" id="kobo.2749.1">yaml</span></code><span class="koboSpan" id="kobo.2750.1"> files, but since it is not prudent to mix sensitive information with code, they are usually defined with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2751.1">kubectl</span></code><span class="koboSpan" id="kobo.2752.1"> commands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2753.1">Below is how to define a Secret, taking the entry values from file contents:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2754.1">kubectl create secret generic credentials --from-file=username.txt --from-file=password.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2755.1">The file names become entry names (just the file name with its extension – the path information is removed), while file contents become the associated entry values. </span><span class="koboSpan" id="kobo.2755.2">Each entry is defined with a different </span><code class="inlineCode"><span class="koboSpan" id="kobo.2756.1">--from-file=…</span></code><span class="koboSpan" id="kobo.2757.1"> option. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2758.1">Creates two files with the above names in a directory, put some content in them, then open a console on that directory, and finally try the above command. </span><span class="koboSpan" id="kobo.2758.2">Once created, you can see it in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2759.1">.yaml</span></code><span class="koboSpan" id="kobo.2760.1"> format with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2761.1">kubectl get secret credentials -o yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2762.1">In the data section, you will see the two entries, but the entry values appear encrypted. </span><span class="koboSpan" id="kobo.2762.2">Actually, they are not encrypted but just base64-encoded. </span><span class="koboSpan" id="kobo.2762.3">Needless to say, you can prevent some Kubernetes users from accessing Secret resources. </span><span class="koboSpan" id="kobo.2762.4">We will see how in </span><a href="Chapter_10.xhtml#_idTextAnchor297"><em class="italic"><span class="koboSpan" id="kobo.2763.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.2764.1">, Security and Observability for Serverless and Microservices Applications</span></em><span class="koboSpan" id="kobo.2765.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2766.1">A Secret can be deleted with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2767.1">kubectl delete secret credentials
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2768.1">Instead of </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.2769.1">using files, one can specify the entry values in line:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2770.1">kubectl create secret generic credentials --from-literal=username=devuser --from-literal=password='$dsd_weew1'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2771.1">As usual, we can </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.2772.1">specify the Secret namespace with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2773.1">-n</span></code><span class="koboSpan" id="kobo.2774.1"> option.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2775.1">Once defined, generic Secrets can be mounted as volumes on Pods:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2776.1">volumes:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2777.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2778.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2779.1">credentialsvolume</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2780.1">  secret:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2781.1">secretName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2782.1">credentials</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2783.1">Each entry is seen as a file whose name is the entry name and whose content is the entry value.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2784.1"> Do not forget that entry values are base64-encoded, so they must be decoded before usage.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2785.1">Secrets can also be passed as environment variables:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2786.1">env:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet"><span class="koboSpan" id="kobo.2787.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2788.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2789.1">USERNAME</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2790.1">valueFrom:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2791.1">secretKeyRef:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2792.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2793.1">credentials</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2794.1">key:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2795.1">username</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2796.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.2797.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2798.1">PASSWORD</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2799.1">valueFrom:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2800.1">secretKeyRef:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2801.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2802.1">credentials</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2803.1">key:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2804.1">password</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2805.1">In this case, Secret values are automatically base64-decoded before passing them as environment variables.</span></p>
<div class="packt_tip">
<p class="normal"> <code class="inlineCode"><span class="koboSpan" id="kobo.2806.1">Let’s try Secrets on the routes-matching worker microservices. </span><span class="koboSpan" id="kobo.2806.2">Let’s create a Kubernetes Secret that contains the RabbitMQ connection string and correct FakeDestination.yaml, FakeSource.yaml, and RoutesPlanning.yaml, to use this Secret.</span></code></p>
</div>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2807.1">tls</span></code><span class="koboSpan" id="kobo.2808.1"> Secrets are designed </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.2809.1">for storing web servers’ certificates. </span><span class="koboSpan" id="kobo.2809.2">We will see how to use them in the </span><em class="italic"><span class="koboSpan" id="kobo.2810.1">Ingresses</span></em><span class="koboSpan" id="kobo.2811.1"> subsection. </span><code class="inlineCode"><span class="koboSpan" id="kobo.2812.1">tls</span></code><span class="koboSpan" id="kobo.2813.1"> secrets take as input both </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.2814.1">the private key certificate (.key) and the public key approved certificate (.crt):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2815.1">kubectl create secret tls test-tls --key="tls.key" --cert="tls.crt"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2816.1">The next important topic concerns how our container code may help Kubernetes verify both whether each container is ready to interact with the remainder of the application and if it is in good health.</span></p>
<h2 class="heading-2" id="_idParaDest-172"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.2817.1">Readiness, liveness, and startup probes</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2818.1">Liveness probes inform Kubernetes when containers are in an unrecoverable faulty state, so Kubernetes </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.2819.1">must kill and restart them. </span><span class="koboSpan" id="kobo.2819.2">If a container has no liveness probe </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.2820.1">defined for it, Kubernetes restarts it just in case it crashes due to some unpredictable exception or because it exceeded its memory </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.2821.1">limits. </span><span class="koboSpan" id="kobo.2821.2">Liveness probes must be carefully designed to detect actual </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.2822.1">unrecoverable error situations; otherwise, the container might end up in an endless loop of restarts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2823.1">Temporary failures, instead, are connected to readiness probes. </span><span class="koboSpan" id="kobo.2823.2">When a readiness probe fails, it informs Kubernetes </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.2824.1">that the container is not able to receive traffic. </span><span class="koboSpan" id="kobo.2824.2">Accordingly, Kubernetes </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.2825.1">removes the failed container from all the lists of matching services that could send traffic to it. </span><span class="koboSpan" id="kobo.2825.2">This way, traffic is split only among the ready containers. </span><span class="koboSpan" id="kobo.2825.3">The faulty container is not restarted and is reinserted in the services list as soon as the readiness probe succeeds again.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2826.1">Finally, a startup probe informs Kubernetes that the container has completed its startup procedure. </span><span class="koboSpan" id="kobo.2826.2">Its only purpose is avoiding Kubernetes killing and restarting the container during startup because of liveness probe failures. </span><span class="koboSpan" id="kobo.2826.3">In fact, similar occurrences might move the container into an endless loop of restarts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2827.1">Put simply, Kubernetes starts liveness and readiness probes only after the startup probe succeeds. </span><span class="koboSpan" id="kobo.2827.2">Since both liveness and readiness probes already have initial delays, startup probes are necessary only in case of very long startup procedures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2828.1">All probes </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.2829.1">have a </span><strong class="keyWord"><span class="koboSpan" id="kobo.2830.1">probe operation</span></strong><span class="koboSpan" id="kobo.2831.1"> that may either fail or succeed, with the following parameters:</span></p>
<ol>
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.2832.1">failureThreshold</span></code><span class="koboSpan" id="kobo.2833.1">: The </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.2834.1">number of consecutive times the probe operation must fail to consider the probe as failed. </span><span class="koboSpan" id="kobo.2834.2">If not provided, it defaults to 3.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2835.1">successThreshold</span></code><span class="koboSpan" id="kobo.2836.1">: Used </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.2837.1">only for readiness probes. </span><span class="koboSpan" id="kobo.2837.2">This is the minimum number of consecutive successes for the probe to be considered successful after having failed. </span><span class="koboSpan" id="kobo.2837.3">It defaults to 1.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2838.1">initialDelaySeconds</span></code><span class="koboSpan" id="kobo.2839.1">: The time in seconds Kubernetes must wait after the container </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.2840.1">starts before trying the first probe. </span><span class="koboSpan" id="kobo.2840.2">The default value is 0.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2841.1">periodSeconds</span></code><span class="koboSpan" id="kobo.2842.1">: The time </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.2843.1">in seconds between two successive probes. </span><span class="koboSpan" id="kobo.2843.2">The default is 10 seconds.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2844.1">timeoutSeconds</span></code><span class="koboSpan" id="kobo.2845.1">: The number </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.2846.1">of seconds after which the probe times out. </span><span class="koboSpan" id="kobo.2846.2">The default is 1 second.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2847.1">Often, liveness </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.2848.1">and readiness probes are </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.2849.1">implemented with the same probe operation, but the liveness probe has a greater failure threshold.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2850.1">Probes are </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.2851.1">container-level properties, that is, they </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.2852.1">are on the same level as container ports, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2853.1">name</span></code><span class="koboSpan" id="kobo.2854.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2855.1">Probe </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.2856.1">operations may be based on shell commands, HTTP requests, or TCP/IP </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.2857.1">connection attempts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2858.1">Probes based on shell commands are defined as:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2859.1">livenessProbe/readinessProbe/startupProbe:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2860.1">exec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2861.1">command:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2862.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2863.1">cat</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.2864.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2865.1">/tmp/healthy</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2866.1">initialDelaySeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2867.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2868.1">periodSeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2869.1">5</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2870.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2871.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2872.1">command</span></code><span class="koboSpan" id="kobo.2873.1"> list contains the command and all its arguments. </span><span class="koboSpan" id="kobo.2873.2">The operation succeeds if it is completed with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2874.1">0</span></code><span class="koboSpan" id="kobo.2875.1"> status code, that is, if the command completes with no errors. </span><span class="koboSpan" id="kobo.2875.2">In the example above, the command succeeds if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2876.1">/tmp/healthy</span></code><span class="koboSpan" id="kobo.2877.1"> file exists.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2878.1">Probes based on TCP/IP connections are defined as:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2879.1">livenessProbe/readinessProbe/startupProbe:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2880.1">tcpSocket:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2881.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2882.1">8080</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2883.1">initialDelaySeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2884.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2885.1">periodSeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2886.1">5</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2887.1">The operation </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.2888.1">succeeds if a TCP/connection </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.2889.1">is successfully established.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2890.1">Finally, probes </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.2891.1">based on HTTP requests </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.2892.1">are defined as:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2893.1">livenessProbe/readinessProbe/startupProbe:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2894.1">httpGet:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2895.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2896.1">/healthz</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2897.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2898.1">8080</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2899.1">httpHeaders:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2900.1">-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2901.1">Custom-Health-Header</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2902.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2903.1">Kubernetes-probe</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2904.1">initialDelaySeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2905.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2906.1">periodSeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2907.1">5</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2908.1">path</span></code><span class="koboSpan" id="kobo.2909.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2910.1">port</span></code><span class="koboSpan" id="kobo.2911.1"> specify </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.2912.1">the endpoint </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.2913.1">path and port. </span><span class="koboSpan" id="kobo.2913.2">The optional </span><code class="inlineCode"><span class="koboSpan" id="kobo.2914.1">httpHeaders</span></code><span class="koboSpan" id="kobo.2915.1"> section lists all HTTP headers that Kubernetes must provide in its request. </span><span class="koboSpan" id="kobo.2915.2">The operation succeeds if the response returns a status code satisfying: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2916.1">200&lt;=status&lt;400</span></code><span class="koboSpan" id="kobo.2917.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2918.1">Let’s add a liveness probe to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2919.1">RoutesPlanning.yaml</span></code><span class="koboSpan" id="kobo.2920.1"> deployment of the </span><em class="italic"><span class="koboSpan" id="kobo.2921.1">Testing the route-matching worker microservice</span></em><span class="koboSpan" id="kobo.2922.1"> section. </span><span class="koboSpan" id="kobo.2922.2">We don’t need a readiness probe, since readiness probes only affect services, and we don’t use services since all communications are handled by RabbitMQ.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2923.1">First of all, let’s define the following API in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2924.1">Program.cs</span></code><span class="koboSpan" id="kobo.2925.1"> file of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2926.1">RoutesPlanning</span></code><span class="koboSpan" id="kobo.2927.1"> project:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2928.1">app.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2929.1">MapGet</span></span><span class="koboSpan" id="kobo.2930.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2931.1">"/liveness"</span></span><span class="koboSpan" id="kobo.2932.1">, </span><span class="hljs-function"><span class="koboSpan" id="kobo.2933.1">() =&gt;</span></span><span class="koboSpan" id="kobo.2934.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2935.1">if</span></span><span class="koboSpan" id="kobo.2936.1"> (</span><span class="hljs-title"><span class="koboSpan" id="kobo.2937.1">MainService</span></span><span class="koboSpan" id="kobo.2938.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.2939.1">ErrorsCount</span></span><span class="koboSpan" id="kobo.2940.1"> &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2941.1">6</span></span><span class="koboSpan" id="kobo.2942.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2943.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2944.1">Results</span></span><span class="koboSpan" id="kobo.2945.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2946.1">Ok</span></span><span class="koboSpan" id="kobo.2947.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2948.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2949.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2950.1">Results</span></span><span class="koboSpan" id="kobo.2951.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2952.1">InternalServerError</span></span><span class="koboSpan" id="kobo.2953.1">();
})
.</span><span class="hljs-title"><span class="koboSpan" id="kobo.2954.1">WithName</span></span><span class="koboSpan" id="kobo.2955.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2956.1">"GetLiveness"</span></span><span class="koboSpan" id="kobo.2957.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2958.1">The code </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.2959.1">returns an error status if there were at least 6 consecutive failed </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.2960.1">attempts to communicate with RabbitMQ.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2961.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2962.1">RoutesPlanning.yaml</span></code><span class="koboSpan" id="kobo.2963.1"> deployment, we must add the code below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.2964.1">livenessProbe:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2965.1">httpGet:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2966.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2967.1">/liveness</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2968.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2969.1">8080</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2970.1">initialDelaySeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2971.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2972.1">periodSeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2973.1">5</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2974.1">After </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.2975.1">this change, if you want, you can retry </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.2976.1">the whole Minikube test from the </span><em class="italic"><span class="koboSpan" id="kobo.2977.1">Testing the route-matching worker microservice</span></em><span class="koboSpan" id="kobo.2978.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2979.1">The next </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.2980.1">section describes a structured, modular, and efficient </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.2981.1">way to handle the interaction between our cluster and the external world.</span></p>
<h2 class="heading-2" id="_idParaDest-173"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.2982.1">Ingresses</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2983.1">Most microservices applications have several frontend microservices, so exposing them with LoadBalancer services </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.2984.1">would require a different IP address for each of them. </span><span class="koboSpan" id="kobo.2984.2">Moreover, inside of our Kubernetes cluster, we don’t need the burden of HTTPS and certificates for </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.2985.1">each microservice, so the best solution is a unique entry point for the whole cluster with a unique IP address that takes care of HTTPS communication with the external world while forwarding HTTP communication to the services inside of the cluster. </span><span class="koboSpan" id="kobo.2985.2">Both functionalities are typical of web servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2986.1">Typically, each IP address has several domain names attached, and a web server splits the traffic between several applications according to both the domain name and the request path inside each domain. </span><span class="koboSpan" id="kobo.2986.2">This web </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.2987.1">server functionality is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2988.1">virtual hosting</span></strong><span class="koboSpan" id="kobo.2989.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2990.1">The translation </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.2991.1">between HTTPS and HTTP is a peculiarity of web servers, too. </span><span class="koboSpan" id="kobo.2991.2">It is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2992.1">HTTPS termination</span></strong><span class="koboSpan" id="kobo.2993.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2994.1">Finally, web servers furnish further services, such as request filtering to prevent various kinds of attacks. </span><span class="koboSpan" id="kobo.2994.2">More generally, they understand the HTTP protocol and offer HTTP-related services such as access to static files, and various kinds of protocol and content negotiations with the client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2995.1">On the other hand, LoadBalancer services just handle the lower-level TCP/IP protocol and perform some load balancing. </span><span class="koboSpan" id="kobo.2995.2">Therefore, it would be great to use an actual web server to interface our Kubernetes cluster with the external world instead of several LoadBalancer services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2996.1">Kubernetes offers the possibility to run actual web servers inside of resources called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2997.1">Ingresses</span></strong><span class="koboSpan" id="kobo.2998.1">. </span><span class="koboSpan" id="kobo.2998.2">Ingresses act </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.2999.1">as interfaces between an actual web server and the Kubernetes API, and enable us to configure most web server services with a common interface that doesn’t </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.3000.1">depend </span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.3001.1">on the specific web server that is behind the Ingress.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3002.1">The following diagram exemplifies how an Ingress splits traffic among all frontend microservices inside a Kubernetes cluster:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.3003.1"><img alt="Figure 8.14: Ingress" src="../Images/B31916_08_14.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.3004.1">Figure 8.14: Ingress</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3005.1">Ingresses can be </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.3006.1">created in a cluster only after an </span><strong class="keyWord"><span class="koboSpan" id="kobo.3007.1">Ingress controller</span></strong><span class="koboSpan" id="kobo.3008.1"> has been installed in the cluster. </span><span class="koboSpan" id="kobo.3008.2">Each Ingress controller installation supplies both a specific web server, such as NGINX, and the code that interfaces it with the Kubernetes API.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3009.1">The information about the Ingress controller and its settings is provided in a resource called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3010.1">IngressClass</span></code><span class="koboSpan" id="kobo.3011.1">, which is referenced in the actual Ingress definition. </span><span class="koboSpan" id="kobo.3011.2">However, often, Ingress controller installations already define a default </span><code class="inlineCode"><span class="koboSpan" id="kobo.3012.1">IngressClass</span></code><span class="koboSpan" id="kobo.3013.1"> class, so there is no need to specify its name inside the ingress definition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3014.1">Below is how to define an IngressClass:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.3015.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3016.1">networking.k8s.io/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3017.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3018.1">IngressClass</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3019.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3020.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3021.1">app.kubernetes.io/component:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3022.1">controller</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3023.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3024.1">nginx-example</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3025.1">annotations:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3026.1">ingressclass.kubernetes.io/is-default-class:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3027.1">"true"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3028.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3029.1">controller:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3030.1">k8s.io/ingress-nginx</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3031.1">parameters:</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.3032.1"># optional parameters that depend on the installed controller</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3033.1">Each class </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.3034.1">specifies just the controller’s name (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3035.1">controller</span></code><span class="koboSpan" id="kobo.3036.1">), if it is the default class (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3037.1">…/is-default-class</span></code><span class="koboSpan" id="kobo.3038.1"> annotation), and some optional parameters </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.3039.1">that depend on the specific controller.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3040.1">Below is how to define an Ingress:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.3041.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3042.1">networking.k8s.io/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3043.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3044.1">Ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3045.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3046.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3047.1">my-example-ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3048.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3049.1">my-namespace</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3050.1"># annotations used to configure the ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3051.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3052.1">ingressClassName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3053.1">&lt;IngressClass</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3054.1">name&gt;</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.3055.1"># Sometimes it is not needed</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3056.1">tls:</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.3057.1"># HTTPS termination data</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3058.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3059.1">rules:</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.3060.1"># virtual hosting rules</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3061.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3062.1">Some controllers, such as the NGINX-based controller, use annotations placed in the metadata section to configure the web server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3063.1">HTTPS termination rules (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3064.1">tls</span></code><span class="koboSpan" id="kobo.3065.1">) are pairs made of a collection of domain names and an HTTPS certificate associated to them, where each certificate must be packaged as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3066.1">tls</span></code><span class="koboSpan" id="kobo.3067.1"> secret (see the </span><em class="italic"><span class="koboSpan" id="kobo.3068.1">Secrets</span></em><span class="koboSpan" id="kobo.3069.1"> subsection):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.3070.1">tls:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3071.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3072.1">hosts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3073.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3074.1">www.mydomain.com</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3075.1">secretName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3076.1">my-certificate1</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3077.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3078.1">hosts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3079.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3080.1">my-subdomain.anotherdomain.com</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3081.1">secretName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3082.1">my-certificate2</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3083.1">In the example above, each certificate applies just to a single domain, but if that domain has subdomains that are secured by the same certificate, we may add them to the same certificate list.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3084.1">There is a virtual hosting rule for each domain, and each of these rules has subrules for various paths:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.3085.1">rules:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3086.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3087.1">host:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3088.1">*.mydomain.com</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.3089.1"># leave this field empty to catch all domains</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3090.1">http:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3091.1">paths:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3092.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3093.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3094.1">/</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3095.1">pathType:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3096.1">Prefix</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.3097.1"># or Exact</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3098.1">backend:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3099.1">service:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3100.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3101.1">my-service-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3102.1">port:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3103.1">number:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.3104.1">80</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3105.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3106.1">host:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3107.1">my-subdomain.anotherdomain.com</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3108.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3109.1">Domain segments </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.3110.1">may be replaced by wildcards (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3111.1">*</span></code><span class="koboSpan" id="kobo.3112.1">). </span><span class="koboSpan" id="kobo.3112.2">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.3113.1">path</span></code><span class="koboSpan" id="kobo.3114.1"> subrule specifies a </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.3115.1">service name, and all traffic matching that rule will be sent to that service, at the port specified in the rule. </span><span class="koboSpan" id="kobo.3115.2">The service, in turn, forwards the traffic to all matching Pods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3116.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3117.1">pathType</span></code><span class="koboSpan" id="kobo.3118.1"> is prefix, it will match all request paths that have the specified path as a subsegment. </span><span class="koboSpan" id="kobo.3118.2">Otherwise, a perfect match is required. </span><span class="koboSpan" id="kobo.3118.3">In the example above, the first rule matches all paths since all paths have the empty segment</span><code class="inlineCode"><span class="koboSpan" id="kobo.3119.1">/</span></code><span class="koboSpan" id="kobo.3120.1">as subsegment.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3121.1"> If an input request matches more paths, the more specific one (the one containing more segments) is preferred.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3122.1">In the next subsection, we will put into practice what we have learned about Ingresses with a very simple example in Minikube.</span></p>
<h3 class="heading-3" id="_idParaDest-174"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.3123.1">Testing Ingresses with Minikube</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.3124.1">The easiest </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.3125.1">way to install an NGINX-based Ingress controller </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.3126.1">in Minikube is to enable the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3127.1">ingress</span></code><span class="koboSpan" id="kobo.3128.1"> addon. </span><span class="koboSpan" id="kobo.3128.2">Therefore, after having started Minikube, let’s enable this addon:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3129.1">minikube addons enable ingress
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3130.1">As a result, some Pods are created in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3131.1">ingress-nginx</span></code><span class="koboSpan" id="kobo.3132.1"> namespace. </span><span class="koboSpan" id="kobo.3132.2">Let’s check it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3133.1">kubectl get pods -n ingress-nginx</span></code><span class="koboSpan" id="kobo.3134.1">!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3135.1">The addon installs the same NGINX-based ingress controller used by most Kubernetes environments (</span><a href="https://github.com/kubernetes/ingress-nginx?tab=readme-ov-file"><span class="url"><span class="koboSpan" id="kobo.3136.1">https://github.com/kubernetes/ingress-nginx?tab=readme-ov-file</span></span></a><span class="koboSpan" id="kobo.3137.1">). </span><span class="koboSpan" id="kobo.3137.2">The installation also automatically creates an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3138.1">IngressClass</span></code><span class="koboSpan" id="kobo.3139.1"> called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3140.1">nginx</span></code><span class="koboSpan" id="kobo.3141.1">. </span><span class="koboSpan" id="kobo.3141.2">The annotations supported by this controller are listed here: </span><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/"><span class="url"><span class="koboSpan" id="kobo.3142.1">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/</span></span></a><span class="koboSpan" id="kobo.3143.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3144.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3145.1">ch08</span></code><span class="koboSpan" id="kobo.3146.1"> folder of the GitHub book repository contains </span><code class="inlineCode"><span class="koboSpan" id="kobo.3147.1">IngressExampleDeployment.yaml</span></code><span class="koboSpan" id="kobo.3148.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3149.1">IngressExampleDeployment2.yaml</span></code><span class="koboSpan" id="kobo.3150.1"> files. </span><span class="koboSpan" id="kobo.3150.2">They define two Deployments with their associated ClusterIP services. </span><span class="koboSpan" id="kobo.3150.3">They deploy two different versions of a very simple web application that creates a simple HTML page. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.3151.1">As usual, let’s copy </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.3152.1">the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.3153.1">.yaml</span></code><span class="koboSpan" id="kobo.3154.1"> files in a folder and open a console </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.3155.1">on that folder. </span><span class="koboSpan" id="kobo.3155.2">As the first step, let’s apply these files:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3156.1">kubectl apply -f IngressExampleDeployment.yaml
kubectl apply -f IngressExampleDeployment2.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3157.1">Now we will create an ingress that connects the first version of the application to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3158.1">/</span></code><span class="koboSpan" id="kobo.3159.1"> and the second version of the application to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3160.1">/v2</span></code><span class="koboSpan" id="kobo.3161.1">. </span><span class="koboSpan" id="kobo.3161.2">The names of the ClusterIP services of the two deployments are </span><code class="inlineCode"><span class="koboSpan" id="kobo.3162.1">helloworldingress-service</span></code><span class="koboSpan" id="kobo.3163.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3164.1">helloworldingress2-service</span></code><span class="koboSpan" id="kobo.3165.1">, and both receive on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3166.1">8080</span></code><span class="koboSpan" id="kobo.3167.1"> port. </span><span class="koboSpan" id="kobo.3167.2">Therefore, we need to bind the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3168.1">helloworldingress-service</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.3169.1">8080</span></code><span class="koboSpan" id="kobo.3170.1"> port to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3171.1">/</span></code><span class="koboSpan" id="kobo.3172.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3173.1">helloworldingress2-service</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.3174.1">8080</span></code><span class="koboSpan" id="kobo.3175.1"> port to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3176.1">/v2</span></code><span class="koboSpan" id="kobo.3177.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.3178.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3179.1">networking.k8s.io/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3180.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3181.1">Ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3182.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3183.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3184.1">example-ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3185.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3186.1">basic-examples</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3187.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3188.1">ingressClassName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3189.1">nginx</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3190.1">rules:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3191.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3192.1">host:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3193.1">http:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3194.1">paths:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3195.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3196.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3197.1">/</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3198.1">pathType:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3199.1">Prefix</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3200.1">backend:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3201.1">service:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3202.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3203.1">helloworldingress-service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3204.1">port:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3205.1">number:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.3206.1">8080</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.3207.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.3208.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3209.1">/v2</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3210.1">pathType:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3211.1">Prefix</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3212.1">backend:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3213.1">service:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3214.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3215.1">helloworldingress2-service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3216.1">port:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.3217.1">number:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.3218.1">8080</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3219.1">It is worth pointing out that the host property is empty, so the Ingress doesn’t perform any selection based on the domain name, but the microservice selection is based just on the path. </span><span class="koboSpan" id="kobo.3219.2">This was a </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.3220.1">forced choice since we are experimenting on an isolated </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.3221.1">development machine without the support of a DNS, so we can’t associate domain names to IP addresses.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3222.1">Let’s put the above code in a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.3223.1">IngressConfiguration.yaml</span></code><span class="koboSpan" id="kobo.3224.1"> and let’s apply it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3225.1">kubectl apply -f IngressConfiguration.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3226.1">In order to connect with the Ingress, we need to open a tunnel with the Minikube virtual machine. </span><span class="koboSpan" id="kobo.3226.2">As usual, open another console and issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3227.1">minikube tunnel</span></code><span class="koboSpan" id="kobo.3228.1"> command in it. </span><span class="koboSpan" id="kobo.3228.2">Remember that the tunnel works as long as this window remains open.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3229.1">Now open the browser and go to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3230.1">http://localhost</span></code><span class="koboSpan" id="kobo.3231.1">. </span><span class="koboSpan" id="kobo.3231.2">You should see something like:</span></p>
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.3232.1">Hello, world!</span></strong></p>
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.3233.1">Version: 1.0.0</span></strong></p>
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.3234.1">Hostname: ……</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.3235.1">Then go to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3236.1">http://localhost/v2</span></code><span class="koboSpan" id="kobo.3237.1">. </span><span class="koboSpan" id="kobo.3237.2">You should see something like:</span></p>
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.3238.1">Hello, world!</span></strong></p>
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.3239.1">Version: 2.0.0</span></strong></p>
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.3240.1">Hostname: ……</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.3241.1">We were able to split the traffic between the two applications according to the request path!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3242.1">When you have finished experimenting, let’s clean up the environment with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3243.1">kubectl delete -f IngressConfiguration.yaml
kubectl delete -f IngressExampleDeployment2.yaml
kubectl delete -f IngressExampleDeployment.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3244.1">Finally, let’s stop Minikube with: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3245.1">minikube stop</span></code><span class="koboSpan" id="kobo.3246.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3247.1">The next subsection explains how to install the same Ingress controller on AKS.</span></p>
<h3 class="heading-3" id="_idParaDest-175"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.3248.1">Using an NGNIX-based Ingress in AKS</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.3249.1">You can manually install the NGNIX-based Ingress on AKS either with a .</span><code class="inlineCode"><span class="koboSpan" id="kobo.3250.1">yaml</span></code><span class="koboSpan" id="kobo.3251.1"> file or with a package </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.3252.1">manager called Helm. </span><span class="koboSpan" id="kobo.3252.2">However, then, you should </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.3253.1">handle complex permissions-related </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.3254.1">configurations to associate a static IP and an Azure DNS zone to your AKS cluster. </span><span class="koboSpan" id="kobo.3254.2">The interested reader can find the complete procedure here: </span><a href="https://medium.com/@anilbidary/domain-name-based-routing-on-aks-azure-kubernetes-service-using-ingress-cert-manager-and-9b4028d762ed"><span class="url"><span class="koboSpan" id="kobo.3255.1">https://medium.com/@anilbidary/domain-name-based-routing-on-aks-azure-kubernetes-service-using-ingress-cert-manager-and-9b4028d762ed</span></span></a><span class="koboSpan" id="kobo.3256.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3257.1">Luckily, you can let Azure do all of this job for you, because Azure has an AKS application routing addon that automatically installs the Ingress for you and facilitates all permission configuration. </span><span class="koboSpan" id="kobo.3257.2">This addon can be enabled on an existing cluster with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3258.1">az aks approuting enable --resource-group &lt;ResourceGroupName&gt; --name &lt;ClusterName&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3259.1">The addon creates </span><code class="inlineCode"><span class="koboSpan" id="kobo.3260.1">webapprouting.kubernetes.azure.com</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.3261.1">IngressClass</span></code><span class="koboSpan" id="kobo.3262.1">, which you must reference in all your Ingresses.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3263.1">An IP address is created whenever you create a new Ingress and remains allocated for the lifetime of the Ingress. </span><span class="koboSpan" id="kobo.3263.2">Moreover, if you create an Azure DNS zone and associate it to the addon, the addon will automatically add all needed records for all domains defined in the rules of your Ingresses.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3264.1">You just need to create an Azure DNS zone with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3265.1">az network dns zone create --resource-group &lt;ResourceGroupName&gt; --name &lt;ZoneName&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3266.1">In order to associate this zone to the addon, you need the zone’s unique ID, which you can get with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3267.1">ZONEID=$(az network dns zone show --resource-group &lt;ResourceGroupName&gt; --name &lt;ZoneName&gt; --query "id" --output tsv)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3268.1">Now you can attach the zone with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3269.1">az aks approuting zone add --resource-group &lt;ResourceGroupName&gt; --name &lt;ClusterName&gt; --ids=${ZONEID} --attach-zones
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3270.1">After this command, all domain names used in your Ingress’s rules will be automatically added to the zone with adequate records. </span><span class="koboSpan" id="kobo.3270.2">Obviously, you must update your domain data in the provider where you bought your domain names. </span><span class="koboSpan" id="kobo.3270.3">More specifically, you must force them to point to the names of the Azure DNS servers that handle your zone. </span><span class="koboSpan" id="kobo.3270.4">You can easily get these DNS server </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.3271.1">names by going to the newly created </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.3272.1">DNS zone in the Azure portal.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3273.1">We have </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.3274.1">finished our amazing Kubernetes trip. </span><span class="koboSpan" id="kobo.3274.2">We will return to most of the concepts learned about here in most of the remaining chapters, and in particular in </span><a href="Chapter_11.xhtml#_idTextAnchor332"><em class="italic"><span class="koboSpan" id="kobo.3275.1">Chapter 11</span></em></a><em class="italic"><span class="koboSpan" id="kobo.3276.1">, </span></em><em class="italic"><span class="koboSpan" id="kobo.3277.1">The Car Sharing App</span></em><span class="koboSpan" id="kobo.3278.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3279.1">The next chapter shows how to start a new microservices application smoothly and with low costs with the help of Azure Container Apps.</span></p>
<h1 class="heading-1" id="_idParaDest-176"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.3280.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3281.1">In this chapter, you learned about the basics of orchestrators and then learned how to install and configure a Kubernetes cluster. </span><span class="koboSpan" id="kobo.3281.2">More specifically, you learned how to interact with a Kubernetes cluster through Kubectl and Kubectl’s main commands. </span><span class="koboSpan" id="kobo.3281.3">Then you learned how to deploy and maintain a microservices application, and how to test it locally with the help of Docker and Minikube.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3282.1">You also learned how to interface your Kubernetes cluster with a LoadBalancer and with an Ingress, and how to fine-tune it to optimize performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3283.1">All concepts were put into practice with both simple examples and with a more complete example taken from the car-sharing case study.</span></p>
<h1 class="heading-1" id="_idParaDest-177"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.3284.1">Questions </span></h1>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3285.1">Why do Kubernetes applications need network disk storage?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3286.1">Because PODs can’t rely on the disk storage of the nodes where they run, since they might be moved to different nodes.</span></p>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.3287.1">Is it true that if a node containing a Pod of a Deployment with 10 replicas crashes, your application will continue running properly?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3288.1">Yes.</span></p>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.3289.1">Is it true that if a node containing a Pod of a StatefulSet with 10 replicas crashes, your application will continue running properly?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3290.1">Not necessarily.</span></p>
<ol>
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.3291.1">Is it true that if a Pod crashes, it is always automatically restarted?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3292.1">Yes.</span></p>
<ol>
<li class="numberedList" value="5"><span class="koboSpan" id="kobo.3293.1">Why do StatefulSets need persistent volume claim templates instead of persistent volume claims?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3294.1">Because each POD of the StatefulSet needs a different volume.</span></p>
<ol>
<li class="numberedList" value="6"><span class="koboSpan" id="kobo.3295.1">What is the utility of persistent volume claims?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3296.1">They enable Kubernetes users to request and manage storage resources dynamically, decoupling storage provisioning from application deployment.</span></p>
<ol>
<li class="numberedList" value="7"><span class="koboSpan" id="kobo.3297.1">What is more adequate for interfacing an application with three different frontend services, a LoadBalancer or an ingress?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3298.1">An Ingress. </span><span class="koboSpan" id="kobo.3298.2">LoadBalancers are adequate just when there is an unique Frontend service.</span></p>
<ol>
<li class="numberedList" value="8"><span class="koboSpan" id="kobo.3299.1">What is the most adequate way of passing a connection string to a container running in a Pod of a Kubernetes cluster?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3300.1">By using a Kubernetes Secret since it contains sensitive information.</span></p>
<ol>
<li class="numberedList" value="9"><span class="koboSpan" id="kobo.3301.1">How are HTTPS certificates installed in Ingresses?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3302.1">Through a specific type of secret.</span></p>
<ol>
<li class="numberedList" value="10"><span class="koboSpan" id="kobo.3303.1">Does standard Kubernetes syntax allow the installation of an HTTPS certificate on a LoadBalancer service?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.3304.1">No.</span></p>
<h1 class="heading-1" id="_idParaDest-178"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.3305.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3306.1">Kubernetes official documentation: </span><a href="https://kubernetes.io/docs/home/"><span class="url"><span class="koboSpan" id="kobo.3307.1">https://kubernetes.io/docs/home/</span></span></a><span class="koboSpan" id="kobo.3308.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3309.1">AKS official documentation: </span><a href="https://learn.microsoft.com/en-us/azure/aks/"><span class="url"><span class="koboSpan" id="kobo.3310.1">https://learn.microsoft.com/en-us/azure/aks/</span></span></a><span class="koboSpan" id="kobo.3311.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3312.1">Minikube official documentation: </span><a href="https://minikube.sigs.k8s.io/docs/"><span class="url"><span class="koboSpan" id="kobo.3313.1">https://minikube.sigs.k8s.io/docs/</span></span></a><span class="koboSpan" id="kobo.3314.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3315.1">AKS autoscaling: </span><a href="https://learn.microsoft.com/en-us/azure/aks/cluster-autoscaler?tabs=azure-cli "><span class="url"><span class="koboSpan" id="kobo.3316.1">https://learn.microsoft.com/en-us/azure/aks/cluster-autoscaler?tabs=azure-cli</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3317.1">Cloud-independent cluster auto-scalers: </span><a href="https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/"><span class="url"><span class="koboSpan" id="kobo.3318.1">https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3319.1">Storage classes: </span><a href="https://kubernetes.io/docs/concepts/storage/storage-classes/"><span class="url"><span class="koboSpan" id="kobo.3320.1">https://kubernetes.io/docs/concepts/storage/storage-classes/</span></span></a><span class="koboSpan" id="kobo.3321.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3322.1">Assigning a static Azure IP address to a LoadBalancer: </span><a href="https://learn.microsoft.com/en-us/azure/aks/static-ip"><span class="url"><span class="koboSpan" id="kobo.3323.1">https://learn.microsoft.com/en-us/azure/aks/static-ip</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3324.1">Example metrics server: </span><a href="https://github.com/kubernetes-sigs/metrics-server"><span class="url"><span class="koboSpan" id="kobo.3325.1">https://github.com/kubernetes-sigs/metrics-server</span></span></a><span class="koboSpan" id="kobo.3326.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3327.1">NGINX-based Ingress controller: </span><a href="https://github.com/kubernetes/ingress-nginx?tab=readme-ov-file"><span class="url"><span class="koboSpan" id="kobo.3328.1">https://github.com/kubernetes/ingress-nginx?tab=readme-ov-file</span></span></a><span class="koboSpan" id="kobo.3329.1"> .</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3330.1">Manual installation of NGINX-based Ingress of AKS: </span><a href="https://www.medium.com/@anilbidary/domain-name-based-routing-on-aks-azure-kubernetes-service-using-ingresscert-manager-and-9b4028d762ed"><span class="url"><span class="koboSpan" id="kobo.3331.1">https://medium.com/@anilbidary/</span></span></a></li>
<li class="bulletList"><a href="https://www.medium.com/@anilbidary/domain-name-based-routing-on-aks-azure-kubernetes-service-using-ingresscert-manager-and-9b4028d762ed"><span class="url"><span class="koboSpan" id="kobo.3332.1">domain-name-based-routing-on-aks-azure-kubernetes-service-using-ingresscert-manager-and-9b4028d762ed</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3333.1">Using RabbitMQ Cluster operator:</span><span class="url"> </span><a href="https://www.rabbitmq.com/kubernetes/operator/using-operator"><span class="url"><span class="koboSpan" id="kobo.3334.1">https://www.rabbitmq.com/kubernetes/operator/using-operator</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3335.1">Installing a RabbitMQ Cluster on Kubernetes: </span><a href="https://www.rabbitmq.com/kubernetes/operator/install-operator"><span class="url"><span class="koboSpan" id="kobo.3336.1">https://www.rabbitmq.com/kubernetes/operator/install-operator</span></span></a><span class="koboSpan" id="kobo.3337.1">.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-179"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.3338.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3339.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/PSMCSharp"><span class="url"><span class="koboSpan" id="kobo.3340.1">https://packt.link/PSMCSharp</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.3341.1"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="../Images/B31916_Discord-QR-Code.png"/></span></p>
</div>
</body></html>