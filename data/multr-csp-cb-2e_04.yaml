- en: Chapter 4. Using the Task Parallel Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 使用任务并行库
- en: 'In this chapter, we will dive into a new asynchronous programming paradigm,
    the Task Parallel Library. You will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究一种新的异步编程范式，即任务并行库。您将学习以下技巧：
- en: Creating a task
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务
- en: Performing basic operations with a task
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务执行基本操作
- en: Combining tasks together
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合任务
- en: Converting the APM pattern to tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将APM模式转换为任务
- en: Converting the EAP pattern to tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将EAP模式转换为任务
- en: Implementing a cancelation option
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: Handling exceptions in tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务中处理异常
- en: Running tasks in parallel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行任务
- en: Tweaking the execution of tasks with `TaskScheduler`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TaskScheduler`调整任务的执行
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, you learned what a thread is, how to use threads,
    and why we need a thread pool. Using a thread pool allows us to save operating
    system resources at the cost of reducing a parallelism degree. We can think of
    a thread pool as an **abstraction layer** that hides details of thread usage from
    a programmer, allowing us to concentrate on a program's logic rather than on threading
    issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了什么是线程，如何使用线程，以及为什么我们需要线程池。使用线程池可以在减少并行度度的代价下节省操作系统资源。我们可以将线程池视为一个**抽象层**，它隐藏了线程使用的细节，使我们能够专注于程序的逻辑，而不是线程问题。
- en: However, using a thread pool is complicated as well. There is no easy way to
    get a result from a thread pool worker thread. We need to implement our own way
    to get a result back, and in case of an exception, we have to propagate it to
    the original thread properly. Besides this, there is no easy way to create a set
    of dependent asynchronous actions, where one action runs after another finishes
    its work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用线程池也很复杂。没有简单的方法可以从线程池工作线程中获取结果。我们需要实现自己的方法来获取结果，并在发生异常的情况下，必须正确地将异常传播到原始线程。除此之外，没有简单的方法来创建一系列依赖的异步操作，其中一个操作在另一个操作完成其工作后运行。
- en: There were several attempts to work around these issues, which resulted in the
    creation of the Asynchronous Programming Model and the Event-based Asynchronous
    Pattern, mentioned in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"),
    *Using a Thread Pool*. These patterns made getting results easier and did a good
    job of propagating exceptions, but combining asynchronous actions together still
    required a lot of work and resulted in a large amount of code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，已经尝试了多种方法，这导致了异步编程模型和基于事件的异步模式（EAP）的创建，这些模式在[第3章](ch03.html "第3章 使用线程池")中提到，*使用线程池*。这些模式使得获取结果更容易，并且在传播异常方面做得很好，但组合异步操作仍然需要大量工作，并导致大量代码的产生。
- en: To resolve all these problems, a new API for asynchronous operations was introduced
    in .Net Framework 4.0\. It was called the Task Parallel Library (TPL). It was
    changed slightly in .Net Framework 4.5 and to make it clear, we will work with
    the latest version of TPL using the 4.6 version of .Net Framework in our projects.
    TPL can be considered as one more abstraction layer over a thread pool, hiding
    the lower-level code that will work with the thread pool from a programmer and
    supplying a more convenient and fine-grained API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决所有这些问题，.Net Framework 4.0中引入了一个新的异步操作API。它被称为任务并行库（TPL）。在.Net Framework
    4.5中它有所改变，为了明确起见，我们将使用项目中.Net Framework 4.6的最新版本来工作。TPL可以被视为在线程池之上的另一个抽象层，它隐藏了与线程池工作的底层代码，并为程序员提供了一个更方便和更细粒度的API。
- en: The core concept of TPL is a task. A task represents an asynchronous operation
    that can be run in a variety of ways, using a separate thread or not. We will
    look through all the possibilities in detail in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TPL的核心概念是任务。任务表示一种异步操作，它可以以多种方式运行，使用单独的线程或不使用。我们将在本章中详细探讨所有可能性。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, a programmer is not aware of how exactly a task is being executed.
    TPL raises the level of abstraction by hiding the task implementation details
    from the user. Unfortunately, in some cases, this could lead to mysterious errors,
    such as the application hanging while trying to get a result from the task. This
    chapter will help you understand the mechanics under the hood of TPL and how to
    avoid using it in improper ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，程序员并不了解任务是如何被具体执行的。TPL通过隐藏任务实现的细节来提高抽象级别。不幸的是，在某些情况下，这可能导致神秘的错误，例如在尝试从任务获取结果时应用程序挂起。本章将帮助您理解TPL底层的机制以及如何避免以不恰当的方式使用它。
- en: A task can be combined with other tasks in different variations. For example,
    we are able to start several tasks simultaneously, wait for all of them to complete,
    and then run a task that will perform some calculations over all the previous
    tasks' results. Convenient APIs for task combination are one of the key advantages
    of TPL compared to the previous patterns.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以与其他任务以不同的变体组合。例如，我们能够同时启动几个任务，等待它们全部完成，然后运行一个任务，该任务将对所有先前任务的输出执行一些计算。方便的任务组合
    API 是 TPL 相比于先前模式的关键优势之一。
- en: There are also several ways to deal with exceptions resulting from tasks. Since
    a task may consist of several other tasks, and they in turn have their child tasks
    as well, there is the concept of `AggregateException`. This type of exception
    holds all exceptions from underlying tasks inside it, allowing us to handle them
    separately.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种方法可以处理任务产生的异常。由于一个任务可能由几个其他任务组成，而这些任务又可能有它们自己的子任务，因此存在 `AggregateException`
    的概念。此类异常包含其内部所有底层任务的异常，允许我们分别处理它们。
- en: And, last but not least, C# has built-in support for TPL since version 5.0,
    allowing us to work with tasks in a very smooth and comfortable way using the
    new `await` and `async` keywords. We will discuss this topic in [Chapter 5](ch05.html
    "Chapter 5. Using C# 6.0"), *Using C# 6.0*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，从版本 5.0 开始，C# 内置了对 TPL 的支持，允许我们使用新的 `await` 和 `async` 关键字以非常顺畅和舒适的方式与任务一起工作。我们将在
    [第 5 章](ch05.html "第 5 章。使用 C# 6.0") 中讨论此主题，*使用 C# 6.0*。
- en: In this chapter, you will learn to use TPL to execute asynchronous operations.
    We will learn what a task is, cover different ways to create tasks, and will learn
    how to combine tasks. We will also discuss how to convert legacy APM and EAP patterns
    to use tasks, how to handle exceptions properly, how to cancel tasks, and how
    to work with several tasks that are being executed simultaneously. In addition,
    we will find out how to deal with tasks in Windows GUI applications properly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 TPL 执行异步操作。我们将学习任务是什么，介绍创建任务的不同方法，并学习如何组合任务。我们还将讨论如何将遗留的 APM 和
    EAP 模式转换为使用任务，如何正确处理异常，如何取消任务，以及如何处理同时执行的任务。此外，我们还将了解如何正确处理 Windows GUI 应用程序中的任务。
- en: Creating a task
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务
- en: This recipe shows the basic concept of what a task is. You will learn how to
    create and execute tasks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方展示了任务的基本概念。您将学习如何创建和执行任务。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe1`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要 Visual Studio 2015。没有其他先决条件。此配方的源代码可以在 `BookSamples\Chapter4\Recipe1`
    中找到。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create and execute a task, perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和执行任务，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Note
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This time, make sure that you are using .Net Framework 4.5 or higher for every
    project.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，请确保您在每个项目中使用 .Net Framework 4.5 或更高版本。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program runs, it creates two tasks with its constructor. We pass the
    lambda expression as the `Action` delegate; this allows us to provide a string
    parameter to `TaskMethod`. Then, we run these tasks using the `Start` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它使用其构造函数创建两个任务。我们将 lambda 表达式作为 `Action` 委托传递；这允许我们向 `TaskMethod` 提供一个字符串参数。然后，我们使用
    `Start` 方法运行这些任务。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that until we call the `Start` method on these tasks, they will not start
    execution. It is very easy to forget to actually start the task.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直到我们调用这些任务的 `Start` 方法，它们将不会开始执行。很容易忘记实际启动任务。
- en: Then, we run two more tasks using the `Task.Run` and `Task.Factory.StartNew`
    methods. The difference is that both the created tasks immediately start working,
    so we do not need to call the `Start` method on the tasks explicitly. All of the
    tasks, numbered `Task 1` to `Task 4`, are placed on thread pool worker threads
    and run in an unspecified order. If you run the program several times, you will
    find that the task execution order is not defined.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Task.Run`和`Task.Factory.StartNew`方法运行两个更多任务。区别在于创建的任务立即开始工作，因此我们不需要显式地调用任务的`Start`方法。所有任务，编号从`Task
    1`到`Task 4`，都被放置在线程池工作线程上，并以不确定的顺序运行。如果你多次运行程序，你会发现任务执行顺序是没有定义的。
- en: The `Task.Run` method is just a shortcut to `Task.Factory.StartNew`, but the
    latter method has additional options. In general, use the former method unless
    you need to do something special, as in the case of `Task 5`. We mark this task
    as long-running, and as a result, this task will be run on a separate thread that
    does not use a thread pool. However, this behavior could change, depending on
    the current **task scheduler** that runs the task. You will learn what a task
    scheduler is in the last recipe of this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Run`方法只是`Task.Factory.StartNew`的快捷方式，但后者方法有额外的选项。通常，除非你需要做特别的事情，例如在`Task
    5`的情况下，使用前者方法。我们将此任务标记为长时间运行，因此这个任务将在不使用线程池的单独线程上运行。然而，这种行为可能会根据运行任务的当前**任务调度器**而改变。你将在本章的最后一个食谱中学习什么是任务调度器。'
- en: Performing basic operations with a task
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务执行基本操作
- en: This recipe will describe how to get the result value from a task. We will go
    through several scenarios to understand the difference between running a task
    on a thread pool or on a main thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述如何从任务中获取结果值。我们将通过几个场景来了解在线程池或主线程上运行任务之间的区别。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe2`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个食谱，你需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在`BookSamples\Chapter4\Recipe2`中找到。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To perform basic operations with a task, perform the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用任务执行基本操作，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At first, we run `TaskMethod` without wrapping it into a task. As a result,
    it is executed synchronously, providing us with information about the main thread.
    Obviously, it is not a thread pool thread.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不将`TaskMethod`包装成任务来运行它。结果，它是同步执行的，为我们提供了有关主线程的信息。显然，它不是线程池线程。
- en: Then, we run `Task 1`, starting it with the `Start` method and waiting for the
    result. This task will be placed on a thread pool, and the main thread waits and
    is blocked until the task returns.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Start`方法启动`Task 1`，并等待结果。这个任务将被放置在线程池中，主线程将等待并阻塞，直到任务返回。
- en: We do the same with `Task 2`, except that we run it using the `RunSynchronously()`
    method. This task will run on the main thread, and we get exactly the same output
    as in the very first case when we called `TaskMethod` synchronously. This is a
    very useful optimization that allows us to avoid thread pool usage for very short-lived
    operations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Task 2`也做同样的处理，只不过我们使用`RunSynchronously()`方法来运行它。这个任务将在主线程上运行，并且我们得到与第一次调用`TaskMethod`同步时完全相同的输出。这是一个非常有用的优化，它允许我们避免在非常短暂的操作中使用线程池。
- en: We run `Task 3` in the same way we did `Task 1`, but instead of blocking the
    main thread, we just spin, printing out the task status until the task is completed.
    This shows several task statuses, which are `Created`, `Running`, and `RanToCompletion`,
    respectively.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与`Task 1`相同的方式运行`Task 3`，但不是阻塞主线程，而是旋转，打印出任务状态，直到任务完成。这显示了几个任务状态，分别是`Created`、`Running`和`RanToCompletion`。
- en: Combining tasks
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合任务
- en: This recipe will show you how to set up tasks that are dependent on each other.
    We will learn how to create a task that will run after the parent task is complete.
    In addition, we will discover a way to save thread usage for very short-lived
    tasks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将向您展示如何设置相互依赖的任务。我们将学习如何创建在父任务完成后运行的任务。此外，我们还将发现一种为非常短暂的任务节省线程使用的方法。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe3`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要 Visual Studio 2015。没有其他先决条件。此配方的源代码可以在 `BookSamples\Chapter4\Recipe3`
    中找到。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To combine tasks, perform the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要组合任务，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, we create two tasks, and for the first task, we
    set up a **continuation** (a block of code that runs after the antecedent task
    is complete). Then, we start both tasks and wait for 4 seconds, which is enough
    for both tasks to be complete. Then, we run another continuation to the second
    task and try to execute it synchronously by specifying a `TaskContinuationOptions.ExecuteSynchronously`
    option. This is a useful technique when the continuation is very short lived,
    and it will be faster to run it on the main thread than to put it on a thread
    pool. We are able to achieve this because the second task is completed by that
    moment. If we comment out the 4-second `Thread.Sleep` method, we will see that
    this code will be put on a thread pool because we do not have the result from
    the antecedent task yet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，我们创建了两个任务，并为第一个任务设置了一个**延续**（在先决任务完成后运行的代码块）。然后，我们启动两个任务并等待 4 秒，这对于两个任务完成来说足够了。然后，我们对第二个任务运行另一个延续，并通过指定
    `TaskContinuationOptions.ExecuteSynchronously` 选项来尝试同步执行它。当延续非常短暂时，这是一个有用的技术，在主线程上运行它比将其放在线程池中要快。我们能够实现这一点，因为此时第二个任务已经完成。如果我们注释掉
    4 秒的 `Thread.Sleep` 方法，我们将看到此代码将被放在线程池中，因为我们还没有先决任务的结果。
- en: Finally, we define a continuation for the previous continuation, but in a slightly
    different manner, using the new `GetAwaiter` and `OnCompleted` methods. These
    methods are intended to be used along with C# language asynchronous mechanics.
    We will cover this topic later in [Chapter 5](ch05.html "Chapter 5. Using C# 6.0"),
    *Using C# 6.0*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为之前的延续定义了一个延续，但方式略有不同，使用了新的 `GetAwaiter` 和 `OnCompleted` 方法。这些方法旨在与 C#
    语言的异步机制一起使用。我们将在第 5 章[使用 C# 6.0](ch05.html "第 5 章。使用 C# 6.0")中介绍这个主题。
- en: The last part of the demo is about the parent-child task relationships. We create
    a new task, and while running this task, we run a so-called child task by providing
    a `TaskCreationOptions.AttachedToParent` option.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 演示的最后部分是关于父-子任务关系。我们创建一个新的任务，并在运行此任务的同时，通过提供 `TaskCreationOptions.AttachedToParent`
    选项来运行所谓的子任务。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The child task must be created while running a parent task so that it is attached
    to the parent properly!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 子任务必须在运行父任务时创建，以确保它正确地附加到父任务上！
- en: This means that the parent task will not be complete until all child tasks finish
    their work. We are also able to run continuations on those child tasks that provide
    a `TaskContinuationOptions.AttachedToParent` option. These continuation tasks
    will affect the parent task as well, and it will not be complete until the very
    last child task ends.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着父任务将不会完成，直到所有子任务完成其工作。我们还可以运行提供 `TaskContinuationOptions.AttachedToParent`
    选项的子任务的延续。这些延续任务也会影响父任务，并且它将不会完成，直到最后一个子任务结束。
- en: Converting the APM pattern to tasks
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 APM 模式转换为任务
- en: In this recipe, we will see how to convert an old-fashioned APM API to a task.
    There are examples of different situations that could take place in the process
    of conversion.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将看到如何将旧式的 APM API 转换为任务。在转换过程中可能发生不同情况都有示例。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe4`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始此配方，您需要 Visual Studio 2015。没有其他先决条件。此配方的源代码可以在 `BookSamples\Chapter4\Recipe4`
    中找到。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To convert the APM pattern to tasks, carry out the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 APM 模式转换为任务，执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we define two kinds of delegates; one of them uses the `out` parameter
    and therefore is incompatible with the standard TPL API for converting the APM
    pattern to tasks. Then, we have three examples of such a conversion.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两种类型的委托；其中一种使用 `out` 参数，因此与将 APM 模式转换为任务的 TPL 标准API 不兼容。然后，我们有三个此类转换的示例。
- en: The key point for converting APM to TPL is the `Task<T>.Factory.FromAsync` method,
    where `T` is the asynchronous operation result type. There are several overloads
    of this method; in the first case, we pass `IAsyncResult` and `Func<IAsyncResult,
    string>`, which is a method that accepts the `IAsyncResult` implementation and
    returns a string. Since the first delegate type provides `EndMethod`, which is
    compatible with this signature, we have no problem converting this delegate asynchronous
    call to a task.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将 APM 转换为 TPL 的关键点是 `Task<T>.Factory.FromAsync` 方法，其中 `T` 是异步操作的结果类型。此方法有几个重载；在第一种情况下，我们传递
    `IAsyncResult` 和 `Func<IAsyncResult, string>`，这是一个接受 `IAsyncResult` 实现并返回字符串的方法。由于第一个委托类型提供了与该签名兼容的
    `EndMethod`，因此我们可以将此委托异步调用转换为任务。
- en: In the second example, we do almost the same, but use a different `FromAsync`
    method overload, which does not allow specifying a callback that will be executed
    after the asynchronous delegate call is completed. We are able to replace this
    with a continuation, but if the callback is important, we can use the first example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们几乎做了同样的事情，但使用了不同的 `FromAsync` 方法重载，它不允许指定在异步委托调用完成后要执行的回调。我们能够用延续来替换它，但如果回调很重要，我们可以使用第一个示例。
- en: The last example shows a little trick. This time, `EndMethod` of the `IncompatibleAsynchronousTask`
    delegate uses the `out` parameter and is not compatible with any `FromAsync` method
    overload. However, it is very easy to wrap the `EndMethod` call into a lambda
    expression that will be suitable for the task factory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例展示了一个小技巧。这次，`IncompatibleAsynchronousTask` 委托的 `EndMethod` 使用 `out` 参数，并且与任何
    `FromAsync` 方法重载都不兼容。然而，将 `EndMethod` 调用包装到一个适合任务工厂的 lambda 表达式中是非常容易的。
- en: To see what is going on with the underlying task, we are printing its status
    while waiting for the asynchronous operation's result. We see that the first task's
    status is `WaitingForActivation`, which means that the task has not actually been
    started yet by the TPL infrastructure.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看底层任务的状态，我们在等待异步操作结果的同时打印其状态。我们看到第一个任务的状态是 `WaitingForActivation`，这意味着任务尚未由
    TPL 基础设施实际启动。
- en: Converting the EAP pattern to tasks
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 EAP 模式转换为任务
- en: This recipe will describe how to translate event-based asynchronous operations
    to tasks. In this recipe, you will find a solid pattern that is suitable for every
    event-based asynchronous API in the .NET Framework class library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将描述如何将基于事件的异步操作转换为任务。在此配方中，您将找到一个适用于 .NET Framework 类库中每个基于事件的异步 API 的可靠模式。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe5`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始此配方，您需要 Visual Studio 2015。没有其他先决条件。此配方的源代码可以在 `BookSamples\Chapter4\Recipe5`
    中找到。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To convert the EAP pattern to tasks, perform the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 EAP 模式转换为任务，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is a very simple and elegant example of converting EAP patterns to tasks.
    The key point is to use the `TaskCompletionSource<T>` type, where `T` is an asynchronous
    operation result type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将EAP模式转换为任务的非常简单且优雅的例子。关键点是使用`TaskCompletionSource<T>`类型，其中`T`是异步操作的结果类型。
- en: It is also important not to forget to wrap the `tcs.SetResult` method call into
    the `try/catch` block in order to guarantee that the error information is always
    set to the task completion source object. It is also possible to use the `TrySetResult`
    method instead of `SetResult` to make sure that the result has been set successfully.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是不要忘记将`tcs.SetResult`方法调用包装在`try/catch`块中，以确保错误信息始终被设置为任务完成源对象。也可以使用`TrySetResult`方法代替`SetResult`来确保结果已成功设置。
- en: Implementing a cancelation option
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: This recipe is about implementing the cancelation process for task-based asynchronous
    operations. You will learn how to use the cancelation token properly for tasks
    and how to find out whether a task is canceled before it was actually run.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是关于实现基于任务的异步操作的取消过程。您将学习如何正确使用取消令牌来处理任务，以及如何在任务实际运行之前找出任务是否被取消。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start with this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe6`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个配方，您需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter4\Recipe6`中找到。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To implement a cancelation option for task-based asynchronous operations, perform
    the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要为基于任务的异步操作实现取消选项，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is another very simple example of how to implement the cancelation option
    for a TPL task. You are already familiar with the cancelation token concept we
    discussed in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"), *Using a
    Thread Pool*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个如何为TPL任务实现取消选项的简单示例。您已经熟悉我们在[第3章](ch03.html "第3章。使用线程池")中讨论的取消令牌概念，*使用线程池*。
- en: First, let's look closely at the `longTask` creation code. We're providing a
    cancelation token to the underlying task once and then to the task constructor
    for the second time. *Why do we need to supply this token twice?*
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们仔细看看`longTask`的创建代码。我们一次性将取消令牌提供给底层任务，然后再次将其提供给任务构造函数。*为什么我们需要提供这个令牌两次？*
- en: The answer is that if we cancel the task before it was actually started, its
    TPL infrastructure is responsible for dealing with the cancelation because our
    code will not be executed at all. We know that the first task was canceled by
    getting its status. If we try to call the `Start` method on this task, we will
    get `InvalidOperationException`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，如果我们在一个任务实际开始之前取消它，那么它的TPL基础设施将负责处理取消操作，因为我们的代码根本不会执行。我们知道第一个任务是通过获取其状态被取消的。如果我们尝试在这个任务上调用`Start`方法，我们将得到`InvalidOperationException`。
- en: Then, we deal with the cancelation process from our own code. This means that
    we are now fully responsible for the cancelation process, and after we canceled
    the task, its status was still `RanToCompletion` because from TPL's perspective,
    the task finished its job normally. It is very important to distinguish these
    two situations and understand the responsibility difference in each case.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们处理从我们自己的代码中取消操作的过程。这意味着我们现在完全负责取消过程，并且在取消任务后，其状态仍然是`RanToCompletion`，因为从TPL的角度来看，任务正常完成了其工作。区分这两种情况并理解每种情况下的责任差异非常重要。
- en: Handling exceptions in tasks
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理任务中的异常
- en: This recipe describes the very important topic of handling exceptions in asynchronous
    tasks. We will go through different aspects of what happens to exceptions thrown
    from tasks and how to get to their information.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方描述了处理异步任务中异常的非常重要的话题。我们将探讨任务抛出的异常的不同方面以及如何获取它们的信息。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe7`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter4\Recipe7`找到。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To handle exceptions in tasks, perform the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理任务中的异常，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE18]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE19]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE20]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the program.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program starts, we create a task and try to get the task results synchronously.
    The `Get` part of the `Result` property makes the current thread wait until the
    completion of the task and propagates the exception to the current thread. In
    this case, we easily catch the exception in a catch block, but this exception
    is a wrapper exception called `AggregateException`. In this case, it holds only
    one exception inside because only one task has thrown this exception, and it is
    possible to get the underlying exception by accessing the `InnerException` property.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，我们创建一个任务并尝试同步地获取任务结果。`Result`属性的`Get`部分使当前线程等待任务完成并将异常传播到当前线程。在这种情况下，我们很容易在捕获块中捕获异常，但这个异常是一个名为`AggregateException`的包装异常。在这种情况下，它只包含一个异常，因为只有一个任务抛出了这个异常，并且可以通过访问`InnerException`属性来获取底层异常。
- en: The second example is mostly the same, but to access the task result, we use
    the `GetAwaiter` and `GetResult` methods. In this case, we do not have a wrapper
    exception because it is unwrapped by the TPL infrastructure. We have an original
    exception at once, which is quite comfortable if we have only one underlying task.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例基本上相同，但为了访问任务结果，我们使用`GetAwaiter`和`GetResult`方法。在这种情况下，我们没有包装异常，因为它是通过TPL基础设施解包的。我们立即有一个原始异常，如果我们只有一个底层任务，这将非常方便。
- en: The last example shows the situation where we have two task-throwing exceptions.
    To handle exceptions, we now use a continuation, which is executed only in case
    the antecedent task finishes with an exception. This behavior is achieved by providing
    a `TaskContinuationOptions.OnlyOnFaulted` option to a continuation. As a result,
    we have `AggregateException` being printed out, and we have two inner exceptions
    from both the tasks inside it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例显示了存在两个抛出异常的任务的情况。为了处理异常，我们现在使用一个延续，它仅在先决任务以异常结束的情况下执行。这种行为是通过向延续提供一个`TaskContinuationOptions.OnlyOnFaulted`选项来实现的。结果，我们打印出`AggregateException`，并且我们有两个来自它内部的内部异常。
- en: There's more…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As tasks may be connected in a very different manner, the resulting `AggregateException`
    exception might contain other aggregate exceptions inside along with the usual
    exceptions. Those inner aggregate exceptions might themselves contain other aggregate
    exceptions within them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务可能以非常不同的方式连接，结果`AggregateException`异常可能包含其他聚合异常，以及通常的异常。这些内部聚合异常可能自身包含其他聚合异常。
- en: To get rid of those wrappers, we should use the root aggregate exception's `Flatten`
    method. It will return a collection of all the inner exceptions of every child
    aggregate exception in the hierarchy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要去除这些包装器，我们应该使用根聚合异常的`Flatten`方法。它将返回所有子聚合异常的内部异常的集合。
- en: Running tasks in parallel
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行任务
- en: This recipe shows how to handle many asynchronous tasks that are running simultaneously.
    You will learn how to be notified effectively when all tasks are complete or any
    of the running tasks have to finish their work.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何处理同时运行的大量异步任务。你将学习如何在所有任务完成或任何正在运行的任务需要完成其工作的情况下有效地得到通知。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe8`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter4\Recipe8`找到。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To run tasks in parallel, perform the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要并行运行任务，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE22]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE23]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program starts, we create two tasks, and then, with the help of the
    `Task.WhenAll` method, we create a third task, which will be complete after all
    initial tasks are complete. The resulting task provides us with an answer array,
    where the first element holds the first task's result, the second element holds
    the second result, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，我们创建两个任务，然后，借助`Task.WhenAll`方法，我们创建第三个任务，该任务将在所有初始任务完成后完成。结果任务为我们提供了一个答案数组，其中第一个元素包含第一个任务的结果，第二个元素包含第二个结果，依此类推。
- en: Then, we create another list of tasks and wait for any of those tasks to be
    completed with the `Task.WhenAny` method. After we have one finished task, we
    remove it from the list and continue to wait for the other tasks to be complete
    until the list is empty. This method is useful to get the task completion progress
    or to use a timeout while running the tasks. For example, we wait for a number
    of tasks, and one of those tasks is counting a timeout. If this task is completed
    first, we just cancel all other tasks that are not completed yet.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建另一个任务列表，并使用`Task.WhenAny`方法等待这些任务中的任何一个完成。在我们有一个完成的任务后，我们将其从列表中删除，并继续等待其他任务完成，直到列表为空。此方法用于获取任务完成进度或在运行任务时使用超时。例如，我们等待一定数量的任务，其中有一个任务是计数超时。如果这个任务首先完成，我们就取消所有尚未完成的任务。
- en: Tweaking the execution of tasks with TaskScheduler
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`TaskScheduler`调整任务的执行
- en: This recipe describes another very important aspect of dealing with tasks, which
    is a proper way to work with a UI from the asynchronous code. You will learn what
    a task scheduler is, why it is so important, how it can harm our application,
    and how to use it to avoid errors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方描述了处理任务的一个重要方面，即从异步代码中正确处理UI的方式。你将学习什么是任务调度器，为什么它如此重要，它如何损害我们的应用程序，以及如何使用它来避免错误。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe9`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，你需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter4\Recipe9`中找到。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To tweak task execution with `TaskScheduler`, perform the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`TaskScheduler`调整任务执行，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# **WPF Application** project. This
    time, we will need a UI thread with a message loop, which is not available in
    console applications.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C# **WPF应用程序**项目。这次，我们需要一个具有消息循环的用户界面线程，这在控制台应用程序中是不可用的。
- en: 'In the `MainWindow.xaml` file, add the following markup inside a grid element
    (that is, between the `<Grid>` and `</Grid>` tags):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`文件中，在网格元素内（即在`<Grid>`和`</Grid>`标签之间）添加以下标记：
- en: '[PRE24]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `MainWindow.xaml.cs` file, use the following `using` directives:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml.cs`文件中，使用以下`using`指令：
- en: '[PRE25]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code snippet below the `MainWindow` constructor:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`构造函数下方添加以下代码片段：
- en: '[PRE26]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we meet many new things. First, we created a WPF application instead of
    a console application. It is necessary because we need a user interface thread
    with a message loop to demonstrate the different options of running a task asynchronously.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们遇到了许多新事物。首先，我们创建了一个WPF应用程序而不是控制台应用程序。这是必要的，因为我们需要一个具有消息循环的用户界面线程来演示异步运行任务的不同选项。
- en: There is a very important abstraction called `TaskScheduler`. This component
    is actually responsible for how the task will be executed. The default task scheduler
    puts tasks on a thread pool worker thread. This is the most common scenario; unsurprisingly,
    it is the default option in TPL. We also know how to run a task synchronously
    and how to attach them to the parent tasks to run those tasks together. Now, let's
    see what else we can do with tasks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常重要的抽象叫做`TaskScheduler`。这个组件实际上负责任务将如何执行。默认任务调度器将任务放在线程池工作线程上。这是最常见的情况；不出所料，它是TPL中的默认选项。我们也知道如何同步运行任务，以及如何将它们附加到父任务以一起运行这些任务。现在，让我们看看我们还可以用任务做什么。
- en: When the program starts, we create a window with three buttons. The first button
    invokes a synchronous task execution. The code is placed inside the `ButtonSync_Click`
    method. While the task runs, we are not even able to move the application window.
    The user interface gets totally frozen while the user interface thread is busy
    running the task and cannot respond to any message loop until the task is complete.
    This is quite a common bad practice for GUI Windows applications, and we need
    to find a way to work around this issue.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，我们创建了一个包含三个按钮的窗口。第一个按钮调用同步任务执行。代码放置在 `ButtonSync_Click` 方法内部。在任务运行期间，我们甚至无法移动应用程序窗口。当用户界面线程忙于运行任务且无法响应任何消息循环直到任务完成时，用户界面会完全冻结。这在
    GUI 窗口应用程序中是一种相当常见的坏习惯，我们需要找到一种方法来解决这个问题。
- en: The second problem is that we try to access the UI controls from another thread.
    Graphical User Interface controls have never been designed to be used from multiple
    threads, and to avoid possible errors, you are not allowed to access these components
    from a thread other than the one on which it was created. When we try to do that,
    we get an exception, and the exception message is printed on the main window in
    5 seconds.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，我们尝试从另一个线程访问 UI 控件。图形用户界面控件从未被设计为可以从多个线程使用，为了避免可能出现的错误，不允许从创建它的线程以外的线程访问这些组件。当我们尝试这样做时，我们会得到一个异常，并且异常消息将在
    5 秒内在主窗口上打印出来。
- en: To resolve the first problem, we try to run the task asynchronously. This is
    what the second button does; the code for this is placed inside the `ButtonAsync_Click`
    method. If you run the task in a debugger, you will see that it is placed on a
    thread pool, and in the end, we will get the same exception. However, the user
    interface remains responsive all the time the task runs. This is a good thing,
    but we need to get rid of the exception.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，我们尝试异步运行任务。这就是第二个按钮所做的事情；这个按钮的代码放置在 `ButtonAsync_Click` 方法内部。如果你在调试器中运行任务，你会看到它被放置在线程池中，最终我们将会得到相同的异常。然而，在整个任务运行期间，用户界面始终保持响应。这是一件好事，但我们需要消除异常。
- en: And we already did that! To output the error message, a continuation was provided
    with the `TaskScheduler.FromCurrentSynchronizationContext` option. If this wasn't
    done, we would not see the error message because we would get the same exception
    that took place inside the task. This option instructs the TPL infrastructure
    to put a code inside the continuation on the UI thread and run it asynchronously
    with the help of the UI thread message loop. This resolves the problem with accessing
    UI controls from another thread, but still keeps our UI responsive.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做到了！为了输出错误消息，我们使用 `TaskScheduler.FromCurrentSynchronizationContext` 选项提供了一个延续。如果没有这样做，我们就不会看到错误消息，因为我们可能会得到任务内部发生的相同异常。此选项指示
    TPL 基础设施将代码放在延续中，并在 UI 线程上运行，同时利用 UI 线程的消息循环异步执行。这解决了从另一个线程访问 UI 控件的问题，但仍然保持了我们的
    UI 响应。
- en: To check whether this is true, we press the last button that runs the code inside
    the `ButtonAsyncOK_Click` method. All that is different is that we provide the
    UI thread task scheduler to our task. After the task is complete, you will see
    that it runs on the UI thread in an asynchronous manner. The UI remains responsive,
    and it is even possible to press another button despite the wait cursor being
    active.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这是否正确，我们按下运行 `ButtonAsyncOK_Click` 方法内部代码的最后一个按钮。唯一不同的是，我们为任务提供了 UI 线程任务调度器。任务完成后，你会看到它是以异步方式在
    UI 线程上运行的。UI 保持响应，即使在等待光标激活的情况下，也可以按下另一个按钮。
- en: 'However, there are some tricks to use the UI thread in order to run tasks.
    If we go back to the synchronous task code and uncomment the line with getting
    the result with the UI thread task scheduler provided, we will never get any result.
    This is a classical deadlock situation: we are dispatching an operation in the
    queue of the UI thread, and the UI thread waits for this operation to complete,
    but as it waits, it cannot run the operation, which will never end (or even start).
    This will also happen if we call the `Wait` method on a task. To avoid deadlock,
    never use synchronous operations on a task scheduled to the UI thread; just use
    `ContinueWith` or `async`/`await` from C#.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些技巧可以用来在 UI 线程上运行任务。如果我们回到同步任务代码，并取消注释使用 UI 线程任务调度器获取结果的行，我们将永远不会得到任何结果。这是一个经典的死锁情况：我们在
    UI 线程的队列中调度了一个操作，UI 线程等待这个操作完成，但是当它等待时，它无法运行这个操作，它将永远不会结束（甚至开始）。如果我们对一个任务调用 `Wait`
    方法，也会发生这种情况。为了避免死锁，永远不要在调度到 UI 线程的任务上使用同步操作；只需使用 C# 中的 `ContinueWith` 或 `async`/`await`。
