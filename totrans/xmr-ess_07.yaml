- en: Chapter 7. Sharing with MvvmCross
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered the basic approaches to reusing code across
    projects and platforms. In this chapter, we will take the next step and look at
    how the use of design patterns and frameworks can increase the amount of code
    that can be reused. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to MvvmCross
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVVM design pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views, ViewModels, and commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation (ViewModel to ViewModel)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project organization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The startup process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `NationalParks.MvvmCross`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's more than a little ambitious to try to cover MvvmCross along with a working
    example in a single chapter. Our approach will be to introduce the core concepts
    at a high level and then dive in and create the national parks sample app using
    MvvmCross. This will give you a basic understanding of how to use the framework
    and the value associated with its use. With that in mind, let's get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MvvmCross
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MvvmCross is an open source framework that was created by Stuart Lodge. It is
    based on the **Model-View-ViewModel** (**MVVM**) design pattern and is designed
    to enhance code reuse across numerous platforms, including Xamarin.Android, Xamarin.iOS,
    Windows Phone, Windows Store, WPF, and Mac OS X. The MvvmCross project is hosted
    on GitHub and can be accessed at [https://github.com/MvvmCross/MvvmCross](https://github.com/MvvmCross/MvvmCross).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM pattern
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MVVM is a variation of the Model-View-Controller pattern. It separates logic
    traditionally placed in a **View** object into two distinct objects, one called
    **View** and the other called **ViewModel**. The View is responsible for providing
    the user interface and the ViewModel is responsible for the presentation logic.
    The presentation logic includes transforming data from the Model into a form that
    is suitable for the user interface to work with and mapping user interaction with
    the View into requests sent back to the Model. The following diagram depicts how
    the various objects in MVVM communicate:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![The MVVM pattern](img/0838OT_07_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'While MVVM presents a more complex implementation model, there are significant
    benefits of it, which are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: ViewModels and their interactions with Models can generally be tested using
    frameworks (such as NUnit) that are much easier than applications that combine
    the user interface and presentation layers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ViewModels can generally be reused across different user interface technologies
    and platforms
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These factors make the MVVM approach both flexible and powerful.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Views
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views in an MvvmCross app are implemented using platform-specific constructs.
    For iOS apps, Views are generally implemented as ViewControllers and XIB files.
    MvvmCross provides a set of base classes, such as `MvxViewContoller`, that iOS
    ViewControllers inherit from. Storyboards can also be used in conjunction with
    a custom presenter to create Views; we will briefly discuss this option in the
    section titled *Implementing the iOS user interface* later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: For Android apps, Views are generally implemented as `MvxActivity` or `MvxFragment`
    along with their associated layout files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: ViewModels
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ViewModels are classes that provide data and presentation logic to views in
    an app. Data is exposed to a View as properties on a ViewModel, and logic that
    can be invoked from a View is exposed as commands. ViewModels inherit from the
    `MvxViewModel` base class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commands are used in ViewModels to expose logic that can be invoked from the
    View in response to user interactions. The command architecture is based on the
    `ICommand` interface used in a number of Microsoft frameworks such as **Windows**
    **Presentation Foundation** (**WPF**) and Silverlight. MvvmCross provides `IMvxCommand`,
    which is an extension of `ICommand`, along with an implementation named `MvxCommand`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands are generally defined as properties on a ViewModel. For example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each command has an action method defined, which implements the logic to be
    invoked:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The commands must be initialized and the corresponding action method should
    be assigned:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Data binding
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data binding facilitates communication between the View and the ViewModel by
    establishing a two-way link that allows data to be exchanged. The data binding
    capabilities provided by MvvmCross are based on capabilities found in a number
    of Microsoft XAML-based UI frameworks such as WPF and Silverlight. The basic idea
    is that you would like to bind a property in a UI control, such as the **Text**
    property of an **EditText** control in an Android app to a property of a data
    object such as the **Description** property of **NationalPark**. The following
    diagram depicts this scenario:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Data binding](img/0838OT_07_06.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: The binding modes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four different binding modes that can be used for data binding:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**OneWay binding**: This mode tells the data binding framework to transfer
    values from the ViewModel to the View and transfer any updates to properties on
    the ViewModel to their bound View property.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OneWayToSource binding**: This mode tells the data binding framework to transfer
    values from the View to the ViewModel and transfer updates to View properties
    to their bound ViewModel property.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TwoWay binding**: This mode tells the data binding framework to transfer
    values in both directions between the ViewModel and View, and updates on either
    object will cause the other to be updated. This binding mode is useful when values
    are being edited.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OneTime binding**: This mode tells the data binding framework to transfer
    values from ViewModel to View when the binding is established; in this mode, updates
    to ViewModel properties are not monitored by the View.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The INotifyPropertyChanged interface
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `INotifyPropertyChanged` interface is an integral part of making data binding
    work effectively; it acts as a contract between the source object and the target
    object. As the name implies, it defines a contract that allows the source object
    to notify the target object when data has changed, thus allowing the target to
    take any necessary actions such as refreshing its display.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface consists of a single event—the `PropertyChanged` event—that the
    target object can subscribe to and that is triggered by the source if a property
    changes. The following sample demonstrates how to implement `INotifyPropertyChanged`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Binding specifications
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bindings can be specified in a couple of ways. For Android apps, bindings can
    be specified in layout files. The following example demonstrates how to bind the
    `Text` property of a `TextView` instance to the `Description` property in a `NationalPark`
    instance:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For iOS, binding must be accomplished using the binding API. `CreateBinding()`
    is a method than can be found on `MvxViewController`. The following example demonstrates
    how to bind the `Description` property to a `UILabel` instance:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Navigating between ViewModels
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigating between various screens within an app is an important capability.
    Within a MvvmCross app, this is implemented at the ViewModel level so that navigation
    logic can be reused. MvvmCross supports navigation between ViewModels through
    use of the `ShowViewModel<T>()` method inherited from `MvxNavigatingObject`, which
    is the base class for `MvxViewModel`. The following example demonstrates how to
    navigate to `DetailViewModel`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Passing parameters
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many situations, there is a need to pass information to the destination
    ViewModel. MvvmCross provides a number of ways to accomplish this. The primary
    method is to create a class that contains simple public properties and passes
    an instance of the class into `ShowViewModel<T>()`. The following example demonstrates
    how to define and use a `parameters` class during navigation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To receive and use parameters, the destination ViewModel implements an `Init()`
    method that accepts an instance of the `parameters` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Solution/project organization
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MvvmCross solutions are organized in a way that is similar to how we organized
    the PCL solution in [Chapter 6](ch06.html "Chapter 6. The Sharing Game"), *The
    Sharing Game.* Each MvvmCross solution will have a single core PCL project that
    houses the reusable code and a series of platform-specific projects that contain
    the various apps. The following diagram depicts the general structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Solution/project organization](img/0838OT_07_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: The startup process
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MvvmCross apps generally follow a standard startup sequence that is initiated
    by platform-specific code within each app. There are several classes that collaborate
    to accomplish the startup; some of these classes reside in the core project and
    some of them reside in the platform-specific projects. The following sections
    describe the responsibilities of each of the classes involved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: App.cs
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The core project has an `App` class that inherits from `MvxApplication`. The
    `App` class contains an override to the `Initialize()` method so that at a minimum,
    it can register the first ViewModel that should be presented when the app starts:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setup.cs
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Android and iOS projects have a `Setup` class that is responsible for creating
    the `App` object from the core project during the startup. This is accomplished
    by overriding the `CreateApp()` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For Android apps, `Setup` inherits from `MvxAndroidSetup`. For iOS apps, `Setup`
    inherits from `MvxTouchSetup`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The Android startup
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Android apps are kicked off using a special `Activity` splash screen that calls
    the `Setup` class and initiates the MvvmCross startup process. This is all done
    automatically for you; all you need to do is include the splash screen definition
    and make sure it is marked as the launch activity. The definition is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The iOS startup
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The iOS app startup is slightly less automated and is initiated from within
    the `FinishedLaunching()` method of `AppDelegate`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating NationalParks.MvvmCross
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have basic knowledge of the MvvmCross framework, let's put that
    knowledge to work and convert the `NationalParks` app to leverage the capabilities
    we just learned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MvvmCross core project
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by creating the core project. This project will contain all the
    code that will be shared between the iOS and Android app primarily in the form
    of ViewModels. The core project will be built as a Portable Class Library.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `NationalParks.Core`, perform the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, navigate to **File** | **New Solution**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **New Solution** dialog box, navigate to **C#** | **Portable Library**,
    enter `NationalParks.Core` for the project **Name** field, enter `NationalParks.MvvmCross`
    for the **Solution** field, and click on **OK**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the MvvmCross starter package to the project from NuGet. Select the `NationalParks.Core`
    project and navigate to **Project** | **Add Packages** from the main menu. Enter
    `MvvmCross starter` in the search field.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MvvmCross – Hot Tuna Starter Pack** entry and click on **Add Package**.![Creating
    the MvvmCross core project](img/0838OT_07_01.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A number of things were added to `NationalParks.Core` as a result of adding
    the package, and they are as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `packages.config` file, which contains a list of libraries (`dlls`) associated
    with the MvvmCross starter kit package. These entries are links to actual libraries
    in the `Packages` folder of the overall solution.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModels` folder with a sample ViewModel named `FirstViewModel`.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An `App` class in `App.cs`, which contains an `Initialize()` method that starts
    the MvvmCross app by calling `RegisterAppStart()` to start `FirstViewModel`. We
    will eventually be changing this to start the `MasterViewModel` class, which will
    be associated with a View that lists national parks.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MvvmCross Android app
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to create an Android app project in the same solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `NationalParks.Droid`, complete the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NationalParks.MvvmCross` solution, right-click on it, and navigate
    to **Add** | **New Project**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **New Project** dialog box, navigate to **C#** | **Android** | **Android
    Application**, enter `NationalParks.Droid` for the **Name** field, and click on
    **OK**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the MvvmCross starter kit package to the new project by selecting `NationalParks.Droid`
    and navigating to **Project** | **Add Packages** from the main menu.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A number of things were added to `NationalParks.Droid` as a result of adding
    the package, which are as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`packages.config`: This file contains a list of libraries (`dlls`) associated
    with the MvvmCross starter kit package. These entries are links to an actual library
    in the `Packages` folder of the overall solution, which contains the actual downloaded
    libraries.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstView` : This class is present in the `Views` folder, which corresponds
    to `FirstViewModel`, which was created in `NationalParks.Core`.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstView`: This layout is present in `Resources\layout`, which is used by
    the `FirstView` activity. This is a traditional Android layout file with the exception
    that it contains binding declarations in the `EditView` and `TextView` elements.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Setup`: This file inherits from `MvxAndroidSetup`. This class is responsible
    for creating an instance of the `App` class from the core project, which in turn
    displays the first ViewModel via a call to `RegisterAppStart()`.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SplashScreen`: This class inherits from `MvxSplashScreenActivity`. The `SplashScreen`
    class is marked as the main launcher activity and thus initializes the `MvvmCross`
    app with a call to `Setup.Initialize()`.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a reference to `NationalParks.Core` by selecting the `References` folder,
    right-click on it, select **Edit References**, select the **Projects** tab, check
    `NationalParks.Core`, and click on **OK**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove `MainActivity.cs` as it is no longer needed and will create a build error.
    This is because it is marked as the main launch and so is the new `SplashScreen`
    class. Also, remove the corresponding `Resources\layout\main.axml` layout file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app. The app will present `FirstViewModel`, which is linked to the corresponding
    `FirstView` instance with an `EditView` class, and `TextView` presents the same
    **Hello MvvmCross** text. As you edit the text in the `EditView` class, the `TextView`
    class is automatically updated by means of data binding. The following screenshot
    depicts what you should see:![Creating the MvvmCross Android app](img/0838OT_07_08.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reusing NationalParks.PortableData and NationalParks.IO
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start creating the Views and ViewModels for our app, we first need
    to bring in some code from our previous efforts that can be used to maintain parks.
    For this, we will simply reuse the `NationalParksData` singleton and the `FileHandler`
    classes that were created previously.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'To reuse the `NationalParksData` singleton and `FileHandler` classes, complete
    the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Copy `NationalParks.PortableData` and `NationalParks.IO` from the solution created
    in [Chapter 6](ch06.html "Chapter 6. The Sharing Game"), *The Sharing Game*, to
    the `NationalParks.MvvmCross` solution folder.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to `NationalParks.PortableData` in the `NationalParks.Droid`
    project.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder named `NationalParks.IO` in the `NationalParks.Droid` project
    and add a link to `FileHandler.cs` from the `NationalParks.IO` project. Recall
    that the `FileHandler` class cannot be contained in the Portable Class Library
    because it uses file IO APIs that cannot be references from a Portable Class Library.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the project. The project should compile cleanly now.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the INotifyPropertyChanged interface
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will be using data binding to bind UI controls to the `NationalPark` object
    and thus, we need to implement the `INotifyPropertyChanged` interface. This ensures
    that changes made to properties of a park are reported to the appropriate UI controls.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement `INotifyPropertyChanged`, complete the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Open `NationalPark.cs` in the `NationalParks.PortableData` project.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify that the `NationalPark` class implements `INotifyPropertyChanged` interface.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `INotifyPropertyChanged` interface, right-click on it, navigate
    to **Refactor** | **Implement interface**, and press *Enter*. Enter the following
    code snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add an `OnPropertyChanged()` method that can be called from each property setter
    method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update each property definition to call the setter in the same way as it is
    depicted for the `Name` property:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile the project. The project should compile cleanly. We are now ready to
    use the `NationalParksData` singleton in our new project, and it supports data
    binding.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the Android user interface
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we are ready to create the Views and ViewModels required for our app.
    The app we are creating will follow the same flow that was used in previous chapters:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: A master list view to view national parks
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detail view to view details of a specific park
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An edit view to edit a new or previously existing park
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process for creating views and ViewModels in an Android app generally consists
    of three different steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Create a ViewModel in the core project with the data and event handlers (commands)
    required to support the View.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Android layout with visual elements and data binding specifications.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Android activity, which corresponds to the ViewModel and displays
    the layout.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our case, this process will be slightly different because we will reuse some
    of our previous work, specifically, the layout files and the menu definitions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'To reuse layout files and menu definitions, perform the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Copy `Master.axml`, `Detail.axml`, and `Edit.axml` from the `Resources\layout`
    folder of the solution created in [Chapter 5](ch05.html "Chapter 5. Developing
    Your First Android App with Xamarin.Android"), *Developing Your First Android
    App with Xamarin.Android*, to the `Resources\layout` folder in the `NationalParks.Droid`
    project, and add them to the project by selecting the layout folder and navigating
    to **Add** | **Add Files**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `MasterMenu.xml`, `DetailMenu.xml`, and `EditMenu.xml` from the `Resources\menu`
    folder of the solution created in [Chapter 5](ch05.html "Chapter 5. Developing
    Your First Android App with Xamarin.Android"), *Developing Your First Android
    App with Xamarin.Android*, to the `Resources\menu` folder in the `NationalParks.Droid`
    project, and add them to the project by selecting the `menu` folder and navigating
    to **Add** | **Add Files**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the master list view
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to implement the first of our View/ViewModel combinations,
    which is the master list view.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Creating MasterViewModel
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step is to create a ViewModel and add a property that will provide
    data to the list view that displays national parks along with some initialization
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `MasterViewModel`, complete the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Select the `ViewModels` folder in `NationalParks.Core`, right-click on it, and
    navigate to **Add** | **New File**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New File** dialog box, navigate to **General** | **Empty Class**, enter
    `MasterViewModel` for the **Name** field, and click on **New**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class definition so that `MasterViewModel` inherits from `MvxViewModel`;
    you will also need to add a few `using` directives:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a property that is a list of `NationalPark` elements to `MasterViewModel`.
    This property will later be data-bound to a list view:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Override the `Start()` method on `MasterViewModel` to load the `_parks` collection
    with data from the `NationalParksData` singleton. You will need to add a `using`
    directive for the `NationalParks.PortableData` namespace again:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now need to modify the app startup sequence so that `MasterViewModel` is
    the first ViewModel that''s started. Open `App.cs` in `NationalParks.Core` and
    change the call to `RegisterAppStart()` to reference `MasterViewModel`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Updating the Master.axml layout
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Update `Master.axml` so that it can leverage the data binding capabilities provided
    by MvvmCross.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'To update `Master.axml`, complete the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Master.axml` and add a namespace definition to the top of the XML to
    include the `NationalParks.Droid` namespace:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This namespace definition is required in order to allow Android to resolve the
    MvvmCross-specific elements that will be specified.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the `ListView` element to a `Mvx.MvxListView` element:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a data binding specification to the `MvxListView` element, binding the
    `ItemsSource` property of the list view to the `Parks` property of `MasterViewModel`,
    as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a list item template attribute to the element definition. This layout controls
    the content of each item that will be displayed in the list view:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the `NationalParkItem` layout and provide `TextView` elements to display
    both the name and description of a park, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add data binding specifications to each of the TextView elements:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in this case, the context for data binding is an instance of an item
    in the collection that was bound to `MvxListView`, for this example, an instance
    of `NationalPark`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating the MasterView activity
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, create `MasterView`, which is an `MvxActivity` instance that corresponds
    with `MasterViewModel`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `MasterView`, complete the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Select the `ViewModels` folder in `NationalParks.Core`, right-click on it, navigate
    to **Add** | **New File**.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New File** dialog, navigate to **Android** | **Activity**, enter `MasterView`
    in the **Name** field, and select **New**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class specification so that it inherits from `MvxActivity`; you
    will also need to add a few `using` directives as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open `Setup.cs` and add code to initialize the file handler and path for the
    `NationalParksData` singleton to the `CreateApp()` method, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile and run the app; you will need to copy the `NationalParks.json` file
    to the device or emulator using the Android Device Monitor. All the parks in `NationalParks.json`
    should be displayed.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the detail view
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the master list view displaying national parks, we can focus
    on creating the detail view. We will follow the same steps for the detail view
    as the ones we just completed for the master view.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Creating DetailViewModel
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start creating `DetailViewModel` by using the following steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Following the same procedure as the one that was used to create `MasterViewModel`,
    create a new ViewModel named `DetailViewModel` in the `ViewModel` folder of `NationalParks.Core`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `NationalPark` property to support data binding for the view controls,
    as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a `Parameters` class that can be used to pass a park ID for the park
    that should be displayed. It''s convenient to create this class within the class
    definition of the ViewModel that the parameters are for:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement an `Init()` method that will accept an instance of the `Parameters`
    class and get the corresponding national park from `NationalParkData`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Updating the Detail.axml layout
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we will update the layout file. The main changes that need to be made
    are to add data binding specifications to the layout file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the `Detail.axml` layout, perform the following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Detail.axml` and add the project namespace to the XML file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add data binding specifications to each of the `TextView` elements that correspond
    to a national park property, as demonstrated for the park name:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Creating the DetailView activity
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, create the `MvxActivity` instance that will work with `DetailViewModel`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `DetailView`, perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Following the same procedure as the one that was used to create `MasterView`,
    create a new view named `DetailView` in the `Views` folder of `NationalParks.Droid`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `OnCreateOptionsMenu()` and `OnOptionsItemSelected()` methods
    so that our menus will be accessible. Copy the implementation of these methods
    from the solution created in [Chapter 6](ch06.html "Chapter 6. The Sharing Game"),
    *The Sharing Game*. Comment out the section in `OnOptionsItemSelect()` related
    to the `Edit` action for now; we will fill that in once the edit view is completed.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding navigation
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last step is to add navigation so that when an item is clicked on in `MvxListView`
    on `MasterView`, the park is displayed in the detail view. We will accomplish
    this using a `command` property and data binding.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'To add navigation, perform the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MasterViewModel` and add an `IMvxCommand` property; this will be used
    to handle a park that is being selected:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create an `Action` delegate that will be called when the `ParkSelected` command
    is executed, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initialize the `command` property in the constructor of `MasterViewModel`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, for the last step, add a data binding specification to `MvvListView` in
    `Master.axml` to bind the `ItemClick` event to the `ParkClicked` command on `MasterViewModel`,
    which we just created:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile and run the app. Clicking on a park in the list view should now navigate
    to the detail view, displaying the selected park.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the edit view
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now almost experts at implementing new Views and ViewModels. One last
    View to go is the edit view.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Creating EditViewModel
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like we did previously, we start with the ViewModel.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `EditViewModel`, complete the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Following the same process that was previously used in this chapter to create
    `EditViewModel`, add a data binding property and create a `Parameters` class for
    navigation.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement an `Init()` method that will accept an instance of the `Parameters`
    class and get the corresponding national park from `NationalParkData` in the case
    of editing an existing park or create a new instance if the user has chosen the
    `New` action. Inspect the parameters passed in to determine what the intent is:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Updating the Edit.axml layout
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Update `Edit.axml` to provide data binding specifications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: To update the `Edit.axml` layout, you first need to open `Edit.axml` and add
    the project namespace to the XML file. Then, add the data binding specifications
    to each of the `EditView` elements that correspond to a national park property.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EditView activity
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a new `MvxActivity` instance named `EditView` to will work with `EditViewModel`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `EditView`, perform the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Following the same procedure as the one that was used to create `DetailView`,
    create a new View named `EditView` in the `Views` folder of `NationalParks.Droid`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `OnCreateOptionsMenu()` and `OnOptionsItemSelected()` methods
    so that the `Done` action will accessible from the ActionBar. You can copy the
    implementation of these methods from the solution created in [Chapter 6](ch06.html
    "Chapter 6. The Sharing Game"), *The Sharing Game*. Change the implementation
    of `Done` to call the `Done` command on `EditViewModel`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding navigation
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add navigation to two places: when New (**+**) is clicked from `MasterView`
    and when **Edit** is clicked in `DetailView`. Let''s start with MasterView.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'To add navigation from `MasterViewModel`, complete the following steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MasterViewModel.cs` and add a `NewParkClicked` command property along
    with the handler for the command. Be sure to initialize the command in the constructor,
    as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that we do not pass in a parameter class into `ShowViewModel()`. This will
    cause a default instance to be created and passed in, which means that `ParkId`
    will be null. We will use this as a way to determine whether a new park should
    be created.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it''s time to hook the `NewParkClicked` command up to the `actionNew`
    menu item. We do not have a way to accomplish this using data binding, so we will
    resort to a more traditional approach—we will use the `OnOptionsItemSelected()`
    method. Add logic to invoke the `Execute()` method on `NewParkClicked`, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To add navigation from `DetailViewModel`, complete the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `DetailViewModel.cs` and add a `EditParkClicked` command property along
    with the handler for the command. Be sure to initialize the command in the constructor,
    as shown in the following code snippet:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that an instance of the `Parameters` class is created, initialized, and
    passed into the `ShowViewModel()` method. This instance will in turn be passed
    into the `Init()` method on `EditViewModel`.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialize the `command` property in the constructor for `MasterViewModel`,
    as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, update the `OnOptionsItemSelect()` method in `DetailView` to invoke the
    `DetailView.EditPark` command when the `Edit` action is selected:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Compile and run `NationalParks.Droid`. You should now have a fully functional
    app that has the ability to create new parks and edit the existing parks. Changes
    made to `EditView` should automatically be reflected in `MasterView` and `DetailView`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the MvvmCross iOS app
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of creating the Android app with MvvmCross provides a solid understanding
    of how the overall architecture works. Creating the iOS solution should be much
    easier for two reasons: first, we understand how to interact with MvvmCross and
    second, all the logic we have placed in `NationalParks.Core` is reusable, so that
    we just need to create the View portion of the app and the startup code.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `NationalParks.iOS`, complete the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NationalParks.MvvmCross` solution, right-click on it, and navigate
    to **Add** | **New Project**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **New Project** dialog, navigate to **C#** | **iOS** | **iPhone** |
    **Single View Application**, enter `NationalParks.iOS` in the Name field, and
    click on **OK**.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the MvvmCross starter kit package to the new project by selecting `NationalParks.iOS`
    and navigating to **Project** | **Add Packages** from the main menu.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A number of things were added to `NationalParks.iOS` as a result of adding
    the package. They are as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`packages.config`: This file contains a list of libraries associated with the
    MvvmCross starter kit package. These entries are links to an actual library in
    the `Packages` folder of the overall solution, which contains the actual downloaded
    libraries.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstView`: This class is placed in the `Views` folder, which corresponds
    to the `FirstViewModel` instance created in `NationalParks.Core`.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Setup`: This class inherits from `MvxTouchSetup`. This class is responsible
    for creating an instance of the `App` class from the core project, which in turn
    displays the first ViewModel via a call to `RegisterAppStart()`.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppDelegate.cs.txt`: This class contains the sample startup code, which should
    be placed in the actual `AppDelete.cs` file.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the iOS user interface
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are now ready to create the user interface for the iOS app. The good news
    is that we already have all the ViewModels implemented, so we can simply reuse
    them. The bad news is that we cannot easily reuse the storyboards from our previous
    work; MvvmCross apps generally use XIB files. One of the reasons for this is that
    storyboards are intended to provide navigation capabilities and an MvvmCross app
    delegates that responsibility to ViewModel and presenter. It is possible to use
    storyboards in combination with a custom presenter, but the remainder of this
    chapter will focus on using XIB files, as this is the more common use. The screen
    layouts as used in [Chapter 4](ch04.html "Chapter 4. Developing Your First iOS
    App with Xamarin.iOS"), *Developing Your First iOS App with Xamarin.iOS*, can
    be used as depicted in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the iOS user interface](img/0838OT_07_07.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: We are now ready to get started.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the master view
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first view we will work on is the master view.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the master view, complete the following steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `ViewController` class named `MasterView` by right-clicking on
    the `Views` folder of `NationalParks.iOS` and navigating to **Add** | **New File**
    | **iOS** | **iPhone View Controller**.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MasterView.xib` and arrange controls as seen in the screen layouts. Add
    outlets for each of the edit controls.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `MasterView.cs` and add the following boilerplate logic to deal with constraints
    on iOS 7, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Within the `ViewDidLoad()` method, add logic to create `MvxStandardTableViewSource`
    for `parksTableView`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that the example uses the `Subtitle` cell style and binds the national
    park name and description to the title and subtitle.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the binding logic to the `ViewDidShow()` method. In the previous step,
    we provided specifications for properties of `UITableViewCell` to properties in
    the binding context. In this step, we need to set the binding context for the
    `Parks` property on `MasterModelView`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Compile and run the app. All the parks in `NationalParks.json` should be displayed.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the detail view
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, implement the detail view using the following steps:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `ViewController` instance named `DetailView`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `DetailView.xib` and arrange controls as shown in the following code. Add
    outlets for each of the edit controls.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `DetailView.cs` and add the binding logic to the `ViewDidShow()` method:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Adding navigation
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add navigation from the master view so that when a park is selected, the detail
    view is displayed, showing the park.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'To add navigation, complete the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MasterView.cs`, create an event handler named `ParkSelected`, and assign
    it to the `SelectedItemChanged` event on `MvxStandardTableViewSource`, which was
    created in the `ViewDidLoad()` method:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Within the event handler, invoke the `ParkSelected` command on `MasterViewModel`,
    passing in the selected park:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Compile and run `NationalParks.iOS`. Selecting a park in the list view should
    now navigate you to the detail view, displaying the selected park.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the edit view
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now need to implement the last of the Views for the iOS app, which is the
    edit view.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the edit view, complete the following steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `ViewController` instance named `EditView`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `EditView.xib` and arrange controls as in the layout screenshots. Add outlets
    for each of the edit controls.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `EditView.cs` and add the data binding logic to the `ViewDidShow()` method.
    You should use the same approach to data binding as the approach used for the
    details view.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an event handler named `DoneClicked`, and within the event handler, invoke
    the `Done` command on `EditViewModel`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `ViewDidLoad()`, add `UIBarButtonItem` to `NavigationItem` for `EditView`,
    and assign the `DoneClicked` event handler to it, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Adding navigation
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add navigation to two places: when New (**+**) is clicked from the master view
    and when **Edit** is clicked on in the detail view. Let''s start with the master
    view.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'To add navigation to the master view, perform the following steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MasterView.cs` and add an event handler named `NewParkClicked`. In the
    event handler, invoke the `NewParkClicked` command on `MasterViewModel`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In `ViewDidLoad()`, add `UIBarButtonItem` to `NavigationItem` for `MasterView`
    and assign the `NewParkClicked` event handler to it:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To add navigation to the details view, perform the following steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `DetailView.cs` and add an event handler named `EditParkClicked`. In the
    event handler, invoke the `EditParkClicked` command on `DetailViewModel`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In `ViewDidLoad()`, add `UIBarButtonItem` to `NavigationItem` for `MasterView`,
    and assign the `EditParkClicked` event handler to it:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Refreshing the master view list
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One last detail that needs to be taken care of is to refresh the `UITableView`
    control on `MasterView` when items have been changed on `EditView`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'To refresh the master view list, perform the following steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MasterView.cs` and call `ReloadData()` on `parksTableView` within the
    `ViewDidAppear()` method of `MasterView`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Compile and run `NationalParks.iOS`. You should now have a fully functional
    app that has the ability to create new parks and edit existing parks. Changes
    made to `EditView` should automatically be reflected in `MasterView` and `DetailVIew`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Considering the pros and cons
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After completing our work, we now have the basis to make some fundamental observations.
    Let''s start with the pros:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: MvvmCross definitely increases the amount of code that can be reused across
    platforms. The ViewModels house the data required by the View, the logic required
    to obtain and transform the data in preparation for viewing, and the logic triggered
    by user interactions in the form of commands. In our sample app, the ViewModels
    were somewhat simple; however, the more complex the app, the more reuse will likely
    be gained.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As MvvmCross relies on the use of each platform's native UI frameworks, each
    app has a native look and feel and we have a natural layer that implements platform-specific
    logic when required.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data binding capabilities of MvvmCross also eliminate a great deal of tedious
    code that would otherwise have to be written.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these positives are not necessarily free; let''s look at some cons:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The first con is complexity; you have to learn another framework on top of Xamarin,
    Android, and iOS.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some ways, MvvmCross forces you to align the way your apps work across platforms
    to achieve the most reuse. As the presentation logic is contained in the ViewModels,
    the views are coerced into aligning with them. The more your UI deviates across
    platforms; the less likely it will be that you can actually reuse ViewModels.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these things in mind, I would definitely consider using MvvmCross for a
    cross-platform mobile project. Yes, you need to learn an addition framework and
    yes, you will likely have to align the way some of the apps are laid out, but
    I think MvvmCross provides enough value and flexibility to make these issues workable.
    I'm a big fan of reuse and MvvmCross definitely pushes reuse to the next level.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，我肯定会考虑在跨平台移动项目中使用 MvvmCross。是的，你需要学习一个额外的框架，而且你很可能需要调整一些应用布局的方式，但我认为
    MvvmCross 提供了足够的价值和灵活性，使得这些问题变得可行。我是一个重用的大粉丝，MvvmCross 确实将重用提升到了新的水平。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the high-level concepts of MvvmCross and worked
    through a practical exercise in order to convert the national parks apps to use
    the MvvmCross framework and the increase code reuse. In the next chapter, we will
    follow a similar approach to exploring the Xamarin.Forms framework in order to
    evaluate how its use can affect code reuse.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 MvvmCross 的高级概念，并通过一个实际练习将国家公园应用转换为使用 MvvmCross 框架并增加代码重用。在下一章中，我们将采用类似的方法来探索
    Xamarin.Forms 框架，以评估其使用如何影响代码重用。
