<html><head></head><body>
<div><div><h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor072"/>Chapter 4</em>: User Interface Responsiveness and Threading</h1>
<p>One of the main reasons to introduce threading concepts to a project is the desire to keep an application responsive to user input. Accessing data through services, a database, or the filesystem can introduce delays, and the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) should remain responsive. The real-world examples in this chapter will provide valuable options for ensuring UI responsiveness in your .NET client applications.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Leveraging background threads</li>
<li>Using the thread pool</li>
<li>Updating the UI thread without exceptions</li>
</ul>
<p>By the end of this chapter, you will understand how to take advantage of parallelism and concurrency to keep your client applications responsive and performant.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows users:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04</a>.</p>
<p>Let’s get started by discussing how background threads can be used to perform non-critical tasks without impacting UI performance.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Leveraging background threads</h1>
<p>In <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, we learned how to create background threads and discussed some of their uses. Background threads have a lower priority than the primary <a id="_idIndexMarker193"/>thread of the process and other thread pool threads. In addition, active background threads will not prevent the user or the system from terminating the application.</p>
<p>This means that background threads are perfect for tasks such as the following:</p>
<ul>
<li>Writing log and analytics data</li>
<li>Monitoring network or filesystem resources</li>
<li>Reading data into the application</li>
</ul>
<p>Do not use background threads for critical application operations such as the following:</p>
<ul>
<li>Saving application state</li>
<li>Performing database transactions</li>
<li>Application data processing</li>
</ul>
<p>A good rule to follow when deciding whether some work can be processed by a background thread is to ask yourself whether abruptly interrupting the work to close the application would risk the data integrity of the system. So, how do you know whether you are creating a background or foreground thread?</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Which threads are background threads?</h2>
<p>We have learned that a thread<a id="_idIndexMarker194"/> can be explicitly created as a background thread by setting its <code>IsBackground</code> property to <code>true</code>. All other threads created by calling a <code>Thread</code> constructor are foreground threads by default. The application’s primary (or main) thread is a foreground thread. All <code>ThreadPool</code> threads are background threads. This includes all asynchronous operations started by the <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>).</p>
<p>So, if all task-based operations such as <code>async</code> methods are executing on background threads, should you avoid using them for saving important application data? Will .NET allow your application to close while these <code>async</code> / <code>await</code> operations are in process? If there is a foreground thread awaiting an <code>async</code> operation, the application will not terminate until the <a id="_idIndexMarker195"/>operation is complete. If you do not use <code>await</code>, or you start an operation on the thread pool with <code>Task.Run</code>, it is possible for the application to terminate normally before the actions have finished.</p>
<p>The great thing about using <code>await</code> with your <code>async</code> methods is the flexibility you gain in controlling the flow of execution while keeping the UI responsive. Let’s discuss <code>async</code> and <code>await</code> in client applications and create an example of a <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>) application that loads data from multiple sources.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Using async, await, tasks, and WhenAll</h2>
<p>Using <code>async</code> and <code>await</code> in your code is the <a id="_idIndexMarker196"/>easiest way to introduce some background<a id="_idIndexMarker197"/> work using <code>ThreadPool</code>. An asynchronous method must be decorated with the <code>async</code> keyword and will return a <code>System.Threading.Tasks.Task</code> type instead of a <code>void</code> return. </p>
<p class="callout-heading">Note</p>
<p class="callout"><code>Async</code> methods return <code>Task</code> so the calling <a id="_idIndexMarker198"/>method can await the result of the method. If you were to create an <code>async</code> method with a <code>void</code> return type, it could not be awaited, and the calling code would continue processing subsequent code before the <code>async</code> method had completed. It is important to note that only event handlers should be declared as <code>async</code> with a <code>void</code> return type.</p>
<p>If the method returns <code>string</code>, then the <code>async</code> equivalent will return a <code>Task&lt;string&gt;</code> generic type. Let’s look at examples of each:</p>
<pre class="source-code">private async Task ProcessDataAsync()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    // Process data here</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private async Task&lt;string&gt; GetStringDataAsync()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    string stringData;</pre>
<pre class="source-code">    // Build string here</pre>
<pre class="source-code">    ...</pre>
<pre class="source-code">    return stringData;</pre>
<pre class="source-code">}</pre>
<p>When you call an <code>async</code> method, there are<a id="_idIndexMarker199"/> two common patterns to follow. </p>
<ul>
<li>First, you can await the call and set the return type to a variable of the type returned inside the method:<pre>await ProcessDataAsync();
string data = await GetStringDataAsync();</pre></li>
<li>The second option is to use <code>Task</code> variables when invoking the methods and await them later:<pre>Task dataTask = ProcessDataAsync();
Task&lt;string&gt; stringDataTask = GetStringDataAsync();
DoSomeOtherSynchronousWork();
string data = await stringDataTask;
await dataTask;</pre></li>
</ul>
<p>Using this second method, the application can execute some synchronous work while the two <code>async</code> methods continue to run on background threads. Once the synchronous work is complete, the application will await the two <code>async</code> methods.</p>
<p>Let’s put our <code>async</code> knowledge to work in a more realistic sample project. In this example, we will create a new Windows client application <a id="_idIndexMarker200"/>with <code>async</code> methods. We will simulate slow service calls to fetch the data in these methods by injecting non-blocking delays with <code>Task.Delay</code>. Each method will take several seconds to return its data, but the UI will remain responsive to user input:</p>
<ol>
<li>Start by creating a new WPF project in Visual Studio. Name the project <code>AwaitWithWpf</code>.</li>
<li>Add two new classes to the project named <code>Order</code> and <code>MainViewModel</code>. Your solution should now look something like this:</li>
</ol>
<div><div><img alt="Figure 4.1 – The AwaitWithWpf solution in Visual Studio " height="324" src="img/Figure_4.1_B18552.jpg" width="913"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The AwaitWithWpf solution in Visual Studio</p>
<ol>
<li value="3">Next, open <code>MVVM Toolkit</code> on the <code>Microsoft.Toolkit.Mvvm</code> package to your project:</li>
</ol>
<div><div><img alt="Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project " height="114" src="img/Figure_4.2_B18552.jpg" width="1341"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project</p>
<p>We will be using <a id="_idIndexMarker202"/>the <code>MainViewModel</code> class.</p>
<p class="callout-heading">Note</p>
<p class="callout">The MVVM Toolkit is an open source MVVM library that is part of the <strong class="bold">Windows Community Toolkit</strong> maintained by Microsoft. If you are unfamiliar with the MVVM pattern or the <a id="_idIndexMarker203"/>MVVM Toolkit, you can read <a id="_idIndexMarker204"/>more about them on Microsoft Docs: <a href="https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction">https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction</a>.</p>
<ol>
<li value="4">Now, open the <code>Order</code> class and add the following implementation:<pre>public class Order
{
    public int OrderId { get; set; }
    public string? CustomerName { get; set; }
    public bool IsArchived { get; set; }
}</pre></li>
</ol>
<p>This will provide a few properties to display for each order when the order list is populated on <code>MainWindow</code>.</p>
<ol>
<li value="5">Now we will start to <a id="_idIndexMarker205"/>build the <code>MainViewModel</code> implementation. The first step is to add a list of orders to bind to the UI and a command to execute when we want to load the orders:<pre>public class MainViewModel : ObservableObject
{
    private ObservableCollection&lt;Order&gt; _orders = 
        new();
    public MainViewModel()
    {
        LoadOrderDataCommand = new AsyncRelayCommand
            (LoadOrderDataAsync);
    }
    public ICommand LoadOrderDataCommand { get; set; }
    public ObservableCollection&lt;Order&gt; Orders
    {
        get { return _orders; }
        set
        {
            SetProperty(ref _orders, value);
        }
    }
    private async Task LoadOrderDataAsync()
    {
        // TODO – Add code to load orders
    }
}</pre></li>
</ol>
<p>Let’s review a few of the properties of the <code>MainViewModel</code> class before moving on to the next step:</p>
<ul>
<li>The <code>MainViewModel</code> class inherits from the <code>ObservableObject</code> type provided by the MVVM Toolkit. </li>
<li>This base class implements the <code>INotifyPropertyChanged</code> interface, which is used by WPF data <a id="_idIndexMarker206"/>binding to notify the UI when data-bound property values change.</li>
<li>The <code>Orders</code> property will provide the list of orders to the UI through WPF data binding. Calling <code>SetProperty</code> on the <code>ObservableObject</code> base sets the value of the <code>_orders</code> backing variable and triggers a property change notification.</li>
<li>The <code>LoadOrderDataCommand</code> property will be executed by a button on <code>MainWindow</code>. In the constructor, the property is being initialized as a new <code>AsyncRelayCommand</code> that calls <code>LoadOrderDataAsync</code> when the command is invoked by the UI.</li>
</ul>
<ol>
<li value="6">Don’t forget to add the necessary <code>using</code> statements to the class:<pre>using Microsoft.Toolkit.Mvvm.ComponentModel;
using Microsoft.Toolkit.Mvvm.Input;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;</pre></li>
<li>Next, let’s create two <code>async</code> methods to load order data. One will create current orders and the<a id="_idIndexMarker207"/> other will create a list of archived orders. These are differentiated by the <code>IsArchived</code> property on the <code>Order</code> class. Each method uses <code>Task.Delay</code> to simulate a service call across a slow internet or network connection:<pre>private async Task&lt;List&lt;Order&gt;&gt; GetCurrentOrders
    Async()
{
    var orders = new List&lt;Order&gt;();
    await Task.Delay(4000);
    orders.Add(new Order { OrderId = 55, CustomerName 
        = "Tony", IsArchived = false });
    orders.Add(new Order { OrderId = 56, CustomerName 
        = "Peggy", IsArchived = false });
    orders.Add(new Order { OrderId = 60, CustomerName 
        = "Carol", IsArchived = false });
    orders.Add(new Order { OrderId = 62, CustomerName 
        = "Bruce", IsArchived = false });
    return orders;
}
private async Task&lt;List&lt;Order&gt;&gt; GetArchivedOrders
    Async()
{
    var orders = new List&lt;Order&gt;();
    await Task.Delay(5000);
    orders.Add(new Order { OrderId = 3, CustomerName = 
        "Howard", IsArchived = true });
    orders.Add(new Order { OrderId = 18, CustomerName 
        = "Steve", IsArchived = true });
    orders.Add(new Order { OrderId = 19, CustomerName 
        = "Peter", IsArchived = true });
    orders.Add(new Order { OrderId = 21, CustomerName 
        = "Mary", IsArchived = true });
    orders.Add(new Order { OrderId = 25, CustomerName 
        = "Gwen", IsArchived = true });
    orders.Add(new Order { OrderId = 34, CustomerName 
        = "Harry", IsArchived = true });
    orders.Add(new Order { OrderId = 36, CustomerName 
        = "Bob", IsArchived = true });
    orders.Add(new Order { OrderId = 49, CustomerName 
        = "Bob", IsArchived = true });
    return orders;
}</pre></li>
<li>Now we need to create a synchronous <code>ProcessOrders</code> method that combines the two lists of <a id="_idIndexMarker208"/>orders and updates the <code>Orders</code> property with the full dataset:<pre>private void ProcessOrders(List&lt;Order&gt; currentOrders, 
    List&lt;Order&gt; archivedOrders)
{
    List&lt;Order&gt; allOrders = new(currentOrders);
    allOrders.AddRange(archivedOrders);
    Orders = new ObservableCollection&lt;Order&gt;
        (allOrders);
}</pre></li>
<li>The final step in building the <code>MainViewModel</code> class is the most important. Add the following <a id="_idIndexMarker209"/>implementation to the <code>LoadOrderDataAsync</code> method:<pre>private async Task LoadOrderDataAsync()
{
    Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = 
        GetCurrentOrdersAsync();
    Task&lt;List&lt;Order&gt;&gt; archivedOrdersTask = 
        GetArchivedOrdersAsync();
    List&lt;Order&gt;[] results = await Task.WhenAll(new 
        Task&lt;List&lt;Order&gt;&gt;[] {
        currentOrdersTask, archivedOrdersTask
    }).ConfigureAwait(false);
    ProcessOrders(results[0], results[1]);
}</pre></li>
</ol>
<p>This method calls <code>GetCurrentOrdersAsync</code> and <code>GetArchivedOrdersAsync</code> and captures each in a <code>Task&lt;List&lt;Order&gt;&gt;</code> variable. You could simply await each call and store the returned orders in <code>List&lt;Order&gt;</code> variables. However, that would mean the second method would not start executing until the first one completed. By awaiting <code>Task.WhenAll</code> instead, the <a id="_idIndexMarker210"/>methods can execute in parallel on background threads.</p>
<p>If your methods all return<a id="_idIndexMarker211"/> the same data type, you can capture the results of <code>Task.WhenAll</code> in an array of the return type. In our case, we are receiving the two lists of orders in an array of <code>List&lt;Order&gt;</code> and passing the two array values to <code>ProcessOrders</code>.</p>
<ol>
<li value="10">Now, let’s move on to the <code>MainWindow.xaml.cs</code> code-behind file. Add the following code to set <code>DataContext</code> of <code>MainWindow</code> in the constructor after the call to <code>InitializeComponent</code>:<pre>public MainWindow()
{
    InitializeComponent();
<strong class="bold">    var vm = new MainViewModel();</strong>
<strong class="bold">    DataContext = vm;</strong>
}</pre></li>
</ol>
<p><code>DataContext</code> is the source for all <code>Binding</code> references in the XAML for <code>MainWindow</code>. We will create the XAML for our UI in the next step.</p>
<ol>
<li value="11">The last file to update is <code>MainWindow.xaml</code>. Open the XAML file and start by adding two rows to <code>Grid</code>. The first row will contain another <code>Grid</code> containing <code>Button</code> and <code>TextBox</code>. The second row will contain <code>ListView</code> to display the list of orders. We’ll create a template for the orders in a moment:<pre>&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="*"/&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid Grid.Row="0" Margin="4"&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="Auto"/&gt;
            &lt;ColumnDefinition Width="*"/&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Button Content="Load Data" Grid.Column="0" 
            Margin="2" Width="200"
<strong class="bold">        Command="{Binding Path=LoadOrderData</strong>
<strong class="bold">            Command}"</strong>/&gt;
        &lt;TextBox Grid.Column="1" Margin="2"/&gt;
    &lt;/Grid&gt;
    &lt;ListView Grid.Row="1" <strong class="bold">ItemsSource="{Binding </strong>
<strong class="bold">        Path=Orders}"</strong> Margin="4"&gt;
    &lt;/ListView&gt;
&lt;/Grid&gt;</pre></li>
</ol>
<p>I have highlighted the two <a id="_idIndexMarker212"/>data binding instances in the XAML markup. The <code>Command</code> of <code>Button</code> is bound to the <code>LoadOrderDataCommand</code> property, and <code>ItemsSource</code> of <code>ListView</code> is bound to the <code>Orders</code> property. Setting <code>ItemsSource</code> will make the properties of the <code>Order</code> class available to the members of <code>ListView.ItemTemplate</code>.</p>
<ol>
<li value="12">Let’s add <code>ItemTemplate</code> to <code>ListView</code> next. Defining <code>DataTemplate</code> within <code>ItemTemplate</code> defines<a id="_idIndexMarker213"/> the structure of each item within <code>ListView</code>:<pre>&lt;ListView Grid.Row="1" ItemsSource="{Binding 
    Path=Orders}" Margin="4"&gt;
    &lt;ListView.ItemTemplate&gt;
        &lt;DataTemplate&gt;
            &lt;StackPanel Margin="2"&gt;
                &lt;StackPanel Orientation="Horizontal"&gt;
                    &lt;TextBlock Text="Order Id:"
                               Margin="2,2,0,2"
                               Width="100"/&gt;
                    &lt;TextBox IsReadOnly="True"
                           Width="200"
                           Text="{Binding 
                           Path=OrderId}" Margin="2"/&gt;
                &lt;/StackPanel&gt;
                &lt;StackPanel Orientation="Horizontal"&gt;
                    &lt;TextBlock Text="Customer:"
                               Margin="2,2,0,2"
                               Width="100"/&gt;
                    &lt;TextBox IsReadOnly="True"
                             Width="200"
                             Text="{Binding 
                             Path=CustomerName}" 
                             Margin="2"/&gt;
                &lt;/StackPanel&gt;
                &lt;StackPanel Orientation="Horizontal"&gt;
                    &lt;TextBlock Text="Archived:"
                               Margin="2,2,0,2"
                               Width="100"/&gt;
                    &lt;TextBox IsReadOnly="True"
                             Width="200"
                             Text="{Binding 
                             Path=IsArchived}"
                              Margin="2"/&gt;
                &lt;/StackPanel&gt;
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ListView.ItemTemplate&gt;
&lt;/ListView&gt;</pre></li>
</ol>
<p>Each <code>Order</code> instance will render as a <code>StackPanel</code> containing three horizontally aligned <code>StackPanel</code> elements, displaying labels and values for the <code>OrderId</code>, <code>CustomerName</code>, and <code>IsArchived</code> data-bound properties.</p>
<ol>
<li value="13">We’re ready to run the <a id="_idIndexMarker214"/>application and see how things work. After the program starts, click the <code>ListView</code>. While you wait, try typing some text into the box to the right of the <code>async</code>/<code>await</code> and the <code>Task.WhenAll</code> method. Once the data has finished loading, you should see a list of twelve orders in the scrollable list:</li>
</ol>
<div><div><img alt="Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application " height="714" src="img/Figure_4.3_B18552.jpg" width="1262"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application</p>
<p>In a real production application, the implementations of the two <code>async</code> methods would be replaced by service calls to fetch data from a database or web services. Regardless of how long it takes to return and <a id="_idIndexMarker216"/>populate the data, other parts of the UI will remain responsive to user input. One change you would want to make is adding an indicator to the UI to inform the user that data is being loaded. You should also disable the <code>LoadOrderDataAsync</code>.</p>
<p>The example illustrates the benefits of using <code>async</code> and <code>await</code> in a Windows application. These <code>async</code> calls are using <code>ThreadPool</code> within the TPL. Let’s look at some other ways to leverage <code>ThreadPool</code> in a Windows application.</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Using the thread pool</h1>
<p>There are other ways to use <code>ThreadPool</code> threads in a .NET application. Let’s discuss a situation where you want to accomplish the<a id="_idIndexMarker217"/> same result that was achieved with <code>async</code> and <code>await</code> in the previous example, but the methods to fetch the order data are not marked as <code>async</code>. One option is to update the methods to be <code>async</code>. If that code is not within your control to change, you have some other options available.</p>
<p>The <code>ThreadPool</code> class has a method called <code>QueueUserWorkItem</code>. This method accepts a method to call and queues it for execution on the thread pool. We could use it with our project like this:</p>
<pre class="source-code">ThreadPool.QueueUserWorkItem(GetCurrentOrders);</pre>
<p>There are a few problems with using this method. The primary issue is that there is no return value to get the list of orders from the method call. You could work around this issue with some wrapper methods that update a shared thread-safe collection such as the <code>BlockingCollection</code>. That isn’t a great design, and there is a better option.</p>
<p>The <code>QueueUserWorkItem</code> method was<a id="_idIndexMarker218"/> more commonly used before the introduction of the TPL. In today’s task-based world, you can use <code>Task.Run</code> to execute a synchronous method as <code>async</code>. Let’s update our WPF project to use <code>Task.Run</code>:</p>
<ol>
<li value="1">The only file that needs to be modified to use <code>Task.Run</code> is <code>MainViewModel</code>. Start by updating <code>GetCurrentOrdersAsync</code> and <code>GetArchivedOrdersAsync</code> to no longer be <code>async</code> methods. They should also be renamed as <code>GetCurrentOrders</code> and <code>GetArchivedOrders</code> so consumers are aware that they are not <code>async</code> methods:<pre><strong class="bold">private List&lt;Order&gt; GetCurrentOrders()</strong>
{
    var orders = new List&lt;Order&gt;();
    <strong class="bold">Thread.Sleep(4000);</strong>
    orders.Add(new Order { OrderId = 55, CustomerName 
        = "Tony", IsArchived = false });
    orders.Add(new Order { OrderId = 56, CustomerName 
        = "Peggy", IsArchived = false });
    orders.Add(new Order { OrderId = 60, CustomerName 
        = "Carol", IsArchived = false });
    orders.Add(new Order { OrderId = 62, CustomerName 
        = "Bruce", IsArchived = false });
    return orders;
}
<strong class="bold">private List&lt;Order&gt; GetArchivedOrders()</strong>
{
    var orders = new List&lt;Order&gt;();
    <strong class="bold">Thread.Sleep(5000);</strong>
    orders.Add(new Order { OrderId = 3, CustomerName = 
        "Howard", IsArchived = true });
    orders.Add(new Order { OrderId = 18, CustomerName 
        = "Steve", IsArchived = true });
    orders.Add(new Order { OrderId = 19, CustomerName 
        = "Peter", IsArchived = true });
    orders.Add(new Order { OrderId = 21, CustomerName 
        = "Mary", IsArchived = true });
    orders.Add(new Order { OrderId = 25, CustomerName 
        = "Gwen", IsArchived = true });
    orders.Add(new Order { OrderId = 34, CustomerName 
        = "Harry", IsArchived = true });
    orders.Add(new Order { OrderId = 36, CustomerName 
        = "Bob", IsArchived = true });
    orders.Add(new Order { OrderId = 49, CustomerName 
        = "Bob", IsArchived = true });
    return orders;
}</pre></li>
</ol>
<p>The changes are minimal, and I have highlighted them in the preceding source code. The <code>async</code> modifier has been removed from the method declarations, the methods have been renamed and they no longer return tasks, and <code>Task.Delay</code> in each <a id="_idIndexMarker219"/>method has been updated to <code>Thread.Sleep</code>.</p>
<ol>
<li value="2">Next, we will update the <code>LoadOrderDataAsync</code> method to call the synchronous methods with <code>Task.Run</code>:<pre>private async Task LoadOrderDataAsync()
{
    Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = 
        <strong class="bold">Task.Run(GetCurrentOrders)</strong>;
    Task&lt;List&lt;Order&gt;&gt; archivedOrdersTask = 
        <strong class="bold">Task.Run(GetArchivedOrders)</strong>;
    List&lt;Order&gt;[] results = await Task.WhenAll(new 
        Task&lt;List&lt;Order&gt;&gt;[] {
        currentOrdersTask, archivedOrdersTask
    }).ConfigureAwait(false);
    ProcessOrders(results[0], results[1]);
}</pre></li>
</ol>
<p>No other changes are necessary. <code>Task.Run</code> will return the same <code>Task&lt;List&lt;Order&gt;&gt;</code> type, which can still be used with <code>Task.WhenAll</code> to wait for their completion.</p>
<ol>
<li value="3">Run the program, and it should work exactly as it did before. The UI remains responsive while the order data is loading.</li>
</ol>
<p>This is an excellent way to start incorporating <code>async</code> and <code>await</code> into existing code, but always use caution when adding threading to your applications. In this application, the two methods being called do not access any shared data. So, there was no need to think about thread safety. If these methods were updating a private collection of orders, you would need to introduce a locking mechanism or use a thread-safe collection for the orders.</p>
<p>Before we move on to a discussion of the UI thread, there is one other <code>Task</code> method to discuss. The <code>Task.Factory.StartNew</code> method is similar in use to <code>Task.Run</code>. In fact, you can use them in the <a id="_idIndexMarker220"/>same way. This code uses <code>Task.Run</code> to get a <code>Task</code> with the current orders:</p>
<pre class="source-code">Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = Task.Run</pre>
<pre class="source-code">     (GetCurrentOrders);</pre>
<p>This code does the same thing with <code>Task.Factory.StartNew</code>:</p>
<pre class="source-code">Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = Task.Factory.StartNew</pre>
<pre class="source-code">     (GetCurrentOrders);</pre>
<p>In this case, you should use <code>Task.Run</code>. It is a newer method and is simply a shortcut meant to simplify the most common use cases. The <code>Task.Factory.StartNew</code> method has some additional overloads for specific uses. This example uses <code>StartNew</code> to call <code>GetCurrentOrders</code> with some optional parameters:</p>
<pre class="source-code">Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = </pre>
<pre class="source-code">    Task.Factory.StartNew(GetCurrentOrders, </pre>
<pre class="source-code">    CancellationToken.None, </pre>
<pre class="source-code">    <strong class="bold">TaskCreationOptions.AttachedToParent</strong>, </pre>
<pre class="source-code">    TaskScheduler.Default);</pre>
<p>The interesting option we have provided here is <code>TaskCreationOptions.AttachedToParent</code>. What this does is it links the task completion of the calling method to that of the child, <code>GetCurrentOrders</code>. The default behavior is for their completions to be unlinked. For a complete list of available overloads and their uses, you can review Microsoft Docs here: <a href="https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew">https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout"><em class="italic">Stephen Toub</em> of the .NET team has a blog post where he discusses <code>Task.Run</code> versus <code>Task.Factory.StartNew</code> and why you might want to choose each option. You can read his post on the <em class="italic">.NET Parallel Programming</em> blog here: <a href="https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/">https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/</a>.</p>
<p>Now, let’s move on to discuss<a id="_idIndexMarker221"/> when you will need to write code to explicitly update the UI thread from a background thread.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Updating the UI thread without exceptions</h1>
<p>When working with managed threading in .NET applications, there are many pitfalls that developers must learn to avoid. One<a id="_idIndexMarker222"/> of the common mistakes developers make is writing code that updates a UI control in a Windows application from a non-UI thread. This kind of error will not be detected by the compiler. Developers will receive a runtime error indicating that a control created on the main thread cannot be modified on another thread.</p>
<p>So, how do you avoid these runtime errors? The best way to avoid them is by not updating UI controls from background threads at all. WPF helps avoid the problem with the MVVM pattern and data binding. Binding updates are automatically marshaled to the UI thread by .NET. You can safely update properties in your <code>ViewModel</code> classes from a background thread without causing errors at runtime.</p>
<p>If you are updating UI controls directly in your code, either in a WinForms application or in the code-behind file of a WPF control, you can use an <code>Invoke</code> call to <em class="italic">push</em> the execution to the main thread. The implementation is slightly different between WinForms and WPF. Let’s start with a WPF example. If you have a method performing some work on a background thread, and it needs to update the <code>Text</code> property of a <code>TextBox</code> on a WPF window, you could wrap the code in an action:</p>
<pre class="source-code">Application.Current.Dispatcher.Invoke(new Action(() =&gt; { </pre>
<pre class="source-code">    usernameTextBox.Text = "John Doe";</pre>
<pre class="source-code">}));</pre>
<p><code>Dispatcher.Invoke</code> will push the execution to the main thread. Keep in mind that if the main thread is busy with other work, your background thread will wait here for this action to complete. If your background worker wants to fire and forget this action, you can use <code>Dispatcher.BeginInvoke</code> instead.</p>
<p>Let’s assume we want to update <code>usernameTextBox</code>, but this time, we are working with a WinForms project. The same invocation can be accomplished by using <code>Form</code> or <code>UserControl</code> executing the code. This<a id="_idIndexMarker223"/> example is a WinForms application with two buttons. Clicking one button will call the <code>UpdateUsername</code> method. The other button will call <code>Task.Run(UpdateUsername)</code>, putting it on a background thread. To determine whether <code>Invoke</code> is needed to access the main thread, you check the Boolean <code>InvokeRequired</code> read-only property. It may not be required if the thread pool chose to run <code>Task</code> on the main thread:</p>
<pre class="source-code">public partial class Form1 : Form</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    public Form1()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        InitializeComponent();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void btnRunInBackground_Click(object sender, </pre>
<pre class="source-code">        EventArgs e)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        Task.Run(UpdateUsername);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void btnRunOnMainThread_Click(object sender, </pre>
<pre class="source-code">        EventArgs e)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        UpdateUsername();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void UpdateUsername()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        var updateAction = new Action(() =&gt;</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            usernameTextBox.Text = "John Doe";</pre>
<pre class="source-code">        });</pre>
<pre class="source-code">        if (<strong class="bold">this.InvokeRequired</strong>)</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            this.Invoke(updateAction);</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        else</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            updateAction();</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>The <code>usernameTextBox</code> will display<a id="_idIndexMarker224"/> the name <strong class="bold">John Doe</strong> successfully regardless of which button is clicked:</p>
<div><div><img alt="Figure 4.3 – Updating a control on a WinForms form " height="510" src="img/Figure_4.4_B18552.jpg" width="1173"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Updating a control on a WinForms form</p>
<p>Like WPF, WinForms has a <code>BeginInvoke</code> method if the background code does not need to wait for the main thread update to complete. <code>BeginInvoke</code> can also accept an <code>EndInvoke</code> delegate that<a id="_idIndexMarker225"/> will receive a callback when the main thread invocation has completed.</p>
<p>This section provided a great start on using .NET managed threading in your Windows client applications. Let’s finish up with a summary of what we learned in this chapter.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Summary</h1>
<p>In this chapter, we learned some useful techniques for improving client application performance. We started by exploring some different uses of <code>async</code> and <code>await</code> in the ViewModel of a WPF application. In that project, we saw that awaiting <code>Task.WhenAll</code> does not block the main thread, which keeps the UI responsive to user input. We discussed how <code>Task.Run</code> and <code>Task.Factory.StartNew</code> can be used to call synchronous code from asynchronous code, making it easier to introduce managed threading to existing applications. We finished up the chapter by learning some techniques to update the UI thread from other threads without causing exceptions at runtime.</p>
<p>You should be feeling more comfortable using <code>async</code>, <code>await</code>, and the TPL in your code after reading this chapter. Try taking what you have learned here and start adding some <code>async</code> code to your own client applications. For additional reading on <code>async</code> and <code>await</code>, you can check out this C# article on Microsoft Docs: <a href="https://docs.microsoft.com/dotnet/csharp/async">https://docs.microsoft.com/dotnet/csharp/async</a>.</p>
<p>In the next chapter, we will dive even deeper into using <code>async</code>, <code>await</code>, and the TPL. We will take some of the concepts from this chapter and expand on them while introducing some best practices.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Questions</h1>
<ol>
<li value="1">What type should every <code>async</code> method return?</li>
<li>Which method can be used to await multiple tasks?</li>
<li>Which method to start a new task accepts <code>TaskDispatcher</code> as one of the parameters?</li>
<li>When calling an <code>async</code> method, what type of thread will execute the task?</li>
<li>What method should be used in a WPF application when updating a user control from a background thread?</li>
<li>Which method should be used on a WinForms control to execute an action on the main thread but not wait for the method to complete?</li>
<li>In WinForms, how can you check whether calling <code>Invoke</code> is necessary?</li>
</ol>
</div>
</div>
</body></html>