<html><head></head><body><div><p>&#13;
    <h1 class="chapterNumber">11</h1>&#13;
    <h1 id="_idParaDest-221" class="chapterTitle">Introducing Stacks, Queues, and HashSets</h1>&#13;
    <p class="normal">In the last chapter, we revisited variables, types, and classes to see what they had to offer beyond the basic features introduced at the beginning of the book. In this chapter, we'll take a closer look at new collection types and learn about their intermediate-level capabilities. Remember, being a good programmer isn't about memorizing code, it's about choosing the right tool for the right job.</p>&#13;
    <p class="normal">Each of the new collection types in this chapter has a specific purpose. For most scenarios where you need a collection of data, a list or array works just fine. However, when you need temporary storage or control over the order of collection elements, or more specifically, the order they are accessed, look to stacks and queues. When you need to perform operations that depend on every element in a collection to be unique, meaning not duplicated, look to HashSets. </p>&#13;
    <p class="normal">Before you start on the code in the following section, let's lay out the topics you'll be learning about:</p>&#13;
    <ul>&#13;
      <li class="bullet">Introducing stacks</li>&#13;
      <li class="bullet">Peeking and popping elements</li>&#13;
      <li class="bullet">Working with queues</li>&#13;
      <li class="bullet">Adding, removing, and peeking elements</li>&#13;
      <li class="bullet">Using HashSets</li>&#13;
      <li class="bullet">Performing operations</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-222" class="title">Introducing stacks</h1>&#13;
    <p class="normal">At its most basic level, a stack is a collection of elements of the same specified type. The length of a stack is variable, meaning it can change depending on how many elements it's holding. The important <a id="_idIndexMarker731"/>difference between a stack and a list or array is how the elements <a id="_idIndexMarker732"/>are stored. While lists or arrays store elements by index, stacks follow the <strong class="keyword">last-in-first-out </strong>(<strong class="keyword">LIFO</strong>) model, meaning the last element in the stack is the first accessible element. This is useful when you want to access elements in reverse order. You should note that they can store <code class="Code-In-Text--PACKT-">null</code> and duplicate values. A helpful analogy is a stack of plates—the last plate you put on the stack is the first one you can easily get to. Once it's removed, the next-to-last plate you stacked is accessible, and so on.</p>&#13;
    <div>&#13;
      <p class="Information-Box--PACKT-">All the collection types in this chapter are a part of the <code class="Code-In-Text--PACKT-">System.Collections.Generic</code> namespace, meaning you need to add the following code to the top of any file that you want to use them in: </p>&#13;
      <pre class="programlisting code"><code class="hljs-code">using System.Collections.Generic;&#13;
</code></pre>&#13;
    </p>&#13;
    <p class="normal">Now that you know what you're about to work with, let's take a look at the basic syntax for declaring stacks.</p>&#13;
    <p class="normal">A stack variable declaration needs to meet the following requirements:</p>&#13;
    <ul>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Stack</code> keyword, its element type between left and right arrow characters, and a unique name</li>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">new</code> keyword to initialize the stack in memory, followed by the <code class="Code-In-Text--PACKT-">Stack</code> keyword and element type between arrow characters</li>&#13;
      <li class="bullet">A pair of parentheses capped off by a semicolon</li>&#13;
    </ul>&#13;
    <p class="normal">In blueprint form, it looks like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Stack&lt;elementType&gt; name = new Stack&lt;elementType&gt;();&#13;
</code></pre>&#13;
    <p class="normal">Unlike the other collection types you've worked with, stacks can't be initialized with elements when they're created. Instead, all elements have to be added after the stack is created.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">C# supports a non-generic version of the stack type that doesn't require you to define the type of element in the stack: </p>&#13;
      <pre class="programlisting code"><code class="hljs-code">Stack myStack = new Stack(); &#13;
</code></pre>&#13;
      <p class="Information-Box--PACKT-">However, this is less safe and more costly than using the preceding generic version, so the generic version above is recommended. You can read more about Microsoft's recommendation at <a href="https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md">https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md</a>.</p>&#13;
    </p>&#13;
    <p class="normal">Your next task is to create a stack of your own and get hands-on experience with working with its class methods.</p>&#13;
    <p class="normal">To test this out, you're going to modify the existing item collection logic in <em class="italic">Hero Born</em> by using a stack to store <a id="_idIndexMarker733"/>possible loot that can be collected. A stack works nicely here because we won't have to worry about supplying indexes to get loot items, we can just get the last one added every time:</p>&#13;
    <ol>&#13;
      <li class="numbered">Open <code class="Code-In-Text--PACKT-">GameBehavior.cs</code> and add in a new stack variable named <code class="Code-In-Text--PACKT-">LootStack</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-comment-slc">// 1</strong>&#13;
public Stack&lt;string&gt; LootStack = new Stack&lt;string&gt;();&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Update the <code class="Code-In-Text--PACKT-">Initialize</code> method with the following code to add new items to the stack:&#13;
        <pre class="programlisting code"><code class="hljs-code">public void Initialize() &#13;
{&#13;
    _state = "Game Manager initialized..";&#13;
    _state.FancyDebug();&#13;
    Debug.Log(_state);&#13;
    <strong class="hljs-comment-slc">// 2</strong>&#13;
    <strong class="hljs-slc">LootStack.Push(</strong><strong class="hljs-string-slc">"Sword of Doom"</strong><strong class="hljs-slc">);</strong>&#13;
    <strong class="hljs-slc">LootStack.Push(</strong><strong class="hljs-string-slc">"HP Boost"</strong><strong class="hljs-slc">);</strong>&#13;
    <strong class="hljs-slc">LootStack.Push(</strong><strong class="hljs-string-slc">"Golden Key"</strong><strong class="hljs-slc">);</strong>&#13;
    <strong class="hljs-slc">LootStack.Push(</strong><strong class="hljs-string-slc">"Pair of Winged Boots"</strong><strong class="hljs-slc">);</strong>&#13;
    <strong class="hljs-slc">LootStack.Push(</strong><strong class="hljs-string-slc">"Mythril Bracer"</strong><strong class="hljs-slc">);</strong>&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Add a new method to the bottom of the script to print out the stack information:&#13;
        <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-comment-slc">// 3</strong>&#13;
public void PrintLootReport()&#13;
{&#13;
    Debug.LogFormat("There are {0} random loot items waiting &#13;
       for you!", LootStack.Count);&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Open <code class="Code-In-Text--PACKT-">ItemBehavior.cs</code> and call <code class="Code-In-Text--PACKT-">PrintLootReport</code> from the <code class="Code-In-Text--PACKT-">GameManager</code> instance:&#13;
        <pre class="programlisting code"><code class="hljs-code">void OnCollisionEnter(Collision collision)&#13;
{&#13;
    if(collision.gameObject.name == "Player")&#13;
    {&#13;
        Destroy(this.transform.parent.gameObject);&#13;
        Debug.Log("Item collected!");&#13;
        GameManager.Items += 1;&#13;
    &#13;
        <strong class="hljs-comment-slc">// 4</strong>&#13;
        <strong class="hljs-slc">GameManager.PrintLootReport();</strong>&#13;
    }&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Breaking this down, it does the following:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Creates an empty stack with elements <a id="_idIndexMarker734"/>of type string to hold the loot items we'll add in next</li>&#13;
      <li class="numbered">Uses the <code class="Code-In-Text--PACKT-">Push</code> method to add string elements to the stack (which are loot item names), increasing its size each time</li>&#13;
      <li class="numbered">Prints out the stack count whenever the <code class="Code-In-Text--PACKT-">PrintLootReport</code> method is called</li>&#13;
      <li class="numbered">Calls <code class="Code-In-Text--PACKT-">PrintLootReport</code> inside <code class="Code-In-Text--PACKT-">OnCollisionEnter</code> every time an item is collected by the player, which we set up in earlier chapters with Collider components</li>&#13;
    </ol>&#13;
    <p class="normal">Hit play in Unity, collect an item Prefab, and take a look at the new loot report that's printed out.</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_11_01.png" alt="" width="831" height="133"/></figure>&#13;
    <p class="packt_figref">Figure 11.1: Output from using stacks</p>&#13;
    <p class="normal">Now that you have a working stack holding all the game loot, you're ready to experiment with how items are accessed using the stack class's <code class="Code-In-Text--PACKT-">Pop</code> and <code class="Code-In-Text--PACKT-">Peek</code> methods.</p>&#13;
    <h2 id="_idParaDest-223" class="title">Popping and peeking</h2>&#13;
    <p class="normal">We've already talked about how stacks store elements using the LIFO method. Now, we need to look at how elements are accessed in a familiar but different collection type—by peeking and popping:</p>&#13;
    <ul>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Peek</code> method returns the next item on the stack without removing it, letting you "peek" at it without <a id="_idIndexMarker735"/>changing anything</li>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Pop</code> method returns <a id="_idIndexMarker736"/>and removes the next item on the stack, essentially "popping" it off and handing it to you</li>&#13;
    </ul>&#13;
    <p class="normal">Both of these methods can be <a id="_idIndexMarker737"/>used by themselves or together depending <a id="_idIndexMarker738"/>on what you need. You'll get hands-on experience with both methods in the following section.</p>&#13;
    <p class="normal">Your next task is to grab the last item added to <code class="Code-In-Text--PACKT-">LootStack</code>. In our example, the last element is determined programmatically in the <code class="Code-In-Text--PACKT-">Initialize</code> method, but you could always programmatically randomize the order the loot items were added to the stack in <code class="Code-In-Text--PACKT-">Initialize</code>. Either way, update <code class="Code-In-Text--PACKT-">PrintLootReport()</code> in <code class="Code-In-Text--PACKT-">GameBehavior</code> with the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public void PrintLootReport()&#13;
{&#13;
    <strong class="hljs-comment-slc">// 1</strong>&#13;
    <strong class="hljs-keyword-slc">var</strong><strong class="hljs-slc"> currentItem = LootStack.Pop();</strong>&#13;
    <strong class="hljs-comment-slc">// 2</strong>&#13;
    <strong class="hljs-keyword-slc">var</strong><strong class="hljs-slc"> nextItem = LootStack.Peek();</strong>&#13;
    <strong class="hljs-comment-slc">// 3</strong>&#13;
    <strong class="hljs-slc">Debug.LogFormat(</strong><strong class="hljs-string-slc">"You got a {0}! You've got a good chance of finding a {1} next!"</strong><strong class="hljs-slc">, currentItem, nextItem);</strong>&#13;
    Debug.LogFormat("There are {0} random loot items waiting for you!", LootStack.Count);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Here's what's going on:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Calls <code class="Code-In-Text--PACKT-">Pop</code> on <code class="Code-In-Text--PACKT-">LootStack</code>, removes the next item on the stack, and stores it. Remember, stack elements are ordered by the LIFO model.</li>&#13;
      <li class="numbered">Calls <code class="Code-In-Text--PACKT-">Peek</code> on <code class="Code-In-Text--PACKT-">LootStack</code> and stores the next item on the stack without removing it.</li>&#13;
      <li class="numbered">Adds a new <a id="_idIndexMarker739"/>debug log to print out the item that was popped <a id="_idIndexMarker740"/>off and the next item on the stack.</li>&#13;
    </ol>&#13;
    <p class="normal">You can see from the console that a <strong class="screenText">Mythril Bracer</strong>, the last item added to the stack, was popped off first, followed by a <strong class="screenText">Pair of Winged Boots</strong>, which was peeked at but not removed. You can also see that <code class="Code-In-Text--PACKT-">LootStack</code> has four remaining elements that can be accessed:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_11_02.png" alt="" width="828" height="161"/></figure>&#13;
    <p class="packt_figref">Figure 11.2: Output from popping and peeking on a stack</p>&#13;
    <p class="normal">Our player can now pick up loot items in the reverse order that they were added to the stack. For instance, the first item picked up will always be a <strong class="screenText">Mythril Bracer</strong>, followed by a <strong class="screenText">Pair of Winged Boots</strong>, then a <strong class="screenText">Golden Key</strong>, and so on.</p>&#13;
    <p class="normal">Now that you know how to create, add, and query elements from a stack, we can move on to some common methods that you have access to through the stack class.</p>&#13;
    <h2 id="_idParaDest-224" class="title">Common methods</h2>&#13;
    <p class="normal">Each of the methods in this section are for example purposes only, they are not included in our game as <a id="_idIndexMarker741"/>we don't need the functionality. </p>&#13;
    <p class="normal">First, you can use the <code class="Code-In-Text--PACKT-">Clear</code> method to empty out or delete the entire contents of a stack:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Empty the stack and reverting the count to 0&#13;
LootStack<strong class="hljs-slc">.Clear();</strong>&#13;
</code></pre>&#13;
    <p class="normal">If you want to know whether an element exists in your stack, use the <code class="Code-In-Text--PACKT-">Contains</code> method and specify the element you're looking for:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Returns true for "Golden Key" item&#13;
var itemFound = LootStack<strong class="hljs-slc">.Contains(</strong><strong class="hljs-string-slc">"Golden Key"</strong><strong class="hljs-slc">);</strong>&#13;
</code></pre>&#13;
    <p class="normal">If you need to copy the elements of a stack to an array, the <code class="Code-In-Text--PACKT-">CopyTo</code> method will let you specify the destination <a id="_idIndexMarker742"/>and the starting index for the copy operation. This feature is helpful when you need to insert stack elements at a specific place in an array. Note that the array you want to copy the stack elements to must already exist:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Creates a new array of the same length as LootStack&#13;
string[] CopiedLoot = new string[5]; &#13;
/* &#13;
Copies the LootStack elements into the new CopiedLoot array at index 0. The index parameter can be set to any index where you want the copied elements to be stored&#13;
*/&#13;
LootStack<strong class="hljs-slc">.CopyTo(copiedLoot, </strong><strong class="hljs-number-slc">0</strong><strong class="hljs-slc">);</strong>&#13;
</code></pre>&#13;
    <p class="normal">If you need to convert a stack into an array, simply use the <code class="Code-In-Text--PACKT-">ToArray()</code> method. This conversion creates a new array out of your stack, which is different than the <code class="Code-In-Text--PACKT-">CopyTo()</code> method, which copies the stack elements to an existing array:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Copies an existing stack to a new array&#13;
LootStack.ToArray();&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">You can find the <a id="_idIndexMarker743"/>entire list of stack methods in the C# documentation at <a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.stack-1?view=netcore-3.1">https://docs.microsoft.com/dotnet/api/system.collections.generic.stack-1?view=netcore-3.1</a>. </p>&#13;
    </p>&#13;
    <p class="normal">That wraps up our introduction to stacks, but we're going to talk about its cousin, the queue, in the following section.</p>&#13;
    <h1 id="_idParaDest-225" class="title">Working with queues</h1>&#13;
    <p class="normal">Like stacks, queues are collections of elements or objects of the same type. The length of any queue is <a id="_idIndexMarker744"/>variable just like a stack, meaning its size changes as elements are <a id="_idIndexMarker745"/>added or removed. However, queues follow the <strong class="keyword">first-in-first-out</strong> (<strong class="keyword">FIFO</strong>) model, meaning the first element in the queue is the first accessible element. You should note that queues can store <code class="Code-In-Text--PACKT-">null</code> and duplicate values but can't be <a id="_idIndexMarker746"/>initialized with elements when they're created. The code in this section is for example purposes only, and is not included in our game.</p>&#13;
    <p class="normal">A queue variable declaration needs to have the following:</p>&#13;
    <ul>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Queue</code> keyword, its element type between left and right arrow characters, and a unique name</li>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">new</code> keyword to initialize the queue in memory, followed by the <code class="Code-In-Text--PACKT-">Queue</code> keyword and element type between arrow characters</li>&#13;
      <li class="bullet">A pair of parentheses capped off by a semicolon</li>&#13;
    </ul>&#13;
    <p class="normal">In blueprint form, a queue looks as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Queue&lt;elementType&gt; name = new Queue&lt;elementType&gt;();&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">C# supports a non-generic version of the queue type that doesn't require you to define the type of element it stores: </p>&#13;
      <pre class="programlisting code"><code class="hljs-code">Queue myQueue = new Queue(); &#13;
</code></pre>&#13;
      <p class="Information-Box--PACKT-">However, this is less safe and more costly than using the preceding generic version. You can read more about Microsoft's recommendation at <a href="https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md">https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md</a>.</p>&#13;
    </p>&#13;
    <p class="normal">An empty queue all by itself isn't all that useful; you want to be able to add, remove, and peek at its elements whenever you need, which is the topic of the following section.</p>&#13;
    <h2 id="_idParaDest-226" class="title">Adding, removing, and peeking</h2>&#13;
    <p class="normal">Since the <code class="Code-In-Text--PACKT-">LootStack</code> variable <a id="_idIndexMarker747"/>in the previous sections could easily be a queue, we'll keep <a id="_idIndexMarker748"/>the following code out of our game scripts for <a id="_idIndexMarker749"/>efficiency. However, feel free to explore the differences, or similarities, of these classes in your own code.</p>&#13;
    <p class="normal">To create a queue of string elements, use the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Creates a new Queue of string values.&#13;
Queue&lt;string&gt; activePlayers = new Queue&lt;string&gt;();&#13;
</code></pre>&#13;
    <p class="normal">To add elements to <a id="_idIndexMarker750"/>the queue, call the <code class="Code-In-Text--PACKT-">Enqueue</code> method with the element you want to add:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Adds string values to the end of the Queue.&#13;
activePlayers<strong class="hljs-slc">.Enqueue(</strong><strong class="hljs-string-slc">"Harrison"</strong><strong class="hljs-slc">);</strong>&#13;
activePlayers<strong class="hljs-slc">.Enqueue(</strong><strong class="hljs-string-slc">"Alex"</strong><strong class="hljs-slc">);</strong>&#13;
activePlayers<strong class="hljs-slc">.Enqueue(</strong><strong class="hljs-string-slc">"Haley"</strong><strong class="hljs-slc">);</strong>&#13;
</code></pre>&#13;
    <p class="normal">To see the first <a id="_idIndexMarker751"/>element in the queue without removing it, use the <code class="Code-In-Text--PACKT-">Peek</code> method:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Returns the first element in the Queue without removing it.&#13;
var firstPlayer = activePlayers<strong class="hljs-slc">.Peek();</strong>&#13;
</code></pre>&#13;
    <p class="normal">To return and remove <a id="_idIndexMarker752"/>the first element in the queue, use the <code class="Code-In-Text--PACKT-">Dequeue</code> method:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Returns and removes the first element in the Queue.&#13;
var firstPlayer = activePlayers<strong class="hljs-slc">.Dequeue();</strong>&#13;
</code></pre>&#13;
    <p class="normal">Now that you know how to work with the basic features of a queue, feel free to explore the more intermediate and advanced methods that the queue class offers.</p>&#13;
    <h2 id="_idParaDest-227" class="title">Common methods</h2>&#13;
    <p class="normal">Queues and stacks share almost the exact same features, so we won't go over them a second time. You can f<a id="_idIndexMarker753"/>ind a complete list of methods and properties <a id="_idIndexMarker754"/>in the C# documentation at <a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.queue-1?view=netcore-3.1">https://docs.microsoft.com/dotnet/api/system.collections.generic.queue-1?view=netcore-3.1</a>.</p>&#13;
    <p class="normal">Before closing out the chapter, let's take a look at the HashSet collection type and the mathematical operations it's uniquely suited for.</p>&#13;
    <h1 id="_idParaDest-228" class="title">Using HashSets</h1>&#13;
    <p class="normal">The last collection type we'll get our hands on in this chapter is the HashSet. This collection is very different <a id="_idIndexMarker755"/>from any other collection type that we've come across: it cannot store duplicate values and is not sorted, meaning its elements are not ordered in any way. Think of HashSets as dictionaries with just keys, instead of key-value pairs. </p>&#13;
    <p class="normal">They can perform set operations and element lookups extremely fast, which we'll explore at the end of this section, and are best suited to situations where the element order and uniqueness are a top priority. </p>&#13;
    <p class="normal">A HashSet variable declaration needs to meet the following requirements:</p>&#13;
    <ul>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">HashSet</code> keyword, its element type between left and right arrow characters, and a unique name</li>&#13;
      <li class="bullet">The <code class="Code-In-Text--PACKT-">new</code> keyword to initialize the HashSet in memory, followed by the <code class="Code-In-Text--PACKT-">HashSet</code> keyword and <a id="_idIndexMarker756"/>element type between arrow characters</li>&#13;
      <li class="bullet">A pair of parentheses capped off by a semicolon</li>&#13;
    </ul>&#13;
    <p class="normal">In blueprint form, it looks as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">HashSet&lt;elementType&gt; name = new HashSet&lt;elementType&gt;();&#13;
</code></pre>&#13;
    <p class="normal">Unlike stacks and queues, you can initialize a HashSet with default values when declaring the variable:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">HashSet&lt;string&gt; people = new HashSet&lt;string&gt;();&#13;
// OR&#13;
HashSet&lt;string&gt; people = new HashSet&lt;string&gt;() { "Joe", "Joan", "Hank"};&#13;
</code></pre>&#13;
    <p class="normal">To add elements, use the <code class="Code-In-Text--PACKT-">Add</code> method and specify the new element:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">people<strong class="hljs-slc">.Add(</strong><strong class="hljs-string-slc">"Walter"</strong><strong class="hljs-slc">);</strong>&#13;
people<strong class="hljs-slc">.Add(</strong><strong class="hljs-string-slc">"Evelyn"</strong><strong class="hljs-slc">);</strong>&#13;
</code></pre>&#13;
    <p class="normal">To remove an element, call <code class="Code-In-Text--PACKT-">Remove</code> and specify the element you want to delete from the HashSet:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">people<strong class="hljs-slc">.Remove(</strong><strong class="hljs-string-slc">"Joe"</strong><strong class="hljs-slc">);</strong>&#13;
</code></pre>&#13;
    <p class="normal">That's it for the easy stuff, and this should start to feel pretty familiar at this point in your programming journey. Set operations are where the HashSet collection really shines, which is the topic of the following section.</p>&#13;
    <h2 id="_idParaDest-229" class="title">Performing operations</h2>&#13;
    <p class="normal">Set operations need <a id="_idIndexMarker757"/>two things: a calling collection object and a passed-in collection object. </p>&#13;
    <p class="normal">The calling collection object is the HashSet you want to modify based on which operation is used, while the passed-in collection object is used for comparison by the set operation. We'll get into this in more detail in the following code, but first, let's go over the three main set operations that crop up in programming <a id="_idIndexMarker758"/>scenarios the most often.</p>&#13;
    <p class="normal">In the following definitions, <code class="Code-In-Text--PACKT-">currentSet</code> refers to the HashSet calling an operation method and <code class="Code-In-Text--PACKT-">specifiedSet</code> refers to the passed-in HashSet method parameter. The modified HashSet is always the current set:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">currentSet.Operation(specifiedSet);&#13;
</code></pre>&#13;
    <p class="normal">There are three main operations that we'll be working with in the rest of this section:</p>&#13;
    <ul>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">UnionWith</code> adds the elements of the current and specified sets together</li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">IntersectWith</code> stores only the elements that are in both the current and specified sets</li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">ExceptWith</code> subtracts the elements of the specified set from the current set</li>&#13;
    </ul>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">There are two more groups of set operations that deal with subset and superset <a id="_idIndexMarker759"/>computations, but these are targeted at specific use cases that are beyond the scope of this chapter. You can find all the relevant information for these methods at <a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.hashset-1?view=netcore-3.1">https://docs.microsoft.com/dotnet/api/system.collections.generic.hashset-1?view=netcore-3.1</a>.</p>&#13;
    </p>&#13;
    <p class="normal">Let's say we have two sets of player names—one for active players and one for inactive players:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">HashSet&lt;string&gt; activePlayers = new HashSet&lt;string&gt;() { "Harrison", "Alex", "Haley"};&#13;
HashSet&lt;string&gt; inactivePlayers = new HashSet&lt;string&gt;() { "Kelsey", "Basel"};&#13;
</code></pre>&#13;
    <p class="normal">We would use the <code class="Code-In-Text--PACKT-">UnionWith()</code> operation to modify a set to include all the elements in both sets:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">activePlayers.UnionWith(inactivePlayers);&#13;
/* activePlayers now stores "Harrison", "Alex", "Haley", "Kelsey", "Basel"*/&#13;
</code></pre>&#13;
    <p class="normal">Now, let's say we have two different sets—one for active players and one for premium players:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">HashSet&lt;string&gt; activePlayers = new HashSet&lt;string&gt;() { "Harrison", "Alex", "Haley"};&#13;
HashSet&lt;string&gt; premiumPlayers = new HashSet&lt;string&gt;() { "Haley", "Basel"};&#13;
</code></pre>&#13;
    <p class="normal">We would <a id="_idIndexMarker760"/>use the <code class="Code-In-Text--PACKT-">IntersectWith()</code> operation to find any active players that are also premium members:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">activePlayers.IntersectWith(premiumPlayers);&#13;
// activePlayers now stores only "Haley"&#13;
</code></pre>&#13;
    <p class="normal">What if we wanted to find all active players that are not premium members? We would do the opposite of what we did with the <code class="Code-In-Text--PACKT-">IntersectWith()</code> operation by calling <code class="Code-In-Text--PACKT-">ExceptWith</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">HashSet&lt;string&gt; activePlayers = new HashSet&lt;string&gt;() { "Harrison", "Alex", "Haley"};&#13;
HashSet&lt;string&gt; premiumPlayers = new HashSet&lt;string&gt;() { "Haley",&#13;
  "Basel"};&#13;
activePlayers.ExceptWith(premiumPlayers);&#13;
// activePlayers now stores "Harrison" and "Alex" but removed "Haley"&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Notice that I'm using brand-new instances of the two example sets for each operation because the current set is modified after each operation is executed. If you keep using the same sets throughout, you will get different results.</p>&#13;
    </p>&#13;
    <p class="normal">Now that you've learned how to perform fast mathematical operations with HashSets, it's time to close our chapter and drive home what we've learned.</p>&#13;
    <h1 id="_idParaDest-230" class="title">Intermediate collections roundup</h1>&#13;
    <p class="normal">Before you move on to the summary and the next chapter, let's drive home some key points from what we've just learned. Topics that don't always have a 1-to-1 relationship with the actual game prototype we're building need a little extra love sometimes. </p>&#13;
    <p class="normal">The one question I'm sure you're asking yourself at this point is: why use any of these other collection types when I could just use lists for everything? And that's a perfectly valid question. The easy answer is that stacks, queues, and HashSets offer better performance than lists when applied in the correct circumstances. For example, when you need to store items in a specific order, and access them in a specific order, a stack would be more efficient than a list. </p>&#13;
    <p class="normal">The more complicated answer is that using different collection types enforces how your code is allowed to interact with them and their elements. This is a mark of good code design, as it removes any ambiguity on how you're planning to use a collection. With lists everywhere, things get confusing when you don't remember what functions you're asking them to perform. </p>&#13;
    <p class="normal">As with everything we've learned in this book, it's always best to use the right tool for the job at hand. More importantly, you need to have different tools available for that to be an option. </p>&#13;
    <h1 id="_idParaDest-231" class="title">Summary</h1>&#13;
    <p class="normal">Congratulations, you're almost at the finish line! In this chapter, you learned about three new collection types, and how they can be used in different situations. </p>&#13;
    <p class="normal">Stacks are great if you want to access your collection elements in the reverse order that they were added, queues are your ticket if you want to access your elements in sequential order, and both are ideal for temporary storage. The important difference between these collection types and lists or arrays is how they can be accessed with popping and peeking operations. Lastly, you learned about the almighty HashSet and its performance-based mathematical set operations. In situations where you need to work with unique values and perform additions, comparisons, or subtractions on large collections, these are key.</p>&#13;
    <p class="normal">In the next chapter, you'll be taken a little deeper into the intermediate world of C# with delegates, generics, and more as you approach the end of this book. Even after all you've learned, the last page is still just the beginning of another journey.</p>&#13;
    <h1 id="_idParaDest-232" class="title">Pop quiz – intermediate collections</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Which collection type stores its elements using the LIFO model?</li>&#13;
      <li class="numbered">Which method lets you query the next element in a stack without removing it?</li>&#13;
      <li class="numbered">Can stacks and queues store <code class="Code-In-Text--PACKT-">null</code> values?</li>&#13;
      <li class="numbered">How would you subtract one HashSet from another?</li>&#13;
    </ol>&#13;
    <h1 class="heading-1">JOIN us on Discord!</h1>&#13;
    <p class="normal">Read this book alongside other users, Unity/C# experts, and Harrison Ferrone. Ask questions, provide solutions to other readers, chat with the author via <em class="italic">Ask Me Anything sessions</em> and much more.</p>&#13;
<p class="normal">Join Now! </p>&#13;
    <p class="normal"><a href="https://packt.link/csharpunity2021">https://packt.link/csharpunity2021</a></p>&#13;
    <p class="normal"><img style="height: 8em; width: auto;" src="img/QR_Code_9781801813945.png" alt="" width="354" height="354"/></p>&#13;
  </div>&#13;
</div></body></html>