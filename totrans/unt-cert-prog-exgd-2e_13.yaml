- en: '*Chapter 13*: Effects, Testing, Performance, and Alt Controls'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：效果、测试、性能和替代控制。'
- en: In this final chapter, we are going to go through the process of checking, supporting,
    polishing, and preparing our game so that it's built and ready to be played on
    a device, making it platform-independent. Because our game will be ready to be
    played on various devices, we need the game to support as many screen ratios as
    possible. Back in [*Chapter 8*](B18381_08_Epub.xhtml#_idTextAnchor150), *Adding
    Custom Fonts and UI*, we made our game's UI support various screen ratios. The
    game, however, was built purposely for a 1,920 x 1,080 resolution, as discussed
    in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048), *Adding and Manipulating
    Objects*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一章中，我们将通过检查、支持、磨光和准备我们的游戏，使其构建并准备好在设备上播放，使其平台无关。因为我们的游戏将准备好在各种设备上播放，我们需要游戏支持尽可能多的屏幕比例。在[*第8章*](B18381_08_Epub.xhtml#_idTextAnchor150)中，*添加自定义字体和UI*，我们使游戏UI支持各种屏幕比例。然而，正如在[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)中讨论的，游戏是专门为1,920
    x 1,080分辨率构建的。
- en: In this chapter, we will make our game run at different screen ratios to support
    the use of mobile devices. This will involve changing Unity's Canvas scale and
    updating our `Player` script controls to update its screen boundaries, touch screen
    capability, and our ability to tap to move our ship. Furthermore, we will make
    our game aware that it is being played on a mobile device, and we'll make some
    changes, such as removing the **AD** button in the shop, as adverts aren't supported
    on PC devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使我们的游戏以不同的屏幕比例运行，以支持移动设备的使用。这涉及到更改Unity的Canvas缩放并更新我们的`Player`脚本控制，以更新其屏幕边界、触摸屏功能以及我们点击移动飞船的能力。此外，我们将使我们的游戏意识到它正在移动设备上播放，我们将进行一些更改，例如在商店中移除**AD**按钮，因为PC设备不支持广告。
- en: The PC version of Killer Wave will have more polished effects applied, such
    as post-processing, which will basically make our game more pretty with effects
    such as motion blur, chromatic aberration, color grading, and a few more effects
    on top. We will also be looking at reflection probes to create a mirrored effect
    for some of our art assets in the `level3` scene.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “杀手波浪”的PC版本将应用更多磨光的特效，例如后处理，这将基本上使我们的游戏通过运动模糊、色差、色彩分级等效果变得更加美观。我们还将研究反射探针，以在`level3`场景中为我们的某些艺术资产创建镜像效果。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Applying physics with **RigidBody**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**RigidBody**应用物理。
- en: Customizing for different platforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同平台定制。
- en: Preparing to build Killer Wave for mobile
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备为移动设备构建“杀手波浪”。
- en: Applying PC visual improvements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用PC视觉改进。
- en: Adding global illumination and other settings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加全局光照和其他设置。
- en: Building and testing our game
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试我们的游戏。
- en: The next section will specify the exam objectives that will be covered in this
    chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将指定本章中将要涵盖的考试目标。
- en: Core exam skills being covered in this chapter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章中将要涵盖的核心考试技能。
- en: 'The following are the core exam skills that will be covered in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将要涵盖的核心考试技能：
- en: '*Programming core interactions*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程核心交互*：'
- en: Implement and configure game object behavior and physics.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象行为和物理。
- en: Implement and configure input and controls.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置输入和控制。
- en: Implement and configure camera views and movement.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置摄像机视图和移动。
- en: '*Working in the art pipeline*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*在艺术管道中工作*：'
- en: Understand materials, textures, and shaders, and write scripts that interact
    with Unity's rendering API.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解材质、纹理和着色器，并编写与Unity渲染API交互的脚本。
- en: Understand lighting, and write scripts that interact with Unity's lighting API.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解光照，并编写与Unity光照API交互的脚本。
- en: '*Optimizing for performance and platforms*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*针对性能和平台优化*：'
- en: Evaluate errors and performance issues using tools such as the Unity Profiler.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity Profiler等工具评估错误和性能问题。
- en: Identify optimizations to address requirements for specific build platforms
    and/or hardware configurations.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别针对特定构建平台和/或硬件配置的要求的优化。
- en: '*Working in professional software development teams*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*在专业软件开发团队中工作*：'
- en: Demonstrate knowledge of developer testing and its impact on the software development
    process, including the Unity Profiler and traditional debugging and testing techniques.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示对开发者测试及其对软件开发过程影响的了解，包括Unity Profiler和传统的调试和测试技术。
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到构建模块化、可读性和可重用性脚本的技巧。
- en: Technical requirements
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_13](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_13).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可以在 [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_13](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_13)
    找到。
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)
    下载每个章节的项目文件。
- en: All the content for this chapter is held in this chapter's `unitypackage` file.
    This file includes a `Complete` folder, which holds all of the work we'll carry
    out in this chapter. So, if at any point you need some reference material or extra
    guidance, check it out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都包含在本章的 `unitypackage` 文件中。此文件包含一个 `Complete` 文件夹，其中包含我们在本章中将要完成的所有工作。因此，如果您在任何时候需要一些参考资料或额外指导，请查看它。
- en: 'Check out the following video to see the *Code in Action*: https://bit.ly/3rYA6k4.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看 *代码执行情况*：https://bit.ly/3rYA6k4。
- en: Applying physics with RigidBody
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RigidBody 应用物理
- en: Throughout this book, we have used colliders and trigger boxes to detect hits
    from a bullet or a selection made in the first rendition of our shop. We have
    also referred to applying a `level3` boss game object going through them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用了碰撞器和触发盒子来检测子弹或在我们商店的第一版中做出的选择。我们还提到了应用一个 `level3` 大BOSS游戏对象穿过它们。
- en: 'The following image shows the cargo art assets being smashed out of the way
    by applying and tweaking **Rigidbody** components, which is what we will achieve
    in this section:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了通过应用和调整 **Rigidbody** 组件，货物艺术资源被撞开，这是我们将在本节中实现的效果：
- en: '![Figure 13.1 – Boxes go flying when hit thanks to Unity''s Rigidbody Component'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 由于 Unity 的 Rigidbody 组件，当被击中时盒子会飞起]'
- en: '](img/Figure_13.01_B18381.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.01](img/Figure_13.01_B18381.jpg)'
- en: Figure 13.1 – Boxes go flying when hit thanks to Unity's Rigidbody Component
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 由于 Unity 的 Rigidbody 组件，当被击中时盒子会飞起
- en: 'Let''s make a start by setting up our `level3` scene with some pre-made assets:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置包含一些预制资源的 `level3` 场景开始：
- en: In the `Assets/Scene` folder.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scene` 文件夹中。
- en: Double-click the `level3` scene to open it.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `level3` 场景以打开它。
- en: In the `physicsBarrier` from `Assets/Prefab` into the **Hierarchy** window.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Prefab` 将 `physicsBarrier` 拖到 **Hierarchy** 窗口。
- en: Select the `physicsBarrier` game object in the `1` on all axes.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有轴上选择 `physicsBarrier` 游戏对象。
- en: The following screenshot shows `physicsBarrier` in the `level3` scene. Note
    the green outline, which shows that this is our series of box colliders, which
    will contain our physics.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `level3` 场景中的 `physicsBarrier`。注意绿色的轮廓，这表明这是我们的一系列盒子碰撞器，它们将包含我们的物理效果。
- en: '![Figure 13.2 – The wireframe is our collision area for our boxes'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – 线框是我们盒子的碰撞区域]'
- en: '](img/Figure_13.02_B18381.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.02](img/Figure_13.02_B18381.jpg)'
- en: Figure 13.2 – The wireframe is our collision area for our boxes
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 线框是我们盒子的碰撞区域
- en: In the `physicsBarrier` to show its three children game objects.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `physicsBarrier` 中显示其三个子游戏对象。
- en: Select all three of these child objects and set their **Rigidbody** component
    so that **Is Kinematic** is ticked.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这三个子对象，并将它们的 **Rigidbody** 组件设置为 **Is Kinematic** 被勾选。
- en: 'The following screenshot shows all three game objects selected and the **Rigidbody**
    settings being updated:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了所有三个游戏对象被选中，并且正在更新 **Rigidbody** 设置：
- en: '![Figure 13.3 – All ''physicsBarrier'' gameobject children have a Rigidbody
    with Is Kinematic marked as true](img/Figure_13.03_B18381.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 所有 ''physicsBarrier'' 游戏对象子对象都有一个标记为 true 的 Rigidbody](img/Figure_13.03_B18381.jpg)'
- en: Figure 13.3 – All 'physicsBarrier' gameobject children have a Rigidbody with
    Is Kinematic marked as true
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 所有 'physicsBarrier' 游戏对象子对象都有一个标记为 true 的 Rigidbody
- en: '**Is Kinematic** will ensure that these three game objects aren''t affected
    by the physics in the scene. Even if we did tick the **Use Gravity** box, the
    game objects won''t begin to fall when the scene starts as expected. So, whatever
    happens in our scene regarding collisions, these three game objects will remain
    still and solid so that they cage all of the physics engine''s reactions.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**是否运动学** 将确保这三个游戏对象不受场景中物理的影响。即使我们勾选了 **使用重力** 复选框，游戏对象在场景开始时也不会像预期的那样开始下落。所以，无论场景中发生什么关于碰撞的事情，这三个游戏对象都将保持静止和坚固，以便它们能捕获所有物理引擎的反应。'
- en: Further Information
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'With a game object selected that holds a **Rigidbody** component, the following
    properties will alter the game object''s behavior when it''s manipulated by Unity''s
    physics engine:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择了一个包含 **刚体** 组件的游戏对象时，以下属性将改变游戏对象在 Unity 物理引擎操作时的行为：
- en: '**Mass**: The game object''s mass in kilograms (Default value: **1**)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量**：游戏对象的千克质量（默认值：**1**）'
- en: '**Drag**: The air resistance, with zero being no resistance (Default value:
    **0**)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻力**：空气阻力，其中零表示没有阻力（默认值：**0**）'
- en: '**Angular Drag**: Air resistance based on rotation (Default value: **0.05**)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**角阻力**：基于旋转的空气阻力（默认值：**0.05**）'
- en: 'More information about **Rigidbody** and its properties can be found here:
    [https://docs.unity3d.com/ScriptReference/Rigidbody.html](https://docs.unity3d.com/ScriptReference/Rigidbody.html).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **刚体** 及其属性的更多信息，请参阅此处：[https://docs.unity3d.com/ScriptReference/Rigidbody.html](https://docs.unity3d.com/ScriptReference/Rigidbody.html)。
- en: Now, we can bring our cargo boxes into the scene.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的货物盒子带入场景。
- en: In the `cargoBulk` prefab from `Assets /Prefab` into the `physicsBarrier` prefab,
    make sure that the **Transform** property values are set to their default values.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `cargoBulk` 预制件从 `Assets /Prefab` 拖到 `physicsBarrier` 预制件中，确保 **变换** 属性值设置为默认值。
- en: 'The `cargoBulk` prefab should be in place and look like the one shown in the
    following screenshot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargoBulk` 预制件应该就位，并看起来像以下截图所示：'
- en: '![Figure 13.4 – The wall of boxes'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4 – 盒子墙'
- en: '](img/Figure_13.04_B18381.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.04_B18381.jpg)'
- en: Figure 13.4 – The wall of boxes
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 盒子墙
- en: To reinforce `cargoBulk` so that it collapses at the right time, a script needs
    to be applied called `TurnOnPhysics`. This will set all of the cargo game objects
    from `true` to `false` after `38` seconds, (feel free to open the `TurnOnPhysics`
    script and adjust 38 to a different number in the `Update` function) which is
    the time the boss is due to crash through the cargo boxes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强 `cargoBulk` 以确保它在正确的时间倒塌，需要应用一个名为 `TurnOnPhysics` 的脚本。这将使所有 `cargo` 游戏对象在
    `38` 秒后从 `true` 变为 `false`，（您可以随意打开 `TurnOnPhysics` 脚本，并在 `Update` 函数中将 38 调整为不同的数字）这是老板预计穿过货物盒子的时间。
- en: '`physicsBarrier` and `cargoBulk` and their children game objects are all set
    as colliders. Currently, our boss is set as a trigger for when they are shot by
    the player. However, we don''t want it to be a trigger here, as the boss will
    move through the cargo boxes like a ghost.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`physicsBarrier`、`cargoBulk` 及其子游戏对象都被设置为碰撞体。目前，我们的老板被设置为当玩家射击时触发。然而，我们不想在这里将其设置为触发器，因为老板将像幽灵一样穿过货物盒子。'
- en: 'We can make `boss` start as a non-trigger and then, at the end of the level,
    turn its trigger on with the use of **Timeline**. To alter the **Is Trigger**
    tick box, we need to do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让 `boss` 以非触发模式启动，然后在关卡结束时，使用 **时间轴** 来开启它的触发器。要更改 **是否触发** 复选框，我们需要执行以下操作：
- en: Select the **Timeline** game object in the **Hierarchy** window.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中选择 **时间轴** 游戏对象。
- en: Right-click the `boss` **Timeline** **track asset**, and from the dropdown,
    select **Edit in Animation Window**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `boss` **时间轴** **轨道资产**，从下拉菜单中选择 **在动画窗口中编辑**。
- en: 'The following screenshot shows where to right-click and load the **Animation**
    window:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了右键单击并加载 **动画** 窗口的位置：
- en: '![Figure 13.5 – Load the Animation Window to update the ''boss'' game object
    animation'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5 – 加载动画窗口以更新 ''boss'' 游戏对象动画'
- en: '](img/Figure_13.05_B18381.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.05_B18381.jpg)'
- en: Figure 13.5 – Load the Animation Window to update the 'boss' game object animation
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 加载动画窗口以更新 'boss' 游戏对象动画
- en: 'Our `boss` game object that we placed in the previous chapter. We can add two
    keyframes to this window to turn it on and then off with the **Is Trigger** box.
    To do this, follow these steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中放置的 `boss` 游戏对象。我们可以在该窗口中添加两个关键帧来开启和关闭它，使用 **是否触发** 复选框。要执行此操作，请按照以下步骤进行：
- en: Drag **Animation Indicator** to the beginning of the animation track in the
    **Animation** window.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**动画指示器**拖动到**动画**窗口中动画轨道的开始处。
- en: Click the **record** button.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**记录**按钮。
- en: In the `boss` game object and select **Is Trigger** to be unchecked in the **Sphere
    Collider** component in the **Inspector** window.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`boss`游戏对象中，在**检查器**窗口的**球体碰撞器**组件中取消选择**触发器**。
- en: Back in the `1193` (this will be the part where the `boss` game object has already
    burst through the boxes).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`1193`（这将是在`boss`游戏对象已经从盒子里爆出来的部分）。
- en: Select the **Is Trigger** box in the **Inspector** window so that it's ticked.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中选择**触发器**框，使其被勾选。
- en: Finally, back in the **Animation** window, press **record** to turn it off and
    close the **Animation** window.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到**动画**窗口，按**记录**按钮关闭并关闭**动画**窗口。
- en: Save the scene and press `level3`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并按`level3`。
- en: 'However, after doing this, something doesn''t seem right. By the time we reach
    the end of the level, the boxes have already collapsed and when the `boss` game
    object collides with them, the boxes appear to float away. This is because the
    game objects in our scene aren''t scaled to real-world size, but the gravity is.
    To make things look heavier, we can change the gravity of the project, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，完成此操作后，似乎有些不对劲。当我们到达关卡末尾时，盒子已经倒塌，当`boss`游戏对象与它们碰撞时，盒子看起来像是飘走了。这是因为我们场景中的游戏对象没有缩放到真实世界的大小，但重力是。为了让东西看起来更重，我们可以更改项目中的重力，如下所示：
- en: At the top of the Unity Editor, go to **Edit** | **Project Settings** | **Physics**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器顶部，转到**编辑** | **项目设置** | **物理**。
- en: Here, we have **Physics Manager**, which is where the gravity has been set to
    its default world scale.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有**物理管理器**，这是重力被设置为默认世界比例的地方。
- en: Change the `-9.81` to `-1000`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`-9.81`更改为`-1000`。
- en: Another potential issue could be that the boss goes right through the cargo
    boxes? To fix this, change the boss GameObject's **Update Mode** from **Normal**
    to **Animate Physics**. and make sure that **Apply** **Root Motion** is unchecked.
    Finally, because your boss is colliding with boxes, be sure it has a Rigidbody
    with **Is Kinematic** ticked.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个潜在问题可能是老板直接穿过货物盒子？为了解决这个问题，将`boss`游戏对象的**更新模式**从**正常**更改为**动画物理**，并确保**应用**
    **根运动**未勾选。最后，因为您的老板正在与盒子碰撞，请确保它有一个带有**是运动学**勾选的刚体。
- en: Further Information
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'Your project''s gravity can also be changed through scripting, as shown here:
    [https://docs.unity3d.com/ScriptReference/Physics-gravity.html](https://docs.unity3d.com/ScriptReference/Physics-gravity.html).'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的项目重力也可以通过脚本进行更改，如下所示：[https://docs.unity3d.com/ScriptReference/Physics-gravity.html](https://docs.unity3d.com/ScriptReference/Physics-gravity.html)。
- en: 'Save the scene again. Now, if we press `boss` game object will burst through
    them, as shown in the following screenshot:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次保存场景。现在，如果我们按下`boss`游戏对象将爆裂穿过它们，如下面的截图所示：
- en: '![Figure 13.6 – The ''boss'' game object colliding with the boxes'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.6 – The ''boss'' game object colliding with the boxes'
- en: '](img/Figure_13.06_B18381.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.06_B18381.jpg]'
- en: Figure 13.6 – The 'boss' game object colliding with the boxes
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – `boss`游戏对象与盒子碰撞
- en: Further Information
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: '**Physics Manager** contains global settings for your project''s physics. One
    of the many useful settings at the bottom of **Physics Manager** is **Layer Collision
    Matrix**. This holds all the names of the layers in your project that can and
    cannot collide with each other. If you would like to know more about **Layer Collision
    Matrix**, check out the following link: [https://docs.unity3d.com/Manual/LayerBasedCollision.html](https://docs.unity3d.com/Manual/LayerBasedCollision.html).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理管理器**包含项目中物理的全局设置。在**物理管理器**底部的许多有用设置之一是**层碰撞矩阵**。它包含了项目中可以和不能相互碰撞的所有层的名称。如果您想了解更多关于**层碰撞矩阵**的信息，请查看以下链接：[https://docs.unity3d.com/Manual/LayerBasedCollision.html](https://docs.unity3d.com/Manual/LayerBasedCollision.html)。'
- en: If you aren't happy with the way the `cargo` game objects react when they're
    hit by the `boss` game object, tweak its **Rigidbody** property values (including
    the ones mentioned in the first tip, earlier in this section).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`cargo`游戏对象被`boss`游戏对象击中时的反应方式不满意，请调整其**刚体**属性值（包括在本节前面提到的那些）。
- en: Every collider can have a physics material applied to it, which will affect
    an object's bounciness and friction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个碰撞体都可以应用物理材质，这将影响物体的弹性和摩擦力。
- en: 'Creating and applying a physics material can be done in three steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和应用物理材质可以分三步完成：
- en: In the **Project** window, right-click and select **Create** | **Physic Material**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**窗口中右键单击并选择**Create** | **Physic Material**。
- en: Select **New Physic Material** and change its property values in the **Inspector**
    window (you can also rename the file so that it represents what physical material
    you're trying to achieve).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**New Physic Material**并在**Inspector**窗口中更改其属性值（您也可以重命名文件，使其代表您试图实现的物理材料）。
- en: Select a game object with a collider. Then, click the **remote** button next
    to the **Material** field and select **New Physic Material**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个带有碰撞器的游戏对象。然后，点击**Material**字段旁边的**remote**按钮并选择**New Physic Material**。
- en: '![Figure 13.7 – Creating a Physic Material, updating its properties, and adding
    the material to a Box Collider](img/Figure_13.07_B18381.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 创建物理材料，更新其属性，并将材料添加到Box Collider](img/Figure_13.07_B18381.jpg)'
- en: Figure 13.7 – Creating a Physic Material, updating its properties, and adding
    the material to a Box Collider
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 创建物理材料，更新其属性，并将材料添加到Box Collider
- en: Further Information
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: More information about **Physic Material** can be found at [https://docs.unity3d.com/Manual/class-PhysicMaterial.html](https://docs.unity3d.com/Manual/class-PhysicMaterial.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于**Physic Material**的信息可以在[https://docs.unity3d.com/Manual/class-PhysicMaterial.html](https://docs.unity3d.com/Manual/class-PhysicMaterial.html)找到。
- en: Our game now has some physics effects applied to it. Now, each time the boss
    crashes through the cubes, the reaction will be different each time and not like
    a fixed animation. This is because all the movement is based on the Unity engine's
    physics.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在已经应用了一些物理效果。现在，每次Boss穿过方块时，反应都会不同，而不是固定的动画。这是因为所有的移动都是基于Unity引擎的物理。
- en: Now, let's move on and make our game more customized for multiple platforms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并使我们的游戏更适合多个平台。
- en: Customizing for different platforms
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同平台定制
- en: Throughout this book, we have been developing and playing our game in the Unity
    Editor. In this section, we are going to start making some considerations regarding
    what will differ between the Android and PC versions of our game. For example,
    mobile devices have a touchscreen, so it would be useful if our game could detect
    that it's being played on a mobile device and, therefore, implement the correct
    controls.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在Unity编辑器中开发和玩游戏。在本节中，我们将开始考虑游戏在Android和PC版本之间的差异。例如，移动设备有触摸屏，所以如果我们的游戏能够检测到它在移动设备上运行，并因此实现正确的控制，这将是有用的。
- en: Also, our game has been developed with a strict 1,920 x 1,080 resolution; we
    have introduced flexibility with the shop scene's UI and ensured that it accommodates
    various aspect ratios. In this section, we will go further and make our game support
    various aspect ratios.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的游戏是以严格的1,920 x 1,080分辨率开发的；我们在商店场景的UI中引入了灵活性，并确保它能够适应各种宽高比。在本节中，我们将进一步使我们的游戏支持各种宽高比。
- en: Let's get started and modify our `Player` script so that it supports touchscreen
    movement and fires on mobile devices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始修改`Player`脚本，使其支持触摸屏移动并在移动设备上发射。
- en: Navigating and firing the player's ship with the touchscreen
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用触摸屏导航和发射玩家的飞船
- en: In this section, we are going to revisit the `Player` script and add some functionality
    so that if and when our game is ported to an Android device, the player has touchscreen
    capabilities.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新审视`Player`脚本并添加一些功能，以便如果我们的游戏被移植到Android设备，玩家将具有触摸屏功能。
- en: 'To allow our player to auto-fire and navigate to a touch position, we need
    to do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许我们的玩家自动发射并导航到触摸位置，我们需要做以下事情：
- en: In the `Assets/Script` folder and open the `Player` script.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中打开`Player`脚本。
- en: At the top of the `Player` script, we are going to add some new variables to
    support the new control system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`脚本顶部，我们将添加一些新的变量以支持新的控制系统。
- en: 'Add the following code, along with the rest of the variables, to the `Player`
    script:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码以及其余的变量添加到`Player`脚本中：
- en: '[PRE0]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `direction` variable will hold the player's touchscreen location; `rb` will
    hold a `mobile` variable is simply a `static` switch that lets the rest of the
    game know the player's controls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`direction`变量将保存玩家的触摸屏位置；`rb`将保存一个`mobile`变量，它只是一个`static`开关，让游戏的其他部分知道玩家的控制。'
- en: We need to make the game recognize which platform the game is running on so
    that it can implement the player's mobile controls. Unity has a platform-dependent
    compilation that lets us choose from a list of directives so that we can determine
    what platform the game is running on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让游戏识别游戏正在运行的平台，以便它可以实现玩家的移动控制。Unity有一个基于平台的编译，允许我们从一系列指令中选择，以便我们可以确定游戏正在运行的平台。
- en: 'Scroll down to the `Start` function in the `Player` script and add the following
    code inside the `Start` function''s scope:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`Player`脚本中的`Start`函数，并在`Start`函数的作用域内添加以下代码：
- en: '[PRE1]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Within the `Start` function, we set our `mobile` `bool` variable to `false`.
    Then, we run a platform defined directives check to see whether we are running
    an Android device and not using the Unity Editor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start`函数内，我们将我们的`mobile` `bool`变量设置为`false`。然后，我们运行一个平台定义的指令检查，以查看我们是否在运行Android设备且未使用Unity编辑器。
- en: Further Information
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步信息
- en: 'If you would like to find out more about other platform-dependent compilations,
    check out the following link:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于其他平台依赖编译的信息，请查看以下链接：
- en: '[https://docs.unity3d.com/Manual/PlatformDependentCompilation.html](https://docs.unity3d.com/Manual/PlatformDependentCompilation.html).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Manual/PlatformDependentCompilation.html](https://docs.unity3d.com/Manual/PlatformDependentCompilation.html)。'
- en: 'If we are using an Android device, we fall into the scope of this special type
    of `if` statement and do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是Android设备，我们将进入这种特殊类型的`if`语句的作用域，并执行以下操作：
- en: We set the `bool` `mobile` variable to `true`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`bool` `mobile`变量设置为`true`。
- en: Make our `Attack` method get called every `0.3` seconds with Unity's own `InvokeRepeating`
    function, which acts as an auto-fire tool.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity自带的`InvokeRepeating`函数，使我们的`Attack`方法每`0.3`秒被调用一次，该函数充当自动射击工具。
- en: Assign the `player_ship` game object's `rb` variables.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配`player_ship`游戏对象的`rb`变量。
- en: Finally, we close the `if` statement.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们关闭`if`语句。
- en: To make our `InvokeRepeating` method fire a bullet with the use of the `Attack`
    method at `0.3` seconds, we need to modify the `Attack` method's `if` statement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的`InvokeRepeating`方法在`0.3`秒内使用`Attack`方法发射子弹，我们需要修改`Attack`方法的`if`语句。
- en: 'Scroll down to the `Attack` method in the `Player` script and replace the `if`
    statement with the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`Player`脚本中的`Attack`方法，并将`if`语句替换为以下内容：
- en: '[PRE2]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By adding the `mobile` variable to the `if` statement's condition, we can check
    whether the player is pressing the fire button or whether the `mobile` `bool`
    variable is set to `true`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`mobile`变量添加到`if`语句的条件中，我们可以检查玩家是否按下了射击按钮，或者`mobile` `bool`变量是否设置为`true`。
- en: Now, we need to add more functionality to the `Update` function within our `Player`
    script, which includes two new methods we haven't coded in yet but will after
    the following code block.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`Player`脚本中的`Update`函数中添加更多功能，这包括两个我们尚未编写的新的方法，但将在以下代码块之后完成。
- en: 'Replace the current `Update` function in the `Player` script and its content
    with the following code so that it supports PC and mobile controls:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Player`脚本中的当前`Update`函数及其内容替换为以下代码，以便它支持PC和移动控制：
- en: '[PRE3]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our refreshed `Update` function contains the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新的`Update`函数包含以下内容：
- en: An `if` statement to check whether the game has been paused. If it has, we bypass
    the rest of the `Update` content. If you want to find out more about pausing the
    game, check out [*Chapter 10*](B18381_10_Epub.xhtml#_idTextAnchor173)*, Pausing
    the Game, Altering Sound, and a Mock Test*.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于检查游戏是否被暂停的`if`语句。如果游戏已被暂停，我们将跳过`Update`内容的其余部分。如果你想知道更多关于暂停游戏的信息，请查看[*第10章*](B18381_10_Epub.xhtml#_idTextAnchor173)*，暂停游戏、更改声音和模拟测试*。
- en: Within the `if` statement, we run a new method called `PlayersSpeedWithCamera`,
    which will contain code we have already coded. We're simply moving the code into
    the method so that it covers PC and mobile controls for when the camera has speed
    applied to it.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`if`语句内，我们运行一个名为`PlayersSpeedWithCamera`的新方法，该方法将包含我们已编写的代码。我们只是将代码移动到方法中，以便它覆盖当相机应用速度时的PC和移动控制。
- en: Then, we have a second `if` statement that checks whether the `mobile` `bool`
    variable is set to `true` or `false`. If `true`, we run our `MobileControls` method;
    otherwise, our PC `Movement` and `Attack` methods will run.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个第二个`if`语句，检查`mobile` `bool`变量是否设置为`true`或`false`。如果是`true`，我们将运行我们的`MobileControls`方法；否则，我们的PC
    `Movement`和`Attack`方法将运行。
- en: As mentioned previously, we have two new methods (`PlayersSpeedWithCamera` and
    `MobileControls`). The first method is a simple cut and paste of code from the
    current `Movement` method, which we want to accommodate for PC and mobile controls.
    The second method will cover touch controls for when the player places their finger
    on the screen and the `player_ship` game object moves to that location.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，我们有两个新的方法（`PlayersSpeedWithCamera`和`MobileControls`）。第一个方法是将当前`Movement`方法中的代码简单复制粘贴，我们希望它适用于PC和移动控制。第二个方法将涵盖当玩家将手指放在屏幕上时，`player_ship`游戏对象移动到该位置时的触摸控制。
- en: 'So, let''s start with the `PlayersSpeedWithCamera` method first. Still in the
    `Player` script, scroll down to the `Movement` method and select and cut the first
    `if` statement. The following is the code that I want you to cut:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们首先从`PlayersSpeedWithCamera`方法开始。仍然在`Player`脚本中，向下滚动到`Movement`方法，选择并剪切第一个`if`语句。以下是我想要您剪切出的代码：
- en: '[PRE4]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, create a new method in the `Player` script called `PlayersSpeedWithCamera`
    and paste the previous `if` statement code block inside the scope of the `PlayersSpeedWithCamera`
    method.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Player`脚本中创建一个新的方法`PlayersSpeedWithCamera`，并将之前的`if`语句代码块粘贴到`PlayersSpeedWithCamera`方法的作用域内。
- en: Now, the content of the `PlayersSpeedWithCamera` method will run for mobile
    and standalone platforms. If you would like to refresh yourself on the details
    of the camera's travel speed, take a look at *, NavMesh, Timeline, and a Mock
    Test*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PlayersSpeedWithCamera`方法的内容将在移动和独立平台上运行。如果您想回顾一下相机移动速度的细节，请查看*NavMesh,
    Timeline, 和模拟测试*。
- en: Now, let's take a look at the second method called `MobileControls`, which can
    be found in the `Player` script.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第二个方法`MobileControls`，它可以在`Player`脚本中找到。
- en: 'Write the following method inside the `Player` script so that the player can
    navigate `player_ship` around the screen:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player`脚本中编写以下方法，以便玩家可以在屏幕上导航`player_ship`：
- en: '[PRE5]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Keep in mind that the `MobileControls` method is called on every frame in the
    `Update` function. Inside the `MobileControls` method, we do the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`MobileControls`方法在`Update`函数的每一帧都会被调用。在`MobileControls`方法内部，我们执行以下操作：
- en: Run an `if` statement to check whether there has been more than one touch on
    the screen of the device. If a finger has touched the screen, we fall into the
    `if` statement's scope.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个`if`语句来检查设备屏幕上是否有超过一个触摸。如果手指触摸了屏幕，我们将进入`if`语句的作用域。
- en: We assign a touch to a `touch` variable.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将触摸操作分配给`touch`变量。
- en: Further Information
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: If you would like to know more about the `Touch` struct and its other properties,
    such as `deltaPosition`, which is useful for measuring swipe gestures, take a
    look at [https://docs.unity3d.com/ScriptReference/Touch.html](https://docs.unity3d.com/ScriptReference/Touch.html).
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`Touch`结构及其其他属性的信息，例如用于测量滑动手势的有用属性`deltaPosition`，请查看[https://docs.unity3d.com/ScriptReference/Touch.html](https://docs.unity3d.com/ScriptReference/Touch.html)。
- en: Next, we take a ready-made function from Unity to convert the screen's touch
    position and store it in a world space position.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们从Unity中提取一个现成的函数来转换屏幕的触摸位置，并将其存储在世界空间位置中。
- en: Further Information
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about converting a point into world space, check
    out the following link: [https://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html](https://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html).'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于将点转换为世界空间的信息，请查看以下链接：[https://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html](https://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html)。
- en: Because we aren't affecting the player ship's *z* axis, we set `touchPosition`
    on the Z axis to zero.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们没有影响玩家飞船的*z*轴，我们将`touchPosition`在Z轴上的值设置为0。
- en: Store the `Vector3` position of `touchPosition`, minus the `Vector3` position
    of the player's ship.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储触摸位置`Vector3`位置减去玩家飞船的`Vector3`位置。
- en: Send the `player_ship` game object to the `Vector3` position that is stored
    in `direction`. Multiply it by `5` to make it move slightly faster.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`player_ship`游戏对象发送到存储在`direction`中的`Vector3`位置。将其乘以`5`以使其移动得稍微快一些。
- en: Apply whatever value is in the `movingScreen` variable to the `direction` *x*
    position.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`movingScreen`变量中的值应用到`direction` *x* 位置。
- en: Finally, if the state of the touch phase has ended (a finger taken off the screen),
    apply a zero value to the `rb velocity` variable.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果触摸阶段的状态已经结束（手指从屏幕上移开），将`rb velocity`变量的值设置为0。
- en: So, now, the player's ship automatically fires and can move around the screen
    thanks to its **Rigidbody** component. Now, we need to make it that when either
    level ends, we stop the player from firing automatically and **Rigidbody** no
    longer has an effect on the player's movement. Otherwise, when the level ends,
    the player's ship won't stop firing, running the risk of not being able to animate
    out of the level.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，玩家的飞船会自动发射并可以在屏幕上移动，这要归功于其**Rigidbody**组件。现在，我们需要确保当任何关卡结束时，我们停止玩家自动发射，并且**Rigidbody**不再影响玩家的移动。否则，当关卡结束时，玩家的飞船不会停止发射，存在无法从关卡中动画出来的风险。
- en: 'To fix our player from continuously shooting and being able to be moved at
    the end of the level, we need to do the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止玩家在关卡结束时持续射击和移动，我们需要做以下操作：
- en: In the `Assets/Script` folder and open the `ScenesManager` script.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中打开`ScenesManager`脚本。
- en: 'Inside the `ScenesManager` script, scroll down to the `if` statement that checks
    whether the game has ended (`!gameEnding`) and add the following line of code
    within its `if` statement:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScenesManager`脚本内部，向下滚动到检查游戏是否结束的`if`语句（`!gameEnding`），并在其`if`语句内添加以下代码行：
- en: '[PRE6]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the previous code block, we have added four new lines of code that will
    do the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，我们添加了四行新的代码，它们将执行以下操作：
- en: Cache a reference from our `player_ship` game object
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的`player_ship`游戏对象缓存引用
- en: Access the `player_ship` `true`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`player_ship` `true`
- en: Set the `mobile` `bool` `static` variable to `false`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`mobile` `bool` `static`变量设置为`false`
- en: Run Unity's `CancelInvoke` function to stop all invokes running in our scene
    (stops auto-fire)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Unity的`CancelInvoke`函数来停止场景中正在运行的所有调用（停止自动发射）
- en: Save the `ScenesManager` script.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`ScenesManager`脚本。
- en: 'Now, we need to go into **Input Manager** and look at the **Fire1** button.
    Here, the left mouse button is set to the **Alt Positive Button** property. To
    fix this in the Unity Editor, do the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要进入**输入管理器**并查看**Fire1**按钮。在这里，左鼠标按钮被设置为**Alt Positive Button**属性。为了在Unity编辑器中修复这个问题，请执行以下操作：
- en: Go to **Edit | Project Settings | Input Manager.**
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Edit | Project Settings | Input Manager**。
- en: Set `mouse 0`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`mouse 0`。
- en: Our game is now self-aware of what device it will run on, and if the device
    does run on a mobile Android device, the touch controls will be implemented.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在能够意识到它将在哪种设备上运行，如果设备是在移动的Android设备上运行，则将实现触摸控制。
- en: Now, let's widen the support for our game and ensure our game covers various
    screen ratios and screen boundaries on either platform.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展我们游戏的支持范围，并确保我们的游戏覆盖各个平台上的各种屏幕纵横比和屏幕边界。
- en: Extending screen ratio support
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展屏幕纵横比支持
- en: In this section, we are going to do two things. The first is to make it that
    no matter what aspect ratio our game is running at, our player will be able to
    fly around. The second is to make sure that the Text UI isn't affected by the
    different screen ratios.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将做两件事。第一件事是确保无论游戏运行在什么纵横比下，玩家都能飞来飞去。第二件事是确保文本UI不会受到不同屏幕纵横比的影响。
- en: So, let's start with our first task of making our game support multiple screen
    ratios during levels.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的第一个任务开始，使游戏在关卡期间支持多种屏幕纵横比。
- en: 'In the `Assets/Script` folder and open the `Player` script. Then, follow these
    steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中打开`Player`脚本。然后，按照以下步骤操作：
- en: 'At the top of the script, where the variables are, comment out the width and
    height floats; we are going to replace them:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部，变量所在的位置，注释掉宽度和高度浮点数；我们将用以下内容替换它们：
- en: '[PRE7]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following `GameObject` array to hold our new points:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`GameObject`数组来保存我们的新点：
- en: '[PRE8]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The array we've just added will hold two points to represent our screen's boundaries.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的数组将保存两个点，以表示屏幕的边界。
- en: 'Next, in the `Player` script''s `Start` function, we need to comment out the
    following:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Player`脚本的`Start`函数中，我们需要注释掉以下内容：
- en: '[PRE9]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following method name:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法名称：
- en: '[PRE10]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method we've just entered does not exist yet, so let's add this new method
    now.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才输入的方法还不存在，所以现在让我们添加这个新方法。
- en: 'Still in the `Player` script, add the following method and its content to create
    our new screen''s boundaries:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`Player`脚本中，添加以下方法和其内容以创建我们新的屏幕边界：
- en: '[PRE11]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, let''s go through the steps of the `CalculateBoundaries` method and see
    what it does to our game:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`CalculateBoundaries`方法的步骤来了解它对游戏做了什么：
- en: First, it creates two new game objects and names them `"p1"` and `"p2"`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它创建了两个新的游戏对象，并将它们命名为`"p1"`和`"p2"`。
- en: We then make use of the `ViewportToWorldPoint` function, which will give us
    our game's world space positions for our screen's boundaries.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用`ViewportToWorldPoint`函数，这将为我们提供游戏世界空间位置以用于屏幕的边界。
- en: Then, we apply our new `Vector3` variables, `v1` and `v2`, to our array of game
    object positions – that is, `"p1"` and `"p2"`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将我们的新`Vector3`变量`v1`和`v2`应用于游戏对象位置数组 – 即`"p1"`和`"p2"`。
- en: Now that `"p1"` and `"p2"` represent the boundaries, we need to make them children
    of the `Player` script, which will update their **Transform** **Position** values.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，“p1”和“p2”代表边界，我们需要将它们作为`Player`脚本的子项，这将更新它们的**变换** **位置**值。
- en: Finally, we update the `movingScreen` `float` value with our `screenPoint` value
    for when the game has a moving camera.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们更新`movingScreen` `float`值，以便在游戏有移动摄像机时使用我们的`screenPoint`值。
- en: Continuing with the `Player` script, we now need to update the `Movement` method's
    directional conditions so that they support our new game boundaries.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 继续更新`Player`脚本，我们现在需要更新`Movement`方法的定向条件，以便它们支持我们新的游戏边界。
- en: 'Scroll down to the `Movement` method and replace all four of the old `if` statements
    with the new ones:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`Movement`方法，并将所有四个旧的`if`语句替换为新的语句：
- en: '[PRE12]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of the new `if` statements in the previous lines of code will hold the
    same purpose of taking the value from the `p1` or `p2` game objects to get a restriction
    of the boundaries of the screen. This ensures that the player ship doesn't go
    too far out of view.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中上一行的每个新的`if`语句都将保持相同的目的，即从`p1`或`p2`游戏对象中获取值以获取屏幕边界的限制。这确保了玩家飞船不会飞出视野太远。
- en: 'The following screenshot shows the `level1` scene, with `p1` and `p2` representing
    the new gameplay boundaries in a different resolution from the usual 1,920 x 1,080
    to show the flexibility that our gameplay boundary now has:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了`level1`场景，其中`p1`和`p2`代表以不同于通常的1,920 x 1,080分辨率的新的游戏边界：
- en: '![Figure 13.8 – Our new gameplay boundaries'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.8 – 我们新的游戏边界'
- en: '](img/Figure_13.08_B18381.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.08_B18381.jpg)'
- en: Figure 13.8 – Our new gameplay boundaries
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 我们新的游戏边界
- en: Lastly, we need to update our `PlayerSpeedWithCamera` method and set the `movingScreen`
    variable to zero if the game camera isn't moving to the right.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的`PlayerSpeedWithCamera`方法，并将`movingScreen`变量设置为零，如果游戏摄像机没有向右移动。
- en: 'Inside the `Player` script, go to the `PlayersSpeedWithCamera` method and add
    the following `else` condition:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player`脚本内部，转到`PlayersSpeedWithCamera`方法并添加以下`else`条件：
- en: '[PRE13]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save the `Player` script.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`Player`脚本。
- en: 'Now, let''s move on and look at the second part of this fix. Here, even though
    the gameplay window now supports various aspect ratios, some images and text will
    struggle to look cosmetically pleasing. The following screenshots show what would
    happen to our game''s pause screen if we changed the typical 1,920 x 1,080 resolution:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并查看这个修复的第二部分。在这里，尽管游戏窗口现在支持各种宽高比，但一些图像和文本在视觉上可能难以吸引人。以下截图显示了如果我们更改典型的1,920
    x 1,080分辨率，我们的游戏暂停界面会发生什么：
- en: '![Figure 13.9 – Pause Screen difference in alternative ratios'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.9 – 暂停界面在不同比例下的差异'
- en: '](img/Figure_13.09_B18381.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.09_B18381.jpg)'
- en: Figure 13.9 – Pause Screen difference in alternative ratios
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 暂停界面在不同比例下的差异
- en: 'As you can see, the text and images lose their scale when they''re in different
    aspect ratios. We can fix this by doing the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当文本和图像处于不同的宽高比时，它们会失去其比例。我们可以通过以下方式修复此问题：
- en: In the `Assets/Scene` folder and double-click the `level1` scene.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scene`文件夹中双击`level1`场景。
- en: 'Select the `Canvas` game object in the **Hierarchy** window. Then, in the **Inspector**
    window, change **UI Scale Mode** in **Canvas Scaler** to **Scale** **With Screen
    Size**, as shown in the following screenshot:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`Canvas`游戏对象。然后，在**检查器**窗口中，将**Canvas Scaler**中的**UI Scale Mode**更改为**Scale
    With Screen Size**，如图下所示：
- en: '![Figure 13.10 – Updating the Canvas Scaler | Scale Mode'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.10 – 更新 Canvas Scaler | 缩放模式'
- en: '](img/Figure_13.10_B18381.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.10_B18381.jpg)'
- en: Figure 13.10 – Updating the Canvas Scaler | Scale Mode
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 更新 Canvas Scaler | 缩放模式
- en: Change the `1920` and `1080`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`1920`和`1080`。
- en: Now, our **Game** window, when shown at various screen sizes, will look more
    in proportion.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的**游戏**窗口以各种屏幕尺寸显示时，将看起来更成比例。
- en: '![Figure 13.11 – Our Pause Screen looks more uniform in the other ratios'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.11 – 我们的暂停界面在其他比例下看起来更统一'
- en: '](img/Figure_13.11_B18381.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.11_B18381.jpg)'
- en: Figure 13.11 – Our Pause Screen looks more uniform in the other ratios
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 在其他比例下，我们的暂停屏幕看起来更加统一
- en: Save the `level1` scene and update **Canvas Scaler** for all the scenes in the
    project.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `level1` 场景并更新项目中所有场景的 **Canvas Scaler**。
- en: With that, we've made our game more compatible in that it supports various aspect
    ratios for platforms other than a standard 1,920 x 1,080 resolution. Also, our
    game controls are self-aware of whether the game's being played on a PC or Android
    device. We also made use of the `Touch` struct to move our player around the scene.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经使我们的游戏在兼容性方面更加出色，它支持除标准 1,920 x 1,080 分辨率之外的各种宽高比。此外，我们的游戏控制能够感知游戏是在
    PC 还是 Android 设备上运行。我们还使用了 `Touch` 结构来移动玩家在场景中的位置。
- en: In the next section, we are going to finalize our game for mobile before adding
    extra effects and general polish for the PC build.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在添加额外的效果和针对 PC 构建的通用润色之前，最终确定我们的移动游戏版本。
- en: Preparing to build Killer Wave for mobile
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备为移动设备构建“杀手波浪”
- en: In this section, we will be finalizing our version of Killer Wave for Android.
    Before we build our game to Android, we need to apply some fixes that will only
    be necessary for the Android build.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将完成我们为 Android 开发的“杀手波浪”版本。在我们将游戏构建到 Android 之前，我们需要应用一些仅对 Android 构建必要的修复。
- en: 'The fixes we will be applying in this section are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将应用以下修复：
- en: Adjusting the lighting so that it suits our Android device
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整照明以适应我们的 Android 设备
- en: Making it that when pressing the pause button, our ship doesn't move to its
    location
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按下暂停按钮时，确保我们的飞船不会移动到其位置
- en: Making it that our game stays in landscape mode
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的游戏保持在横幅模式
- en: Stopping the screen from dimming when the device hasn't been touched for a while
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设备一段时间未被触摸时，停止屏幕变暗
- en: Setting the game textures to a lower resolution
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将游戏纹理设置为较低的分辨率
- en: Adding a prefab explosion to enemies and players
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为敌人和玩家添加预制爆炸效果
- en: After we've applied these minor fixes, we will build the game for our Android
    device.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用这些小修复后，我们将为我们的 Android 设备构建游戏。
- en: So, let's get started with our first task by altering the lighting.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过调整照明来开始我们的第一个任务。
- en: Setting up the lighting for Killer Waves for Android
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Android 版本的“杀手波浪”设置照明
- en: Each scene that contains a 3D model will require lighting to be generated. The
    Unity Editor's lighting will differ from the lighting provided on an Android device.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包含 3D 模型的场景都需要生成照明。Unity 编辑器的照明将与 Android 设备上提供的照明不同。
- en: 'With the current default lighting settings applied, the following screenshot
    shows the difference between both platforms. The image on the left was taken on
    a PC, while the one on the right was taken from a mobile device:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用当前默认照明设置后，以下截图显示了两个平台之间的差异。左边的图像是在 PC 上拍摄的，而右边的图像是从移动设备上拍摄的：
- en: '![Figure 13.12 – The difference in lighting between platforms'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.12 – 平台之间照明的差异'
- en: '](img/Figure_13.12_B18381.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.12_B18381.jpg]'
- en: Figure 13.12 – The difference in lighting between platforms
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 – 平台之间照明的差异
- en: 'So, let''s adjust the lighting so that both platforms have a similar level
    of brightness and contrast:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们调整照明，以便两个平台具有相似的亮度和对比度：
- en: At the top of the Unity Editor, go to **Window** | **Lighting** | **Settings**.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的顶部，转到**窗口** | **照明** | **设置**。
- en: 'Press the **Environment** button at the top of the **Lighting** window and
    apply the following values:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**照明**窗口的顶部按下**环境**按钮，并应用以下值：
- en: '![Figure 13.13 – The updated values for the "Lighting" windows properties'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.13 – “照明”窗口属性的更新值'
- en: '](img/Figure_13.13_B18381.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.13_B18381.jpg]'
- en: Figure 13.13 – The updated values for the "Lighting" windows properties
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – “照明”窗口属性的更新值
- en: Next click on the **Scene** tab. At the top of the window click on the **New
    Lighting Settings** button. Untick **Realtime Global Illumination** and **Baked
    Global Illumination**.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来点击**场景**标签。在窗口顶部点击**新建照明设置**按钮。取消选中**实时全局照明**和**烘焙全局照明**。
- en: We will cover these two settings when we apply visual improvements, but for
    now, **Realtime Global Illumination** affects the indirect lighting that's applied
    to other objects to help create a more realistic, soft-colored light. **Baked
    Global Illumination** will have lights stuck on 3D assets to give the appearance
    of light shining on a surface, but the majority of our lights move, so this will
    not work as a baked light.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用视觉改进时，我们将涵盖这两个设置，但到目前为止，**实时全局照明**会影响应用于其他对象的间接照明，以帮助创建更真实、柔和颜色的光。**烘焙全局照明**将灯光固定在3D资产上，以产生光照在表面上闪耀的外观，但我们的大多数灯光都在移动，所以这不会像烘焙光那样工作。
- en: 'The following screenshots now show that the PC and mobile versions are starting
    to look similar:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图现在显示，PC和移动端版本开始看起来相似：
- en: '![Figure 13.14 – PC versus Mobile lighting now looks similar'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.14 – PC与移动端光照现在看起来相似'
- en: '](img/Figure_13.14_B18381.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.14_B18381.jpg)'
- en: Figure 13.14 – PC versus Mobile lighting now looks similar
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – PC与移动端光照现在看起来相似
- en: 'Now, we need to enable and adjust the emission of the following enemy materials
    in the `Assets/Material`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在`Assets/Material`中启用并调整以下敌人材质的发射：
- en: '`basicEnemyShip_Inner`: `993600 (Hex)`, and `0.6`'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basicEnemyShip_Inner`: `993600 (Hex)`, 和 `0.6`'
- en: '`basicEnemyShip_Outer`: `4C0000(Hex)`, and `0.3`'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basicEnemyShip_Outer`: `4C0000(Hex)`, 和 `0.3`'
- en: '`darkRed`: `801616(Hex)`, and `0.5`'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`darkRed`: `801616(Hex)`, 和 `0.5`'
- en: 'We explained how to change the emission of a material back in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,
    Adding and Manipulating Objects*. Changing these values will give us the following
    output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)*，添加和管理对象*中解释了如何更改材质的发射。更改这些值将给出以下输出：
- en: '![Figure 13.15 – PC versus Mobile; both lighting and colors look near enough
    the same'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.15 – PC与移动端；光照和颜色几乎相同'
- en: '](img/Figure_13.15_B18381.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.15_B18381.jpg)'
- en: Figure 13.15 – PC versus Mobile; both lighting and colors look near enough the
    same
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 – PC与移动端；光照和颜色几乎相同
- en: Our game now looks nice and bright on either platform. Next, we'll fix the small
    issue with pausing the mobile version of the game.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏在任一平台上看起来都很漂亮且明亮。接下来，我们将修复移动端游戏暂停的小问题。
- en: Stopping involuntary player controls
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止非自愿玩家控制
- en: When it comes to playing the game on a mobile device, we will want to press
    the pause button. But if and when we do, the game will also consider the press
    as a movement command, and the player's ship will move into the top-left corner
    where the press was made.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当在移动设备上玩游戏时，我们希望按下暂停按钮。但如果我们按下，游戏也会将按下视为移动命令，玩家的飞船将移动到按下位置的上左角。
- en: 'So, to fix this minor issue, we will apply an extra condition to our `MobileControls`
    method, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了修复这个小问题，我们将在`MobileControls`方法中应用一个额外的条件，如下所示：
- en: In the `Assets/Script` folder and open the `Player` script.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中打开`Player`脚本。
- en: 'Inside the `Player` script, scroll down to the `MobileControls` method and
    replace the current `if` statement condition with the following one:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player`脚本内部，向下滚动到`MobileControls`方法，并将当前的`if`语句条件替换为以下内容：
- en: '[PRE14]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code block will run a check to see whether a finger is touching
    the screen as before but will also check that there isn't a game object in the
    location when being pressed. If any of these conditions aren't met, then the player
    will not move.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块将运行一个检查，看看是否有手指触摸屏幕，就像之前一样，但也会检查在按下时该位置没有游戏对象。如果这些条件中的任何一个不满足，那么玩家将不会移动。
- en: 'Finally, to import `EventSystem`, scroll to the top of the `Player` script
    and add the following namespace:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了导入`EventSystem`，滚动到`Player`脚本顶部并添加以下命名空间：
- en: '[PRE15]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the `Player` script.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`Player`脚本。
- en: In the next section, we will do some final texture optimizations and apply a
    ready-made and well-earned explosion prefab.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进行一些最终的纹理优化，并应用一个现成的、应得的爆炸预制体。
- en: Final optimizations for Killer Wave
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杀手波浪的最终优化
- en: In this section, we will be adding some optimization to our mobile version of
    the game by reducing the size of the textures. We will also add explosions to
    our enemies and player.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过减少纹理大小来对我们的游戏移动端进行一些优化。我们还将为敌人和玩家添加爆炸效果。
- en: Let's start by reducing our textures and compressing them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从减少纹理大小并压缩它们开始。
- en: Reducing texture sizes and compression
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少纹理大小和压缩
- en: To reduce the size of the `.apk` file that gets installed on Android devices,
    as well as the overall performance increase, we can reduce the size of the textures
    of our game through Unity and also apply compression, which lowers the size even
    more.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减小安装在Android设备上的`.apk`文件的大小，以及提高整体性能，我们可以通过Unity减小游戏纹理的大小，并应用压缩，这进一步降低了大小。
- en: The trick is to reduce the size of the texture but not too much; otherwise,
    the textures themselves will begin to blur and look cheap.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是减小纹理的大小，但不要过度；否则，纹理本身将会开始模糊，看起来很廉价。
- en: 'In this section, we will be reducing the texture sizes of the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将减小以下纹理的大小：
- en: '`PlayerShip` and its extras (shop upgrades and thrusters)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShip`及其附加组件（商店升级和推进器）'
- en: The background wallpaper texture of the stars in our two levels
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们两个级别中星星的背景壁纸纹理
- en: Shop button icons
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店按钮图标
- en: 'Let''s start by selecting and reducing the player ship''s texture sizes and
    compressing them:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先选择并减小玩家飞船的纹理大小，并压缩它们：
- en: In the `Assets/Texture` folder.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Texture`文件夹中。
- en: 'Select all of the following filenames:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择以下所有文件名：
- en: '`playerShip_diff`'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerShip_diff`'
- en: '`playerShip_em`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerShip_em`'
- en: '`playerShip_met`'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerShip_met`'
- en: '`playerShip_nrm`'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerShip_nrm`'
- en: '`playerShip_oc`'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerShip_oc`'
- en: 'All these files have a texture size of 512 x 512, so let''s reduce them to
    256 x 256, compress them, and turn off any filtering by setting them to the values
    shown in the following screenshot of the **Inspector** window:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些文件都具有512 x 512的纹理大小，所以让我们将它们减小到256 x 256，压缩它们，并通过将它们设置为以下**检查器**窗口截图中的值来关闭任何过滤：
- en: '![Figure 13.16 – Reduce the texture size from 512 x 512 to 256 x 256'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.16 – 将纹理大小从512 x 512减小到256 x 256'
- en: '](img/Figure_13.16_B18381.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.16_B18381.jpg)'
- en: Figure 13.16 – Reduce the texture size from 512 x 512 to 256 x 256
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 – 将纹理大小从512 x 512减小到256 x 256
- en: 'Do the same to the following textures, all of which can be in the same folder.
    However, this time, set the texture size from 1,024 x 1,024 all the way down to
    64 x 64:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下纹理做同样的处理，所有这些纹理都可以放在同一个文件夹中。然而，这次，将纹理大小从1,024 x 1,024全部降低到64 x 64：
- en: '`b. Shot_diff`'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b. Shot_diff`'
- en: '`b. Shot_nrm`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b. Shot_nrm`'
- en: '`c. Bomb_diff`'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c. Bomb_diff`'
- en: '`c. Bomb_nrm`'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c. Bomb_nrm`'
- en: Continue doing this for the rest of the textures, and see what the results look
    like in the game by playing between the `shop` and `level1` scenes. Do this at
    your own discretion.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 继续对其他纹理做同样的处理，并通过在`shop`和`level1`场景之间进行游戏来查看游戏中的结果。请自行决定是否这样做。
- en: Further Information
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about the textures that get imported into a
    project and how to adjust their quality levels, check out the following link:
    [https://docs.unity3d.com/Manual/ImportingTextures.html](https://docs.unity3d.com/Manual/ImportingTextures.html).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于导入到项目中的纹理以及如何调整它们的质量级别，请查看以下链接：[https://docs.unity3d.com/Manual/ImportingTextures.html](https://docs.unity3d.com/Manual/ImportingTextures.html)。
- en: Now, let's move on and add a ready-made particle explosion to each of our players
    and enemies by making some minor scripting tweaks.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进，通过一些小的脚本调整，为我们的每个玩家和敌人添加一个现成的粒子爆炸效果。
- en: Adding explosions to our players and enemies
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的玩家和敌人添加爆炸效果
- en: The time has come to add a prefab explosion to our game objects to represent
    their destruction and their general effect on the boss when they are being shot
    at. We covered particle systems back in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087),
    *Applying Art, Animation, and Particles*. Here, we will apply some scripting so
    that when a `Die` method is called, we will instantiate our `explode` prefab.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给我们的游戏对象添加一个预制爆炸效果，以表示它们在被射击时的破坏以及它们对Boss的一般影响。我们之前在[*第4章*](B18381_04_Epub.xhtml#_idTextAnchor087)中介绍了粒子系统，*应用艺术、动画和粒子*。在这里，我们将应用一些脚本，以便当调用`Die`方法时，我们将实例化我们的`explode`预制体。
- en: 'To instantiate the explode prefab when an enemy dies, we need to do the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在敌人死亡时实例化爆炸预制体，我们需要做以下操作：
- en: In the `Assets/Script` folder and open the `EnemyWave` script.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中打开`EnemyWave`脚本。
- en: 'Inside the `Die` method, replace its content with the following to instantiate
    the `explode` game object:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Die`方法内部，将其内容替换为以下内容以实例化`explode`游戏对象：
- en: '[PRE16]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous code block, we added two extra lines above the current `Destroy`
    function. We covered this in detail in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*. The two extra lines do the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们在当前的 `Destroy` 函数上方添加了两行额外的代码。我们已经在 [*第 2 章*](B18381_02_Epub.xhtml#_idTextAnchor048)，*添加和操作对象*
    中详细介绍了这一点。这两行额外的代码执行以下操作：
- en: When the `Die` method runs, it will create the `explode` prefab from `Assets/Prefab`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `Die` 方法运行时，它将从 `Assets/Prefab` 创建 `explode` 预制件。
- en: The position of the `explode` instance is updated with the same location as
    the enemies.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`explode` 实例的位置更新为与敌人相同的地点。'
- en: Save the `EnemyWave` script and repeat this process for the `EnemyFlee` and
    `BossScript` scripts.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `EnemyWave` 脚本，并重复此过程对 `EnemyFlee` 和 `BossScript` 脚本进行操作。
- en: Finally, for our `Player`, we will add something similar but also add a delay
    for when `player_ship` gets destroyed so that we can see the explosion before
    we reload the scene again.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的 `Player`，我们将添加类似的东西，但也会为 `player_ship` 被销毁时添加一个延迟，这样我们就可以在重新加载场景之前看到爆炸效果。
- en: 'Still in the same `Player` script, scroll down to the `Die` method, and replace
    its content with the following:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在同一 `Player` 脚本中，向下滚动到 `Die` 方法，并用以下内容替换其内容：
- en: '[PRE17]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code, we have updated the player's `Die` method so that it creates
    a prefab explosion and houses its position where the player's position is.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经更新了玩家的 `Die` 方法，使其创建一个预制件爆炸，并将其位置放在玩家位置处。
- en: However, we need to add a delay in the `GameManager` script where the previous
    code block was introduced.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要在 `GameManager` 脚本中添加一个延迟，在之前代码块引入的地方。
- en: Save the `Player` script before continuing with the `GameManager` script.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续 `GameManager` 脚本之前，保存 `Player` 脚本。
- en: Open the `GameManager` script so that you can add a delay to the scene when
    it's updated.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameManager` 脚本，以便在场景更新时添加延迟。
- en: 'In the `GameManager` script, scroll down to the `LifeLost` method, select its
    content, *Cut* it (cut, not *Delete*, as we are going to paste it somewhere else),
    and replace the `LifeLost` method with the following code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameManager` 脚本中，向下滚动到 `LifeLost` 方法，选择其内容，*剪切*它（剪切，而不是 *删除*，因为我们将要将其粘贴到其他地方），并用以下代码替换
    `LifeLost` 方法：
- en: '[PRE18]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are delaying the content from our `LifeLost` method. However, here,
    we will be using `StartCoroutine` to create the delay, as shown in the previous
    line of code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在延迟 `LifeLost` 方法的内容。然而，在这里，我们将使用 `StartCoroutine` 来创建延迟，如前一行代码所示。
- en: 'Next, we will paste the content from the original `LifeLost` method inside
    the following code block:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把原始 `LifeLost` 方法的内容粘贴到下面的代码块中：
- en: '[PRE19]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code block, we have added `IEnumerator`. This will be executed
    from `StartCoroutine`, along with a 2-second wait. If your `IEnumerator` has an
    error underlined in the IDE. Add the library `using System.Collections`; at the
    top of the script.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们添加了 `IEnumerator`。这将通过 `StartCoroutine` 执行，并等待 2 秒。如果你的 `IEnumerator`
    在 IDE 中有下划线错误，请在脚本顶部添加库 `using System.Collections`。
- en: Paste in the `LifeLost` content we cut earlier and then save the `GameManager`
    script.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前剪切的 `LifeLost` 内容粘贴进来，然后保存 `GameManager` 脚本。
- en: 'The following screenshot shows our game object with particle explosions applied:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用了粒子爆炸的游戏对象：
- en: '![Figure 13.17 – Particle Effects'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.17 – 粒子效果'
- en: '](img/Figure_13.17_B18381.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.17_B18381.jpg)'
- en: Figure 13.17 – Particle Effects
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17 – 粒子效果
- en: Now, the time has come to create a build of our Android platform.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建安卓平台的构建了。
- en: Setting up the build settings for Android
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置安卓的构建设置
- en: In this section, we are going to set up our **Player Settings** and build our
    Unity Project for an Android device. For testing purposes, I will be using a fairly
    old tablet and a recent phone to see whether there are any differences in terms
    of the setup between the two devices.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置我们的**玩家设置**并构建适用于安卓设备的 Unity 项目。为了测试目的，我将使用一款相当旧的平板电脑和一部最新的手机来查看这两款设备在设置方面是否存在任何差异。
- en: 'Before setting up our **Player Settings**, ensure you have copies of the Java
    Development Kit and Android SDK installed. To check this, do the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们的**玩家设置**之前，请确保您已安装 Java 开发工具包和安卓软件开发工具包。为此，请执行以下操作：
- en: At the top of the Unity Editor, go to **Edit** | **Preferences**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的顶部，转到 **Edit** | **Preferences**。
- en: Then, click on **External Tools** in the **Unity Preferences** window.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **Unity Preferences** 窗口中点击 **External Tools**。
- en: The following screenshot shows these two development kits, along with **Download**
    buttons for them. If you don't have either, these can be installed via the Unity
    Hub, which we covered in [*Chapter 1*](B18381_01_Epub.xhtml#_idTextAnchor016)*,
    Setting Up and Structuring Our Project*.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了这两个开发工具包，以及它们的**下载**按钮。如果你没有其中任何一个，可以通过Unity Hub安装，我们已在[*第1章*](B18381_01_Epub.xhtml#_idTextAnchor016)*，设置和构建我们的项目*中介绍过。
- en: '![Figure 13.18 – Both Development Kits are installed'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.18 – 两个开发工具包都已安装'
- en: '](img/Figure_13.18_B18381.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.18_B18381.jpg)'
- en: Figure 13.18 – Both Development Kits are installed
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 – 两个开发工具包都已安装
- en: Further Information
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you require any more specific information about the development kit installation
    process, check out the following link: [https://docs.unity3d.com/Manual/Preferences.html](https://docs.unity3d.com/Manual/Preferences.html).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要有关开发工具包安装过程的更多具体信息，请查看以下链接：[https://docs.unity3d.com/Manual/Preferences.html](https://docs.unity3d.com/Manual/Preferences.html)。
- en: 'Now, let''s continue to **Player Settings** and set up our game:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到**玩家设置**并设置我们的游戏：
- en: At the top of the Unity Editor, go to **File** | **Build Settings…**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，转到**文件** | **构建设置…**。
- en: Make sure you have all of the scenes set up in **Scenes In Build**.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有场景都已设置在**构建中的场景**中。
- en: Select **Android** from the **Platform** list and click **Switch Platform**.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**平台**列表中选择**Android**，然后点击**切换平台**。
- en: '![Figure 13.19 – In Build Settings, select "Android" and then "Switch Platform"'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.19 – 在构建设置中，选择“Android”然后选择“切换平台”'
- en: '](img/Figure_13.19_B18381.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.19_B18381.jpg)'
- en: Figure 13.19 – In Build Settings, select "Android" and then "Switch Platform"
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 – 在构建设置中，选择“Android”然后选择“切换平台”
- en: Click **Player Settings...** to move on to the next stage of setting up for
    Android.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**玩家设置...**以进入Android设置的下一阶段。
- en: In the **Inspector** window, at the top of the window, update the **Company
    Name** and **Product Name** fields to whatever you wish.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的顶部，更新**公司名称**和**产品名称**字段为你想要的任何内容。
- en: Select the **Resolution and Presentation** tab and untick **Portrait** and **Portrait
    Upside Down**.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**分辨率和显示**选项卡，取消选中**纵向**和**纵向颠倒**。
- en: Select the **Other Settings** tab.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**其他设置**选项卡。
- en: 'Scroll down to the **Identification** section. In the following screenshot,
    you will see the **Package Name** field is filled out with our company name and
    product name (**com.Packt.KillerWave**):'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**标识**部分。在以下截图中，你会看到**包名**字段已填写我们的公司名称和产品名称（**com.Packt.KillerWave**）：
- en: '![Figure 13.20 – Adding our package name in the ''Identification'' section
    (Player Settings)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.20 – 在玩家设置的“标识”部分添加我们的包名'
- en: '](img/Figure_13.20_B18381.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.20_B18381.jpg)'
- en: Figure 13.20 – Adding our package name in the 'Identification' section (Player
    Settings)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 – 在玩家设置的“标识”部分添加我们的包名
- en: Also, set **Minimum API Level** to **23** or above if your device can handle
    it. If it can't, when we go to build, you will receive an error in the **Console**
    window regarding changing the **Minimum API Level** value.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果你的设备可以处理，请将**最小API级别**设置为**23**或更高。如果不行，当我们进行构建时，你将在**控制台**窗口中收到有关更改**最小API级别**值的错误。
- en: Go back to the **Build Settings** window and click the **Build** button.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**构建设置**窗口，并点击**构建**按钮。
- en: You will be asked to give `apk` a name and location. Pick wherever and whatever
    you want to name the file and click **Save**.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被要求为`apk`命名和指定位置。选择你想要的位置和文件名，然后点击**保存**。
- en: Tips
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you get a **Gradle build failed** error, try changing **Build System** in
    the **Build Settings** window to **Internal**.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你遇到**Gradle构建失败**错误，尝试在**构建设置**窗口中将**构建系统**更改为**内部**。
- en: Finally, ensure you have your Android device in USB debugging mode and copy
    `apk` over to the device.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保你的Android设备处于USB调试模式，并将`apk`复制到设备上。
- en: Go to the location where `apk` has been copied on the device and select it to
    install and run it.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往设备上已复制`apk`的位置，选择它以安装和运行。
- en: Tip
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: When testing the game on an Android device, you may find it distracting that
    your device's brightness dims when the screen isn't being touched.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Android设备上测试游戏时，你可能会发现当屏幕未被触摸时，设备的亮度变暗可能会分散你的注意力。
- en: 'We can fix this by adding the following code, ideally in the `Awake` function
    of the `GameManager` script, as this relates to the game''s overall interaction:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过添加以下代码来修复这个问题，最好是在`GameManager`脚本的`Awake`函数中，因为这关系到游戏的整体交互：
- en: '`#if UNITY_ANDROID`'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#if UNITY_ANDROID`'
- en: '`Screen.sleepTimeout = SleepTimeout.NeverSleep;`'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Screen.sleepTimeout = SleepTimeout.NeverSleep;`'
- en: '`#endif`'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#endif`'
- en: This brings us to the end of building our game for mobile. In this section,
    we covered setting up our lighting settings so that they matched what we were
    seeing in the Unity Editor. After that, we cleared up some small fixes so that
    we wouldn't unintentionally move the player ship to where the pause button is
    when we press it on our device. We also reduced the size of our `apk` by reducing
    the size of the textures for our game. This also helps with the performance of
    Android devices when they're playing our game. Then, we added our `explode` prefab
    and made some fixes to our script to instantiate our explosions in the right place
    at the right time.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们完成了为移动设备构建游戏的过程。在本节中，我们涵盖了设置我们的光照设置，以确保它们与我们在Unity编辑器中看到的一致。之后，我们清理了一些小问题，以免我们在设备上按下暂停按钮时不小心将玩家飞船移动到暂停按钮的位置。我们还通过减小游戏纹理的大小来减小我们的`apk`大小。这也帮助了Android设备在玩游戏时的性能。然后，我们添加了我们的`explode`预制体，并对我们的脚本进行了一些修改，以确保在正确的时间和地点实例化爆炸。
- en: Finally, we went through the procedure of setting up our Unity build file and
    copied it over to the Android device so that it can be installed and run.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了设置我们的Unity构建文件的过程，并将其复制到Android设备上，以便安装和运行。
- en: Congratulations if you have made it this far, built the game, and everything
    works as expected! If not, or you met some issues along the way, don't worry –
    other Unity users will have had similar problems, and the solutions to them aren't
    too hard to find with some Googling. Now, we will start bug-testing our game.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经走到这一步，构建了游戏，并且一切如预期般工作，那么恭喜您！如果没有，或者您在过程中遇到了一些问题，请不要担心——其他Unity用户可能遇到过类似的问题，通过一些谷歌搜索就能找到它们的解决方案。现在，我们将开始对游戏进行故障测试。
- en: '![Figure 13.21 – Killer Wave running on an old tablet'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.21 – 在旧平板上运行的Killer Wave'
- en: '](img/Figure_13.21_B18381.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.21_B18381.jpg)'
- en: Figure 13.21 – Killer Wave running on an old tablet
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21 – 在旧平板上运行的Killer Wave
- en: In the next section, we'll apply polish and shine to our PC version.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为我们的PC版本添加光泽和光泽。
- en: Applying PC visual improvements
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用PC视觉改进
- en: In this section, we are going to focus on the PC version, where we will have
    more leg room to apply effects, as it's likely the PC playing this game will be
    more powerful than a mobile device.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于PC版本，我们将有更多的空间来应用效果，因为很可能玩这款游戏的PC将比移动设备更强大。
- en: We will cover things such as post-processing, where we can create pretty effects
    to make our game shine even more. We can do this by applying effects such as blur
    motion, blurring to the edges of the screen, bending the screen to give it a dome
    screen effect, and altering the coloring.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖诸如后处理等内容，通过它我们可以创建一些漂亮的效果，使我们的游戏更加闪耀。我们可以通过应用如模糊运动、模糊屏幕边缘、弯曲屏幕以产生穹顶屏幕效果以及改变色彩来实现这一点。
- en: We'll also be taking a look at lighting and reflections so that we have a slightly
    modified shop scene that will hold multiple lights and make the game stand out
    more. In the `level3` scene, we will be adding reflective assets to show off the
    use of these reflection probes on our art assets.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看光照和反射，以便我们有一个稍微修改过的商店场景，它将包含多个光源并使游戏更加突出。在`level3`场景中，我们将添加反射资产以展示这些反射探针在我们艺术资产中的应用。
- en: Let's start by discussing post-processing.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来讨论一下后处理。
- en: Post-processing
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后处理
- en: In this section, we will be installing and applying post-processing effects
    to our game. This will provide us with effects that are used in films, such as
    film grain, chromatic abbreviation, color grading, and lens distortion. Let's
    make a start by installing this package into our project.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装并应用后处理效果到我们的游戏中。这将为我们提供在电影中使用的效果，例如胶片颗粒、色差、色彩分级和镜头畸变。让我们从将此包安装到我们的项目中开始吧。
- en: Installing post-processing
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装后处理
- en: '**Post Processing** is installed via the **Package Manager** directly into
    our project. In the previous chapter, we installed **Default Playables** in a
    similar way. This time, we won''t be going to the Asset Store; we can download
    and install **Post Processing** from **Packages: Unity Registry**.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**后处理**通过**包管理器**直接安装到我们的项目中。在前一章中，我们以类似的方式安装了**默认可播放内容**。这次，我们不会去资产商店；我们可以从**包：Unity注册表**下载并安装**后处理**。'
- en: 'The following steps will take you through the process of installing **Post
    Processing** in the project:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您在项目中安装**后处理**的过程：
- en: In the Unity Editor at the top, click **Window** | **Package Manager**.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，点击**窗口** | **包管理器**。
- en: 'At the top-left corner of the **Package Manager** window, change its dropdown
    to **Packages: Unity Registry**.'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**包管理器**窗口的左上角，将其下拉菜单更改为**包：Unity 注册表**。
- en: A long list of packages will be displayed; from the list, either scroll down
    and select `Post Processing` into it.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示一个长长的包列表；从列表中，你可以向下滚动并选择将其中的`Post Processing`选中。
- en: Finally, click **Install** at the bottom-right corner.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在右下角点击**安装**。
- en: 'The following screenshot shows **Package Manager** with **Post Processing**
    selected:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了已选择**Post Processing**的**包管理器**：
- en: '![Figure 13.22 – The Package Manager with Post Processing selected to install'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.22 – The Package Manager with Post Processing selected to install'
- en: '](img/Figure_13.22_B18381.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.22_B18381.jpg]'
- en: Figure 13.22 – The Package Manager with Post Processing selected to install
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22 – 选择带有后处理的包管理器以安装
- en: At the top of the Unity Editor, go to **File** | **Build Settings...**.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，转到**文件** | **构建设置...**。
- en: Select **PC, Mac & Linux Standalone**, followed by **Switch Platform**.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**PC, Mac & Linux 独立版**，然后选择**切换平台**。
- en: Our Unity project now has post-processing installed. With that, we can begin
    preparing some scenes for our standalone game.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目现在已安装了后处理。有了这个，我们可以开始为我们的独立游戏准备一些场景。
- en: Preparing and applying post-processing to our title and level scenes
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备并应用后处理到我们的标题和关卡场景
- en: 'In this section, we are going to make some changes to our `title` scene so
    that it supports our image and text being affected by post-processing. By the
    end of this section, our `title` scene will look more impressive, as shown in
    the following screenshots:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对我们的`title`场景进行一些更改，以便它支持我们的图像和文本受到后处理的影响。本节结束时，我们的`title`场景将看起来更加引人注目，如下面的截图所示：
- en: '![Figure 13.23 – Difference between post-processing and not'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.23 – Difference between post-processing and not'
- en: '](img/Figure_13.23_B18381.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.23_B18381.jpg]'
- en: Figure 13.23 – Difference between post-processing and not
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.23 – 后处理与未后处理的区别
- en: 'To apply post-processing to our `title` scene, we need to do the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要将后处理应用到我们的`title`场景，我们需要执行以下操作：
- en: In the `Assets/Scene` and open `title`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scene`中打开`title`。
- en: We now need to change some property values in the `Canvas` game object so that
    the post-processing changes come from the camera's feed, not just the `Canvas`
    itself.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要更改`Canvas`游戏对象的一些属性值，以便后处理更改来自摄像机的输入，而不仅仅是`Canvas`本身。
- en: In the `Canvas` game object.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Canvas`游戏对象中。
- en: In the `Canvas` component property's **Render Mode** option to **Screen Space
    - Camera.**
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Canvas**组件属性的**渲染模式**选项中选择**屏幕空间 - 相机**。
- en: Drag **Main Camera** from the **Hierarchy** window into the **Render Camera**
    property field.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Main Camera**从**层次结构**窗口拖动到**渲染相机**属性字段。
- en: Next, we will add two post-processing components to our **Main Camera** game
    object.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的**Main Camera**游戏对象添加两个后处理组件。
- en: Select **Main Camera** in the **Hierarchy** window.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**主相机**。
- en: Click the **Add Component** button in the **Inspector** window.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中点击**添加组件**按钮。
- en: Type `Post Process Layer` into the drop-down list. When you see its name in
    the list, select it.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中输入`Post Process Layer`。当你在列表中看到它的名字时，选择它。
- en: In the `PostProcessing` and change **Everything** to **PostProcessing** to remove
    the warning message in the **Post Processing Layer** component.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostProcessing`中，将**Everything**更改为**PostProcessing**以移除**Post Processing
    Layer**组件中的警告信息。
- en: Click the `Post Process Volume` until you see it on the list. Then, select it.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Post Process Volume`直到它在列表中可见。然后，选择它。
- en: At the top of the **Post Process Volume** component, tick the **Is Global**
    box.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Post Process Volume**组件的顶部，勾选**全局**框。
- en: In the `Assets/Scene` folder into the **Profile** parameter in the **Inspector**
    window.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scene`文件夹中，在**检查器**窗口的**Profile**参数中。
- en: The **Game** window will have the **Profile** post-processing effect applied
    to it, which may or may not be too extreme for you. We can set **Weight** from
    **1** all the way down to **0**. I'm setting mine to **0.6**.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Game**窗口将应用**Profile**后处理效果，这可能对你来说可能过于极端。我们可以将**权重**从**1**调整到**0**。我将我的设置为**0.6**。'
- en: 'The following screenshot shows our title scene **Game** window, along with
    the two **Post Process Layer** and **Post Process Volume** components and the
    highlighted areas mentioned in the previous steps for reference:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的标题场景**Game**窗口，以及之前步骤中提到的两个**Post Process Layer**和**Post Process Volume**组件以及突出显示的区域，供参考：
- en: '![Figure 13.24 – Post Processing components (on the Main Camera game object)
    with the property values changed](img/Figure_13.24_B18381.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图13.24 – 属性值已更改的**主相机**游戏对象上的后处理组件](img/Figure_13.24_B18381.jpg)'
- en: Figure 13.24 – Post Processing components (on the Main Camera game object) with
    the property values changed
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24 – 属性值已更改的后处理组件（在主相机游戏对象上）](img/Figure_13.24_B18381.jpg)
- en: Save the scene.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'Repeat *steps 2–12* for the `shop` scene, but instead of applying the `shop`
    scene before and after post-processing has been applied (with the **Weight** property
    set to **1**), also if your camera background isn''t set to black. Change it to
    black now.:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`shop`场景重复*步骤2–12*，但不是在应用后处理之前和之后（将**权重**属性设置为**1**），如果你的相机背景没有设置为黑色，现在将其设置为黑色：
- en: '![Figure 13.25 – Post-processing effects applied and not applied to our shop
    scene'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.25 – 应用和未应用后处理效果的我们的商店场景'
- en: '](img/Figure_13.25_B18381.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.25_B18381.jpg)'
- en: Figure 13.25 – Post-processing effects applied and not applied to our shop scene
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25 – 应用和未应用后处理效果的我们的商店场景
- en: 'Now, repeat *steps 2–13* for the `gameOver` scene. The end result should look
    similar to the following:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重复*步骤2–13*为`gameOver`场景。最终结果应类似于以下内容：
- en: '![Figure 13.26 – The Game Over screen with Post Processing Effects applied'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.26 – 应用后处理效果的游戏结束屏幕'
- en: '](img/Figure_13.26_B18381.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.26_B18381.jpg)'
- en: Figure 13.26 – The Game Over screen with Post Processing Effects applied
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 – 应用后处理效果的游戏结束屏幕
- en: Repeat *steps 5–13*, but instead of applying the **TEXT** post-processing profile,
    add the **DEFAULT** post-processing profile.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤5–13*，但不是应用**文本**后处理配置文件，而是添加**默认**后处理配置文件。
- en: 'The following image shows an example of the `level3` scene with and without
    the **DEFAULT** post-processing profile applied:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了应用和未应用**默认**后处理配置文件的`level3`场景示例：
- en: '![Figure 13.27 – Game screens with no post-processing applied and post-processing
    applied'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.27 – 未应用和已应用后处理的游戏屏幕'
- en: '](img/Figure_13.27_B18381.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.27_B18381.jpg)'
- en: Figure 13.27 – Game screens with no post-processing applied and post-processing
    applied
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 – 未应用和已应用后处理的游戏屏幕
- en: That's all of the scenes we need to implement for a post-processing profile.
    In the next section, we will briefly go through each of the effects that we have
    and can apply.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要实现后处理配置文件的所有场景。在下一节中，我们将简要介绍我们可以应用的所有效果。
- en: Post-processing effects (overrides)
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后处理效果（覆盖）
- en: In this section, we are briefly going to discuss the effects the post-processing
    package offers us. By the end of this section, you will be more familiar with
    the effects and be able to make your own post-processing profile.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论后处理包为我们提供的功能。到本节结束时，你将更加熟悉这些效果，并能够创建自己的后处理配置文件。
- en: 'Now that we''ve seen what post-processing does to our game, we can talk about
    each of the effects. Let''s start by loading up the `title` scene and altering
    what we have:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了后处理对我们游戏的影响，我们可以讨论每个效果。让我们先加载`title`场景并更改我们已有的内容：
- en: In the `Assets/Scene` folder and load up the `title` scene.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scene`文件夹中加载`title`场景。
- en: Select **Main Camera** in the **Hierarchy** window.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中选择**主相机**。
- en: 'Our main focus for this section will be the **Overrides** section in the **Post-process
    Volume** component:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要关注点将是**后处理体积**组件中的**覆盖**部分：
- en: '![Figure 13.28 – The ''Bloom'', ''Chromatic Aberration'', and ''Color Grading''
    locations in the Post Process Volume Component](img/Figure_13.28_B18381.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![图13.28 – 后处理体积组件中的‘Bloom’，‘色差’和‘色彩分级’位置](img/Figure_13.28_B18381.jpg)'
- en: Figure 13.28 – The 'Bloom', 'Chromatic Aberration', and 'Color Grading' locations
    in the Post Process Volume Component
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 – 后处理体积组件中的‘Bloom’，‘色差’和‘色彩分级’位置
- en: So, let's go through some of these **Overrides** for **Post Process Volume**
    in the **Inspector** window. Then, I will provide a link that I encourage you
    to explore so that you can play around with some of the values.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们查看**检查器**窗口中的一些**后处理体积**的**覆盖**设置。然后，我将提供一个链接，我鼓励你探索，以便你可以玩一些值。
- en: Bloom
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Bloom
- en: This effect creates fringes of light extending from the borders of bright areas
    in an image.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果在图像中明亮区域的边缘创建光晕。
- en: 'We can extend the content by selecting the arrow to the left of the **Bloom**
    tick box (at the top-left corner in the following screenshot):'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择**bloom**复选框左侧的箭头（如下面的屏幕截图右上角所示）来扩展内容：
- en: '![Figure 13.29 – Setting the Bloom property values'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.29 – 设置 bloom 属性值'
- en: '](img/Figure_13.29_B18381.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.29_B18381.jpg)'
- en: Figure 13.29 – Setting the Bloom property values
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.29 – 设置 bloom 属性值
- en: In the preceding screenshot, we have turned all of the properties on. Simply
    deselect and select each property to see what influences (if any) are made to
    each of the properties. Also, try and change some of the values. Use the preceding
    screenshot as a fallback if you feel you have gone too far with the effect.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们已经打开了所有属性。只需取消选择并选择每个属性，就可以看到（如果有的话）对每个属性的影响。还可以尝试更改一些值。如果你觉得效果过强，可以使用前面的屏幕截图作为备选方案。
- en: 'An interesting property to take a look at here is the `1.14`, the bloom effect
    will increase. However, if we make the value too low, we can overcook it and destroy
    the look of our game, as shown in the following:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里值得一看的有趣属性是 `1.14`，bloom 效果将会增强。然而，如果我们把值设置得太低，我们可能会过度处理并破坏我们游戏的外观，如下所示：
- en: '![Figure 13.30 – The ''Threshold'' property levels'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.30 – ''阈值'' 属性级别'
- en: '](img/Figure_13.30_B18381.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.30_B18381.jpg)'
- en: Figure 13.30 – The 'Threshold' property levels
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.30 – '阈值' 属性级别
- en: Hopefully, I have made you curious enough to continue playing and experimenting
    with the bloom effect.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我已经让你足够好奇，继续探索和实验 bloom 效果。
- en: Further Information
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: More information about the **Bloom** effect can be found at [https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Bloom.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Bloom.html).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**bloom**效果的更多信息可以在[https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Bloom.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Bloom.html)找到。
- en: Next, we'll look at **Chromatic Aberration**.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨**色差**。
- en: Chromatic Aberration
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 色差
- en: This effect mimics what a real-world camera produces when its lens fails to
    join all the colors at the same point.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果模仿了当现实世界中的相机镜头无法将所有颜色在相同点汇聚时产生的效果。
- en: 'The following screenshot shows our current settings:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了我们的当前设置：
- en: '![Figure 13.31 – Setting the Chromatic Aberration property values'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.31 – 设置色差属性值'
- en: '](img/Figure_13.31_B18381.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.31_B18381.jpg)'
- en: Figure 13.31 – Setting the Chromatic Aberration property values
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.31 – 设置色差属性值
- en: 'This effect is more noticeable around the edges of the **Game** window. As
    an example, in the following screenshots, I have moved the image and its text
    up so that we can see these two components begin to warp more obviously:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果在**游戏**窗口的边缘更为明显。例如，在下面的屏幕截图中，我已经将图像和其文本向上移动，以便我们可以更明显地看到这两个组件开始变形：
- en: '![Figure 13.32 – ''Chromatic Aberration'' – off versus on'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.32 – ''色差'' – 关闭与开启'
- en: '](img/Figure_13.32_B18381.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.32_B18381.jpg)'
- en: Figure 13.32 – 'Chromatic Aberration' – off versus on
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.32 – '色差' – 关闭与开启
- en: Further Information
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: More information about the **Chromatic Aberration** effect can be found at [https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Chromatic-Aberration.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Chromatic-Aberration.html).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**色差**效果的更多信息可以在[https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Chromatic-Aberration.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Chromatic-Aberration.html)找到。
- en: Next, we'll look at the final effect we applied to our `title` scene – **Color
    Grading**.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨我们应用于 `title` 场景的最终效果 – **色彩分级**。
- en: Color Grading
  id: totrans-482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 色彩分级
- en: 'This effect alters the color and luminance of the final image that Unity produces.
    **Color Grading** has the biggest range of properties throughout all of the post-processing
    effects. I''ve split these properties up into bulleted segments:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果改变了 Unity 产生的最终图像的颜色和亮度。**色彩分级**在所有后处理效果中具有最广泛的属性范围。我已经将这些属性分成几个项目符号段：
- en: '**Mode**:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**：'
- en: '![Figure 13.33 – Setting the ''Color Grading'' override values'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.33 – 设置 ''色彩分级'' 覆盖值'
- en: '](img/Figure_13.33_B18381.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.33_B18381.jpg)'
- en: Figure 13.33 – Setting the 'Color Grading' override values
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.33 – 设置 '色彩分级' 覆盖值
- en: Here, we have a choice of three-color grading modes so that we can alter the
    camera's final image. In the preceding screenshot, Unity gave us a warning regarding
    changing **ColorSpace** from **Gamma** to **Linear**. If you want to do this,
    it can be changed in **Edit** | **Project Settings** | **Player** | **Player Settings**
    | **Other Settings**.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三种颜色评分模式可供选择，以便我们可以改变相机的最终图像。在前面的屏幕截图中，Unity提醒我们更改**色彩空间**从**伽玛**到**线性**。如果您想这样做，可以在**编辑**
    | **项目设置** | **玩家** | **玩家设置** | **其他设置**中进行更改。
- en: '**Tonemapping**:'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**色调映射**:'
- en: '![Figure 13.34 – Tonemapping'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.34 – 色调映射'
- en: '](img/Figure_13.34_B18381.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.34_B18381.jpg)'
- en: Figure 13.34 – Tonemapping
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.34 – 色调映射
- en: This hosts a selection of tonemapping algorithms that we can use at the end
    of the color grading process.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了在颜色评分过程结束时可以使用的色调映射算法的选择。
- en: '**White Balance**:'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白平衡**:'
- en: '![Figure 13.35 – White Balance'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.35 – 白平衡'
- en: '](img/Figure_13.35_B18381.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.35_B18381.jpg)'
- en: Figure 13.35 – White Balance
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.35 – 白平衡
- en: This alters the temperature and tint of the final picture.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这会改变最终图片的温度和色调。
- en: '**Tone**:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**色调**:'
- en: '![Figure 13.36 – Tone'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.36 – 色调'
- en: '](img/Figure_13.36_B18381.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.36_B18381.jpg)'
- en: Figure 13.36 – Tone
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.36 – 色调
- en: Here, you can adjust the **Saturation**, **Contrast**, **Hue Shift**, **Color
    filter**, and **Post-exposure (EV)** options, which, similar to the **Bloom**
    effect's **Threshold** property, can easily be overcooked and provide some powerfully
    bright or dark results.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以调整**饱和度**、**对比度**、**色调偏移**、**颜色滤镜**和**曝光后（EV）**选项，这些选项与**光晕**效果的**阈值**属性类似，很容易过度处理并提供一些非常明亮或暗淡的结果。
- en: '**Channel Mixer**:'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频道混合器**:'
- en: '![Figure 13.37 – Channel Mixer'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.37 – 频道混合器'
- en: '](img/Figure_13.37_B18381.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.37_B18381.jpg)'
- en: Figure 13.37 – Channel Mixer
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.37 – 频道混合器
- en: This changes each overall image's RGB channel.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这会改变每个整体图像的RGB通道。
- en: '**Trackballs**:'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轨迹球**:'
- en: '![Figure 13.38 – Trackballs'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.38 – 轨迹球'
- en: '](img/Figure_13.38_B18381.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.38_B18381.jpg)'
- en: Figure 13.38 – Trackballs
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.38 – 轨迹球
- en: Here, the three trackballs (**Lift** adjusts dark tones, **Gamma** adjusts mid-tones,
    and **Gain** adjusts highlights) affect the overall hue of the final image.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，三个轨迹球（**提升**调整暗色调，**伽玛**调整中间色调，**增益**调整高光）影响最终图像的整体色调。
- en: '**Grading Curves**:'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评分曲线**:'
- en: '![Figure 13.39 – Grading Curves'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.39 – 评分曲线'
- en: '](img/Figure_13.39_B18381.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.39_B18381.jpg)'
- en: Figure 13.39 – Grading Curves
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.39 – 评分曲线
- en: '**Grading Curves** is an advanced way to adjust specific ranges in hue, saturation,
    or luminosity in the final image.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**评分曲线**是调整最终图像中特定色调、饱和度或亮度的范围的高级方法。'
- en: Further Information
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: More information about the **Color Grading** effect can be found at [https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Color-Grading.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Color-Grading.html).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于**颜色评分**效果的信息可以在[https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Color-Grading.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/Color-Grading.html)找到。
- en: 'That concludes our look at all three of the post-processing overrides for the
    `title` scene. If you would like to know more about the rest of the effects that
    are available, check out the following link, where you can read up on the other
    11 effects that can be applied to a Unity scene: [https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/index.html).'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对`标题`场景所有三个后期处理覆盖效果的探讨。如果您想了解更多关于其他可用效果的信息，请查看以下链接，您可以阅读有关可以应用于Unity场景的其他11个效果的说明：[https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.postprocessing@2.1/manual/index.html).
- en: Anti-aliasing modes
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抗锯齿模式
- en: In this section, we are going to view the different types of anti-aliasing in
    the **Post Process Layer** component. As you may know, anti-aliasing smooths the
    rough edges of game objects in our game to get rid of staircase effects. Unity
    offers three different algorithms that smooth edges.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看**后期处理层**组件中不同类型的抗锯齿。如您所知，抗锯齿平滑游戏对象粗糙的边缘，以消除阶梯效应。Unity提供了三种不同的算法来平滑边缘。
- en: 'The following modes are offered:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式可供选择：
- en: '**Fast Approximate Anti-Aliasing (FXAA)**: This is typically used with mobile
    platforms due to its quick algorithm. It is the most efficient technique but doesn''t
    support motion vectors.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速近似抗锯齿（FXAA）**：由于其快速算法，这通常用于移动平台。这是最有效的方法，但不支持运动矢量。'
- en: '**Subpixel Morphological Anti-Aliasing (SMAA)**: This is high-quality but is
    more demanding in terms of system performance.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚像素形态抗锯齿 (SMAA)**：这是高质量但系统性能要求更高的技术。'
- en: '**Temporal Anti-Aliasing (TAA)**: An advanced, high-demanding technique that
    uses motion vectors (a motion vector is a key element in the motion estimation
    process).'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间抗锯齿 (TAA)**：这是一种高级且要求较高的技术，它使用运动矢量（运动矢量是运动估计过程中的关键元素）。'
- en: 'The following screenshots show the player''s ship with different anti-aliasing
    techniques applied to it:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用了不同抗锯齿技术的玩家飞船：
- en: '![Figure 13.40 – Visual differences with anti-aliasing modes'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.40 – 使用抗锯齿模式的视觉差异]'
- en: '](img/Figure_13.40_B18381.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.40_B18381.jpg]'
- en: Figure 13.40 – Visual differences with anti-aliasing modes
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.40 – 使用抗锯齿模式的视觉差异
- en: As you can see, the purpose of anti-aliasing is to take off jagged edges, but
    with our game, these edges aren't as noticeable, since it's full of dark backgrounds.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，抗锯齿的目的是去除锯齿边缘，但鉴于我们的游戏背景大多是深色，这些边缘并不那么明显。
- en: Further Information
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to apply anti-aliasing and want to find out more, check out
    the following link: [https://docs.unity3d.com/Manual/PostProcessing-Antialiasing.html](https://docs.unity3d.com/Manual/PostProcessing-Antialiasing.html).'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想应用抗锯齿并想了解更多信息，请查看以下链接：[https://docs.unity3d.com/Manual/PostProcessing-Antialiasing.html](https://docs.unity3d.com/Manual/PostProcessing-Antialiasing.html)。
- en: Next, we'll look at creating and applying our own post-processing profiles,
    which we created at the start of the *Applying PC visual improvements* section.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨创建和应用我们自己的后处理配置文件，这些配置文件是在 *应用 PC 视觉改进* 部分的开头创建的。
- en: Creating and applying post-processing profiles
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建和应用后处理配置文件
- en: In the final section on post-processing, we will discuss creating a post-processing
    profile. From there, you can (if you want to – I encourage you to) create your
    own profile and apply it to the **Post Process Volume** component in the **Inspector**
    window. Finally, you will be able to add/remove your own effects to alter the
    final look of the standalone game.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在后处理的最后部分，我们将讨论创建后处理配置文件。从那里，您可以选择（如果您想的话——我鼓励您这样做）创建自己的配置文件并将其应用到 **检查器** 窗口中的
    **后处理体积** 组件。最后，您将能够添加/删除自己的效果以改变独立游戏的最终外观。
- en: 'So, to create and add our own effects, I suggest that we go back to a scene
    that we have already prepared – the `title` scene:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了创建和添加我们自己的效果，我建议我们回到一个我们已经准备好的场景——`title` 场景：
- en: In the `Assets/Scene` and open the `title` scene.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scene` 中打开 `title` 场景。
- en: Select the **Main Camera** game object in the **Hierarchy** window.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次** 窗口中选择 **主相机** 游戏对象。
- en: 'Press the **New** button inside the **Post Process Volume** component (as shown
    in the following screenshot):'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **后处理体积** 组件内部的 **新建** 按钮（如图所示）：
- en: '![Figure 13.41 – Creating a new post-processing profile'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.41 – 创建新的后处理配置文件]'
- en: '](img/Figure_13.41_B18381.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.41_B18381.jpg]'
- en: Figure 13.41 – Creating a new post-processing profile
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.41 – 创建新的后处理配置文件
- en: To add your own post-processing effects, click the **Add effect...** button
    (as shown in the preceding screenshot) at the bottom of the **Post Process Volume**
    component and select an effect from the drop-down list.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加自己的后处理效果，请点击 **添加效果...** 按钮（如图所示），位于 **后处理体积** 组件的底部，并从下拉列表中选择一个效果。
- en: 'Once you have applied the effect, click **All** to turn all the properties
    on (as shown in the following screenshot):'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用效果后，点击 **全部** 以启用所有属性（如图所示）：
- en: '![Figure 13.42 – Turning all the properties on'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.42 – 启用所有属性]'
- en: '](img/Figure_13.42_B18381.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.42_B18381.jpg]'
- en: Figure 13.42 – Turning all the properties on
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.42 – 启用所有属性
- en: If you want to remove the effect, click in the top-right corner of the effect
    (above the **Off** button) and select **Remove** from the drop-down list (as shown
    in the preceding screenshot).
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想删除效果，请点击效果右上角（在 **关闭** 按钮上方）并从下拉列表中选择 **删除**（如图所示）。
- en: 'It''s as simple as that! If you want to see where the file is located, click
    on the **PostProcessProfile** field, as shown in the following screenshot:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如此简单！如果您想查看文件的位置，请点击 **PostProcessProfile** 字段，如图所示：
- en: '![Figure 13.43 – Applying and locating the post-processing profile'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.43 – 应用和定位后处理配置文件]'
- en: '](img/Figure_13.43_B18381.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.43_B18381.jpg]'
- en: Figure 13.43 – Applying and locating the post-processing profile
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.43 – 应用和定位后处理配置文件
- en: The location will ping yellow in the **Project** window (as shown in the preceding
    screenshot), which is also where you can rename the file to something that resembles
    the use of the profile (right-click the file and select **Rename** from the dropdown).
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，位置将闪烁黄色（如前一张截图所示），这也是你可以重命名文件以反映配置文件用途的地方（右键单击文件，从下拉菜单中选择**重命名**）。
- en: If you don't like what you've created, you can delete the **PostProcessProfile**
    file from the **Project** window and click the small **remote** button to the
    right of the **Profile** parameter in **Post Process Volume** to add the **TEXT**
    profile once more (or whichever profile you want).
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你不喜欢你所创建的，你可以从**项目**窗口中删除**后处理配置文件**文件，然后点击**后处理体积**中**配置文件**参数右侧的小**远程**按钮，再次添加**TEXT**配置文件（或你想要的任何配置文件）。
- en: This was an extensive overview of the post-processing package that Unity has
    to offer. In this section, we imported our Unity package and added post-processing
    components to each of our game scenes. From there, we applied ready-made profiles
    to customize the scenes' post-processing effects. We then lightly reviewed some
    of the effects that can be added to the **Post Process Volume** component, which
    was already in our scenes.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Unity提供的后处理包的全面概述。在本节中，我们导入了我们的Unity包并为每个游戏场景添加了后处理组件。从那里，我们应用了现成的配置文件来定制场景的后处理效果。然后，我们简要回顾了一些可以添加到**后处理体积**组件中的效果，这些效果已经存在于我们的场景中。
- en: We ended this section by altering our scene's anti-aliasing properties. With
    this, we took the rough edges off our art assets.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过改变场景的抗锯齿属性来结束本节。这样，我们消除了艺术资产的粗糙边缘。
- en: I encourage you to make your own profiles, but if you feel like you need more
    profiles to play around with, you can purchase a compilation of profiles from
    the Asset Store for a small price.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你创建自己的配置文件，但如果你觉得你需要更多配置文件来尝试，你可以以小额价格从资源商店购买配置文件的集合。
- en: In the next section, we are going to take a look at the lighting settings and
    apply some global illumination, lighting, and fog to our shop scene.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看照明设置并应用一些全局照明、照明和雾效到我们的商店场景中。
- en: Adding global illumination and other settings
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加全局照明和其他设置
- en: In this section, we are going to give our shop scene a background by adding
    art assets from the `level3` scene and adding a red emission material.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过添加来自`level3`场景的艺术资产和添加红色发射材料来为我们的商店场景添加背景。
- en: Unity is currently working on a new global illumination lighting package, which
    means this version we are using will be eventually phased out. The good news is
    that it will be supported during 2020 LTS.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: Unity目前正在开发一个新的全局照明照明包，这意味着我们正在使用的这个版本最终将被淘汰。好消息是，它将在2020 LTS期间得到支持。
- en: We will activate the scene's real-time global illumination, which is where the
    red emission material will glow on the surface of the corridor. We will also be
    adding extra lights to our shop display and the player ship to make it stand out
    more. Finally, we will add some black fog to create some darkness creeping around
    the glowing lights.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将激活场景的实时全局照明，红色发射材料将在走廊的表面上发光。我们还将为商店展示和玩家飞船添加额外的灯光，使其更加突出。最后，我们将添加一些黑色雾气，以在发光的灯光周围创造一些黑暗。
- en: 'The following screenshots show a comparison between the shop scene before and
    after we complete this section:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了完成本节前后商店场景的比较：
- en: '![Figure 13.44 – Global illumination/Lighting/Fog – off versus on'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.44 – Global illumination/Lighting/Fog – off versus on]'
- en: '](img/Figure_13.44_B18381.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.44_B18381.jpg]'
- en: Figure 13.44 – Global illumination/Lighting/Fog – off versus on
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.44 – 全局照明/照明/雾 – 关闭与开启
- en: So, let's start this section off by adding the art assets that we are going
    to use for the shop scene.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从这个部分开始，添加我们将用于商店场景的艺术资产。
- en: Adding art assets to our shop scene
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将艺术资产添加到我们的商店场景中
- en: In this section, we are going to drag and drop some pre-made art assets into
    our `shop` scene. From there, we can continue setting up our **Lighting** settings.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将拖放一些预制的艺术资产到我们的`shop`场景中。从那里，我们可以继续设置我们的**照明**设置。
- en: 'To apply the art assets to our `shop` scene, we need to do the following:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 要将艺术资产应用到我们的`shop`场景中，我们需要执行以下操作：
- en: First, load up the `shop` scene itself from the `Assets/Scene`. Then, double-click
    the `shop` scene.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从`Assets/Scene`加载`shop`场景本身。然后，双击`shop`场景。
- en: In the `Assets/Prefab` folder.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Prefab`文件夹中。
- en: Drag and drop the **Environment** prefab into the **Hierarchy** window.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**环境**预制体拖放到**层次结构**窗口中。
- en: 'The scene, when viewed from the **Game** window, will look as follows:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 从**游戏**窗口查看场景时，将如下所示：
- en: '![Figure 13.45 – Current look of our shop scene'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.45 – 我们商店场景的当前外观'
- en: '](img/Figure_13.45_B18381.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.45_B18381.jpg)'
- en: Figure 13.45 – Current look of our shop scene
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.45 – 我们商店场景的当前外观
- en: The art assets that we have brought into the `shop` scene should be marked as
    **static**. Specifically, it's **Contribute GI** that needs to be marked so that
    we can generate the lights we need from our red emission strips, as shown in the
    preceding screenshot.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入到`shop`场景中的艺术资产应标记为**静态**。具体来说，需要标记**贡献全局光照**，这样我们才能从我们的红色发射带生成所需的灯光，如图中所示的前一个屏幕截图。
- en: 'The following screenshot shows the **Inspector** window with the **Environment**
    game object (and all its children) marked as **Static**:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了标记为**静态**的**环境**游戏对象（及其所有子对象）的**检查器**窗口：
- en: '![Figure 13.46 – The ''Environment'' game object and its children marked as
    static'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.46 – ‘环境’游戏对象及其标记为静态的子对象'
- en: '](img/Figure_13.46_B18381.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.46_B18381.jpg)'
- en: Figure 13.46 – The 'Environment' game object and its children marked as static
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.46 – ‘环境’游戏对象及其标记为静态的子对象
- en: Further Information
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: If we did have moving game objects in the scene that we wanted to be affected
    by the lighting of the scene, we would need to add **Light Probes** to update
    any indirect colors on that moving game object.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景中存在我们希望受场景光照影响的移动游戏对象，我们需要添加**光照探针**来更新该移动游戏对象上的任何间接颜色。
- en: If you would like to know more about **Light Probes**, check out [https://docs.unity3d.com/Manual/LightProbes.html](https://docs.unity3d.com/Manual/LightProbes.html).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于**光照探针**的信息，请查看[https://docs.unity3d.com/Manual/LightProbes.html](https://docs.unity3d.com/Manual/LightProbes.html)。
- en: 'Now, we need to disable any kind of light we currently have in our scene so
    that we don''t dilute the effect we are trying to achieve:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要禁用场景中当前任何类型的灯光，以免稀释我们试图实现的效果：
- en: If the **Hierarchy** window contains **Directional Light**, select it and press
    *delete* on your keyboard.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**层次结构**窗口包含**方向光**，请选择它，然后在键盘上按*删除*键。
- en: Now, we can set up our **Lighting** settings so that they support **Realtime
    Global Illumination**. To do that, we need to access our **Lighting** window and
    enter some values.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置**光照**设置，以便它们支持**实时全局光照**。为此，我们需要访问**光照**窗口并输入一些值。
- en: If the **Lighting** window hasn't loaded, in the Unity Editor, at the top of
    the screen, select **Window** | **Rendering** | **Lighting**.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**光照**窗口尚未加载，在Unity编辑器中，屏幕顶部，选择**窗口** | **渲染** | **光照**。
- en: 'Select the **Scene** button in the **Lighting** window. Now, let''s start turning
    off all **Environment** lights. Set your **Environment** settings to the ones
    shown in the following screenshot:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**光照**窗口中选择**场景**按钮。现在，让我们开始关闭所有**环境**灯光。将您的**环境**设置调整为以下屏幕截图所示：
- en: '![Figure 13.47 – The ''Lighting'' window and its updated property values in
    the ''Scene'' tab'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.47 – ‘光照’窗口及其在‘场景’标签页中的更新属性值'
- en: '](img/Figure_13.47_B18381.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.47_B18381.jpg)'
- en: Figure 13.47 – The 'Lighting' window and its updated property values in the
    'Scene' tab
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.47 – ‘光照’窗口及其在‘场景’标签页中的更新属性值
- en: As shown in the preceding screenshot, we have knocked out any kind of light
    that our scene might have had. Now, we can go back to the **Scene** tab and turn
    **Realtime Global Illumination** on, which is just below the **Environment** segment
    of the **Lighting** window. If all settings are grayed out, we need to create
    a **New Lighting Settings** at the top-right of the **Scene** tab.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们已经移除了场景可能拥有的任何类型的灯光。现在，我们可以回到**场景**标签页，并打开位于**光照**窗口**环境**部分下方的**实时全局光照**，如果所有设置都变为灰色，我们需要在**场景**标签页右上角创建**新的光照设置**。
- en: '![Figure 13.48 – Tick ''Realtime Global Illumination'''
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.48 – 打勾‘实时全局光照’'
- en: '](img/Figure_13.48_B18381.jpg)'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.48_B18381.jpg)'
- en: Figure 13.48 – Tick 'Realtime Global Illumination'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.48 – 打勾‘实时全局光照’
- en: Make sure **Baked Global Illumination** is unticked, as we don't want our lights
    to be computed at runtime. This is because it uses up RAM and HDD/SSD space.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保取消勾选**烘焙全局光照**，因为我们不希望我们的灯光在运行时计算。这是因为它会消耗RAM和HDD/SSD空间。
- en: Still inside the **Lighting** window's settings, we can lower some of the **Lightmapping
    Settings** values so that the map isn't as detailed and is also quicker to generate
    light on slower systems.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在**照明**窗口的设置中，我们可以降低一些**光照贴图设置**的值，以便地图不那么详细，并且在较慢的系统上生成光照也更快。
- en: 'Leave **Lightmapping Settings** at its default values, as shown in the following
    screenshot:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**光照贴图设置**保留在其默认值，如下面的截图所示：
- en: '![Figure 13.49 – Update the ''Lightmapping Settings'' property values to the
    ones shown here'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.49 – 将“光照贴图设置”属性值更新为这里显示的值'
- en: '](img/Figure_13.49_B18381.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.49_B18381.jpg)'
- en: Figure 13.49 – Update the 'Lightmapping Settings' property values to the ones
    shown here
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.49 – 将“光照贴图设置”属性值更新为这里显示的值
- en: At the bottom of the **Lighting** window, make sure **Auto Generate** is unticked
    and click the **Generate Lighting** button.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**照明**窗口的底部，确保**自动生成**未被勾选，并点击**生成照明**按钮。
- en: Wait for the blue bar at the bottom-right corner of the Unity Editor to complete
    and disappear.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Unity编辑器右下角的蓝色条完成并消失。
- en: 'We will be presented with the following output in the **Game** window:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在**游戏**窗口中看到以下输出：
- en: '![Figure 13.50 – Our ''Game'' window shows our shop scene is washed out in
    a strong light'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.50 – 我们的“游戏”窗口显示我们的商店场景在强烈的光线下变得苍白'
- en: '](img/Figure_13.50_B18381.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.50_B18381.jpg)'
- en: Figure 13.50 – Our 'Game' window shows our shop scene is washed out in a strong
    light
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.50 – 我们的“游戏”窗口显示我们的商店场景在强烈的光线下变得苍白
- en: Further Information
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: We can (if we want to) check the indirect lighting that we have created from
    our current **Lighting** settings by selecting the **Shaded** button below the
    **Scene** tab and selecting **Indirect** from the dropdown (don't forget to change
    it back to **Shaded** once you're done).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以（如果想要的话）通过选择**场景**标签下的**着色**按钮，并从下拉菜单中选择**间接照明**来检查我们从当前的**照明**设置中创建的间接照明（完成后不要忘记将其改回**着色**）。
- en: Our `shop` scene looks overly bright red and has drowned the scene out. However,
    we nearly have what we want. Now, we can turn on some **fog** from the **Lighting**
    window to create a dark alley with the red emission bleeding through.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`shop`场景看起来过于明亮且红色过重，淹没了场景。然而，我们几乎得到了我们想要的效果。现在，我们可以从**照明**窗口打开一些**雾**，以创建一个黑暗的巷子，红色辐射从中渗透出来。
- en: 'To add `shop` scene, in our **Lighting** window, near the bottom, we need to
    apply the following values:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加`shop`场景，在我们的**照明**窗口中，靠近底部，我们需要应用以下值：
- en: '![Figure 13.51 – The ''Fog'' settings property values'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.51 – “雾”设置属性值'
- en: '](img/Figure_13.51_B18381.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.51_B18381.jpg)'
- en: Figure 13.51 – The 'Fog' settings property values
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.51 – “雾”设置属性值
- en: 'Our `shop` scene, as shown in the following screenshot:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们的`shop`场景：
- en: '![Figure 13.52 – The ''Game'' window with a black fog background'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.52 – 带有黑色雾背景的“游戏”窗口'
- en: '](img/Figure_13.52_B18381.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.52_B18381.jpg)'
- en: Figure 13.52 – The 'Game' window with a black fog background
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.52 – 带有黑色雾背景的“游戏”窗口
- en: 'The final touch is to drag and drop the `shopLights` prefab from `Assets/Prefab`
    into the **Hierarchy** window to light up the player ship:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将`shopLights`预制件从`Assets/Prefab`拖放到**层次结构**窗口中，以照亮玩家飞船：
- en: '![Figure 13.53 – Small light added to the player ship'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.53 – 添加到玩家飞船上的小光源'
- en: '](img/Figure_13.53_B18381.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.53_B18381.jpg)'
- en: Figure 13.53 – Small light added to the player ship
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.53 – 添加到玩家飞船上的小光源
- en: Save the `shop` scene.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`shop`场景。
- en: With that, we have successfully removed the default lighting from our `shop`
    scene and applied `shop` scene's background.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经成功从我们的`shop`场景中移除了默认照明并应用了`shop`场景的背景。
- en: In the next section, we will be discussing and implementing a small section
    of our `level3` scene so that we can start adding art assets with reflections.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论和实现`level3`场景的一个小部分，这样我们就可以开始添加具有反射的艺术资产。
- en: Reflection probe
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射探针
- en: 'In this section, we are going to introduce the final art asset for our game.
    This asset will reflect the environment in the scene, as shown by the two-sphere
    statues in the following screenshot:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍我们游戏的最终艺术资产。该资产将反映场景中的环境，如下面的截图中的两个球体雕像所示：
- en: '![Figure 13.54 – Reflective orbs in the background'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.54 – 背景中的反射球体'
- en: '](img/Figure_13.54_B18381.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.54_B18381.jpg)'
- en: Figure 13.54 – Reflective orbs in the background
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.54 – 背景中的反射球体
- en: You can imagine how useful it would be to have a material that reflects its
    surroundings like a mirror. We are going to add the `level3` scene and calibrate
    its property values to get a decent result without affecting our system's resources.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以想象，拥有一个像镜子一样反射周围环境的材质是多么有用。我们将添加`level3`场景并校准其属性值，以获得令人满意的结果，而不会影响我们的系统资源。
- en: 'So, let''s start by loading up the `level3` scene:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先加载`level3`场景：
- en: In the `Assets/Scene` folder and double-click on the `level3` scene.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scene`文件夹中双击`level3`场景。
- en: Now, we are going to place our **shinySphere** asset in the scene.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的**shinySphere**资产放置到场景中。
- en: In the `Assets/Prefab` folder.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Prefab`文件夹中。
- en: Drag **shinySphere** into the **Hierarchy** window.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**shinySphere**拖入**层次结构**窗口。
- en: 'Select the **shinySphere** asset in the **Hierarchy** window and make sure
    that its **Transform** values are set as shown in the following screenshot:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**shinySphere**资产，并确保其**变换**值设置如下所示：
- en: '![Figure 13.55 – The ''shinySphere'' Transform property values'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.55 – ‘shinySphere’变换属性值'
- en: '](img/Figure_13.55_B18381.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.55_B18381.jpg]'
- en: Figure 13.55 – The 'shinySphere' Transform property values
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.55 – ‘shinySphere’变换属性值
- en: 'The **shinySphere** game object should now be in a location next to the cargo
    blocks at the end of the level, as shown in the following screenshot:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '**shinySphere**游戏对象现在应该位于关卡末尾的货物块旁边的位置，如下截图所示：'
- en: '![Figure 13.56 – The placement of the ''shinySphere'' game object'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.56 – ‘shinySphere’游戏对象的放置'
- en: '](img/Figure_13.56_B18381.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.56_B18381.jpg]'
- en: Figure 13.56 – The placement of the 'shinySphere' game object
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.56 – ‘shinySphere’游戏对象的放置
- en: 'Before we add the second **shinySphere** game object, let''s add a **Reflection
    Probe** component to this game object, as follows:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加第二个**shinySphere**游戏对象之前，让我们向此游戏对象添加一个**反射探针**组件，如下所示：
- en: In the **Hierarchy** window, expand the **shinySphere** game object and select
    the **spheres** child game object.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，展开**shinySphere**游戏对象并选择**spheres**子游戏对象。
- en: Right-click the **spheres** game object in the **Hierarchy** window and select
    **Light** | **Reflection Probe**.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击**spheres**游戏对象，然后选择**灯光**|**反射探针**。
- en: The **spheres** game object now has a child game object called **Reflection
    Probe**. Select this game object.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**球体**游戏对象现在有一个名为**反射探针**的子游戏对象。选择此游戏对象。'
- en: 'In the **Inspector** window, we have the **Reflection Probe** component, along
    with its values. First, let''s change the **Type** values to the ones shown in
    the following screenshot to make our game object reflect its environment:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，我们有**反射探针**组件及其值。首先，让我们将**类型**值更改为以下截图所示的值，以便我们的游戏对象能够反射其环境：
- en: '![Figure 13.57 – The ''Type'' values updated to the ones shown here to create
    a reflection'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.57 – 将“类型”值更新为这里显示的值以创建反射'
- en: '](img/Figure_13.57_B18381.jpg)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.57_B18381.jpg]'
- en: Figure 13.57 – The 'Type' values updated to the ones shown here to create a
    reflection
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.57 – 将“类型”值更新为这里显示的值以创建反射
- en: Our **shinySphere** game object will now update its reflection on every frame.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**shinySphere**游戏对象现在将每帧更新其反射。
- en: 'Next, we will alter the **Runtime settings** values to increase the accuracy
    of the reflection. If the **Box Projection** is grayed out, switch from **Android**
    to **PC**, **Mac & Linux Standalone** build in **Build Settings**. Use the values
    shown in the following screenshot:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改**运行时设置**的值以提高反射的准确性。如果**盒子投影**变灰，请在**构建设置**中从**Android**切换到**PC**、**Mac
    & Linux 独立**构建。使用以下截图所示的值：
- en: '![Figure 13.58 – Increasing the accuracy reflection in ''Runtime Settings'''
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.58 – 在“运行时设置”中提高反射的准确性'
- en: '](img/Figure_13.58_B18381.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.58_B18381.jpg]'
- en: Figure 13.58 – Increasing the accuracy reflection in 'Runtime Settings'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.58 – 在“运行时设置”中提高反射的准确性
- en: Further Information
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: '**Box Projection** will help improve the accuracy of the reflections given
    in the environment. If you would like to know more, check out the following link:
    [https://docs.unity3d.com/Manual/AdvancedRefProbe.html](https://docs.unity3d.com/Manual/AdvancedRefProbe.html).'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**盒子投影**将有助于提高环境中提供的反射的准确性。如果您想了解更多信息，请查看以下链接：[https://docs.unity3d.com/Manual/AdvancedRefProbe.html](https://docs.unity3d.com/Manual/AdvancedRefProbe.html)。'
- en: 'The last property values to update can be found in **Cubemap capture settings**.
    Changing these values will change the final look of the reflections (simply estimate
    what color the **Background** property should be so that it suits your scene):'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要更新的属性值可以在**Cubemap捕获设置**中找到。更改这些值将改变最终反射的外观（简单地估计**背景**属性应该是什么颜色，以便它适合你的场景）：
- en: '![Figure 13.59 – The ''Cubemap capture settings'' property values updated to
    the ones shown here'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.59 – 将‘Cubemap捕获设置’属性值更新为这里显示的值'
- en: '](img/Figure_13.59_B18381.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.59_B18381.jpg)'
- en: Figure 13.59 – The 'Cubemap capture settings' property values updated to the
    ones shown here
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.59 – 将‘Cubemap捕获设置’属性值更新为这里显示的值
- en: The reflection probe can create performance issues if it's not used carefully,
    depending on the platform the game is being pointed toward. For example, with
    the previous settings, a higher resolution will show a clearer reflection but
    will obviously require more resources.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用不当，反射探针可能会根据游戏指向的平台造成性能问题。例如，使用之前的设置，更高的分辨率将显示更清晰的反射，但显然需要更多的资源。
- en: Further Information
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'For more information about reflection probes and their performance, check out
    the following link: [https://docs.unity3d.com/Manual/RefProbePerformance.html](https://docs.unity3d.com/Manual/RefProbePerformance.html).'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于反射探针及其性能的信息，请查看以下链接：[https://docs.unity3d.com/Manual/RefProbePerformance.html](https://docs.unity3d.com/Manual/RefProbePerformance.html)。
- en: 'To duplicate the `level3` scene, we need to do the following:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制`level3`场景，我们需要做以下几步：
- en: Select the **shinySphere** game object in the **Hierarchy** window and click
    **Overrides | Apply All** at the top-right corner of the **Inspector** window
    to update the prefab.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**shinySphere**游戏对象，并在**检查器**窗口的右上角点击**覆盖 | 应用全部**来更新预制体。
- en: To copy and paste the **shinySphere** game object, right-click **shinySphere**
    in the **Hierarchy** window and select **Copy** from the drop-down list.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要复制并粘贴**shinySphere**游戏对象，在**层次结构**窗口中右键点击**shinySphere**，从下拉列表中选择**复制**。
- en: Right-click in the **Hierarchy** window (in an open space, near the bottom)
    and select **Paste** from the drop-down list.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中（在空白区域，靠近底部）右键点击，并从下拉列表中选择**粘贴**。
- en: Finally, move the **shinySphere** game object to the right of the *x* axis.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**shinySphere**游戏对象移动到*x*轴的右侧。
- en: Save the scene.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'The following screenshot shows the two **shinySphere** game objects reflecting
    the environment:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了两个**shinySphere**游戏对象反射的环境：
- en: '![Figure 13.60 – Both ''shinySphere'' game objects with reflections'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.60 – 两个带有反射的‘shinySphere’游戏对象'
- en: '](img/Figure_13.60_B18381.jpg)'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.60_B18381.jpg)'
- en: Figure 13.60 – Both 'shinySphere' game objects with reflections
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.60 – 两个带有反射的‘shinySphere’游戏对象
- en: If, in any other future Unity Projects, you are required to create a shiny surface,
    marble floor, a brand-new shiny car, and so on, making use of a reflection probe
    would cover these requirements.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在未来的任何其他Unity项目中，你需要创建一个闪亮的表面、大理石地板、全新的闪亮汽车等等，使用反射探针将满足这些需求。
- en: With that, we have reached the point where our game is complete, and we've covered
    everything specified in the Game Design Document. Now would be a good time to
    build our standalone version of the game and see how well it runs. Are there any
    bugs? How are we going to test our game? Let's move on and see how we can tackle
    such issues.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经到达了游戏完成的点，我们已经涵盖了游戏设计文档中指定的所有内容。现在是一个很好的时机来构建我们游戏的独立版本，看看它的运行情况如何。有没有什么错误？我们打算如何测试我们的游戏？让我们继续前进，看看我们如何解决这些问题。
- en: Building and testing our game
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试我们的游戏
- en: We have reached the point where we can build and run our game instead of just
    testing our game's scenes in the Unity Editor. This section will be about not
    only building the game, as we did earlier for the Android version of the game,
    but also to see whether we have any bugs with our final build. We will also look
    for any potential issues along the way by using performance spikes in the profiler.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了可以构建和运行我们的游戏的点，而不仅仅是测试Unity编辑器中的游戏场景。本节不仅将涉及构建游戏，就像我们之前为游戏的Android版本所做的那样，还将查看我们的最终构建是否有任何错误。我们还将通过使用性能分析器中的性能峰值来查找沿途的任何潜在问题。
- en: Let's start building our game and see how well it runs before we do any tests.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先构建我们的游戏，看看它在测试之前运行得如何。
- en: 'To build our game for a PC, we need to do the following:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 要为PC构建我们的游戏，我们需要做以下几步：
- en: At the top of the Unity Editor, go to **File** | **Build Settings...**
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，转到**文件** | **构建设置...**
- en: Make sure all the scenes are in the **Scenes In Build** list and in the correct
    order.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有场景都在**构建中的场景**列表中，并且顺序正确。
- en: '**Platform** should be set to **PC, Mac & Linux Standalone**. If not, select
    it and select the **Switch Platform** button.'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平台**应设置为**PC、Mac & Linux 独立版**。如果不是，请选择它并选择**切换平台**按钮。'
- en: 'Next, we need to add the aspect ratios that this game is intended for in the
    **Player Settings...** window:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在**玩家设置...**窗口中添加这个游戏打算使用的纵横比：
- en: Select the **Player** tab.
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**玩家**选项卡。
- en: In the **Inspector** window, expand the **Resolution and Presentation** content.
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，展开**分辨率和展示**内容。
- en: Expand the **Supported Aspect Ratios** content.
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**支持的纵横比**内容。
- en: 'Deselect the aspect ratios shown in the following screenshot:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 取消选择以下截图显示的纵横比：
- en: '![Figure 13.61 – Select the 16:10 and 16:9 aspect ratios (typical widescreen
    ratios)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.61 – 选择16:10和16:9的纵横比（典型宽屏比例）'
- en: '](img/Figure_13.61_B18381.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.61_B18381.jpg)'
- en: Figure 13.61 – Select the 16:10 and 16:9 aspect ratios (typical widescreen ratios)
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.61 – 选择16:10和16:9的纵横比（典型宽屏比例）
- en: Back in the **Build Settings** window, press the **Build** button.
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**构建设置**窗口，按**构建**按钮。
- en: 'The following screenshot shows these references highlighted:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这些引用被突出显示：
- en: '![Figure 13.62 – All game scenes added and in order (Scenes In Build), ''PC,
    Mac & Linux Standalone'' selected in the ''Platform'' settings, and ''Build''
    clicked'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.62 – 所有游戏场景已添加并排序（构建中的场景），在“平台”设置中选择了‘PC、Mac & Linux 独立版’，并点击了“构建”'
- en: '](img/Figure_13.62_B18381.jpg)'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.62_B18381.jpg)'
- en: Figure 13.62 – All game scenes added and in order (Scenes In Build), 'PC, Mac
    & Linux Standalone' selected in the 'Platform' settings, and 'Build' clicked
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.62 – 所有游戏场景已添加并排序（构建中的场景），在“平台”设置中选择了‘PC、Mac & Linux 独立版’，并点击了“构建”
- en: In the **Windows Explorer** window that appears, select a location where you
    wish to install the game and click the **Save** button.
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的**Windows资源管理器**窗口中，选择你希望安装游戏的地点并点击**保存**按钮。
- en: Once the game has been built, run its `.exe` file.
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦游戏构建完成，运行其`.exe`文件。
- en: Now, let's fix any potential issues that may arise in our game.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复我们游戏中可能出现的任何潜在问题。
- en: Tackling bugs
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决错误
- en: Imagine we have sent our game off to be bug-tested and get a response from several
    bug testers questioning bugs, the game's UI, and the performance of the game.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经将我们的游戏发送出去进行错误测试，并收到了几个错误测试人员对错误、游戏UI和游戏性能的反馈。
- en: The following sections contain four reports that I want you to read and think
    about. We will go through the answers near the end of this chapter.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节包含四个报告，我希望你阅读并思考。我们将在本章末尾讨论答案。
- en: Let's start with the first bug report.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个错误报告开始。
- en: Bug report – Standalone AD button
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误报告 – 独立AD按钮
- en: It has been reported that when our bug tester plays the PC version of the game,
    they can't watch an advert in the shop scene.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 已有报告称，当我们的错误测试人员玩PC版本的游戏时，他们无法在商店场景中观看广告。
- en: How can we resolve this issue?
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？
- en: 'The following screenshot shows the `AD` button in the `shop` scene:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`shop`场景中的`AD`按钮：
- en: '![Figure 13.63 – The AD and Start buttons from the shop scene'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.63 – 商店场景中的AD和开始按钮'
- en: '](img/Figure_13.63_B18381.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.63_B18381.jpg)'
- en: Figure 13.63 – The AD and Start buttons from the shop scene
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.63 – 商店场景中的AD和开始按钮
- en: '**Hint**: Do we need the AD button in the standalone version of the shop scene?
    Is it supported by Unity?'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：在商店场景的独立版本中我们需要AD按钮吗？Unity支持它吗？'
- en: Bug report – Resetting the player's lives
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误报告 – 重置玩家的生命值
- en: A second report has been given to us, suggesting that when the game is completed,
    the player's lives don't reset.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了第二份报告，建议当游戏完成时，玩家的生命值不会重置。
- en: Why is this happening and how do we fix this issue?
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况，我们如何解决这个问题？
- en: 'The following screenshot shows the player''s lives counter on level 1:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了第1级玩家的生命值计数器：
- en: '![Figure 13.64 – Player''s Lives'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.64 – 玩家的生命值'
- en: '](img/Figure_13.64_B18381.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.64_B18381.jpg)'
- en: Figure 13.64 – Player's Lives
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.64 – 玩家的生命值
- en: '**Hint**: Does this happen when you quit the game through the pause screen?
    Do the player''s lives reset when all their lives are lost?'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：这是否发生在你通过暂停屏幕退出游戏时？当所有生命值都丢失时，玩家的生命值会重置吗？'
- en: Bug report – Slower systems on level 3
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误报告 – 第3级较慢的系统
- en: When the Android version is played on slower systems, it has been reported that
    level 3 runs slower than levels 1 and 2.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 当在较慢的系统上玩 Android 版本时，据报道，第 3 关的运行速度比第 1 关和第 2 关慢。
- en: What amendments can be made, if any, to fix this problem?
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何，可以做出哪些修改来解决这个问题？
- en: 'The following screenshot shows where the game slows down:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了游戏减速的位置：
- en: '![Figure 13.65 – Halfway through Level 3'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.65 – 第三级的一半'
- en: '](img/Figure_13.65_B18381.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.65_B18381.jpg)'
- en: Figure 13.65 – Halfway through Level 3
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.65 – 第三级的一半
- en: '**Hint**: What changes can be made that won''t upset standalone or more powerful
    performing Android devices?'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：可以做出哪些修改而不会影响独立或性能更强的 Android 设备？'
- en: Bug report – Sometimes, the game ends too quickly
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误报告 – 有时，游戏结束得太快
- en: Some bug testers have reported that, when starting a game, it ends earlier than
    intended, with the player ship animating out of the screen.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误测试人员报告说，在开始游戏时，游戏结束得比预期要早，玩家的飞船动画从屏幕中消失。
- en: Why is this happening and how can this be amended?
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况，如何进行修改？
- en: 'The following screenshot shows the tail end of the player ship''s thrusters
    as it leaves the level too soon:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了玩家飞船的推进器在离开关卡过早时的末端：
- en: '![Figure 13.66 – Player has left too early'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.66 – 玩家离开得太早'
- en: '](img/Figure_13.66_B18381.jpg)'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.66_B18381.jpg)'
- en: Figure 13.66 – Player has left too early
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.66 – 玩家离开得太早
- en: '**Hint**: Which level does this happen on? Does it happen in the Unity Editor?
    Does it happen all the time? If not, what are you doing and what''s different?'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：这个问题发生在哪个关卡？是在 Unity 编辑器中发生的吗？是每次都发生吗？如果不是，你在做什么？有什么不同之处？'
- en: 'You may be able to solve some of these questions by Googling key problems.
    Others are more specific, and you may need to add `Debug.Log()` to parts of your
    code holding variable names so that you can see what''s changed after a certain
    point in the game. For example, does `GameManager.playerLives` debug a different
    value than it should at certain points in the game? If you''re using Microsoft
    Visual Studio as your IDE, you may want to start adding breakpoints and step through
    your code to see what changes. If you don''t know what breakpoints are, I suggest
    that you check out the following link: [https://docs.microsoft.com/en-us/visualstudio/debugger/using-breakpoints?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/using-breakpoints?view=vs-2019).'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以通过 Google 搜索关键问题来解决这些问题。其他问题可能更具体，你可能需要在你代码中包含变量名的部分添加 `Debug.Log()`，以便在游戏的一定点后看到发生了什么变化。例如，`GameManager.playerLives`
    在游戏的一定点是否调试了与预期不同的值？如果你使用 Microsoft Visual Studio 作为你的 IDE，你可能想开始添加断点并逐步执行你的代码以查看发生了什么变化。如果你不知道断点是什么，我建议你查看以下链接：[https://docs.microsoft.com/en-us/visualstudio/debugger/using-breakpoints?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/using-breakpoints?view=vs-2019)。
- en: To potentially help with these performance issues, we are going to check out
    the **Profiler** tool and see how it can help us with checking the performance
    of our game.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可能帮助解决这些性能问题，我们将检查**分析器**工具，看看它如何帮助我们检查游戏性能。
- en: Understanding the Profiler tools
  id: totrans-744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解分析器工具
- en: In this section, we will be checking out one of the Unity Editor's tools – **Profiler**.
    This handy tool will show us where our game may spike in demands for system resources
    and/or show where our game is using too many resources at once.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查 Unity 编辑器的一个工具 – **分析器**。这个实用的工具将向我们展示我们的游戏可能在系统资源需求方面出现峰值，以及我们的游戏何时一次性使用过多资源。
- en: 'Let''s open the **Profiler** window and see its default layout before going
    into any more detail about it:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解之前，让我们打开**分析器**窗口，看看它的默认布局：
- en: At the top of the Unity Editor, select **Window** | **Profiler**.
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的顶部，选择**窗口** | **分析器**。
- en: 'The **Profiler** window behaves like any other new window in Unity. Typically,
    **Profiler** should run well in fullscreen mode on a second screen. Otherwise,
    dock **Profiler** down with **Console**, as shown in the following screenshot:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析器**窗口在 Unity 中表现得像任何其他新窗口。通常，**分析器**应在第二屏幕的全屏模式下运行良好。否则，将**分析器**与**控制台**一起停靠，如图下截图所示：'
- en: '![Figure 13.67 – The ''Profiler'' window'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.67 – ‘分析器’窗口'
- en: '](img/Figure_13.67_B18381.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.67_B18381.jpg)'
- en: Figure 13.67 – The 'Profiler' window
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.67 – ‘分析器’窗口
- en: At the top of the Unity Editor, press the **Play** button. After about 5 seconds
    (roughly), press the **Pause** button (it doesn't matter which scene is running).
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的顶部，按**播放**按钮。大约 5 秒（左右）后，按**暂停**按钮（运行的场景无关紧要）。
- en: 'The **Profiler** window will come alive, showing a graph and a table of information.
    This will be split into four sections, as shown in the following screenshot:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析器**窗口将变得活跃，显示一个图表和信息表。这将被分为四个部分，如下面的截图所示：'
- en: '![Figure 13.68 – Sections of the ''Profiler'' window'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.68 – ‘分析器’窗口的各个部分'
- en: '](img/Figure_13.68_B18381.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.68_B18381.jpg)'
- en: Figure 13.68 – Sections of the 'Profiler' window
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.68 – ‘分析器’窗口的各个部分
- en: 'Let''s take a look at these sections in more depth:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看这些部分：
- en: '**Profiler Modules** – A breakdown of modules that give measurements for each
    property that can be added.'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析器模块** – 对每个可以添加的属性的测量值的模块分解。'
- en: '![Figure 13.69 – Profiler Modules'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.69 – 分析器模块'
- en: '](img/Figure_13.69_B18381.jpg)'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.69_B18381.jpg)'
- en: Figure 13.69 – Profiler Modules
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.69 – 分析器模块
- en: '**Profiler Controls** – Navigation of controls to move through frames.'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析器控制** – 通过控制导航来移动帧。'
- en: '**Frame Chart** – In this section, we can click and scrub (drag) the mouse
    to see an indicator on the area. The **Module Details Panel** will list an update
    on what resources are being used during play mode (depending on which module is
    selected).'
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**帧图表** – 在这个部分，我们可以点击并拖动鼠标来查看区域上的指示器。**模块详细信息面板**将列出在播放模式期间使用的资源更新（取决于选择的哪个模块）。'
- en: '**Module Details Panel** – Selecting each profiler module will give further
    details in the module details panel. For example, if **CPU Usage** is selected,
    there will be an "**Overview**" with an individual breakdown of which resources
    are used the most. If **GPU Usage** is selected, we are given two different types
    of **Hierarchy** panels (**Hierarchy** and **Hierarchy Raw**). We''ll explain
    more about a scenario using the profiler and the module details panel next.'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模块详细信息面板** – 选择每个分析器模块将在模块详细信息面板中提供更多详细信息。例如，如果选择**CPU 使用率**，将有一个“**概述**”，其中包含对哪些资源使用最多的详细分解。如果选择**GPU
    使用率**，我们将获得两种不同类型的**层次结构**面板（**层次结构**和**层次结构原始**）。我们将在下一节中解释如何使用分析器和模块详细信息面板的情景。'
- en: Let's take a further look at the profiler and how to diagnose a performance
    spike.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步了解分析器以及如何诊断性能峰值。
- en: The following screenshot shows a highlighted spike (denoted by **i**), along
    with the indicator. We can uncheck each of the properties within the "GPU Usage"
    module (denoted by ii) to see what is causing the spike in the **Frame Chart**.
    Also, update the **Module Details Panel** (denoted by iii) list to show what's
    causing the performance spike.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个高亮的峰值（标记为 **i**），以及指示器。我们可以取消选中“GPU 使用率”模块（标记为 ii）内的每个属性，以查看导致**帧图表**中峰值的原因。同时，更新**模块详细信息面板**（标记为
    iii）列表以显示导致性能峰值的原因。
- en: '![Figure 13.70 – ''Profiler'' showing signs of a performance spike while the
    game is running'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.70 – 游戏运行时‘分析器’显示性能峰值迹象'
- en: '](img/Figure_13.70_B18381.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.70_B18381.jpg)'
- en: Figure 13.70 – 'Profiler' showing signs of a performance spike while the game
    is running
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.70 – 游戏运行时‘分析器’显示性能峰值迹象
- en: In the `UpdateDepthTexture.`
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UpdateDepthTexture.`
- en: With a quick Google search, we can see why this is happening and whether there
    is anything we can do to fix the issue. According to a topic on the Unity forums,
    this issue is caused by the profiler itself, which is fine, as we won't be requiring
    the profiler in the final build. Try to reproduce spikes, cross-compare, and check
    more than one answer to verify as much as possible that your spike relates. It's
    likely you will find a way to minimize/remove the issue.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速 Google 搜索，我们可以看到为什么会出现这种情况，以及我们是否可以采取任何措施来修复问题。根据 Unity 论坛上的一个主题，此问题是由分析器本身引起的，这是可以接受的，因为我们不会在最终构建中需要分析器。尝试重现峰值，交叉比较，并检查多个答案以尽可能多地验证您的峰值是否相关。您很可能会找到一种方法来最小化/删除问题。
- en: 'Another way of checking this, and one that will possibly solve the issue, is
    to run our game outside of the Unity Editor to remove any resources being used
    up. One way of tackling this is to build and run (denoted by iii) our game as
    a standalone (denoted by i) **Development Build** and auto-connect it to the **Profiler**
    window (denoted by ii), as shown in the following screenshots:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检查此问题的方法，可能也是解决此问题的方法，是在 Unity 编辑器外运行我们的游戏，以删除任何正在使用的资源。处理此问题的一种方法是将我们的游戏作为独立（标记为
    i）**开发版本**构建并运行（标记为 iii），并将其自动连接到**分析器**窗口（标记为 ii），如下面的截图所示：
- en: '![Figure 13.71 – Killer Wave running with ''Profiler'' outside of the Unity
    Editor'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.71 – 在 Unity 编辑器外使用‘分析器’运行的‘Killer Wave’'
- en: '](img/Figure_13.71_B18381.jpg)'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.71_B18381.jpg)'
- en: Figure 13.71 – Killer Wave running with 'Profiler' outside of the Unity Editor
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.71 – 'Killer Wave'在Unity编辑器外运行，带有'性能分析器'
- en: As you can see, we no longer have this resource issue showing up in our **Development
    Build** (denoted by ***** in the preceding screenshot).
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不再在我们的**开发构建**（如前一张截图中的*****所示）中出现此资源问题。
- en: Further Information
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about the **Profiler** window, check out the
    following link: [https://docs.unity3d.com/Manual/Profiler.html](https://docs.unity3d.com/Manual/Profiler.html).'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于**性能分析器**窗口的信息，请查看以下链接：[https://docs.unity3d.com/Manual/Profiler.html](https://docs.unity3d.com/Manual/Profiler.html)。
- en: As we have seen, the **Profiler** window is a helpful tool that helps us rectify
    any issues with memory leaks, garbage collection, and any other possible issues.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**性能分析器**窗口是一个有用的工具，它帮助我们纠正内存泄漏、垃圾回收以及任何其他可能的错误。
- en: Now, we'll look at our last Unity tool, which we can use to see how the graphics
    pipeline is being used to display our game.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看我们的最后一个Unity工具，我们可以用它来查看图形管线是如何用来显示我们的游戏的。
- en: Frame Debugger
  id: totrans-781
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧调试器
- en: '**Frame Debugger** can be used to show how each frame is created for our game
    in the Unity Editor. This can help us with any potential shader issues regarding
    how a piece of art is displayed. However, this is also a healthy reminder of how
    a scene is brought together and challenges potentially any unnecessary effects/materials
    used.'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧调试**可以用来在Unity编辑器中显示我们游戏的每个帧是如何创建的。这可以帮助我们解决任何关于艺术作品显示的潜在着色器问题。然而，这也是一个健康的提醒，说明了场景是如何组合起来的，并挑战了可能使用的任何不必要的效果/材质。'
- en: 'To access the **Frame Debugger** tool, do the following:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问**帧调试**工具，请执行以下操作：
- en: At the top of the Unity Editor, select **Window** | **Frame Debugger**.
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器顶部，选择**窗口** | **帧调试**。
- en: Our **Frame Debug** window will appear.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**帧调试**窗口将出现。
- en: Now, let's load up our `title` scene from the `Assets/Scene`).
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从`Assets/Scene`加载我们的`title`场景。
- en: Click on the **Enable** button at the top of the **Frame Debug** window to see
    how the frame is created.
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**帧调试**窗口顶部的**启用**按钮，以查看帧是如何创建的。
- en: The **Frame Debug** window will come alive and show us a list of tools and properties
    being implemented.
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**帧调试**窗口将变得活跃，并显示正在实施的工具和属性列表。'
- en: With the **Game** window in view, scroll the slider (highlighted in the following
    screenshot) in the **Frame Debug** window from the right slowly to the left to
    see how this frame is created.
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**游戏**窗口可见的情况下，将**帧调试**窗口中的滑块（以下截图中所突出显示）从右向左缓慢滚动，以查看此帧是如何创建的。
- en: 'The following screenshots show the **Frame Debug** window with the **Enable**
    button highlighted, along with three steps (**4**, **8**, and **26**):'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有高亮显示的**启用**按钮的**帧调试**窗口，以及三个步骤（**4**、**8**和**26**）：
- en: '![Figure 13.72 – The ''Frame Debugger'' tool going through each step of your
    game'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.72 – ''帧调试器''工具遍历游戏中的每个步骤'
- en: '](img/Figure_13.72_B18381.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.72_B18381.jpg)'
- en: Figure 13.72 – The 'Frame Debugger' tool going through each step of your game
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.72 – '帧调试器'工具遍历游戏中的每个步骤
- en: Note that *step 4* shows the image that has been applied to the **Bloom** texture
    to create the shiny glow in *step 26*.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*步骤4*显示了应用于**Bloom**纹理的图像，以在**步骤26**中创建闪亮的发光效果。
- en: After going through each of these steps and seeing all the maps, render targets,
    and all the other necessary steps to make a frame, it's also possible to select
    draw calls (a call to the graphics card) from the **Frame Debug** window, which
    will highlight the game object it's referring to.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成每个步骤并查看所有地图、渲染目标和创建帧所需的其它所有必要步骤后，您还可以从**帧调试**窗口中选择绘制调用（对图形卡的调用），这将突出显示它所引用的游戏对象。
- en: 'In the following screenshots, we have the `shop` scene with a total of `47`
    steps, as shown at the top of **Frame Debug**. If one of the draw calls is selected
    within the **Frame Debug** window (the middle highlighted rectangle), it will
    ping which game object it is referring to in the **Hierarchy** window, as shown
    on the left-hand side:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们有`shop`场景，总共有`47`个步骤，如**帧调试**窗口顶部所示。如果在**帧调试**窗口中选中了绘制调用（中间突出显示的矩形），它将在**层次结构**窗口中ping它所引用的游戏对象，如左侧所示：
- en: '![Figure 13.72 – The ''Frame Debugger'' tool going through each step of your
    game'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.72 – ''帧调试器''工具遍历游戏中的每个步骤'
- en: '](img/Figure_13.73_B18381.jpg)'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.73_B18381.jpg)'
- en: Figure 13.73 – Frame Debugger showing which game object it's referring to
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.73 – 帧调试器显示它所引用的游戏对象
- en: Further Information
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to find out more about **Frame Debugger** and its capabilities,
    check out the following link: [https://docs.unity3d.com/Manual/FrameDebugger.html](https://docs.unity3d.com/Manual/FrameDebugger.html).'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于**帧调试器**及其功能的信息，请查看以下链接：[https://docs.unity3d.com/Manual/FrameDebugger.html](https://docs.unity3d.com/Manual/FrameDebugger.html)。
- en: Hopefully, you will be able to make great use of **Frame Debugger** and debug
    any graphical issues and understand the graphical pipeline more with Unity.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能充分利用**帧调试器**并调试任何图形问题，以及通过Unity更深入地理解图形管道。
- en: Before we summarize this chapter, we are going to go through each of the four
    bug reports from our game's bug testers.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结这一章之前，我们将逐一查看我们游戏测试人员提供的四个错误报告。
- en: Tackling bugs – answers
  id: totrans-804
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决bug – 答案
- en: As programmers, we need to, for example, follow a value through a series of
    steps to see whether it's the reason why code is not doing what it's supposed
    to do. However, there are also different methods for carrying out testing, and
    it's also good to think about checking your or someone else's code after an update
    has been applied to the project's code.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们需要例如，跟踪一系列步骤中的值，以查看它是否是代码没有按预期执行的原因。然而，也有不同的测试执行方法，在项目代码更新后检查你或他人的代码也是一个好主意。
- en: As a programmer, you will likely hear of different types of methodology that
    are carried out and how much of a project's code should be tested.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你可能会听到关于执行的不同类型的方法以及一个项目代码应该测试多少的内容。
- en: 'Here are the more popular types of tests you will carry out on your own and
    other projects:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你在自己的项目和其它项目上将要执行的一些更流行的测试类型：
- en: '`for` loop or a method to make sure a small block of code is working correctly.'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环或一种确保一小块代码正确工作的方法。'
- en: '**Integration**: This type of test is used when multiple sections of code (which
    could be from other programmers) are brought together and tested to see whether
    any issues occur when the game is running.'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**: 当多个代码部分（可能来自其他程序员）被合并在一起并测试以查看游戏运行时是否出现问题时，会使用这种类型的测试。'
- en: '**Smoke**: These are tests that are carried out to determine whether the current
    build is stable. This type of test helps bug testers decide whether to proceed
    with further tests. Smoke tests should be minimal and frequent between builds.'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟测试**: 这些测试是为了确定当前构建是否稳定。这种类型的测试有助于测试人员决定是否继续进行进一步的测试。冒烟测试应该是最小化和频繁的。'
- en: '**Regression**: When adding code to a project, there is always a chance that
    the existing code may clash with the new code that''s been added. Here, you check
    the existing code to make sure that a change or addition hasn''t created errors.
    These tests can be run manually for small projects or a suite of tests each time
    an update has been implemented for larger projects.'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**: 当向项目中添加代码时，现有代码可能与新添加的代码发生冲突。在这里，你检查现有代码以确保更改或添加没有产生错误。这些测试可以手动运行小型项目，或者在大型项目中每次实施更新时运行一系列测试。'
- en: '**System**: Typically, a system test would be conducted after an integration
    test to check the project code as a whole for any defects and general code behavior.'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**: 通常，在集成测试之后，会进行系统测试来检查整个项目代码是否存在缺陷以及代码的一般行为。'
- en: Testing often helps you to keep track of a project overall and not be solely
    focused on one part of it. This is also why it's important to have some kind of
    plan; for example, we have our Game Design Brief. We could also be even more technical
    and have a UML diagram to help us see the connections between our scripts. So,
    we shouldn't think any differently about coding. Now that we have our code, we
    can hopefully improve it, make it more efficient, and remind ourselves of the
    SOLID principles.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常有助于你跟踪整个项目，而不仅仅关注其一部分。这也是为什么制定某种计划很重要的原因；例如，我们有我们的游戏设计简报。我们还可以更加技术性地拥有一个UML图来帮助我们查看脚本之间的连接。因此，我们不应该对编码有其他的想法。现在我们有了代码，我们希望改进它，使其更高效，并提醒自己SOLID原则。
- en: Speaking of bug-testing, have you thought of any solutions to the four bug reports
    that were made for our game back in the *Tackling bugs* section? Hopefully, you
    have, as we are going to go through each of them now.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 说到bug测试，你有没有想过在*解决bug*部分提出的我们游戏的四个错误报告的解决方案？希望你已经有了，因为我们现在将逐一查看它们。
- en: Bug report – "Standalone AD button" solution
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误报告 – "独立AD按钮"解决方案
- en: As you may recall, we have our `shop` scene, which features an `AD` button.
    When pressed, the player will watch an advert and receive shop credits as a reward.
    This works fine in the mobile version of the game, but it had been reported that
    this button does not work on the standalone version.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，我们有一个 `shop` 场景，其中有一个 `AD` 按钮。当按下时，玩家将观看广告并获得商店积分作为奖励。这在游戏的移动版本中运行良好，但已经有人报告说这个按钮在独立版本中不起作用。
- en: 'The short answer to this is that Unity doesn''t support adverts for standalone
    builds. This leaves us either looking for a solution to have an advert in our
    game or turning off the `AD` button game object, either through scripting or manually
    through the `AD` button will automatically make the `Start` button resize, thanks
    to **Vertical Layout Group**. Some redesign would need to be implemented to solve
    this issue, rather than it being solely a programmer problem:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的简短答案是，Unity 不支持独立构建的广告。这让我们要么寻找在游戏中添加广告的解决方案，要么关闭 `AD` 按钮游戏对象，无论是通过脚本还是手动通过
    `AD` 按钮都会自动使 `Start` 按钮调整大小，多亏了 **垂直布局组**。为了解决这个问题，我们需要实施一些重新设计，而不仅仅是程序员的问题：
- en: '![Figure 13.74 – The Shop button layout without the AD button'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.74 – 没有AD按钮的商店按钮布局'
- en: '](img/Figure_13.74_B18381.jpg)'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.74_B18381.jpg)'
- en: Figure 13.74 – The Shop button layout without the AD button
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.74 – 没有AD按钮的商店按钮布局
- en: Bug report – "Resetting the player's lives" solution
  id: totrans-821
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障报告——“重置玩家的生命”的解决方案
- en: To make the player's lives reset correctly, we need to apply a fix in the `TitleComponent`
    script so that when our game restarts back at the beginning from either quitting
    or the player losing all of their lives, `GameManager.playerLives` is reset back
    to `3`.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确重置玩家的生命，我们需要在 `TitleComponent` 脚本中应用一个修复，以便当我们的游戏从退出或玩家失去所有生命重新开始时，`GameManager.playerLives`
    被重置回 `3`。
- en: 'In the `TitleComponent` script, add the following code to reset the player''s
    lives back to `3`:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TitleComponent` 脚本中添加以下代码以将玩家的生命重置回 `3`：
- en: '[PRE20]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Save the `TitleComponent` script.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 `TitleComponent` 脚本。
- en: Bug report – "Slower systems on level 3" solution
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障报告——“第 3 级别较慢的系统”的解决方案
- en: 'The benefit of having multiple devices to run a series of tests is vital. If
    your game supports a low spec device, then you are also appealing to a wider audience.
    Reports for our game are coming in stating that the device struggles with lower-powered
    devices. To fix this, you need to ensure the following:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个设备来运行一系列测试的好处至关重要。如果您的游戏支持低规格设备，那么您也在吸引更广泛的受众。关于我们游戏的报告表明，设备在低功耗设备上表现不佳。为了解决这个问题，您需要确保以下内容：
- en: Post-processing is disabled.
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后处理已禁用。
- en: Fewer enemies are in the levels on the screen at once. You can do this by changing
    the speed of `EnemySpawner` in the **Inspector** window.
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上同时出现的敌人更少。您可以通过在 **检查器** 窗口中更改 `EnemySpawner` 的速度来实现这一点。
- en: Remove any global illumination from scenes and apply basic lighting.
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从场景中移除任何全局照明并应用基本照明。
- en: Remove additional backgrounds from the `shop` scene.
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `shop` 场景中移除额外的背景。
- en: Change the `CameraMovement` script's `Start` function. Invoke from a `6`-second
    wait to `7` seconds to give the device more time to load.
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `CameraMovement` 脚本的 `Start` 函数。从 `6` 秒等待时间改为 `7` 秒，以给设备更多的时间来加载。
- en: Bug report – "Sometimes, the game ends too quickly" solution
  id: totrans-833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障报告——“有时游戏结束得太快”的解决方案
- en: It has been reported that levels finish earlier than they should do, so instead
    of a level lasting 25 seconds, it has been reported to last only 5–10 seconds.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 已有报告称，关卡结束得比预期要早，因此，而不是关卡持续 25 秒，据报道只持续了 5-10 秒。
- en: 'This is happening because the `BeginGame` method in the `ScenesManager` script
    is not resetting the `gameTimer` variable back to zero. Follow these steps to
    fix this bug:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `ScenesManager` 脚本中的 `BeginGame` 方法没有将 `gameTimer` 变量重置为零。按照以下步骤修复此错误：
- en: Open the `ScenesManager` script.
  id: totrans-836
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ScenesManager` 脚本。
- en: 'Scroll down to the `BeginGame` method, and at the top of the method, add the
    following line:'
  id: totrans-837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `BeginGame` 方法，并在方法顶部添加以下行：
- en: '[PRE21]'
  id: totrans-838
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Save the `ScenesManager` script.
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `ScenesManager` 脚本。
- en: Test your code, keep revisiting it, and keep polishing it. Continue to look
    at other ways of improving your script. Accept that the first few lines of code
    aren't going to be your best and that it's okay to revisit and keep optimizing
    your code.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的代码，不断回顾它，并不断打磨它。继续寻找改进脚本的其他方法。接受最初几行代码可能不是您最好的，并且重新访问并持续优化代码是可以的。
- en: Further Information
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步信息
- en: 'If you would like to continue looking into how to improve the code for the
    game you''ve created, check out the following link from Unity: [https://learn.unity.com/tutorial/fixing-performance-problems#5c7f8528edbc2a002053b595](https://learn.unity.com/tutorial/fixing-performance-problems#5c7f8528edbc2a002053b595).'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要继续了解如何改进你创建的游戏的代码，请查看Unity提供的以下链接：[https://learn.unity.com/tutorial/fixing-performance-problems#5c7f8528edbc2a002053b595](https://learn.unity.com/tutorial/fixing-performance-problems#5c7f8528edbc2a002053b595)。
- en: That brings us to the end of this section, where we built our standalone version
    of our game and looked at potential issues that we needed to overcome, which we
    picked up with our bug testers. After that, we looked at the **Profiler** window,
    which we can use to monitor the performance of our game, and **Frame Debugger**,
    which shows what steps are followed to make a frame. We then discussed how and
    when to test our game, before looking at the bugs we were issued and how to correct
    them.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了本节的结尾，我们构建了游戏的独立版本，并检查了需要克服的潜在问题，这些问题是我们与虫害测试员一起解决的。之后，我们查看了**分析器**窗口，我们可以用它来监控游戏性能，以及**帧调试器**，它显示了制作一帧所遵循的步骤。然后，我们讨论了何时以及如何测试我们的游戏，在查看我们收到的错误以及如何纠正它们之前。
- en: Now, let's discuss this chapter as a whole.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们整体讨论这一章。
- en: Summary
  id: totrans-845
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about taking the game we have been developing throughout this
    book and putting it together as it reached its end. We spoke about how we could
    push our game further by adding physics collisions other than bullets or buttons.
    We set up collisions that got us more involved with tweaking the Rigidbody component
    to make our game objects behave in different ways. We did this by adding drag
    and affecting our scene's gravity.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是关于将我们在整本书中开发的游戏整合在一起，直到它达到尾声。我们讨论了如何通过添加除子弹或按钮之外的物理碰撞来推动我们的游戏进一步发展。我们设置了碰撞，这使我们更多地参与了调整Rigidbody组件，使我们的游戏对象以不同的方式表现。我们通过添加阻力和影响场景的重力来实现这一点。
- en: We then moved on and discussed how we could improve our game's screen ratio
    by updating its Canvas Scaler and how it would make our UI look more stable under
    different ratios. We also made our game-playing area more flexible under the different
    resolutions using different Unity functions, such as `WorldToViewportPoint`.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续讨论如何通过更新Canvas Scaler来改进我们游戏的屏幕比例，以及它如何使我们的UI在不同比例下看起来更稳定。我们还使用不同的Unity函数，如`WorldToViewportPoint`，使我们的游戏区域在不同分辨率下更加灵活。
- en: At this point, our mobile version was ready to be built and tested so that we
    could see how well it ran with updated touchscreen controls. We also looked into
    its optimization in terms of textures and compressed them to decrease the size
    of our game and make it run better overall.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的移动版本已经准备好构建和测试，以便我们可以看到它使用更新的触摸屏控制运行得如何。我们还研究了其在纹理方面的优化，并将它们压缩以减小游戏的大小，使其整体运行得更好。
- en: After the mobile build, we looked at the PC version and made some more changes
    to improve the look of the game. We did this because the standalone machine was
    likely going to have a more powerful CPU, graphics card, memory, and so on. Then,
    we added effects such as post-processing to change the look and feel of our game
    to make it more polished. We continued adding more polish to our game by adding
    global illumination and fogging effects from our **Lighting** settings window.
    This made our materials shine red and bleed through the foggy darkness to give
    them more of a futuristic feel. We also added reflective statues to our end level.
    These made use of the reflection probe component. After that, we discussed how
    to optimize it in terms of the size of its reflective texture.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动版本构建之后，我们检查了PC版本，并对游戏的外观进行了更多改进。我们这样做是因为独立机器可能拥有更强大的CPU、显卡、内存等。然后，我们添加了如后处理等效果，以改变游戏的外观和感觉，使其更加精致。我们通过从**照明**设置窗口添加全局照明和雾化效果来继续为我们的游戏添加更多精致。这使得我们的材料闪耀红色，并透过雾蒙蒙的黑暗，赋予它们更多未来感。我们还向最终关卡添加了反射雕像。这些使用了反射探针组件。之后，我们讨论了如何从其反射纹理的大小方面优化它。
- en: Finally, we looked into building and testing our standalone version and also
    introduced some bug-testing scenarios, where our bug testers found issues with
    things not working the way they should. We reviewed and addressed them together.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了构建和测试我们的独立版本，并介绍了一些虫害测试场景，其中我们的虫害测试员发现了某些事物运行不正常的问题。我们一起审查并解决了这些问题。
- en: Making a game isn't easy, and there are many ways in which a game can be made.
    Someone will always have a better way than you and likely pick holes in it. However,
    as mentioned in this chapter, a game can be made in sweeps and improved at each
    sweep; the worst thing to do is to try and make a perfect game the first time
    around. If you think like that, you'll end up with no game at all.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个游戏并不容易，制作游戏的方法有很多。总有人会比你的方法更好，并且可能会找到它的漏洞。然而，正如本章所述，游戏可以在每个阶段制作并改进；最糟糕的事情就是试图第一次就制作出一个完美的游戏。如果你这样想，你最终可能一个游戏都做不出来。
- en: 'Are you ready for the full mock test? You should be; see what you''ve remembered
    by reading (and hopefully recreating) this book. If there are any problems with
    the questions that you can''t answer, there are reference numbers next to each
    question (example: `CH1,` meaning Chapter 1) to help jog your memory. This will
    all be explained thoroughly in the next chapter – enjoy it.'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好进行完整的模拟测试了吗？你应该准备好了；通过阅读（并希望重现）这本书来检验你记住了什么。如果你对某些无法回答的问题有任何问题，每个问题旁边都有参考编号（例如：`CH1`，表示第一章）来帮助你回忆。这一切都会在下一章中详细解释——享受它吧。
