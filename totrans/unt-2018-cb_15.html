<html><head></head><body>
        

                            
                    <h1 class="header-title">Editor Extensions and Immediate Mode GUI (IMGUI)</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Menu items to log messages and clear the console</li>
<li>Displaying a panel with text data</li>
<li>An interactive panel and persistent storage</li>
<li>Creating GameObjects, parenting and registering Undo actions</li>
<li>Working with selected objects and deactivating menu items</li>
<li>Menu item to create 100 randomly positioned prefab clones</li>
<li>A progress bar to display proportion completed of Editor extension processing</li>
<li>An editor extension to allow pickup type (and parameters) to be changed at design time via a custom Inspector UI</li>
<li>An editor extension to have an object-creator GameObject, with buttons to instantiate different pickups at cross-hair object's location in scene</li>
<li>Extensible class-based code architecture to manage complex IMGUIs</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>One aspect of game development in general (and inventories as our particular examples in this chapter) is the distinction about when we undertake an activity. Runtime is when the game is running (and when all our software and UI choices take effect). However, design-time is the time when different members of our game design team work on constructing a wide range of game components, including the scripts, audio and visual assets, and the process of constructing each game level (or scene in Unity-speak).</p>
<p>Unity's Editor extensions are scripting and multimedia components that enable a game software engineer to make design-time work easier and less likely to introduce errors. Editor extensions allow workflow improvements, thus allowing designers to achieve their goals quicker and more easily; for example, removing the need for any scripting knowledge when generating many randomly located inventory pickups in a scene via a menu choice or editing the type or properties of pickups being hand-placed in different locations in a level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Big picture</h1>
                
            
            
                
<p>Apart from plain text, there are four sections below will give you an idea of what this chapter is about.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity Immediate Mode GUI (IMGUI)</h1>
                
            
            
                
<p>In the early versions of Unity, all <strong>UI</strong> components were created through code - there was no <strong>Canvas</strong>, or <strong>Rect</strong> Transform, or drag-and-drop <strong>UI</strong> control layout and so on. A few years ago (Unity 4.6), Unity introduced what we now know as the <strong>UI</strong> system. The new (play-mode) UI system is an example of a <strong>Retained Mode UI</strong>; the <strong>UI</strong> items we created are remembered frame-to-frame and don't need to be re-created/displayed by us as developers. However, the code-based GUI system still has an important role to play for Editor Extensions. The <strong>IMGUI</strong> system is called <strong>Immediate Mode</strong>, since its code executes one more times each frame. Therefore, there is no need to clear previous GUI displays, since that it automatic.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying and saving changes</h1>
                
            
            
                
<p>The concept of serialization is raised in the Editor extension recipes, whereby we need to remember that, when we are editing item properties in the Inspector, each change needs to be saved to disk, so that the updated property is correct when we next use or edit that item. This is achieved in the <kbd>OnInspectorGUI()</kbd> method by first calling the <kbd>serializedObject.Update()</kbd> method and, after all changes have been made in the Inspector, finally calling the <kbd>serializedObject.ApplyModifiedProperties()</kbd> method.</p>
<p>We can detect when the user has made a change to a GUI control by interrogating Unity's special public bool value: <kbd>GUI.changed</kbd>. This is set to true if a GUI control has changed input data (for example, if the user has been typing or clicking GUI controls). Here is a simple example of using <kbd>GUI.changed</kbd> to log a message when the content of a text input field has been updated:</p>
<pre>stringToEdit = GUILayout.TextField(stringToEdit, 25);<br/> <br/> if (GUI.changed)<br/>     Debug.Log("new contents of 'stringToEdit' = " + stringToEdit); </pre>
<p>Unity's EditorGUI class provides <kbd>Begin-End ChangeCheck()</kbd> methods that will set GUI.changed to true if the user has changed one or more interactive GUI components in a block of statements delimited by these methods:</p>
<pre>EditorGUI.BeginChangeCheck();<br/> stringToEdit = GUILayout.TextField(stringToEdit, 25);<br/> ... other interactive GUI statements here<br/> EditorGUI.EndChangeCheck();<br/> <br/> // logic if any have changed<br/> if(GUI.changed)<br/>     ... do actions since user has changed at least one GUI control </pre>
<p>If they have, we can save a statement, since <kbd>EditorGUI.EndChangeCheck()</kbd>, as well as declaring the end of the block of statements for GUI.change. This also returns the bool value of GUI.changed. So, we can actually use this method call in our if-statement instead of GUI.changed. In essence:</p>
<pre>EditorGUI.BeginChangeCheck();<br/> stringToEdit = GUILayout.TextField(stringToEdit, 25);<br/> ... other interactive GUI statements here<br/> <br/> // logic if any have changed<br/> if(EditorGUI.EndChangeCheck())<br/>     ... do actions since user has changed at least one GUI control </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Memory - EditorPrefs persistent storage</h1>
                
            
            
                
<p class="MsoSalutation">An issue with Immediate Mode systems is that everything is temporary and forgotten. Unity provides <strong>EditorPrefs,</strong> similar to <strong>PlayerPrefs,</strong> a facility for storing data that is remembered between the closing of a panel and its reopening. Just as with <strong>PlayerPrefs,</strong> different <strong>types</strong> of values can be stored and retrieved using <kbd>Get&lt;&gt;()</kbd> and <kbd>Set&lt;&gt;()</kbd> methods, including:</p>
<ul>
<li><kbd>SetString(&lt;key&gt;, &lt;value&gt;)</kbd></li>
<li><kbd>GetString(&lt;key&gt;)</kbd></li>
<li>And so on<br/></li>
</ul>
<p>Also provided are methods to delete all stored EditorPrefs data (<kbd>DeleteAll()</kbd>), to delete just one item for a given key (<kbd>DeleteKey(&lt;key&gt;)</kbd>), and to check if an item exists for a given key (<kbd>HasKey(&lt;key&gt;)</kbd>).</p>
<p>Of course, <kbd>DeleteAll()</kbd> isn't something to be used without careful consideration. There is an example of <kbd>DeleteAll()</kbd> in the Unity documentation that ensures the game developer is first asked if they are sure they really want to delete all stored values: <a href="https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html">https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html</a></p>
<p>Typically, values are <strong>loaded</strong> from <strong>EditorPrefs</strong> using getters (if the <kbd>&lt;key&gt;</kbd>s exist) each time the panel gets the focus. For example:</p>
<pre>private void OnFocus()  <br/> {<br/>     if (EditorPrefs.HasKey("PlayerName"))<br/>         playerName = EditorPrefs.GetString("PlayerName");<br/> } </pre>
<p>Likewise, when panels lose focus (<kbd>OnLostFocus()</kbd>) or are closed (<kbd>OnDestroy()</kbd>) we may wish to automatically save any values to EditorPrefs using setters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conclusions and further resources</h1>
                
            
            
                
<p>While Editor extensions are quite an advanced topic, having someone on your team who can write custom editor components, such as those we illustrate, can greatly increase the productivity of a small team with only one or two members who are confident at scripting.</p>
<p>In this chapter, we introduce recipes demonstrating some Unity Editor extension scripts, illustrating how we can make things easier, less-script based, and less prone to errors, by limiting and controlling the properties of objects and how they are selected or changed via the Inspector.</p>
<p>There is a lot to working with Editor Extensions and the IMGUI. Here is a list of resources to learn more about these topics:</p>
<ul>
<li>Learn more about EditorPrefs in the Unity Documentation: <a href="https://docs.unity3d.com/ScriptReference/EditorPrefs.html">https://docs.unity3d.com/ScriptReference/EditorPrefs.html</a></li>
<li>Unity blog post about IMGUI: <a href="https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/">https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/</a></li>
<li>Video about IMGUI by Casey Muratori: <a href="https://caseymuratori.com/blog_0001">https://caseymuratori.com/blog_0001</a></li>
<li>the Unity Immediate Mode GUI reference pages: <a href="https://docs.unity3d.com/Manual/GUIScriptingGuide.html">https://docs.unity3d.com/Manual/GUIScriptingGuide.html</a></li>
<li>The Unity GUI event scripting reference page: <a href="https://docs.unity3d.com/ScriptReference/Event.html">https://docs.unity3d.com/ScriptReference/Event.html</a></li>
<li>Unity scripting OnGUI reference page: <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html</a></li>
<li>Ryan Meier's blog: <a href="http://www.ryan-meier.com/blog/?p=72">http://www.ryan-meier.com/blog/?p=72</a></li>
<li>Tutsplus tutorials and custom scripts (including grids and color pickers): <a href="http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047">http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047</a></li>
<li>Gamasutra getting starting Editor Extensions article: <a href="https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php">https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php</a></li>
</ul>
<ul>
<li>Menu items: <a href="https://docs.unity3d.com/ScriptReference/MenuItem.html">https://docs.unity3d.com/ScriptReference/MenuItem.html</a></li>
<li>EditorGUI.BeingChangeCheck: <a href="https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html">https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Menu items to log messages and clear the console</h1>
                
            
            
                
<p>Custom menus are a great way to offer game developers easy access to your Editor Extension features. Logging actions is a good way to display and keep a record of actions performance and object properties that have been changed. In this recipe, we'll create a new menu for the Unity Editor application and a menu item that when selected logs a simple message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/83266c1e-2c0e-4c62-96d0-8d0956aba787.png" style="width:21.00em;height:4.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a menu with a menu item to log messages to console, follow these steps:</p>
<ol>
<li>In the Project panel, create a new folder, Editor.</li>
<li>In your new Editor folder, create a new C# script-class named <kbd>ConsoleUtilities.cs</kbd>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> using System.Reflection;<br/> <br/> public class ConsoleUtilities : EditorWindow<br/> {<br/>     [MenuItem("My Utilities/Clear Console")]<br/>     public static void ClearLogConsole()<br/>     {<br/>         var assembly = Assembly.GetAssembly(typeof(SceneView));<br/>         var type = assembly.GetType("UnityEditor.LogEntries");<br/>         var method = type.GetMethod("Clear");<br/>         method.Invoke(new object(), null);<br/>     }<br/> <br/>     [MenuItem("My Utilities/Log a message")]<br/>     public static void LogHello()<br/>     { <br/>         Debug.Log("Hello from my console utilties");<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you should now see a menu named My Utilities appear with two items Clear Console and Log a message.</li>
<li>You should now be able to clear the console and generate Log messages with these menu items.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created an editor extension script-class in a folder Editor that extends the <kbd>EditorWindow</kbd> class. You defined two methods; each method was immediately preceded by an attribute to add a menu item to a menu named My Utilities.</p>
<p>The <kbd>ClearLogConsole()</kbd> method was immediately preceded by an attribute declaring a new menu, My Utilities, and its single menu item <kbd>Clear Console</kbd>:</p>
<pre>    [MenuItem("My Utilities/Clear Console")] </pre>
<p>The MenuItem <strong>attribute</strong> immediately precedes a <strong>static</strong> method, that implements the actions to be executed if the menu item is selected by the user. The menu path is in the form:</p>
<ul>
<li>MenuName/MenuItemName or</li>
<li>MenuName/SubMenuName/MenuItemName and so on for submenus</li>
</ul>
<p>The <kbd>LogHello()</kbd> method creates a new Log message each time it is invoked.</p>
<p>The <kbd>ClearLogConsole()</kbd> method gets a reference to the Unity logs and clears them.</p>
<p>You can learn more about Editor Extensions for menus in the Unity tutorial on this topic: <a href="https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items">https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items</a></p>
<p>It should be noted that using Reflection is very slow and so generally only used for Editor scripts or scripts that are only executed once and a short delay will not impact upon the user's or game developer's quality of experience.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Keyboard shortcuts</h1>
                
            
            
                
<p>Special characters in the Menu Item string can be used to specify a keyboard shortcut for the menu item:</p>
<ul>
<li>% indicates the CTRL-key (Windows) or CMD-key (Mac)</li>
<li># indicate the SHIFT-key</li>
<li>&lt;c&gt; then the (lowercase) letter or character shortcut key (e.g. 'k' for the K-key)</li>
</ul>
<p>When keyboard shortcut has been defined, Unity also indicates this to the right of the menu item:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/15001952-a500-46a8-8342-4e63f2308462.png" style="width:22.58em;height:5.00em;"/></p>
<p>So, let's add shortcuts so that <em>CTRL</em>/<em>CMD</em>-<em>L</em> logs a message and <em>CTRL</em>/<em>CMD</em>-<em>K</em> clears the log (keys <em>L</em> and <em>K</em> are next to each other on the keyboard):</p>
<pre>[MenuItem("My Utilities/Log a message %l")] // CMD + L<br/> public static void LogHello()<br/> {<br/>     Debug.Log("Hello from my console utilties");<br/> }<br/> <br/> [MenuItem("My Utilities/Clear Console %k")] // CMD + K<br/> public static void ClearLogConsole()<br/> {<br/>     var assembly = Assembly.GetAssembly(typeof(SceneView));<br/>     var type = assembly.GetType("UnityEditor.LogEntries");<br/>     var method = type.GetMethod("Clear");<br/>     method.Invoke(new object(), null);<br/> } </pre>
<p>Learn more about Unity Menu Item Keyboard Shortcuts at <kbd>https://docs.unity3d.com/ScriptReference/MenuItem.html</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sub-menus</h1>
                
            
            
                
<p>You can create sub-menus by adding a third text item between forward slashes, in the following form:</p>
<pre>Menu Name/Sub-menu name/menu item </pre>
<p>So, to have a menu Utilities with a sub-menu Console and two items for that submenu, you could write the following:</p>
<pre>[MenuItem("Utilities/Console/Clear Console")]<br/> public static void ClearLogConsole() {<br/>     // code here<br/> }<br/> <br/> [MenuItem("Utilities/Console/Log a message")]<br/> public static void LogHello() {<br/>     // code here<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying a panel with text data</h1>
                
            
            
                
<p>Sometimes, we want to create and display a new panel as part of an Editor Extension. In this recipe, we create a menu item that creates and displays a new panel, displaying some text information:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c0f137bd-4fe3-40cb-bb0d-6bf2240af0b2.png" style="width:24.08em;height:9.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To display a panel with text data, follow these steps:</p>
<ol>
<li>In the Project panel, create a new folder, Editor.</li>
<li>In your new Editor folder, create a new C# script-class named <kbd>InformationPanel.cs</kbd>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class InformationPanel : EditorWindow<br/> {<br/>     [MenuItem("My Game/Info Panel")]<br/>     public static void ShowWindow()<br/>     {<br/>         GetWindow&lt;InformationPanel&gt;("My Game", true);<br/>     }<br/> <br/>     private void OnGUI()<br/>     {<br/>         GUILayout.Label("Hello editor world");<br/>         GUILayout.FlexibleSpace();<br/>         GUILayout.Label("Here is some important information");<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you should now see a menu named My Game appear, with menu item Info Panel.</li>
<li>Select menu item Info Panel - you should now see a new panel appear, entitled My Game and containing the two text messages.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You preceded the <kbd>ShowWindow()</kbd> method with an attribute to add a menu item Info Panel to a menu named My Game. The <kbd>GetWindow()</kbd> statement gets a reference to an InformationPanel object - if no such window-panel exists, it creates one. It searches for a window-panel of type (that is, for this script-class). The first argument is the title of the panel My Game. The true for the second argument tells Unity to make the window-panel have the focus (if a window panel already existed).</p>
<p>If a new window panel has been created it will always be given the focus.</p>
<p>The <kbd>OnGUI()</kbd> method, which executes a least once every frame, uses <kbd>GUILayout</kbd> to display two text labels. Since <kbd>GUILayout</kbd> begins adding items at the top-left, the first message Hello editor world appears in the top-left of the panel. Then there is a <kbd>FlexibleSpace()</kbd> statement. This tells the GUI layout manager to fill up as much (default - vertical) space as it can, while allowing space in the panel for any other content. The third statement displays a second text label. The result is that the second text label is pushed to the bottom of the panel by the <kbd>FlexibleSpace()</kbd>.</p>
<p>Try resizing the panel; you'll see the second text label is always at the bottom.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>Here are some details that you won't want to miss throughout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vertical centering</h1>
                
            
            
                
<p>If we wanted to vertically center some text, we can have a <kbd>FlexibleSpace()</kbd> statement both before and after the content. For example, the following code would vertically center text <kbd>Here is some important information</kbd>:</p>
<pre>GUILayout.Label("Hello editor world");<br/> <br/> GUILayout.FlexibleSpace();<br/> GUILayout.Label("Here is some important information");<br/> GUILayout.FlexibleSpace(); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Vertical and horizontal centering (middle of an area)</h1>
                
            
            
                
<p>To center horizontally, we need to change from the default vertical layout by starting (and ending) a horizontal layout, in the following form:</p>
<pre>GUILayout.BeginHorizontal();<br/> // content here is laid out horiztonally<br/> GUILayout.EndHorizontal(); </pre>
<p>By the having <kbd>FlexibleSpace()</kbd> before and after the content in the horizontal layout, we can center content horizontally as well.</p>
<p>To center both vertically and horizontally, we use <kbd>FlexibleSpace()</kbd> before and after the horizontal layout, and also before and after the content inside the horizontal layout. For example:</p>
<pre>private void OnGUI() {<br/>     GUILayout.Label("Hello editor world");<br/>     GUILayout.FlexibleSpace();<br/> <br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/> <br/>         GUILayout.Label("I am in the center !!!");<br/> <br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     GUILayout.FlexibleSpace();<br/> } </pre>
<p>This use of flexible spacing is illustrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9a5319f2-cdbc-45f0-b8dd-af703305c03f.png" style="width:30.25em;height:13.58em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An interactive panel with persistent storage</h1>
                
            
            
                
<p>With Immediate Mode, we have to store the values of interactive controls like buttons and text inputs at the time we display them. Also, we need to decide if, and when, to persistently store values to be remembered when the panel is out of focus or closed.</p>
<p>In this recipe, we display a text label saying hello to the player and using their name if it has been found in the EditorPrefs storage. We also offer a text input and a button and, when the button is clicked, we update the name being greeted:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/510a539f-d625-4cec-a4f9-c8aa242d7a97.png" style="width:22.25em;height:9.08em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To offer an interactive panel with persistent storage, follow these steps:</p>
<ol>
<li>In the Project panel, create a new Editor folder.</li>
<li>In your new Editor folder, create a new C# script-class named <kbd>Welcome.cs</kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class Welcome : EditorWindow<br/> {<br/>     private string playerName = "";<br/>     private string tempName = "";<br/> <br/>     [MenuItem("Welcome/Hello Player")]<br/>     public static void ShowWindow()<br/>     {<br/>         GetWindow&lt;Welcome&gt;("Welcome", true);<br/>     }<br/> <br/>     private void OnGUI()<br/>     {<br/>         // hello<br/>         string helloMessage = "Hello (no name)";<br/>         if (playerName.Length &gt; 0){<br/>             helloMessage = "Hello " + playerName;<br/>         }<br/> <br/>         GUILayout.Label(helloMessage);<br/>         GUILayout.FlexibleSpace();<br/> <br/>         // text input<br/>         tempName = EditorGUILayout.TextField("Player name:", tempName);<br/> <br/>         // button<br/>         if (GUILayout.Button("Update")){<br/>             playerName = tempName;<br/>         }<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you should now see a menu named Welcome appear with menu item Hello Player.</li>
<li>Select the menu item Hello Player. You should now see a new panel appear, entitled Welcome, displaying a hello message, a text input box, and a button labeled Update.</li>
<li>Enter your name in the text box and, when you press the button, you should see a message greeting you by name.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You preceded the <kbd>ShowWindow()</kbd>  method with an attribute to add a menu item, Hello Player, to a menu named Welcome. The <kbd>GetWindow()</kbd> statement gets a reference to an <kbd>EditorWindow</kbd> object of type (that is, for this script-class), creating a new one if no existing window-panel of this type can be found.</p>
<p>The <kbd>OnGUI()</kbd> method, which executes every frame, uses GUILayout to display the following:</p>
<ul>
<li>A text label in the form Hello</li>
<li>A text input with the prompt Player name</li>
<li>An Update button</li>
</ul>
<p class="mce-root"/>
<p>There is some <kbd>FlexibleSpace()</kbd> between the first item (greeting label) and the input box and button, so the input box and button appear at the bottom of the panel.</p>
<p>There are two private string variables:</p>
<ul>
<li><kbd>playerName</kbd></li>
<li><kbd>tempName</kbd></li>
</ul>
<p>The <kbd>playerName</kbd> variable is used to decide what greeting to display. If the length of this string is greater than zero (in essence, it's not an empty string), then the hello message will be Hello. If <kbd>playerName</kbd> was empty, then the message will be Hello (no name).</p>
<p>The second variable, <kbd>tempName</kbd>, is set to the value in the text box. This has to be re-assigned every frame (in <kbd>OnGUI()</kbd>), since the text box is redisplayed every frame. Each time the user types different text in the text box, the new text is immediately stored in the <kbd>tempName</kbd> variable.</p>
<p>Finally, there is an <kbd>if</kbd> statement that displays the Update button. If, during a frame, the button is clicked by the user, then the <kbd>if-</kbd>statement will be executed, which copies the <kbd>tempName</kbd> from the text box into the <kbd>playerName</kbd> variable. The very next frame, we'll see the greeting change to reflect the new value inside <kbd>playerName</kbd>.</p>
<p>We have used <kbd>EditorGUILayout.TextField(...)</kbd> for the text field entry, whereas the other methods are GUILayout methods. <kbd>The EditorGUILayout</kbd> methods make interactive controls easier, while the GUILayout methods make layout easier. For window-panels like this you can mix-and-match these GUI methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Persistent storage with EditorPrefs</h1>
                
            
            
                
<p>At present, if the panel is closed (for example, due to a new panel layout being invoked), then any name that was being shown will be lost. However, we can add some code that uses the EditorPrefs system to store the new name each time the Update button is clicked. Additional code can then check for an EditorPrefs value when the panel is newly displayed and initialize <kbd>playerName</kbd> to the stored value.</p>
<p>First, when the panel is created/gets the focus, let's attempt to read an EditorPrefs item with the key <kbd>"PlayerName"</kbd>. If found, we'll retrieve that string and assign the <kbd>playerName</kbd> variable to the stored value:</p>
<pre class="SourceCode">private void OnFocus() {<br/> if (EditorPrefs.HasKey("PlayerName"))<br/> playerName = EditorPrefs.GetString("PlayerName");<br/> }</pre>
<p>Now, let's create a method that will save the value in <kbd>playerName</kbd> into EditorPrefs, again using the key <kbd>"PlayerName"</kbd>:</p>
<pre>private void SavePrefs() {<br/>     EditorPrefs.SetString("PlayerName", playerName);<br/> } </pre>
<p>There are two times we may wish to ensure the value is saved, when the panel loses focus and when it is closed (destroyed). So, for both these events, we'll write methods that will invoke our <kbd>SavePrefs()</kbd> method:</p>
<pre>// automatic save when panel loses focus<br/> private void OnLostFocus() {<br/>     SavePrefs();<br/> }<br/> <br/> // automatic save when panel closed/destroyed<br/> private void OnDestroy() {<br/>     SavePrefs();<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">GUILayout versus EditorGUILayout</h1>
                
            
            
                
<p>You may have noticed there were two different <kbd>GUILayout</kbd> different method calls in this recipe:</p>
<pre>GUILayout.Label(helloMessage);<br/> GUILayout.FlexibleSpace();<br/> tempName = EditorGUILayout.TextField("Player name:", tempName);</pre>
<p><kbd>GUILayout</kbd> and <kbd>EditorGUILayout</kbd> both perform very similar roles, in that they provide UI controls with some automated layout - that is, we don't have to specify exact (x,y) values or rectangles for the window-panel size and position of each item. <kbd>GUILayout</kbd> offers some of the more flexible layout options, like <kbd>FlexibleSpace</kbd> and horizontal and vertical groups, which with <kbd>FlexibleSpace</kbd> can vertically and horizontally align items. However, <kbd>EditorGUILayout</kbd> offers easier and more powerful numeric and text input fields, as well as color selection widgets, foldout groups, and so on.</p>
<p>DM Gregory, in a StackExchange post in 2017, lists many of the extra methods available when using <kbd>EditorGUILayout</kbd>: <a href="https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout">https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating GameObjects, parenting, and registering Undo actions</h1>
                
            
            
                
<p>Whether from a menu item, or an Inspector view, there are times when we want to create a new GameObject in the scene from an Editor Extension. In this recipe, we'll create a new GameObject and set its position and color randomly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8c5ba467-2b3e-4745-bb68-6d273af200dd.png" style="width:31.50em;height:16.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create an object and change its value follow these steps:</p>
<ol>
<li>In the Project panel, create a new folder, Editor.</li>
<li>In your new Editor folder create a new C# script-class named <kbd>ObjectManager.cs</kbd>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class ObjectManager : EditorWindow<br/> {<br/>     [MenuItem("GameObject/MyObjectManager/Create New Empty Game Object")]<br/>     static void CreateCustomEmptyGameObject(MenuCommand menuCommand)<br/>     {<br/>         GameObject go = new GameObject("GameObject - custom - Empty");<br/>         go.transform.position = RandomPosition(5);<br/> <br/>         // Ensure it gets reparented if this was a context click (otherwise does nothing)<br/>         GameObjectUtility.SetParentAndAlign(go, menuCommand.context as GameObject);<br/> <br/>         // Register the creation in the undo system<br/>         Undo.RegisterCreatedObjectUndo(go, "Create " + go.name);<br/>         Selection.activeObject = go;<br/>     }<br/> <br/>     private static Vector3 RandomPosition(float limit)<br/>     {<br/>         float x = Random.Range(-limit, limit);<br/>         float y = Random.Range(-limit, limit);<br/>         float z = Random.Range(-limit, limit);<br/>         return new Vector3(x,y,z);<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you'll see added to the GameObject menu a new sub-menu named MyObjectManager appear, with menu item Create New Empty Game Object.</li>
</ol>
<ol start="4">
<li>Choose menu: GameObject | MyObjectManager | Create New Empty Game Object.</li>
<li>You should now see a new GameObject named GameObject - custom - Empty created in the Hierarchy panel. If you select this object, it's position (x,y,z) values should be random, in the range -0.5 ... 0.5.</li>
<li>You can Undo this create GameObject from the Edit menu (or <em>CTRL/CMD-Z</em>).</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/eb80dd6d-d551-41d9-ad44-547ba7ba622e.png" style="width:34.33em;height:3.17em;"/></p>
<ol start="7">
<li>With the new empty GameObject selected in the Hierarchy, right-mouse click to get the context menu for this object. Now, choose menu: Create | MyObjectManager | Create New Empty Game Object.</li>
<li>You should now see a second empty GameObject created as a child of the first one;</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/db175896-d0cd-4921-9cc7-11ad781235e8.png" style="width:18.67em;height:9.58em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You preceded the <kbd>CreateCustomEmptyGameObject(...)</kbd> method with an attribute to add to existing menu GameObject a sub-menu MyObjectManager with menu item Create New Empty Game Object.</p>
<p>The <kbd>CreateCustomEmptyGameObject(...)</kbd> method creates a new, empty GameObject with the name GameObject - custom - Empty. It then sets the position property to a Vector3 random location, returned from method <kbd>RandomPosition(...)</kbd>.</p>
<p>The <kbd>CreateCustomEmptyGameObject(...)</kbd> method then uses the <kbd>GameObjectUtility.SetParentAndAlign(...)</kbd> method to parent the new GameObject to the object selected in the Hierarchy, if the menu was invoked in the contents of a selected GameObject. Otherwise, the new GameObject will have no parent in the Hierarchy.</p>
<p>The <kbd>RandomPosition(...)</kbd> method takes as input a float parameter &lt;limit&gt;, and generates three values (x,y,z) in the random range from negative to positive &lt;limit&gt;. It then creates and returns a new Vector3 object with these three values.</p>
<p>Because we chose to add our action to the special GameObject menu, our sub-menu item appears in the Hierarchy panel's content Create menu as: Create | MyObjectManager | Create New Empty Game Object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering object changes to allow Undo'ing of actions</h1>
                
            
            
                
<p>When we performance an object creation/deletion/change action in the Unity Editor, we should offer the user the change to Undo the action. Unity makes it very easy for us to facilitate this, through registration of the changed object by providing an Undo class.</p>
<p>We can add to <kbd>CreateCustomEmptyGameObject(...)</kbd> a call to the <kbd>Undo.RegisterCreatedObjectUndo(...)</kbd> method. This registers the GameObject creation in the Unity system Undo register so that the action can be undone if the uses wishes to do so:</p>
<pre>[MenuItem("GameObject/MyObjectManager/Create New Empty Game Object")]<br/> static void CreateCustomEmptyGameObject(MenuCommand menuCommand)<br/> {<br/>     GameObject go = new GameObject("GameObject - custom - Empty");<br/>     go.transform.position = RandomPosition(5);<br/> <br/>     // Ensure it gets reparented if this was a context click (otherwise does nothing)<br/>     GameObjectUtility.SetParentAndAlign(go, menuCommand.context as GameObject);<br/> <br/>     // Register the creation in the undo system<br/>     Undo.RegisterCreatedObjectUndo(go, "Create " + go.name);<br/>     Selection.activeObject = go;<br/> } </pre>
<p>Learn more about the Undo features in the Unity documentation pages: <a href="https://docs.unity3d.com/ScriptReference/Undo.html" target="_blank">https://docs.unity3d.com/ScriptReference/Undo.html</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating primitive 3D GameObjects with random colors</h1>
                
            
            
                
<p>Rather than creating empty GameObjects, we can create new GameObjects that are 3D primitives like cubes and spheres etc. We can do this using the <kbd>GameObject.CreatePrimitive(...)</kbd> method. By adding the following three methods, we'll be able to create randomly positioned, randomly colored, random 3D GameObjects from a second menu item in our MyObjectManager sub-menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/23903447-0d03-4556-a156-be5484f6ee2e.png" style="width:30.83em;height:12.67em;"/></p>
<p>Let's write a method to add a second menu item, which offers to create random GameObjects with 3D primitives:</p>
<pre>[MenuItem("GameObject/MyObjectManager/Create New RandomShape GameObject")]<br/> static void CreateCustomPrimitiveGameObject(MenuCommand menuCommand){<br/>     // Create a custom game object<br/>     GameObject go = BuildGameObjectRandomPrimitive();<br/>     go.transform.position = RandomPosition(5);<br/>     go.GetComponent&lt;Renderer&gt;().sharedMaterial = RandomMaterialColor();<br/> } </pre>
<p>We can choose a random integer from 0..3 to choose between Cube/Sphere/Capsule/Cylinder 3D primitives for our new GameObject:</p>
<pre>private static GameObject BuildGameObjectRandomPrimitive() {<br/>     GameObject go;<br/>     PrimitiveType primitiveType = PrimitiveType.Cube;<br/>     int type = Random.Range(0, 4);<br/> <br/>     switch (type) {<br/>         case 0:<br/>             primitiveType = PrimitiveType.Sphere;<br/>             break;<br/> <br/>         case 1:<br/>             primitiveType = PrimitiveType.Capsule;<br/>             break;<br/> <br/>         case 2:<br/>             primitiveType = PrimitiveType.Cylinder;<br/>             break;<br/>     }<br/> <br/>     go = GameObject.CreatePrimitive(primitiveType);<br/>     go.name = "GameObject - custom - " + primitiveType.ToString();<br/>     return go;<br/> } </pre>
<p>Here is the final method we need to create a new Material with a random color, that can be assigned to the new primitives sharedMaterial property:</p>
<pre>private static Material RandomMaterialColor() {<br/>     Shader shaderSpecular = Shader.Find("Specular");<br/>     Material material = new Material(shaderSpecular);<br/>     material.color = Random.ColorHSV();<br/> <br/>     return material;<br/> } </pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with selected objects and deactivating menu items</h1>
                
            
            
                
<p>Sometimes, we only want to execute some statements if an object is currently selected, related to those actions. In this recipe, we learn how to disable a menu item if nothing is selected. If a GameObject is selected, we'll get a reference to that object and move it back to the origin (0,0,0):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2d2fce19-bada-4533-9dac-a2384ef117f4.png" style="width:35.92em;height:3.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To work with selected objects and deactivate menu items follow these steps:</p>
<ol start="1">
<li>In the Project panel, create a new folder, Editor.</li>
<li>In your new Editor folder create a new C# script-class named <kbd>SelectedObjectManager.cs</kbd>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class SelectedObjectManager : EditorWindow<br/> {<br/>     [MenuItem("MyMenu/Move To Origin")]<br/>     static void ZeroPosition()<br/>     {<br/>         GameObject selectedGameObject = Selection.activeTransform.gameObject;<br/> <br/>         Undo.RecordObject (selectedGameObject.transform, "Zero Transform Position");<br/>         selectedGameObject.transform.position = Vector3.zero;<br/>     }<br/> <br/>     [MenuItem("MyMenu/Move To Origin", true)]<br/>     static bool ValidateZeroPosition()<br/>     {<br/>         // Return false if no transform is selected.<br/>         return Selection.activeTransform != null;<br/>     }<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>After a few seconds, you'll see a new menu MyMenu created, with menu item Move To Origin.</li>
<li>If no GameObject is selected in the Hierarchy, then the Move To Origin menu item should be greyed out (inactive).</li>
<li>Create a new, empty GameObject and set its transform position to (5,6,7).</li>
<li>With this new GameObject selected in the Hierarchy, choose menu: MyMenu | Move To Origin. The menu item should be active, and once chosen the position of the GameObject should be zeroed to (0,0,0).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You preceded the <kbd>ZeroPosition()</kbd> method with a MenuItem attribute to create a new menu MyMenu with menu item Move To Origin. This method gets a reference to the currently selected GameObject using the <kbd>Selection.activeTransform.gameObject</kbd> property. The object is registered to the Undo systems property change record, and then its transform position is set to (0,0,0).</p>
<p>There is a second method, <kbd>ValidateZeroPosition()</kbd>. This method is preceded by a MenuItem attribute with the same <strong>menu path</strong> as method <kbd>ZeroPosition()</kbd>. The MenuItem attribute is passed true to indicate this is a validation method:</p>
<pre>[MenuItem("MyMenu/MoveToOrigin", true)] </pre>
<p>Validation methods must be static methods, marked with the same MenuItem attribute as the item they are validating, and pass true to the validation argument. The method must return a bool true/false, to indicate whether the condition has been met for the menu item to be active.</p>
<p><kbd>ValidateZeroPosition()</kbd> returns the bool true/false value of the expression <kbd>Selection.activeTransform != null</kbd>. In other words, it returns true if there is a selected GameObject, and false if there is not.</p>
<p>Learn more about Editor Extension menu items in the Unity tutorial: <a href="https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items">https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Menu item to create 100 randomly positioned prefab clones</h1>
                
            
            
                
<p>Sometimes we want to create <em>lots</em> of pickups, randomly in our scene. Rather than doing this by hand, it is possible to add a custom menu and item to the Unity editor, which, when selected, will execute a script. In this recipe, we create a menu item that calls a script to create 100 randomly positioned star pickup prefabs in the Scene:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/799bffad-3fcb-4213-acdf-c4c0e3ff159d.png" style="width:27.25em;height:15.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you are starting with the project <kbd>Simple2Dgame_SpaceGirl</kbd> setup from the first recipe in <a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml">Chapter 3</a><em>, Inventory UI</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create an editor extension to add 100 randomly located copies of a prefab with one menu click, follow these steps:</p>
<ol start="1">
<li>Start with a new copy of mini-game <kbd>Simple2Dgame_SpaceGirl</kbd>.</li>
<li>In the Project panel, create a new folder named Prefabs. Inside this new folder, create a new empty prefab named <kbd>prefab_star</kbd>. Populate this prefab by dragging GameObject star from the Hierarchy panel over <kbd>prefab_star</kbd> in the Project panel. The prefab should now turn blue and have a copy of all of GameObject star's properties and components.</li>
</ol>
<ol start="3">
<li>Delete GameObject star from the Hierarchy.</li>
<li>In the Project panel, create a new folder named Editor. Inside this new folder, create a new C# script class named <kbd>MyGreatGameEditor</kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEditor;<br/> <br/> public class MyGreatGameEditor : MonoBehaviour {<br/>     const float X_MAX = 10f;<br/>     const float Y_MAX = 10f;<br/> <br/>     static GameObject starPrefab;<br/> <br/>     [MenuItem("My-Great-Game/Make 100 stars")]<br/>     static void PlacePrefabs() {<br/>         string assetPath = "Assets/Prefabs/prefab_star.prefab";<br/>         starPrefab = (GameObject)AssetDatabase.LoadMainAssetAtPath(assetPath);<br/> <br/>         int total = 100;<br/>         for(int i = 0; i &lt; total; i++){<br/>             CreateRandomInstance();<br/>         }<br/>     }<br/> <br/>     static void CreateRandomInstance() {<br/>         Vector3 randomPosition = RandomPosition();<br/>         Instantiate(starPrefab, randomPosition, Quaternion.identity);<br/>     }<br/> <br/>     private static Vector3 RandomPosition() {<br/>         float x = Random.Range(-X_MAX, X_MAX);<br/>         float y = Random.Range(-Y_MAX, Y_MAX);<br/>         float z = 0;<br/>         return new Vector3(x,y,z);<br/>     }<br/> }</pre>
<ol start="5">
<li>After a few seconds, depending on the speed of your computer, you should see a new menu appear, My Great Game, with a single menu item, Make 100 stars.</li>
<li>Choose this menu item and, as if by magic, you should now see 100 new <kbd>prefab_star(Clone)</kbd> GameObjects appear in the scene!</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The core aim of this recipe is to add a new menu, containing a single menu item that will execute the action we desire. <kbd>C# attribute [MenuItem("&lt;menuName&gt;/&lt;menuItemName&gt;")]</kbd> declares the menu name and the menu item name, and Unity will execute the static method that follows in the code listing, each time the menu item is selected by the user.</p>
<p>In this recipe, the <kbd>[MenuItem("My-Great-Game/Make 100 stars")]</kbd> statement declares the menu name as My-Great-Game and the menu item as Make 100 stars. The method immediately following this attribute is the <kbd>PlacePrefabs()</kbd> method. When this method is executed, it makes the <kbd>starPrefab</kbd> variable become a reference to the prefab found via the <kbd>Assets/Prefabs/prefab_star.prefab</kbd> path. Then, a For-loop is executed 100 times, each time calling the <kbd>CreateRandomInstance()</kbd> method.</p>
<p>The <kbd>RandomPosition()</kbd> method returns a Vector3 variable that is a random position, making use of <kbd>X_MAX</kbd> and <kbd>Y_MAX</kbd> constants (z is always zero).</p>
<p>The <kbd>CreateRandomInstance()</kbd> method get a Vector3 randomPosition by calling the <kbd>RandomPosition()</kbd> method. The <kbd>Instantiate(...</kbd>) built-in method is then used to create a new GameObject in the scene, making a clone of the prefab and locating it at the position defined by randomPosition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Some details you don't want to miss:</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Childing each new GameObject to a single parent, to avoid filling up the Hierarchy with 100s of new objects</h1>
                
            
            
                
<p>Rather than having hundreds of new object clones fill up our Hierarchy panel, a good way to keep things tidy is to have an empty "parent" GameObject and child a collection of related GameObjects to it. Let's have a GameObject in the Hierarchy named Star-container and child all the new stars to this object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/85e72b55-0d08-4081-be7e-4035aa2043e7.png" style="width:17.08em;height:13.58em;"/></p>
<p>We need a variable that will be a reference to our container object, starContainerGO. We also need a new method, <kbd>CreateStarContainerGO()</kbd>, which will find a reference to GameObject star-container, if such an object already exists it is deleted, and then the method will create a new empty GameObject and give it this name. Add the following variable and method to our script class:</p>
<pre>static GameObject starContainerGo;<br/> <br/> static void CreateStarContainerGo() {<br/>     string containerName = "Star-container";<br/>     starContainerGo = GameObject.Find(containerName);<br/>     if (null != starContainerGO)<br/>         DestroyImmediate(starContainerGO);<br/> <br/>     starContainerGo = new GameObject(containerName);<br/> } </pre>
<p>Before we create the prefab clones, we need to first ensure we have created our star container GameObject. So, we need to call our new method as the first thing we do when the <kbd>PlacePrefabs()</kbd> method is executed, so add a statement to call this method at the beginning of the <kbd>PlacePrefabs()</kbd> method:</p>
<pre>static void PlacePrefabs(){<br/>     CreateStarContainerGo();<br/> <br/>     // rest of method as before ...<br/> } </pre>
<p>Now, we need to modify the <kbd>CreateRandomInstance()</kbd> method so that it gets a reference to the new GameObject it has just created and can then child this new object to our star-container GameObject variable starContainerGO. Modify the <kbd>CreateRandomInstance()</kbd> method so that it looks as follows:</p>
<pre>static void CreateRandomInstance() {<br/>     float x = UnityEngine.Random.Range(-X_MAX, X_MAX);<br/>     float y = UnityEngine.Random.Range(-Y_MAX, Y_MAX);<br/>     float z = 0;<br/>     Vector3 randomPosition = new Vector3(x,y,z);<br/> <br/>     GameObject newStarGo = (GameObject)Instantiate(starPrefab,  randomPosition, Quaternion.identity);<br/>     newStarGo.transform.parent = starContainerGO.transform;<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">A progress bar to display proportion completed of Editor extension processing</h1>
                
            
            
                
<p>If an <strong>Editor</strong> task is going to take more than half a second or so, then we should indicate progress complete/remaining to the user via a progress bar so that they understand that something is actually happening and the application has not crashed and frozen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0ca27244-3283-4684-a2bd-5b611289e806.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To add a progress bar during the loop (and then remove it after the loop is complete), replace the <kbd>PlacePrefabs()</kbd> method with the following code:</p>
<pre>static void PlacePrefabs(){ 

   string assetPath = "Assets/Prefabs/prefab_star.prefab"; 

   starPrefab = (GameObject)AssetDatabase.LoadMainAssetAtPath(assetPath); 

   int total = 100; 

      for(int i = 0; i &lt; total; i++){ 

         CreateRandomInstance(); 

         EditorUtility.DisplayProgressBar("Creating your starfield",  i + "%", i/100f); 

      } 

      EditorUtility.ClearProgressBar(); 

   } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As can be seen, inside the for loop, we call the <kbd>EditorUtility.DisplayProgressBar(...)</kbd> method, passing three parameters. The first is a string title for the progress bar dialog window, the second is a string to show below the bar itself (usually a percentage is sufficient), and the final parameter is a value between 0.0 and 1.0, indicating the percentage complete to be displayed.</p>
<p>Since we have loop variable i that is a number from 1 to 100, we can display this integer followed by a percentage sign for our second parameter and just divide this number by 100 to get the decimal value needed to specify how much of the progress bar should be shown as completed. If the loop were running for some other number, we'd just divide the loop counter by the loop total to get our decimal progress value.</p>
<p>Finally, after the loop has finished, we remove the progress bar with the <kbd>EditorUtility.ClearProgressBar()</kbd> statement. If we don't have this step, the progress bar window-panel will be left floating around - annoying the user!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An editor extension to allow pickup type (and parameters) to be changed at design time via a custom Inspector UI</h1>
                
            
            
                
<p>The use of <strong>enums</strong> and corresponding drop-down menus in the Inspector panel to restrict changes to one of a limited set often works fine (for example, pickup types for a pickup object). However, the trouble with this approach is, when two or more properties are related and need to be changed together, there is a danger of changing one property, for example, pickup type from Heart to Key, but forgetting to change corresponding properties; for example, leaving the Sprite Renderer component still showing a Heart sprite. Such mismatches cause problems both in terms of messing up intended level design and, of course, the frustration for the player when they collide with something showing one pickup image, but a different kind of pickup type is added to the inventory!</p>
<p>If a class of GameObject has several related properties or components, which all need to be changed together, then a good strategy is to use Unity Editor extensions to do all the associated changes each time a different choice is made from a drop-down menu showing the defined set of enumerated choices.</p>
<p>In this recipe, we introduce an Editor extension for <kbd>PickUp</kbd> components of GameObjects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f0b3f7fc-bd92-4c7b-b8c9-a2135307ecc1.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you are starting with the <kbd>Simple2Dgame_SpaceGirl</kbd> project setup from the first recipe in <em>Chapter 3, Inventory UI</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create an editor extension to allow pickup type (and parameters) to be changed at Design Time via a custom Inspector UI, follow these steps:</p>
<ol>
<li>Start with a new copy of mini-game <kbd>Simple2Dgame_SpaceGirl</kbd>.</li>
<li>In the Project panel, create a new folder named EditorSprites. Move the following images from folder Sprites into this new folder: star, healthheart, icon_key_green_100, icon_key_green_32, icon_star_32, and icon_heart_32:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b24734bd-643b-42d2-ba7e-8a8b6a53e77c.png"/></p>
<ol start="3">
<li>In the Hierarchy panel, rename GameObject star to be named pickup.</li>
<li>Edit the tags, changing tag Star to Pickup. Ensure the pickup GameObject now has the tag Pickup.</li>
<li>Create C# script-class <kbd>PickUp</kbd> and add an instance-object as a component to GameObject pickup in the Hierarchy:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System;<br/> using System.Collections;<br/> <br/> public class PickUp : MonoBehaviour {<br/>   public enum PickUpType {<br/>     Star, Health, Key<br/>   }<br/> <br/>   [SerializeField]<br/>   public PickUpType type;<br/> <br/>   public void SetSprite(Sprite newSprite){<br/>     SpriteRenderer spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();<br/>     spriteRenderer.sprite = newSprite;<br/>   }<br/> } </pre>
<ol start="6">
<li>In the Project panel, create a new folder named Editor.</li>
<li>Inside this new Editor folder, create a new C# script class named <kbd>PickUpEditor</kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System.Collections;<br/> using System;<br/> using UnityEditor;<br/> using System.Collections.Generic;<br/> <br/> [CanEditMultipleObjects]<br/> [CustomEditor(typeof(PickUp))]<br/> public class PickUpEditor : Editor<br/> {<br/>   public Texture iconHealth;<br/>   public Texture iconKey;<br/>   public Texture iconStar;<br/> <br/>   public Sprite spriteHealth100;<br/>   public Sprite spriteKey100;<br/>   public Sprite spriteStar100;<br/> <br/>   UnityEditor.SerializedProperty pickUpType;<br/> <br/>   private Sprite sprite;<br/>   private PickUp pickupObject;<br/> <br/>   void OnEnable () {<br/>     iconHealth = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_heart_32.png", typeof(Texture)) as Texture;<br/>     iconKey = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_key_32.png", typeof(Texture)) as Texture;<br/>     iconStar =  AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/ icon_star_32.png", typeof(Texture)) as Texture;<br/> <br/>     spriteHealth100 =  AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/ healthheart.png", typeof(Sprite)) as Sprite;<br/>     spriteKey100 =  AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/ icon_key_100.png", typeof(Sprite)) as Sprite;<br/>     spriteStar100 =  AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/ star.png", typeof(Sprite)) as Sprite;<br/> <br/>     pickupObject = (PickUp)target;<br/>     pickUpType = serializedObject.FindProperty ("type");<br/>   }<br/> <br/> <br/>   public override void OnInspectorGUI()<br/>   {<br/>     serializedObject.Update ();<br/> <br/>     string[] pickUpCategories = TypesToStringArray();<br/>     pickUpType.enumValueIndex =  EditorGUILayout.Popup("PickUp TYPE: ",  pickUpType.enumValueIndex, pickUpCategories);<br/> <br/>     PickUp.PickUpType type =  (PickUp.PickUpType)pickUpType.enumValueIndex;<br/>     switch(type)<br/>     {<br/>     case PickUp.PickUpType.Health:<br/>       InspectorGUI_HEALTH();<br/>       break;<br/> <br/>     case PickUp.PickUpType.Key:<br/>       InspectorGUI_KEY();<br/>       break;<br/> <br/>     case PickUp.PickUpType.Star:<br/>     default:<br/>       InspectorGUI_STAR();<br/>       break;<br/>     }<br/> <br/>     serializedObject.ApplyModifiedProperties ();<br/>   }<br/> <br/>   private void InspectorGUI_HEALTH()<br/>   {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconHealth);<br/>     GUILayout.Label("HEALTH");<br/>     GUILayout.Label(iconHealth);<br/>     GUILayout.Label("HEALTH");<br/>     GUILayout.Label(iconHealth);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteHealth100);<br/>   }<br/> <br/>   private void InspectorGUI_KEY()<br/>   {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteKey100);<br/>   }<br/> <br/>   private void InspectorGUI_STAR()<br/>   {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconStar);<br/>     GUILayout.Label("STAR");<br/>     GUILayout.Label(iconStar);<br/>     GUILayout.Label("STAR");<br/>     GUILayout.Label(iconStar);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteStar100);<br/>   }<br/>   private string[] TypesToStringArray(){<br/>     var pickupValues =  (PickUp.PickUpType[])Enum.GetValues(typeof (PickUp.PickUpType));<br/> <br/>     List&lt;string&gt; stringList = new List&lt;string&gt;();<br/> <br/>     foreach(PickUp.PickUpType pickupValue in pickupValues){<br/>       string stringName = pickupValue.ToString();<br/>       stringList.Add(stringName);<br/>     }<br/> <br/>     return stringList.ToArray();<br/>   }<br/> } </pre>
<ol start="8">
<li>In the Inspector panel, select GameObject pickup and choose different values of the drop-down menu PickUp Type. You should see corresponding changes in the image and icons in the Inspector for the Pick Up (Script) component (three icons with the name of the type in between). The Sprite property of the Sprite Renderer component for this GameObject should change. Also, in the Scene panel, you'll see the image in the scene change to the appropriate image for the pickup type you have chosen.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/22162569-212f-431a-9c3c-2979c10784a9.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Our script class <kbd>PickUp</kbd> has the enum <kbd>PickUpType</kbd> with the three values: <kbd>Star</kbd>, <kbd>Health</kbd>, and <kbd>Key</kbd>. Also, there is the variable type, storing the type of the parent GameObject. Finally, there is a <kbd>SetSprite(...)</kbd> method that sets the Sprite Renderer component of the parent GameObject to be set to the provided Sprite parameter. It is this method that is called from the editor script each time the pickup type is changed from the drop-down menu (with the corresponding sprite for the new type being passed).</p>
<p>The vast majority of the work for this recipe is the responsibility of the script class <kbd>PickUpEditor</kbd>. While there is a lot in this script, its work is relatively straightforward: for each frame, via method <kbd>OnInspectorGUI()</kbd>, a dropdown list of PickUpType values is presented to the user. Based on the value selected from this drop-down list, one of three methods is executed: <kbd>InspectorGUI_HEALTH()</kbd>, <kbd>InspectorGUI_KEY()</kbd>, or <kbd>InspectorGUI_STAR()</kbd>. Each of these methods displays three icons and the name of the type in the Inspector beneath the drop-down menu and ends by calling the <kbd>SetSprite(...)</kbd> method of the GameObject being edited in the Inspector to update the Sprite Renderer component of the parent GameObject with the appropriate sprite.</p>
<p>The C# attribute <kbd>[CustomEditor(typeof(PickUp))]</kbd> appearing before our class is declared, tells Unity to use this special editor script to display component properties in the Inspector panel for Pick Up (Script) components of GameObjects, rather than Unity's default Inspector which displays public variables of such scripted components.</p>
<p>Before and after its main work, the <kbd>OnInspectorGUI()</kbd> method first ensures that any variables relating to the object being edited in the Inspector have been updated - <kbd>serializedObject.Update()</kbd>. The last statement of this method correspondingly ensures that any changes to variables in the editor script have been copied back to the GameObject being edited - <kbd>serializedObject.ApplyModifiedProperties()</kbd>.</p>
<p>The <kbd>OnEnable()</kbd> method of script class PickUpEditor loads the three small icons (for display in the Inspector) and the three larger sprite images (to update the Sprite Renderer for display in the Scene/Game panels). The <kbd>pickupObject</kbd>variable is set to be a reference to the PickUp scripted component, allowing us to call the <kbd>SetSprite(...)</kbd> method. The <kbd>pickUpType</kbd> variable is set to be linked to the type variable of the PickUp scripted component whose special Inspector editor view makes this script possible - <kbd>serializedObject.FindProperty ("type")</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some details you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Offer the custom editing of pickup parameters via Inspector</h1>
                
            
            
                
<p>Many pickups have additional properties, rather than simply being an item being carried.  For example, a health pickup may add health points to the player's character, a coin pickup may add money points to the character's bank balance, and so on. So, let's add an integer points variable to our PickUp class and offer the user the ability to easily edit this points value via a GUI slider in our customer Inspector editor:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/06fa225e-b993-4694-8e80-de8e7188c895.png"/></p>
<p>To add an editable points property to our <kbd>PickUp</kbd> objects, follow these steps:</p>
<ol>
<li>Add the following extra line into C# script <kbd>PickUp</kbd> to create our new integer points variable:</li>
</ol>
<pre style="padding-left: 60px">public int points; </pre>
<ol start="2">
<li>Add the following extra line into C# script <kbd>PickUpEditor</kbd> to work with our new integer points variable:</li>
</ol>
<pre style="padding-left: 60px">UnityEditor.SerializedProperty points; </pre>
<ol start="3">
<li>Add the following extra line into the <kbd>OnEnable()</kbd> method in C# script <kbd>PickUpEditor</kbd> to associate our new points variable with its corresponding value in the <kbd>PickUp</kbd> scripted component of the GameObject being edited:</li>
</ol>
<pre style="padding-left: 60px">csharp void OnEnable () {    

points = serializedObject.FindProperty ("points");    

pickUpType = serializedObject.FindProperty ("type");    

// rest of method as before...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Now, we can add an extra line into each GUI method for the different <kbd>PickUp</kbd> types. For example, we can add a statement to display an <kbd>IntSlider</kbd> to the user to be able to see and modify the points value for a Health PickUp object. We add a new statement at the end of the <kbd>InspectorGUI_HEALTH()</kbd> method in C# script <kbd>PickUpEditor</kbd> to display a modifiable <kbd>IntSlider</kbd> representing our new points variable as follows:</li>
</ol>
<pre style="padding-left: 60px">private void InspectorGUI_HEALTH(){<br/>   // beginning of method just as before...<br/> <br/>   pickupObject.SetSprite(spriteHealth100);<br/> <br/> // now display Int Slider for points<br/>   points.intValue = EditorGUILayout.IntSlider  ("Health points", points.intValue, 0, 100);<br/> } </pre>
<p>We provide four parameters to the <kbd>IntSlider(...)</kbd> method. The first is the text label the user will see next to the slider. The second is the initial value the slider displays. The last two are the maximum and minimum values. In our example, we are permitting values from 0 to 100, but if health pickups only offer one, two, or three health points, then we'd just call with <kbd>EditorGUILayout.IntSlider</kbd> <kbd>("Health points, points.intValue, 1, 5")</kbd>. This method returns a new integer value based on where the slider has been positioned, and this new value is stored back into the integer value part of our <kbd>SerializedProperty</kbd> variable points.</p>
<p>Note that the loading and saving of values from the scripted component in the GameObject and our editor script is all part of the work undertaken by our calls to the <kbd>Update()</kbd> method and the <kbd>ApplyModifiedProperties()</kbd> method on the serialized object in the <kbd>OnInspectorGUI()</kbd> method.</p>
<p>Note that, since points may not have any meaning for some pickups, for example, keys, then we simply would not display any slider for the GUI Inspector editor when the user is editing <kbd>PickUp</kbd> objects of that type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Offer a drop-down list of tags for key-pickup to fit via Inspector</h1>
                
            
            
                
<p>While the concept of points may have no meaning for a key pickup, the concept of the type of lock that a given key fits is certainly something we may wish to implement in a game. Since Unity offers us a defined (and editable) list of string tags for any GameObject, often it is sufficient, and straightforward, to represent the type of lock or door corresponding to a key via its tag. For example, a green key might fit all objects tagged LockGreen and so on:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/311aa5a6-740a-4547-9412-0b2a02812fce.png" style="width:27.92em;height:24.75em;"/></p>
<p>Therefore, it is very useful to be able to offer a custom Inspector editor for a string property of key pickups that stores the tag of the lock(s) the key can open. This task combines several actions, including using C# to retrieve an array of tags from the Unity editor, then the building and offering of a drop-down list of these tags to the user, with the current value already selected in this list.</p>
<p class="mce-root"/>
<p>To add a selectable list of strings for the tag for lock(s) that a key fits, follow these steps:</p>
<ol>
<li>Add the following extra line into C# Script <kbd>PickUp</kbd> to create our new integer <kbd>fitsLockTag</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">public string fitsLockTag; </pre>
<ol start="2">
<li>Add the following extra line into C# script <kbd>PickUpEditor</kbd> to work with our new integer <kbd>fitsLockTag</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">UnityEditor.SerializedProperty fitsLockTag; </pre>
<ol start="3">
<li>Add the following extra line into the <kbd>OnEnable()</kbd> method in C# script <kbd>PickUpEditor</kbd> to associate our new <kbd>fitsLockTag</kbd> variable with its corresponding value in the <kbd>PickUp</kbd> scripted component of the GameObject being edited:</li>
</ol>
<pre style="padding-left: 60px">csharp void OnEnable () {      

fitsLockTag =  serializedObject.FindProperty ("fitsLockTag");     points = serializedObject.FindProperty ("points");      

pickUpType = serializedObject.FindProperty ("type");      

// rest of method as before... </pre>
<ol start="4">
<li>Now, we need to add some extra lines of code into the GUI method for key PickUps. We need to add several statements to the end of method <kbd>InspectorGUI_KEY()</kbd> in C# script PickUpEditor to set up and display a selectable popup drop-down list representing our new <kbd>fitsLockTag</kbd> variable as follows. Replace the <kbd>InspectorGUI_KEY()</kbd> method with the following code:</li>
</ol>
<pre style="padding-left: 60px">private void InspectorGUI_KEY() {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteKey100);<br/> <br/>     string[] tags =  UnityEditorInternal.InternalEditorUtility.tags;<br/>     Array.Sort(tags);<br/>     int selectedTagIndex =  Array.BinarySearch(tags, fitsLockTag.stringValue);<br/>     if(selectedTagIndex &lt; 0)<br/>         selectedTagIndex = 0;<br/> <br/>     selectedTagIndex =  EditorGUILayout.Popup("Tag of door key fits: ",  selectedTagIndex, tags);<br/> <br/>     fitsLockTag.stringValue = tags[selectedTagIndex];<br/> } </pre>
<p>We've added several statements to the end of this method. First tags, an array of strings, is created (and sorted), containing the list of tags currently available in the Unity editor for the current game. We then attempt to find the location in this array of the current value of <kbd>fitsLockTag</kbd> - we can use the <kbd>BinarySearch(...)</kbd> method of built-in script class Array because we have alphabetically sorted our array (which also makes it easier for the user to navigate). If the string in <kbd>fitsLockTag</kbd> cannot be found in array tags, then the first item will be selected by default (index 0).</p>
<p>The user is then shown the drop-down list via the <kbd>GUILayout</kbd> method <kbd>EditorGUILayout.Popup(...)</kbd> and this method returns the index of whichever item is selected. The selected index is stored into <kbd>selectedTagIndex</kbd> and the last statement in the method extracts the corresponding string and stores that string into the <kbd>fitsLockTag</kbd> variable.</p>
<p>Note: Rather than displaying all possible tags, a further refinement might remove all items from array tags that do not have the prefix Lock. So the user is only presented with tags such as LockBlue and LockGreen, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Logic to open doors with keys based on fitsLockTag</h1>
                
            
            
                
<p>In our player collision logic, we can now search through our inventory to see if any key items fit the lock we have collided with. For example, if a green door was collided with, and the player was carrying a key that could open such doors, then that item should be removed from the inventory <kbd>List&lt;&gt;</kbd> and the door should be opened.</p>
<p>To implement this, you would need to add an if test inside the <kbd>OnTriggerEnter()</kbd> method to detected collision with the item tagged <kbd>Door</kbd>, and then logic to attempt to open the door, and, if unsuccessful, do the appropriate action (for example, play sound) to inform the player they cannot open the door yet (we'll assume we have written a door animation controller that plays the appropriate animation and sounds and when a door is to be opened):</p>
<pre>if("Door" == hitCollider.tag){<br/>     if(!OpenDoor(hitCollider.gameObject))<br/>         DoorNotOpenedAction();<br/> } </pre>
<p>The <kbd>OpenDoor()</kbd> method would need to identify which item (if any) in the inventory can open such a door, and, if found, then that item should be removed from the <kbd>List&lt;&gt;</kbd> and the door should be opened by the appropriate method:</p>
<pre>private bool OpenDoor(GameObject doorGO){<br/>     // search for key to open the tag of doorGO<br/>     int colorKeyIndex = FindItemIndex(doorGO.tag);<br/>     if( colorKeyIndex &gt; -1 ){<br/>         // remove key item from inventory List&lt;&gt;<br/>         inventory.RemoveAt( colorKeyIndex );<br/> <br/>         // now open the door...<br/>         DoorAnimationController doorAnimationController =  doorGO.GetComponent&lt;&gt;(DoorAnimationController);<br/>         doorAnimationController.OpenDoor();<br/> <br/>         return true;<br/>     }<br/> <br/>     return false;<br/> } </pre>
<p class="mce-root"/>
<p>The following is the code for a method to find the inventory list key item fitting a door tag:</p>
<pre>private int FindItemIndex(string doorTag){<br/>     for (int i = 0; i &lt; inventory.Count; i++){<br/>         PickUp item = inventory[i];<br/>         if( (PickUp.PickUpType.Key == item.type) &amp;&amp;   (item.fitsLockTag == doorTag))<br/>             return i;<br/>     }<br/> <br/>     // not found<br/>     return -1;<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The need to add [SerializeField] for private properties</h1>
                
            
            
                
<p>Note that, if we wished to create editor extensions to work with private variables, then we'd need to explicitly add <kbd>[SerializeField]</kbd> in the line immediately before the variable to be changed by the editor script. Public variables are serialized by default in Unity, so this was not required for our public type variable in script class PickUp, although it's good practice to flag ALL variables that are changeable via an Editor Extension in this way.</p>
<p>Learn more from the Unity editor scripts documentation pages: <a href="http://docs.unity3d.com/ScriptReference/Editor.html">http://docs.unity3d.com/ScriptReference/Editor.html</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An editor extension to have an object-creator GameObject, with buttons to instantiate different pickups at cross-hair object location in scene</h1>
                
            
            
                
<p>If a level designer wishes to place each pickup carefully "by hand", we can still make this easier than having to drag copies of prefabs manually from the Projects panel. In this recipe, we provide a "cross-hairs" GameObject, with buttons in the Inspector allowing the game designer to create instances of three different kinds of prefab at precise locations by clicking the appropriate button when the center of the cross-hairs is at the desired location.</p>
<p>A Unity Editor extension is at the heart of this recipe and illustrates how such extensions can allow less technical members of a game development team to take an active role in level creation within the Unity Editor.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/23016e79-f90b-4f6d-aea8-0b6a444af84c.png" style="width:30.75em;height:9.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you are starting with the <kbd>Simple2Dgame_SpaceGirl</kbd> project setup from the first recipe in <a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml"/><a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml">Chapter 3</a><em>, Inventory UI</em>.</p>
<p>For this recipe, we have prepared the cross-hairs image you need in a folder named Sprites in the <kbd>18_09</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create an object-creator GameObject, follow these steps:</p>
<ol>
<li>Start with a new copy of mini-game <kbd>Simple2Dgame_SpaceGirl</kbd>.</li>
<li>In the Project panel, rename GameObject star as pickup.</li>
<li>In the Project panel, create a new folder named Prefabs. Inside this new folder, create three new empty prefabs named star, heart, and key.</li>
<li>Populate the star prefab by dragging GameObject pickup from the Hierarchy panel over star in the Project panel. The prefab should now turn blue and have a copy of all of the star GameObject's properties and components.</li>
<li>Add a new tag Heart in the Inspector. Select GameObject pickup in the Hierarchy panel and assign it the tag Heart. Also, drag from the Project panel (folder Sprites) the healthheart image into the Sprite property of GameObject pickup so that the player sees the heart image on screen for this pickup item.</li>
</ol>
<ol>
<li>Populate the heart prefab by dragging GameObject pickup from the Hierarchy panel over heart in the Prefabs folder in the Project panel. The prefab should now turn blue and have a copy of all of the pickup GameObject's properties and components.</li>
<li>Add a new tag Key in the Inspector. Select GameObject's pickup in the Hierarchy panel and assign it this tag Key. Also, drag from the Project panel (folder Sprites) image icon_key_green_100 into the Sprite property of GameObject's pickup so that the player sees the key image on screen for this pickup item.</li>
<li>Populate the key prefab by dragging GameObject pickup from the Hierarchy panel over key in the Prefabs folder in the Project panel. The prefab should now turn blue and have a copy of all of the pickup GameObject's properties and components.</li>
<li>Delete GameObject pickup from the Hierarchy.</li>
<li>In the Project panel, create a new folder named Editor. Inside this new folder, create a new C# script class named <kbd>ObjectBuilderEditor</kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using UnityEditor;<br/><br/>[CustomEditor(typeof(ObjectBuilderScript))]<br/>public class ObjectBuilderEditor : Editor{<br/>   private Texture iconStar;<br/>   private Texture iconHeart;<br/>   private Texture iconKey;<br/>   <br/>   private GameObject prefabHeart;<br/>   private GameObject prefabStar;<br/>   private GameObject prefabKey;<br/>   <br/>   void OnEnable () {<br/>      iconStar = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_star_32.png", typeof(Texture)) as Texture;<br/>      iconHeart = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_heart_32.png", typeof(Texture)) as Texture;<br/>      iconKey = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_key_green_32.png", typeof(Texture)) as Texture;<br/>      <br/>      prefabStar = AssetDatabase.LoadAssetAtPath("Assets/Prefabs/star.prefab", typeof(GameObject)) as GameObject;<br/>      prefabHeart = AssetDatabase.LoadAssetAtPath("Assets/Prefabs/heart.prefab", typeof(GameObject)) as GameObject;<br/>      prefabKey = AssetDatabase.LoadAssetAtPath("Assets/Prefabs/key.prefab", typeof(GameObject)) as GameObject;<br/>   }<br/>   <br/>   public override void OnInspectorGUI() {<br/>      GUILayout.Label("");<br/>      GUILayout.BeginHorizontal();<br/>      GUILayout.FlexibleSpace();<br/>      GUILayout.Label("Click button to create instance of prefab");<br/>      GUILayout.FlexibleSpace();<br/>      GUILayout.EndHorizontal();<br/>      GUILayout.Label("");<br/>      <br/>      GUILayout.BeginHorizontal();<br/>      GUILayout.FlexibleSpace();<br/>      if(GUILayout.Button(iconStar)) AddObjectToScene(prefabStar);<br/>      GUILayout.FlexibleSpace();<br/>      if(GUILayout.Button(iconHeart)) AddObjectToScene(prefabHeart);<br/>      GUILayout.FlexibleSpace();<br/>      if(GUILayout.Button(iconKey)) AddObjectToScene(prefabKey);<br/>      GUILayout.FlexibleSpace();<br/>      GUILayout.EndHorizontal();<br/>   }<br/>   <br/>   private void AddObjectToScene(GameObject prefabToCreateInScene) {<br/>      ObjectBuilderScript myScript = (ObjectBuilderScript)target;<br/>      GameObject newGo = Instantiate(prefabToCreateInScene, myScript.gameObject.transform.position, Quaternion.identity);<br/>      newGo.name = prefabToCreateInScene.name;<br/>   }<br/>}</pre>
<ol start="11">
<li>Our Editor script is expecting to find the three icons in a folder named EditorSprites, so let's do this. First, create a new folder named EditorSprites. Next, drag the three 32 x 32 pixel icons from the Sprites folder into this new EditorSprites folder. Our Editor script should now be able to load these icons for image-based buttons that it will be drawing in the Inspector, from which the user chooses which pickup prefab object to clone into the scene.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/af577152-388f-4dca-ab3c-8162c0884ff7.png"/></p>
<ol start="12">
<li>From the Project panel, drag <kbd>sprite cross_hairs.fw</kbd> into the Scene. Rename this GameObject object-creator-cross-hairs, and in its Sprite Renderer component in the Inspector, set Sorting Layer to Foreground.</li>
<li>Attach the following C# script to GameObject object-creator-cross-hairs:</li>
</ol>
<pre>    using UnityEngine;<br/> <br/>     public class ObjectBuilderScript : MonoBehaviour {<br/>       void Awake(){<br/>         gameObject.SetActive(false);<br/>       }<br/>     } </pre>
<ol start="14">
<li>Select the Rect Tool (shortcut key T), and as you drag gameObject object-creator-cross-hairs and click on the desired icon in the Inspector, new pickup GameObjects will be added to the scene's Hierarchy.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The script class <kbd>ObjectBuilderScript</kbd> has just two methods, one of which has just one statement - the <kbd>Awake()</kbd> method simply makes this GameObject become inactive when the game is running (since we don't want the user to see our cross-hairs created tool during gameplay). The <kbd>AddObjectToScene(...)</kbd> method receives a reference to a prefab as a parameter and instantiates a new clone of the prefab in the scene at the location of GameObject object-creator-cross-hairs at that point in time.</p>
<p>Script class <kbd>ObjectBuilderEditor</kbd> has a C# attribute <kbd>[CustomEditor(typeof(ObjectBuilderScript))]</kbd> immediately before the class is declared, telling Unity to use this class to control how <kbd>ObjectBuilderScript</kbd> GameObject properties and components are shown to the user in the Inspector.</p>
<p>There are six variables, three textures for the icons to form the buttons in the Inspector, and three GameObject references to the prefabs of which instances will be created. The <kbd>OnEnable()</kbd> method assigns values to these six variables using the built-in method <kbd>AssetDatabase.LoadAssetAtPath()</kbd>, retrieving the icons from the Project folder EditorSprites and getting references to the prefabs in the Project folder Prefabs.</p>
<p>The <kbd>OnInspectorGUI()</kbd> method has a variable myScript, which is set to be a reference to the instance of scripted component <kbd>ObjectBuilderScript</kbd> in GameObject object-creator-cross-hairs (so we can call its method when a prefab has been chosen). The method then displays a mixture of empty text <kbd>Labels</kbd> (to get some vertical spacing) and <kbd>FlexibleSpace</kbd> (to get some horizontal spacing and centering) and displays three buttons to the user, with icons of star, heart, and key. The scripted GUI technique for Unity custom Inspector GUIs wraps an <kbd>if</kbd> statement around each button, and on the frame the user clicks the button, the statement block of the if statement will be executed. When any of the three buttons is clicked, a call is made to <kbd>AddObjectToScene(...)</kbd> of the scripted component <kbd>ObjectBuilderScript</kbd>, passing the prefab corresponding to the button that was clicked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extensible class-based code architecture to manage complex IMGUIs</h1>
                
            
            
                
<p>For complex objects and editor interactions, you may find the number of GUI statements gets high, and code can quickly get hard to manage with very long <kbd>OnGUI()</kbd> methods. One approach to organise complex GUIs involves a list of items, and each item being an object-instance of a wrapper-class for a GUI control object. Each wrapper class will implement its own <kbd>OnGUI()</kbd> method.</p>
<p>In this recipe, we'll use this approach to create a complex GUI with well-organised code. This recipe is adapted from an example posted by Statement on answers.unity.com in 2013 to a question about the different IMGUI libraries: <a href="https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html">https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html</a></p>
<p>We'll create IMGUI static labels, interactive text boxes and a button, and illustrate some flexible space and centering using <kbd>BeginHorizontal()</kbd> and <kbd>EndHorizontal()</kbd>, where the fiddly GUILayout statements are put into their own classes.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e71780bc-4b94-4685-99ac-9010da763561.png" style="width:30.75em;height:16.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create an extensible class-based code architecture to manage complex IMGUIs, follow these steps:</p>
<ol>
<li>First let's create an <strong>interface</strong>, that is, a template script-class that defines a method all implementing-classes must have. Create a folder Editor. Inside that create a folder MyGUI. Inside that create a new C# script-class named <kbd>IMyGUI</kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">public interface IMyGUI<br/> {<br/>     void OnGUI();<br/> } </pre>
<ol start="2">
<li>Now, let's define a FlexibleSpace class for our GUI library. Create a C# script class named <kbd>MyGUIFlexibleSpace</kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> <br/> public class MyGUIFlexibleSpace : IMyGUI<br/> {<br/>     public void OnGUI()<br/>     {<br/>         GUILayout.FlexibleSpace();<br/>     }<br/> }</pre>
<ol start="3">
<li>Now, we'll create a button class. Create a C# script class named <kbd>MyGUIButton</kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> <br/> public class MyGUIButton : IMyGUI<br/> {<br/>     public GUIContent label = new GUIContent();<br/>     public event System.Action OnClick;<br/> <br/>     public void OnGUI() {<br/>         // if button clicked, invoke methods registed with 'OnClick' event<br/>         if (GUILayout.Button (label) &amp;&amp; OnClick != null)<br/>             OnClick ();<br/>     }<br/> } </pre>
<ol start="4">
<li>Now, we'll create an input Text Field class. Create a C# script class named <kbd>MyGUITextField</kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEditor;<br/> <br/> public class MyGUITextField : IMyGUI<br/> {<br/>     public string text = "";<br/>     public GUIContent label = new GUIContent();<br/> <br/>     public void OnGUI() {<br/>         text = EditorGUILayout.TextField (label, text);<br/>     }<br/> } </pre>
<ol start="5">
<li>Now, we'll create a non-interactive text label class. Create a C# script class named <kbd>MyGUILabel</kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> <br/> public class MyGUILabel : IMyGUI {<br/>     private string text;<br/>     private bool centerFully;<br/> <br/>     public MyGUILabel(string text, bool centerFully = false) {<br/>         this.text = text;<br/>         this.centerFully = centerFully;<br/>     }<br/> <br/>     public void OnGUI() {<br/>         if (centerFully) {<br/>             GUILayout.BeginVertical();<br/>             GUILayout.FlexibleSpace();<br/>             GUILayout.BeginHorizontal();<br/>             GUILayout.FlexibleSpace();<br/>         }<br/> <br/>         GUILayout.Label(text);<br/>         if (centerFully) {<br/>             GUILayout.FlexibleSpace();<br/>             GUILayout.EndHorizontal();<br/>             GUILayout.FlexibleSpace();<br/>             GUILayout.EndVertical();<br/>         }<br/>     }<br/> } </pre>
<ol start="6">
<li>In Editor folder, we'll now create a class to display an interactive custom panel, making use of our <kbd>MyGUI</kbd> classes above. Create <kbd>C# script-class MyEditorWindow</kbd> containing the following to start with:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEditor;<br/> using System.Collections.Generic;<br/> <br/> // adapted from answers.unity.com sample code posted by 'Statememt' (Dec 2013)<br/> // https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html<br/> public class MyEditorWindow : EditorWindow<br/>  {<br/>      MyGUITextField username;<br/>      MyGUITextField realname;<br/>      MyGUIButton registerButton;<br/>      MyGUIFlexibleSpace flexibleSpace;<br/> <br/>      // Optional, but may be convenient.<br/>      List&lt;IMyGUI&gt; gui = new List&lt;IMyGUI&gt;();<br/> <br/>      [MenuItem("Example/Show Window")]<br/>      public static void ShowWindow () {<br/>          GetWindow&lt;MyEditorWindow&gt;("My Reg Panel", true);<br/>      }<br/> }</pre>
<ol start="7">
<li>We'll now add the method to display a menu item to open our window-panel. Add the following to <kbd>C# script-class MyEditorWindow</kbd>:</li>
</ol>
<pre style="padding-left: 60px">[MenuItem("Example/Show Window")]<br/> public static void ShowWindow () {<br/>  GetWindow&lt;MyEditorWindow&gt;("My Reg Panel", true);<br/> } </pre>
<ol start="8">
<li>We'll now add a method to setup our <kbd>MyGUI</kbd> objects and add them to our GUI list of objects. Add the following to C# script-class<kbd> MyEditorWindow</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    void OnEnable()<br/>     {<br/>         username = new MyGUITextField ();<br/>         username.label.text = "Username";<br/>         username.text = "JDoe";<br/> <br/>         realname = new MyGUITextField ();<br/>         realname.label.text = "Real name";<br/>         realname.text = "John Doe";<br/> <br/>         registerButton = new MyGUIButton ();<br/>         registerButton.label.text = "Register";<br/>          // add RegisterUser() to button's OnClick event broadcaster<br/>         registerButton.OnClick += LogUser;<br/> <br/>         bool centerFully = true;<br/>         gui.Add(new MyGUILabel("Unity 2018 is great", centerFully));<br/> <br/>         gui.Add (username);<br/>         gui.Add (realname);<br/>         gui.Add(new MyGUIFlexibleSpace());<br/>         gui.Add (registerButton);<br/>     } </pre>
<ol start="9">
<li>We'll now add a method loop through and display all our GUI objects each frame. Add the following to C# script-class <kbd>MyEditorWindow</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    void OnGUI() {<br/>      foreach (var item in gui)<br/>          item.OnGUI();<br/>     }</pre>
<p class="mce-root"/>
<ol start="10">
<li>Finally, we need to add a method to respond to the button clicks (<kbd>LogUser</kbd>). Also a method to ensure we re-register this method when the window is disabled (to avoid memory leaks). Add these two methods to C# script-<kbd>class MyEditorWindow</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    private void OnDisable()<br/>     {<br/>      registerButton.OnClick -= LogUser;<br/>     }<br/> <br/>     void LogUser()<br/>     {<br/>      var msg = "Registering " + realname.text + " as " + username.text;<br/>      Debug.Log (msg);<br/>     } </pre>
<ol start="11">
<li>After a few seconds, you should now see a menu named Example appear with a Show Window item.</li>
<li>You should now be able to display our custom registration panel by choosing this menu item.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Since there are several C# script-classes, each shall be separately described in the following.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class MyEditorWindow</h1>
                
            
            
                
<p>In C# script-class <kbd>MyEditorWindow</kbd>, you preceded the <kbd>ShowWindow()</kbd> method with an attribute to add a menu item Show Window to a menu named Example. The <kbd>GetWindow()</kbd> statement gets a reference to an <kbd>MyEditorWindow</kbd> object - if no such window-panel exists, it creates one. The first argument is the title of the panel My Reg Panel. The true for the second argument tells Unity to make the window-panel have the focus (if a window panel already existed).</p>
<p>The <kbd>OnEnable()</kbd> method is executed when the window-panel first becomes enabled (active). It creates 2 <kbd>MyGUITextField</kbd> objects for username and real name, and a register <kbd>MyGUIButton</kbd>. Each of these objects are based on the MyGUI component script-classes in folder <kbd>MyGUI.</kbd> Then GUI objects are added in the sequence we wish, to the list variable <kbd>guiCompoennts</kbd>. The first GUI component added to the list is a new object-instance of an non-interactive <kbd>MyGUILabel</kbd> (passing the text string Unity 2018 is great and a true for full centering). Then, we add the two text input components (username and real name), then a new <kbd>MyGUIFlexible</kbd> space object-instance, and finally a <kbd>MyGUIButton</kbd> with the label Register, whose <kbd>OnClick</kbd> event will cause the invocation of the <kbd>LogUser()</kbd> method.</p>
<p>The <kbd>LogUser()</kbd> method logs the names in the two text fields to the Debug.Log.</p>
<p>The <kbd>OnDisable()</kbd> method ensures that when the window-panel is being disabled/closed we de-register the <kbd>LogUser()</kbd> method from the OnClick event of the button object.</p>
<p>The <kbd>OnGUI()</kbd> method, which executes every frame, simply loops through each GUI compoennt in list guiComponents, invoking the components' <kbd>OnGUI()</kbd> method. So each frame, our GUI is redisplayed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class IMyGUI</h1>
                
            
            
                
<p>This C# script-class declares an <strong>interface named</strong> IMyGUI. An interface is a template script-class that defines method(s) all implementing classes must implement. Our interface class is very simple, it simply requires all implementing classes must defined an <kbd>OnGUI()</kbd> method. There is a naming convention that recommends all interface classes have a capital letter I, before the upper-camel case class name.</p>
<p>By declaring this interface, we can now implement lots of different <kbd>IMyGUI</kbd> classes, which can all be treated the same way - that is, they can have their <kbd>OnGUI()</kbd> method invoked each frame.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class MyGUIFlexibleSpace</h1>
                
            
            
                
<p>This simple script-class adds a <kbd>GUILayout.FlexibleSpace()</kbd> to the IMGUI system when its <kbd>OnGUI()</kbd> method is invoked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class MyGUITextField</h1>
                
            
            
                
<p>This class declares two public items: a public string (for the text the user can see and edit), and a public label. Its <kbd>OnGUI()</kbd> method displays the labelled text field, and stores its value back into variable text.</p>
<p>So our custom editor classes can set the initial text value and label, and also read any new value of the text from an object-instance of this class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class MyGUILabel</h1>
                
            
            
                
<p>This class has two private values: the text to be displayed, and a bool, defining whether or not to fully center the text. Its <kbd>OnGUI()</kbd> method will add a <kbd>GUILayout.Lable()</kbd> to the GUI, and if the bool is true, it will add other GUILayout components before and after the label to ensure the label is both vertically and horizontally centered when displayed.</p>
<p>This is an example of how some of the complexity of an interface can be delegated to its own class like this. By setting a single bool to true, several Begin/End/Vertical/Horizontal statements and FlexibleSpace statements are added to the GUI that is output.</p>
<p>The screenshot illustrates how the flexible space and vertical/horizonal groups result in the desired alignment and spacing in the window-panel the user sees:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/466a14ac-e0db-4fff-86f4-4accbd7ed5c2.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class MyGUIButton</h1>
                
            
            
                
<p>This class declares a public label, and also a public <kbd>OnClick</kbd> event. During the execution of its <kbd>OnGUI()</kbd> method, if the button has been clicked any methods that have been registered to listen for, <kbd>OnClick</kbd> events will be invoked.</p>
<p>There is a condition in the <kbd>OnGUI()</kbd> method, to ensure that if no methods are registered to list for <kbd>OnClick</kbd> events, then no statement is executed.</p>
<p>We can see the <kbd>LogUser</kbd> method of the <kbd>MyEditorWindow</kbd> the window-panel object being registered for the <kbd>OnClick</kbd> event of the <kbd>registerButton</kbd> object, in its <kbd>OnEnable()</kbd> method:</p>
<pre>registerButton = new MyGUIButton ();<br/> registerButton.label.text = "Register";<br/> // add RegisterUser() to button's OnClick event broadcaster<br/> registerButton.OnClick += LogUser; </pre>
<p>While perhaps overkill for this simple window-panel, this recipe illusrtates how the use of an Interface and a list of GUI component objects, allows for an extensible system of custom GUI component classes to be created, while allowing the complexity of the <kbd>EditorWindow</kbd> classes to be maintained.</p>
<p> </p>
<p>NOTE: An alternative to C# events would be to use Unity Events and in some cases lambda expressions. You can read a discussion of such topics in these online articles:</p>
<ul>
<li><kbd>http://www.blockypixel.com/2012/09/c-in-unity3d-dynamic-methods-with-lambda-expressions/</kbd></li>
<li><kbd>https://forum.unity.com/threads/how-to-use-an-action.339952/</kbd></li>
</ul>


            

            
        
    </body></html>