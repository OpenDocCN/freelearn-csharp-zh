- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Writing Data to Relational and NoSQL Databases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据写入关系型和非关系型数据库
- en: After creating the first implementation of the service using minimal APIs, we
    build on that to read and write to databases. In this chapter, we will replace
    the in-memory repository built in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031)
    using **Entity Framework Core** (**EF Core**) to access a relational database
    – Microsoft SQL Server – and an Azure Cosmos DB NoSQL database using EF Core.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用最小API创建服务的第一个实现之后，我们将在此基础上进行读取和写入数据库的操作。在本章中，我们将用**Entity Framework Core**（**EF
    Core**）替换内存中的存储库，以访问关系型数据库——Microsoft SQL Server——以及使用EF Core的Azure Cosmos DB
    NoSQL数据库。
- en: You’ll create two libraries to access these databases, create EF Core context
    classes, specify the mappings from model classes, and configure the minimal APIs
    service to use one or the other database. After adding these changes, the games
    will be persisted and you can continue game runs when the service is restarted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建两个库来访问这些数据库，创建EF Core上下文类，指定从模型类到数据库的映射，并配置最小API服务以使用其中一个数据库。在添加这些更改后，游戏将被持久化，当服务重启时可以继续游戏运行。
- en: 'In this chapter, you’ll be exploring these topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索以下主题：
- en: Exploring the models for the data to be stored in the databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索要存储在数据库中的数据模型
- en: Creating and configuring an EF Core context to access Microsoft SQL Server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置EF Core上下文以访问Microsoft SQL Server
- en: Creating migrations to update the database schema
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建迁移以更新数据库架构
- en: Creating and configuring an EF Core context to access Azure Cosmos DB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置EF Core上下文以访问Azure Cosmos DB
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure)。
- en: 'The `ch03` source code folder contains the code samples for this chapter. The
    most important projects for this chapter are the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch03`源代码文件夹包含本章的代码示例。本章最重要的项目如下：'
- en: '`Codebreaker.Data.SqlServer` – This is the new library to access Microsoft
    SQL Server.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Data.SqlServer` – 这是用于访问Microsoft SQL Server的新库。'
- en: '`Codebreaker.Data.Cosmos` – This is the new library to access Azure Cosmos
    DB.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Data.Cosmos` – 这是用于访问Azure Cosmos DB的新库。'
- en: '`Codebreaker.GamesAPIs` – This is the web API project created in the previous
    chapter. In this chapter, the **dependency injection** (**DI**) container is updated
    to use .NET Aspire components to use SQL Server and Azure Cosmos DB.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GamesAPIs` – 这是上一章创建的Web API项目。在本章中，**依赖注入**（**DI**）容器已更新，以使用.NET
    Aspire组件来使用SQL Server和Azure Cosmos DB。'
- en: '`Codebreaker.GameAPIs.Models` – This project just has a minimal change in this
    chapter, adding a property to the `Game` class.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.Models` – 本章节中该项目仅进行了最小更改，为`Game`类添加了一个属性。'
- en: '`Codebreaker.AppHost` – This project is updated with SQL Server and Azure Cosmos
    DB resources and forwarding configuration values.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost` – 该项目已更新，包含SQL Server和Azure Cosmos DB资源以及转发配置值。'
- en: '`Codebreaker.ServiceDefaults` – This project is unchanged from the previous
    chapter.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.ServiceDefaults` – 该项目与上一章保持不变。'
- en: The `analyzer` library from the previous chapter is not included in this chapter.
    Here, we’ll just use the `CNinnovation.Codebreaker.Analyzers` NuGet package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的`analyzer`库在本章中未包含。在这里，我们仅使用`CNinnovation.Codebreaker.Analyzers` NuGet包。
- en: If you worked through the previous chapter to create the models and implemented
    the minimal APIs project, you can continue from there. You can also copy the files
    from the `ch02` folder if you didn’t complete the previous work and start from
    there. `ch03` contains all the updates from this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了上一章的内容，创建了模型并实现了最小API项目，你可以从那里继续。如果你没有完成上一章的工作，也可以从`ch02`文件夹中的文件开始。`ch03`包含了本章的所有更新。
- en: 'Other than a development environment, you need Microsoft SQL Server and Azure
    Cosmos DB. You don’t need an Azure subscription at this point. SQL Server is installed
    together with Visual Studio. You can also download the SQL Server 2022 Developer
    Edition instead. This is easy via `winget` (but you can also download and install
    Windows installer packages instead):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开发环境之外，您还需要 Microsoft SQL Server 和 Azure Cosmos DB。目前您不需要 Azure 订阅。SQL Server
    会与 Visual Studio 一起安装。您也可以下载 SQL Server 2022 开发者版。这可以通过 `winget` 实现很简单（但您也可以下载并安装
    Windows 安装程序包）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you use a Mac, you can use a Docker image for SQL Server. In [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    you can read more details on Docker and running SQL Server within a Docker container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Mac，您可以使用 SQL Server 的 Docker 镜像。在 [*第 5 章*](B21217_05.xhtml#_idTextAnchor110)
    中，您可以阅读有关 Docker 和在 Docker 容器中运行 SQL Server 的更多详细信息。
- en: For easy use of SQL Server and Azure Cosmos DB, Docker images are used in this
    chapter. You can also use SQL Server, which is installed together with Visual
    Studio, and the Azure Cosmos DB emulator instead.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用 SQL Server 和 Azure Cosmos DB，本章使用了 Docker 镜像。您也可以使用与 Visual Studio 一起安装的
    SQL Server，以及 Azure Cosmos DB 模拟器。
- en: 'To run Azure Cosmos DB, an emulator to run it locally is available. You can
    install this NoSQL database emulator with the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Azure Cosmos DB，有一个本地运行的模拟器可用。您可以使用以下命令安装此 NoSQL 数据库模拟器：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Azure Cosmos emulator is only available on Windows. With Linux environments
    (and also on Windows and the Mac), you can use a Docker image to run the emulator.
    See [https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator](https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator)
    for information on running the emulator. Read [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110)
    for more information on Docker.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos 模拟器仅在 Windows 上可用。在 Linux 环境中（以及 Windows 和 Mac 上），您可以使用 Docker
    镜像来运行模拟器。有关运行模拟器的信息，请参阅 [https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator](https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator)。有关
    Docker 的更多信息，请参阅 [*第 5 章*](B21217_05.xhtml#_idTextAnchor110)。
- en: 'To read and write your SQL Server data, within Visual Studio you can use SQL
    Server Object Explorer. Outside of Visual Studio, and with more functionality,
    use **SQL Server Management Studio** (**SSMS**), which can be installed with the
    following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取和写入您的 SQL Server 数据，在 Visual Studio 中，您可以使用 SQL Server 对象资源管理器。在 Visual Studio
    之外，并且具有更多功能，请使用 **SQL Server Management Studio**（**SSMS**），可以使用以下命令安装：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The projects of this chapter and how they relate to each other are shown in
    *Figure 3**.1* with a C4 component diagram. The `gamesAPI` and `models` components
    have been created in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031). In this
    chapter, two projects for accessing SQL Server and Azure Cosmos DB databases will
    be added (`sqlDatabase` and `cosmosDatabase`). Depending on the configuration,
    the games API will use either the in-memory repository (created in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031))
    or one of the other `IGamesRepository` implementations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目及其相互关系在 *图 3.1* 中以 C4 组件图展示。`gamesAPI` 和 `models` 组件是在 [*第 2 章*](B21217_02.xhtml#_idTextAnchor031)
    中创建的。在本章中，将添加两个用于访问 SQL Server 和 Azure Cosmos DB 数据库的项目（`sqlDatabase` 和 `cosmosDatabase`）。根据配置，游戏
    API 将使用内存中的存储库（在 [*第 2 章*](B21217_02.xhtml#_idTextAnchor031) 中创建）或 `IGamesRepository`
    的其他实现之一：
- en: '![Figure 3.1 – Projects](img/B21217_03_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 项目](img/B21217_03_01.jpg)'
- en: Figure 3.1 – Projects
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 项目
- en: Let’s start exploring the project containing the models while making a small
    change to the models.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在对模型进行小修改的同时，开始探索包含这些模型的工程。
- en: Exploring the models for database mapping
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据库映射的模型
- en: When creating services, different models can be used for the database, the functionality,
    and the APIs. The database layer might have different requirements than the other
    layers. When creating a monolithic application, this usually is the case, but
    it also means that while maintaining the application and adding a field, all the
    different layers need to be touched and updated. When creating microservices with
    smaller scopes, there’s a good chance to use the same model with the database,
    the functionality of the application, and the APIs. This not only reduces maintenance
    costs but also improves performance in that not every layer creates new instances
    and copies the values around.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建服务时，可以使用不同的模型来处理数据库、功能和 API。数据库层可能与其他层有不同的要求。当创建单体应用程序时，通常是这样的，但这也意味着在维护应用程序和添加字段时，所有不同的层都需要被触及并更新。当创建具有较小范围的微服务时，有很大可能可以使用与数据库、应用程序的功能和
    API 相同的模型。这不仅降低了维护成本，还提高了性能，因为不是每个层都会创建新的实例并在周围复制值。
- en: With the sample application, the `Game` and `Move` types with their generic
    counterparts created in the previous chapter are not that simple, but it’s possible
    to use them directly with EF Core.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中，`Game` 和 `Move` 类型及其在前一章中创建的泛型对应类型并不简单，但它们可以直接与 EF Core 一起使用。
- en: 'Let’s look at the models and what must be mapped for the database, starting
    with the `Game` type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模型以及数据库需要映射的内容，从 `Game` 类型开始：
- en: Codebreaker.GameAPIs.Models/Game.cs
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Models/Game.cs
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Game` class contains properties of type `Guid`, `string`, `DateTime`, `TimeSpan`,
    `int`, and `bool`. All these properties can easily be mapped to database columns.
    Just the size of the string needs to be configured. With SQL Server, the convention
    to map a string is `nvarchar(max)`. This can be reduced in size. What’s more interesting
    is the constructor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 类包含 `Guid`、`string`、`DateTime`、`TimeSpan`、`int` 和 `bool` 类型的属性。所有这些属性都可以轻松映射到数据库列。只需配置字符串的大小即可。对于
    SQL Server，映射字符串的约定是 `nvarchar(max)`。这可以减小大小。更有趣的是构造函数。'
- en: The class doesn’t define a parameterless constructor. While some tools require
    a parameterless constructor, both JSON serialization as well as EF Core nowadays
    don’t need one. EF Core supports constructors with parameters as long as the constructors
    map to simple properties – which is the case with the `Game` class. EF Core mapping
    supports properties with `get` and `set` accessors. If there’s just a `get` accessor
    available, the mapping will fail. A way around this is to use `private` fields.
    EF Core supports explicit mapping to fields. Another option is to use private
    `set` accessors – which are used with the `Game` class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该类没有定义无参构造函数。虽然一些工具需要无参构造函数，但现在的 JSON 序列化和 EF Core 都不需要。EF Core 支持具有参数的构造函数，只要构造函数映射到简单属性即可——`Game`
    类就是这样。EF Core 映射支持具有 `get` 和 `set` 访问器的属性。如果只有一个 `get` 访问器可用，映射将失败。一种解决方案是使用 `private`
    字段。EF Core 支持显式映射到字段。另一个选项是使用私有的 `set` 访问器——这在 `Game` 类中被使用。
- en: 'Some other interesting members are available with the `Game` class: the `FieldValues`
    property is of type `IDictionary<string, IEnumerable<string>>`. The field values
    define the possible options the user can choose from. All games of one game type
    usually have the same field values, but this can change over time. We shouldn’t
    expect these values to always stay the same. The application might change the
    colors or shapes to choose from over time. So, we can’t just ignore the property
    to be stored – this should be stored with the game. As for this type, a default
    mapping is not available, so we need to add a conversion.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 类还有一些其他有趣的成员：`FieldValues` 属性的类型为 `IDictionary<string, IEnumerable<string>>`。字段值定义了用户可以选择的可能选项。通常，同一游戏类型的所有游戏都具有相同的字段值，但这些都可能随时间而变化。我们不应该期望这些值始终保持不变。应用程序可能会随着时间的推移更改可选择的颜色或形状。因此，我们不能简单地忽略要存储的属性——这个属性应该与游戏一起存储。至于这种类型，没有默认的映射可用，因此我们需要添加一个转换。'
- en: The `Codes` property is of type string array. EF Core 8.0 supports built-in
    mapping of collections of primitive types; that is, a list of arrays, integers,
    strings, and more. With the built-in functionality, the collection is stored in
    the JSON format in a string table. This fits the purpose. The `Codes` property
    contains a list of a solution. With the color-based game types, this is a list
    of up to five colors; with the shape game type, one string of the collection consists
    of a shape and a color with a delimiter. Using a version older than EF Core 8,
    a custom conversion would be required. With EF Core 8, this will map with the
    default functionality.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codes` 属性是字符串数组类型。EF Core 8.0 支持内置映射原始类型集合；也就是说，数组、整数、字符串等的列表。使用内置功能，集合以 JSON
    格式存储在字符串表中。这符合目的。`Codes` 属性包含一个解决方案的列表。对于基于颜色的游戏类型，这是一个最多包含五种颜色的列表；对于形状游戏类型，集合中的一个字符串由形状和颜色以及分隔符组成。使用低于
    EF Core 8 的版本，则需要自定义转换。使用 EF Core 8，这将使用默认功能进行映射。'
- en: The `Moves` property is typically a relation with relational databases. Using
    SQL Server, we will use the `Moves` table to store every move. It would be possible
    to store moves with a JSON column, but we’ll use a separate table and query for
    moves if needed. Using a NoSQL database, it’s a natural way to store moves within
    the game.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Moves` 属性通常与关系型数据库相关联。使用 SQL Server，我们将使用 `Moves` 表来存储每个移动。如果需要，可以使用 JSON
    列存储移动，但我们将使用单独的表和查询来存储移动。使用 NoSQL 数据库，在游戏中存储移动是一种自然的方式。'
- en: 'Let’s look into the `Move` type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `Move` 类型：
- en: Codebreaker.GameAPIs.Models/Move.cs
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Models/Move.cs
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the `Move` class, `GuessPegs` (the guess of the player for the move) and
    `KeyPegs` (the result from the analyzer) can be serialized similarly to the `Codes`
    property from the `Game` type. What’s more interesting here is what’s *not* here.
    That is, the absence of a foreign key property like `GameId` or a direct `Game`
    property to establish a relationship between the `Move` and `Game` types. While
    using the `Move` type so far, this relationship was not required. With EF Core,
    it’s also not required to add this relationship to the model. EF Core supports
    a feature named **shadow properties**. These properties are not part of the model
    but are stored within the database and can be accessed while using the EF Core
    context.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Move` 类，`GuessPegs`（玩家对移动的猜测）和 `KeyPegs`（分析器的结果）可以像 `Game` 类型的 `Codes` 属性一样进行序列化。更有趣的是这里没有的东西。也就是说，没有像
    `GameId` 这样的外键属性或直接建立 `Move` 和 `Game` 类型之间关系的 `Game` 属性。到目前为止，在使用 `Move` 类型时，这种关系不是必需的。在
    EF Core 中，也不需要在模型中添加这种关系。EF Core 支持一个名为 **影子属性** 的功能。这些属性不是模型的一部分，但存储在数据库中，并且在使用
    EF Core 上下文时可以访问。
- en: 'Let’s summarize what needs to be done to map the `Game` and `Move` types with
    EF Core:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下使用 EF Core 映射 `Game` 和 `Move` 类型所需完成的任务：
- en: For simple string properties, the size of the database string needs to be defined
    with SQL Server.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于简单的字符串属性，需要使用 SQL Server 定义数据库字符串的大小。
- en: The `FieldValues` property of type `IDictionary<string, IEnumerable<string>>`
    needs a **value converter**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FieldValues` 属性的类型为 `IDictionary<string, IEnumerable<string>>` 需要一个 **值转换器**。'
- en: The `Moves` property maps a collection to the `Move` type. With a relational
    database, `Move` objects should be stored in a separate `Moves` table. Because
    the `Move` type doesn’t define a primary key, **shadow properties** are needed.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Moves` 属性将集合映射到 `Move` 类型。在关系型数据库中，`Move` 对象应该存储在单独的 `Moves` 表中。因为 `Move`
    类型没有定义主键，所以需要 **影子属性**。'
- en: Using Azure Cosmos DB, the moves should be stored in the game JSON document.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Azure Cosmos DB，移动应该存储在游戏 JSON 文档中。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: EF Core supports mapping via conventions, annotations, and the fluent API. Conventions
    are provider-specific. For example, a .NET string mapping to `nvarchar(max)` is
    a convention. Using nullability, a non-nullable property maps to a required database
    column, while a nullable property is not required. Conventions are overridden
    using annotations. Annotations are attributes such as `[StringLength(20)]`,which
    not only can be used to validate user input but also to specify the column to
    be `nvarchar(20)`. Using the fluent API, annotations can be overridden. The fluent
    API offers most options and overrides all the other settings. We’ll use the fluent
    API in the next sections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 支持通过约定、注解和流畅 API 进行映射。约定是提供程序特定的。例如，.NET 字符串映射到 `nvarchar(max)` 是一个约定。使用可空性，不可空属性映射到必需的数据库列，而可空属性不是必需的。约定可以通过注解覆盖。注解是如
    `[StringLength(20)]` 这样的属性，它不仅可以用于验证用户输入，还可以指定列应为 `nvarchar(20)`。使用流畅 API，可以覆盖注解。流畅
    API 提供了大多数选项，并覆盖了所有其他设置。我们将在下一节中使用流畅 API。
- en: Let’s define a mapping to work with these models, both with a relational database
    and NoSQL.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个映射来处理这些模型，无论是关系数据库还是 NoSQL。
- en: Using EF Core with SQL Server
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 与 SQL Server
- en: 'Let’s start with a relational database to store games and moves in multiple
    tables. We need to do the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从关系数据库开始，在多个表中存储游戏和移动。我们需要做以下事情：
- en: Create a class library project
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建类库项目
- en: Create the EF Core context
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 EF Core 上下文
- en: Customize the mapping of simple properties
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义简单属性的映射
- en: Create value conversions to map complex properties
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于映射复杂属性的值转换
- en: Define relations between games and moves
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义游戏和移动之间的关系
- en: Create shadow properties for the `Move` type
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Move` 类型创建阴影属性
- en: Implement the repository contract
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现存储库合约
- en: Configure the application model with SQL Server
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SQL Server 配置应用程序模型
- en: Configure the DI container with the minimal APIs project
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最小 API 项目配置 DI 容器
- en: Creating a data class library using SQL Server
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SQL Server 创建数据类库
- en: 'To create the class library project, you can use the .NET CLI as shown or use
    the class library project template from Visual Studio:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类库项目，您可以使用如下所示的 .NET CLI 或使用 Visual Studio 中的类库项目模板：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To access SQL Server with EF Core, add the `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet package. This project also has a dependency on the `Codebreaker.GameAPIs.Models`
    project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 EF Core 访问 SQL Server，请添加 `Microsoft.EntityFrameworkCore.SqlServer` NuGet
    包。此项目还依赖于 `Codebreaker.GameAPIs.Models` 项目。
- en: Creating an EF Core context for SQL Server
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 SQL Server 创建 EF Core 上下文
- en: 'The mapping to the database is specified with an EF Core context implemented
    with the `GamesSqlServerContext` class, as shown in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码片段所示，使用实现 `GamesSqlServerContext` 类的 EF Core 上下文指定数据库映射：
- en: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An EF Core context class needs to derive from the `DbContext` base class. Using
    the context from a DI container, the connection string can be configured outside
    of the context. This requires using the constructor with the `DbContextOption`
    parameter, which needs to be forwarded to the base class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 上下文类需要从 `DbContext` 基类派生。使用来自 DI 容器的上下文，可以在上下文外部配置连接字符串。这需要使用带有 `DbContextOption`
    参数的构造函数，该参数需要传递给基类。
- en: The `GamesSqlServerContext` class implements the `IGamesRepository` interface,
    which we defined in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031), to be used
    by the `GamesService` class. In [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031),
    we implemented this interface with the `GamesMemoryRepository` in-memory repository
    class. The EF Core context class supports the repository pattern by implementing
    the same interface. This way, we can easily switch the in-memory repository by
    using `GamesSqlServerContext` instead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesSqlServerContext` 类实现了我们在 [*第 2 章*](B21217_02.xhtml#_idTextAnchor031)
    中定义的 `IGamesRepository` 接口，以便 `GamesService` 类使用。在 [*第 2 章*](B21217_02.xhtml#_idTextAnchor031)
    中，我们使用 `GamesMemoryRepository` 内存存储库类实现了此接口。EF Core 上下文类通过实现相同的接口支持存储库模式。这样，我们可以通过使用
    `GamesSqlServerContext` 来轻松切换内存存储库。'
- en: The overridden `OnModelCreating` method allows customization to map the model
    types to the database. With SQL Server, the default schema name is `dbo`. This
    is changed by invoking `modelBuilder.HasDefaultSchema`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的 `OnModelCreating` 方法允许自定义将模型类型映射到数据库。对于 SQL Server，默认架构名称是 `dbo`。这可以通过调用
    `modelBuilder.HasDefaultSchema` 来更改。
- en: To reduce the complexity of the `OnModelCreating` method, `GameConfiguration`
    and `MoveConfiguration` classes are created to customize the mapping with the
    `Game` and `Move` types.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少`OnModelCreating`方法的复杂性，创建了`GameConfiguration`和`MoveConfiguration`类来使用`Game`和`Move`类型进行自定义映射。
- en: One more thing that’s required with the context class is for properties of type
    `DbSet<TEntity>` to allow using properties to access mapped database tables.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上下文类还需要的一件事是，允许使用属性来访问映射的数据库表，对于类型为`DbSet<TEntity>`的属性。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Creating the `codebreaker` solution had several iterations. One time, an abstract
    base class and generically derived class were used to support all the different
    game types. Using EF Core, it’s also possible to map inheritance, and this is
    also possible with the JSON serialization and the OpenAPI definition. EF Core
    can map an inheritance tree to a single table (**table-per-hierarchy** or **TpH**),
    to a table for every type (**table-per-type** or **TpT**), and a table for every
    concrete type (**table-per-concrete-type** or **TpC**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`codebreaker`解决方案经历了几个迭代。一次，使用了一个抽象基类和泛型派生类来支持所有不同的游戏类型。使用EF Core，也可以映射继承，这同样适用于JSON序列化和OpenAPI定义。EF
    Core可以将继承树映射到单个表（**table-per-hierarchy**或**TpH**），每个类型一个表（**table-per-type**或**TpT**），以及每个具体类型一个表（**table-per-concrete-type**或**TpC**）。
- en: Instead of creating a complex class hierarchy for the model types to plan for
    future features that might be never needed, it often helps to have model types
    as simple as possible, depending on what’s required with the current version.
    A complex model design adds complexity in multiple places.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了规划可能永远不会需要的未来功能，而不是创建一个复杂的类层次结构，通常最好将模型类型保持得尽可能简单，这取决于当前版本所需的内容。复杂的模型设计会在多个地方增加复杂性。
- en: The `Game` class as it is defined now fulfills requirements for a group of different
    `Game` types as data holders. Functionality is abstracted away and done from the
    `analyzers` library, which just uses a contract to access the game.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义的`Game`类作为数据持有者满足了一组不同的`Game`类型的要求。功能被抽象化，并通过`analyzers`库执行，该库仅使用合约来访问游戏。
- en: As microservices are used in a smaller scope, the **KISS** principle (**Keep
    It Simple, Stupid**) can help not only reduce work that needs to be done but also
    increase performance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务被用于较小的范围内，**KISS**原则（**Keep It Simple, Stupid**）不仅能帮助减少需要完成的工作，还能提高性能。
- en: Customizing the mapping of simple properties
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义简单属性的映射
- en: 'The mapping of the `Game` class is specified with the `GameConfiguration` class.
    A configuration class that is applied using `ApplyConfiguration` with the context
    configuration needs to implement the `IEntityTypeConfiguration` generic interface:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ApplyConfiguration`与上下文配置应用时，需要实现`IEntityTypeConfiguration`泛型接口的配置类来指定`Game`类的映射。
- en: Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the implementation of this class, the key of the table is specified to
    map to the `Id` property. This would not be required, as convention defines that
    a property with the name `Id` or an ID prefixed with the class name maps to the
    primary key.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现此类，表的关键字被指定为映射到`Id`属性。这并不是必需的，因为约定规定，名为`Id`或以类名前缀ID的属性映射到主键。
- en: The fluent API `HasMaxLength` property is used to change the database types
    for the `GameType` and `PlayerName` properties. The `Codes` property is not such
    a simple property but can still be limited to a size of 120 characters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅的API `HasMaxLength`属性用于更改`GameType`和`PlayerName`属性的数据库类型。`Codes`属性不是一个简单的属性，但仍可以限制为120个字符的大小。
- en: This configuration for the `Games` table is applied by invoking `ApplyConfiguration`
    from the context configuration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置应用于`Games`表是通过从上下文配置中调用`ApplyConfiguration`来实现的。
- en: 'The `MoveConfiguration` class specifies a similar configuration for the `GuessPegs`
    and `KeyPegs` properties:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveConfiguration`类为`GuessPegs`和`KeyPegs`属性指定了类似的配置：'
- en: Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the `Move` type, shadow properties will be specified later in the *Defining
    relations between games and* *moves* section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Move`类型，阴影属性将在*定义游戏和移动之间的关系*部分中稍后指定。
- en: Creating value conversion to map complex properties
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建值转换以映射复杂属性
- en: To allow mapping of types not directly supported by EF Core, value conversion
    can be used. The `FieldValues` property of type `IDictionary<string, IEnumerable<string>>`
    is not directly supported with the default mapping. With the game, the content
    of this value is not really that huge and also doesn’t need to be searched within.
    This allows us to map this to a `nvarchar`-type column.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许映射EF Core不支持的数据类型，可以使用值转换。类型`IDictionary<string, IEnumerable<string>>`的`FieldValues`属性不直接支持默认映射。在这个游戏中，这个值的实际内容并不大，也不需要在其中搜索。这使得我们可以将其映射到`nvarchar`类型的列。
- en: Different options are available for the implementation. We will use a different
    one with SQL Server and with Azure Cosmos DB, but both options could be used with
    any of these providers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实现有多种选项可用。我们将使用不同的选项与SQL Server和Azure Cosmos DB一起使用，但这两个选项都可以与这些提供者中的任何一个一起使用。
- en: 'Let’s look at an example of what the data looks like. Let’s imagine we have
    a dictionary such as the following with colors and shapes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据看起来像什么的一个例子。让我们想象我们有一个如下所示的包含颜色和形状的字典：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This should result in this string:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下字符串：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Every value is prefixed with the key of the value. With the source repository,
    you’ll find a unit test to check for the implementation of this conversion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值都以前缀键开头。在源代码库中，你可以找到一个单元测试来检查这个转换的实现。
- en: 'To convert this dictionary to a string, the `ToFieldsString` extension method
    is implemented:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个字典转换为字符串，实现了`ToFieldsString`扩展方法：
- en: Codebreaker.Data.SqlServer/MappingExtensions.cs
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/MappingExtensions.cs
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the implementation, using the LINQ `SelectMany` method, for every key in
    the dictionary, a value is created that’s prefixed by the key.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，使用LINQ的`SelectMany`方法，对于字典中的每个键，都会创建一个以键为前缀的值。
- en: 'The reverse functionality converts the string to a dictionary with the `FromFieldsString`
    method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 反向功能使用`FromFieldsString`方法将字符串转换为字典：
- en: Codebreaker.Data.SqlServer/MappingExtensions.cs
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/MappingExtensions.cs
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the implementation, the complete string is first split using the `#` separator.
    Each resulting string contains a key and value separated with `:`. These results
    are added to a pair, to finally return a dictionary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，首先使用`#`分隔符将完整的字符串分割。每个结果字符串包含一个键和一个用`:`分隔的值。这些结果被添加到一个对中，最终返回一个字典。
- en: 'These methods are now used with the configuration of the `Game` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法现在用于`Game`类的配置：
- en: Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The column name and data type are specified using the fluent API’s `HasColumnName`,
    `HasColumnType`, and `HasMaxLength` properties. The `HasConversion` method is
    used to convert a type to be mapped to the database representation. This method
    has several overloads for different use cases. Here, the first parameter references
    an expression to convert the .NET property type to the database type, while the
    second parameter does the reverse. Here, we invoke the previously created extension
    methods. With the third parameter, an instance of the `ValueComparer` class is
    invoked. This is used to compare the value for equality.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用fluent API的`HasColumnName`、`HasColumnType`和`HasMaxLength`属性指定列名和数据类型。使用`HasConversion`方法将映射的类型转换为数据库表示。此方法有几个重载，用于不同的用例。在这里，第一个参数引用一个表达式，将.NET属性类型转换为数据库类型，而第二个参数执行反向操作。在这里，我们调用了之前创建的扩展方法。第三个参数调用`ValueComparer`类的实例。这用于比较值的相等性。
- en: Defining relations between games and moves
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义游戏和移动之间的关系
- en: 'With the relational database, the `Games` table has a relation to the `Moves`
    table. One game maps to a list of moves. To make this possible, with the `Moves`
    table a foreign key named `GameId` is defined to reference the primary key of
    the `Games` table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，`Games`表与`Moves`表有关联。一个游戏映射到一个移动列表。为了实现这一点，在`Moves`表中定义了一个名为`GameId`的外键，以引用`Games`表的主键：
- en: Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using `EntityTypeBuilder` for the `Move` type, invoking the `Property` method
    creates a `Move` type doesn’t have a property with this name. If there’s not a
    property with the same name, specifying the type is required as done here using
    the generic parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EntityTypeBuilder`为`Move`类型调用，调用`Property`方法创建一个没有这个名称属性的`Move`类型。如果没有相同名称的属性，则需要指定类型，就像这里使用泛型参数所做的那样。
- en: 'The following code snippet maps this relationship to database tables:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将这个关系映射到数据库表中：
- en: Codebreaker.Data.SqlServer/GameConfiguration.cs
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/GameConfiguration.cs
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: EF Core supports one-to-one, one-to-many, and many-to-many relationships. With
    games and moves, a one-to-many relationship is defined with the `HasMany` and
    `WithOne` methods. The `HasForeignKey` method specifies the `GameId` value of
    the `Move` class to reference the ID of the game records.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 支持一对一、一对多和多对多关系。对于游戏和移动，使用 `HasMany` 和 `WithOne` 方法定义了一对多关系。`HasForeignKey`
    方法指定 `Move` 类的 `GameId` 值以引用游戏记录的 ID。
- en: After defining the mapping from the classes to the tables, let’s implement the
    contract of the repository and add migrations to create the database.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了类到表的映射后，让我们实现存储库的合约并添加迁移以创建数据库。
- en: Implementing the repository contract
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现存储库合约
- en: In the previous chapter, we defined the `IGamesRepository` interface and implemented
    it with an in-memory representation. Now, let’s implement this interface to read
    and write to the SQL Server database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们定义了 `IGamesRepository` 接口，并使用内存表示实现了它。现在，让我们实现这个接口以读取和写入 SQL Server
    数据库。
- en: Adding and deleting games
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和删除游戏
- en: 'Let’s add the implementation of the `AddGameAsync` and `DeleteGameAsync` methods
    of the contract to the `GamesSqlServerContext` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将合约的 `AddGameAsync` 和 `DeleteGameAsync` 方法的实现添加到 `GamesSqlServerContext`
    类中：
- en: Codebreaker.Data.SqlServer/GameSqlServerContext.cs
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/GameSqlServerContext.cs
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the `AddGameAsync` method, the passed `Game` object is added to the `Games`
    property of the EF Core context, which marks the entity as *added* with the change
    tracker. The `SaveChangesAsync` method creates `INSERT` statements in the database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddGameAsync` 方法，传递的 `Game` 对象被添加到 EF Core 上下文的 `Games` 属性中，这标志着实体被更改跟踪器标记为
    *已添加*。`SaveChangesAsync` 方法在数据库中创建 `INSERT` 语句。
- en: The `DeleteGameAsync` method receives the game ID with the parameter. Here,
    the `ExecuteDeleteAsync` method is invoked on the record matching the ID. `ExecuteDeleteAsync`
    and `ExecuteUpdateAsync` methods, available since EF Core 7, don’t use tracking
    and directly execute `DELETE` and `UPDATE` statements. This increases performance
    when change tracking is not necessary. When the record was not found to be deleted,
    this method returns `false`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteGameAsync` 方法接收游戏 ID 参数。在这里，对匹配 ID 的记录调用 `ExecuteDeleteAsync` 方法。自 EF
    Core 7 以来，`ExecuteDeleteAsync` 和 `ExecuteUpdateAsync` 方法不使用跟踪并直接执行 `DELETE` 和
    `UPDATE` 语句。当不需要更改跟踪时，这提高了性能。如果未找到要删除的记录，此方法返回 `false`。'
- en: 'Starting a 6x4 game creates this SQL statement to store the game:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个 6x4 游戏将创建以下 SQL 语句来存储游戏：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s set a move with the next implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用下一个实现来设置一个移动。
- en: Updating a game
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新游戏
- en: 'When a move is set, some game information such as the last move number is updated
    as well. The implementation to add a move and update the game is shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置移动时，一些游戏信息，如最后移动编号，也会更新。添加移动和更新游戏的实现如下所示：
- en: Codebreaker.Data.SqlServer/GameSqlServerContext.cs
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/GameSqlServerContext.cs
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Move` object is added to the context with the `Add` method, and the `Game`
    object is added with the `Update` method. This way, the change tracker is configured
    in that invoking the `SaveChangesAsync` method creates SQL `UPDATE` and `INSERT`
    statements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Add` 方法将 `Move` 对象添加到上下文中，并使用 `Update` 方法添加 `Game` 对象。这样，通过调用 `SaveChangesAsync`
    方法配置了更改跟踪器，从而创建 SQL 的 `UPDATE` 和 `INSERT` 语句。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, one invocation of `SaveChangesAsync` creates one transaction. If
    updating the game fails, there’s a rollback for updating the move. In case you
    need multiple `SaveChangesAsync` instances within one transaction, the easiest
    option to use is ambient transactions (using the `TransactionScope` class from
    the `System.Transactions` namespace).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一次 `SaveChangesAsync` 调用创建一个事务。如果更新游戏失败，则对移动进行回滚。如果您需要在单个事务中执行多个 `SaveChangesAsync`
    实例，最简单的选项是使用环境事务（使用 `System.Transactions` 命名空间中的 `TransactionScope` 类）。
- en: Querying games
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询游戏
- en: 'To retrieve games, we need to implement `Getxx` methods. Let’s start with `GetGameAsync`
    to get the game by using the game ID:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索游戏，我们需要实现 `Getxx` 方法。让我们从 `GetGameAsync` 开始，通过游戏 ID 获取游戏：
- en: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `GetGameAsync` method uses the `SingleOrDefaultAsync` method to get either
    one or zero records. If the game ID is not found, `null` is returned. Behind the
    scenes, a query using `SELECT TOP(2)` is created to check if more than one record
    would be returned from this query. If this is the case, the `SingleOrDefaultAsync`
    method throws an exception.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetGameAsync`方法使用`SingleOrDefaultAsync`方法获取一个或零条记录。如果找不到游戏ID，则返回`null`。在幕后，创建了一个使用`SELECT
    TOP(2)`的查询来检查此查询是否将返回多条记录。如果是这种情况，`SingleOrDefaultAsync`方法会抛出异常。'
- en: The `Include` method is used to create a query that includes moves that relate
    to the returned query. Here, the SQL `LEFT JOIN` statement is used to join multiple
    tables. EF Core writes all the queries and updates to the log output. To better
    see which output maps to which LINQ methods, the `TagWith` method can be used.
    This tag is shown as a title with the log output.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Include`方法创建一个查询，该查询包含与返回查询相关的移动。在这里，使用SQL的`LEFT JOIN`语句来连接多个表。EF Core将所有查询和更新写入日志输出。为了更好地查看哪些输出映射到哪些LINQ方法，可以使用`TagWith`方法。这个标签在日志输出中显示为一个标题。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `TagWith` method is of great help with debugging and troubleshooting. Checking
    the log outputs to see SQL queries sent, the tag gives a fast way to see where
    this query was generated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`TagWith`方法在调试和故障排除中非常有帮助。通过检查日志输出以查看发送的SQL查询，标签提供了一个快速查看此查询生成位置的方法。'
- en: 'The following snippet shows the log output from this query, including the title:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了此查询的日志输出，包括标题：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To query by date, player name, or some other query option, pass the `GamesQuery`
    object to the `GetGamesAsync` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要按日期、玩家名称或其他查询选项进行查询，请将`GamesQuery`对象传递给`GetGamesAsync`方法：
- en: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The implementation of this method uses the `IQueryable` variable to add different
    LINQ query methods. Depending on the values passed with the `GamesQuery` parameter,
    multiple `Where` methods are added, in addition to `OrderBy` or `OrderByDescending`,
    to define the order of the result. To not return all the games played, only the
    first 500 games based on the filter are returned.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的实现使用`IQueryable`变量添加不同的LINQ查询方法。根据`GamesQuery`参数传递的值，除了`OrderBy`或`OrderByDescending`外，还会添加多个`Where`方法来定义结果的顺序。为了不返回所有玩过的游戏，只返回基于筛选器的第一个500个游戏。
- en: 'Calling this method passing the player’s name and a date results in this SQL
    query:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递玩家的名称和日期调用此方法会产生以下SQL查询：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Include` method results in a `LEFT JOIN` operation to access the `Moves`
    table. Because of the `Take` method, `SELECT TOP` is used. Multiple invocations
    of the LINQ `Where` method results in a `WHERE` clause.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Include`方法导致执行`LEFT JOIN`操作以访问`Moves`表。由于`Take`方法，使用`SELECT TOP`。多次调用LINQ的`Where`方法会导致`WHERE`子句。'
- en: Configuring user secrets
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置用户密钥
- en: To access the database, we need to retrieve some configuration values. Some
    of these configuration values are secrets that shouldn’t be part of the source
    code repository. During development time, you can use user secrets. User secrets
    are stored with the user profile.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据库，我们需要检索一些配置值。其中一些配置值是秘密，不应包含在源代码存储库中。在开发期间，您可以使用用户密钥。用户密钥与用户配置文件一起存储。
- en: 'To initialize user secrets, use this .NET CLI command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化用户密钥，请使用以下.NET CLI命令：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This creates a `UserSecretsId` property in the project file. Because all user
    secrets are stored with the user profile, this string is used to differentiate
    the configurations with multiple applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目文件中创建一个`UserSecretsId`属性。因为所有用户密钥都存储在用户配置文件中，所以这个字符串用于区分多个应用程序的配置。
- en: 'To set a configuration value with the secrets, use the `dotnet user-secrets`
    `set` command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用密钥设置配置值，请使用`dotnet user-secrets` `set`命令：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the SQL Server Docker container we use, there are some requirements for
    the password. Be aware that you can’t use simple passwords. Three of four sets
    need to match: uppercase letters, lowercase letters, base 10 digits, and symbols.
    You can check the log output to see if there’s an issue with the password.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们使用的SQL Server Docker容器，对密码有一些要求。请注意，您不能使用简单的密码。需要匹配三到四个集合：大写字母、小写字母、十进制数字和符号。您可以通过检查日志输出来查看是否存在密码问题。
- en: You can also use Visual Studio and a context menu with Visual Studio to configure
    user secrets.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Visual Studio和一个带有Visual Studio的上下文菜单来配置用户密钥。
- en: Be aware that the provider to read configuration values from user secrets by
    default is only used if the secret ID is configured and the application is running
    in the `Development` environment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，从用户密钥中读取配置值的提供程序仅在使用配置的密钥ID且应用程序在`Development`环境中运行时使用。
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User secrets cannot be used in production. The idea of user secrets is to not
    store secrets with a configuration file that’s pushed to a source code repository.
    Every developer working on this project needs to configure the configuration values
    for secrets. In production, you can use other services such as Azure Key Vault.
    This is covered in [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用户密钥在生产环境中不能使用。用户密钥的想法是不将密钥存储在推送到源代码仓库的配置文件中。每个在此项目上工作的开发者都需要配置密钥的配置值。在生产环境中，可以使用其他服务，如Azure
    Key Vault。这将在[*第7章*](B21217_07.xhtml#_idTextAnchor162)中介绍。
- en: Configuring the application model with SQL Server
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL Server配置应用程序模型
- en: 'To run SQL Server, .NET Aspire makes it easy to run a Docker container. Just
    add this code to the application model in the `Codebreaker.AppHost` project:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行SQL Server，.NET Aspire使得运行Docker容器变得简单。只需将以下代码添加到`Codebreaker.AppHost`项目中的应用程序模型中：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `AddSqlServer` method adds a SQL Server resource. Using this method, during
    development time, a Docker container is used. In [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    we’ll get into the details of Docker and add more configuration with this SQL
    Server Docker container. The name of this resource is sql. Optionally, a password
    can be passed to the `AddSqlServer` method. If a configuration parameter value
    is set with the resource name postfixed with -`password` (as we did), this `password`
    is used. Otherwise a random `password` is generated.. The `AddDatabase` method
    adds a database to the resource with the first parameter, the name of the resource
    that is used as a name for the connection string name, and the database name.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSqlServer`方法添加一个SQL Server资源。使用此方法，在开发时间，使用Docker容器。在[*第5章*](B21217_05.xhtml#_idTextAnchor110)中，我们将深入了解Docker，并使用此SQL
    Server Docker容器添加更多配置。此资源的名称为sql。可选地，可以将密码传递给`AddSqlServer`方法。如果使用资源名称后缀为`-password`（如我们所做）的配置参数值设置，则使用此`password`。否则，将生成一个随机的`password`。`AddDatabase`方法使用第一个参数（资源名称）将数据库添加到资源中，该资源名称用作连接字符串名称，以及数据库名称。'
- en: 'To allow us to dynamically decide between different game repositories, we use
    the `DataStore` configuration to decide between in-memory, SQL Server, and Azure
    Cosmos DB on the startup of the application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够动态地在不同的游戏存储库之间进行选择，我们使用`DataStore`配置在应用程序启动时决定使用内存、SQL Server还是Azure
    Cosmos DB：
- en: Codebreaker.AppHost/appsettings.json
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/appsettings.json
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Depending on the database provider you want to use, change the value as needed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您想要使用的数据库提供程序，根据需要更改值。
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[*Chapter 7*](B21217_07.xhtml#_idTextAnchor162), *Flexible Configuration*,
    goes into the details of the `appsettings.json` file and environment-specific
    counterparts, as well as other options to store configuration values such as environmental
    variables, program arguments, and Azure App Configuration instances. In this chapter,
    all we need is to configure settings within `appsettings.json` as well as user
    secrets, which are covered with Azure Cosmos DB.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B21217_07.xhtml#_idTextAnchor162)，*灵活配置*，深入探讨了`appsettings.json`文件及其环境特定对应项的细节，以及存储配置值的其他选项，例如环境变量、程序参数和Azure
    App Configuration实例。在本章中，我们只需要配置`appsettings.json`中的设置以及受Azure Cosmos DB保护的用户密钥。'
- en: 'The configuration value is retrieved with the startup of the `AppHost` project:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 配置值是在`AppHost`项目的启动时检索的：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In case the value is not configured, it defaults to the in-memory provider we
    created in the previous chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值未配置，则默认使用我们在上一章中创建的内存提供程序。
- en: 'Now, we can change dependencies for the game APIs:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更改游戏API的依赖项：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `WithEnvironment` method creates an environment variable for the game APIs
    project with the `DataStore` key and the value that’s retrieved from the configuration.
    The `WithReference` method references the SQL Server resource and creates an environment
    variable for the connection string.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithEnvironment`方法为游戏API项目创建一个环境变量，该变量具有`DataStore`键和从配置中检索的值。`WithReference`方法引用SQL
    Server资源并创建一个用于连接字符串的环境变量。'
- en: Next, let’s configure the minimal APIs project to retrieve the configuration
    values from the `AppHost` project.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置最小 API 项目以从`AppHost`项目检索配置值。
- en: Configuring the DI container with the minimal APIs project
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用最小 API 项目配置 DI 容器
- en: After the mapping of the model to the database is completed and the resource
    dependencies are defined with the Aspire `AppHost` project, the DI container can
    be configured to use the EF Core context.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型映射到数据库完成，并且使用 Aspire `AppHost` 项目定义了资源依赖项之后，可以配置 DI 容器以使用 EF Core 上下文。
- en: The games API project needs a reference to the `Codebreaker.Data.SqlServer`
    project and the `Aspire.Microsoft.EntityFrameworkCore.SqlServer` NuGet package.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏API项目需要引用`Codebreaker.Data.SqlServer`项目和`Aspire.Microsoft.EntityFrameworkCore.SqlServer`
    NuGet 包。
- en: 'The configuration for the `DataStore` is retrieved with the following code
    snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段检索`DataStore`的配置：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Depending on the retrieved configuration value for `DataStore`, we configure
    Azure Cosmos DB, SQL Server, or the in-memory repository that we implemented in
    the previous chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根据检索到的`DataStore`配置值，我们配置 Azure Cosmos DB、SQL Server 或我们在上一章中实现的内存存储库。
- en: 'The configuration for SQL Server, which is called from the previous `switch/case`
    statement, is shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了从上一个`switch/case`语句中调用的 SQL Server 配置：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the .NET Aspire SqlServer EF Core component, we can invoke the `AddSqlServerDbContext`
    API to configure the EF Core context with .NET Aspire. However, this API doesn’t
    provide the level of flexibility we need for working with different database providers.
    Thus, instead, we configure the EF Core context using EF Core APIs such as `AddDbContext`
    and `AddDbContextPool` and add Aspire functionality by using `EnrichSqlServerDbContext`.
    The `AddDbContextObjectPool` method configures to use the SQL Server EF Core provider,
    passing the connection string, which is passed via the `AppHost` project and thus
    needs to match the name configured with the top-level statements in the AppHost
    project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire SqlServer EF Core 组件，我们可以调用`AddSqlServerDbContext` API 来配置 .NET
    Aspire 的 EF Core 上下文。然而，此 API 并未提供我们与不同数据库提供程序一起工作所需的灵活性级别。因此，我们改用 EF Core API，如`AddDbContext`和`AddDbContextPool`来配置
    EF Core 上下文，并通过使用`EnrichSqlServerDbContext`添加 Aspire 功能。`AddDbContextObjectPool`方法配置为使用
    SQL Server EF Core 提供程序，传递连接字符串，该连接字符串通过`AppHost`项目传递，因此需要与 AppHost 项目中的顶级语句配置名称相匹配。
- en: Invoking the `UseQueryTrackingBehavior` method adds one interesting aspect when
    using EF Core. By default, all queries are tracked within the EF Core context
    to allow the context to know about changes. Within the API service, the context
    is newly created with every new HTTP request. Thus, keeping this tracking state
    for every context is not required. Adding and updating entities are explicitly
    marked with the `Add` and `Update` methods. Setting the query tracking behavior
    to `QueryTrackingBehavior.NoTracking` disables tracking with all queries (unless
    overwritten with a query using the `AsTracking` method) and thus reduces the overhead.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`UseQueryTrackingBehavior`方法在使用 EF Core 时增加了一个有趣的方面。默认情况下，所有查询都在 EF Core 上下文中跟踪，以便上下文了解更改。在
    API 服务中，上下文会随着每个新的 HTTP 请求而新建。因此，对于每个上下文保持此跟踪状态是不必要的。添加和更新实体时，会显式使用`Add`和`Update`方法。将查询跟踪行为设置为`QueryTrackingBehavior.NoTracking`将禁用所有查询的跟踪（除非使用`AsTracking`方法覆盖），从而减少了开销。
- en: Instead of turning tracking off by default, you can also use the option to turn
    tracking off with a single query using the `AsNoTracking` method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是默认关闭跟踪，您还可以使用`AsNoTracking`方法通过单个查询来关闭跟踪。
- en: The `EnrichSqlServerDbContext` method adds health checks, logging, and telemetry
    configuration offered by the Aspire component. Logging and telemetry configuration
    are covered in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263), and health checks
    are covered in [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnrichSqlServerDbContext`方法添加了 Aspire 组件提供的健康检查、日志记录和遥测配置。日志记录和遥测配置在[*第 11
    章*](B21217_11.xhtml#_idTextAnchor263)中介绍，健康检查在[*第 12 章*](B21217_12.xhtml#_idTextAnchor294)中介绍。'
- en: As the mappings and the repository contract are implemented, we can now continue
    to create the database using migrations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 随着映射和存储库合约的实现，我们现在可以继续使用迁移创建数据库。
- en: Creating migrations with EF Core
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 创建迁移
- en: Using EF Core, you can create the database with the `Database.EnsureCreatedAsync`
    context API method. However, this does not take schema changes into account. Over
    time, the database schema will change as new features are added – and it’s best
    to do this automatically.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EF Core，你可以使用 `Database.EnsureCreatedAsync` 上下文 API 方法创建数据库。然而，这并不考虑架构更改。随着时间的推移，数据库架构会因为新功能的添加而发生变化——最好是自动进行。
- en: '[*Chapter 8*](B21217_08.xhtml#_idTextAnchor183) describes how to automatically
    publish services to testing and production environments. With this, updating the
    database is important as well. When the database schema changes, updates should
    be published to the environments. EF Core offers **migrations** to record all
    schema changes and update the database schema programmatically.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 8 章*](B21217_08.xhtml#_idTextAnchor183) 描述了如何自动将服务发布到测试和生产环境。因此，更新数据库也很重要。当数据库架构发生变化时，应该将更新发布到环境中。EF
    Core 提供了 **migrations** 来记录所有架构更改并程序化更新数据库架构。'
- en: 'Next, let’s do the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们执行以下操作：
- en: Add the .NET EF Core tool
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 .NET EF Core 工具
- en: Add the EF Core tool and create initial migrations
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 EF Core 工具并创建初始迁移
- en: Update the model and add migrations
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模型并添加迁移
- en: Update the database programmatically
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序化更新数据库
- en: Adding the .NET EF Core tool
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 .NET EF Core 工具
- en: If you don’t have the EF Core .NET command-line tool installed yet, you can
    install it with the `dotnet` CLI as a global or a local tool. Here, we install
    it as a local tool to have a specific version of this tool as part of the `Codebreaker.Data.SqlServer`
    project.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 EF Core .NET 命令行工具，你可以使用 `dotnet` CLI 作为全局或本地工具来安装它。在这里，我们将它作为本地工具安装，以便在
    `Codebreaker.Data.SqlServer` 项目中拥有这个工具的特定版本。
- en: 'To install local tools, a `tool-manifest` file first needs to be created:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装本地工具，首先需要创建一个 `tool-manifest` 文件：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the `tool-manifest` template, the `dotnet new` command creates a `.config`
    directory with a `dotnet-tools.json` file. This manifest file will contain all
    the tools that should be installed when working on the project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tool-manifest` 模板，`dotnet new` 命令会创建一个包含 `dotnet-tools.json` 文件的 `.config`
    目录。这个清单文件将包含在项目工作中应该安装的所有工具。
- en: 'As soon as this manifest file is available, we can install the `dotnet-ef`
    tool:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个清单文件可用，我们就可以安装 `dotnet-ef` 工具：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command configures this tool with the tool manifest file and installs it
    locally. In case you’ve installed another version of this tool globally, while
    the current directory of your command prompt is within the project folder, you
    use the tool version that’s specified with the tool manifest file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使用工具清单文件配置此工具并将其本地安装。如果你在项目文件夹内，而命令提示符的当前目录中安装了此工具的另一个版本，你将使用工具清单文件中指定的工具版本。
- en: 'To get all the tools installed and configured with a tool manifest file, you
    can use the `tool` `restore` command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用工具清单文件安装和配置所有工具，可以使用 `tool` `restore` 命令：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `restore` command can be practically used when you clone a repository containing
    a tool manifest file. Using `dotnet tool restore`, all tools specified with the
    project are restored.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你克隆包含工具清单文件的存储库时，可以使用 `restore` 命令。使用 `dotnet tool restore`，可以恢复项目中指定的所有工具。
- en: 'Let’s use this tool to create an initial migration for the actual context:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个工具为实际上下文创建一个初始迁移：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`migrations` is a command of the `dotnet ef` tool. Using `add`, a new migration
    is added with the name that follows the `add` command (here, `InitGames`). The
    `-s` (or `--startup-project`) option specifies the project where the EF Core context
    is configured with the DI container, and the connection string to the database
    is specified. This is a different project than the project where the EF Core context
    is implemented (`Codebreaker.Data.Cosmos` and `Codebreaker.Data.SqlServer`); that’s
    why this option is needed.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrations` 是 `dotnet ef` 工具的一个命令。使用 `add`，可以添加一个新的迁移，其名称跟随 `add` 命令（这里，`InitGames`）。`-s`（或
    `--startup-project`）选项指定了配置了 DI 容器和数据库连接字符串的 EF Core 上下文的项目，这与实现 EF Core 上下文的项目不同（`Codebreaker.Data.Cosmos`
    和 `Codebreaker.Data.SqlServer`）；这就是为什么需要这个选项。'
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In case creating the migration fails, check the error message. An error could
    be that you failed to specify a mapping, and here the errors are very detailed.
    While working around issues, you can temporarily ignore the properties of the
    model to see if the error is really based on a property mapping.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建迁移失败，请检查错误信息。可能的一个错误是你未能指定映射，这里的错误信息非常详细。在处理问题时，你可以暂时忽略模型属性以查看错误是否真的基于属性映射。
- en: After a successful run of this tool, you’ll see a `Migrations` folder with the
    project. This folder contains a snapshot of the current state of the database,
    including all the table mappings, the property mappings, and the relations. This
    class is named based on the EF Core context suffixed by `ModelSnapshot`; for example,
    `GameSqlServerContextModelSnapshot`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工具成功运行之后，你将看到与项目一起的 `Migrations` 文件夹。这个文件夹包含数据库当前状态的快照，包括所有表映射、属性映射和关系。这个类是根据
    EF Core 上下文后缀名为 `ModelSnapshot` 命名的；例如，`GameSqlServerContextModelSnapshot`。
- en: Every time you add a new migration, the snapshot will be updated and a new `Migration`-derived
    class created that includes all the schema changes based on the previous migration.
    The migration is named with the migration name prefixed with the time. The generated
    class contains an `Up` method that will be invoked when the migration is applied
    to the SQL Server database and a `Down` method that will be invoked when the migration
    is dropped from the database.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每次添加新的迁移时，快照将被更新，并创建一个新的 `Migration` 派生类，该类包含基于前一个迁移的所有模式更改。迁移名称以时间前缀命名。生成的类包含一个
    `Up` 方法，当迁移应用到 SQL Server 数据库时将被调用，以及一个 `Down` 方法，当迁移从数据库中删除时将被调用。
- en: 'Next, we’ll use the `dotnet ef` tool to apply the migration to the database
    and create the database if it doesn’t exist yet. This can be done using the `dotnet
    ef database` `update` command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `dotnet ef` 工具将迁移应用到数据库上，并在数据库尚不存在时创建数据库。这可以通过使用 `dotnet ef database
    update` 命令来完成：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This command now uses the connection string from the startup project to apply
    migrations to the database. Using migrations to create the database, you’ll see
    all the games and moves tables created – along with the `_EFMigrationsHistory`
    table. Reading the content of this table, you’ll see all the migration names applied
    to the database. This information is checked when doing another update to the
    database schema using migrations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个命令现在使用启动项目的连接字符串来将迁移应用到数据库上。使用迁移创建数据库时，你会看到所有游戏和移动表被创建——包括 `_EFMigrationsHistory`
    表。阅读这个表的内容，你会看到应用到数据库上的所有迁移名称。当使用迁移对数据库模式进行另一次更新时，会检查这些信息。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are some cases where creating the database fails while creating the migration
    succeeds. Mapping errors can be the reason here as well. Checking the error message
    again gives good details on the reason for the failure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，在创建数据库失败的同时，迁移创建却成功了。映射错误也可能是这里的原因。再次检查错误信息可以提供关于失败原因的详细信息。
- en: Creating or updating the database programmatically
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化创建或更新数据库
- en: 'Instead of using the command line to apply a migration, migrations can be started
    programmatically invoking the EF Core context with `context.Database.MigrateAsync`.
    Let’s implement this functionality with the `CreateOrUpdateDatabaseAsync` method,
    which is called from the application startup code for easy use of the solution:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 代替使用命令行来应用迁移，可以通过调用 EF Core 上下文并使用 `context.Database.MigrateAsync` 来程序化地启动迁移。让我们通过
    `CreateOrUpdateDatabaseAsync` 方法实现这个功能，该方法从应用程序启动代码中被调用，以便易于使用解决方案：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the implementation, we check if the solution is configured to use SQL Server.
    In that case, the `MigrateAsync` method is invoked to update the database to the
    newest version.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施过程中，我们检查解决方案是否配置为使用 SQL Server。在这种情况下，将调用 `MigrateAsync` 方法来更新数据库到最新版本。
- en: 'With the `codebreaker` solution, this is really convenient – running the solution,
    everything is ready, including the database. From a security standpoint, in the
    production environment, the service running should not have a database connection
    string that is allowed to change the schema. Instead, a separate program can be
    used to update the database. This could be invoked from a GitHub action with automatic
    deployment. Using the `dotnet ef` tool, you can even create a standalone application
    to update the database schema: `dotnet ef migrations bundle` creates an application
    with the .NET runtime included, thus you can start this application from clients
    who don’t have the .NET runtime installed. You can also create a SQL script to
    start the migration if this is the preferred option by the database administrator:
    `dotnet ef` `migrations script`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `codebreaker` 解决方案，这确实很方便 - 运行解决方案，一切就绪，包括数据库。从安全角度来看，在生产环境中运行的服务不应有一个允许更改模式的数据库连接字符串。相反，可以使用一个单独的程序来更新数据库。这可以通过
    GitHub 动作自动部署来调用。使用 `dotnet ef` 工具，你甚至可以创建一个用于更新数据库模式的独立应用程序：`dotnet ef migrations
    bundle` 创建了一个包含 .NET 运行时的应用程序，因此你可以从没有安装 .NET 运行时的客户端启动此应用程序。你也可以创建一个 SQL 脚本来启动迁移，如果数据库管理员更喜欢这种方式：`dotnet
    ef migrations script`。
- en: Next, let’s make a change to the model that influences the database schema.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们对模型进行更改，这将影响数据库模式。
- en: Updating the database schema
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据库模式
- en: 'In [*Chapter 9*](B21217_09.xhtml#_idTextAnchor216), we’ll differentiate anonymous
    from authenticated users. With this, game information will be stored when the
    game is played by an authenticated user. For this, we’ll add a `PlayerIsAuthenticated`
    flag to the `Game` class:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B21217_09.xhtml#_idTextAnchor216) 中，我们将区分匿名用户和认证用户。使用这种方式，当游戏由认证用户玩时，游戏信息将被存储。为此，我们将在
    `Game` 类中添加一个 `PlayerIsAuthenticated` 标志：
- en: Codebreaker.GameAPIs.Models/Game.cs
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Models/Game.cs
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This new property is not defined to be ignored from the database. To update
    the database schema, we add a new migration:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新属性没有被定义为从数据库中忽略。为了更新数据库模式，我们添加一个新的迁移：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The new migration is named `AddPlayerIsAuthenticated`. This change updates
    the snapshot in the `Migrations` folder and adds a new migration, as shown in
    this code snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 新迁移命名为 `AddPlayerIsAuthenticated`。此更改更新了 `Migrations` 文件夹中的快照并添加了一个新的迁移，如以下代码片段所示：
- en: Codebreaker.Data.SqlServer/Migrations/ 20231225095931_AddPlayerIsAuthenticated.cs
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.SqlServer/Migrations/ 20231225095931_AddPlayerIsAuthenticated.cs
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With the `Up` method, updating a database from the previous version, the column
    is added to the database schema (`AddColumn`), and the `Down` method removes the
    column (`DropColumn`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Up` 方法，从上一个版本更新数据库时，会将列添加到数据库模式中（`AddColumn`），而 `Down` 方法会移除该列（`DropColumn`）。
- en: During development, you might often update the schema and create many migrations.
    Before publishing a new version of the application, it’s a good idea to combine
    migrations into one. Just pay attention to the version installed in production
    or staging environments. You should keep the migrations already deployed. Migrations
    that have been used only in your development environment can be removed with `dotnet
    ef migrations remove` (possibly called multiple times to always remove the last
    migration) – and finally, one invocation of `dotnet ef migrations add <Name of
    the migration>`, which then creates one migration with all schema changes since
    the last migration.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你可能经常更新模式并创建许多迁移。在发布应用程序的新版本之前，将迁移合并为一个是一个好主意。请注意生产或预发布环境中安装的版本。你应该保留已部署的迁移。仅在你开发环境中使用过的迁移可以使用
    `dotnet ef migrations remove`（可能多次调用以始终删除最后一个迁移）来移除 - 最后，通过一次调用 `dotnet ef migrations
    add <迁移名称>`，这将创建一个包含自上次迁移以来所有模式更改的迁移。
- en: Now, let’s run the solution using SQL Server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 SQL Server 运行解决方案。
- en: Running the application with SQL Server
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SQL Server 运行应用程序
- en: 'Starting the host application now, not only the game APIs service is running,
    but also SQL Server in a Docker container, as shown in *Figure 3**.2*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动主机应用程序，不仅游戏 API 服务正在运行，而且 SQL Server 在 Docker 容器中运行，如图 *图 3.2* 所示：
- en: '![Figure 3.2 – .NET Aspire resources with SQL Server](img/B21217_03_02.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 与 SQL Server 的 .NET Aspire 资源](img/B21217_03_02.jpg)'
- en: Figure 3.2 – .NET Aspire resources with SQL Server
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 与 SQL Server 的 .NET Aspire 资源
- en: 'You can access the OpenAPI endpoint description to start games. Make sure to
    check into the details of the games API service. Details give information about
    the resource, the endpoints, and the environment variables, as shown in *Figure
    3**.3*:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 OpenAPI 端点描述来开始游戏。请确保检查游戏 API 服务的详细信息。详细信息提供了关于资源、端点和环境变量的信息，如图 *3.3*
    所示：
- en: '![Figure 3.3 – Environment variables](img/B21217_03_03.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 环境变量](img/B21217_03_03.jpg)'
- en: Figure 3.3 – Environment variables
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 环境变量
- en: With the environment variables set for this service, check `DataStore` and `ConnectionStrings__CodebreakerSql`,
    which are set by the `AppHost` project.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为此服务设置环境变量后，检查 `DataStore` 和 `ConnectionStrings__CodebreakerSql`，这些由 `AppHost`
    项目设置。
- en: Try to play a game using the HTTP files. Verify how records are added to the
    SQL Server database. However, when you stop the project and run the application
    again, the database is created from a fresh state. With Docker, we need volumes
    to map storage outside of the Docker container. This is covered in [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 HTTP 文件玩游戏。验证记录如何添加到 SQL Server 数据库。然而，当你停止项目并再次运行应用程序时，数据库将从全新状态创建。使用
    Docker，我们需要卷来映射 Docker 容器外的存储。这将在 [*第 5 章*](B21217_05.xhtml#_idTextAnchor110)
    中介绍。
- en: After this, let’s move over to Azure Cosmos DB.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们转向 Azure Cosmos DB。
- en: Using EF Core with Azure Cosmos DB
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 与 Azure Cosmos DB
- en: With Azure Cosmos DB, Microsoft offers different databases with several APIs
    that make use of the same infrastructure. Most of these database offerings are
    NoSQL databases for different purposes. Azure Cosmos DB offers a JSON document
    store that can be accessed with the Mongo DB API. The Apache Cassandra API offers
    a wide column store where each row can have different columns. The Apache Gremlin
    query language can be used to access a graph version of the database. This is
    great to query for relations using vertices and edges. Azure Cosmos DB for PostgreSQL
    is a distributed high-performance relational database using the same infrastructure
    to read and write from a database network worldwide.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure Cosmos DB，Microsoft 提供了具有多个 API 的不同数据库，这些 API 都使用了相同的底层基础设施。这些数据库产品中的大多数都是针对不同目的的
    NoSQL 数据库。Azure Cosmos DB 提供了一个可以与 MongoDB API 一起访问的 JSON 文档存储。Apache Cassandra
    API 提供了一个宽列存储，其中每一行可以有不同的列。可以使用 Apache Gremlin 查询语言来访问数据库的图版本。这对于使用顶点和边查询关系非常有用。Azure
    Cosmos DB for PostgreSQL 是一个使用相同基础设施进行全球数据库网络读写的高性能分布式关系数据库。
- en: For the `codebreaker` solution, we’ll use Azure Cosmos DB for NoSQL. Here, an
    EF Core provider is available. This allows us to use the same API as with SQL
    Server, but the mapping will be different.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `codebreaker` 解决方案，我们将使用 Azure Cosmos DB for NoSQL。在这里，有一个 EF Core 提供器可用。这允许我们使用与
    SQL Server 相同的 API，但映射将不同。
- en: 'Writing the games and moves to Azure Cosmos DB, we need to do the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏和动作写入 Azure Cosmos DB，我们需要执行以下操作：
- en: Create a class library project
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类库项目
- en: Create the EF Core context
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 EF Core 上下文
- en: Create a value converter to map complex types
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个值转换器来映射复杂类型
- en: Create embedded entities
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建嵌入式实体
- en: Implement the repository contract
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现存储库合约
- en: Configure the application model
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置应用程序模型
- en: Configure the DI container
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 DI 容器
- en: We created a SQL Server database when applying the migrations first. With Azure
    Cosmos DB, migrations are not available and are not needed. As JSON documents
    are stored, we are very flexible in the data to write. There is no concept of
    tables and relations between tables – we just store JSON documents within a container.
    One container can keep data of different kinds. A container can be used as a scaling
    unit, but you can also decide to specify the scaling with the complete database
    and share **request units** (**RU/s**) with different containers in a database.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一次应用迁移时创建了一个 SQL Server 数据库。使用 Azure Cosmos DB，迁移不可用且不需要。由于存储的是 JSON 文档，我们在写入数据方面非常灵活。没有表和表之间关系概念——我们只是在容器中存储
    JSON 文档。一个容器可以保存不同类型的数据。容器可以用作扩展单元，但你也可以选择指定整个数据库的扩展，并与数据库中的不同容器共享 **请求单位**（**RU/s**）。
- en: 'With containers, you also need to know about partitions. Partitions are used
    to scale containers for performance. Before specifying partitions, you need to
    know about some attributes of Azure Cosmos DB:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器时，你还需要了解分区。分区用于扩展容器以提升性能。在指定分区之前，你需要了解一些 Azure Cosmos DB 的属性：
- en: A partition is limited to 20 GB storage. The size limit of a container is 1
    TB.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区限制为 20 GB 存储空间。容器的大小限制为 1 TB。
- en: Writing to the database, a transaction can only span writing to a single partition.
    If different data should be written within a transaction, this data should use
    the same partition key.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中写入时，事务只能跨越写入单个分区。如果事务内需要写入不同的数据，这些数据应使用相同的分区键。
- en: 10,000 RU/s is the maximum limit for a partition. With a container, the limit
    is 1,000,000 RU/s (with serverless, the container RU/s limit is 20,000). For the
    best-performance parallel reading of data, different partition keys should be
    used.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区的最大限制为10,000 RU/s。使用容器时，限制为1,000,000 RU/s（在无服务器模式下，容器RU/s限制为20,000）。为了实现数据并行读取的最佳性能，应使用不同的分区键。
- en: The maximum length of a partition key is 2048 bytes.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区键的最大长度为2048字节。
- en: The maximum size of one item to store is 2 MB.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的单个项的最大大小为2 MB。
- en: There’s no limit on the distinct values of partition keys.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区键的不同值没有限制。
- en: We will use the game ID for the partition key. Games are created and updated
    independently of other games. It’s not necessary to write multiple games within
    one transaction. Running Azure Cosmos DB with a multi-region write configuration
    allows us to create games from different Azure regions with high performance.
    This makes the `Id` value of the game a good candidate for the partition key.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用游戏ID作为分区键。游戏是独立于其他游戏创建和更新的。没有必要在一个事务中写入多个游戏。使用具有多区域写入配置的Azure Cosmos DB可以让我们以高性能从不同的Azure区域创建游戏。这使得游戏的`Id`值成为分区键的好候选。
- en: With this information, we’ll create a class library next.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，我们将接下来创建一个类库。
- en: Creating a class library project for EF Core with NoSQL
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为EF Core创建一个NoSQL类库项目
- en: 'Similar to creating a library for SQL Server, we use a library to access Azure
    Cosmos DB:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建SQL Server库类似，我们使用库来访问Azure Cosmos DB：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This library makes use of the `Microsoft.EntityFrameworkCore.Cosmos` NuGet package
    – and of course, a reference to the `Codebreaker.GameAPIs.Models` project is needed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 该库使用了`Microsoft.EntityFrameworkCore.Cosmos` NuGet包——当然，还需要引用`Codebreaker.GameAPIs.Models`项目。
- en: Creating an EF Core context for Azure Cosmos DB
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Azure Cosmos DB创建一个EF Core上下文
- en: 'Let’s create a context class to access Azure Cosmos DB, as shown with the following
    code snippet:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个上下文类来访问Azure Cosmos DB，如下面的代码片段所示：
- en: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Similar to before, the custom context class derives from the `DbContext` base
    class and defines a constructor with context options, which allows us to configure
    the DI container with the connection string. The differences start now. With SQL
    Server, we defined the default schema name. This is not available with Azure Cosmos
    DB, but we can define the default container name using the `HasDefaultContainer`
    method. In case you have entities that should not be stored with the default container,
    these can be configured to use a different container with the help of the `ToContainer`
    method. The previously discussed partition key is configured by invoking the `HasPartitionKey`
    method. Using the `SetPartitionKey` and `ComputePartitionKey` methods, the partition
    key is configured as a **shadow property** with the same value as the game ID.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前类似，自定义上下文类从`DbContext`基类派生，并定义了一个带有上下文选项的构造函数，这允许我们使用连接字符串配置DI容器。差异从现在开始。在SQL
    Server中，我们定义了默认模式名称。在Azure Cosmos DB中，这不可用，但我们可以使用`HasDefaultContainer`方法定义默认容器名称。如果你有不应与默认容器一起存储的实体，可以使用`ToContainer`方法配置它们使用不同的容器。之前讨论的分区键通过调用`HasPartitionKey`方法进行配置。使用`SetPartitionKey`和`ComputePartitionKey`方法，分区键被配置为与游戏ID相同的**影子属性**。
- en: While `Id` is a good option for the partition key, other types that could be
    stored in the same container might not have an `Id` value. Thus, for the partition
    key, `PartitionKey` is used. With games, the `Id` value will be mapped to `PartitionKey`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Id`是分区键的好选择，但可能存储在相同容器中的其他类型可能没有`Id`值。因此，对于分区键，使用`PartitionKey`。对于游戏，`Id`值将被映射到`PartitionKey`。
- en: Writing different object types to a single container requires the use of a discriminator
    value. By default, the discriminator value is the name of the class. By invoking
    the `HasDiscriminator` method, the default discriminator configuration is overridden
    by specifying the `Discriminator` shadow property. For `Game` types, the `GameV3`
    value is written. This allows us to differentiate game objects stored with incompatible
    new versions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将不同类型的对象写入单个容器需要使用判别器值。默认情况下，判别器值是类的名称。通过调用 `HasDiscriminator` 方法，可以通过指定 `Discriminator`
    隐藏属性来覆盖默认的判别器配置。对于 `Game` 类型，写入 `GameV3` 值。这使我们能够区分存储不兼容新版本的游戏对象。
- en: Azure Cosmos DB stores JSON documents, thus only the `Game` type needs to be
    specified with a `DbSet` property, and not the `Move` type, as we did with SQL
    Server. Defining maximum sizes for string properties is not needed as well – there’s
    no schema describing this.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB 存储 JSON 文档，因此只需指定 `Game` 类型具有 `DbSet` 属性，而不是 `Move` 类型，就像我们在
    SQL Server 中做的那样。定义字符串属性的最大大小也不需要，因为没有模式描述这一点。
- en: Creating a value converter to convert complex types
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个转换复杂类型的值转换器
- en: 'In the SQL Server section, we converted the `Idictionary`-typed property, passing
    expressions to the `HasConversion` method to convert the dictionary to a string.
    The same could be done with Azure Cosmos DB, but now we’ll create a class deriving
    from `ValueConverter` and convert the dictionary to and from JSON, as shown in
    the following code snippet:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 部分，我们将 `Idictionary` 类型的属性转换为字符串，通过传递表达式到 `HasConversion` 方法将字典转换为字符串。对于
    Azure Cosmos DB 也可以这样做，但现在我们将创建一个从 `ValueConverter` 派生的类，并将字典转换为 JSON，如下代码片段所示：
- en: Codebreaker.Data.Cosmos/Utilities/FieldValueValueConverter.cs
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.Cosmos/Utilities/FieldValueValueConverter.cs
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: An EF Core value converter derives from the `ValueConverter` base class and
    specifies with the generic parameter what type to convert. With the `FieldValues`
    property, this is `IDictionary<string, IEnumerable<string>>`. The constructor
    of the base class requires parameters to convert to the database data type and
    to convert from the database data type. With the implementation, the `JsonSerializer`
    class from the `System.Text.Json` namespace is used to do the serialization and
    deserialization.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 值转换器从 `ValueConverter` 基类派生，并使用泛型参数指定要转换的类型。使用 `FieldValues` 属性，这是 `IDictionary<string,
    IEnumerable<string>>`。基类的构造函数需要参数来转换到数据库数据类型和从数据库数据类型转换。在实现中，使用 `System.Text.Json`
    命名空间中的 `JsonSerializer` 类来进行序列化和反序列化。
- en: 'An instance of this value converter is now passed to an overload of the `HasConversion`
    method with the `FieldValues` property configuration:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此值转换器的实例传递给具有 `FieldValues` 属性配置的 `HasConversion` 方法的重载：
- en: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Similar to `FieldValueValueConverter`, a `FieldValueComparer` instance is created.
    Instances of these two types are created to pass to the `HasConversion` method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `FieldValueValueConverter` 类似，创建了一个 `FieldValueComparer` 实例。创建了这两个类型的实例以传递给
    `HasConversion` 方法。
- en: When creating the mapping for a relational database, much more was needed to
    configure. We reduced the code from the data context by creating configuration
    classes with every mapped table. This is not worthwhile doing here. The complete
    EF Core configuration, as well as the implementation of the repository interface,
    is done with the context class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建关系型数据库的映射时，需要配置的内容更多。我们通过为每个映射的表创建配置类来减少数据上下文中的代码。在这里这样做不值得。完整的 EF Core 配置以及仓库接口的实现都是通过上下文类完成的。
- en: Creating embedded entities
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建嵌入式实体
- en: What about the relationship between games and moves? EF Core defines the `OwnsOne`
    and `OwnsMany` methods to define an owned relationship. With a relational database,
    `OwnsOne` adds columns of the owned type to the owner type. With the Azure Cosmos
    DB provider, invoking `OwnsMany` from `gameModel` and referencing the `Moves`
    property, moves will be stored as JSON within the game.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，游戏和移动之间的关系如何？EF Core 定义了 `OwnsOne` 和 `OwnsMany` 方法来定义一个拥有关系。在关系型数据库中，`OwnsOne`
    将拥有类型的列添加到拥有类型中。在 Azure Cosmos DB 提供程序中，从 `gameModel` 调用 `OwnsMany` 并引用 `Moves`
    属性，移动将被存储在游戏中的 JSON 内。
- en: Since EF Core 7, this is the default behavior with related entity types with
    the Azure Cosmos DB provider. So, nothing needs to be configured to make this
    happen.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 EF Core 7 开始，这是与 Azure Cosmos DB 提供程序相关的实体类型的默认行为。因此，无需配置即可实现此功能。
- en: Implementing the repository contract
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现仓库合约
- en: 'With the implementation of the repository, there are many similarities to the
    implementation with SQL Server, but because of the different storage, some changes
    are necessary. Here, we’ll concentrate on the differences:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现存储库时，与 SQL Server 的实现有许多相似之处，但由于存储方式不同，需要进行一些更改。在这里，我们将专注于差异：
- en: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When adding or updating the game, the partition key needs to be set. Other than
    that, the code is the same as with SQL Server.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加或更新游戏时，需要设置分区键。除此之外，代码与 SQL Server 相同。
- en: There’s a difference in what happens at runtime. Instead of using SQL `INSERT`
    and `UPDATE` statements, the Azure Cosmos DB provider executes `CreateItem` and
    `ReplaceItem` functions. When you check the log output, you can see the number
    of RUs required for every statement done.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时发生的情况有所不同。而不是使用 SQL `INSERT` 和 `UPDATE` 语句，Azure Cosmos DB 提供程序执行 `CreateItem`
    和 `ReplaceItem` 函数。当你检查日志输出时，你可以看到每个语句所需的 RUs 数量。
- en: 'The `GetGamesAsync` method defined previously also works with the Cosmos DB
    provider. This is the query created:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的 `GetGamesAsync` 方法也适用于 Cosmos DB 提供程序。这是创建的查询：
- en: '[PRE45]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Comparing this query to the query to the SQL Server database, with Cosmos DB,
    it’s a lot simpler: joining of tables is not required. An interesting part of
    this query is the filtering on `Discriminator`. By default, every object stored
    in a container has a `Discriminator` filter that includes the type name. This
    allows the storage of different documents in the container. Queries for a specific
    type include the `Discriminator` filter.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将此查询与查询 SQL Server 数据库的查询进行比较，使用 Cosmos DB，它要简单得多：不需要表连接。这个查询的一个有趣部分是对 `Discriminator`
    的过滤。默认情况下，存储在容器中的每个对象都有一个包含类型名称的 `Discriminator` 过滤器，这允许在容器中存储不同的文档。对特定类型的查询包括
    `Discriminator` 过滤器。
- en: In case you only store objects of the same type within one container, you can
    turn off storing with the `Discriminator` filter with the `HasNoDiscriminator`
    model definition method.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只在一个容器中存储同一类型的对象，你可以使用 `HasNoDiscriminator` 模型定义方法关闭带有 `Discriminator` 过滤器的存储。
- en: Be aware that not all LINQ queries translate successfully from the Cosmos DB
    provider. For example, `Include` and `Join` methods are not translated. While
    the `Include` method was used with SQL Server to include the moves with a query
    for a game, with a JSON document where the moves are stored within a game, this
    is not required. As there are no tables with NoSQL, `Join` is usually not required
    as well. In case you want to combine a list of different object types, create
    two queries and combine the results with the caller.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有 LINQ 查询都能成功从 Cosmos DB 提供程序转换。例如，`Include` 和 `Join` 方法无法转换。虽然 `Include`
    方法曾与 SQL Server 一起使用，用于包含游戏查询中的移动，但在存储在游戏中的 JSON 文档中，这并不是必需的。由于没有 NoSQL 的表，因此通常也不需要
    `Join`。如果你想要组合不同对象类型的列表，请创建两个查询并将结果与调用者合并。
- en: Configuring the application model with Azure Cosmos DB
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置应用程序模型以使用 Azure Cosmos DB
- en: With SQL Server, we’ve been using a Docker container for SQL Server. Using Azure
    Cosmos DB, a Docker container is available as well. However, with Cosmos DB, this
    is just an emulator and should not be used for production. In [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    we’ll use the database running with Microsoft Azure.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 中，我们一直使用 SQL Server 的 Docker 容器。使用 Azure Cosmos DB，也有可用的 Docker
    容器。然而，在 Cosmos DB 中，这只是一个模拟器，不应用于生产。在 [*第 5 章*](B21217_05.xhtml#_idTextAnchor110)
    中，我们将使用在 Microsoft Azure 上运行的数据库。
- en: 'To add Azure resources to the `AppHost` project, we need to add the `Aspire.Hosting.Azure`
    NuGet package. Let’s add Azure Cosmos DB to the Aspire `AppHost` application model:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Azure 资源添加到 `AppHost` 项目中，我们需要添加 `Aspire.Hosting.Azure` NuGet 包。让我们将 Azure
    Cosmos DB 添加到 Aspire `AppHost` 应用程序模型中：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE46]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Invoking the `AddAzureCosmosDB` method registers the Azure Cosmos DB resource.
    `codebreakercosmos` is the resource name, which needs to be lowercase and is used
    as the connection string to the Azure Cosmos DB account. Here, the name of the
    database is not part of the connection string. The database is specified by invoking
    the `AddDatabase` method and defines the name of the database. The `RunAsEmulator`
    method specifies a Docker image to run the database within a Docker container,
    but only within the development environment. Similar to before, the Cosmos DB
    resource is referenced from the games API project, which forwards the connection
    string with the `codebreakercosmos` key to this project. Be aware it’s not the
    name passed to `AddDatabase` (which was the case with SQL Server) because the
    database name is not part of the connection string.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`AddAzureCosmosDB`方法注册Azure Cosmos DB资源。`codebreakercosmos`是资源名称，需要小写，并用作连接Azure
    Cosmos DB账户的连接字符串。在这里，数据库名称不是连接字符串的一部分。数据库通过调用`AddDatabase`方法指定，并定义了数据库名称。`RunAsEmulator`方法指定一个Docker镜像，在Docker容器内运行数据库，但仅限于开发环境。与之前类似，Cosmos
    DB资源从游戏API项目引用，并将带有`codebreakercosmos`键的连接字符串转发到该项目。请注意，它不是传递给`AddDatabase`的名称（SQL
    Server的情况），因为数据库名称不是连接字符串的一部分。
- en: Configuring the DI container
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置DI容器
- en: 'To configure the DI container with the games API project, we have to add the
    `Aspire.Microsoft.EntityFrameworkCore.Cosmos` NuGet package to use this Aspire
    component. The configuration of the DI container was already prepared with the
    configuration of the relational database. All that’s needed now is to add the
    Cosmos DB EF Core context, as shown in the following code snippet:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置DI容器与游戏API项目，我们必须添加`Aspire.Microsoft.EntityFrameworkCore.Cosmos` NuGet包以使用此Aspire组件。DI容器的配置已经与关系型数据库的配置一起准备好了。现在所需做的就是添加Cosmos
    DB EF Core上下文，如下面的代码片段所示：
- en: Codebreaker.GameApis/ApplicationServices.cs
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameApis/ApplicationServices.cs
- en: '[PRE47]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The .NET Aspire Azure Cosmos DB EF Core component offers the `AddCosmosDbContext`
    method, but similar to before, because we need the registration of the `IGamesRepository`
    interface, we use the EF Core `AddDbContext` method and add the Aspire component
    features by invoking the `EnrichCosmosDbContext` method. The `UseCosmos` method
    registers to use the EF Core provider for Azure Cosmos DB and assigns the connection
    string that is passed from the application model definition.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Aspire Azure Cosmos DB EF Core组件提供了`AddCosmosDbContext`方法，但与之前类似，因为我们需要注册`IGamesRepository`接口，所以我们使用EF
    Core的`AddDbContext`方法，并通过调用`EnrichCosmosDbContext`方法添加Aspire组件的功能。`UseCosmos`方法注册使用EF
    Core提供程序来连接Azure Cosmos DB，并分配从应用程序模型定义传递的连接字符串。
- en: 'To create the database and the Cosmos DB container, we add the `else` part
    to the `CreateOrUpdateDatabaseAsync` method:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据库和Cosmos DB容器，我们在`CreateOrUpdateDatabaseAsync`方法中添加`else`部分：
- en: Codebreaker.GameApis/ApplicationServices.cs
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameApis/ApplicationServices.cs
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Database.EnsureCreatedAsync` method creates the database and the Azure
    Cosmos DB container with the partition key specified.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database.EnsureCreatedAsync`方法创建数据库和具有指定分区键的Azure Cosmos DB容器。'
- en: Having the configuration in place, let’s start the application as before with
    SQL Server and check the stored games with your Azure Cosmos DB database while
    you set moves. Just make sure that the `DataStore` configuration is set to the
    correct database type. Using the HTTP files, don’t forget to use the returned
    game ID that is returned after creating the game.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 配置就绪后，让我们像之前一样使用SQL Server启动应用程序，并在您设置移动时检查存储的游戏与您的Azure Cosmos DB数据库。只需确保`DataStore`配置设置为正确的数据库类型。使用HTTP文件时，不要忘记使用创建游戏后返回的游戏ID。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we changed to using persistent storage with the API service
    using a relational and a NoSQL database. We created the database context to map
    the `Game` and `Move` types to tables in a relational database and to a JSON document
    with a NoSQL database – both using EF Core.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们改用持久化存储，使用API服务结合关系型数据库和NoSQL数据库。我们创建了数据库上下文，将`Game`和`Move`类型映射到关系型数据库的表中，以及NoSQL数据库的JSON文档中——两者都使用EF
    Core。
- en: To select which database to use in your environment, if you have relational
    data with a fixed schema, select SQL Server. If the schema is not required in
    your scenario, and changes to the data happen often, a NoSQL database can be the
    best option.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择在您的环境中使用哪个数据库，如果您有具有固定模式的关系型数据，请选择SQL Server。如果您的场景中不需要模式，并且数据经常发生变化，NoSQL数据库可能是最佳选择。
- en: You learned about how to map objects and how to deal with special mapping requirements
    based on the object model. Using a relational database, you also learned how to
    create migrations to update the database schema and to initially create the database.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了如何映射对象以及如何根据对象模型处理特殊的映射要求。使用关系数据库，您还学习了如何创建迁移来更新数据库架构以及最初创建数据库。
- en: You learned how to use database resources with the .NET Aspire application model
    specified with the `AppHost` project.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了如何使用指定了`AppHost`项目的.NET Aspire应用程序模型来使用数据库资源。
- en: Before starting the next chapter, it’s well deserved to play another game round.
    Just use the HTTP files to make your game run. With the state of the current implementation,
    the game can continue to run after you restart the service – the games and moves
    are persisted.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下一章之前，玩另一轮游戏是当之无愧的。只需使用 HTTP 文件让您的游戏运行。根据当前实现的状态，在您重启服务后，游戏可以继续运行——游戏和移动是持久化的。
- en: In the next chapter, we create a library that can be used by client applications
    to invoke the web API so that it becomes more convenient to play the game.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们创建一个库，该库可以被客户端应用程序用来调用 Web API，从而使玩游戏变得更加方便。
- en: Further reading
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考以下链接：
- en: 'Value conversions: [https://learn.microsoft.com/ef/core/modeling/value-conversions](https://learn.microsoft.com/ef/core/modeling/value-conversions)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值转换：[https://learn.microsoft.com/ef/core/modeling/value-conversions](https://learn.microsoft.com/ef/core/modeling/value-conversions)
- en: 'Inheritance with EF Core: [https://learn.microsoft.com/ef/core/modeling/inheritance](https://learn.microsoft.com/ef/core/modeling/inheritance)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EF Core 进行继承：[https://learn.microsoft.com/ef/core/modeling/inheritance](https://learn.microsoft.com/ef/core/modeling/inheritance)
- en: 'Owned entity types: [https://learn.microsoft.com/ef/core/modeling/owned-entities](https://learn.microsoft.com/ef/core/modeling/owned-entities)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有实体类型：[https://learn.microsoft.com/ef/core/modeling/owned-entities](https://learn.microsoft.com/ef/core/modeling/owned-entities)
- en: 'Transactions: [https://learn.microsoft.com/ef/core/saving/transactions](https://learn.microsoft.com/ef/core/saving/transactions)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务：[https://learn.microsoft.com/ef/core/saving/transactions](https://learn.microsoft.com/ef/core/saving/transactions)
- en: 'Migrations: [https://learn.microsoft.com/ef/core/managing-schemas/migrations](https://learn.microsoft.com/ef/core/managing-schemas/migrations)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移：[https://learn.microsoft.com/ef/core/managing-schemas/migrations](https://learn.microsoft.com/ef/core/managing-schemas/migrations)
- en: 'Azure Cosmos DB intro: [https://learn.microsoft.com/azure/cosmos-db/introduction](https://learn.microsoft.com/azure/cosmos-db/introduction)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cosmos DB 简介：[https://learn.microsoft.com/azure/cosmos-db/introduction](https://learn.microsoft.com/azure/cosmos-db/introduction)
- en: 'Limitations with the EF Core Cosmos provider: [https://learn.microsoft.com/ef/core/providers/cosmos/limitations](https://learn.microsoft.com/ef/core/providers/cosmos/limitations)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EF Core Cosmos 提供程序的局限性：[https://learn.microsoft.com/ef/core/providers/cosmos/limitations](https://learn.microsoft.com/ef/core/providers/cosmos/limitations)
- en: '.NET Aspire SqlServer EF Core component: [https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component](https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Aspire SqlServer EF Core 组件：[https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component](https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component)
- en: '.NET Aspire Microsoft EF Core Cosmos DB component: [https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component](https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Aspire Microsoft EF Core Cosmos DB 组件：[https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component](https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component)
