- en: Adapting Systems with an Adapter
  prefs: []
  type: TYPE_NORMAL
- en: In a world full of different types of cables and plugs, we have all become accustomed
    to the concept of adapters. The Adapter pattern will be one of those patterns
    that will be easy for you to grasp because it correlates so perfectly with our
    real-world experiences with technology. The Adapter pattern's name perfectly reveals
    its core purpose; it offers us a way to seamlessly use old code with new code
    by adding an interface between the code that will act as an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The examples presented in this chapter are skeleton code. It's simplified for
    learning purposes so we can focus on the structure of the pattern. It might not
    be optimized or contextualized enough to be used as is in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub: [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14)
    [](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3wBHqkX](https://bit.ly/3wBHqkX)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name implies, the Adapter pattern adapts two incompatible interfaces;
    like a plug adapter, it doesn't modify what it adjusts but bridges one interface
    with another. This approach can be beneficial when dealing with legacy code that
    you cannot refactor due to its fragility, or when you need to add features to
    a third-party library but don't want to modify it to avoid issues when upgrading
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick breakdown of the two main approaches to implementing the Adapter
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object Adapter**: In this version, the pattern uses object composition, and
    the adapter acts as a wrapper around the adapted object. It''s helpful if we have
    a class that doesn''t have the methods we require, but we can''t modify it directly.
    The Object Adapter adopts the methods of the original class and adapts them to
    what we need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Adapter**: In this version of the pattern, the adapter uses inheritance
    to adapt the interface of an existing class to that of another. It''s useful when
    we need to adjust a class so it can work with others but can''t modify it directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our code example, we will use a permutation of the Class Adapter as it's
    more challenging to learn. If we understand the Class Adapter version, then we
    can extrapolate an understanding of the Object Adapter version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a side-by-side diagram of the Object and Class Adapters;
    the core differences are subtle, but the similarities are apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82dbcfc8-0321-4c29-90ec-32dbf28f35e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Diagram of a replay system
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in both cases, the **Adapter** class is positioned between the **Client** and
    the adapted entity (**Adaptee**). But the Class Adapter establishes a relationship
    with the Adaptee through inheritance. In contrast, the Object Adapter uses composition
    to wrap an instance of the Adaptee for adaption.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the entity that we are adapting is not modified. And the client
    is not aware of what we are adapting; it just knows that it has a consistent interface
    to communicate with the adapted object.
  prefs: []
  type: TYPE_NORMAL
- en: Composition and inheritance are ways to define relationships between objects;
    they describe how they relate to each other. And that difference in the relationship
    structure determines in part the difference between the Object and Class Adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to address is that the Adapter can sometimes be confused with
    the Facade pattern. We must understand that the core difference between them is
    that the Facade pattern establishes a simplified front-facing interface to a complex
    system. But the Adapter adapts incompatible systems while maintaining a consistent
    interface for a client.
  prefs: []
  type: TYPE_NORMAL
- en: Both patterns are related as they are both structural patterns but have entirely
    different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition** is one of the core concepts of **O****bject-Oriented Programming**
    (**OOP**); it refers to the concept of combining simple types to make more complex
    ones. For instance, a motorbike has wheels, an engine, and a handlebar. So composition
    establishes a "has a" relationship while inheritance sets an "is a" relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the benefits of the Adapter pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapting without modifying**: The main benefit of the Adapter pattern is
    that it offers a standard approach to adapting old or third-party code without
    modifying it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability and flexibility**: This pattern permits the continued use of
    legacy code on new systems with minimal changes; this has an immediate return
    on investment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some potential drawbacks of the Adapter pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persisting legacy**: The ability to use legacy code with new systems is cost-effective,
    but in the long term, it can become an issue, because the old code might limit
    your upgrade options as it becomes deprecated and incompatible with new versions of
    Unity or third-party libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slight overhead**: Because, in some instances, you are redirecting calls
    between objects, there might be a slight performance hit, usually too small to
    become an issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adapter is part of the structural pattern family, including the Facade,
    Bridge, Composite, Flyweight, and Decorator.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A potential use case for the Adapter in Unity is when you have a third-party
    library that you downloaded from the Unity Asset Store, and you need to modify
    some of its core classes and interfaces to add new features. But when changing
    third-party code, you risk having merge issues every time you pull an update from
    the library owners.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, you find yourself in a situation where you choose to wait for the third-party
    library owners to integrate the changes you need or modify their code and add
    the missing features. Both choices have their risks versus rewards. But the Adapter
    pattern gives us a solution to this dilemma by letting us place an adapter between
    existing classes so they can work together without modifying them directly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine we are working on the code base of a project that uses an inventory
    system package downloaded from the Unity Asset Store. The system is excellent;
    it saves the player's purchased or gifted inventory items to a secure cloud backend
    service. But there's one problem, it doesn't support local disk saves. This limitation
    has become an issue in our project because we need both local and cloud saves
    for redundancy purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we could easily modify the vendor's code and add the feature
    we need. But when they release their next update, we will have to merge our code
    with theirs. This approach can be an error-prone process. Instead, we will use
    the Adapter pattern and implement a wrapper that will maintain a consistent interface
    to the inventory system while adding local-save support. And in the process, we
    will not have to modify any of the existing classes. Thus, we will be able to
    avoid changing the vendor's code and still have your local save system handle
    the saving of inventory items.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement an example of this use case in the next section. But in conclusion,
    the Adapter pattern is handy in situations in which you have incompatible systems
    that need to interface with each other. Still, you want to avoid modifying any
    existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code example will be simple; we will not attempt to write an entire local
    disk save system because that's not the focus of this chapter. Instead, we will
    write the skeleton of the system to concentrate on the use of the Adapter pattern
    and not be impeded by unrelated implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, we will implement a placeholder class that will mock the third-party
    inventory system as presented in the scenario of the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InventorySystem` class provided by our fictional provider has three methods,
    `AddItem()`, `RemoveItem()`, and `GetInventory()`. All of these methods are hardcoded
    to use cloud storage and we can''t modify them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the class that will act as our adapter in this scenario. It adds
    the ability to save inventory items to a local disk. But it also exposes a new
    functionality that permits the merging and syncing of the player''s local and
    cloud inventories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that by inheriting the third party's `InventorySystem` class, we have
    access to all its properties and methods. Thus we can continue to use its core
    functionalities while adding our own. We are modifying nothing in the process,
    just adapting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to expose an interface to our new inventory system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The client who uses this interface is not aware that it's communicating with
    a system adapted from another. The Adaptee is also not aware that we are adapting
    it. Like a charger adapter, the phone and cable are unaware of which plug they
    are connected to, only that current is passing through the system and charging
    the battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our implementation, we need to add an `enum` that exposes the save
    locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And for our last step, we will implement a placeholder `InventoryItem` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Testing the Adapter pattern implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test our implementation in your instance of Unity, copy all the classes
    we just reviewed into your project and attach the following client class to an
    empty GameObject in a new Unity scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We now can build a new inventory system that uses the functionality of an older
    one provided by a third party. We can continue to pull library updates from the
    third-party website with confidence and without the need to worry about merge
    issues. Our system can grow in features while we continue to adapt theirs, and
    if one day we want to remove their system from our code base and just use our
    own, we could start the deprecation process by updating the `adapter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the Adapter pattern to our toolbox. It's a type of
    pattern that's very beneficial to have in our back pocket. One of the biggest
    challenges for a professional programmer is dealing with incompatible systems
    that are often developed by external vendors or other teams inside an organization.
    A consistent approach to adapting existing classes can only be helpful, especially
    when time becomes an issue and it's just faster to reuse old code for new purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review a close cousin of the Adapter, the Facade
    pattern, which we will use to manage the growing complexity in our code.
  prefs: []
  type: TYPE_NORMAL
