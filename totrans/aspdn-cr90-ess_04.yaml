- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Real-Time Interactions with SignalR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SignalR进行实时交互
- en: As part of ASP.NET Core 9, the web API is a framework for building HTTP services,
    which can be made available for both web page consumption and mobile applications.
    The structure provided by the .Net Core platform provides the development of APIs
    with high quality and performance. In this chapter, we will learn more about WebAPI,
    including the standards, conventions, and best practices for delivering solutions
    via a service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为ASP.NET Core 9的一部分，Web API是一个用于构建HTTP服务的框架，可以为网页消费和移动应用提供。.Net Core平台提供的结构为API的开发提供了高质量和性能。在本章中，我们将更多地了解WebAPI，包括通过服务提供解决方案的标准、约定和最佳实践。
- en: We will work on creating a real-time task management application where we will
    use various techniques available on the .NET platform and SignalR to learn about
    the concepts and implement an example of applications that use the Stream concept.
    We will also explore the premises for hosting SignalR applications on a server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将致力于创建一个实时任务管理应用，我们将使用.NET平台和SignalR提供的各种技术来了解概念，并实现使用流概念的示例应用程序。我们还将探讨在服务器上托管SignalR应用的前提条件。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is SignalR?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是SignalR？
- en: Understanding the concepts of server and clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务器和客户端的概念
- en: Working with streaming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与流式处理一起工作
- en: Hosting the ASP.NET Core SignalR applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管ASP.NET Core SignalR应用
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码示例可以在本书的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04)'
- en: What is SignalR?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是SignalR？
- en: 'As we learned in previous chapters, web-based applications have two parts:
    the client and the Server.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中学到的，基于Web的应用有两个部分：客户端和服务器。
- en: A **browser** generally represents the client, where the user interacts with
    the application. Applications have actions executed on a server to process information
    and return a response.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器**通常代表客户端，用户与应用程序进行交互。应用程序在服务器上执行操作以处理信息并返回响应。'
- en: This process is based on two phases, which are **request** and **response**
    . These phases happen in sequence. With each interaction between the client and
    the server, a new communication process is created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程基于两个阶段，即**请求**和**响应**。这两个阶段按顺序发生。每当客户端和服务器之间发生交互时，就会创建一个新的通信过程。
- en: Most web applications have these features that are sufficient for most business
    contexts. However, there are scenarios where there is a need for a **real-time
    communication model** , where the information processed by an application is constantly
    updated. This provides an immediate response to users, enriching usability and
    certain functional requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用都有这些功能，对于大多数商业环境来说已经足够。然而，在某些场景中，需要**实时通信模型**，其中应用程序处理的信息是不断更新的。这为用户提供即时响应，丰富了可用性和某些功能需求。
- en: A good example of real-time applications would be, for example, a map application
    where users have traffic information on a given route, and are notified about
    any aspects that affect navigation. Furthermore, other types of applications such
    as games, social networks, or even collaborative web text editors depend on constant
    updates to users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的实时应用的例子，比如，一个地图应用，用户可以在给定的路线上获得交通信息，并被告知任何影响导航的方面。此外，其他类型的应用，如游戏、社交网络，甚至是协作网络文本编辑器，都依赖于对用户的持续更新。
- en: To develop applications that contain real-time features, it would be necessary
    for the server and client to be able to communicate constantly on an active channel.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发包含实时功能的应用程序，服务器和客户端需要能够在活动通道上持续通信。
- en: The .NET platform has SignalR. This is a library that adds the ability to build
    real-time solutions in a simplified way, instantly allowing constant communication
    between client and server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: .NET平台有SignalR。这是一个库，它以简化的方式增加了构建实时解决方案的能力，立即允许客户端和服务器之间进行持续的通信。
- en: '![Figure 4.1 – SignalR components](img/B21788_04_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – SignalR组件](img/B21788_04_1.jpg)'
- en: Figure 4.1 – SignalR components
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – SignalR组件
- en: 'As you can see, *Figure 4* *.1* demonstrates most of the SignalR components
    that abstract the communication model between the client and the server. Communication
    between the client and the server occurs over an active connection, using a transport
    technique that transports JSON or binary messages. WebSockets is the standard
    communication technique used by SignalR. The other two options are used as fallback.
    In other words, if WebSockets is not supported, Server-sent events or long polling
    will be used immediately. The order of precedence for transport is the same as
    that established in the following list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，*图 4.1* 展示了 SignalR 的多数组件，这些组件抽象了客户端和服务器之间的通信模型。客户端和服务器之间的通信通过一个活跃的连接进行，使用传输技术传输
    JSON 或二进制消息。WebSockets 是 SignalR 使用的标准通信技术。其他两种选项作为后备使用。换句话说，如果 WebSockets 不受支持，将立即使用服务器发送事件或长轮询。传输的优先级顺序与以下列表中建立的顺序相同：
- en: '**WebSockets** : It provides the ability to establish a *full-duplex connection*
    , that is, allowing constant communication between client and server.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**WebSockets**：它提供了建立 *全双工连接* 的能力，即允许客户端和服务器之间进行持续的通信。'
- en: '**Server-sent events** : It establishes a *one-way connection* from the Server
    to the client. The client does not have the ability to send messages to the server
    over the same connection, requiring a separate HTTP request.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器发送事件**：它从服务器到客户端建立一个 *单向连接*。客户端没有能力通过相同的连接向服务器发送消息，需要单独的 HTTP 请求。'
- en: '**Long polling** : It is a more basic technique whereby the client sends a
    message to the server. Instead of sending an immediate message, the server then
    processes the information and only returns the response after finishing.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**长轮询**：这是一种更基本的技巧，客户端向服务器发送消息。服务器不会立即发送消息，而是处理信息，并在完成后才返回响应。'
- en: SignalR abstracts the choice of transport, making it possible to define the
    use of just WebSocket, if necessary.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 抽象了传输的选择，使得在必要时只使用 WebSocket 成为可能。
- en: The connection between the client and the server depends on an important component
    called the Hub. The Hub is a special object. It’s a part of the SignalR API that
    acts as a proxy, allowing server-client communication, where the server can execute
    functions or methods on the client, remotely, through the use of **RPC** ( **Remote**
    **Procedure Call** ).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的连接依赖于一个重要的组件，称为 Hub。Hub 是一个特殊对象。它是 SignalR API 的一部分，充当代理，允许服务器和客户端之间的通信，其中服务器可以通过使用
    **RPC**（**远程** **过程调用**）在客户端远程执行函数或方法。
- en: RPC
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: RPC
- en: RPC is a communication protocol that has existed since 1970 and serves as the
    basis for several innovations that currently exist, such as gRPC, a high-performance
    communication model developed by Google. You can find more information about RPC
    at [https://en.wikipedia.org/wiki/Remote_procedure_call](https://en.wikipedia.org/wiki/Remote_procedure_call)
    .
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是一种自 1970 年以来就存在的通信协议，它是目前存在的一些创新（如 Google 开发的高性能通信模型 gRPC）的基础。你可以在 [https://en.wikipedia.org/wiki/Remote_procedure_call](https://en.wikipedia.org/wiki/Remote_procedure_call)
    找到更多关于 RPC 的信息。
- en: SignalR abstracts all the complexity of connection and communication management,
    in addition to bringing other capabilities, such as sending notifications to all
    connected clients, specific clients, or a group of clients. Additionally, APIs
    can be used in conjunction with .NET applications, even console, Java, and JavaScript.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 抽象了连接和通信管理的所有复杂性，同时带来了其他功能，例如向所有已连接客户端、特定客户端或一组客户端发送通知。此外，API 可以与 .NET
    应用程序（包括控制台、Java 和 JavaScript）一起使用。
- en: It is possible, for example, to have a server that communicates with a console
    application developed on the .NET or even Java platform.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以有一个与在 .NET 或甚至 Java 平台上开发的控制台应用程序通信的服务器。
- en: It may seem complex at first, but as we learn about the main concepts and good
    practices, we will come to understand how powerful the SignalR library is. Let’s
    explore some concepts, patterns, and good practices that involve SignalR and how
    to develop a real-time application using this library.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能看起来很复杂，但当我们了解主要概念和良好实践时，我们将了解到 SignalR 库是多么强大。让我们探索一些涉及 SignalR 的概念、模式和良好实践，以及如何使用这个库开发实时应用。
- en: Understanding the concepts of Servers and Clients
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务器和客户端的概念
- en: As we learned earlier, SignalR is a powerful library that abstracts much of
    the complexity of creating real-time applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学，SignalR 是一个强大的库，它抽象了创建实时应用的大部分复杂性。
- en: However, it is important to know the concepts and standards related to using
    the SignalR library to benefit from its features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解与使用 SignalR 库相关的概念和标准对于充分利用其功能非常重要。
- en: As we know, web applications basically have two main components, the Client
    and the Server. Likewise, real-time applications using SignalR require both client
    and server components. We will learn how these components interact with each other
    through a task management application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Web 应用程序基本上有两个主要组件，客户端和服务器。同样，使用 SignalR 的实时应用程序也需要客户端和服务器组件。我们将通过任务管理应用程序了解这些组件如何相互交互。
- en: Working with a task management application
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务管理应用程序进行工作
- en: 'The task management application will be created using **Razor Pages** technology
    and have the following functionalities:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任务管理应用程序将使用 **Razor Pages** 技术创建，并具有以下功能：
- en: Implement concepts in real time
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时实现概念
- en: Create tasks
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务
- en: Complete tasks
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成任务
- en: View created tasks
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看创建的任务
- en: View completed tasks
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看已完成任务
- en: All functionalities will be resolved using Visual Studio Code. JavaScript will
    be used to work with the functionalities on the Client side and C# will be used
    on the Server side.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有功能都将使用 Visual Studio Code 解决。JavaScript 将用于在客户端处理功能，而 C# 将用于服务器端。
- en: 'We can see an outline of the main components used in the application in *Figure
    4* *.2* :'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图 4.2* 中看到应用程序中使用的主要组件的概述：
- en: '![Figure 4.2 – TaskManager application components](img/B21788_04_2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – TaskManager 应用程序组件](img/B21788_04_2.jpg)'
- en: Figure 4.2 – TaskManager application components
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – TaskManager 应用程序组件
- en: As we can see in *Figure 4* *.2* , we have some important components that will
    be used in the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 *图 4.2* 中所见，我们将使用一些重要的组件，这些组件将在应用程序中使用。
- en: 'The Client will be implemented using Razor Pages, which will aim to allow user
    interaction in relation to the application’s functionalities:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将使用 Razor Pages 实现，旨在允许用户与应用程序功能进行交互：
- en: The **index-page.js** file will be responsible for managing interactions between
    the server and the application’s main page.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**index-page.js** 文件将负责管理服务器与应用程序主页面之间的交互。'
- en: The **signalr.js** file is part of the SignalR JavaScript SDK.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**signalr.js** 文件是 SignalR JavaScript SDK 的一部分。'
- en: The server is the Razor Page application that will act as an orchestrator server.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器是作为协调服务器运行的 Razor Page 应用程序。
- en: The Hub implementation will be responsible for managing real-time communication
    between the server and the client.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hub 实现将负责管理服务器和客户端之间的实时通信。
- en: As we create the project, we will explain how each component works and implementation
    details. For now, let’s start with creating the project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目时，我们将解释每个组件的工作原理和实现细节。现在，让我们从创建项目开始。
- en: 'We will focus on the main activities for creating a task manager project. However,
    you can check the entire implementation of the solution in the book GitHub repository,
    mentioned in the *Technical requirements* section. Here are the steps we will
    be following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注创建任务管理器项目的关键活动。然而，您可以在书中提到的 GitHub 仓库中查看解决方案的完整实现，该仓库在 *技术要求* 部分中提及。以下是我们将遵循的步骤：
- en: 'To create the project, open the terminal in a directory of your choice and
    run the following command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建项目，请在您选择的目录中打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A new folder called **TaskManager** will be created containing the entire project
    structure. Access this page with the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个名为 **TaskManager** 的新文件夹，包含整个项目结构。使用以下命令访问此页面：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that the project has been created, we need to add the SignalR JavaScript
    SDK. It will not be necessary to add the SDK to the server, as it is automatically
    added when creating the project, as part of the . NET platform.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在项目已创建，我们需要添加 SignalR JavaScript SDK。不需要将 SDK 添加到服务器，因为它在创建项目时自动添加，作为 .NET
    平台的一部分。
- en: As we are using Razor Pages, we will have the client and server in the same
    project. However, we can create a **Single-Page Application** ( **SPA** ) solution
    and a WebAPI in Asp.NET Core 9 and perform the same procedures.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Razor Pages，客户端和服务器将位于同一项目中。然而，我们可以在 Asp.NET Core 9 中创建一个 **单页应用程序**
    ( **SPA** ) 解决方案和 WebAPI，并执行相同的步骤。
- en: We will continue with the Razor pages and go to the installation of the SignalR
    JavaScript SDK. We will use a tool called **LibMan** , which is a **Command Line
    Interface** ( **CLI** ) from Microsoft, responsible for managing client libraries.
    Its operation is similar to **Node Package** **Management** ( **NPM** ).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用Razor页面，并转到SignalR JavaScript SDK的安装。我们将使用一个名为**LibMan**的工具，它是来自Microsoft的**命令行界面**（**CLI**），负责管理客户端库。其操作类似于**Node
    Package Management**（**NPM**）。
- en: 'To use it, it is advisable to uninstall any previous version existing on your
    operating system. Therefore, we’ll follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它之前，建议卸载操作系统上存在的任何先前版本。因此，我们将遵循以下步骤：
- en: 'Run the following commands in sequence to install the tool:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按顺序运行以下命令来安装工具：
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will run the command to install the SignalR SDK. Run the following
    command and check in the application’s main directory:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行命令来安装SignalR SDK。运行以下命令并检查应用程序的主目录：
- en: '[PRE3]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding command avoided installing the **@microsoft/signalr@latest** library
    and then only added the necessary scripts to the application directories.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的命令避免了安装**@microsoft/signalr@latest**库，然后只向应用程序目录添加了必要的脚本。
- en: At this moment, the project is being created and prepared to receive implementations
    of real-time features. We must start by creating the Hub and configuring the application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，项目正在创建并准备接收实时功能的实现。我们必须首先创建中心节点（Hub）并配置应用程序。
- en: Creating the Hub
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建中心节点（Hub）
- en: The Hub is one of the most important components for implementing SignalR. It
    acts as a proxy that manages the connections of all clients to the server and
    allows both the client and the server to talk to each other to execute methods
    in real time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 中心节点（Hub）是实现SignalR最重要的组件之一。它充当一个代理，管理所有客户端与服务器之间的连接，并允许客户端和服务器相互通信以实时执行方法。
- en: 'For our **TaskManager** application, our first task will be to create a Hub
    and prepare it for communicating with clients. To do this, still in the terminal
    and the application directory, type the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的**TaskManager**应用程序，我们的第一个任务将是创建一个中心节点（Hub）并为其准备与客户端通信。为此，仍然在终端和应用程序目录中，输入以下命令：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will open an instance of VS Code in the application directory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在应用程序目录中打开一个VS Code实例。
- en: At the root of the project, create a folder called **Hubs** and then a file
    called **TaskManagerHub.cs** .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为**Hubs**的文件夹，然后创建一个名为**TaskManagerHub.cs**的文件。
- en: 'The project class will have two methods and will look like the code that follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 项目类将有两个方法，其代码如下：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first detail to note is inherited from the **Hub** class. The **Hub** class
    is a superclass that abstracts all connection management and interaction with
    clients, available through the **Microsoft.AspNetCore.SignalR** package. All custom
    **Hub** classes must inherit from this class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第一个细节是继承自**Hub**类。**Hub**类是一个超类，它抽象了所有连接管理和与客户端的交互，这些功能通过**Microsoft.AspNetCore.SignalR**包提供。所有自定义**Hub**类都必须从这个类继承。
- en: Next, we have the **CreateTask** and **CompleteTask** methods. These methods
    will be invoked through clients and at the same time will invoke methods on clients.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有**CreateTask**和**CompleteTask**方法。这些方法将通过客户端调用，并同时将在客户端上调用方法。
- en: 'The **CreateTask** method receives as a parameter a class called **TaskModel**
    . This class has been broken into the **Model/TaskModel.cs** directory:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateTask**方法接收一个名为**TaskModel**的类作为参数。此类已被拆分到**Model/TaskModel.cs**目录中：'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the **TaskModel** class only has a few basic properties such
    as **Id** , **Name** , and **IsCompleted** , which represent a task.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**TaskModel**类只有几个基本属性，如**Id**、**Name**和**IsCompleted**，它们代表一个任务。
- en: Communication between the client and the server is done through a transport
    strategy, as mentioned previously, and WebSockets will generally be used. The
    information transmitted is serialized in JSON or binary. However, binary data,
    commonly used for audio, images, and videos, is not supported. Only text data
    will be transmitted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的通信是通过传输策略完成的，如前所述，通常使用WebSockets。传输的信息以JSON或二进制格式序列化。然而，二进制数据，通常用于音频、图像和视频，不受支持。只传输文本数据。
- en: 'Now, let’s look at the complete implementation of the **CreateTask** method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看**CreateTask**方法的完整实现：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code performs two basic procedures:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行了两个基本步骤：
- en: '**Persist a task** : The **_taskRepository** property is an interface that
    abstracts communication with a persistence layer. For this persistence project,
    it is being done in memory and the complete code for this implementation can be
    found in the book’s GitHub repository (see the *Technical* *requirements* section).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化任务**：**_taskRepository**属性是一个抽象与持久化层通信的接口。对于这个持久化项目，它是在内存中完成的，并且这个实现的完整代码可以在书的GitHub仓库中找到（见*技术*
    *要求*部分）。'
- en: '**Notify customers** : The **Hub** base class has a **Client** property with
    some functionality. In the code example, a notification is being made to all potential
    clients connected to **Hub** . The **SendAsync** method has 10 overloads of different
    variations. However, for the preceding code, two main parameters are being used.
    The first parameter concerns the name of the client method that will process the
    Hub’s response, while the second parameter is the task object itself that will
    be sent to clients.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知客户**：**Hub**基类有一个**Client**属性，具有一些功能。在代码示例中，正在向所有连接到**Hub**的潜在客户端发送通知。**SendAsync**方法有10种不同变体的重载。然而，对于前面的代码，使用了两个主要参数。第一个参数涉及将处理Hub响应的客户端方法名称，而第二个参数是本身将被发送到客户端的任务对象。'
- en: Constants are best practices
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是最佳实践
- en: As we noted in the **SendAsync** method, the first parameter references a constant.
    This is good practice as it is necessary to know the name of the method that will
    process the communication made through the server. Since it’s a string, it’s easy
    to make mistakes. Use constants whenever necessary to center strings containing
    method names. This will facilitate maintenance and improvements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在**SendAsync**方法中提到的，第一个参数引用了一个常量。这是一个好习惯，因为需要知道将通过服务器进行的通信处理的方法名称。由于它是一个字符串，很容易出错。在必要时使用常量来集中包含方法名称的字符串。这将有助于维护和改进。
- en: With the Hub implemented, it will now be necessary to configure the application
    to handle communication through SignalR.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Hub的部署完成，现在需要配置应用程序以通过SignalR处理通信。
- en: Preparing the server application
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备服务器应用程序
- en: The application needs to be configured to be able to handle connectivity between
    the client and the server. Without this step, the Hub will have no use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要配置以能够处理客户端和服务器之间的连接性。没有这一步，Hub将没有用处。
- en: To do this, we will need to change the code in the **Program.cs** file and add
    some important lines of code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要更改**Program.cs**文件中的代码并添加一些重要的代码行。
- en: We must configure the SignalR services in the application container and map
    the Hub endpoint that will be used by the client to establish the connection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在应用程序容器中配置SignalR服务并映射客户端将用于建立连接的Hub端点。
- en: 'At the end of the changes, the file should be similar to the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改完成后，文件应类似于以下代码：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is very important to follow the order in which the settings were made. The
    **builder.Services.AddSignalR()** method was added before the **var app = builder.Build()**
    line. Likewise, the Hub route mapping is added right after the **app.MapRazorPages()**
    statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要遵循设置顺序。在**builder.Services.AddSignalR()**方法被添加到**var app = builder.Build()**行之前。同样，Hub路由映射是在**app.MapRazorPages()**语句之后添加的。
- en: It is important to note the mapping of the Hub route, configured as **/taskmanagerhub**
    . The Hub route definition follows the same REST API pattern and this same route
    will be used so that client applications are able to establish connections with
    the server. The client will use the previously installed SignalR JavaScript SDK
    to connect to the Hub.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Hub路由的映射，配置为**/taskmanagerhub**。Hub路由定义遵循相同的REST API模式，并且将使用此相同的路由，以便客户端应用程序能够与服务器建立连接。客户端将使用之前安装的SignalR
    JavaScript SDK连接到Hub。
- en: The Hub is configured and ready to receive connections. Now, it’s time to configure
    the client.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Hub已配置并准备好接收连接。现在，是时候配置客户端了。
- en: Preparing the client application
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备客户端应用程序
- en: With the Hub configured, we must add the necessary features to the client application.
    To do this, we will use the **Pages/index.cshtml** page and create the JavaScript
    that will orchestrate all interactions between the client and the server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好Hub后，我们必须向客户端应用程序添加必要的功能。为此，我们将使用**Pages/index.cshtml**页面并创建JavaScript代码，该代码将协调客户端和服务器之间的所有交互。
- en: 'Change the entire contents of the **Index.cshtml** page to the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Index.cshtml**页面的全部内容更改为以下代码：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The HTML available is quite simple, just adding a form containing a field to
    name the task and a button that will be responsible for sending the new task to
    the server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的 HTML 代码相当简单，只需添加一个包含一个用于命名任务的字段和一个负责将新任务发送到服务器的按钮的表单。
- en: Additionally, there are two lists (completed tasks and uncompleted tasks) that
    will be displayed according to user interaction. We are not using any Razor Pages
    directives in the HTML elements, so it will not be necessary to make any changes
    to the **Index.cshtml.cs** file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个列表（已完成任务和未完成任务）将根据用户交互显示。我们没有在 HTML 元素中使用任何 Razor Pages 指令，因此不需要对 **Index.cshtml.cs**
    文件进行任何更改。
- en: It is important to note that to facilitate the understanding of the concepts
    of client and server, together with SignalR, we are using a Razor Pages application.
    However, it is possible to benefit from another approach called SPA, which makes
    it possible to use Frameworks such as Angular, React, or VueJS to create applications
    in JavaScript and HTML that run on the client and interact with the server.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，为了便于理解客户端、服务器以及 SignalR 的概念，我们正在使用一个 Razor Pages 应用程序。然而，可以采用另一种称为 SPA
    的方法，这使得可以使用 Angular、React 或 VueJS 等框架在 JavaScript 和 HTML 中创建应用程序，这些应用程序在客户端运行并与服务器交互。
- en: SPA
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SPA
- en: The **TaskManager** application uses Razor Pages to facilitate the explanation
    of SignalR concepts, concentrating the client and server in the same project.
    However, SignalR can be installed in a separate application that uses pure JavaScript,
    typescript, or any framework such as Angular, Vue.js, and so on. Furthermore,
    the SPA concept is a great practice for developing real-time functionalities.
    Otherwise, if there are several pages being loaded by the browser, with each new
    request, a new connection with the server is established. SPA makes it possible
    to render application pages dynamically while maintaining the same connection
    when using SignalR.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**TaskManager** 应用程序使用 Razor Pages 来简化 SignalR 概念的解释，将客户端和服务器集中在同一个项目中。然而，SignalR
    可以安装在一个单独的应用程序中，该应用程序使用纯 JavaScript、TypeScript 或任何框架，例如 Angular、Vue.js 等。此外，SPA
    概念是开发实时功能的一个很好的实践。否则，如果浏览器正在加载多个页面，每次新的请求都会与服务器建立一个新的连接。SPA 使得在使用 SignalR 时，可以在保持相同连接的同时动态渲染应用程序页面。'
- en: Note that the HTML code uses a **@section Scripts {}** directive, where the
    previously installed SignalR libraries and the JavaScript file that we will create
    are added. This section was defined in the **Pages/Shared/_Layout.cshtml** file,
    as we learned in [*Chapter 2*](B21788_02.xhtml#_idTextAnchor031) .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，HTML 代码使用了一个 **@section Scripts {}** 指令，其中添加了之前安装的 SignalR 库和我们将创建的 JavaScript
    文件。这个部分是在 **Pages/Shared/_Layout.cshtml** 文件中定义的，正如我们在 [*第 2 章*](B21788_02.xhtml#_idTextAnchor031)
    中所学的。
- en: Create an **index-page.js** file in the **wwwroot/js/index** directory. The
    entire content of this file is available in the application’s source code in the
    book’s repository.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **wwwroot/js/index** 目录中创建一个 **index-page.js** 文件。该文件的全部内容可在本书的代码库中的应用程序源代码中找到。
- en: 'Let’s focus on the most important points for establishing a connection with
    the Hub. To do this, we will basically need three main steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注建立与 Hub 连接的最重要几点。为此，我们基本上需要三个主要步骤：
- en: Create a connection object.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个连接对象。
- en: Map the events.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射事件。
- en: Start the connection.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动连接。
- en: 'These three steps are defined in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个步骤在以下代码中定义：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first line, we have the creation of the connection object using a SignalR
    object. Note that the **withUrl(HUB_URL)** method uses a constant that must contain
    the value of the Hub URL. As we are using Razor Pages, the client and server will
    be available through the same address, and in this case, we can enter a relative
    URL such as **/taskmanagerhub** . This URL is exactly the endpoint that was previously
    mapped on the server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们使用 SignalR 对象创建了一个连接对象。请注意，**withUrl(HUB_URL)** 方法使用一个必须包含 Hub URL 值的常量。由于我们使用
    Razor Pages，客户端和服务器将通过相同的地址可用，在这种情况下，我们可以输入一个相对 URL，例如 **/taskmanagerhub**。这个
    URL 正是之前在服务器上映射的端点。
- en: 'Next, we have the event implementation that will process the return from the
    server. In this case, we use the **on** method of the connection object. This
    method receives two parameters, the first being a string that represents the event.
    In this case, the **NotifyTaskManager** value was set to a constant. The **updateTaskList**
    method will process the return. We can use an inline function. However, to facilitate
    maintenance, we create a separate function that has the following signature:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有事件实现，它将处理来自服务器的返回。在这种情况下，我们使用连接对象的**on**方法。此方法接收两个参数，第一个是一个表示事件的字符串。在这种情况下，**NotifyTaskManager**值被设置为常量。**updateTaskList**方法将处理返回。我们可以使用内联函数。然而，为了便于维护，我们创建了一个具有以下签名的单独函数：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function could have any name and different types of parameters. However,
    the methods available in the Hub are sending the client a **TaskModel** object
    as a parameter. This object will be serialized in JSON or binary and SignalR will
    add it to the event corresponding to the processing of this return.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以具有任何名称和不同类型的参数。然而，Hub中可用的方法会将一个**TaskModel**对象作为参数发送给客户端。此对象将被序列化为JSON或二进制格式，SignalR会将它添加到对应于处理此返回的事件中。
- en: The **updateTaskList** function just gets the returned object and dynamically
    feeds the completed or incomplete task lists into the HTML using JavaScript.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**updateTaskList**函数只是获取返回的对象，并使用JavaScript动态地将完成的或未完成的任务列表馈入HTML。'
- en: Best practice
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: It is good practice to use objects as method parameters, both on the client
    and on the server. This prevents us from having to change method signatures in
    applications if output and input parameters are modified. The use of objects simplifies
    information traffic between the client and server.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器上使用对象作为方法参数是一种良好的实践。这防止了在输出和输入参数修改时需要更改应用程序中的方法签名。使用对象简化了客户端和服务器之间的信息流量。
- en: It is important to note that the name of the event must be the same both on
    the client and on the server, hence the use of constants to facilitate maintenance
    and writing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，事件名称在客户端和服务器上必须相同，因此使用常量来便于维护和编写。
- en: The third step is to start the connection through the **Start** method of the
    connection object. The **Start** method delivers a promise that is triggered after
    the connection is established. Additionally, it is possible to implement the **catch**
    method, for mapping and any possible error when trying to connect with the Hub.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是通过连接对象的**Start**方法启动连接。**Start**方法传递一个在连接建立后触发的承诺。此外，还可以实现**catch**方法，用于映射以及在尝试与Hub连接时可能出现的任何错误。
- en: 'Now it’s time to add the **click** event to the **Add Task** button, which
    will be responsible for requesting the addition of a new task, according to the
    code that follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给**添加任务**按钮添加**点击**事件了，该事件将负责根据以下代码请求添加新任务：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code requests the server through the **connection.Invoke()** function,
    having the name of the method available in the Hub and a **TaskModel** object
    with the name defined through user input as parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码通过**connection.Invoke()**函数请求服务器，该函数具有在Hub中可用的方法名称，以及一个通过用户输入定义名称的**TaskModel**对象作为参数。
- en: We currently have all the necessary requirements for the **TaskManager** application
    to have real-time functionality. Although it may seem complex, the approach is
    simple, requiring the client to be aware of the methods available on the server
    and the server to be aware of the events that can be executed on the client.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前拥有**TaskManager**应用程序实现实时功能所需的所有必要要求。尽管这可能看起来很复杂，但方法很简单，需要客户端了解服务器上的方法，以及服务器了解客户端上可以执行的事件。
- en: Let’s analyze the application execution flow in more detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分析应用程序执行流程。
- en: Understanding the client and server communication flow
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解客户端和服务器通信流程
- en: 'With the Hub and client properly configured, it’s time to understand how the
    communication flow will work. The flow for creating a task is represented according
    to *Figure 4* *.3* :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确配置了Hub和客户端之后，现在是时候了解通信流程将如何工作了。创建任务的流程根据*图4* *.3* 表示：
- en: '![Figure 4.3 – Communication between the Client and Server using SignalR](img/B21788_04_3.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 使用SignalR在客户端和服务器之间进行通信](img/B21788_04_3.jpg)'
- en: Figure 4.3 – Communication between the Client and Server using SignalR
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 使用SignalR在客户端和服务器之间进行通信
- en: 'The steps shown in *Figure 4* *.3* simply illustrate the entire communication
    flow of the application. Let’s understand each of these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4* *.3* 中所示的步骤简单地说明了整个应用程序的通信流程。让我们了解每个步骤：'
- en: After entering the task name, the user clicks the **Add Task** button. The button’s
    click event requests the **CreateTask** method, available on the server, through
    the Hub, passing a **TaskModel** object with the **Name** property defined as
    a parameter. The invocation of the server-side method is done through the connection
    that was previously made to the Hub.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入任务名称后，用户点击**添加任务**按钮。按钮的点击事件通过 Hub 请求服务器上的**CreateTask**方法，通过连接传递一个**TaskModel**对象，其中**Name**属性被定义为参数。对服务器端方法的调用是通过之前与
    Hub 建立的连接完成的。
- en: Upon receiving a request for the **CreateTask** method, the Hub then processes
    the task, adding it to a list in memory through the **Save** method, which adds
    values to the **Id** and **IsCompleted** properties.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到对**CreateTask**方法的请求后，Hub 然后处理任务，通过**Save**方法将其添加到内存中的列表中，该方法向**Id**和**IsCompleted**属性添加值。
- en: Then, the Hub invokes the **NotifyTaskManager** method on the client, passing
    it as a parameter from the created **TaskModel** object.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Hub 在客户端上调用**NotifyTaskManager**方法，并将创建的**TaskModel**对象作为参数传递。
- en: The client executes the method responsible for processing the server notification.
    This method was implemented in the SignalR connection object and updates the application
    screen, displaying the list of created tasks and the list of completed tasks.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端执行处理服务器通知的方法。此方法在 SignalR 连接对象中实现，并更新应用程序屏幕，显示已创建的任务列表和已完成任务的列表。
- en: In this section, we learned the main concepts of SignalR for implementing real-time
    communication between client and server. These concepts can be used in different
    types of applications, such as chat apps, order status updates in an online store,
    and so on. However, there are cases wherein we must work with a constant data-sending
    model between the client and server and this depends on another synchronization
    model that can be implemented with SignalR through the use of streaming. This
    concept is widely used in dashboards and applications such as news feeds. In the
    next section, we will understand how streaming works.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 SignalR 的主要概念，用于在客户端和服务器之间实现实时通信。这些概念可用于不同类型的应用程序，例如聊天应用、在线商店中的订单状态更新等。然而，在某些情况下，我们必须在客户端和服务器之间使用恒定的数据发送模型，这取决于另一个可以通过使用流式传输实现的同步模型。这个概念在仪表板和新闻源等应用程序中广泛使用。在下一节中，我们将了解流式传输是如何工作的。
- en: Working with streaming
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与流式传输一起工作
- en: In the context of SignalR, streaming is a powerful way of sending data from
    the server to the client and vice versa, in a continuous stream. Unlike traditional
    request/response models, where data is sent in a single batch, streaming allows
    for a constant flow of data, which is particularly useful for scenarios involving
    real-time updates, such as live feeds, dashboards, or even chat apps.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SignalR 的上下文中，流式传输是一种强大的方式，可以从服务器向客户端发送数据，反之亦然，以连续流的形式。与传统请求/响应模型不同，其中数据以单个批次发送，流式传输允许数据持续流动，这对于涉及实时更新的场景特别有用，例如实时流、仪表板或甚至聊天应用。
- en: Streaming on SignalR is characterized by several important features that make
    it an exceptional choice for real-time applications. Through a continuous flow,
    data is sent as soon as it becomes available, which is crucial to creating a real-time
    user experience. This means users receive updates immediately, keeping them constantly
    informed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 的流式传输具有几个重要特性，使其成为实时应用的卓越选择。通过持续流动，数据一旦可用就立即发送，这对于创建实时用户体验至关重要。这意味着用户会立即收到更新，保持他们持续了解情况。
- en: Next, streaming operations in SignalR are inherently asynchronous, ensuring
    that the application remains responsive even when dealing with multiple streaming
    operations or large volumes of data. Lastly, SignalR supports bidirectional streaming,
    allowing not only server-to-client but also client-to-server data flows.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，SignalR 中的流式传输操作本质上是异步的，确保即使在处理多个流式传输操作或大量数据时，应用程序也能保持响应。最后，SignalR 支持双向流式传输，不仅允许服务器到客户端的数据流，还允许客户端到服务器的数据流。
- en: This flexibility opens up a wide range of possibilities for interactive applications
    where both the server and clients can initiate and participate in data exchanges,
    further enhancing the dynamic, real-time capabilities of applications built with
    SignalR.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性为交互式应用程序开辟了广泛的可能性，其中服务器和客户端都可以发起并参与数据交换，进一步增强了使用SignalR构建的应用程序的动态、实时能力。
- en: 'The streaming strategy is a powerful solution. However, it is important to
    keep some limitations and challenges in mind:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 流式策略是一个强大的解决方案。然而，重要的是要记住一些限制和挑战：
- en: '**Network dependency and stability** : One of the main limitations of streaming
    on SignalR is its dependence on network quality. Since streaming involves a continuous
    flow of data, a stable and reliable network connection is crucial. Instabilities
    can cause a loss of connection, compromising the user experience.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络依赖性和稳定性**：SignalR上流式处理的主要限制之一是其对网络质量的依赖。由于流式处理涉及数据的持续流动，一个稳定且可靠的网络连接至关重要。不稳定性可能导致连接丢失，损害用户体验。'
- en: '**Resource intensity** : Streaming can be more resource-intensive than traditional
    request/response interactions. Since the server must maintain an open connection
    and continually process and send data, this can increase CPU and memory usage.
    In high-volume scenarios or with a large number of connected clients, this can
    become a significant challenge for resource management and expansion strategies.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源密集度**：流式处理可能比传统的请求/响应交互更资源密集。由于服务器必须保持一个开放的连接并持续处理和发送数据，这可能会增加CPU和内存的使用。在高流量场景或连接大量客户端的情况下，这可能会成为资源管理和扩展策略的一个重大挑战。'
- en: '**Complexity in implementation and maintenance** : Implementing streaming logic
    is generally more complex than dealing with standard request/response models due
    to the need to manage continuous connections and deal with asynchronous data streams.
    Additionally, it is challenging to debug streaming applications, especially when
    it comes to ensuring data integrity and dealing with network issues.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现和维护的复杂性**：由于需要管理持续连接和处理异步数据流，实现流式逻辑通常比处理标准请求/响应模型更复杂。此外，调试流式应用程序尤其具有挑战性，尤其是在确保数据完整性和处理网络问题时。'
- en: '**Scalability challenges** : Scaling real-time streaming applications can be
    challenging as the number of concurrent users increases and the load on the server
    can increase quickly.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性挑战**：随着并发用户数量的增加和服务器负载的快速增加，实时流式应用程序的可扩展性可能是一个挑战。'
- en: '**Limited browser support and compatibility issues** : Although modern browsers
    generally support the technologies underlying SignalR, there may still be compatibility
    issues, especially with older browsers.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的浏览器支持和兼容性问题**：尽管现代浏览器通常支持SignalR背后的技术，但仍可能存在兼容性问题，尤其是在较旧的浏览器中。'
- en: '**Security considerations** : With open and continuous connections, streaming
    applications may have different security considerations compared to traditional
    web applications.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全考虑**：与开放的持续连接相比，流式应用程序可能需要考虑不同的安全问题，与传统的Web应用程序相比。'
- en: Understanding these limitations provides better strategy definition and application
    design to take advantage of the best benefits available in SignalR.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些限制有助于更好地定义和应用设计策略，以充分利用SignalR中可用的最佳功能。
- en: Implementing basic streaming
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基本流式处理
- en: We already understand the most important concepts of SignalR, such as how the
    Hub and the communication between the client and the server work. However, it
    is important to implement a simple application example to understand the streaming
    approach.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了SignalR最重要的概念，例如Hub以及客户端和服务器之间通信的工作方式。然而，实现一个简单的应用程序示例来理解流式方法是很重要的。
- en: 'There’s nothing better than making an application to capture the concepts we’re
    learning. Therefore, follow these steps to implement an application that uses
    streaming:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比创建一个应用程序来捕捉我们正在学习的概念更好的了。因此，按照以下步骤实现一个使用流式处理的应用程序：
- en: 'Access your operating system’s terminal navigate to a directory of your choice
    and create a folder with the following instructions:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问您的操作系统终端，导航到您选择的目录，并按照以下说明创建一个文件夹：
- en: '[PRE13]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, follow these steps to create the application:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤创建应用程序：
- en: 'Run the following command to create the project:'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建项目：
- en: '[PRE14]'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, access the created application directory and open Visual Studio code:'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，访问创建的应用程序目录并打开Visual Studio代码：
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the same way as we did in the **TaskManager** project, the first task will
    be to create a Hub. Create a new folder called **Hubs** and then a class called
    **StreamHub.cs** :'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们在 **TaskManager** 项目中做的一样，第一个任务将是创建一个 Hub。创建一个名为 **Hubs** 的新文件夹，然后创建一个名为
    **StreamHub.cs** 的类：
- en: '[PRE16]'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code has a **Countdown** method that returns a stream of integers counting
    down from a specified number.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码有一个返回从指定数字开始倒计时整数的 **Countdown** 方法。
- en: 'Now let’s change the **Program.cs** file by adding SignalR functionalities
    in the same way as we did in the **TaskManager** project. The class should look
    like the following code:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过在 **Program.cs** 文件中添加与 **TaskManager** 项目中相同的方式的 SignalR 功能来更改该文件。类应如下所示：
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the signalR client library using the **libman** application:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **libman** 应用程序添加 signalR 客户端库：
- en: '[PRE18]'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we need to create a script to establish the connection to the Hub. To do
    this, create a file called **index-stream.js** in the **wwwroo/js** directory.
    This file must contain the following code:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个脚本来建立与 Hub 的连接。为此，在 **wwwroo/js** 目录下创建一个名为 **index-stream.js** 的文件。此文件必须包含以下代码：
- en: '[PRE19]'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code aims to connect the client application to the server, using
    the same approach learned in the previous session. In this example, first, there
    is the connection to the Hub. This is accomplished by creating the connection
    using the new **SignalR.HubConnectionBuilder()** line of code.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码旨在使用在上一节课中学到的相同方法将客户端应用程序连接到服务器。在这个例子中，首先，有到 Hub 的连接。这是通过使用新的 **SignalR.HubConnectionBuilder()**
    代码行创建连接来实现的。
- en: Then, when starting the connection, the streaming approach is used, initiated
    by the **connection.stream(..)** method. The **stream** method depends on two
    arguments, the first being the name of the method that will be requested on the
    server, called **Countdown** , previously created in the **StreamHub.cs** file.
    The second parameter is an integer value, where the countdown implemented in the
    server’s **Countdown** method will start. It is important to note that the number
    of parameters required by the stream method, in addition to the name of the function
    defined as a string, will vary according to the number of parameters implemented
    on the server.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在启动连接时，使用 **connection.stream(..)** 方法启动流式传输方法。该 **stream** 方法依赖于两个参数，第一个是将在服务器上请求的方法的名称，称为
    **Countdown**，之前在 **StreamHub.cs** 文件中创建。第二个参数是一个整数值，其中服务器上实现的 **Countdown** 方法将从该值开始倒计时。需要注意的是，流方法所需的参数数量，除了作为字符串定义的函数名称外，还将根据服务器上实现的参数数量而变化。
- en: 'The stream method has a nested method called **subscribe** , which has an implementation
    to obtain responses from the server. The **subscribe** method has an object that
    contains three main callback methods: **next** , **complete** , and **error**
    . Each of these events is executed at a certain point in the streaming. The **next**
    method is used for the response sent from the server. The **complete** method
    is used when the streaming flow is finished and the error method is used if an
    error occurs. All three subscribe methods use a **logStream** javascript function
    implemented in the **index-stream.js** file that adds a list element to the HTML
    containing the response to events.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 流方法有一个嵌套方法称为 **subscribe**，它有一个从服务器获取响应的实现。该 **subscribe** 方法有一个包含三个主要回调方法的对象：**next**、**complete**
    和 **error**。在流式传输的某个点上执行每个这些事件。**next** 方法用于从服务器发送的响应。**complete** 方法用于流式传输流程完成时。如果发生错误，则使用
    **error** 方法。所有三个 **subscribe** 方法都使用在 **index-stream.js** 文件中实现的 **logStream**
    JavaScript 函数，该函数将响应事件添加到包含 HTML 中的列表元素。
- en: 'Next, we need to change the **Pages/Index.cshtml** file to the following code:'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 **Pages/Index.cshtml** 文件更改为以下代码：
- en: '[PRE20]'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, just run the application using the following command:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需使用以下命令运行应用程序：
- en: '[PRE21]'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Figure 4.4 – SignalR streaming app](img/B21788_04_4.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – SignalR 流式应用程序](img/B21788_04_4.jpg)'
- en: Figure 4.4 – SignalR streaming app
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – SignalR 流式应用程序
- en: As seen in *Figure 4* *.4* , we have a countdown starting from the number **10**
    and, at the end, there is a **Stream Completed** message, which determines the
    end of the streaming. In this example, the **next** and **complete** events from
    the **subscribe** method were used. This way, we can work with constant interaction
    between the client and the server using streaming, bringing greater power to our
    applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 4* *.4* 所示，我们从数字**10**开始倒计时，最后有一个**流完成**的消息，这决定了流传输的结束。在这个例子中，使用了**订阅**方法的**next**和**complete**事件。这样，我们可以通过流式传输在客户端和服务器之间进行持续交互，从而为我们的应用程序带来更大的力量。
- en: The application is very simple and basically generates a list of numbers obtained
    through the connection to the Hub, with a small delay to simulate latency.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序非常简单，基本上生成一个通过连接到 Hub 获得的数字列表，并带有小延迟来模拟延迟。
- en: The stream approach is very interesting for transporting small blocks of information
    and allowing active processing in parts, ensuring a better user experience.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 流式传输方法对于传输小块信息并允许部分主动处理，从而确保更好的用户体验，是非常有趣的。
- en: We already understand the main features available in SignalR, but now let’s
    learn what is needed to host applications on a server.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 SignalR 中可用的主要功能，但现在让我们学习在服务器上托管应用程序所需的内容。
- en: Hosting the ASP.NET Core SignalR application
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管 ASP.NET Core SignalR 应用程序
- en: Like any web-based application, we must make them available through a server
    after the development stage. Applications developed in ASP.NET Core SignalR have
    the same characteristics and with all the power of the .NET platform, there is
    the possibility of hosting on internal servers and different cloud providers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何基于网络的程序一样，在开发阶段之后，我们必须通过服务器使它们可用。在 ASP.NET Core SignalR 中开发的应用程序具有相同的特性和
    .NET 平台的所有功能，因此可以在内部服务器和不同的云提供商上进行托管。
- en: We will discuss more about hosting applications in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162)
    . For now, we will just learn what is necessary to generate a hostable package
    for a SignalR application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 10 章*](B21788_10.xhtml#_idTextAnchor162)中讨论更多关于托管应用程序的内容。现在，我们将仅学习生成
    SignalR 应用程序可托管包所需的内容。
- en: The basics of hosting a SignalR application
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主持 SignalR 应用程序的基本知识
- en: Hosting an ASP.NET Core SignalR application isn’t drastically different from
    hosting a regular ASP.NET Core web app. However, due to the real-time nature of
    SignalR, there are specific considerations to keep in mind.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 托管 ASP.NET Core SignalR 应用程序与托管常规 ASP.NET Core 网络应用程序并没有太大不同。然而，由于 SignalR 的实时特性，有一些特定的考虑因素需要记住。
- en: 'It is important to define what the hosting model will be. In general, currently
    public clouds are selected, such as Azure, AWS, or GCP (Google). However, let’s
    understand each type of hosting available for ASP.NET Core 9 applications:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 定义托管模型是什么很重要。一般来说，目前选择的是公共云，例如 Azure、AWS 或 GCP（谷歌）。然而，让我们了解为 ASP.NET Core 9
    应用程序可用的每种托管类型：
- en: '**Traditional hosting (IIS, Nginx, and Apache)** : These are standard web servers
    that can also serve SignalR applications. They mainly act as reverse proxies,
    forwarding client requests to the SignalR application.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统托管（IIS、Nginx 和 Apache）**：这些是标准的网络服务器，也可以托管 SignalR 应用程序。它们主要充当反向代理，将客户端请求转发到
    SignalR 应用程序。'
- en: '**Cloud hosting** : Cloud platforms offer robust and scalable hosting environments.
    **Azure App Service** , for example, provides an easy-to-use hosting model for
    ASP.NET Core applications, including those using SignalR.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云托管**：云平台提供强大且可扩展的托管环境。例如，**Azure App Service** 为 ASP.NET Core 应用程序（包括使用
    SignalR 的应用程序）提供了一个易于使用的托管模型。'
- en: '**Containers (Docker and Kubernetes)** : For those looking for more control
    over their hosting environment, containerization offers a way to package the SignalR
    application with all its dependencies, ensuring consistency across different environments.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器（Docker 和 Kubernetes）**：对于那些寻求对其托管环境有更多控制权的人来说，容器化提供了一种将 SignalR 应用程序及其所有依赖项打包的方法，确保在不同环境中的一致性。'
- en: 'After defining the hosting server, the process of hosting the application follows
    approximately four steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义托管服务器后，托管应用程序的过程大致遵循以下四个步骤：
- en: '**Publishing the application** : Use Visual Studio or the .NET CLI to publish
    your application, generating a deployable unit. This task can be done by running
    the following command as an example that compiles the application in the **Release**
    mode and generates publication files in the **Published** folder:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发布应用程序**：使用 Visual Studio 或 .NET CLI 发布您的应用程序，生成可部署单元。以下命令是一个示例，它以 **发布**
    模式编译应用程序，并在 **发布** 文件夹中生成发布文件：'
- en: '[PRE22]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Configuring the server** : Whether it’s IIS, a Linux server with Nginx/Apache,
    or a cloud service, you will need to configure the server or service to host your
    application. This includes installing the necessary .NET runtimes, in the case
    of IIS or Nginex/Apache servers, and configuring the web server or cloud service.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置服务器**：无论是 IIS、带有 Nginx/Apache 的 Linux 服务器，还是云服务，您都需要配置服务器或服务以托管您的应用程序。这包括为
    IIS 或 Nginx/Apache 服务器安装必要的 .NET 运行时，以及配置 Web 服务器或云服务。'
- en: '**Configuring reverse proxy (if necessary)** : For IIS, Nginx, and Apache,
    ensure they are configured to correctly forward requests to your ASP.NET Core
    application. This is crucial for SignalR as it relies on persistent connections.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置反向代理（如有必要）**：对于 IIS、Nginx 和 Apache，确保它们配置正确，以便正确转发请求到您的 ASP.NET Core 应用程序。这对于
    SignalR 至关重要，因为它依赖于持久连接。'
- en: '**Deploying the application** : Upload or deploy the published application
    to your hosting environment. This can be done via FTP, Web Deploy, or CI/CD pipelines
    if you are using cloud services or containerization.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署应用程序**：将发布的应用程序上传或部署到您的托管环境中。如果您使用云服务或容器化，可以通过 FTP、Web Deploy 或 CI/CD 管道完成此操作。'
- en: Hosting SignalR applications presents unique challenges due to their nature
    of maintaining persistent connections to clients and can significantly burden
    server resources.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SignalR 应用程序需要维护与客户端的持久连接，因此托管 SignalR 应用程序会带来独特的挑战，并可能显著增加服务器资源负担。
- en: It is important to be aware of the connection limits of your server or hosting
    plan, as each will have a maximum number of simultaneous connections it can support.
    In environments where load balancing is employed, the use of sticky sessions is
    recommended to preserve the integrity of connections, ensuring that a client communicates
    consistently with the same server instance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解您服务器或托管计划的连接限制，因为每个计划都支持的最大并发连接数是有限的。在采用负载均衡的环境下，建议使用粘性会话来保持连接的完整性，确保客户端始终与同一服务器实例进行通信。
- en: Additionally, as the number of concurrent connections increases, you may need
    to expand your application, involving deploying multiple instances of your application
    and distributing traffic between them. This would let you increase your ability
    to effectively manage a larger volume of concurrent connections. This approach
    helps maintain the optimal performance and reliability of your SignalR application
    under heavy load.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着并发连接数的增加，您可能需要扩展应用程序，包括部署多个应用程序实例并在它们之间分配流量。这将使您能够提高有效管理更大并发连接量的能力。这种方法有助于在重负载下保持
    SignalR 应用程序的最佳性能和可靠性。
- en: However, we understand that SignalR applications add the option of developing
    real-time applications using ASP.NET Core 9 and their hosting does not present
    major differences from traditional web-based applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们理解 SignalR 应用程序提供了使用 ASP.NET Core 9 开发实时应用程序的选项，并且它们的托管与传统基于 Web 的应用程序没有太大差异。
- en: In [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) , we will explore in greater
    detail how we can host any type of web-based application dynamically, using the
    best practices available.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 10 章*](B21788_10.xhtml#_idTextAnchor162) 中，我们将更详细地探讨如何使用最佳实践动态托管任何类型的基于
    Web 的应用程序。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned vital skills for creating dynamic real-time applications.
    We learned about the powerful features of ASP.NET Core 9 SignalR, its architectural
    model and fundamentals, and supporting technologies, as well as creating a real-time
    task management application. Furthermore, we explained the concepts of streaming
    in SignalR and covered the main activities required to host SignalR applications
    on servers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了创建动态实时应用程序的重要技能。我们了解了 ASP.NET Core 9 SignalR 的强大功能、其架构模型和基础知识，以及支持技术，以及创建实时任务管理应用程序。此外，我们解释了
    SignalR 中的流概念，并涵盖了在服务器上托管 SignalR 应用程序所需的主要活动。
- en: In the next chapter, we will explore working with data and persistence by learning
    the aspects of data management and persistence in ASP.NET Core 9 applications,
    using technologies such as Entity Framework Core. We will delve deeper into your
    understanding of database interactions and state management. These are essential
    components for any web-based application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习ASP.NET Core 9应用程序中的数据管理和持久性方面，使用诸如Entity Framework Core等技术来探索与数据和工作持久性的工作。我们将更深入地了解数据库交互和状态管理。这些是任何基于Web的应用程序的基本组件。
- en: 'Part 2: Data and Security'
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：数据和安全性
- en: When developing modern web solutions, we must deal with data persistence models
    and, of course, security. In this part, we will cover the principles, patterns,
    and best practices for connecting applications developed in ASP.NET Core 9 to
    databases such as SQL Server. We will learn about the entity-relational and NoSQL
    persistence models. We will learn how ASP.NET Core 9 provides powerful tools for
    interacting with data access layers and we will learn about the use of technologies
    such as EntityFramework Core and Dapper. In addition to interacting with data,
    we will learn about aspects related to application security, understanding the
    use of authorization and authentication, and how to implement applications that
    restrict access to information using ASP.NET Core Identity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发现代Web解决方案时，我们必须处理数据持久性模型和，当然，安全性。在本部分中，我们将介绍将ASP.NET Core 9开发的应用程序连接到SQL
    Server等数据库的原则、模式和最佳实践。我们将了解实体关系和NoSQL持久性模型。我们将学习ASP.NET Core 9如何提供与数据访问层交互的强大工具，以及我们将了解EntityFramework
    Core和Dapper等技术的使用。除了与数据交互外，我们还将了解与应用程序安全相关的方面，理解授权和认证的使用，以及如何使用ASP.NET Core Identity实现限制对信息访问的应用程序。
- en: 'This part has the following chapters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , *Working with Data and Persistence*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21788_05.xhtml#_idTextAnchor078) ，*与数据和持久性工作*'
- en: '[*Chapter 6*](B21788_06.xhtml#_idTextAnchor093) , *Enhancing Security and Quality*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21788_06.xhtml#_idTextAnchor093) ，*增强安全和质量*'
