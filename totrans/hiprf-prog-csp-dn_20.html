<html><head></head><body>
		<div id="_idContainer202">
			<h1 id="_idParaDest-291"><a id="_idTextAnchor297"/>Assessments</h1>
			<p>This section is for answers to questions from all chapters.</p>
			<h1 id="_idParaDest-292"><em class="italic"><a id="_idTextAnchor298"/></em><a href="B16617_01_Final_SB_Epub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, Introducing C# 10.0 and .NET 6</h1>
			<ol>
				<li>Performance improvements in the garbage collector and JIT compiler, improved performance of text-based processing, faster regular expression processing, and performance of threading and asynchronous operations has been boosted. There have also been performance improvements to collections, LINQ, networking, and Blazor; plus, there are additional performance-based APIs and analyzers that are new to .NET 6.</li>
				<li>You can now write top-level programs and use <strong class="source-inline">init</strong>-only properties and records. There are new pattern matching features and new expressions with targeted types. You can use covariant returns and perform native compilation.</li>
				<li><strong class="source-inline">dotnet</strong> and <strong class="source-inline">ngen</strong>.</li>
				<li>Run the Microsoft Store app performance assessment. Follow Microsoft’s advice based on the assessment to improve your app’s performance, and address each of the highlighted issues found with your app.</li>
				<li>Perform baseline measurements, begin optimizations by performing the refactoring with the largest overall impact, enable HTTP compression, reduce TCP/IP connection overheads, and use HTTP/2 over SSL.</li>
				<li>Reading tasks to be completed by the reader at their discretion.</li>
				<li>Coding tasks to be completed by the reader at their discretion.</li>
				<li>Benchmarking tasks to be completed by the reader at their discretion.</li>
			</ol>
			<h1 id="_idParaDest-293"><em class="italic"><a id="_idTextAnchor299"/></em><a href="B16617_02_Final_SB_Epub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, Implementing C# Interoperability</h1>
			<ol>
				<li value="1">Platform invocation.</li>
				<li>Explain what <strong class="source-inline">P/Invoke</strong> is.</li>
				<li>It reminds the programmer that they are responsible for the safety of their code, since it is not managed by the .NET Framework.</li>
				<li>There are three generations of objects: zero, one, and two. Normally, objects are added to generation zero and garbage is collected. But if they survive generation zero, they are promoted to generation one. Objects that survive generation one are promoted to generation two. If generations zero, one, and two are completely full and new objects are added, then you end up with <strong class="source-inline">OutOfMemoryException</strong>, and your application will crash.</li>
				<li>The <strong class="source-inline">fixed</strong> keyword is used to ensure that objects referenced by pointers are not promoted by the garbage collector. Otherwise, the pointers would point to the wrong thing, causing bugs in the software.</li>
				<li>BSTR.</li>
				<li>IronPython, although other packages also exist.</li>
				<li>Implement the disposable design pattern.</li>
				<li>Set large fields to <strong class="source-inline">null</strong> when the object is being disposed of. This makes them unreachable, and they are released faster than if they were reclaimed non-deterministically. You will do this outside of the <strong class="source-inline">conditional</strong> block. See <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose</a>.</li>
			</ol>
			<h1 id="_idParaDest-294"><em class="italic"><a id="_idTextAnchor300"/></em><a href="B16617_03_Final_SB_Epub.xhtml#_idTextAnchor053"><em class="italic">Chapter 3</em></a>, Predefined Data Types and Memory Allocations</h1>
			<ol>
				<li value="1"><strong class="source-inline">bool</strong>, <strong class="source-inline">byte</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">DateTime</strong>, <strong class="source-inline">decimal</strong>, <strong class="source-inline">double</strong>, <strong class="source-inline">enum</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">sbyte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">struct</strong>, <strong class="source-inline">value tuple</strong>, <strong class="source-inline">uint</strong>, and <strong class="source-inline">ulong</strong>.</li>
				<li><strong class="source-inline">object</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">delegate</strong>, and <strong class="source-inline">dynamic</strong>.</li>
				<li>Create an instance of the <strong class="source-inline">static</strong> type.</li>
				<li>No. The same physical memory is used for both the stack and the heap.</li>
				<li>Items are simply popped onto the stack when they are in use and immediately popped off the stack when they are no longer needed. Objects added to the heap need to be managed and object reference counters maintained. Items placed on the stack use both the stack and the heap, as items on the heap have pointer variables on the stack. So, there is more overhead to using the heap compared to the stack.</li>
				<li>A string is placed on the heap. A variable is placed on the stack with the string’s memory address. When another variable is assigned the same string, it is given the address of the string. So, multiple items on the stack will be pointing to the same string. However, if you append anything to the string, a new string is then created on the heap with a new memory address. The variable that is assigned the new string will have the memory address that points to the new string on the heap, so the original string is never updated.</li>
				<li>Less than 80,000 bytes.</li>
				<li>80,000 bytes or higher.</li>
			</ol>
			<h1 id="_idParaDest-295"><em class="italic"><a id="_idTextAnchor301"/></em><a href="B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, Memory Management</h1>
			<ol>
				<li value="1">Three: generation 0, generation 1, and generation 2.</li>
				<li>Objects less than 80,000 bytes are placed on the SOH.</li>
				<li>Objects 80,000 bytes or more are placed on the LOH.</li>
				<li>A strong reference is a reference that does not get garbage-collected.</li>
				<li>A weak reference is a reference that does get garbage-collected.</li>
				<li>Implement the <strong class="source-inline">IDisposable</strong> pattern.</li>
				<li>Unsubscribe event listeners when they are no longer used. Dispose of event publishers or set them to null when they are no longer used.</li>
				<li><strong class="source-inline">Marshal.ReleaseComObject(object)</strong>.</li>
				<li>Make sure that any allocated memory is deallocated. Use the <strong class="source-inline">IDisposable</strong> pattern to ensure that memory is cleaned up when the object is disposed of.</li>
			</ol>
			<h1 id="_idParaDest-296"><em class="italic"><a id="_idTextAnchor302"/></em><a href="B16617_05_Final_SB_Epub.xhtml#_idTextAnchor085"><em class="italic">Chapter 5</em></a>, Application Profiling and Tracing</h1>
			<ol>
				<li value="1">Applications, assemblies, namespaces, types, methods, and fields.</li>
				<li>Maintainability index, cyclomatic complexity, depth of inheritance, class coupling, lines of source code, and lines of executable code.</li>
				<li>Dump location and time, the name of the process, processor architecture, exception information, OS and CLR version, and the names, versions, and physical paths of the loaded modules.</li>
				<li>The name, path, optimized user code, symbol status, O (order), version, process, and AppDomain.</li>
				<li>Microsoft Visual Studio 2022, and JetBrains dotTrace, dotMemory, and dotnet-counters.</li>
				<li>We were able to list the .NET processes that can be monitored and counters that can be used to collect data. We obtained the .NET process identifiers and monitored them, and we collected, saved, and viewed data that we collected from the running .NET processes.</li>
			</ol>
			<h1 id="_idParaDest-297"><em class="italic"><a id="_idTextAnchor303"/></em><a href="B16617_06_Final_SB_Epub.xhtml#_idTextAnchor117"><em class="italic">Chapter 6</em></a>, The .NET Collections</h1>
			<ol>
				<li value="1"><strong class="source-inline">System.Collections</strong>, <strong class="source-inline">System.Collections.Generic</strong>, <strong class="source-inline">System.Collections.Concurrent</strong>, and <strong class="source-inline">System.Collections.Specialized</strong>.</li>
				<li>Big O notation is used to determine algorithmic efficiency.</li>
				<li>Algorithmic efficiency determines how time scales with respect to input.</li>
				<li>Benchmarking showed that using <strong class="source-inline">IList&lt;T&gt;</strong> was faster than using <strong class="source-inline">List&lt;T&gt;</strong>, and so using <strong class="source-inline">IList&lt;T&gt;</strong> is preferred over using <strong class="source-inline">List&lt;T&gt;</strong>.</li>
				<li>You can use either. What you choose depends upon your performance requirements and what you are trying to achieve. There are trade-offs between using collections and arrays. Understanding these trade-offs will help you choose which option you should apply to your code.</li>
				<li>Indexers enable objects in classes to be accessed in the same way as you access items in an array.</li>
				<li><strong class="source-inline">IEnumerator&lt;T&gt;</strong> is faster at iterating through in-memory collections than <strong class="source-inline">IEnumerable&lt;T&gt;</strong>.</li>
				<li>In terms of memory and speed performance, querying the database and obtaining the enumerator is the fastest way to query a database and iterate through the results according to the benchmarks.</li>
				<li>Use the <strong class="source-inline">yield</strong> keyword.</li>
			</ol>
			<h1 id="_idParaDest-298"><em class="italic"><a id="_idTextAnchor304"/></em><a href="B16617_07_Final_SB_Epub.xhtml#_idTextAnchor139"><em class="italic">Chapter 7</em></a>, LINQ Performance</h1>
			<ol>
				<li value="1">Use the index rather than the <strong class="source-inline">Last()</strong> call for direct access to the last element in a collection. Avoid using the <strong class="source-inline">let</strong> keyword in your LINQ queries. Convert a list to an array to perform group by, and then return an enumerator.</li>
				<li>The compiler generates more lines of code that take longer to run, and more memory is allocated at runtime than when the <strong class="source-inline">let</strong> keyword is not used.</li>
				<li>Filter items starting with objects that have the least number of items, followed by the objects with an increasing number of items. Also, avoid using the <strong class="source-inline">let</strong> keyword.</li>
				<li>Closures with parameters perform better than closures without parameters.</li>
			</ol>
			<h1 id="_idParaDest-299"><em class="italic"><a id="_idTextAnchor305"/></em><a href="B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152"><em class="italic">Chapter 8</em></a>, File and Stream I/O</h1>
			<ol>
				<li value="1">Absolute, relative, UNC, and DOS device.</li>
				<li>In the registry editor, set <strong class="source-inline">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem\LongPathsEnabled</strong> to <strong class="source-inline">1</strong>.</li>
				<li>The most efficient way to calculate the size of a directory is to get <strong class="source-inline">DirectoryInfo</strong> for the directory, followed by the call to <strong class="source-inline">GetFileSystemInfos()</strong>. You then iterate through the result, adding the length of each <strong class="source-inline">FileInfo</strong> object to get the directory’s size.</li>
				<li>The most efficient method of moving files is to obtain <strong class="source-inline">FileInfo</strong> objects from the in-memory cache and then use the <strong class="source-inline">FileInfo.MoveTo(string destination)</strong> method to move the file.</li>
				<li>When you encounter a non-recoverable exception before you exit the application.</li>
				<li><strong class="source-inline">IOException</strong>.</li>
				<li>Local, Local Cache, Roaming, Temporary, and C:\ProgramData.</li>
				<li>Users may only install the software for themselves when prompted. This will result in each logged-on person using the software having their own copy of the data, with the data located in the Microsoft VirtualStore under their logged-on account.</li>
				<li>When multiple users log onto the same computer, and an application has been installed for just one user rather than all users, instead of the application data being stored under the centralized location of <strong class="source-inline">C:\ProgramData</strong>, it will be stored under Microsoft Virtual Store. </li>
				<li><strong class="source-inline">C:\Users\%USERNAME%\AppData\Local\VirtualStore</strong>.</li>
			</ol>
			<h1 id="_idParaDest-300"><em class="italic"><a id="_idTextAnchor306"/></em><a href="B16617_09_Final_SB_Epub.xhtml#_idTextAnchor168"><em class="italic">Chapter 9</em></a>, Enhancing the Performance of Networked Applications</h1>
			<ol>
				<li value="1">Application layer, presentation layer, session layer, transport layer, network layer, data link layer, and physical layer.</li>
				<li>HTTP, HTTPS, SSH, SSL, DHCP, DNS, FTP, TFTP, Telnet, SMTP, IMAP4, POP3, TCP, IP, UDP, Ethernet, and PPP.</li>
				<li>TCP enables the transmitting and receiving of data that is guaranteed to be received. UDP only allows the transmission of data that is not guaranteed to be received.</li>
				<li>Use the developer tools that are built into your browser.</li>
				<li>gRPC is a cross-platform, cross-language, and cross-device framework for making remote procedure calls between applications. gRPC-Web is a proxy for browser-based RCP calls, as browser applications are unable to use gRPC directly.</li>
				<li>Reduce the number of things the page is doing and the number of services the page calls. Reduce the size of images. Use file compression to reduce the size of files transmitted over a network. Cache network resources. Filter data on the server, divide it into pages, and return only the requested page of data.</li>
			</ol>
			<h1 id="_idParaDest-301"><em class="italic"><a id="_idTextAnchor307"/></em><a href="B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189"><em class="italic">Chapter 10</em></a>, Setting Up Our Database Project</h1>
			<p class="Normal" lang="en-US" xml:lang="en-US">N/A.</p>
			<h1 id="_idParaDest-302"><em class="italic"><a id="_idTextAnchor308"/></em><a href="B16617_11_Final_SB_Epub.xhtml#_idTextAnchor205"><em class="italic">Chapter 11</em></a>, Benchmarking Relational Data Access Frameworks</h1>
			<ol>
				<li value="1">Executing a stored procedure with Dapper.NET.</li>
				<li>Executing a raw SQL statement with Dapper.NET.</li>
				<li>Executing a stored procedure with ADO.NET.</li>
				<li>Executing a stored procedure with ADO.NET.</li>
				<li>Executing a stored procedure with ADO.NET.</li>
				<li>Not necessarily. A hybrid approach may be better because you can maximize your data access performance for the data operations in question by using the most performant method from the frameworks you have selected to work with.</li>
			</ol>
			<h1 id="_idParaDest-303"><em class="italic"><a id="_idTextAnchor309"/></em><a href="B16617_12_Final_SB_Epub.xhtml#_idTextAnchor215"><em class="italic">Chapter 12</em></a>, Responsive User Interfaces</h1>
			<ol>
				<li value="1">Configure the application for high-DPI awareness.</li>
				<li>Configure the application to be long file path-aware.</li>
				<li>Add a splash screen to the start of your application.</li>
				<li>Run the long-running task as a background task.</li>
				<li>Memory caching and distributed caching.</li>
				<li>Use AJAX.</li>
				<li><strong class="source-inline">WebSockets</strong> and SignalR.</li>
				<li><strong class="source-inline">SetSemanticFocus</strong>, <strong class="source-inline">Announce</strong>, and <strong class="source-inline">Font scaling</strong>.</li>
				<li>Add the <strong class="source-inline">BlazorWebView</strong> component to a page and point it to the root of your Blazor application.</li>
				<li><strong class="source-inline">ProgressRing</strong> and <strong class="source-inline">ProgressBar</strong>.</li>
			</ol>
			<h1 id="_idParaDest-304"><em class="italic"><a id="_idTextAnchor310"/></em><a href="B16617_13_Final_SB_Epub.xhtml#_idTextAnchor239"><em class="italic">Chapter 13</em></a>, Distributed Systems  </h1>
			<ol>
				<li value="1">Command query responsibility separation.</li>
				<li>We may want to use one model for commands and another model for queries.</li>
				<li>Event-driven programming.</li>
				<li>We use events to trigger the execution of a serverless function, such as an Azure Durable Function.</li>
				<li>A piece of software that is used to package an application and its dependencies that can be deployed to and executed in the cloud or on-premises. </li>
				<li>To deploy third-party dependencies and legacy code.</li>
				<li>Microservices in the form of functions that only run when they are required and that usually run in response to an event trigger.</li>
				<li>Serverless functions can scale rapidly, and you only pay for the time the functions run. This can save money when compared to containers that need to be running most of the time.</li>
				<li>Extensions to Azure Functions that enable the writing of stateful functions in a serverless environment. We can also use them to define workflows.</li>
				<li>Activity, Orchestrator, Entity, and Client.</li>
				<li>Aggregator (stateful entities), fan-out/fan-in, function chaining, human interaction, and monitoring (actors).</li>
				<li>An infrastructure-as-code platform for managing microservices.</li>
				<li>You can manage your microservices and their resources using C#, from creation to running, stopping, and deleting them.</li>
			</ol>
			<h1 id="_idParaDest-305"><em class="italic"><a id="_idTextAnchor311"/></em><a href="B16617_14_Final_SB_Epub.xhtml#_idTextAnchor254"><em class="italic">Chapter 14</em></a>, Multi-Threaded Programming</h1>
			<ol>
				<li value="1"><strong class="source-inline">Running</strong>, <strong class="source-inline">suspended</strong>, <strong class="source-inline">wait</strong>, <strong class="source-inline">sleep</strong>, <strong class="source-inline">join</strong>, and <strong class="source-inline">stop</strong>.</li>
				<li>You don’t – this API is now obsolete.</li>
				<li>Foreground and background.</li>
				<li>Use <strong class="source-inline">CancellationToken</strong> to raise <strong class="source-inline">TaskCanceledException</strong> when a <strong class="source-inline">CancellationTokenSource</strong> operation times out.</li>
				<li><strong class="source-inline">Thread.Start()</strong> or <strong class="source-inline">Thread.Start(object)</strong>.</li>
			</ol>
			<h1 id="_idParaDest-306"><em class="italic"><a id="_idTextAnchor312"/></em><a href="B16617_15_Final_SB_Epub.xhtml#_idTextAnchor266"><em class="italic">Chapter 15</em></a>, Parallel Programming</h1>
			<ol>
				<li value="1">Task Parallel Library.</li>
				<li>Parallel LINQ Library.</li>
				<li>Performance Monitor aka <strong class="source-inline">perfmon</strong>.</li>
				<li>No.</li>
				<li>Use <strong class="source-inline">BenchmarkDotNet</strong> to test the performance of various methods.</li>
			</ol>
			<h1 id="_idParaDest-307"><em class="italic"><a id="_idTextAnchor313"/></em><a href="B16617_16_Final_SB_Epub.xhtml#_idTextAnchor280"><em class="italic">Chapter 16</em></a>, Asynchronous Programming</h1>
			<ol>
				<li value="1">Task-based asynchronous pattern.</li>
				<li><strong class="source-inline">CancellationToken</strong>.</li>
				<li><strong class="source-inline">IProgress&lt;T&gt;</strong>.</li>
				<li>An asynchronous method is declared, with the <strong class="source-inline">async</strong> keyword preceding the method name. The <strong class="source-inline">await</strong> keyword precedes an asynchronous operation and prevents the continuation of any further code until the asynchronous operation is complete. <strong class="source-inline">Task</strong> is what an asynchronous method returns. For <strong class="source-inline">void</strong> methods, the return type is <strong class="source-inline">Task</strong>, and for methods that return a value, the return type is <strong class="source-inline">Task&lt;T&gt;</strong>.</li>
				<li>Create a new <strong class="source-inline">CancelationTokenSource</strong> and then set the method of cancelation, such as <strong class="source-inline">CancelAfter(3000)</strong>.</li>
				<li>Pass an <strong class="source-inline">IProgress&lt;T&gt;</strong> type into an asynchronous method as a parameter and add event handlers for the <strong class="source-inline">ProgressChanged</strong> event. Alternatively, you can pass a single handler into the <strong class="source-inline">Progress&lt;T&gt;</strong> constructor. </li>
			</ol>
		</div>
	</body></html>