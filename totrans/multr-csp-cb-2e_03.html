<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Using a Thread Pool</h1></div></div></div><p>In this chapter, we will describe the common techniques that are used for working with shared resources from multiple threads. You will learn the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Invoking a delegate on a thread pool</li><li class="listitem" style="list-style-type: disc">Posting an asynchronous operation on a thread pool</li><li class="listitem" style="list-style-type: disc">A thread pool and the degree of parallelism</li><li class="listitem" style="list-style-type: disc">Implementing a cancellation option</li><li class="listitem" style="list-style-type: disc">Using a wait handle and timeout with a thread pool</li><li class="listitem" style="list-style-type: disc">Using a timer</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">BackgroundWorker</code> component</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Introduction</h1></div></div></div><p>In the previous chapters, we discussed several ways to create threads and organize their cooperation. Now, let's consider another scenario where we will create many asynchronous operations that take very little time to complete. As we discussed in the <em>Introduction</em> section of <a class="link" href="ch01.html" title="Chapter 1. Threading Basics">Chapter 1</a>, <em>Threading Basics</em>, creating a thread is an expensive operation, so doing this for each short-lived, asynchronous operation will include a significant overhead expense.</p><p>To deal with this problem, there <a id="id97" class="indexterm"/>is a common approach called <strong>pooling</strong> that can be successfully applied to any situation when we need many short-lived, expensive resources. We allocate a certain amount of these resources in advance and organize them into a resource pool. Each time we need a new resource, we just take it from the pool, instead of creating a new one, and return it to the pool after the resource is no longer needed.</p><p>The <strong>.NET thread pool</strong> is <a id="id98" class="indexterm"/>an implementation of this concept. It is accessible via the <code class="literal">System.Threading.ThreadPool</code> type. A thread pool is managed by the .NET <strong>Common </strong><a id="id99" class="indexterm"/>
<strong>Language Runtime</strong> (<strong>CLR</strong>), which means that there is one instance of a thread pool per CLR. The <code class="literal">ThreadPool</code> type has a <a id="id100" class="indexterm"/>
<code class="literal">QueueUserWorkItem</code> static method that accepts a <strong>delegate</strong>, representing a user-defined, asynchronous operation. After this method is called, this delegate goes to the internal queue. Then, if there are no threads inside the pool, it creates a new <a id="id101" class="indexterm"/>
<strong>worker thread</strong> and puts the first delegate in the queue on it.</p><p>If we put new operations on a thread pool, after the previous operations are completed, it is possible to reuse this one thread to execute these operations. However, if we put new operations faster, the thread pool will create more threads to serve these operations. There is a limit to prevent creating too many threads, and in that case, new operations wait in the queue until the worker threads in the pool become free to serve them.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>It is very important to keep operations on a thread pool shortlived! Do not put long-running operations on a thread pool or block worker threads. This will lead to all worker threads becoming busy, and they will no longer be able to serve user operations. This, in turn, will lead to performance problems and errors that are very hard to debug.</p></div></div><p>When we stop putting new operations on a thread pool, it will eventually remove threads that are no longer needed after being idle for some time. This will free up any operating system resources that are no longer required.</p><p>I would like to emphasize once again that a thread pool is intended to execute short-running operations. Using a thread pool lets us save operating system resources at the cost of reducing the degree of parallelism. We use fewer threads, but execute asynchronous operations more slowly than usual, batching them by the number of worker threads available. This makes sense if operations complete rapidly, but this will degrade the performance if we execute many long-running, compute-bound operations.</p><p>Another important thing to be very careful of is using a thread pool in ASP.NET applications. The ASP.NET infrastructure uses a thread pool itself, and if you waste all worker threads from a thread pool, a web server will no longer be able to serve incoming requests. It is <a id="id102" class="indexterm"/>recommended that you use only input/output-bound asynchronous operations in ASP.NET because they use different mechanics called <strong>I/O threads</strong>. We will discuss I/O threads in <a class="link" href="ch09.html" title="Chapter 9. Using Asynchronous I/O">Chapter 9</a>, <em>Using Asynchronous I/O</em>.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>Note that worker threads in a thread pool are background threads. This means that when all of the threads in the foreground (including the main application thread) are complete, then all the background threads will be stopped.</p></div></div><p>In this chapter, you will learn to use a thread pool to execute asynchronous operations. We will cover different ways to put an operation on a thread pool and how to cancel an operation and prevent it from running for a long time.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Invoking a delegate on a thread pool</h1></div></div></div><p>This recipe will show you how to execute a delegate asynchronously on a thread pool. In addition, we will <a id="id103" class="indexterm"/>discuss an approach <a id="id104" class="indexterm"/>called the <strong>Asynchronous Programming </strong><a id="id105" class="indexterm"/>
<strong>Model</strong> (<strong>APM</strong>), which was historically the first asynchronous programming pattern in .NET.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec69"/>Getting ready</h2></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe1</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec70"/>How to do it...</h2></div></div></div><p>To understand how to invoke a delegate on a thread pool, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">private delegate string RunOnThreadPool(out int threadId);

private static void Callback(IAsyncResult ar)
{
  WriteLine("Starting a callback...");
  WriteLine($"State passed to a callbak: {ar.AsyncState}");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  WriteLine($"Thread pool worker thread id: {CurrentThread.ManagedThreadId}");
}

private static string Test(out int threadId)
{
  WriteLine("Starting...");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  threadId = CurrentThread.ManagedThreadId;
  return $"Thread pool worker thread id was: {threadId}";
}</pre></div></li><li class="listitem">Add the <a id="id106" class="indexterm"/>following code inside the <code class="literal">Main</code> method:<div><pre class="programlisting">int threadId = 0;

RunOnThreadPool poolDelegate = Test;

var t = new Thread(() =&gt; Test(out threadId));
t.Start();
t.Join();

WriteLine($"Thread id: {threadId}");

IAsyncResult r = poolDelegate.BeginInvoke(out threadId, Callback, "a delegate asynchronous call");
r.AsyncWaitHandle.WaitOne();

string result = poolDelegate.EndInvoke(out threadId, r);

WriteLine($"Thread pool worker thread id: {threadId}");
WriteLine(result);

Sleep(TimeSpan.FromSeconds(2));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec71"/>How it works...</h2></div></div></div><p>When the program runs, it creates a thread in the old-fashioned way and then starts it and waits for its completion. Since a thread constructor accepts only a method that does not return any result, we use a <a id="id107" class="indexterm"/>
<strong>lambda expression</strong> to wrap up a call to the <code class="literal">Test</code> method. We make sure that this thread is not from the thread pool by printing out the <code class="literal">Thread.CurrentThread.IsThreadPoolThread</code> property value. We also print out a managed thread ID to identify a thread on which this code was executed.</p><p>Then, we define a <a id="id108" class="indexterm"/>delegate and run it by calling the <code class="literal">BeginInvoke</code> method. This method accepts a callback that will be called after the asynchronous operation is complete and a user-defined state to pass into the callback. This state is usually used to distinguish one asynchronous call from another. As a result, we get a <code class="literal">result</code> object that implements the <code class="literal">IAsyncResult</code> interface. The <code class="literal">BeginInvoke</code> method returns the result immediately, allowing us to continue with any work while the asynchronous operation is being executed on a worker thread of the thread pool. When we need the result of an asynchronous operation, we use the <code class="literal">result</code> object returned from the <code class="literal">BeginInvoke</code> method call. We <a id="id109" class="indexterm"/>can poll on it using the <code class="literal">IsCompleted</code> result property, but in this case, we use the <code class="literal">AsyncWaitHandle</code> result property to wait on it until the operation is complete. After this is done, to get a result from it, we call the <code class="literal">EndInvoke</code> method on a delegate, passing the delegate arguments and our <code class="literal">IAsyncResult</code> object.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Actually, using <code class="literal">AsyncWaitHandle</code> is not necessary. If we comment out <code class="literal">r.AsyncWaitHandle.WaitOne</code>, the code will still run successfully because the <code class="literal">EndInvoke</code> method actually waits for the asynchronous operation to complete. It is always important to call <code class="literal">EndInvoke</code> (or <code class="literal">EndOperationName</code> for other asynchronous APIs) because it throws any unhandled exceptions back to the calling thread. Always call both the <code class="literal">Begin</code> and <code class="literal">End</code> methods when using this kind of asynchronous API.</p></div></div><p>When the operation completes, a callback passed to the <code class="literal">BeginInvoke</code> method will be posted on a thread pool, more specifically, a worker thread. If we comment out the <code class="literal">Thread.Sleep</code> method call at the end of the <code class="literal">Main</code> method definition, the callback will not be executed. This is because when the main thread is completed, all the background threads will be stopped, including this callback. It is possible that both asynchronous calls to a delegate and a callback will be served by the same worker thread, which is easy to see by a worker thread ID.</p><p>This approach of using the <code class="literal">BeginOperationName</code>/<code class="literal">EndOperationName</code> method and the <code class="literal">IAsyncResult</code> object in .NET is called the Asynchronous Programming Model or the APM pattern, and such method pairs are called asynchronous methods. This pattern is still used in various .NET class library APIs, but in modern programming, it is preferable to use the <strong>Task </strong><a id="id110" class="indexterm"/>
<strong>Parallel Library</strong> (<strong>TPL</strong>) to organize an asynchronous API. We will cover this topic in <a class="link" href="ch04.html" title="Chapter 4. Using the Task Parallel Library">Chapter 4</a>, <em>Using the Task Parallel Library</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Posting an asynchronous operation on a thread pool</h1></div></div></div><p>This recipe <a id="id111" class="indexterm"/>will describe how to put an <a id="id112" class="indexterm"/>asynchronous operation on a thread pool.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec72"/>Getting ready</h2></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe2</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec73"/>How to do it...</h2></div></div></div><p>To understand <a id="id113" class="indexterm"/>how to post an asynchronous <a id="id114" class="indexterm"/>operation on a thread pool, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">private static void AsyncOperation(object state)
{
  WriteLine($"Operation state: {state ?? "(null)"}");
  WriteLine($"Worker thread id: {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(2));
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">const int x = 1;
const int y = 2;
const string lambdaState = "lambda state 2";

ThreadPool.QueueUserWorkItem(AsyncOperation);
Sleep(TimeSpan.FromSeconds(1));

ThreadPool.QueueUserWorkItem(AsyncOperation, "async state");
Sleep(TimeSpan.FromSeconds(1));

ThreadPool.QueueUserWorkItem( state =&gt; {
  WriteLine($"Operation state: {state}");
  WriteLine($"Worker thread id: {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(2));
}, "lambda state");

ThreadPool.QueueUserWorkItem( _ =&gt;
{
  WriteLine($"Operation state: {x + y}, {lambdaState}");
  WriteLine($"Worker thread id: {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(2));
}, "lambda state");

Sleep(TimeSpan.FromSeconds(2));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec74"/>How it works...</h2></div></div></div><p>First, we define <a id="id115" class="indexterm"/>the <code class="literal">AsyncOperation</code> method that accepts a single parameter of the <code class="literal">object</code> type. Then, we post this method <a id="id116" class="indexterm"/>on a thread pool using the <code class="literal">QueueUserWorkItem</code> method. Then, we post this method once again, but this time, we pass a <code class="literal">state</code> object to this method call. This object will be passed to the <code class="literal">AsynchronousOperation</code> method as the <code class="literal">state</code> parameter.</p><p>Making a thread sleep for 1 second after these operations allows the thread pool to reuse threads for new operations. If you comment on these <code class="literal">Thread.Sleep</code> calls, most certainly the thread IDs will be different in all cases. If not, probably the first two threads will be reused to run the following two operations.</p><p>First, we post a lambda expression to a thread pool. Nothing special here; instead of defining a separate method, we use the lambda expression syntax.</p><p>Secondly, instead of passing the state of a lambda expression, we use <strong>closure</strong> mechanics. This gives us more <a id="id117" class="indexterm"/>flexibility and allows us to provide more than one object to the asynchronous operation and static typing for those objects. So, the previous mechanism of passing an object into a method callback is really redundant and obsolete. There is no need to use it now when we have closures in C#.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>A thread pool and the degree of parallelism</h1></div></div></div><p>This recipe will <a id="id118" class="indexterm"/>show you how a thread pool works with <a id="id119" class="indexterm"/>many asynchronous operations and how it is different from creating many separate threads.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec75"/>Getting ready</h2></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found in <code class="literal">BookSamples\Chapter3\Recipe3</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec76"/>How to do it...</h2></div></div></div><p>To learn how a <a id="id120" class="indexterm"/>thread pool works with many <a id="id121" class="indexterm"/>asynchronous operations and how it is different from creating many separate threads, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Diagnostics;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static void UseThreads(int numberOfOperations)
{
  using (var countdown = new CountdownEvent(numberOfOperations))
  {
    WriteLine("Scheduling work by creating threads");
    for (int i = 0; i &lt; numberOfOperations; i++)
    {
      var thread = new Thread(() =&gt;
      {
        Write($"{CurrentThread.ManagedThreadId},");
        Sleep(TimeSpan.FromSeconds(0.1));
        countdown.Signal();
      });
      thread.Start();
    }
    countdown.Wait();
    WriteLine();
  }
}

static void UseThreadPool(int numberOfOperations)
{
  using (var countdown = new CountdownEvent(numberOfOperations))
  {
    WriteLine("Starting work on a threadpool");
    for (int i = 0; i &lt; numberOfOperations; i++)
    {
      ThreadPool.QueueUserWorkItem( _ =&gt; 
      {
        Write($"{CurrentThread.ManagedThreadId},");
        Sleep(TimeSpan.FromSeconds(0.1));
        countdown.Signal();
      });
    }
    countdown.Wait();
    WriteLine();
  }
}</pre></div></li><li class="listitem">Add the <a id="id122" class="indexterm"/>following code snippet <a id="id123" class="indexterm"/>inside the <code class="literal">Main</code> method:<div><pre class="programlisting">const int numberOfOperations = 500;
var sw = new Stopwatch();
sw.Start();
UseThreads(numberOfOperations);
sw.Stop();
WriteLine($"Execution time using threads: {sw.ElapsedMilliseconds}");

sw.Reset();
sw.Start();
UseThreadPool(numberOfOperations);
sw.Stop();
WriteLine($"Execution time using the thread pool: {sw.ElapsedMilliseconds}");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec77"/>How it works...</h2></div></div></div><p>When the main program starts, we create many different threads and run an operation on each one of them. This operation prints out a thread ID and blocks a thread for 100 milliseconds. As a result, we create 500 threads running all these operations in parallel. The total time on my machine is about 300 milliseconds, but we consume many operating system resources for all these threads.</p><p>Then, we follow the same workflow, but instead of creating a thread for each operation, we post them on a thread pool. After this, the thread pool starts to serve these operations; it begins to create <a id="id124" class="indexterm"/>more threads near the end; however, it still <a id="id125" class="indexterm"/>takes much more time, about 12 seconds on my machine. We save memory and threads for operating system use but pay for it with application performance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Implementing a cancellation option</h1></div></div></div><p>This recipe <a id="id126" class="indexterm"/>shows an example on how to cancel an asynchronous operation on a thread pool.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec78"/>Getting ready</h2></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found in <code class="literal">BookSamples\Chapter3\Recipe4</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec79"/>How to do it...</h2></div></div></div><p>To understand how <a id="id127" class="indexterm"/>to implement a cancellation <a id="id128" class="indexterm"/>option on a thread, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static void AsyncOperation1(CancellationToken token)
{
  WriteLine("Starting the first task");
  for (int i = 0; i &lt; 5; i++)
  {
    if (token.IsCancellationRequested)
    {
      WriteLine("The first task has been canceled.");
      return;
    }
    Sleep(TimeSpan.FromSeconds(1));
  }
  WriteLine("The first task has completed succesfully");
}

static void AsyncOperation2(CancellationToken token)
{
  try
  {
    WriteLine("Starting the second task");

    for (int i = 0; i &lt; 5; i++)
    {
      token.ThrowIfCancellationRequested();
      Sleep(TimeSpan.FromSeconds(1));
    }
    WriteLine("The second task has completed succesfully");
  }
  catch (OperationCanceledException)
  {
    WriteLine("The second task has been canceled.");
  }
}

static void AsyncOperation3(CancellationToken token)
{
  bool cancellationFlag = false;
  token.Register(() =&gt; cancellationFlag = true);
  WriteLine("Starting the third task");
  for (int i = 0; i &lt; 5; i++)
  {
    if (cancellationFlag)
    {
      WriteLine("The third task has been canceled.");
      return;
    }
    Sleep(TimeSpan.FromSeconds(1));
  }
  WriteLine("The third task has completed succesfully");
}</pre></div></li><li class="listitem">Add the <a id="id129" class="indexterm"/>following code snippet inside the <a id="id130" class="indexterm"/><code class="literal">Main</code> method:<div><pre class="programlisting">using (var cts = new CancellationTokenSource())
{
  CancellationToken token = cts.Token;
  ThreadPool.QueueUserWorkItem(_ =&gt; AsyncOperation1(token));
  Sleep(TimeSpan.FromSeconds(2));
  cts.Cancel();
}

using (var cts = new CancellationTokenSource())
{
  CancellationToken token = cts.Token;
  ThreadPool.QueueUserWorkItem(_ =&gt; AsyncOperation2(token));
  Sleep(TimeSpan.FromSeconds(2));
  cts.Cancel();
}

using (var cts = new CancellationTokenSource())
{
  CancellationToken token = cts.Token;
  ThreadPool.QueueUserWorkItem(_ =&gt; AsyncOperation3(token));
  Sleep(TimeSpan.FromSeconds(2));
  cts.Cancel();
}

Sleep(TimeSpan.FromSeconds(2));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec80"/>How it works...</h2></div></div></div><p>Here, we introduce the <code class="literal">CancellationTokenSource</code> and <code class="literal">CancellationToken</code> constructs. They <a id="id131" class="indexterm"/>appeared in .NET 4.0 and now are the de facto standard to implement asynchronous operation cancellation processes. Since the thread pool has existed for a long time, it has no special API for cancellation tokens; however, they can still be used.</p><p>In this program, we see three ways to organize a cancellation process. The first is just to poll and check the <a id="id132" class="indexterm"/>
<code class="literal">CancellationToken.IsCancellationRequested</code> property. If it is set to <code class="literal">true</code>, this means that our operation is being cancelled and we must abandon the operation.</p><p>The second way is to throw an <code class="literal">OperationCancelledException</code> exception. This allows us to control the cancellation process not from inside the operation, which is being canceled, but from the code on the outside.</p><p>The last option is to register a <a id="id133" class="indexterm"/>
<strong>callback</strong> that will be called on a thread pool when an operation is canceled. This will allow us to chain cancellation logic into another asynchronous operation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Using a wait handle and timeout with a thread pool</h1></div></div></div><p>This recipe <a id="id134" class="indexterm"/>will describe how to implement a timeout for <a id="id135" class="indexterm"/>thread pool operations and how to wait properly <a id="id136" class="indexterm"/>on a thread pool.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec81"/>Getting ready</h2></div></div></div><p>To step into this <a id="id137" class="indexterm"/>recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe5</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec82"/>How to do it...</h2></div></div></div><p>To learn how to implement a timeout and how to wait properly on a thread pool, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static void RunOperations(TimeSpan workerOperationTimeout)
{
  using (var evt = new ManualResetEvent(false))
  using (var cts = new CancellationTokenSource())
  {
    WriteLine("Registering timeout operation...");
    var worker = ThreadPool.RegisterWaitForSingleObject(evt
                , (state, isTimedOut) =&gt; WorkerOperationWait(cts, isTimedOut)
                , null
                , workerOperationTimeout
                , true);

    WriteLine("Starting long running operation...");
    ThreadPool.QueueUserWorkItem(_ =&gt; WorkerOperation(cts.Token, evt));

    Sleep(workerOperationTimeout.Add(TimeSpan.FromSeconds(2)));
    worker.Unregister(evt);
  }
}

static void WorkerOperation(CancellationToken token, ManualResetEvent evt)
{
  for(int i = 0; i &lt; 6; i++)
  {
    if (token.IsCancellationRequested)
    {
      return;
    }
    Sleep(TimeSpan.FromSeconds(1));
  }
  evt.Set();
}

static void WorkerOperationWait(CancellationTokenSource cts, bool isTimedOut)
{
  if (isTimedOut)
  {
    cts.Cancel();
    WriteLine("Worker operation timed out and was canceled.");
  }
  else
  {
    WriteLine("Worker operation succeded.");
  }
}</pre></div></li><li class="listitem">Add the <a id="id138" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">RunOperations(TimeSpan.FromSeconds(5));
RunOperations(TimeSpan.FromSeconds(7));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec83"/>How it works...</h2></div></div></div><p>A thread pool has <a id="id139" class="indexterm"/>another useful method: <code class="literal">ThreadPool.RegisterWaitForSingleObject</code>. This method allows us to queue a callback on a thread <a id="id140" class="indexterm"/>pool, and this callback will be executed when the <a id="id141" class="indexterm"/>provided wait handle is signaled or a timeout has occurred. This allows us to implement a timeout for thread pool operations.</p><p>First, we register the timeout handling asynchronous operation. It will be called when one of the following events take place: on receiving a signal from the <code class="literal">ManualResetEvent</code> object, which is set by the worker operation when it is completed successfully, or when a timeout has occurred before the first operation is completed. If this happens, we use <code class="literal">CancellationToken</code> to cancel the first operation.</p><p>Then, we queue a long-running worker operation on a thread pool. It runs for 6 seconds and then sets a <code class="literal">ManualResetEvent</code> signaling construct, in case it completes successfully. In other case, if the cancellation is requested, the operation is just abandoned.</p><p>Finally, if we provide a 5-second timeout for the operation, that would not be enough. This is because the operation takes 6 seconds to complete, and we'd need to cancel this operation. So, if we <a id="id142" class="indexterm"/>provide a 7-second timeout, which is acceptable, the <a id="id143" class="indexterm"/>operation completes successfully.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec84"/>There's more…</h2></div></div></div><p>This is very useful <a id="id144" class="indexterm"/>when you have a large number of threads that <a id="id145" class="indexterm"/>must wait in the <code class="literal">blocked</code> state for some multithreaded event construct to signal. Instead of blocking all these threads, we are able to use the thread pool infrastructure. It will allow us to free up these threads until the event is set. This is a very important scenario for server applications, which require scalability and performance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Using a timer</h1></div></div></div><p>This recipe will <a id="id146" class="indexterm"/>describe how to use a <code class="literal">System.Threading.Timer</code> object to create periodically-called asynchronous operations on a thread pool.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec85"/>Getting ready</h2></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe6</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec86"/>How to do it...</h2></div></div></div><p>To learn how to create periodically-called asynchronous operations on a thread pool, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static Timer _timer;

static void TimerOperation(DateTime start)
{
  TimeSpan elapsed = DateTime.Now - start;
  WriteLine($"{elapsed.Seconds} seconds from {start}. " +
    $"Timer thread pool thread id: {CurrentThread.ManagedThreadId}");
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">WriteLine("Press 'Enter' to stop the timer...");
DateTime start = DateTime.Now;
_timer = new Timer(_ =&gt; TimerOperation(start), null
    , TimeSpan.FromSeconds(1)
    , TimeSpan.FromSeconds(2));
try
{
  Sleep(TimeSpan.FromSeconds(6));

  _timer.Change(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(4));

  ReadLine();
}
finally
{
  _timer.Dispose();
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec87"/>How it works...</h2></div></div></div><p>First, we create a <a id="id147" class="indexterm"/>new <code class="literal">Timer</code> instance. The first parameter is a lambda expression that will be executed on a thread pool. We call the <code class="literal">TimerOperation</code> method, providing it with a start date. We do not use the user <code class="literal">state</code> object, so the second parameter is null; then, we specify when are we going to run <code class="literal">TimerOperation</code> for the first time and what will be the period between calls. So, the first value actually means that we start the first operation in 1 second, and then, we run each of them in 2 seconds.</p><p>After this, we wait for 6 seconds and change our timer. We start <code class="literal">TimerOperation</code> in a second after calling the <code class="literal">_timer.Change</code> method, and then run each of them for 4 seconds.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p><strong>A timer could be more complex than this!</strong></p><p>It is possible to use a timer in more complicated ways. For instance, we can run the timer operation only once, by providing a timer period parameter with the <code class="literal">Timeout.Infinite</code> value. Then, inside the timer asynchronous operation, we are able to set the next time when the timer operation will be executed, depending on some custom logic.</p></div></div><p>Lastly, we wait for the <em>Enter</em> key to be pressed and to finish the application. While it is running, we can see the <a id="id148" class="indexterm"/>time passed since the program started.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Using the BackgroundWorker component</h1></div></div></div><p>This recipe <a id="id149" class="indexterm"/>describes another approach to asynchronous programming via an example of a <code class="literal">BackgroundWorker</code> component. With the help of this object, we are able to organize our asynchronous code as a set of events and event handlers. You will learn how to use this component for asynchronous programming.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec88"/>Getting ready</h2></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe7</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec89"/>How to do it...</h2></div></div></div><p>To learn how to use the <code class="literal">BackgroundWorker</code> component, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.ComponentModel;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static void Worker_DoWork(object sender, DoWorkEventArgs e)
{
  WriteLine($"DoWork thread pool thread id: {CurrentThread.ManagedThreadId}");
  var bw = (BackgroundWorker) sender;
  for (int i = 1; i &lt;= 100; i++)
  {
    if (bw.CancellationPending)
    {
      e.Cancel = true;
      return;
    }
    if (i%10 == 0)
    {
      bw.ReportProgress(i);
    }

    Sleep(TimeSpan.FromSeconds(0.1));
  }

  e.Result = 42;
}

static void Worker_ProgressChanged(object sender, ProgressChangedEventArgs e)
{
  WriteLine($"{e.ProgressPercentage}% completed. " +
    $"Progress thread pool thread id: {CurrentThread.ManagedThreadId}");
}

static void Worker_Completed(object sender, RunWorkerCompletedEventArgs e)
{
  WriteLine($"Completed thread pool thread id: {CurrentThread.ManagedThreadId}");
  if (e.Error != null)
  {
    WriteLine($"Exception {e.Error.Message} has occured.");
  }
  else if (e.Cancelled)
  {
    WriteLine($"Operation has been canceled.");
  }
  else
  {
    WriteLine($"The answer is: {e.Result}");
  }
}</pre></div></li><li class="listitem">Add the <a id="id150" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">var bw = new BackgroundWorker();
bw.WorkerReportsProgress = true;
bw.WorkerSupportsCancellation = true;

bw.DoWork += Worker_DoWork;
bw.ProgressChanged += Worker_ProgressChanged;
bw.RunWorkerCompleted += Worker_Completed;

bw.RunWorkerAsync();

WriteLine("Press C to cancel work");
do
{
  if (ReadKey(true).KeyChar == 'C')
  {
    bw.CancelAsync();
  }
}
while(bw.IsBusy);</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec90"/>How it works...</h2></div></div></div><p>When the program <a id="id151" class="indexterm"/>starts, we create an instance of a <code class="literal">BackgroundWorker</code> component. We explicitly state that we want our background worker to support cancellation and notifications on the operation's progress.</p><p>Now, this is where the most interesting part comes into play. Instead of manipulating with a thread pool and <a id="id152" class="indexterm"/>delegates, we use another C# idiom called <strong>events</strong>. An event represents a <em>source </em>of notifications and a number of <em>subscribers</em> ready to react when a notification arrives. In our case, we state that we will subscribe for three events, and when they occur, we <a id="id153" class="indexterm"/>call the corresponding <strong>event handlers</strong>. These are methods with a specially defined signature that will be called when an event notifies its subscribers.</p><p>Therefore, instead of organizing an asynchronous API in a pair of <code class="literal">Begin</code>/<code class="literal">End</code> methods, it is possible to just start an asynchronous operation and then subscribe to different events that could happen while this operation is executed. This approach is called an <strong>Event-based </strong><a id="id154" class="indexterm"/>
<strong>Asynchronous Pattern</strong> (<strong>EAP</strong>). It was historically the second attempt to structure asynchronous programs, and now, it is recommended to use TPL instead, which will be described in <a class="link" href="ch04.html" title="Chapter 4. Using the Task Parallel Library">Chapter 4</a>, <em>Using the Task Parallel Library</em>.</p><p>So, we subscribed to three events. The first of them is the <code class="literal">DoWork</code> event. A handler of this event will be called when a background worker object starts an asynchronous operation with the <code class="literal">RunWorkerAsync</code> method. The event handler will be executed on a thread pool, and this is the main operating point where work is canceled if cancellation is requested and where we provide information on the progress of the operation. At last, when we get the result, we set it to event arguments, and then, the <code class="literal">RunWorkerCompleted</code> event handler is called. Inside this method, we find out whether our operation has succeeded, there were some errors, or it was canceled.</p><p>Besides this, a <code class="literal">BackgroundWorker</code> component is actually intended to be used in <strong>Windows Forms </strong><a id="id155" class="indexterm"/>
<strong>Applications</strong> (<strong>WPF</strong>). Its implementation makes working with UI controls possible from a background worker's event handler <a id="id156" class="indexterm"/>code directly, which is very comfortable as compared to the interaction of worker threads in a thread pool with UI controls.</p></div></div></body></html>