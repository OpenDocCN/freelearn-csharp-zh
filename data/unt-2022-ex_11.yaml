- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Extending the Adventure Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展冒险游戏
- en: In [*Chapter 7*](B18347_07.xhtml#_idTextAnchor130), we added polish to the game
    by applying some simple VFX using post-processing effects (mainly Bloom) with
    the Universal RP, Shader Graph for a custom 2D shader to make specific parts of
    a sprite glow, 2D lights to highlight the player, and the Trail Renderer component
    for a quick VFX win on our bullet sprite.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18347_07.xhtml#_idTextAnchor130)中，我们通过应用一些简单的VFX（主要是Bloom）使用通用RP、Shader
    Graph为自定义2D着色器制作发光特定部分的精灵、2D灯光突出玩家，以及使用Trail Renderer组件在我们的子弹精灵上快速实现VFX，从而为游戏添加了润色。
- en: We then moved away from the player to give some much-needed attention to the
    enemy NPCs in the game by creating configurable enemies using a ScriptableObject
    architecture and introducing changing behaviors based on the state pattern as
    implemented via a simple FSM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将注意力从玩家转移到游戏中急需关注的敌人NPC上，通过使用ScriptableObject架构创建可配置的敌人，并引入基于状态模式的变化行为，实现了简单的有限状态机（FSM）。
- en: With the base functionality in place for the playable character and enemies
    with behaviors (mostly) set up, we can now move on to spawning enemies that attack
    the player and vice versa with a reusable health and damage system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在可玩角色和敌人（行为设置主要是）的基础功能到位后，我们现在可以继续添加攻击玩家的敌人以及反之亦然的敌人，使用可重用的生命值和伤害系统。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Health and inflicting damage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值和造成伤害
- en: Updating the player and enemy to use health
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新玩家和敌人使用生命值
- en: Enemy wave spawner
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人波生成器
- en: By the end of this chapter, you’ll be able to spawn enemies with simple health
    and damage systems – that will also be applicable for the player or any damageable
    objects in the game!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够生成具有简单生命值和伤害系统的敌人——这些系统也适用于游戏中的玩家或任何可伤害的对象！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along in this chapter with the same artwork created for the project
    in the book, download the assets from the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中为书中项目创建的相同艺术作品，请从以下GitHub仓库下载资源：
- en: '[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop, or a graphics program that can export layered Photoshop
    PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随自己的艺术作品，你需要使用Adobe Photoshop或能够导出分层Photoshop PSD/PSB文件的图形程序（例如，Gimp、MediBang
    Paint、Krita和Affinity Photo）创建类似的艺术作品。
- en: Health and inflicting damage
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命值和造成伤害
- en: At this point in our project, we have implemented much of what we specified
    in our GDD ([*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), *Table 4.1*) for
    our player character and enemies, but an essential system is still missing – health
    and damage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目进行到这一点时，我们已经实现了我们在GDD中指定的许多内容（[*第4章*](B18347_04.xhtml#_idTextAnchor079)，*表4.1*）为我们玩家角色和敌人，但一个重要的系统仍然缺失——生命值和伤害。
- en: In the coming sections, we’ll not only tackle adding health to the player and
    enemies with a reusable component but also finish the enemy’s attack behavior
    for inflicting damage on the player. The player can already fire a weapon that
    shoots a projectile, so we’ll add to the `Bullet` object we previously made in
    [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116), so that it can inflict damage,
    too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们不仅将解决为玩家和敌人添加可重用组件以使用生命值，还将完成敌人的攻击行为，对玩家造成伤害。玩家已经可以发射能够发射弹丸的武器，因此我们将向之前在[*第6章*](B18347_06.xhtml#_idTextAnchor116)中制作的`Bullet`对象添加功能，使其也能造成伤害。
- en: Health system
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命值系统
- en: We’ll develop a `HealthSystem` component to create a reusable component for
    `Player`, enemy, and other objects (e.g., in the environment – think a destructible
    crate). This health system will track health, take damage and/or heal, and can
    be added to any object. The remainder of the setup will include creating Interfaces
    that tie the system together and make the whole thing operate in an abstract way
    (i.e., reusable, extensible, maintainable).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个`HealthSystem`组件，为`Player`、敌人和其他对象（例如，在环境中——想想可破坏的箱子）创建一个可重用的组件。这个生命值系统将跟踪生命值，受到伤害和/或治疗，并且可以添加到任何对象。其余的设置将包括创建接口，将系统连接起来，并使整个系统以抽象的方式运行（即可重用、可扩展、可维护）。
- en: Like before, to clearly understand how we’ll create the health system, we’ll
    utilize a UML diagram based on the concepts we just described in the preceding
    paragraph. We can always refer back to this diagram at any point if needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前一样，为了清楚地了解我们将如何创建健康系统，我们将利用基于我们前面段落中描述的概念的UML图。如果需要，我们始终可以参考此图。
- en: '![Figure 8.1 – Health system class diagram](img/B18347_08_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 健康系统类图](img/B18347_08_1.jpg)'
- en: Figure 8.1 – Health system class diagram
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 健康系统类图
- en: 'Now, let’s dive into it! Create a new script in the `Assets/Scripts` folder
    and name it `HealthSystem`. This, being central to the UML diagram, will be the
    largest class we’ll be creating for the health system because, well, it *is* the
    health system! Since it will consist of the most code we’ll be writing in this
    section, we’ll break it up by first just declaring the member variables and a
    Unity message event, then proceed to flesh it out as we build up the system’s
    functionality:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨！在`Assets/Scripts`文件夹中创建一个新的脚本，并将其命名为`HealthSystem`。由于它是UML图的核心，因此将成为我们为健康系统创建的最大的类，因为，嗯，它**确实是**健康系统！由于它将包含我们将在本节中编写的最多代码，我们将首先仅声明成员变量和一个Unity消息事件，然后随着我们构建系统的功能，逐步完善它：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task list (IDE)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表（IDE）
- en: You’ve undoubtedly seen **// UNDONE:** in the preceding code and may have wondered
    what that’s all about. Well, we can use some tokens in our comments that our IDE
    will pick up, and it will generate a task list based on them! This feature helps
    us locate incomplete tasks and highlight things that need attention. Additionally,
    you can create your own custom tokens, which can be super useful for your specific
    needs (but you’ll need to check your specific IDE for support).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您无疑在先前的代码中看到了**// UNDONE:**，并可能想知道这是关于什么的。嗯，我们可以在我们的注释中使用一些标记，我们的IDE会识别它们，并基于它们生成任务列表！此功能帮助我们定位未完成的任务，并突出需要关注的事项。此外，您还可以创建自己的自定义标记，这对于您的特定需求可能非常有用（但您需要检查您的特定IDE是否支持）。
- en: 'Common tokens include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常见标记包括以下内容：
- en: '**//** **TODO:**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** **TODO:**'
- en: '**//** **UNDONE:**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** **UNDONE:**'
- en: '**//** **HACK:**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** **HACK:**'
- en: 'As you may be able to infer from the code we have so far – and if you’ve read
    the code comments – `HealthSystem` functions through collisions with other objects
    in the scene, such as projectiles from enemies or healing pickups. The other objects
    can either damage or heal the object with the `HealthSystem` component on it,
    and that will depend on the interface the object inherits from (from the UML diagram:
    `IDamage` and `IHeal`). Even the ground as an object can potentially damage the
    player if, let’s say, the player’s velocity is above a certain threshold when
    colliding.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从我们迄今为止的代码中推断出的一样——如果您已经阅读了代码注释——`HealthSystem`通过与其他场景中的对象发生碰撞来工作，例如来自敌人的投射物或治疗拾取物。其他对象可以损坏或治疗带有`HealthSystem`组件的对象，这取决于对象继承的接口（从UML图中：`IDamage`和`IHeal`）。甚至地面作为一个对象，如果玩家的速度在碰撞时超过某个阈值，也可能对玩家造成潜在伤害。
- en: 'Here’s the breakdown for the code added so far, plus the required additions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是迄今为止添加的代码的分解，以及所需添加的内容：
- en: 'Variable declarations will enable the core function of `HealthSystem`:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明将启用`HealthSystem`的核心功能：
- en: '`_healthMax` will specify the maximum health value for the object (i.e., the
    object we’re giving health by adding the `HealthSystem` component).'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_healthMax`将指定对象的最大健康值（即，通过添加`HealthSystem`组件赋予健康值的对象）。'
- en: '`_healthCurrent` will specify the current health of the object. As the object
    is either damaged or healed, this value will decrease or increase respectively.
    When the object is created in the scene, we should set the current health to the
    `_healthMax` value, which we’ll do now by adding the `Awake()` Unity message event
    as follows:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_healthCurrent`将指定对象的当前健康值。当对象被损坏或治疗时，此值将相应地减少或增加。当对象在场景中创建时，我们应该将当前健康值设置为`_healthMax`值，我们现在将通过添加以下`Awake()`
    Unity消息事件来完成此操作：'
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note here that the max health value (`_healthMax` is the serialized stored value)
    will be saved within the `Object with Health` Prefab, but imagine that you could
    also use a ScriptableObject, database, cloud-obtained (JSON) data, or even Unity’s
    own **Remote Config** (as part of **Unity Gaming Services**) so that we can change
    the max health value dynamically (and, with some of these methods, at any time
    without being dependent on distributing a new build of the game).
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，这里最大健康值（`_healthMax` 是序列化存储的值）将保存在 `Object with Health` 预制件中，但想象一下，你也可以使用
    ScriptableObject、数据库、从云端获取的（JSON）数据，甚至 Unity 的 **Remote Config**（作为 **Unity Gaming
    Services** 的一部分），这样我们就可以动态地更改最大健康值（并且，使用这些方法中的某些，可以在任何时间进行更改，而不依赖于分发游戏的新版本）。
- en: Additional reading | Unity Gaming Services
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity Gaming Services
- en: 'Remote Config: [https://unity.com/products/remote-config](https://unity.com/products/remote-config)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 远程配置：[https://unity.com/products/remote-config](https://unity.com/products/remote-config)
- en: '`OnTriggerEnter2D()` is where the magic happens! Collisions with other objects
    drive the health system, so we’ll use this Unity message event to handle the interactions
    when triggered from the physics system.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter2D()` 是魔法发生的地方！与其他对象的碰撞驱动健康系统，因此我们将使用这个 Unity 消息事件来处理从物理系统触发的交互。'
- en: 'Let’s add both damage and healing methods first, and then we’ll add the evaluations
    that call these methods next:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加伤害和治疗方法，然后我们再添加调用这些方法的评估：
- en: Note | Physical interactions
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 | 物理交互
- en: To have the objects physically respond to each other when colliding, use a **Collider**
    instance on the object that does not have **IsTrigger** enabled and respond to
    the collision using the **OnCollisionEnter2D()** Unity message event. For an object
    to not have a physical response when colliding, use a **Collider** instance with
    the **IsTrigger** field enabled and respond to the collision using the **OnTriggerEnter2D()**
    Unity message event.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使对象在碰撞时相互物理响应，请在没有启用 **IsTrigger** 的对象上使用 **Collider** 实例，并使用 **OnCollisionEnter2D()**
    Unity 消息事件来响应碰撞。要使对象在碰撞时没有物理响应，请使用具有启用 **IsTrigger** 字段的 **Collider** 实例，并使用 **OnTriggerEnter2D()**
    Unity 消息事件来响应碰撞。
- en: '`HandleDamageCollision()`, as the name implies, handles when we collide with
    another object that can damage us. We’ll pass in the collision parameter from
    when `OnTriggerEnter2D()` is called and, a future addition, the object that caused
    the damage (which is the object inheriting from the `IDamage` interface).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandleDamageCollision()`，正如其名所示，处理当我们与可以伤害我们的另一个对象碰撞时的情况。我们将传递当调用 `OnTriggerEnter2D()`
    时的碰撞参数，以及未来的添加，造成伤害的对象（该对象是从 `IDamage` 接口继承的）。'
- en: 'Add the following method to the `HealthSystem` class:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `HealthSystem` 类中：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Okay, yes, we’ve added another unfinished method to be called here that we’ll
    again add to later: `TakeDamage()`. We’re keeping the approach simple, taking
    one baby step at a time to build out the health system. The simple UML diagram
    may set an expectation that this will be easy. Well, it is – provided we tackle
    the implementation one step at a time.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好的，是的，我们在这里又添加了一个未完成的方法，我们将在稍后再次添加：`TakeDamage()`。我们正在保持方法简单，一次迈出一小步来构建健康系统。简单的
    UML 图可能设定了一个期望，这将是容易的。嗯，是的，前提是我们一步一步地处理实现。
- en: Our future selves will again tackle implementing the `TakeDamage()` method in
    the coming *Taking damage – IDamage interface* section when we also add the required
    `IDamage` interface.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的 *Taking damage – IDamage interface* 部分中，当我们添加所需的 `IDamage` 接口时，我们的未来自我将再次处理实现
    `TakeDamage()` 方法。
- en: '`HandleHealCollision()` is similar to the method for handling damage. We’ll
    add one for handling object healing. However, we’ll omit to pass in the `collision`
    object as a parameter this time; we’ll handle things a bit differently for healing
    compared to taking damage (as you’ll see in the coming *Healing – IHeal* *interface*
    section).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandleHealCollision()` 方法与处理伤害的方法类似。我们将添加一个用于处理对象治疗的方法。然而，这次我们将省略传递 `collision`
    对象作为参数；我们将对治疗的处理与受到伤害的处理有所不同（正如你将在接下来的 *Healing – IHeal* 接口部分中看到的）。'
- en: 'Add the following method to the `HealthSystem` class:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `HealthSystem` 类中：
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Okay, we’re piling on the *undone* methods to implement here, right?! Just like
    for `TakeDamage()`, we’ll have a method called for healing and changing the health
    value of the affected object.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好的，我们正在不断增加要在这里实现的方法，对吧？！就像 `TakeDamage()` 方法一样，我们将有一个用于治疗和改变受影响对象健康值的方法。
- en: And that’s the core of the `HealthSystem` class laid out. Let’s go ahead and
    add the required interfaces that our new health system classes inherit from and
    make things actually function!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`HealthSystem`类核心内容的布局。让我们继续添加我们新的健康系统类所继承的必需接口，并使事物真正运行起来！
- en: Interfaces required!
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要接口！
- en: There’s still more work to do before we add a `HealthSystem` component to any
    of our GameObjects, so let’s sort out and evaluate these damage and heal collisions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将`HealthSystem`组件添加到任何GameObject之前，还有很多工作要做，所以让我们整理并评估这些伤害和治疗的碰撞。
- en: 'The first part we’ll need interfaces for is the evaluation of the object that
    collides with the object that has health (e.g., a `Player` or enemy object with
    the `HealthSystem` component added). We’ll determine whether the colliding object
    can damage or heal – we’re replacing this first `UNDONE` token in our task list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要接口来评估与具有健康（例如，添加了`HealthSystem`组件的`Player`或敌人对象）发生碰撞的对象。我们将确定碰撞对象是否可以造成伤害或治疗——我们正在替换任务列表中的第一个`UNDONE`标记：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the UML diagram, we can see the object we want to evaluate is either inherited
    from `IDamage` or `IHeal`. Using interfaces to inherit from ensures that the required
    members exist in our classes that provide the intended functionality (i.e., the
    class must satisfy the “contract” of the interface).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从UML图中，我们可以看到我们想要评估的对象要么是从`IDamage`或`IHeal`继承的。使用接口继承确保我们的类中存在提供预期功能所需成员（即，类必须满足接口的“契约”）。
- en: Standard naming conventions dictate that when naming an interface, it should
    begin with the letter “*I*,” which offers us an opportunity to be a bit clever,
    or even memorable, in our naming and bring more readability to our codebase. So,
    for an object that can damage another object, we’ll name the interface `IDamage`
    – as in *I damage [an object]*. In the *Healing – IHeal interface* section, we’ll
    add additional interfaces for `IHaveHealth` and `IHeal` – see what we did there.
    Not that I’m being terribly clever here because *IDamage*, *IDamageable*, and
    *ITakeDamage* are pretty common interface names for game code for the same naming
    reasoning.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的命名约定规定，在命名一个接口时，它应该以字母“*I*”开头，这为我们提供了一个机会，在命名上变得稍微聪明一点，甚至可以让人印象深刻，从而提高代码库的可读性。因此，对于一个可以损坏另一个对象的实体，我们将接口命名为`IDamage`——就像*I
    damage [an object]*。在*治疗 – IHeal接口*部分，我们将添加额外的接口`IHaveHealth`和`IHeal`——看看我们在这里做了什么。并不是说我在这里非常聪明，因为`IDamage`、`IDamageable`和`ITakeDamage`对于游戏代码来说是非常常见的接口名称，原因相同的命名理由。
- en: 'Now, let’s update the `OnTriggerEnter2D()` method with the following `if` statements
    that include the interfaces (that we’ll create just after this step):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新`OnTriggerEnter2D()`方法，添加以下包含接口的`if`语句（我们将在这一步之后创建这些接口）：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s have a look at the following two evaluations and how they’ll provide
    the desired functionality for our health system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下两个评估以及它们如何为我们的健康系统提供所需的功能：
- en: '`collision.TryGetComponent<IDamage>()`: If you haven’t realized by now, I’m
    a fan of the *try get component pattern* – we can fail gracefully if the component
    doesn’t exist on the object we’re testing. And if it does exist, we conveniently
    have an `out` parameter that returns the component. Simples!'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collision.TryGetComponent<IDamage>()`：如果你到现在还没有意识到，我是一个*try get component模式*的粉丝——如果测试的对象上不存在该组件，我们可以优雅地失败。如果它存在，我们方便地有一个返回组件的`out`参数。简单！'
- en: Optimization note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 优化提示
- en: When using the **TryGetComponent** method, the method does not allocate memory
    on the heap when it doesn’t find a component. When it does find a component, it
    allocates memory only for the return value, not the component itself. This can
    be very beneficial for improving performance and reducing garbage collection,
    unlike the **GetComponent** methods, which can generate garbage and allocate more
    memory – both negatively impacting performance. By utilizing **TryGetComponent**
    instead, you can avoid unnecessary memory allocations and keep your game running
    smooth as butter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**TryGetComponent**方法时，如果找不到组件，该方法不会在堆上分配内存。当它找到组件时，它只为返回值分配内存，而不是组件本身。这可以非常有益于提高性能和减少垃圾回收，与可以生成垃圾并分配更多内存的**GetComponent**方法相比——两者都会对性能产生负面影响。通过利用**TryGetComponent**，你可以避免不必要的内存分配，并保持游戏运行得像黄油一样顺滑。
- en: So, what’s occurring here is, if the object we collided with has a component
    that inherits from `IDamage` on it, as in, *I damage this object*, then return
    the component and pass it into `HandleDamageCollision()` as a parameter along
    with the collision object itself. Peeking ahead a bit and referring back to the
    UML diagram, we can see that we’ll be implementing a `ProjectileDamage` component
    (e.g., on `Bullet`) that inherits from `IDamage`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里发生的情况是，如果我们碰撞的对象上有一个从 `IDamage` 继承的组件，即 *我伤害这个对象*，那么返回该组件并将其作为参数传递给 `HandleDamageCollision()`，同时传递碰撞对象本身。向前看一点并参考
    UML 图，我们可以看到我们将实现一个 `ProjectileDamage` 组件（例如，在 `Bullet` 上），它继承自 `IDamage`。
- en: '`collision.TryGetComponent<IHeal>()`: Ditto here. If the component we collided
    with has a component that inherits from `IHeal` on it, as in, *I heal this object*,
    then return the component and pass it into `HandleHealCollision()`. Again, peeking
    back at the UML diagram, we can see that we’ll be implementing a `PickupHeal`
    component (e.g., on a Water Diamond) that inherits from `IHeal`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collision.TryGetComponent<IHeal>()`：这里也是一样。如果碰撞的组件上有一个从 `IHeal` 继承的组件，即 *我治疗这个对象*，那么返回该组件并将其传递给
    `HandleHealCollision()`。再次参考 UML 图，我们可以看到我们将实现一个 `PickupHeal` 组件（例如，在 Water Diamond
    上），它继承自 `IHeal`。'
- en: Currently, if the object collided does neither damage nor heal, then we simply
    ignore the collision (of course, when colliding with anything, the obvious choice
    here is to do a camera shake!).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果碰撞的对象既不造成伤害也不治疗，那么我们只需忽略碰撞（当然，当与任何东西碰撞时，这里显然的选择是进行相机震动！）。
- en: Now that we have an implementation of the interface, we need to actually create
    them. These interfaces aren’t going to write themselves, so let’s start with `IDamage`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了接口的实现，我们需要实际创建它们。这些接口不会自己编写，所以让我们从 `IDamage` 开始。
- en: Taking damage – IDamage interface
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受伤 – IDamage 接口
- en: 'We’ve already seen the UML diagram (*Figure 8**.1*) and the `HandleDamageCollision()`
    code, where the `IDamage` interface is implemented but hasn’t been defined yet.
    I lied above, too: they can write themselves (at least partially) if we use the
    IDE’s refactoring tools – in `OnTriggerEnter2D()`, `IDamage` will have a red squiggly
    underline. Right-clicking on the word (or clicking anywhere on it and pressing
    *Alt + Enter* or *Ctrl + .* depending on your IDE) and selecting **Generate interface
    ‘IDamage’ in a new file** will generate the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 UML 图（*图 8**.1*）和 `HandleDamageCollision()` 代码，其中实现了 `IDamage` 接口，但尚未定义。我上面也撒了谎：如果我们使用
    IDE 的重构工具，它们可以（至少部分地）自己编写（在 `OnTriggerEnter2D()` 中，`IDamage` 将有一个红色的波浪线）。在单词上右键单击（或在其上单击并按
    *Alt + Enter* 或 *Ctrl + .* 取决于您的 IDE）并选择 **在新的文件中生成接口‘IDamage’** 将生成以下内容：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you decided not to use refactoring tools (why not?), create a new C# script
    in the `Assets/Scripts/Interfaces` folder and name it `IDamage`. Even if you did
    use the refactoring tools, you’ll likely still need to move the generated script
    into the `Assets/Scripts/Interfaces` folder to keep things tidy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定不使用重构工具（为什么不呢？），在 `Assets/Scripts/Interfaces` 文件夹中创建一个新的 C# 脚本，并将其命名为 `IDamage`。即使您使用了重构工具，您可能仍然需要将生成的脚本移动到
    `Assets/Scripts/Interfaces` 文件夹中，以保持整洁。
- en: 'Now, we’ll need a field for specifying the value for how much the object inheriting
    from `IDamage` will damage the object with health, so add a `DamageAmount` variable
    declaration like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个字段来指定从 `IDamage` 继承的对象对具有生命值的对象造成伤害的值，所以添加一个 `DamageAmount` 变量声明，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember, all members of an interface are public, so there is no need to add
    the accessor. We’ll set the property to be a getter only, though; we’ll only want
    the value to be read by other classes (no modification outside of the class inheriting
    the interface – all nice and hidden, how we like it).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，接口的所有成员都是公共的，因此不需要添加访问器。我们将属性设置为只读属性；我们只想让其他类读取值（不允许在继承接口的类之外修改 – 所有这些都很好，符合我们的喜好）。
- en: Now that we have our `IDamage` interface. We can use it for making projectiles
    and, well, just about any other object that hurt the player, by subtracting health
    when a collision occurs between the object and `HealthSystem`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `IDamage` 接口。我们可以用它来制作投射物，以及，嗯，几乎任何其他伤害玩家的对象，通过在对象与 `HealthSystem` 之间发生碰撞时减去生命值。
- en: 'Let’s fix up the `HandleDamageCollision()` method now back in our `HealthSystem`
    class by removing the `// UNDONE:` token comment and using `DamageAmount` for
    the parameter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `HealthSystem` 类中修复 `HandleDamageCollision()` 方法，通过移除 `// UNDONE:`
    注释并使用 `DamageAmount` 作为参数：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This sets us up nicely to have our IDE’s refactoring tools generate the `TakeDamage()`
    method for us, so let’s continue by doing just that. You know the drill: red squiggly
    line, etc., etc., then select **Generate** **method ‘TakeDamage.’**.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就为我们的 IDE 的重构工具生成 `TakeDamage()` 方法做好了准备，所以让我们继续这样做。你知道的：红色波浪线等，然后选择 **生成**
    **方法‘TakeDamage。’**。
- en: 'And here we are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们就到了这里：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I’m so sorry, more *undone* comments! Please don’t fret; with this very temporary
    instruction, we’ll fix up the code straight away. Fill in the method with the
    following statements:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常抱歉，有更多的 *未完成* 注释！请不要担心；通过这个非常临时的指令，我们将立即修复代码。在方法中填写以下语句：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first thing we do is update the current health value for the amount of damage
    received by subtracting `amount` from `_healthCurrent`. We’re getting some help
    from the `Mathf.Max()` function here so that the current health value will never
    dip below zero (keeping things positive).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是更新当前健康值，通过从 `_healthCurrent` 中减去 `amount` 来计算受到的伤害量。在这里，我们得到了 `Mathf.Max()`
    函数的帮助，这样当前健康值永远不会低于零（保持正值）。
- en: Additional reading | Unity documentation
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: '**Mathf.Max()**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mathf.Max()**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml)'
- en: 'Let’s uncomment our placeholder for the `HealthChanged()` method. Go ahead
    and create an empty method block for it, but completing this method will be a
    job for our future selves when we actually have some objects set up to enact the
    health change:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取消注释 `HealthChanged()` 方法的占位符。创建一个空的方法块，但完成此方法将是我们的未来自我在实际上有一些设置来执行健康变化时的任务：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll call this method anytime the health value has changed so we can evaluate
    the current health of the object and *do stuff* accordingly – such as notify other
    classes about the health value of the object changing or die/destroy if health
    reaches zero.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当健康值发生变化时，我们将调用此方法，这样我们就可以评估对象的当前健康状态并根据情况执行操作 – 例如通知其他类关于对象健康值的变化或如果健康值达到零则死亡/销毁。
- en: So, let’s get an object set up now that will inflict damage on the player.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们设置一个对象，该对象将对玩家造成伤害。
- en: ProjectileDamage component
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子弹伤害组件
- en: 'Create a new script called `ProjectileDamage` in the `Assets/Scripts` folder
    – this is a component we’ll add to our `Bullet` Prefab. To ensure this component
    will cause damage to our health system, it will implement the `IDamage` interface:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 文件夹中创建一个新的脚本名为 `ProjectileDamage` – 这是我们将添加到 `Bullet` 预制体的组件。为了确保此组件将对我们的健康系统造成伤害，它将实现
    `IDamage` 接口：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The public `DamageAmount int` variable is required to be declared to satisfy
    the `IDamage` interface contract – it’s also necessary for the health system to
    obtain the value for the amount of damage this projectile causes! `DamageAmount`
    is a public property because all interface members are public and cannot contain
    fields. Because C# properties are not serialized by Unity, to assign a value in
    the `Bullet` Prefab), we’ll encapsulate a private `_damageAmount` variable and
    decorate it with the `[SerializeField]` attribute. If you haven’t already guessed,
    this is the structure we’ll continue with throughout the remainder of the book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 公共 `DamageAmount int` 变量必须声明以满足 `IDamage` 接口合约 – 它对于健康系统获取此弹头造成的伤害量值也是必要的！`DamageAmount`
    是一个公共属性，因为所有接口成员都是公共的，并且不能包含字段。由于 C# 属性不会被 Unity 序列化，为了在 `Bullet` 预制体中分配值，我们将封装一个私有
    `_damageAmount` 变量，并用 `[SerializeField]` 属性装饰它。如果你还没有猜到，这就是我们将继续整本书的结构。
- en: 'When you’ve finished saving the script, open up the `Bullet` Prefab in `ProjectileDamage`
    to the root GameObject, as seen in the following figure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存完脚本后，打开 `Bullet` 预制体中的 `ProjectileDamage` 到根 GameObject，如图所示：
- en: '![Figure 8.2 – Bullet Prefab ProjectileDamage component](img/B18347_08_2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Bullet Prefab ProjectileDamage 组件](img/B18347_08_2.jpg)'
- en: Figure 8.2 – Bullet Prefab ProjectileDamage component
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 子弹预制体中的 Bullet Prefab ProjectileDamage 组件
- en: When we declared `_damageAmount` in the preceding code, we set a default value
    of `5`, which you can already see as the assigned value in the **Inspector** window.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中声明 `_damageAmount` 时，我们将其默认值设置为 `5`，你已经在 **检查器** 窗口中看到的分配值中看到了这一点。
- en: Okay, we can damage stuff now; great! But that’s not really fair if objects
    such as our player cannot also have a chance to heal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在可以伤害东西了；太棒了！但如果我们的玩家等对象没有机会治疗，那就真的不太公平了。
- en: Healing – IHeal interface
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 治疗 – IHeal接口
- en: We’ve taken care of the left side of the UML diagram (*Figure 8**.1*) for our
    health system, so now, similar to `IDamage`, we need to define the `IHeal` interface
    to take care of the right side. We’ll also create a component to add to objects
    that can apply healing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了UML图（*图8**.1*）的左侧，所以现在，类似于`IDamage`，我们需要定义`IHeal`接口来处理右侧。我们还将创建一个组件，可以添加到可以应用治疗的对象上。
- en: 'Back in the `OnTriggerEnter2D()` method now, let’s repeat the steps performed
    for creating the `IDamage` interface but for `IHeal`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`OnTriggerEnter2D()`方法中，让我们重复创建`IDamage`接口时执行的步骤，但这次是为`IHeal`：
- en: 'Create the `IHeal` interface script (have your IDE generate it) in the `Assets/Scripts/Interfaces`
    folder and add the `HealAmount` variable for, you guessed it, specifying the amount
    of healing power:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts/Interfaces`文件夹中创建`IHeal`接口脚本（由您的IDE生成），并为指定治疗量添加`HealAmount`变量：
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the placeholder `HandlHealCollision()` method, specifying the `HealAmount`
    value from the interface as the parameter when calling `ApplyHealing()`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新占位符`HandlHealCollision()`方法，在调用`ApplyHealing()`时指定接口中的`HealAmount`值作为参数：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, create the `ApplyHealing()` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`ApplyHealing()`方法：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing we do is update the current health value for the amount of healing
    received by adding `amount` to `_healthCurrent`. Just like when we took damage,
    we’re getting some help from a `Mathf` function here again, but it’s `Mathf.Min()`
    this time, so that the current health value will never exceed the object’s maximum
    health value (no cheating).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先更新当前健康值，通过将`amount`添加到`_healthCurrent`来增加治疗量。就像我们受到伤害时一样，我们再次从`Mathf`函数中获得一些帮助，但这次是`Mathf.Min()`，这样当前健康值就不会超过对象的最高健康值（没有作弊）。
- en: Additional reading | Unity documentation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity文档
- en: '**Mathf.Min**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mathf.Min**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml)'
- en: And, like with damage, we’ll create a healing component that will add health
    when a collision occurs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像伤害一样，我们将创建一个治疗组件，当发生碰撞时将增加健康值。
- en: PickupHeal component
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PickupHeal组件
- en: 'Create a new script called `PickupHeal` in the `Assets/Scripts` folder:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中创建一个名为`PickupHeal`的新脚本：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Same as with the `ProjectileDamage` script, we can see that we’ve inherited
    from `IHeal` (to ensure healing with our health system) and implemented the `IHeal`
    interface by defining `HealAmount`. We’ve also encapsulated `HealAmount` by declaring
    a private `_healAmount` variable serialized so we can set the value in the `10`
    is also assigned here).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ProjectileDamage`脚本类似，我们可以看到我们已从`IHeal`继承（以确保使用我们的健康系统进行治疗）并通过定义`HealAmount`实现了`IHeal`接口。我们还通过声明一个序列化的私有`_healAmount`变量来封装`HealAmount`，这样我们就可以在`10`处设置值）。
- en: Note on code architecture
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码架构的说明
- en: If you find yourself needing many different types for damage or heal components,
    you can create a new base class for each that implements the interface, so you
    aren’t repeating yourself with the event and method to invoke. The current implementation
    suits our current needs, so you can also leave off here, or challenge yourself
    to create both a **DamageBase** and **HealBase** abstract class that **ProjectileDamage**
    and **PickupHeal** inherit from, respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己需要许多不同类型的伤害或治疗组件，可以为每个创建一个新的基类，实现接口，这样您就不必重复事件和调用的方法和函数。当前的实现适合我们的当前需求，因此您也可以在这里停止，或者挑战自己创建一个**DamageBase**和**HealBase**抽象类，分别由**ProjectileDamage**和**PickupHeal**继承。
- en: '`PickupHeal` is a component we’ll add to… hmmm… what object will we add it
    to? Let’s consult our GDD ([*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), *Table
    4.2*):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickupHeal`是一个我们将添加到…嗯…我们将添加到哪个对象上？让我们参考我们的GDD（[*第4章*](B18347_04.xhtml#_idTextAnchor079)，*表4.2*）：'
- en: '| **What is a buff mechanic for the player in the** **adventure game?** | The
    player will be able to collect energy shards (water diamonds) scattered throughout
    the environment that, when a certain quantity has been collected, will give a
    power-up state to all of the weapons (increasing damage dealt). |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **在冒险游戏中，玩家如何获得增益机制？** | 玩家将能够收集散布在环境中的能量碎片（水钻石），当收集到一定数量的碎片时，将使所有武器获得增强状态（增加造成的伤害）。|'
- en: Table 8.1 – Adding a buff to the GDD
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – 在GDD中添加增益
- en: 'Sounds great. Well, actually, I think we can do better. Let’s revise; after
    all, the GDD is a living document:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来不错。实际上，我认为我们可以做得更好。让我们修订；毕竟，GDD是一个活文档：
- en: '| **What is a buff mechanic for the player in the** **adventure game?** | Players
    can gather energy shards (water diamonds) as they explore the game world. The
    player can later use the collected energy to power up weapons (increase damage
    dealt) or heal the player, offering more strategic options for the player while
    navigating the game’s challenges. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **在冒险游戏中，玩家如何获得增益机制？** | 玩家在探索游戏世界时可以收集能量碎片（水钻石）。玩家可以稍后使用收集到的能量来增强武器（增加造成的伤害）或治疗自己，为玩家在导航游戏挑战时提供更多策略选择。|'
- en: Table 8.2 – Revising the buff in the GDD
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – 修订GDD中的增益
- en: Better! Allowing players to choose between using energy shards to power up weapons
    or to heal themselves creates a risk-versus-reward strategy in the game. To make
    the mechanic meaningful to the player, a game designer must consider the approach
    carefully, especially if the choice is only sometimes clear!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更好！允许玩家在使用能量碎片为武器充电或治疗自己之间做出选择，这为游戏创造了一种风险与回报的策略。为了使这种机制对玩家有意义，游戏设计师必须仔细考虑这种方法，尤其是如果选择只有在某些时候才清晰的话！
- en: For now, let’s just create an object that will heal the player when picked up.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们只创建一个当拾取时将治疗玩家的对象。
- en: Creating a water diamond pickup
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建水钻石拾取
- en: 'Let’s use the water diamond from the artwork provided at the following link:
    [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下链接提供的艺术品中的水钻石：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets)。
- en: '![Figure 8.3 – Water diamond artwork](img/B18347_08_3.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 水钻石艺术品](img/B18347_08_3.jpg)'
- en: Figure 8.3 – Water diamond artwork
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 水钻石艺术品
- en: 'To create our water diamond pickup Prefab based on the water diamond artwork,
    and as a refresher, follow these steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据水钻石的艺术作品创建我们的水钻石拾取预制件，并且作为一个提醒，请按照以下步骤操作：
- en: Import the artwork to the `Assets/Sprites/Pickups` folder. (I love how this
    water diamond art came out, by the way; nice job, Nica!)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将艺术品导入到`Assets/Sprites/Pickups`文件夹。（顺便说一句，我喜欢这个水钻石艺术作品的效果；做得好，Nica！）
- en: In the **Project** window, select the water diamond sprite and, in the **Inspector**
    window, use **Sprite Editor** to set the provided normal map as the secondary
    texture.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，选择水钻石精灵，并在**检查器**窗口中，使用**精灵编辑器**将提供的正常图设置为次级纹理。
- en: Drag the water diamond sprite into the `Water Diamond (Heal)` (remember, you
    can easily parent a GameObject in the **Hierarchy** window by right-clicking on
    it and selecting **Create** **Empty Parent**).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将水钻石精灵拖动到`Water Diamond (Heal)`（记住，你可以在**层次结构**窗口中通过右键单击它并选择**创建** **空父对象**来轻松地将GameObject设置为父对象）。
- en: Add a `CapsuleCollider2D` instance to the parent object to enable physics (precisely,
    collision detection).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CapsuleCollider2D`实例添加到父对象，以启用物理（确切地说，是碰撞检测）。
- en: Use the **Edit Collider** button to enable resizing of the collider around the
    diamond shape, as seen in the following figure.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**编辑碰撞器**按钮启用围绕钻石形状的碰撞器调整大小，如图所示。
- en: '![Figure 8.4 – Water diamond healing Prefab](img/B18347_08_4.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 水钻石治疗预制件](img/B18347_08_4.jpg)'
- en: Figure 8.4 – Water diamond healing Prefab
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 水钻石治疗预制件
- en: Add the `PickupHeal` component to the Prefab root (also seen in *Figure 8**.4*).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PickupHeal`组件添加到预制件根目录（也见*图8**.4*）。
- en: Lastly, drag the parent object from the `Assets/Prefabs` folder.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从`Assets/Prefabs`文件夹中拖动父对象。
- en: 'For a quick hack to bump up the visuals, you can cheat a bit (as indie game
    devs, it’s all about cheating to save time anywhere we can) and reuse the material
    we created in [*Chapter 7*](B18347_07.xhtml#_idTextAnchor130), for the bullet.
    Follow these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速提升视觉效果，你可以稍微作弊一下（作为独立游戏开发者，我们可以在任何地方节省时间，所以作弊是关键）并重用我们在[*第7章*](B18347_07.xhtml#_idTextAnchor130)中为子弹创建的材料。按照以下步骤操作：
- en: In the `Assets/Materials` folder, duplicate the `Bullet 1` material and rename
    it `Water` `Diamond 1`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Materials`文件夹中，复制`Bullet 1`材质并将其重命名为`Water` `Diamond 1`。
- en: Assign the water diamond sprite to the `MainTex` channel but leave the `bullet1_emission`
    map.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将水钻石精灵分配给`MainTex`通道，但保留`bullet1_emission`贴图。
- en: Assign this new material to the **Sprite Renderer Material** field on the **Water
    Diamond 1** Prefab’s graphic.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此新材质分配给**Water Diamond 1**预制件的图形上的**Sprite Renderer Material**字段。
- en: Adjust the HDR color and intensity for desired visuals.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整HDR颜色和强度以获得所需的视觉效果。
- en: Our pickup Prefab is looking good. Yay!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的拾取预制件看起来不错。太棒了！
- en: We need to add one last bit of functionality for this Prefab to be a pickup
    for the player. It has to disappear once “collected,” and we can do that by revisiting
    an existing reusable component we previously made – along with a new one.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个预制件添加最后一点功能，使其成为玩家的拾取对象。它必须在“收集”后消失，我们可以通过回顾之前制作的现有可重用组件以及一个新的组件来实现这一点。
- en: Composition for pickup behavior
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拾取行为组合
- en: As previously introduced, being able to bring multiple objects together to achieve
    a desired behavior or functionality is a form of **composition**. To state another
    way, we’ll combine two or more reusable components, each responsible for a specific
    aspect of an object’s behavior or appearance. This will allow us to create a new
    behavior directly in the editor without introducing new code – this is especially
    valuable for designers on your team where experimentation can generate new ideas
    independently.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，能够将多个对象组合在一起以实现所需的行为或功能是一种**组合**形式。换一种说法，我们将结合两个或更多可重用组件，每个组件负责对象行为或外观的特定方面。这将允许我们在编辑器中直接创建新的行为，而无需引入新代码——这对你的团队中的设计师来说特别有价值，因为实验可以独立产生新的想法。
- en: Let’s start by adding the `TriggeredEvent` component to the root `gameObject`
    of the `OnTriggered` event that fires when the player collides with the pickup
    object. We want to destroy the pickup, but there isn’t a built-in way to do that.
    However, it’s easily solved.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向`OnTriggered`事件的根`gameObject`添加`TriggeredEvent`组件开始，该事件在玩家与拾取对象碰撞时触发。我们想要销毁拾取对象，但没有内置的方法来做这件事。然而，这很容易解决。
- en: Destroyer component
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 销毁器组件
- en: 'To destroy the pickup, all we need is an additional component serving as a
    single-purpose but reusable component. This component will be added to the existing
    composition for the pickup behavior. To clarify, we need to destroy the pickup
    object by calling the `TriggeredEvent.OnTriggered` event. So, first, make a new
    script named `Destroyer` in the `Assets/Scripts` folder:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁拾取对象，我们只需要一个额外的组件，作为单一用途但可重用的组件。这个组件将被添加到现有的拾取行为组合中。为了明确，我们需要通过调用`TriggeredEvent.OnTriggered`事件来销毁拾取对象。所以，首先，在`Assets/Scripts`文件夹中创建一个新的名为`Destroyer`的脚本：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Simple. A public method that can be called that destroys the object – `DestroyMe()`.
    I’ve added the option for setting a delay before destroying the object – yes,
    I’m confident this is a typical enough use case, it literally only took seconds
    to add, and I’ll defend that I’m not violating the YAGNI principle!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 简单。一个公开的方法，可以调用它来销毁对象——`DestroyMe()`。我添加了在销毁对象前设置延迟的选项——是的，我确信这是一个足够典型的用例，实际上只花了几秒钟就添加了，我将捍卫这不是违反YAGNI原则！
- en: YAGNI | “You ain’t gonna need it”
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI | “你不需要它”
- en: This principle states that a programmer should only add functionality if necessary.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则指出，程序员只有在必要时才应该添加功能。
- en: Another one I like is **DRY** (**don’t repeat yourself**), which is simply directed
    at reducing repetition (a basic example would be if you find yourself writing
    the same code more than once, extract it to a method or abstraction).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我还喜欢的是**DRY**（**不要重复自己**），它简单地说就是减少重复（一个基本例子是如果你发现自己多次编写相同的代码，将其提取到方法或抽象中）。
- en: 'Go ahead and add `Destroyer` to the root of the `Water Diamond (Heal)` Prefab
    so we can wire things up in the **Inspector** window:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 继续将`Destroyer`添加到`Water Diamond (Heal)`预制件的根目录，这样我们就可以在**检查器**窗口中连接东西了：
- en: Set the execution state dropdown to **Runtime Only**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将执行状态下拉菜单设置为**仅运行时**。
- en: Drag the `Destroyer` component to the object field (using its title area).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Destroyer`组件拖动到对象字段（使用其标题区域）。
- en: In the function selection dropdown, select **Destroyer** | **DestroyMe( )**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数选择下拉菜单中，选择**Destroyer** | **DestroyMe()**。
- en: I’d leave `0` for this pickup, but for other behavior, you may want to adjust
    (see, you have that option!). And, yes, although `Destroy()` has a second parameter
    to delay destroying the object, the `Destroyer` class serves as a general example
    for introducing an execution delay.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我会为这个拾取物留 `0`，但对于其他行为，你可能需要调整（看，你有这个选项！）。而且，虽然 `Destroy()` 有一个用于延迟销毁对象的第二个参数，但
    `Destroyer` 类作为一个引入执行延迟的通用示例。
- en: '![Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)](img/B18347_08_5.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 将 DestroyMe 分配给 OnTriggered (UnityEvent)](img/B18347_08_5.jpg)'
- en: Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 将 DestroyMe 分配给 OnTriggered (UnityEvent)
- en: Okay, so let’s talk about what objects can affect the health of other objects
    – right now, it’s like the Wild West out there, with everything able to damage
    everything else. We can’t have any of that going on, so let’s put on a mask to
    start getting everyone to behave properly – a LayerMask, that is.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么让我们谈谈哪些对象可以影响其他对象的健康——现在，那里就像野西一样，任何东西都能伤害任何其他东西。我们不能让这种情况发生，所以让我们戴上掩码，开始让每个人都表现得体——这是一个
    LayerMask。
- en: Controlling what damages/heals what
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制哪些伤害/治疗哪些
- en: The problem we have to solve here is finding a simple way to specify what objects
    can damage other objects – this is essential for reinforcing the game’s design.
    We’ve solved this problem before by using a **tag** and also a **LayerMask**.
    My preference, generally, is to use tags only when comparing a single type of
    object in code and using a LayerMask for sorting out several different types of
    objects, with the added bonus of a LayerMask being designer friendly since the
    assignment is made in the **Inspector** window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须解决的问题是找到一个简单的方法来指定哪些对象可以伤害其他对象——这对于加强游戏设计至关重要。我们之前通过使用 **标签** 和 **LayerMask**
    解决了这个问题。我通常的偏好是仅在代码中比较单个类型的对象时使用标签，并使用 LayerMask 来区分几种不同类型的对象，LayerMask 的额外好处是它对设计师友好，因为分配是在
    **检查器** 窗口中进行的。
- en: What damages
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么造成伤害
- en: The time to evaluate the objects is at the time of the collision, so we will
    update the *handle collision* methods in `HealthSystem` accordingly. But first,
    we need to define the `LayerMask` variables in the right places, starting with
    damage.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 评估对象的时间是在碰撞时，因此我们将相应地更新 `HealthSystem` 中的 `handle collision` 方法。但首先，我们需要在正确的位置定义
    `LayerMask` 变量，从伤害开始。
- en: 'Add a `DamageMask` declaration to the `IDamage` interface:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `IDamage` 接口中添加 `DamageMask` 声明：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, add the following variables so we can use `DamageMask` and satisfy the
    existing contract we have in `ProjectileDamage` for the interface implementation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加以下变量，以便我们可以使用 `DamageMask` 并满足我们在 `ProjectileDamage` 中为接口实现所拥有的现有合约：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here is the encapsulation pattern again (told you!) for the `_damageMask` variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `_damageMask` 变量的封装模式（告诉过你！）。
- en: 'We can now revise the `HandleDamageCollision()` method in `HealthSystem` to
    implement the mask check:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修订 `HealthSystem` 中的 `HandleDamageCollision()` 方法以实现掩码检查：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `if` statement should look a bit familiar; it’s the same *is this object’s
    layer in the LayerMask?* evaluation we used for our `Bullet` back in [*Chapter
    6*](B18347_06.xhtml#_idTextAnchor116). So, if the `ProjectileDamage.DamageMask`
    includes the object with health’s layer, only then will `TakeDamage()` be called.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `if` 语句看起来有点熟悉；这是我们之前在 [*第 6 章*](B18347_06.xhtml#_idTextAnchor116) 中用于我们的
    `Bullet` 的相同的 *这个对象是否在 LayerMask 中？* 评估。所以，如果 `ProjectileDamage.DamageMask` 包含具有健康层的对象，那么才会调用
    `TakeDamage()`。
- en: Damage bad. Heal good. Let’s do the same for what can heal.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 伤害是坏事。治疗是好事。让我们为可以治疗的事物做同样的事情。
- en: What heals
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么可以治疗
- en: 'We’re going to repeat what we did for what damages, so add the `LayerMask`
    variable `HealMask` to the `IHeal` interface:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复我们为造成伤害所做的事情，所以将 `LayerMask` 变量 `HealMask` 添加到 `IHeal` 接口：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the updated `IHeal` interface contract in `PickupHeal` – encapsulating
    the `_healMask` variable:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PickupHeal` 中实现更新的 `IHeal` 接口合约 – 封装 `_healMask` 变量：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As an exception to repeating what we did in the `HandleDamageCollision()` method,
    let’s not repeat ourselves here by also adding the layer mask check code to `HealthSystem.HandleHealCollision()`;
    instead, let’s extract the layer mask evaluation to a method, and we’ll give it
    a nice, easy-to-understand name: `IsLayerInLayerMask()` (using `Is` to start the
    name with makes it obvious this will return a bool `true` or `false` value, no?):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对在 `HandleDamageCollision()` 方法中重复我们的做法的例外，我们不要在这里重复自己，通过也将层掩码检查代码添加到 `HealthSystem.HandleHealCollision()`；相反，我们将层掩码评估提取到一个方法中，我们将给它一个非常好、易于理解的名字：`IsLayerInLayerMask()`（使用
    `Is` 开头使它明显将返回一个布尔 `true` 或 `false` 值，不是吗？）：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Utility methods (C#)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实用方法（C#）
- en: You’ll likely need this **IsLayerInLayerMask()** check in other classes, so
    consider creating a new static class for utility methods such as this one that
    can be used from anywhere in the code base.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在其他类中需要这个 **IsLayerInLayerMask()** 检查，所以考虑创建一个新的静态类，用于此类实用方法，可以从代码库的任何地方使用。
- en: 'Or, for action on specific types, consider adding an **extension** **method**:
    [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于特定类型的操作，考虑添加一个 **扩展** **方法**：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).
- en: 'Let’s update `HandleHealCollision()` and use our new utility LayerMask check
    method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `HandleHealCollision()` 并使用我们新的实用工具层掩码检查方法：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Better readability for the win! Don’t forget to return to the `HandleDamageCollision()`
    method to refactor the LayerMask evaluation to use the new `IsLayerInLayerMask()`
    method too!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的可读性！别忘了回到 `HandleDamageCollision()` 方法，重构层掩码评估以使用新的 `IsLayerInLayerMask()`
    方法！
- en: Optimization note | Physics 2D
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 优化笔记 | 物理二维
- en: We can also control the physics interactions between objects by specifying what
    collisions are processed by their layer using the physics Layer Collision Matrix
    (**Edit** | **Project Settings** | **Physics 2D**, select the **Layer Collision**
    **Matrix** tab).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过指定由其层处理的碰撞来控制对象之间的物理交互（**编辑** | **项目设置** | **物理二维**，选择 **层碰撞** **矩阵**
    选项卡）。
- en: In this section, we created our health system that any object in the game can
    use for receiving damage and healing – it also provides a method for handling
    the final death/destruction of the object. You learned how to use interfaces to
    tie everything together in an extensible way by not relying on concrete class
    references.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个健康系统，任何游戏中的对象都可以使用它来接收伤害和恢复——它还提供了一个处理对象最终死亡/破坏的方法。您学习了如何通过不依赖于具体类引用的方式来使用接口以可扩展的方式将一切联系在一起。
- en: We haven’t added our new `HealthSystem` to any of our game’s objects yet. Let’s
    do that in the next section, starting with the player.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有将我们的新 `HealthSystem` 添加到我们游戏的任何对象中。让我们在下一节中这样做，从玩家开始。
- en: Updating the player and enemy to use health
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新玩家和敌人以使用健康
- en: Not only `Player` and enemy objects but any object can be set up to use `HealthSystem`.
    It’s barely an inconvenience; in fact, the object simply needs to implement the
    `IHaveHealth` interface.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅 `Player` 和敌人对象，任何对象都可以设置为使用 `HealthSystem`。这几乎不是什么不便；实际上，对象只需实现 `IHaveHealth`
    接口。
- en: Assigning the object with health – IHaveHealth interface
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配具有健康的对象——IHaveHealth 接口
- en: 'Back in the health system UML diagram (*Figure 8**.1*), we see at the bottom
    that the object having health will implement the `IHaveHealth` interface (again,
    some meaningful naming here). Create a new file named `IHaveHealth` in the `Assets/Scripts/Interfaces`
    folder:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在健康系统 UML 图 (*图 8**.1*) 中，我们看到底部有一个具有健康的对象将实现 `IHaveHealth` 接口（在这里，一些有意义的命名）。在
    `Assets/Scripts/Interfaces` 文件夹中创建一个名为 `IHaveHealth` 的新文件：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We don’t yet have a class for the `Player` object, only `PlayerController`.
    We don’t want to add health to something named `controller` because it wouldn’t
    make sense considering the single-responsibility principle – and the controller’s
    only concern is movement. Let’s fix that now by creating a script named `Player`
    in the `Assets/Scripts` folder:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有为 `Player` 对象添加一个类，只有 `PlayerController`。我们不希望将健康添加到名为 `controller` 的东西上，因为这不符合单一职责原则——并且控制器的唯一关注点是移动。让我们现在通过在
    `Assets/Scripts` 文件夹中创建一个名为 `Player` 的脚本来解决它：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make sure it implements `IHaveHealth`. You can use the IDE’s refactoring tools
    again here. `IHaveHealth` should have the ever-so-helpful red squiggly underline
    – so, use the IDE refactoring to *implement interface* on it, and you will get
    the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它实现了 `IHaveHealth`。您可以使用 IDE 的重构工具再次在这里。`IHaveHealth` 应该有那个非常有用的红色波浪下划线——所以，使用
    IDE 重构在它上面 *实现接口*，您将得到以下内容：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Until we decide what actions to perform for these methods, we’ll leave it as
    is for now. You will get a reminder in the `throw` indicates an exception has
    occurred while the program is running – in this case, `NotImplementedException:
    The method or operation is` `not implemented`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们决定对这些方法执行什么操作之前，我们现在将其保持原样。您将在 `throw` 中收到提醒，表示在程序运行时发生了异常——在这种情况下，`NotImplementedException:
    The method or operation is` `not implemented`。'
- en: Caution when using throw
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用throw时的注意事项
- en: 'Be warned, however: throwing these exceptions will cause program execution
    in the calling method to stop – meaning any statements that follow **HealthChanged()**
    will not be executed! If unsure, replace the **throw** statements with something
    such as **Debug.LogError("Player.HealthChanged() has not** **been implemented!");**.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意：抛出这些异常将导致调用方法中的程序执行停止——这意味着在**HealthChanged()**之后的任何语句都不会被执行！如果不确定，可以将**throw**语句替换为类似**Debug.LogError("Player.HealthChanged()
    has not** **been implemented!");**的内容。
- en: 'Do exactly the same for `Enemy`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Enemy`也做完全相同的操作：
- en: Create a new `Enemy` script in the `Assets/Scripts` folder.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中创建一个新的`Enemy`脚本。
- en: Add `IHaveHealth` to the class declaration.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IHaveHealth`添加到类声明中。
- en: Implement the `IHaveHealth` interface methods.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口`IHaveHealth`的方法。
- en: 'The last step is to add the components to their respective objects: adding
    `Player` to the `Player` Prefab and `Enemy` to both enemy Prefabs. Of course,
    they also both get `HealthSystem` added, as seen here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将组件添加到相应的对象中：将`Player`添加到`Player`预制体中，将`Enemy`添加到所有敌人预制体中。当然，它们也都会添加`HealthSystem`，如图所示：
- en: '![Figure 8.6 – Player and Enemy Prefabs with health](img/B18347_08_6.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 具有健康的玩家和敌人预制体](img/B18347_08_6.jpg)'
- en: Figure 8.6 – Player and Enemy Prefabs with health
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 具有健康的玩家和敌人预制体
- en: Initial values for max health are just initial values for testing. Playtesting
    will determine what values they’ll eventually land on, depending on difficulty
    and balanced gameplay. You got this!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最大健康值的初始值只是测试的初始值。游戏测试将确定它们最终将落在什么值上，这取决于难度和平衡的游戏玩法。你做到了！
- en: Now that we have objects with health, we have one final part of our `HealthSystem`
    in need of completion – processing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了具有健康属性的对象，我们`HealthSystem`的最后一个部分也需要完成——处理健康变化。
- en: Process changes to health
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理健康变化
- en: 'To finish up our fully functioning `HealthSystem`, we just need to process
    the changes to health for our objects that, yeah, have health. Back in our `HealthSystem`
    class, add the variable that will hold the reference to the object with health
    and get the object reference in `Awake()` using a `GetComponent()` call:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们完全功能的`HealthSystem`，我们只需要处理具有健康属性的对象的健康变化。回到我们的`HealthSystem`类中，添加一个将持有具有健康属性的对象引用的变量，并在`Awake()`中使用`GetComponent()`调用获取对象引用：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As our future selves now, we’ll revisit the `HealthChanged()` method and squash
    those final lingering `UNDONE` token comments! We’ll use a null check (`if` statement)
    to ensure we have a sibling component on this GameObject that implements the `IHaveHealth`
    interface. We’ll give ourselves a warning in the console if we don’t (and use
    a `return` statement as a sort of cancellation not to execute any code that follows),
    and proceed to process the health change otherwise:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们未来的自己，我们将重新审视`HealthChanged()`方法，并消除那些最后的残留`UNDONE`标记注释！如果GameObject上没有实现`IHaveHealth`接口的兄弟组件，我们将在控制台中发出警告（并使用`return`语句作为取消执行后续代码的一种方式），否则继续处理健康变化：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With that, our health system is complete! It allows the addition of health to
    any object and gives the ability for any object to cause damage or heal without
    any concrete class references! Interfaces for the win!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的健康系统就完整了！它允许将健康添加到任何对象中，并赋予任何对象造成伤害或治愈的能力，而无需任何具体的类引用！接口获胜！
- en: 'We covered much territory creating the health system and wrote lots of code
    back and forth in several classes, so don’t forget that you can always refer to
    the completed project code for this chapter on the book’s GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建健康系统时，我们覆盖了很多领域，并在几个类之间来回编写了很多代码，所以不要忘记，你始终可以参考书中GitHub仓库中本章的完整项目代码：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Keeping with our composition pattern, let’s quickly look at how we can set up
    the ability to easily add different behaviors (i.e., components) when interactions
    with `HealthSystem` occur.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的组合模式，让我们快速看看我们如何设置在`HealthSystem`交互时轻松添加不同行为（即组件）的能力。
- en: Adding behavior with UnityEvent
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用UnityEvent添加行为
- en: We’ve used `UnityEvent` before, for the `TriggeredEvent` component back in [*Chapter
    4*](B18347_04.xhtml#_idTextAnchor079). It’s flexible, in that listeners can be
    registered by code or assigned in the **Inspector** window (you already know I’m
    a fan of this one), so it will be a perfect use case for our needs here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用过 `UnityEvent`，用于 *第 4 章* 中提到的 `TriggeredEvent` 组件（[B18347_04.xhtml#_idTextAnchor079]）。它是灵活的，因为监听器可以通过代码注册或分配在
    **检查器** 窗口中（你知道我是个粉丝），所以它将是我们需求的完美用例。
- en: 'Only a few additions are required to add a `UnityEvent` instance that will
    be invoked when we handle the collisions for `IDamage` and `IHeal`. Let’s start
    by adding a method declaration to the interfaces:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 仅需要添加几个 `UnityEvent` 实例，以便在处理 `IDamage` 和 `IHeal` 的碰撞时调用。让我们首先向接口添加一个方法声明：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see in the differences in the declarations, we’ll change things up
    just a bit with each implementation. `DoDamage()` will pass two parameters for
    collision and whether the object is affected by the collision (as in, did it just
    collide or was it affected by the damage?). We can use this bool to alter things
    such as the visual effect (e.g., small versus a sizeable varying particle effect),
    where `DoHeal()` will just pass in the object that is being healed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在声明中的差异所看到的，我们将在每个实现中稍作调整。`DoDamage()` 将传递两个参数，用于碰撞以及对象是否受到碰撞的影响（例如，它刚刚发生碰撞还是受到了伤害的影响？）。我们可以使用这个布尔值来改变诸如视觉效果（例如，小粒子效果与可观的粒子效果）等事物，而
    `DoHeal()` 则只需传递正在被治愈的对象。
- en: 'Now let’s implement the changes to the interfaces, starting with damage in
    the `ProjectileDamage` class. Add the `UnityEvent` and `DoDamage()` methods:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现接口的更改，从 `ProjectileDamage` 类中的伤害开始。添加 `UnityEvent` 和 `DoDamage()` 方法：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here are the specifics of the implementation coded in the preceding snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面代码片段中编写的实现的具体细节：
- en: '`OnDamageEvent`: Declare as a `UnityEvent` instance with two parameters. `Collider2D`
    takes the collision object that can be used to get the intersection position between
    the objects. And the `isAffected` value indicates whether or not the damage was
    applied as a result of the collision - this is from the layer mask evaluation,
    as we’ll see in a minute.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDamageEvent`: 声明为一个具有两个参数的 `UnityEvent` 实例。`Collider2D` 用于获取对象之间的交点位置。`isAffected`
    值表示是否由于碰撞而应用了伤害——这是来自层掩码评估的，我们将在下一分钟看到。'
- en: Take notice that we won’t use the `event` keyword here because it is a `UnityEvent`
    instance – it’s not a delegate type but a serializable class. Otherwise, always
    use the `event` keyword for your events to enforce the event pattern, where only
    the implementing class should invoke!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里不会使用 `event` 关键字，因为它是一个 `UnityEvent` 实例——它不是一个委托类型，而是一个可序列化的类。否则，始终使用
    `event` 关键字来强制事件模式，只有实现类应该调用！
- en: '`DoDamage()`: This is the public method called from `HandleDamageCollision()`
    when the interaction occurs, and its sole responsibility is to invoke the `UnityEvent`
    instance (passing the parameters).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoDamage()`: 这是一个在交互发生时由 `HandleDamageCollision()` 调用的公共方法，它的唯一责任是调用 `UnityEvent`
    实例（传递参数）。'
- en: 'And now do the same for `PickupHeal` – implement the changes with the interface:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为 `PickupHeal` 也做同样的操作——使用接口实现更改。
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the explanation for these code changes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对这些代码更改的解释：
- en: '`OnHealEvent`: Declared as a `UnityEvent` instance with one parameter. The
    `GameObject` instance is just the object that is affected by the healing. The
    usage could simply be getting the object’s transform position for instantiating
    an object or particle effect.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHealEvent`: 声明为一个具有一个参数的 `UnityEvent` 实例。`GameObject` 实例只是受到治愈影响的对象。使用方法可以是简单地获取对象的变换位置以实例化对象或粒子效果。'
- en: '`DoHeal()`: Just like the damage method, this is a public method called from
    `HandleHealCollision()` when the interaction occurs and is also solely responsible
    for invoking the `UnityEvent` instance (passing the parameter).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoHeal()`: 就像伤害方法一样，这是一个在交互发生时由 `HandleHealCollision()` 调用的公共方法，它也仅负责调用 `UnityEvent`
    实例（传递参数）。'
- en: 'The final step is to add the public `Do` calls to the `HealthSystem.OnTriggerEnter2D()`
    method. Update `HandleDamageCollision()` like so:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将公共的 `Do` 调用添加到 `HealthSystem.OnTriggerEnter2D()` 方法中。更新 `HandleDamageCollision()`
    如下：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We introduced a local bool variable, `isAffected`, to get the `IsLayerInLayerMask()`
    result – we can then use the variable in place of calling `IsLayerInLayerMask()`
    multiple times.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个局部布尔变量 `isAffected` 来获取 `IsLayerInLayerMask()` 的结果——然后我们可以使用这个变量代替多次调用
    `IsLayerInLayerMask()`。
- en: We can then just call `DoDamage()` and only call `TakeDamage()` if the object
    is affected by the damaging object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需调用`DoDamage()`，并且只有当对象受到伤害对象的影响时才调用`TakeDamage()`。
- en: 'Now, update `HandleHealCollision()` like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像这样更新`HandleHealCollision()`：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Unlike with damage, we don’t care about the impact of the damaging object having
    an effect or not. We’ll process healing if it’s in `HealMask`. We just need to
    call the public `DoHeal()` – passing in the object being healed – and we’re done!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与伤害不同，我们不在乎伤害对象是否有影响。如果它在`HealMask`中，我们将处理治疗。我们只需要调用公共的`DoHeal()` - 传递正在被治疗的物体
    - 我们就完成了！
- en: Now that we have an event exposed on the `ProjectileDamage` and `PickupHeal`
    components, let’s refactor an earlier composition for destroying the water diamond
    pickup. Hence, we have an example of its usage.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`ProjectileDamage`和`PickupHeal`组件上公开了一个事件，让我们重构一个早期的组合来破坏水钻石拾取。因此，我们有一个其用法的示例。
- en: Re-composition for Destroyer
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对破坏者进行重新组合
- en: With `PickupHeal` now having a `UnityEvent` instance triggered when the collision
    occurs, we can improve the composition for destroying the water diamond object
    when it’s collected. We previously used the `TriggeredEvent` component, but now
    we need to assign the `Destroyer.DestroyMe()` function to the `OnHealEvent` function
    selection drop-down menu.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PickupHeal`现在有一个在碰撞发生时触发的`UnityEvent`实例，我们可以改进收集水钻石对象时破坏其组合。我们之前使用了`TriggeredEvent`组件，但现在我们需要将`Destroyer.DestroyMe()`函数分配给`OnHealEvent`函数选择下拉菜单。
- en: '![Figure 8.7 – Revising Destroyer](img/B18347_08_7.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 修改破坏者](img/B18347_08_7.jpg)'
- en: Figure 8.7 – Revising Destroyer
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 修改破坏者
- en: 'Referring to *Figure 8**.7*, let’s walk through this change:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图**8**.7，让我们来了解一下这个变化：
- en: (*A*) – Click the little `OnHealEvent` tab to add a new listener to the list.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*A*) – 点击小`OnHealEvent`标签以向列表中添加一个新的监听器。
- en: (*B*) – Drag the `Destroyer` component to the object field (using its title
    area).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*B*) – 将`Destroyer`组件拖到对象字段（使用其标题区域）。
- en: In the function selection drop-down menu, select **Destroyer |** **DestroyMe(
    )**.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数选择下拉菜单中，选择**破坏者 |** **DestroyMe( )**。
- en: (*C*) – Right-click on the `TriggeredEvent` title area to bring up the context
    menu and select **Remove Component**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*C*) – 右键单击`TriggeredEvent`标题区域以弹出上下文菜单并选择**移除组件**。
- en: You end up with an **Inspector** window that looks like the right-most image
    – you are done. Easy-peasy.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会得到一个**检查器**窗口，看起来像最右边的图像——你完成了。简单易懂。
- en: Also, we don’t need to worry about `IsTriggeredByPlayer` from the `TriggeredEvent`
    component anymore since `DoHeal()` will only be called if the `HealMask` check
    is satisfied.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不再需要担心`TriggeredEvent`组件的`IsTriggeredByPlayer`，因为`DoHeal()`只有在`HealMask`检查满足时才会被调用。
- en: In this section, we have created a fully implemented health system, and that’s
    a game changer (yes, bad pun). Again, you learned the power of interfaces and
    how we can quickly add functionality to existing systems. We also practiced composition
    by refactoring some reusable components to explore a different approach to destroying
    the heal pickup object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经创建了一个完全实现的健康系统，这是一个游戏规则的改变（是的，这是一个糟糕的玩笑）。再次，你学习了接口的力量以及我们如何快速向现有系统添加功能。我们还通过重构一些可重用组件来练习组合，以探索破坏治疗拾取对象的不同方法。
- en: In the next section, let’s put the health system through its paces by having
    a bunch of pesky enemies to contend with as we introduce a wave spawner.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们通过引入波生成器来让一些讨厌的敌人来测试健康系统。
- en: Enemy wave spawner
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人波生成器
- en: A **wave spawner** may sound scary, but it’s just a straightforward script.
    We need to instantiate a new enemy from a given position and on a fixed (or random)
    time interval. We’ll also ensure things don’t get out of hand by limiting the
    number of enemies spawned.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**波生成器**听起来可能很吓人，但它只是一个简单的脚本。我们需要从一个给定的位置和固定（或随机）的时间间隔实例化一个新的敌人。我们还将通过限制生成的敌人数量来确保事情不会失控。'
- en: 'So, with that in mind, let’s have a look at our new `EnemySpawner` script –
    create it in the `Assets/Scripts` folder – and see whether you can point out where
    the few requirements I just stated have been implemented:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这一点，让我们来看看我们的新`EnemySpawner`脚本 - 在`Assets/Scripts`文件夹中创建它 - 看看你是否能指出我刚才提到的几个要求在哪里得到了实现：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s break this class down – a lot of this should be looking very familiar
    by now:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个类——现在大部分内容应该看起来很熟悉：
- en: Declare a variable for the enemy Prefab that will be spawned – we use the `Enemy`
    type here instead of `GameObject` because when we reference `_enemyPrefab` later,
    we’ll be referencing the `Enemy` class directly and won’t need to do `GetComponent()`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个用于将要生成的敌人 Prefab 的变量——我们在这里使用 `Enemy` 类型而不是 `GameObject`，因为我们稍后引用 `_enemyPrefab`
    时，将直接引用 `Enemy` 类，而无需执行 `GetComponent()`。
- en: Declare a variable for `_spawnInterval`, which will be the delay before spawning
    the next enemy.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个用于 `_spawnInterval` 的变量，它将是生成下一个敌人之前的延迟。
- en: Declare a variable for `_maxSpawned`, which will be the total number of enemies
    onscreen – from this spawner – at the same time.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个用于 `_maxSpawned` 的变量，它将是屏幕上（从这个生成器）同时存在的敌人总数。
- en: Declare a variable for `_objectCount`, which keeps track of how many enemies
    are currently spawned.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个用于 `_objectCount` 的变量，它跟踪当前已生成的敌人数量。
- en: Create the `Start()` method – here we’ll simply use `InvokeRepeating()` to repeatedly
    call `SpawnEnemy()` at the specified spawn interval (`_spawnInterval`).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Start()` 方法——在这里，我们将简单地使用 `InvokeRepeating()` 在指定的生成间隔（`_spawnInterval`）重复调用
    `SpawnEnemy()`。
- en: Create the `SpawnEnemy()` method – we first check to see whether we’ve already
    instantiated our `_maxSpawned` amount of enemies, and, if not, `Instantiate()`
    a new `Enemy`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `SpawnEnemy()` 方法——我们首先检查是否已经实例化了 `_maxSpawned` 数量的敌人，如果没有，就使用 `Instantiate()`
    创建一个新的 `Enemy`。
- en: We create a new (implicit declaration using `var`) local `enemy` variable –
    returned from the `Instantiate()` call – so that we can call `Init()` and pass
    in a callback parameter (as a pseudo constructor). This is in place of what would
    usually be the C# constructor (objects created with the `new` keyword, which,
    if you remember, we cannot do with `MonoBehaviour`).
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的（使用 `var` 进行隐式声明的）局部 `enemy` 变量——从 `Instantiate()` 调用返回——这样我们就可以调用 `Init()`
    并传入一个回调参数（作为伪构造函数）。这代替了通常的 C# 构造函数（使用 `new` 关键字创建的对象，如果你还记得，我们无法在 `MonoBehaviour`
    中这样做）。
- en: Increment the number of spawned objects with `_objectCount++`.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `_objectCount++` 增加已生成对象的数量。
- en: Define the `DestroyedCallback()` method passed into the `Enemy.Init()` call
    so that, when the enemy object is destroyed, the currently spawned enemy count
    can be decreased – resulting in the spawner instantiating another enemy to maintain
    the `_maxSpawned` count.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义传递给 `Enemy.Init()` 调用的 `DestroyedCallback()` 方法，以便在敌人对象被销毁时，可以减少当前生成的敌人数量——结果是在生成器实例化另一个敌人以保持
    `_maxSpawned` 数量。
- en: Don’t forget about object pooling!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记对象池！
- en: Note that if we have waves and waves of many enemies, we do want to optimize
    this by introducing object pooling. Refer back to [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们有多个波次的敌人，我们确实希望通过引入对象池来优化这一点。请参阅 [*第 6 章*](B18347_06.xhtml#_idTextAnchor116)。
- en: 'We’ll have to tie `DestroyedCallback` to the `Enemy` class because it’s passed
    to the instantiated enemy object via the `enemy.Init()` call. Let’s add everything
    to support that now; it’s not much, so open the `Enemy` script and add the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将 `DestroyedCallback` 绑定到 `Enemy` 类，因为它是通过 `enemy.Init()` 调用传递给实例化敌人对象的。现在让我们添加所有支持这些功能的内容；这并不多，所以打开
    `Enemy` 脚本并添加以下内容：
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we have a `UnityAction` instance that we’ll use to invoke the callback
    when the enemy object is destroyed – you’ve seen all this before.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个 `UnityAction` 实例，我们将使用它来在敌人对象被销毁时调用回调——你之前已经见过所有这些。
- en: 'We just need to actually destroy the enemy object, and we do that when the
    object dies, as dictated by the `IhaveHealth`-interface-implemented `Died()` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要实际销毁敌人对象，我们会在对象死亡时这样做，正如由 `IhaveHealth` 接口实现的 `Died()` 方法所指示的：
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A note about `DestroyedCallback` and why we don’t have to *unregister from
    the event* when enemy is destroyed: the responsibility is being flipped here since
    `EnemySpawner` is not holding a reference to the instantiated enemy object. You
    only need to unregister (or `RemoveListener`) from events that can become invalid
    references.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `DestroyedCallback` 和为什么在敌人被销毁时我们不必 *注销事件* 的说明：这里的责任是颠倒的，因为 `EnemySpawner`
    没有持有实例化敌人对象的引用。你只需要从可能成为无效引用的事件中注销（或 `RemoveListener`）。
- en: Let’s set up a Prefab we can reuse as a preconfigured enemy spawner.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个可以重复使用的 Prefab，作为预配置的敌人生成器。
- en: Creating the enemy spawner Prefab
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建敌人生成器 Prefab
- en: Go ahead and, in your current open scene in Unity, create a new empty GameObject
    in the `EnemyB Spawner 1` – we can have different Prefabs for different enemy
    spawning behaviors. Make sure to place it right at ground level in your environment
    because the spawner’s transform position will be used as the enemy instantiation
    point. Add the `EnemySpawner` component to the `EnemyB``Spawner 1` object and
    drag in the `EnemyB` Prefab from the `Assets/Prefabs` folder to the **Enemy Prefab**
    field, as seen in *Figure 8**.8*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，在你的当前打开的场景中，创建一个新的空游戏对象在`EnemyB Spawner 1`中——我们可以为不同的敌人生成行为有不同的预制件。确保将其放置在环境中的地面水平上，因为生成器的变换位置将被用作敌人实例化点。将`EnemySpawner`组件添加到`EnemyB
    Spawner 1`对象中，并将`Assets/Prefabs`文件夹中的`EnemyB`预制件拖到**敌人预制件**字段中，如图 8.8 所示。
- en: '![Figure 8.8 – Enemy spawner setup](img/B18347_08_8.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 敌人生成器设置](img/B18347_08_8.jpg)'
- en: Figure 8.8 – Enemy spawner setup
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 敌人生成器设置
- en: Finish up by dragging the `EnemyB Spawner 1` object in the `Assets/Prefabs`
    folder. Yay!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`Assets/Prefabs`文件夹中的`EnemyB Spawner 1`对象拖动到场景中。太棒了！
- en: If you playtest the enemy wave spawner now, they’ll just spawn on top of one
    another, be disorganized, and not go anywhere – in other words, not acting like
    robots at all. Let’s integrate spawning with the patrolling behavior to keep things
    orderly.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在进行敌人波次生成器的测试，它们将只是堆叠在一起，变得杂乱无章，并且无处可去——换句话说，根本不像机器人。让我们将生成与巡逻行为集成，以保持事物的有序性。
- en: Integrating spawning with patrol behavior
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将生成与巡逻行为集成
- en: If you haven’t picked up on it already, because we’ve paid attention to the
    project’s code structure and followed good programming practices from the beginning,
    maintaining and extending the code to add new functionality has been simple and
    straightforward. Integrating our new wave spawner to work with the existing patrol
    behavior will also be quick work. We’ll just need to add a few things to set it
    up.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有注意到，因为我们从一开始就关注项目的代码结构并遵循良好的编程实践，维护和扩展代码以添加新功能一直很简单且直接。将我们的新波次生成器集成到现有的巡逻行为中也将是快速的工作。我们只需要添加一些东西来设置它。
- en: 'First things first, let’s see if the instantiated `Enemy B` Prefab has a patrol
    behavior and, if so, `SetWaypoints()`. To do that, let’s modify the `SpawnEnemy()`
    method in the `EnemySpawner` class. Here you can see we’re again using `TryGetComponent()`
    to fail gracefully if the component doesn’t exist on the enemy:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看实例化的`Enemy B`预制件是否有巡逻行为，如果有，则调用`SetWaypoints()`。为此，让我们修改`EnemySpawner`类中的`SpawnEnemy()`方法。在这里，我们可以看到我们再次使用`TryGetComponent()`来优雅地处理组件不存在的情况：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `PatrolWaypoints` class, add the following `SetWaypoints()` method (or,
    again, use the IDE’s refactoring tools to generate it) to allow setting the left
    and right waypoint private variables externally (encapsulation at work):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PatrolWaypoints`类中，添加以下`SetWaypoints()`方法（或者，再次使用 IDE 的重构工具生成它），以便外部设置左右航点的私有变量（封装在起作用）：
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And, don’t forget: we’ll need to add a `SetWaypoints()` method declaration
    to our `IBehaviorPatrolWaypoints` interface so that it’s accessible from the reference
    in the `EnemySpawner` class:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了：我们需要在`IBehaviorPatrolWaypoints`接口中添加一个`SetWaypoints()`方法声明，以便它可以从`EnemySpawner`类中的引用访问：
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Seriously, that’s it – three simple additions get the patrolling behavior all
    wired up to our enemy spawner. You’ll just have to add two empty GameObjects to
    the scene for the patrolling path of this enemy spawner, one for left and one
    for right, and assign them in the **Inspector** window, as seen in the enemy spawner
    setup from *Figure 8**.8*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 严肃地说，就是这样——三个简单的添加就将巡逻行为完全集成到我们的敌人生成器中。你只需要在场景中添加两个空的游戏对象作为这个敌人生成器的巡逻路径，一个用于左侧，一个用于右侧，并在**检查器**窗口中分配它们，如图
    8.8 所示。
- en: However, you’ll notice we have a problem (you playtested, right?). Enemies won’t
    be able to pass each other as they patrol between the waypoints – a simple problem
    to solve by removing their physics interactions with each other. First, we’ll
    need a layer to set the enemy objects to… how about `Enemy`?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会注意到我们有一个问题（你进行了测试，对吧？）。敌人在巡逻时无法在航点之间相互穿过——这是一个简单的问题，可以通过移除它们之间的物理交互来解决。首先，我们需要一个层来设置敌人对象…比如说`Enemy`？
- en: Using the **Layers** drop-down menu in the top-right corner of the **Editor**
    window, select **Edit Layers…**.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在**编辑器**窗口右上角的**层**下拉菜单中选择**编辑层…**。
- en: '![Figure 8.9 – Add an enemy layer](img/B18347_08_9.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 添加敌人层](img/B18347_08_9.jpg)'
- en: Figure 8.9 – Add an enemy layer
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 添加敌人层
- en: Under the `Enemy` to add it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在“敌人”下添加它。
- en: 'Now we can control the physics interactions between enemy objects by specifying
    what collisions are processed by their layer. Using the `Enemy` layer (uncheck
    **Enemy/Enemy**):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过指定由它们的层处理的碰撞来控制敌人对象之间的物理交互。使用“敌人”层（取消选中**敌人/敌人**）：
- en: '![Figure 8.10 – Physics 2D layer collision matrix](img/B18347_08_10.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 物理二维层碰撞矩阵](img/B18347_08_10.jpg)'
- en: Figure 8.10 – Physics 2D layer collision matrix
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 物理二维层碰撞矩阵
- en: When you playtest the enemy wave spawner in the scene now, the spawned enemies
    will patrol past one another. Awesome!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在在场景中测试敌人波生成器时，生成的敌人将会巡逻经过彼此。太棒了！
- en: In this section, we created a wave spawner to instantiate new enemies on a fixed
    time interval and integrated it with the existing patrol behavior. We finished
    up by resolving physics interactions between enemy objects to allow them to pass
    each other while patrolling.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个波生成器，以固定的时间间隔实例化新的敌人，并将其与现有的巡逻行为集成。我们通过解决敌人对象之间的物理交互来结束，使它们在巡逻时能够相互通过。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the implementation of a health system that any object
    in the game can use to receive damage, heal, and handle the final death/destruction
    of the object. This system was designed using interfaces to tie everything together
    in an extensible way without relying on concrete class references – the flexibility
    of interfaces allowed for the quick addition of new functionality to our existing
    code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了实现一个任何游戏中的对象都可以使用的健康系统，该系统可以用来接收伤害、治疗以及处理对象的最终死亡/破坏。这个系统是通过使用接口设计的，以可扩展的方式将所有内容连接在一起，而不依赖于具体的类引用
    – 接口的灵活性允许我们快速向现有代码中添加新功能。
- en: We continued by creating a wave spawner that instantiates new enemies on a fixed
    time interval and integrates with the existing patrol behavior. This allows for
    adding in more complex enemy behavior, which adds new challenges to the game.
    Additionally, we discussed how to disable physics interactions between objects,
    which allowed patrolling enemies to pass each other in this case.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续创建了一个波生成器，它以固定的时间间隔实例化新的敌人，并将其与现有的巡逻行为集成。这允许添加更复杂的敌人行为，这为游戏增加了新的挑战。此外，我们还讨论了如何禁用对象之间的物理交互，这使得巡逻的敌人能够相互通过。
- en: Finally, we further explored composition by refactoring some of our reusable
    components to explore a different approach to destroying the heal pickup object.
    Through examples such as this, the importance of good programming practices and
    the use of interfaces to build flexible and extensible systems was highlighted.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进一步探索了组合，通过重构一些可重用组件来探索破坏治疗拾取对象的不同方法。通过这样的例子，强调了良好编程实践和利用接口构建灵活和可扩展系统的重要性。
- en: In the next chapter, we’ll complete the adventure game by creating a simple
    quest system for collecting key objects for solving the entryway puzzle. We will
    also introduce a new event system for keeping our code loosely coupled.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过创建一个简单的任务系统来收集解决入口谜题的关键对象，以完成冒险游戏。我们还将引入一个新的事件系统，以保持我们的代码松散耦合。
