- en: '*Chapter 5*: Application Profiling and Tracing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：应用程序性能分析和跟踪'
- en: Application profiling is the internal examination of the inner workings of a
    computer program. We use application profiling to measure the performance of a
    program's internals. This helps us to identify any performance bottlenecks and
    memory issues. Then, we can use this information to refactor and improve the performance
    of the program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序性能分析是对计算机程序内部运作的内部检查。我们使用应用程序性能分析来衡量程序内部性能。这有助于我们识别任何性能瓶颈和内存问题。然后，我们可以使用这些信息来重构和改进程序的性能。
- en: Application tracing is used to monitor the internal performance of a computer
    program as it is running. You can trace the execution of your computer program
    during development, testing, and when released into production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序跟踪用于监控计算机程序在运行时的内部性能。你可以在开发、测试以及将程序发布到生产时跟踪你的计算机程序的执行。
- en: When used together, application profiling and application tracing can be very
    powerful and useful in identifying why computer programs are slow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合使用时，应用程序性能分析和应用程序跟踪可以非常强大且有用，有助于识别为什么计算机程序运行缓慢。
- en: In this chapter, you will learn how to profile your applications to identify
    any poor areas of performance. You will come to understand code metrics and how
    to perform static code analysis. In your drive to write more performant code,
    you will learn how to make use of memory dumps, the loaded modules viewer, debugging,
    tracing, and `dotnet-counters`. By the time you have completed this chapter, you
    will have the necessary skills and experience you need to profile and trace your
    own applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何对应用程序进行性能分析以识别任何性能不佳的区域。你将了解代码指标以及如何进行静态代码分析。在你努力编写更高效代码的过程中，你将学习如何利用内存转储、已加载模块查看器、调试、跟踪和`dotnet-counters`。当你完成本章时，你将具备对自身应用程序进行性能分析和跟踪所需的技能和经验。
- en: 'In this chapter, we will be covering the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: '**Understanding code metrics**: In this section, we will be looking at what
    application, assembly, namespace, type, method, and field metrics various tools
    can offer us.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解代码指标**：在本节中，我们将探讨各种工具可以为我们提供哪些应用程序、程序集、命名空间、类型、方法和字段指标。'
- en: '**Performing static code analysis**: In this section, we will look at performing
    static code analysis with Visual Studio 2022\. And we will be generating metrics
    for our software that consist of the maintainability index, cyclomatic complex,
    the depth of inheritance, class coupling, units of source code, and lines of executable
    code.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行静态代码分析**：在本节中，我们将探讨使用Visual Studio 2022执行静态代码分析。我们将为我们的软件生成指标，包括可维护性指数、循环复杂度、继承深度、类耦合、源代码单元和可执行代码行数。'
- en: '**Generating and viewing memory dumps**: In this section, we will look at how
    to generate and view memory dumps when a breakpoint is hit in code or when an
    application is encountered.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成和查看内存转储**：在本节中，我们将探讨在代码中遇到断点或应用程序遇到时如何生成和查看内存转储。'
- en: '**Viewing loaded modules**: In this section, we will display the **Modules**
    window in Visual Studio so that we can view the modules that are loaded into memory
    by our application and view information about those modules.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看已加载模块**：在本节中，我们将展示Visual Studio中的**模块**窗口，以便我们可以查看由我们的应用程序加载到内存中的模块，并查看有关这些模块的信息。'
- en: '**Debugging your applications**: This section highlights the various debugging
    options that are available to us.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试你的应用程序**：本节突出了我们可用的各种调试选项。'
- en: '**Using tracing and diagnostics tools**: In this section, we will introduce
    tools that can help us to perform tracing and diagnostics on our software applications.
    Specifically, we will consider Visual Studio 2022, JetBrains dotMemory, and JetBrains
    dotTrace.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用跟踪和诊断工具**：在本节中，我们将介绍可以帮助我们在软件应用程序上执行跟踪和诊断的工具。具体来说，我们将考虑Visual Studio 2022、JetBrains
    dotMemory和JetBrains dotTrace。'
- en: '`dotnet-counters` and use them to list .NET processes that can be monitored,
    list the available counters that we can use to gather performance data, monitor
    a .NET process, and collect data for that process in a CSV file for post-processing
    analysis in Excel.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dotnet-counters`并使用它们来列出可监控的.NET进程、列出我们可以使用的可用计数器以收集性能数据、监控.NET进程，并将该进程的数据收集到CSV文件中，以便在Excel中进行后续分析。
- en: '**Tracking down and fixing a memory leak with dotMemory**: In this section,
    we will use dotMemory to hunt down a memory leak in a WPF application and fix
    it.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 dotMemory 跟踪和修复内存泄漏**：在本节中，我们将使用 dotMemory 来追踪 WPF 应用程序中的内存泄漏并修复它。'
- en: '**Finding the cause of a UI freeze with dotTrace**: In this section, we will
    use dotTrace to hunt down the cause of a UI freeze in a WPF application and fix
    it.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 dotTrace 查找 UI 冻结的原因**：在本节中，我们将使用 dotTrace 来追踪 WPF 应用程序中 UI 冻结的原因并修复它。'
- en: '**Optimizing application performance and memory traffic**: In this section,
    we will use dotTrace to identify opportunities to improve performance and memory
    traffic for a WPF application.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化应用程序性能和内存流量**：在本节中，我们将使用 dotTrace 来识别改进 WPF 应用程序性能和内存流量的机会。'
- en: 'After completing this chapter, you will be skilled in the following things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将掌握以下技能：
- en: Understanding code metrics and being able to use them to improve code quality
    and performance
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码度量指标并能够使用它们来提高代码质量和性能
- en: Performing static code analysis to improve code quality and performance
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行静态代码分析来提高代码质量和性能
- en: Using loaded modules to identify what modules your code uses
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载的模块来识别您的代码使用了哪些模块
- en: Effectively debugging software
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效调试软件
- en: Effectively tracing software
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效跟踪软件
- en: Using `dotnet-counters` to perform first-level performance investigations
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dotnet-counters` 进行初步的性能调查
- en: Using JetBrains dotMemory to track down memory leaks and fix them
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JetBrains dotMemory 跟踪内存泄漏并修复它们
- en: Using JetBrains dotTrace to track down the cause of UI freezes and fix them
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JetBrains dotTrace 跟踪 UI 冻结的原因并修复它们
- en: Using JetBrains dotTrace to track down performance and memory traffic issues
    and fix them
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JetBrains dotTrace 跟踪性能和内存流量问题并修复它们
- en: Note
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Don't be alarmed if you are asked to access code from previous chapters for
    some of the examples. Due to the page limitation for chapters, adding code examples
    for those exercises would have exceeded the count limit for this chapter.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您被要求访问前几章的代码以进行某些示例，请不要感到惊讶。由于章节的页面限制，为那些练习添加代码示例将超过本章的计数限制。
- en: Technical requirements
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements to follow along with this chapter are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循本章内容所需的技术要求如下：
- en: Visual Studio 2022 or higher
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 或更高版本
- en: JetBrains dotMemory
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains dotMemory
- en: JetBrains dotTrace
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains dotTrace
- en: 'Source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH05](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH05)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH05](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH05)
- en: 'Optional: Microsoft Excel or some other CSV file viewer'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：Microsoft Excel 或其他 CSV 文件查看器
- en: Understanding code metrics
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码度量指标
- en: In this section, we will be looking at the code metrics that can be gathered
    using various tools that are paid for, free, and open source. Source code metrics
    are extracted from source code and are used to measure the quality and performance
    of our source code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用各种付费、免费和开源工具可以收集到的代码度量指标。源代码度量指标是从源代码中提取出来的，用于衡量我们源代码的质量和性能。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Different tools have different metrics that they can measure and calculate.
    Since each tool is different, it is a good idea for you to see what tools and
    metrics are available that satisfy your own project's requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工具可以测量和计算不同的度量指标。由于每个工具都不同，了解哪些工具和度量指标可以满足您自己的项目需求是个好主意。
- en: In the upcoming subsections, we will learn about the different code metrics
    that we can use to measure our code and improve performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，我们将了解我们可以用来衡量我们的代码并提高性能的不同代码度量指标。
- en: Application metrics
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序度量指标
- en: Application metrics cover your application's complete source code across assemblies.
    They give you the big picture regarding how many lines of code your application
    has, along with how many lines are covered by tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序度量指标涵盖了您的应用程序在整个程序集的完整源代码。它们为您提供了关于应用程序有多少行代码以及有多少行代码被测试覆盖的总体情况。
- en: 'In this section, we will cover, from a high level, the various metrics that
    certain tools such as the *ndepends* tool offer. As part of your own studies,
    identify different application metrics gathering tools. Then, see what metrics
    they offer. Choose the tool that best fits your needs. In the next section, the
    generation of code metrics will be demonstrated using Visual Studio''s built-in
    static code analysis tool to generate the following metrics: the maintainability
    index, cyclomatic complexity, the depth of inheritance, class coupling, the lines
    of source code, and the lines of executing code. These and other metrics are described
    next.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从高层次介绍某些工具（如 *ndepends* 工具）提供的各种指标。作为你自己的研究的一部分，确定不同的应用指标收集工具。然后，查看它们提供的指标。选择最适合你需求的工具。在下一节中，将使用
    Visual Studio 的内置静态代码分析工具演示代码指标的生成，包括以下指标：可维护性指数、循环复杂度、继承深度、类耦合、源代码行数和执行代码行数。接下来将描述这些和其他指标。
- en: 'Although metrics are different between tool vendors, available application
    metrics might include the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管工具供应商之间的指标不同，但可用的应用指标可能包括以下内容：
- en: '**Lines of Code** (**LOC**): There are two types of LOC measurements. They
    include logical LOC and physical LOC. A logical LOC refers to those lines of code
    that can span one or more lines and are terminated by either a closing curly brace
    or a semicolon. A physical LOC refers to actual lines of code including comments
    and whitespace.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码行数**（**LOC**）：有两种类型的 LOC 测量。它们包括逻辑 LOC 和物理 LOC。逻辑 LOC 指的是可以跨越一行或多行，并以闭合花括号或分号结束的代码行。物理
    LOC 指的是包括注释和空白符的实际代码行。'
- en: '**Lines of comment**: The number of lines used for comments.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注释行数**：用于注释的行数。'
- en: '**Percentage comment**: This metric identifies the percentage of code that
    is made up of comments. It is calculated using this formula: *100 x Lines of Comment/(Lines
    of Comment + Lines of Code)*.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注释百分比**：此指标用于识别代码中注释所占的百分比。它是通过以下公式计算的：*100 x 注释行数/(注释行数 + 代码行数)*。'
- en: '**IL instructions**: When your code compiles, it is converted into **Intermediate
    Language** (**IL**) code. Depending on how you code your C# code, this can lead
    to the generation of a large or small number of IL instructions. It makes sense
    to measure the number of IL instructions generated by your code. That''s because
    even if the code is small, it could generate many IL instructions. And conversely,
    a method can be large but generate smaller lines of code compared to the smaller
    version of the code. The smaller number of IL instructions, the easier the method
    is to maintain.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IL 指令**：当你的代码编译时，它会被转换成**中间语言**（**IL**）代码。根据你如何编写 C# 代码，这可能导致生成大量或少量 IL 指令。测量你的代码生成的
    IL 指令数量是有意义的。这是因为即使代码很小，它也可能生成许多 IL 指令。相反，一个方法可能很大，但与代码的小版本相比，生成的代码行数更少。IL 指令数量越少，该方法越容易维护。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The company *ndepend* has a recommendation on their documentation code-metrics
    page that states methods that produce IL instructions higher than 100 are hard
    to understand and maintain. Additionally, they state that unless the methods are
    autogenerated by code generation tools, methods that produce 200 lines or more
    of IL instructions are extremely complex and should be split into smaller methods.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 公司 *ndepend* 在他们的文档代码指标页面上有一个建议，指出生成 IL 指令超过 100 的方法难以理解和维护。此外，他们还表示，除非方法是代码生成工具自动生成的，否则生成
    200 行或更多 IL 指令的方法非常复杂，应该拆分成更小的方法。
- en: '**Application assemblies**: The application assembly count.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用汇编**：应用汇编计数。'
- en: '**Application namespaces**: The application namespace count.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用命名空间**：应用命名空间计数。'
- en: '**Application methods**: The application method count.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用方法**：应用方法计数。'
- en: '**Application fields**: The application field count.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用字段**：应用字段计数。'
- en: '**Lines of code covered**: The number of lines covered by tests.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码行数覆盖**：被测试覆盖的代码行数。'
- en: '**Lines of code not covered**: The number of lines not covered by tests.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未覆盖的代码行数**：未由测试覆盖的代码行数。'
- en: Now we will cover what assembly metrics are and what types of metrics can be
    gathered.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍什么是汇编指标以及可以收集哪些类型的指标。
- en: Assembly metrics
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编指标
- en: Assembly metrics are more focused on measuring the quality and stability of
    individual assemblies. Since an application can consist of many assemblies, problems
    can arise in any one or more of those assemblies. If multiple assemblies rely
    on one poorly performing assembly, then the whole application will be affected.
    Additionally, it is good to be able to reuse assemblies in different projects,
    so coupling should be kept to an absolute minimum.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集指标更侧重于衡量单个程序集的质量和稳定性。由于一个应用程序可以由许多程序集组成，因此任何单个或多个程序集中都可能出现问题。如果多个程序集依赖于一个性能不佳的程序集，那么整个应用程序都将受到影响。此外，能够在不同的项目中重用程序集是很好的，因此耦合应保持在绝对最小。
- en: 'Gathering assembly metrics enables you to understand how your assemblies are
    coupled together, and you can also see how abstract and stable or unstable they
    are. Additionally, you can determine whether they are reusable in their current
    form based on those metrics. The various metrics that are available to measure
    assembly source code include the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 收集程序集指标使你能够了解你的程序集是如何耦合在一起的，你还可以看到它们是抽象和稳定的还是不稳定。此外，你可以根据这些指标确定它们是否以当前形式可重用。可用于衡量程序集源代码的各种指标包括以下内容：
- en: '**Afferent coupling**: This is the count of classes in other assemblies that
    rely on classes within the current assembly.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入耦合**：这是其他程序集中依赖于当前程序集中类的类的数量。'
- en: '**Efferent coupling**: This is the count of classes in the current assembly
    that depend upon classes in other packages.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出耦合**：这是当前程序集中依赖于其他包中类的类的数量。'
- en: '**Relational cohesion**: The average count of internal relationships per type
    within an assembly.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联内聚性**：一个程序集中每个类型内部关系的平均数量。'
- en: '**Instability**: The ratio of efferent coupling to total coupling.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不稳定性**：输出耦合与总耦合的比率。'
- en: '**Abstractness**: The ratio of internal abstract classes and interfaces to
    internal types.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象性**：内部抽象类和接口与内部类型的比率。'
- en: '**Distance from the main sequence**: A number that indicates the balance between
    abstractness and stability.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主序列距离**：一个表示抽象性和稳定性之间平衡的数字。'
- en: Now, let's look at what namespace metrics are and what kind of metrics can be
    gathered.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看命名空间指标是什么以及可以收集哪些类型的指标。
- en: Namespace metrics
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间指标
- en: Namespaces are an important part of any professional quality API. Correctly
    partitioning your code into relevantly named namespaces helps programmers understand
    your API and find what they are looking for more easily. Namespace metrics help
    you to understand whether you have dependency cycles and whether your assemblies
    are high-level, mid-level, or low-level.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是任何专业质量API的重要组成部分。正确地将你的代码分区到相关命名的命名空间有助于程序员理解你的API，并更容易找到他们想要的东西。命名空间指标帮助你了解你是否存在依赖循环，以及你的程序集是高级、中级还是低级。
- en: 'The metrics that are available concerning the code quality of namespaces include
    the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名空间代码质量的可用指标包括以下内容：
- en: '**Afferent coupling**: The count of namespaces that directly depend on the
    current namespace.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入耦合**：直接依赖于当前命名空间的命名空间的数量。'
- en: '**Efferent coupling**: The count of different namespaces that the current namespace
    depends on.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出耦合**：当前命名空间所依赖的不同命名空间的数量。'
- en: '**Level**: The level value of a namespace. This metric can help you identify
    dependency cycles. Additionally, it helps you objectively classify your assemblies,
    namespaces, methods, and types as high-level, mid-level, or low-level.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别**：命名空间的水平值。这个指标可以帮助你识别依赖循环。此外，它还有助于你客观地将你的程序集、命名空间、方法和类型分类为高级、中级或低级。'
- en: It's time to look at what type metrics are and the type of metrics that can
    be gathered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看有哪些类型的指标以及可以收集哪些类型的指标了。
- en: Type metrics
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型指标
- en: Type refers to class types, interface types, array types, value types, enumeration
    types, type parameters, generic type definitions, and open or closed constructed
    generic types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类型指的是类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义以及开放或封闭构造的泛型类型。
- en: Types and how they are coded and used are behind all the problems we experience
    as programmers and end users. Understanding how they are used in our programs
    is an effective way of identifying a variety of issues with our code. When problems
    are identified, they can be rectified.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类型及其编码和使用方式是我们作为程序员和最终用户所遇到的所有问题的背后。理解它们在我们程序中的使用方式是识别我们代码中各种问题的有效方法。当问题被识别出来时，它们可以被纠正。
- en: 'Type code quality metrics include the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代码质量指标包括以下内容：
- en: '**Type rank**: A computed value that is computed based on the application of
    a ranking algorithm, similar to Google''s PageRank algorithm, on types dependencies
    graph.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型排名**：基于对类型依赖图应用排名算法计算得出的值，类似于谷歌的PageRank算法。'
- en: '**Afferent coupling**: The count of types that depend upon the current type.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入耦合**：依赖于当前类型的类型数量。'
- en: '**Efferent coupling**: The count of types that the current type directly depends
    on.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出耦合**：当前类型直接依赖的类型数量。'
- en: '**Lack of cohesion methods**: For the code to adhere to the **single responsibility
    principle** (**SRP**), it will have only one reason to change, and no more.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏内聚的方法**：为了使代码遵循**单一职责原则**（SRP），它将只有一个变更的理由，没有更多。'
- en: '**Cyclomatic complexity**: The count of pathways through a method.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环复杂度**：通过方法路径的数量。'
- en: '**IL cyclomatic complexity**: The count of pathways through IL code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IL循环复杂度**：通过IL代码的路径数量。'
- en: '**Size of instance**: The size, in bytes, of the instances of the specified
    type.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例大小**：指定类型的实例的大小，以字节为单位。'
- en: '**Interfaces implemented**: The count of interfaces implemented.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现的接口**：实现的接口数量。'
- en: '**Association between classes**: The count of members from other types that
    are directly used in the body of the methods of the current type.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类之间的关联**：在其他类型的成员中直接用于当前类型方法体内的成员数量。'
- en: '**The number of children**: The count of subclasses for a class, or the count
    of types that implement an interface.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子类数量**：类的子类数量，或实现接口的类型数量。'
- en: '**Depth of inheritance tree**: The count of base classes for a class or structure.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承树深度**：类或结构的基础类数量。'
- en: Now we will look at what method metrics are and the types of method metrics
    that can be gathered.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨方法指标是什么以及可以收集到的方法指标类型。
- en: Method metrics
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法指标
- en: 'Normally, methods are behind most performance issues. It is the method within
    a class that executes instructions that can cause any number of issues for your
    customers. These problems can include runtime errors, data errors, and performance
    issues. Being able to see and understand how a method interacts with other methods
    can be a real big help in solving various issues including performance issues.
    The method metrics that are available for analyzing the code quality of methods
    include the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，方法背后隐藏着大多数性能问题。是类中的方法执行指令，可能会给客户带来任何数量的问题。这些问题可能包括运行时错误、数据错误和性能问题。能够看到和理解方法如何与其他方法交互，对于解决包括性能问题在内的各种问题非常有帮助。可用于分析方法代码质量的指标包括以下内容：
- en: '**Method rank**: A computed value based on the application of a ranking algorithm,
    similar to Google''s PageRank algorithm, on the method dependencies graph.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法排名**：基于对方法依赖图应用排名算法计算得出的值，类似于谷歌的PageRank算法。'
- en: '**Afferent coupling**: The count of methods that directly depend upon the current
    method.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入耦合**：直接依赖于当前方法的方法数量。'
- en: '**Efferent coupling**: The count of methods that the current method directly
    depends on.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出耦合**：当前方法直接依赖的方法数量。'
- en: '**IL nesting depth**: The maximum count of encapsulated scopes inside a method
    body computed from the IL code.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IL嵌套深度**：从IL代码中计算出的方法体内封装的作用域的最大数量。'
- en: '**Parameters**: The number of parameters used in the method signature.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：在方法签名中使用的参数数量。'
- en: '**Variables**: The method body variable count.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：方法体内的变量数量。'
- en: '**Overloads**: The method overload count.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重载**：方法重载的数量。'
- en: '**Percentage branch coverage**: The percentage of branches covered by tests
    generated from opcodes.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支覆盖率百分比**：由操作码生成的测试覆盖的分支百分比。'
- en: The final metrics that we will look at are field metrics.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最终指标是字段指标。
- en: Field metrics
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段指标
- en: The metrics available for measuring coupling at the field level is **afferent
    coupling**. This refers to the count of methods that directly uses a variable.
    The higher the count, the more unstable the software becomes. So, this metric
    can be useful for improving the stability of the software.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在字段级别测量耦合的指标是**输入耦合**。这指的是直接使用变量的方法数量。数量越高，软件的稳定性越低。因此，这个指标可以用于提高软件的稳定性。
- en: The size of instance metric measures the size, in bytes, of the instances of
    a specified type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实例大小指标衡量的是指定类型实例的大小，以字节为单位。
- en: In the next section, we will look at how to improve the architecture and code
    quality by performing static code analysis.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过执行静态代码分析来改进架构和代码质量。
- en: Performing static code analysis
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行静态代码分析
- en: 'The purpose of static code analysis is to help you improve your overall architectural
    quality, code quality, and performance by doing the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析的目的在于通过以下方式帮助您提高整体架构质量、代码质量和性能：
- en: Visualizing software architecture and its software dependencies
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化软件架构及其软件依赖关系
- en: Enforcing the designated architectural rules regarding laying, subsystems, calling
    rules, and more
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行有关布局、子系统、调用规则等方面的指定架构规则
- en: Identifying code that has been cloned and modified using cut, copy, and paste
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别使用剪切、复制和粘贴方式克隆和修改的代码
- en: Identifying dead code that can be removed
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别可以删除的无效代码
- en: Calculating various software metrics
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算各种软件度量
- en: Performing code style checks and flagging violations
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行代码风格检查并标记违规项
- en: 'Many companies employ static code analysis as part of their **Continuous Integration**
    (**CI**) process. There are various stages at which problems can come to light.
    These stages are listed as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司将静态代码分析作为其**持续集成**（**CI**）流程的一部分。问题可能在以下各个阶段显现。这些阶段如下列出：
- en: When compiling source code in the IDE
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在 IDE 中编译源代码时
- en: When running unit tests and end-to-end system tests
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行单元测试和端到端系统测试时
- en: When pushing source code to version control and issuing a pull request
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将源代码推送到版本控制并提交拉取请求时
- en: When a pull request has been issued and the code is issued to the build pipeline
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提交拉取请求并将代码发送到构建管道时
- en: Performing static code analysis during the coding phase helps to prevent issues
    from being flagged further down the development and release processes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码阶段执行静态代码分析有助于防止问题在开发发布流程的后期被标记。
- en: 'In Visual Studio via the **Project Properties** | **Code Analysis** page, you
    can run analyzers on the build and live analyses. You can enable .NET analyzers
    and set the analysis level to **preview**, **latest**, **5.0**, and **none**.
    Additionally, you can enforce CodeStyle on build. *Figure 5.1* shows the **Code
    Analysis** page:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，您可以通过**项目属性** | **代码分析**页面运行构建和实时分析的分析器。您可以启用 .NET 分析器并将分析级别设置为**预览**、**最新**、**5.0**和**无**。此外，您可以在构建上强制执行
    CodeStyle。*图 5.1*显示了**代码分析**页面：
- en: '![Figure 5.1 – The Visual Studio Code Analysis page on the Project Properties
    tab'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 项目属性选项卡上的 Visual Studio Code 分析页面'
- en: '](img/Figure_5.01_B16617.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B16617.jpg)'
- en: Figure 5.1 – The Visual Studio Code Analysis page on the Project Properties
    tab
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 项目属性选项卡上的 Visual Studio Code 分析页面
- en: 'The **Code Metrics Results** window is available from the **View** menu by
    selecting **View** | **Other Windows – Code Metrics Results**. The **Code Metrics
    Results** window is displayed in *Figure 5.2*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码度量结果**窗口可通过**视图**菜单中的**视图** | **其他窗口 – 代码度量结果**访问。**代码度量结果**窗口如图 5.2 所示：'
- en: '![Figure 5.2 – The Code Metrics Results window'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 代码度量结果窗口'
- en: '](img/Figure_5.02_B16617.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B16617.jpg)'
- en: Figure 5.2 – The Code Metrics Results window
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 代码度量结果窗口
- en: 'Right-click on the `CH04_Finalization` project and select **Analyze** and **Code
    Cleanup** | **Calculate Code Metrics** from the context pop-up menu. The **Code
    Metrics Results** window will be updated with the results of the analysis:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 `CH04_Finalization` 项目，并在上下文弹出菜单中选择**分析**和**代码清理** | **计算代码度量**。**代码度量结果**窗口将更新为分析结果：
- en: '![Figure 5.3 – Visual Studio 2022 Code Metrics Results for the CH04_WeakReference
    project'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – CH04_WeakReference 项目的 Visual Studio 2022 代码度量结果'
- en: '](img/Figure_5.03_B16617.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B16617.jpg)'
- en: Figure 5.3 – Visual Studio 2022 Code Metrics Results for the CH04_WeakReference
    project
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – CH04_WeakReference 项目的 Visual Studio 2022 代码度量结果
- en: The `CH04_Finalization`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`CH04_Finalization`。'
- en: Learn About the Metrics in Detail
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 详细了解度量信息
- en: If you want to learn more about the metrics (**Maintainability Index**, **Cyclomatic
    Complexity**, **Depth of Inheritance**, **Class Coupling**, **Lines of Source
    Code**, and **Lines of Executable code**), then you can find a dedicated chapter
    ([*Chapter 12*](B16617_12_Final_SB_Epub.xhtml#_idTextAnchor215)) in my other book,
    *Clean Code in C#* ([https://www.packtpub.com/product/clean-code-in-c/9781838982973](https://www.packtpub.com/product/clean-code-in-c/9781838982973)),
    which is published by Packt.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于指标（**可维护性指数**、**圈复杂度**、**继承深度**、**类耦合度**、**源代码行数**和**可执行代码行数**）的信息，那么你可以在我的另一本书中找到一个专门的章节（[*第
    12 章*](B16617_12_Final_SB_Epub.xhtml#_idTextAnchor215)），这本书名为 *Clean Code in C#*
    ([https://www.packtpub.com/product/clean-code-in-c/9781838982973](https://www.packtpub.com/product/clean-code-in-c/9781838982973))），由
    Packt 出版。
- en: From the traffic-light indicators of the **Maintainability Index** column, you
    can see that our project has green lights all the way. This means that our project
    is maintainable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **可维护性指数** 列的交通灯指示器中，你可以看到我们的项目一路绿灯。这意味着我们的项目是可维护的。
- en: The cyclomatic complexity of our methods is between **1** and **2**, so our
    individual method code contains no risk. However, the overall cyclomatic complexity
    of our project is **31**, which is medium risk. This value is the summation of
    the overall cyclomatic complexity of each of the classes within our project. The
    cyclomatic complexity of each of our classes is the summation of the cyclomatic
    complexity of each of the methods. Since none of the classes have a cyclomatic
    complexity of more than **13**, our code is complex but only poses a low risk
    to our project. Because the overall complexity of the project is **31**, we should
    look to see whether the code can be refactored to lower the cyclomatic complexity.
    Sometimes, you will find that code is as simple as you can make it and that it
    is not possible to reduce cyclomatic complexity. That is okay. Just use your common
    sense and better judgment when you encounter such code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方法的圈复杂度在 **1** 到 **2** 之间，所以我们的单个方法代码不包含任何风险。然而，我们项目的整体圈复杂度为 **31**，属于中等风险。这个值是项目中每个类整体圈复杂度的总和。我们每个类的圈复杂度是每个方法圈复杂度的总和。由于没有哪个类的圈复杂度超过
    **13**，我们的代码复杂但只对我们项目构成低风险。因为项目的整体复杂度为 **31**，我们应该检查代码是否可以重构以降低圈复杂度。有时，你会发现代码已经尽可能简单，并且无法进一步降低圈复杂度。这是可以的。当你遇到这样的代码时，只需运用你的常识和更好的判断力即可。
- en: The maximum depth of inheritance in our project is `FreeAllocateMemory` class
    inherits from our `DisposableBase` class, which inherits from the `System.Object`
    class. If we study what the `DisposableBase` class does, we can see that it will
    not cause us any issues.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中继承的最大深度是 `FreeAllocateMemory` 类继承自我们的 `DisposableBase` 类，而 `DisposableBase`
    类又继承自 `System.Object` 类。如果我们研究一下 `DisposableBase` 类的功能，我们可以看到它不会给我们带来任何问题。
- en: The total number of lines of code in our project is about **200**. There are
    **50** lines of executable code. That's because we are making effective use of
    whitespace so that our code is easy to read. Easy-to-read code is easier to understand,
    extend, and maintain.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中的代码行数总计约为 **200**。有 **50** 行可执行代码。这是因为我们有效地使用了空白，使得代码易于阅读。易于阅读的代码更容易理解、扩展和维护。
- en: 'Open the `CH06_Collections`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `CH06_Collections`：
- en: '![Figure 5.4 – The Visual Studio 2022 code analysis results for the CH04_Finalization
    project'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – CH04_Finalization 项目的 Visual Studio 2022 代码分析结果'
- en: '](img/Figure_5.04_B16617.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B16617.jpg)'
- en: Figure 5.4 – The Visual Studio 2022 code analysis results for the CH04_Finalization
    project
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – CH04_Finalization 项目的 Visual Studio 2022 代码分析结果
- en: In the preceding screenshot, we can see that we have 0 errors, 4 warnings, and
    62 messages. The three informational messages inform us that three different methods
    do not access instance data and can be marked as static.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们有 0 个错误，4 个警告和 62 条消息。三条信息性消息告诉我们，有三个不同的方法没有访问实例数据，可以标记为静态。
- en: 'In the `CH04_Finalization.DisposableBase` class, we implement the `IDisposable`
    interface. In this class, code analysis raises two informational messages for
    code analysis rule CA1816\. This code analysis rule informs us that the `Dispose`
    methods should call `SuppressFinalize`. Despite calling `GC.SuppressFinalize`,
    we are receiving this code analysis rule as an informational message. Therefore,
    to remove (suppress) the warning, we wrap the code in `#pragma` compiler directives.
    This can be done manually or by right-clicking on the message and selecting `DisposableBase`
    source file as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CH04_Finalization.DisposableBase` 类中，我们实现了 `IDisposable` 接口。在这个类中，代码分析会为代码分析规则
    CA1816 产生两个信息性消息。这个代码分析规则告诉我们，`Dispose` 方法应该调用 `SuppressFinalize`。尽管调用了 `GC.SuppressFinalize`，但我们仍然收到这个代码分析规则的信息性消息。因此，为了移除（抑制）警告，我们将代码包裹在
    `#pragma` 编译器指令中。这可以手动完成，或者通过右键单击消息并选择以下方式选择 `DisposableBase` 源文件：
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that the `DisposableBase` class has been updated with these `#pragma` warning
    disable CA1816 statements, notice that the messages are no longer displayed in
    the error list.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`DisposableBase` 类已经通过这些 `#pragma` 警告禁用 CA1816 语句进行了更新，请注意，这些消息不再在错误列表中显示。
- en: Well, we have had a look at how to generate code metrics and run code analysis
    on our `CH04_Finalization` project using Visual Studio 2022\. Now, let's move
    on to look at how to generate memory dumps and analyze them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经了解了如何使用 Visual Studio 2022 生成代码度量值并对 `CH04_Finalization` 项目进行代码分析。现在，让我们看看如何生成内存转储并分析它们。
- en: Generating and viewing memory dumps
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成和查看内存转储
- en: When debugging in Visual Studio, if your program has stopped on a breakpoint
    or an exception, then the **Save Dump As** menu option becomes available in the
    **Debug** menu.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中进行调试时，如果你的程序在断点或异常处停止，那么在 **Debug** 菜单中就会出现 **Save Dump As**
    菜单选项。
- en: A minidump with a heap file provides a snapshot of an application's memory,
    shows the process that was running, and lists the modules that were loaded at
    a point in time. Dump files enable you to examine the stack, threads, and variables
    as they were within the application and memory at the point in time when the dump
    was saved.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 包含堆文件的 minidump 提供了应用程序内存的快照，显示了当时正在运行的过程，并列出了在某个时间点加载的模块。转储文件使您能够检查在转储保存时应用程序和内存中的堆栈、线程和变量。
- en: You would save a minidump with heap files when testing software and a crash
    is encountered, and when a customer program crash cannot be replicated on your
    computer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当在测试软件时遇到崩溃，并且无法在您的计算机上重现客户程序崩溃时，您会保存包含堆文件的 minidump。
- en: 'Let''s go through the process of saving and loading a minidump with a heap
    file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤保存和加载包含堆文件的 minidump：
- en: 'Using our `CH04_WeakReferences` project, put a breakpoint on the following
    line in the `program.cs` file:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的 `CH04_WeakReferences` 项目，在 `program.cs` 文件中的以下行设置断点：
- en: '[PRE19]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run the project to the breakpoint. Then, when the breakpoint is hit, select
    `CH04_WeakReference.dmp`. This file is a minidump with a heap file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目到断点。然后，当断点被触发时，选择 `CH04_WeakReference.dmp`。这是一个包含堆文件的 minidump 文件。
- en: 'To read the file, select **File** | **Open** | **File**. Then, select the file
    you just saved. You should see the following window:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要读取文件，请选择 **文件** | **打开** | **文件**。然后，选择您刚刚保存的文件。您应该看到以下窗口：
- en: '![Figure 5.5 – A minidump with a heap file loaded in Visual Studio 2022'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – 在 Visual Studio 2022 中加载堆文件的 minidump'
- en: '](img/Figure_5.05_B16617.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.05_B16617.jpg]'
- en: Figure 5.5 – A minidump with a heap file loaded in Visual Studio 2022
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 在 Visual Studio 2022 中加载堆文件的 minidump
- en: The preceding screenshot shows us that we can see the time at which the file
    was last updated, the process name, the computer architecture, the exception code
    and information, the heap information, and the error information. Then, we have
    the CLR and OS versions. Finally, there is a list of modules, including their
    names, versions, and paths.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示我们可以看到文件最后更新的时间、进程名称、计算机架构、异常代码和信息、堆信息以及错误信息。然后，我们有 CLR 和 OS 版本。最后，有一个模块列表，包括它们的名称、版本和路径。
- en: You have just learned how to generate and read memory dumps in Visual Studio
    2022\. Now we will look at using the **Modules** window in Visual Studio 2022
    to view what modules have been loaded by our projects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚学习了如何在 Visual Studio 2022 中生成和读取内存转储。现在，我们将看看如何使用 Visual Studio 2022 中的 **Modules**
    窗口查看我们的项目加载了哪些模块。
- en: Viewing loaded modules
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看已加载的模块
- en: To identify what might be causing performance issues such as excessive memory
    load, or that might be generating runtime errors, it can be useful to see what
    modules have been loaded into memory. In this section, you will learn how to view
    loaded modules and understand the items of information provided regarding those
    modules.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定可能引起性能问题，如过度的内存加载，或可能生成运行时错误的原因，查看已加载到内存中的模块可能会有所帮助。在本节中，您将学习如何查看加载的模块以及了解有关这些模块提供的信息项。
- en: 'When you are debugging in Visual Studio 2022, the **Debug** | **Windows** menu
    contains the menus, as shown in *Figure 5.6*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Visual Studio 2022 中进行调试时，**调试** | **窗口** 菜单包含以下菜单，如图 *图 5.6* 所示：
- en: '![Figure 5.6 – The Windows menu during a debugging session'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 调试会话期间的 Windows 菜单'
- en: '](img/Figure_5.06_B16617.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.06_B16617.jpg)'
- en: Figure 5.6 – The Windows menu during a debugging session
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 调试会话期间的 Windows 菜单
- en: 'From the preceding menu, as shown in *Figure 5.6*, you can select **Modules**
    during a debugging session. This will load the **Modules** window, as shown in
    *Figure 5.7*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.6* 所示的先前菜单中，您可以在调试会话期间选择 **模块**。这将加载 **模块** 窗口，如图 *图 5.7* 所示：
- en: '![Figure 5.7 – The Modules window showing the loaded modules for the current
    process'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 显示当前进程加载模块的模块窗口'
- en: '](img/Figure_5.07_B16617.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.07_B16617.jpg)'
- en: Figure 5.7 – The Modules window showing the loaded modules for the current process
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 显示当前进程加载模块的模块窗口
- en: 'As *Figure 5.7* shows, the `CH04_WeakReferences.exe` process runs in the **clrhost**
    AppDomain, and loads the following modules:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.7* 所示，`CH04_WeakReferences.exe` 进程在 **clrhost** 应用域中运行，并加载以下模块：
- en: '`System.Private.CoreLib.dll`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Private.CoreLib.dll`'
- en: '`CH04_WeakReference.dll`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CH04_WeakReference.dll`'
- en: '`System.Runtime.dll`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Runtime.dll`'
- en: '`System.Console.dll`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Console.dll`'
- en: 'The list of fields that are displayed in the **Modules** window is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **模块** 窗口中显示的字段列表如下：
- en: '**Name**: The name of the loaded assembly (loaded module)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：已加载的汇编（加载的模块）的名称'
- en: '**Path**: The path to the loaded module'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：已加载模块的路径'
- en: '**Optimized**: Yes/no'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化**：是/否'
- en: '**User Code**: Yes/no'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户代码**：是/否'
- en: '**Symbol Status**: Skipped loading symbols/symbols loaded'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号状态**：跳过加载符号/符号已加载'
- en: '**Symbol File**: The path and filename of the loaded symbol file'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号文件**：已加载符号文件的路径和文件名'
- en: '**Order**: The order of assembly loading'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序**：汇编加载的顺序'
- en: '**Version**: The assembly version'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：汇编版本'
- en: '**Address**: The memory address of the loaded module'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**：已加载模块的内存地址'
- en: '**Process**: The process identifier and executable name responsible for causing
    the modules to be loaded into memory'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**：负责将模块加载到内存中的进程标识符和可执行文件名'
- en: '**AppDomain**: The name of the application domain that the module is running
    under. This doesn''t have any meaning in .NET Core and .NET 5 or higher. It is
    displayed because the debugger UI does not make the distinction between the .NET
    Framework and .NET Core.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用域**：模块正在运行的程序域的名称。在 .NET Core 和 .NET 5 或更高版本中，这没有任何意义。它被显示出来是因为调试器 UI 没有区分
    .NET Framework 和 .NET Core。'
- en: You can use this information to see what modules are loaded, whereabouts they
    reside in memory, whether the symbols have been loaded, whether the code is system
    code or user code, and whether the code is optimized or not optimized. If you
    find user code that has not been optimized, then you can apply optimizations to
    improve performance.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些信息来查看已加载的模块，了解有关这些模块提供的信息项，包括它们在内存中的位置、符号是否已加载、代码是系统代码还是用户代码，以及代码是否已优化或未优化。如果您发现未优化的用户代码，则可以应用优化以提高性能。
- en: In the next section, we will look at how to further debug your applications
    by briefly covering the tools available to you that you should already be familiar
    with.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍如何通过介绍您应该已经熟悉的工具来进一步调试您的应用程序。
- en: Debugging your applications
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试您的应用程序
- en: 'It is assumed that you know how to debug your code by running through your
    code, stepping out and stepping over the code, running to the cursor, and setting
    breakpoints. However, there are other useful tools available when using the debugger.
    These include the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您知道如何通过运行代码、单步执行和跳过代码、运行到光标处以及设置断点来调试您的代码。然而，当使用调试器时，还有其他有用的工具可用。以下是一些工具：
- en: '![Figure 5.8 – The Debug | Windows menu'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 调试 | 窗口菜单'
- en: '](img/Figure_5.08_B16617.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.08_B16617.jpg)'
- en: Figure 5.8 – The Debug | Windows menu
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 调试 | 窗口菜单
- en: As you can see, there are a good number of different windows available to help
    debug your applications. The **Immediate** window is very good for executing commands
    when your program is paused. The **Locals** window is good for seeing the present
    state of your variables, and the call stack is useful for finding where an exception
    occurred, especially if it is in close code that is not yours! Take the time to
    run through your source code with these windows open. Different windows such as
    **XAML Binding Failures** are only used when working on the XAML-based code. But
    other windows, such as **Immediate**, **Locals**, **Output**, **Autos**, and **Call
    Stack,** can be used with all project types. The best way to get the most out
    of these tools is to use them for yourself and get to know them as you work through
    your code. Next, we will look at using tracing and diagnostics tools.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有相当数量的不同窗口可供帮助调试您的应用程序。**立即**窗口在程序暂停时执行命令非常出色。**局部变量**窗口用于查看变量的当前状态，调用堆栈对于查找异常发生的位置非常有用，尤其是如果它是在您不熟悉的代码中！花些时间在打开这些窗口的情况下运行您的源代码。例如，**XAML
    绑定失败**这样的窗口仅在处理基于 XAML 的代码时使用。但其他窗口，如**立即**、**局部变量**、**输出**、**自动**和**调用堆栈**，可以与所有项目类型一起使用。充分利用这些工具的最好方法是亲自使用它们，并在编写代码的过程中了解它们。接下来，我们将探讨使用跟踪和诊断工具。
- en: Using tracing and diagnostics tools
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用跟踪和诊断工具
- en: In this section, we will look at some profiling tools to help you trace and
    diagnose any issues with your code. By tracing and diagnosing your program, you
    can identify areas of performance concern and address them. Such concerns might
    be the number of memory allocations and the number of bytes they are using and
    identifying the number of objects surviving garbage collection. Such information
    can be useful in improving memory usage and performance and in preventing and
    removing memory leaks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些分析工具，以帮助您跟踪和诊断代码中的任何问题。通过跟踪和诊断程序，您可以识别性能关注点并解决它们。这些关注点可能包括内存分配的数量和它们使用的字节数，以及识别垃圾回收后存活的对象数量。此类信息可用于提高内存使用率和性能，以及防止和移除内存泄漏。
- en: We will look at two offerings from JetBrains, called **dotMemory** and **dotTrace**,
    that are valuable tools in this respect. But first, we will start by looking at
    the built-in profiler that comes with Visual Studio 2022 called **Performance
    Profiler**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨来自 JetBrains 的两个产品，称为 **dotMemory** 和 **dotTrace**，这些工具在这方面非常有价值。但首先，我们将从
    Visual Studio 2022 内置的名为 **性能分析器** 的分析器开始。
- en: Using the Visual Studio 2022 Performance Profiler
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2022 性能分析器
- en: Now we are going to view the performance profile for our project. This will
    show us the number of objects over time and the way garbage collection is being
    utilized in our project, along with the number of objects that survive garbage
    collection. We can drill down on this profile to the assembly and method levels.
    This enables us to see the number of object allocations within a method and the
    total number of bytes those allocations use up. And because of this information,
    we can identify the areas of our program that generate the most memory usage.
    With such information, we can consider heavy allocation code for refactoring to
    improve memory performance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看我们项目的性能配置文件。这将显示随时间推移的对象数量以及垃圾回收在我们的项目中的使用方式，以及垃圾回收后存活的对象数量。我们可以将此配置文件深入到程序集和方法级别。这使得我们可以看到方法内的对象分配数量以及这些分配使用的总字节数。正因为有了这些信息，我们可以识别出程序中生成最多内存使用的区域。有了这样的信息，我们可以考虑对重分配代码进行重构以改善内存性能。
- en: 'To access the Visual Studio 2022 Performance Profile, select **Performance
    Profiler** from the Visual Studio 2022 **Debug** menu. This will bring up a tab,
    as shown in *Figure 5.9*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 Visual Studio 2022 性能配置文件，请从 Visual Studio 2022 **调试**菜单中选择**性能分析器**。这将打开一个标签页，如图
    *图 5.9* 所示：
- en: '![Figure 5.9 – The Visual Studio 2022 Performance Profiler'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – Visual Studio 2022 性能分析器'
- en: '](img/Figure_5.09_B16617.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.09_B16617.jpg)'
- en: Figure 5.9 – The Visual Studio 2022 Performance Profiler
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – Visual Studio 2022 性能分析器
- en: 'Now, we will run an analysis on the `CH04_Finalization` project:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对 `CH04_Finalization` 项目进行分析：
- en: Select your startup project.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的启动项目。
- en: Then, select the tool that you want to use. In our case, we have selected `CH04_Finalization`.
    And the tool we have selected is the tool for tracking .NET object allocations.
    This enables us to see where the .NET objects are allocated and when they are
    reclaimed.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择您想要使用的工具。在我们的例子中，我们选择了`CH04_Finalization`。我们选择的工具是用于跟踪.NET对象分配的工具。这使我们能够看到.NET对象在哪里分配以及何时被回收。
- en: 'Click on the **Start** button to start profiling the application. The profiler
    will run and then stop when the code stops. You will see a report similar to the
    one in *Figure 5.10*:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始**按钮以开始分析应用程序。分析器将运行，并在代码停止时停止。您将看到一个类似于*图5.10*的报告：
- en: '![Figure 5.10 – The complete Visual Studio 2022 Performance Profiler report'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.10 – 完整的 Visual Studio 2022 性能分析器报告'
- en: showing live objects over time
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 显示活动对象随时间变化
- en: '](img/Figure_5.10_B16617.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.10_B16617.jpg]'
- en: Figure 5.10 – The complete Visual Studio 2022 Performance Profiler report showing
    live objects over time
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 显示活动对象随时间变化的完整 Visual Studio 2022 性能分析器报告
- en: The main chart area shows the number of live objects over time. There are also
    four tabs that contain **Allocations**, **Call Tree**, **Functions**, and **Collections**
    data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 主要图表区域显示了随着时间的推移活动对象的数量。此外，还有四个标签页，包含**分配**、**调用树**、**函数**和**收藏集**数据。
- en: 'On the **Allocations** tab, you can see the types used and the number of their
    allocations. Clicking on a type brings up the **Backtrace** for that type. You
    can see the number of allocations for that type and the number of bytes allocated
    in your functions, as shown in *Figure 5.11*:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**分配**标签页上，您可以看到使用的类型及其分配数量。点击一个类型将显示该类型的**回溯**。您可以看到该类型的分配数量以及在您的函数中分配的字节数，如图*图5.11*所示：
- en: '![Figure 5.11 – The Visual Studio 2022 Performance Profiler allocations of
    System.Sbyte[]'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.11 – Visual Studio 2022 性能分析器中System.Sbyte[]的分配]'
- en: '](img/Image87475.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Image87475.jpg]'
- en: Figure 5.11 – The Visual Studio 2022 Performance Profiler allocations of System.Sbyte[]
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – Visual Studio 2022 性能分析器中System.Sbyte[]的分配
- en: In *Figure 5.11*, we can see that in our `Main` method, there are 19 allocations
    of the `System.Sbyte[]` type with an allocation size of **952** bytes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.11*中，我们可以看到在我们的`Main`方法中，有19次`System.Sbyte[]`类型的分配，分配大小为**952**字节。
- en: 'Select the `DisplayGeneration(Product product)` method, there is one `System.Int32`
    allocation that is **24** bytes in size, as shown in *Figure 5.12*:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DisplayGeneration(Product product)`方法，有一个大小为**24**字节的`System.Int32`分配，如图*图5.12*所示：
- en: '![Figure 5.12 – The Visual Studio 2022 Performance Profiler Call Tree tab'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.12 – Visual Studio 2022 性能分析器调用树标签页'
- en: '](img/Figure_5.12_B16617.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.12_B16617.jpg]'
- en: Figure 5.12 – The Visual Studio 2022 Performance Profiler Call Tree tab
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – Visual Studio 2022 性能分析器调用树标签页
- en: 'Select the `Main` method has a total of **347** allocations, **27** self-allocations,
    and is a total of **1,438** bytes in size, as shown in *Figure 5.13*:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Main`方法总共有**347**次分配，**27**次自我分配，总大小为**1,438**字节，如图*图5.13*所示：
- en: '![Figure 5.13 – Visual Studio 2022 Performance Profiler Functions tab showing
    allocations and sizes for various methods'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.13 – Visual Studio 2022 性能分析器函数标签页显示各种方法的分配和大小'
- en: '](img/Figure_5.13_B16617.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.13_B16617.jpg]'
- en: Figure 5.13 – Visual Studio 2022 Performance Profiler Functions tab showing
    allocations and sizes for various methods
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – Visual Studio 2022 性能分析器函数标签页显示各种方法的分配和大小
- en: 'Click on the **Collections** tab. Then, click on a row. You will see two pie
    charts for the top collected types and top survived types, as shown in *Figure
    5.14*:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**收藏集**标签页。然后，点击一行。您将看到两个饼图，分别显示**顶级收集类型**和**顶级存活类型**，如图*图5.14*所示：
- en: '![Figure 5.14 – Visual Studio 2022 Performance Profiler showing a breakdown
    of the garbage collection'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.14 – Visual Studio 2022 性能分析器显示垃圾回收的分解'
- en: '](img/Figure_5.14_B16617.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.14_B16617.jpg]'
- en: Figure 5.14 – Visual Studio 2022 Performance Profiler showing a breakdown of
    the garbage collection
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – Visual Studio 2022 性能分析器显示垃圾回收的分解
- en: In *Figure 5.14*, we can see the number of live objects over time along with
    the object delta (% change). Additionally, we can see the top collected types
    and top survived types in the two pie charts.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.14*中，我们可以看到随着时间的推移，活动对象的数量以及对象变化量（百分比变化）。此外，我们还可以在两个饼图中看到顶级收集类型和顶级存活类型。
- en: The Visual Studio 2022 Performance Profiler is a very useful tool that enables
    you to view allocations, byte sizes, and garbage collected and survived objects.
    You can also see the number of live objects over time. Now that you have been
    introduced to the profiler and know what it is capable of, let's move our attention
    to the JetBrains tool called **dotMemory**.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 性能分析器是一个非常实用的工具，它使您能够查看分配、字节大小以及垃圾回收和存活的对象。您还可以看到随时间变化的存活对象数量。现在您已经了解了分析器及其功能，让我们将注意力转向
    JetBrains 的工具 **dotMemory**。
- en: Using JetBrains dotMemory
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JetBrains dotMemory
- en: We use dotMemory to profile and optimize memory and to help us identify memory
    leaks and other memory-related issues. In this section, we will be discussing
    the JetBrains dotMemory memory profiler.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 dotMemory 来分析和优化内存，并帮助我们识别内存泄漏和其他内存相关的问题。在本节中，我们将讨论 JetBrains dotMemory
    内存分析器。
- en: 'The memory profiler will provide a chart with milliseconds on the *x* axis
    and megabytes on the *y* axis, which shows your application''s memory usage over
    time. The following list of items is displayed on the chart:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器将在 *x* 轴上提供以毫秒为单位的图表，在 *y* 轴上提供以兆字节为单位的图表，该图表显示了您的应用程序随时间变化的内存使用情况。以下项目在图表上显示：
- en: '**Total used**: The total amount of memory used.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总使用量**：使用的内存总量。'
- en: '**Unmanaged memory**: The total amount of memory placed on the stack.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未托管内存**：放置在堆栈上的内存总量。'
- en: '**Heap generation 0**: The amount of memory taken up by new objects. These
    objects will be less than 80,000 bytes in size.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆生成 0**：新对象占用的内存量。这些对象的大小将小于 80,000 字节。'
- en: '**Heap generation 1**: The objects that survive generation 0 garbage collection.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆生成 1**：在生成 0 垃圾回收中存活的对象。'
- en: '**Heap generation 2**: Long-lived objects that survive level 1 garbage collection.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆生成 2**：在 1 级垃圾回收中存活的长期对象。'
- en: '**Large object heap (LOH)**: The amount of memory used by objects that are
    80,000 bytes or larger in size.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大对象堆 (LOH)**：大小为 80,000 字节或更大的对象使用的内存量。'
- en: '**Allocated in LOH since GC**: The amount of memory used on the LOH after garbage
    collection has taken place.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自垃圾回收以来分配到 LOH**：垃圾回收发生后在 LOH 上使用的内存量。'
- en: 'Let''s see the dotMemory memory profiler in action. If you have not already
    done so, download and install dotMemory from JetBrains and the code for `chapter
    4` from the GitHub page. Open dotMemory, and you will be presented with a screen
    similar to the one shown in *Figure 5.15*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 dotMemory 内存分析器的实际应用。如果您还没有这样做，请从 JetBrains 下载并安装 dotMemory，以及从 GitHub
    页面获取 `第 4 章` 的代码。打开 dotMemory，您将看到一个类似于 *图 5.15* 所示的屏幕：
- en: '![Figure 5.15 – The dotMemory Memory Profiler ready to profile .NET Core Application'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.15 – 准备分析 .NET Core 应用程序的 dotMemory 内存分析器'
- en: '](img/Figure_5.15_B16617.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B16617.jpg)'
- en: Figure 5.15 – The dotMemory Memory Profiler ready to profile .NET Core Application
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 准备分析 .NET Core 应用程序的 dotMemory 内存分析器
- en: 'In *Figure 5.15*, we have selected to profile `CH04_PreventingMemoryLeaks.dll`.
    Click on the **Run** button. This will enable the profiler to start running and
    profiling your application. Once the application has been profiled, a report will
    be displayed showing the results in graphical form, as shown in *Figure 5.16*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.15* 中，我们选择了分析 `CH04_PreventingMemoryLeaks.dll`。点击 **运行** 按钮。这将使分析器开始运行并分析您的应用程序。一旦应用程序被分析，将显示一个报告，以图形形式显示结果，如图
    *图 5.16* 所示：
- en: '![Figure 5.16 – The profile report for CH04_PreventingMemoryLeaks.dll'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.16 – CH04_PreventingMemoryLeaks.dll 的分析报告'
- en: '](img/Figure_5.16_B16617.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B16617.jpg)'
- en: Figure 5.16 – The profile report for CH04_PreventingMemoryLeaks.dll
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – CH04_PreventingMemoryLeaks.dll 的分析报告
- en: As you can see from the preceding screenshot, our application uses a total of
    **8.16 MB** of memory. This is not that much. Most of the memory is placed on
    the stack, as shown by the unmanaged memory usage at **8.06 MB**. The rest of
    the memory is on the heap. On the heap, **24 KB** has been allocated on generation
    **0**, **77.6 KB** has been allocated on generation **1**, and **1.3 KB** has
    been allocated on generation **2**. The most heap memory, **19.2 KB**, was placed
    on the LOH and did not remain after garbage collection.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们的应用程序总共使用了 **8.16 MB** 的内存。这并不多。大部分内存都放在堆栈上，如未托管内存使用量所示，为 **8.06
    MB**。其余的内存位于堆上。在堆上，**0 代**分配了 **24 KB**，**1 代**分配了 **77.6 KB**，**2 代**分配了 **1.3
    KB**。最多堆内存 **19.2 KB** 被放置在 LOH 上，并且在垃圾回收后没有保留。
- en: Having seen the dotMemory tool in action, we can now turn our attention to what
    the JetBrains dotTrace tool has to offer us in terms of tracing and profiling.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到 dotMemory 工具的实际操作后，我们现在可以将注意力转向 JetBrains dotTrace 工具在跟踪和性能分析方面能为我们提供什么。
- en: Using JetBrains dotTrace
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JetBrains dotTrace
- en: In this section, we will be looking at JetBrains dotTrace. You will learn how
    to use the JetBrains dotTrace tool to perform application tracing at runtime on
    your programs. This will help you to identify bottlenecks and memory issues in
    your executable programs.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 JetBrains dotTrace。您将学习如何使用 JetBrains dotTrace 工具在程序运行时进行应用程序跟踪。这将帮助您识别可执行程序中的瓶颈和内存问题。
- en: 'The profiler options available in dotTrace include the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: dotTrace 中可用的分析器选项包括以下内容：
- en: '**Sampling**: An accurate measurement of call time. This is optimal for most
    use cases.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样**：对调用时间的精确测量。这对于大多数用例是最优的。'
- en: '**Tracing**: An accurate measurement of call number. This is optimal for analyzing
    algorithm complexity.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：对调用次数的精确测量。这对于分析算法复杂度是最优的。'
- en: '**Line-byline**: Advanced use cases only.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐行分析**：仅适用于高级用例。'
- en: '**Timeline**: The measurement of temporal performance data. This is optimal
    for most use cases, including the analysis of multithreaded applications:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间线**：对时间性能数据的测量。这对于大多数用例是最优的，包括多线程应用程序的分析：'
- en: '![Figure 5.17 – JetBrains dotTrace ready to profile our application'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – JetBrains dotTrace 准备分析我们的应用程序](img/Figure_5.17_B16617.jpg)'
- en: '](img/Figure_5.17_B16617.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – Breakdown of the main method](img/Figure_5.17_B16617.jpg)'
- en: Figure 5.17 – JetBrains dotTrace ready to profile our application
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – JetBrains dotTrace 准备分析我们的应用程序
- en: '*Figure 5.17* shows the initial state of dotTrace. We have selected **CH03_PassByValueAndReference.exe**
    as our application to profile. And for our profiling option, we have selected
    to go with the default **Sampling** setting. Make sure that **Collect profiling
    data from start** is selected. Then, click on the **Run** button to start tracing.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.17* 展示了 dotTrace 的初始状态。我们已将 **CH03_PassByValueAndReference.exe** 作为我们的分析应用程序。在我们的分析选项中，我们选择了默认的
    **采样** 设置。确保已选中 **从开始收集分析数据**。然后，点击 **运行** 按钮开始跟踪。'
- en: 'When the tracing has been completed, the dotTrace Performance Viewer will automatically
    open, as shown in *Figure 5.18*:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当跟踪完成后，dotTrace 性能查看器将自动打开，如 *图 5.18* 所示：
- en: '![Figure 5.18 – JetBrains dotTrace Performance Viewer'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18 – JetBrains dotTrace 性能查看器](img/Figure_5.18_B16617.jpg)'
- en: '](img/Figure_5.18_B16617.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18 – Breakdown of the main method](img/Figure_5.18_B16617.jpg)'
- en: Figure 5.18 – JetBrains dotTrace Performance Viewer
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – JetBrains dotTrace 性能查看器
- en: 'The outcome of profiling the `CH03_PassByValueAndReference.exe` file is shown
    in the default view of *Figure 5.18*. If you click on the `Main` line, you will
    see the program code. The breakdown of the `Main` method shows that 19 ms (43.20%)
    of time was spent executing system code, 13 ms (29.56%) of time was spent performing
    File I/O, and 12 ms (27.24%) of time was executing the **String** subsystem, as
    shown in *Figure 5.19*:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `CH03_PassByValueAndReference.exe` 文件进行性能分析的结果显示在 *图 5.18* 的默认视图中。如果您点击 `Main`
    行，您将看到程序代码。`Main` 方法的分解显示，19 毫秒（43.20%）的时间用于执行系统代码，13 毫秒（29.56%）的时间用于执行文件 I/O，12
    毫秒（27.24%）的时间用于执行 **String** 子系统，如 *图 5.19* 所示：
- en: '![Figure 5.19 – Breakdown of the main method'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – Breakdown of the main method](img/Figure_5.19_B16617.jpg)'
- en: '](img/Figure_5.19_B16617.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – Breakdown of the main method](img/Figure_5.19_B16617.jpg)'
- en: Figure 5.19 – Breakdown of the main method
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 主要方法的分解
- en: '*Figure 5.19* shows the `Main` method source code and the fact that between
    `Main` and `InParameterModifier`, the `Main` method takes the most time to process.
    This information can be helpful to identify and work with bottlenecks.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.19* 展示了 `Main` 方法的源代码以及从 `Main` 到 `InParameterModifier` 之间，`Main` 方法花费了最多时间进行处理的实际情况。这些信息有助于识别并处理瓶颈。'
- en: We have seen two tools for memory profiling and tracing that can be used to
    measure performance and identify bottlenecks and problems. Now, let's move our
    attention to installing and using `dotnet-counters`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两个用于内存分析和跟踪的工具，可以用来衡量性能、识别瓶颈和问题。现在，让我们将注意力转向安装和使用 `dotnet-counters`。
- en: Installing and using dotnet-counters
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用 dotnet-counters
- en: In this section, we will install and use `dotnet-counters`. These counters are
    very useful data-gathering tools that help us to monitor the health of our programs.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装和使用 `dotnet-counters`。这些计数器是非常有用的数据收集工具，帮助我们监控程序的健康状况。
- en: 'Open Developer Command Prompt for Visual Studio 2022\. Then, type in the following
    command and press *Enter*:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2022 的开发者命令提示符。然后，输入以下命令并按 *Enter* 键：
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will download and install dotnet-tools. A successful installation will
    be presented, as shown in *Figure 5.20*:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并安装 dotnet-tools。成功安装将显示，如图 *图 5.20* 所示：
- en: '![Figure 5.20 – The successful installation of dotnet-tools version 3.1.141901
    using'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.20_B16617.jpg)'
- en: Developer Command Prompt
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者命令提示符
- en: '](img/Figure_5.20_B16617.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.20_B16617.jpg)'
- en: Figure 5.20 – The successful installation of dotnet-tools version 3.1.141901
    using Developer Command Prompt
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 使用开发者命令提示符成功安装 dotnet-tools 版本 3.1.141901
- en: 'The purpose of using `dotnet-counters` is to perform health monitoring and
    a first-level performance investigation of your applications. If when using this
    program, potential performance problems are identified, then you can perform a
    more serious performance investigation using tools such as PerfView or dotnet-trace:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet-counters` 的目的是对您的应用程序进行健康监控和初步的性能调查。如果在使用此程序时发现潜在的性能问题，则可以使用 PerfView
    或 dotnet-trace 等工具进行更深入的性能调查：
- en: To periodically collect selected counter values and export them to a file for
    post-processing, use the `dotnet-counters collect` command.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定期收集所选计数器值并将它们导出到文件以进行后期处理，请使用 `dotnet-counters collect` 命令。
- en: The `dotnet-counters list` command displays a list of the counter names and
    descriptions that are grouped by the provider.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet-counters list` 命令显示按提供程序分组的计数器名称和描述列表。'
- en: And to display a list of .NET processes that can be monitored, you can use the
    `dotnet-counters ps` command.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示可以监控的 .NET 进程列表，可以使用 `dotnet-counters ps` 命令。
- en: Using the `dotnet-counters monitor` command, you can display periodically refreshed
    values for selected counters.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dotnet-counters monitor` 命令，您可以定期显示所选计数器的刷新值。
- en: 'To get a list of the available options for each command, append `-h` or `–help`.
    Let''s put each of those commands to use. And before we do, add the following
    lines to the end of the `CH04_WeakRefereces` `Main` method in the `Program` class:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取每个命令的可用选项列表，请附加 `-h` 或 `–help`。让我们使用这些命令中的每一个。在我们这样做之前，将以下行添加到 `CH04_WeakRefereces`
    `Main` 方法在 `Program` 类的末尾：
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program. It will pause and wait for you to press a key before it continues.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序。程序将暂停并等待你按下一个键后继续。
- en: Collecting data and saving it to a file for post-analysis
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集数据并将其保存到文件以供后期分析
- en: 'Now we will use `dotnet-counters` to save data to a file that we can analyze
    once our program has finished running:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 `dotnet-counters` 将数据保存到文件中，以便我们的程序运行完成后进行分析：
- en: Remove the breakpoint of `CH04_WeakReferences` in the `Program` class.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `Program` 类中 `CH04_WeakReferences` 的断点。
- en: 'Update the `ProcessReferences()` method in the `Program` class as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program` 类中的 `ProcessReferences()` 方法更新如下：
- en: '[PRE23]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add a breakpoint to the `while (x < 10000)` loop.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `while (x < 10000)` 循环中添加一个断点。
- en: Then, run the program. Running the program will require some time – approximately
    10,000 iterations x 2 seconds = 5.5h.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行程序。运行程序将需要一些时间 - 大约 10,000 次迭代 x 2 秒 = 5.5 小时。
- en: When the program stops on the breakpoint added in *step 3*, open Command Prompt
    as an admin and type in `dotnet-counters ps` followed by *Enter*. If you don't
    run as an admin, you will encounter counter access errors.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序在 *步骤 3* 中添加的断点处停止时，以管理员身份打开命令提示符，并输入 `dotnet-counters ps` 然后按 *Enter*。如果您不以管理员身份运行，您将遇到计数器访问错误。
- en: Obtain the process ID for the program.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取程序的进程 ID。
- en: Change the directory in Command Prompt to point to `C:\Temp`. Create the directory
    if it does not exist.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令提示符中的目录更改为指向 `C:\Temp`。如果不存在，则创建该目录。
- en: Enter the `dotnet-counters collect --process-id 1234` command (replace **1234**
    with the ID of your .NET process) followed by *Enter*.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `dotnet-counters collect --process-id 1234` 命令（将 **1234** 替换为你的 .NET 进程 ID），然后按
    *Enter*。
- en: The performance data will now be collected.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将收集性能数据。
- en: 'Remove the breakpoint added in *step 3* and continue the program. When you
    have let the program run a little while, press the *q* key. Your Command Prompt
    screen should look similar to *Figure 5.21*:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除在 *步骤 3* 中添加的断点并继续程序。当你让程序运行了一段时间后，按 *q* 键。你的命令提示符屏幕应该类似于 *图 5.21*：
- en: '![Figure 5.21 – The Developer Command Prompt having completed a collection'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.21_B16617.jpg)'
- en: '](img/Figure_5.21_B16617.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.21_B16617.jpg)'
- en: Figure 5.21 – The Developer Command Prompt having completed a collection
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 完成收集后开发者命令提示符
- en: 'Open the file called `C:\Temp\counter.csv` in **Excel**. *Figure 5.22* shows
    an excerpt of the data contained within the spreadsheet:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Excel** 中打开名为 `C:\Temp\counter.csv` 的文件。*Figure 5.22* 显示了电子表格中的数据摘录：
- en: '![Figure 5.22 – An excerpt from counter.csv'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.22 – counter.csv 的摘录'
- en: '](img/Figure_5.22_B16617.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_5.22_B16617.jpg](img/Figure_5.22_B16617.jpg)'
- en: Figure 5.22 – An excerpt from counter.csv
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.22 – counter.csv 的摘录
- en: As you can see, there are various items that are recorded by the `dotnet-counters`
    collect process. These items include CPU usage, garbage collection data, heap
    information, exception information, the number of loaded assemblies, and JIT compilation
    information.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`dotnet-counters` 收集过程记录了各种项目。这些项目包括 CPU 使用率、垃圾收集数据、堆信息、异常信息、加载的程序集数量和
    JIT 编译信息。
- en: Listing .NET processes that can be monitored
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出可监控的 .NET 进程
- en: 'To list .NET processes that can be monitored, open the Developer Command Prompt
    screen and type in the `dotnet-counters ps` command. You should see an output
    similar to the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可监控的 .NET 进程，请打开开发者命令提示符窗口并输入 `dotnet-counters ps` 命令。你应该会看到类似以下输出：
- en: '![Figure 5.23 – The list of .NET processes that can be monitored'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.23 – 可监控的 .NET 进程列表'
- en: '](img/Figure_5.23_B16617.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_5.23_B16617.jpg](img/Figure_5.23_B16617.jpg)'
- en: Figure 5.23 – The list of .NET processes that can be monitored
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.23 – 可监控的 .NET 进程列表
- en: As *Figure 5.23* shows, the only process that can be monitored is process **5364**.
    Process **5364** is the program that we are currently debugging. If more .NET
    programs were running, then more would appear on this list.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *Figure 5.23* 所示，唯一可监控的进程是进程 **5364**。进程 **5364** 是我们目前正在调试的程序。如果有更多的 .NET
    程序在运行，那么这个列表中会有更多。
- en: Listing the available list of well-known .NET counters
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出可用的已知 .NET 计数器列表
- en: 'To list the available .NET counters, run the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可用的 .NET 计数器，请运行以下命令：
- en: '[PRE24]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see a list of counters and their descriptions output to the console.
    For `Microsoft.AspNetCore.Hosting`, the available counters are listed as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在控制台看到计数器和它们的描述列表。对于 `Microsoft.AspNetCore.Hosting`，可用的计数器如下所示：
- en: '**requests-per-second**: The request rate'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**requests-per-second**: 请求速率'
- en: '**total-requests**: The total number of requests'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**total-requests**: 请求总数'
- en: '**current-requests**: The current number of requests'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**current-requests**: 当前请求数量'
- en: '**failed-requests**: The failed number of requests'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**failed-requests**: 请求失败的数量'
- en: 'The available well-known counters for `System.Runtime` are listed as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出 `System.Runtime` 可用的已知计数器：
- en: '**cpu-usage**: The amount of time the process has utilized the CPU in milliseconds'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cpu-usage**: 进程已使用的 CPU 时间（以毫秒为单位）'
- en: '**working-set**: The amount of working set used by the process in megabytes'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**working-set**: 进程使用的内存工作集大小（以兆字节为单位）'
- en: '**gc-heap-size**: The total heap reported by the garbage collector in megabytes'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gc-heap-size**: 垃圾收集器报告的总堆大小（以兆字节为单位）'
- en: '**gen-0-gc-count**: The number of generation 0 garbage collections per minute'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gen-0-gc-count**: 每分钟生成 0 收集器的垃圾收集次数'
- en: '**gen-1-gc-count**: The number of generation 1 garbage collections per minute'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gen-1-gc-count**: 每分钟生成 1 收集器的垃圾收集次数'
- en: '**gen-2-gc-count**: The number of generation 2 garbage collections per minute'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gen-2-gc-count**: 每分钟生成 2 收集器的垃圾收集次数'
- en: '**loh size**: Large object heap size'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**loh size**: 大对象堆大小'
- en: '**alloc-rate**: The number of bytes allocated in the managed heap per second'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**alloc-rate**: 每秒在托管堆中分配的字节数'
- en: '**assembly-count**: The number of assemblies loaded'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**assembly-count**: 加载的程序集数量'
- en: '**exception-count**: The number of exceptions per second'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exception-count**: 每秒异常数量'
- en: '**threadpool-thread-count**: The number of thread pool threads'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**threadpool-thread-count**: 线程池线程数量'
- en: '**monitor-lock-contention-count**: The number of times there were contentions
    when trying to take the monitor lock per second'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**monitor-lock-contention-count**: 每秒尝试获取监视器锁时的争用次数'
- en: '**threadpool-queue-length**: The number of work items in the thread pool queue'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**threadpool-queue-length**: 线程池队列中的工作项数量'
- en: '**threadpool-completed-items-count**: The number of completed work items in
    the thread pool'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**threadpool-completed-items-count**: 线程池中完成的工作项数量'
- en: '**active-timer-count**: The number of timers that are currently active'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**active-timer-count**: 当前活动的计时器数量'
- en: Monitoring a .NET process
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控 .NET 进程
- en: 'We are going to run our `CH04_WeakReferences` project. Once you have the project
    running, run the following command to get the process ID:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行 `CH04_WeakReferences` 项目。一旦项目运行，请运行以下命令以获取进程 ID：
- en: '[PRE25]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, once you have the process ID for your .NET program, run the following
    command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦你有了.NET程序的进程ID，运行以下命令：
- en: '[PRE26]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For me, the process has an ID of **6719**. Replace **6719** with whatever your
    process ID is. The result should be that you see the .NET counters being displayed
    and updated in real time, as shown in *Figure 5.24*:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，该进程的ID为**6719**。将**6719**替换为你的进程ID。结果应该是你看到.NET计数器实时显示和更新，如图*图5.24*所示：
- en: '![Figure 5.24 – The dotnet-counters being listed and updated in real time for
    our'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24 – dotnet-counters正在实时列出和更新我们的'
- en: CH04_WeakReferences project
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: CH04_WeakReferences项目
- en: '](img/Figure_5.24_B16617.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.24_B16617.jpg)'
- en: Figure 5.24 – The dotnet-counters being listed and updated in real time for
    our CH04_WeakReferences project
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 – dotnet-counters正在实时列出和更新我们的CH04_WeakReferences项目
- en: Press *q* to quit. As you can see, we have **19.042%** garbage collection fragmentation.
    There are **19,640** bytes on the LOH, and **80,864** bytes are assigned to generation
    **2**. We have **9** assemblies loaded and **24** bytes allocated to generation
    **0** and generation **1**. We have observed that memory fragmentation has occurred
    at **19.042%**, so this can be investigated further to see why we have fragmentation
    and to see whether we can avoid this.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 按*q*键退出。如你所见，我们有**19.042%**的垃圾收集碎片。在LOH上有**19,640**字节，**80,864**字节分配给了第**2**代。我们已加载**9**个程序集，**24**字节分配给了第**0**代和第**1**代。我们观察到内存碎片发生在**19.042**%，因此可以进一步调查为什么有碎片，以及我们是否可以避免这种情况。
- en: In the next section, we are going to look at an example that tracks down a memory
    leak in a WPF application.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一个示例，该示例追踪一个WPF应用程序中的内存泄漏。
- en: Tracking down and fixing a memory leak with dotMemory
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dotMemory追踪和修复内存泄漏
- en: In this section, we are going to run through an example of how to track down
    and fix memory leaks. A `OutOfMemoryException` exception being thrown by the application.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个示例来演示如何追踪和修复内存泄漏。应用程序抛出的`OutOfMemoryException`异常。
- en: Our example will be a WPF application called `CH05_GameOfLife`. To save time
    and space, download the source code for the WPF application. This will help you
    to focus on the task at hand, which is to track down the memory leak and fix it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将是一个名为`CH05_GameOfLife`的WPF应用程序。为了节省时间和空间，下载WPF应用程序的源代码。这将帮助你专注于当前的任务，即追踪内存泄漏并修复它。
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When profiling and tracing, you are better off building your projects using
    **Release** mode. The reason for this is that **Debug** builds contain compiler
    instructions that might affect profiling results.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析和跟踪时，你最好使用**发布**模式构建你的项目。原因是**调试**构建包含可能影响分析结果的编译指令。
- en: 'Perform the following steps:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Download and compile the `CH05_GameOfLife` project in **Release** mode.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并编译`CH05_GameOfLife`项目，以**发布**模式编译。
- en: Open **dotMemory**. The version used in this example is **2020.3.4**
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**dotMemory**。本例中使用的版本是**2020.3.4**
- en: 'Under **New Session**, select **Local**. Then, under **Profile Application**,
    select **.NET Core Application**. Select the **CH05_GameOfLife.exe** file under
    **.NET Core Application**, and for the **Profiler Options**, select **Collect
    memory allocation and traffic data from the start**. *Figure 5.25* shows dotMemory
    prepared to profile our application:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新会话**下，选择**本地**。然后，在**分析应用程序**下，选择**.NET Core应用程序**。在**.NET Core应用程序**下选择**CH05_GameOfLife.exe**文件，对于**分析器选项**，选择**从开始收集内存分配和流量数据**。*图5.25*显示了dotMemory准备分析我们的应用程序：
- en: '![Figure 5.25 – dotMemory ready to profile our .NET 6.0 application CH05_GameOfLife.exe'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25 – dotMemory准备分析我们的.NET 6.0应用程序CH05_GameOfLife.exe'
- en: '](img/Figure_5.25_B16617.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.25_B16617.jpg)'
- en: Figure 5.25 – dotMemory ready to profile our .NET 6.0 application CH05_GameOfLife.exe
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25 – dotMemory准备分析我们的.NET 6.0应用程序CH05_GameOfLife.exe
- en: 'Click **Run** to start profiling our application. You will see a new **Analysis**
    tab appear in dotMemory, as shown in *Figure 5.26*:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**以开始分析我们的应用程序。你将看到dotMemory中出现一个新的**分析**标签，如图*图5.26*所示：
- en: '![Figure 5.26 – dotMemory displaying the Analysis tab during the profiling
    of our app'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.26 – dotMemory在分析我们的应用程序时显示分析标签'
- en: '](img/Figure_5.26.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.26.jpg)'
- en: Figure 5.26 – dotMemory displaying the Analysis tab during the profiling of
    our app
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26 – dotMemory在分析我们的应用程序时显示分析标签
- en: 'When the profiler starts, it also starts our application. Click on the **Start**
    button of our application, as shown in *Figure 5.27*:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当分析器启动时，它也会启动我们的应用程序。点击应用程序的**开始**按钮，如图*图5.27*所示：
- en: '![Figure 5.27 – Running CH05_GameOfLife'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.27 – 运行 CH05_GameOfLife'
- en: '](img/Image87625.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Image87625.jpg)'
- en: Figure 5.27 – Running CH05_GameOfLife
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 运行 CH05_GameOfLife
- en: After *Game of Life* has been running for a while, click on the **Get Snapshot**
    button to take a memory snapshot. This will capture the application's managed
    heap at that moment in time.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *生命游戏* 运行一段时间后，点击 **获取快照** 按钮以拍摄内存快照。这将捕捉到该时刻应用程序的托管堆。
- en: Close the advert.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭广告。
- en: 'Take another snapshot so that we have two snapshots. Then, close the *Game
    of Life* application to stop the profiler. *Figure 5.28* shows the dotMemory **Analysis**
    tab with both snapshots taken:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次拍摄一个快照，以便我们有两个快照。然后，关闭 *生命游戏* 应用程序以停止分析器。*图 5.28* 显示了已拍摄两个快照的 dotMemory **分析**
    选项卡：
- en: '![Figure 5.28 – The dotMemory Analysis tab displaying both memory snapshots'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.28 – 显示两个内存快照的 dotMemory 分析选项卡'
- en: '](img/Figure_5.28.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.28.jpg)'
- en: Figure 5.28 – The dotMemory Analysis tab displaying both memory snapshots
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28 – 显示两个内存快照的 dotMemory 分析选项卡
- en: 'The next step is for us to compare the two different snapshots. *Figure 5.29*
    shows a close-up of the two snapshots side by side:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是我们比较两个不同的快照。*图 5.29* 显示了两个快照并排的特写：
- en: '![Figure 5.29 – dotMemory snapshots 1 and 2'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.29 – dotMemory 快照 1 和 2'
- en: '](img/Figure_5.29.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.29.jpg)'
- en: Figure 5.29 – dotMemory snapshots 1 and 2
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 – dotMemory 快照 1 和 2
- en: 'Click on **Compare** to open the detailed side-by-side comparison of the two
    snapshots. You should see the comparison, as shown in *Figure 5.30*:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **比较** 打开两个快照的详细并排比较。您应该看到如图 *图 5.30* 所示的比较：
- en: '![Figure 5.30 – The side-by-side snapshot comparison screen'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.30 – 并排快照比较屏幕'
- en: '](img/Figure_5.30_B16617.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.30_B16617.jpg)'
- en: Figure 5.30 – The side-by-side snapshot comparison screen
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 – 并排快照比较屏幕
- en: As you can see, this view shows the number of new objects created, the number
    of objects that have been collected (dead objects) by the garbage collector, and
    the number of objects that have survived garbage collection. This is a good source
    of information that can be used to identify memory leaks.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此视图显示了创建的新对象数量，垃圾收集器收集的对象数量（已死亡的对象），以及经过垃圾收集后存活的对象数量。这是可以用来识别内存泄漏的良好信息来源。
- en: 'Click on the **Namespace** column. Then, expand the **CH05_GameOfLife** namespace
    and highlight the **AdWindow** entry, as shown in *Figure 5.31*:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **命名空间** 列表。然后，展开 **CH05_GameOfLife** 命名空间并突出显示 **AdWindow** 条目，如图 *图 5.31*
    所示：
- en: '![Figure 5.31 – The analysis by Namespace with CH05_GameOfLife highlighted'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.31 – 使用 CH05_GameOfLife 高亮的命名空间分析'
- en: '](img/Figure_5.31_B16617.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.31_B16617.jpg)'
- en: Figure 5.31 – The analysis by Namespace with CH05_GameOfLife highlighted
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 使用 CH05_GameOfLife 高亮的命名空间分析
- en: 'In the **Survived objects** column, click on number **1** in the **AdWindow**
    row. This will bring up the dialog, as shown in *Figure 5.32*:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **存活对象** 列表中，点击 **AdWindow** 行中的数字 **1**。这将弹出对话框，如图 *图 5.32* 所示：
- en: '![Figure 5.32 – dotMemory dialog prompting the opening of a snapshot'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.32 – dotMemory 对话框提示打开快照'
- en: '](img/Figure_5.32_B16617.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.32_B16617.jpg)'
- en: Figure 5.32 – dotMemory dialog prompting the opening of a snapshot
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32 – dotMemory 对话框提示打开快照
- en: Select the newer snapshot option.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择较新的快照选项。
- en: 'Then, click on the **Key Retention Paths** tab. The JetBrains dotMemory view
    will change to a view that is similar to *Figure 5.33*:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **关键保留路径** 选项卡。JetBrains dotMemory 视图将更改为类似于 *图 5.33* 的视图：
- en: '![Figure 3.33 – The Key Retention Paths tab'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.33 – 关键保留路径选项卡'
- en: '](img/Figure_5.33_B16617.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.33_B16617.jpg)'
- en: Figure 3.33 – The Key Retention Paths tab
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.33 – 关键保留路径选项卡
- en: You can see that `EventHandler` is keeping `AdWindow` alive, and `EventHandler`
    is referenced by the `DispatcherTimer` class. The `DispatcherTimer` class is referenced
    by the `Tick` event.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 `EventHandler` 正在保持 `AdWindow` 活跃，并且 `EventHandler` 被类 `DispatcherTimer`
    引用。`DispatcherTimer` 类被 `Tick` 事件引用。
- en: 'Click on the `DispatcherTimer` box. This will take you to the `DispatcherTimer`
    class, as shown in *Figure 3.34*:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `DispatcherTimer` 框。这将带您到 `DispatcherTimer` 类，如图 *图 3.34* 所示：
- en: '![Figure 3.34 – The Outgoing References table displaying the details of DispatcherTimeruse'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.34 – 显示 DispatcherTimeruse 详细信息的输出引用表'
- en: '](img/Figure_5.34_B16617.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.34_B16617.jpg)'
- en: Figure 3.34 – The Outgoing References table displaying the details of DispatcherTimeruse
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.34 – 显示 DispatcherTimeruse 详细信息的输出引用表
- en: This tab certainly shows that `Tick EventHandler` is retaining bytes, which
    is leading to our `DispatcherTimer` object being kept alive in memory.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项卡确实显示 `Tick EventHandler` 正在保留字节，这导致我们的 `DispatcherTimer` 对象在内存中保持活跃。
- en: 'Click on the `EventHandler` creation. The method appears at the top, as shown
    in *Figure 3.35*:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `EventHandler` 创建。方法出现在顶部，如图 *图 3.35* 所示：
- en: '![Figure 3.35 – The Creation Stack Trace tab showing the AdWindow constructor
    that creates the timer'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.35 – 显示创建堆栈跟踪选项卡中的 AdWindow 构造函数，该构造函数创建计时器]'
- en: '](img/Figure_5.35_B16617.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.35_B16617.jpg)'
- en: Figure 3.35 – The Creation Stack Trace tab showing the AdWindow constructor
    that creates the timer
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.35 – 显示创建堆栈跟踪选项卡中的 AdWindow 构造函数，该构造函数创建计时器
- en: 'Locate the `AdWindow` constructor in the `AdWindow` class of the **CH05_GameOfLife**
    project:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **CH05_GameOfLife** 项目的 `AdWindow` 类中定位 `AdWindow` 构造函数：
- en: '[PRE27]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see from the preceding code snippet, we are subscribing to the `Tick`
    event, which is handled by the `ChangeAds` method. But the one thing we are not
    doing is unsubscribing from the event when we no longer require it. This is the
    reason for the memory leak.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们正在订阅 `Tick` 事件，该事件由 `ChangeAds` 方法处理。但我们没有做的一件事是在我们不再需要它时取消订阅事件。这就是内存泄漏的原因。
- en: 'To rectify our memory leak, all we have to do is unsubscribe from the event
    when we no longer need it. And to do this, we update the `OnClosed` method, as
    shown in the following code:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了纠正我们的内存泄漏，我们只需要在我们不再需要它时取消订阅事件。为此，我们更新 `OnClosed` 方法，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have now rectified our memory leak by unsubscribing from the `Tick` event
    when we close the `AdWindow` constructor. Repeat the steps to profile this memory
    leak, and you will see that it has now been fixed, as shown in *Figure 5.36*:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过在关闭 `AdWindow` 构造函数时取消订阅 `Tick` 事件来纠正我们的内存泄漏。重复这些步骤来分析这个内存泄漏，你会看到它现在已经被修复，如图
    *图 5.36* 所示：
- en: '![Figure 5.36 – dotMemory showing that the memory leak has been fixed'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.36 – dotMemory 显示内存泄漏已被修复'
- en: '](img/Figure_5.36.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.36.jpg)'
- en: Figure 5.36 – dotMemory showing that the memory leak has been fixed
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36 – dotMemory 显示内存泄漏已被修复
- en: Note
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have effectively tracked down and fixed a memory leak with dotMemory. The
    memory leak was because we did not unsubscribe from an event we were subscribed
    to. This is a very common source of memory leaks in C#. To learn more about dotMemory
    and how to use it in various scenarios, please visit the official How-To documentation
    by JetBrains at [https://www.jetbrains.com/help/dotmemory/Examples.html](https://www.jetbrains.com/help/dotmemory/Examples.html).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有效地追踪并修复了一个内存泄漏，这是由于我们没有取消订阅我们订阅的事件。这是 C# 中内存泄漏的非常常见的原因。要了解更多关于 dotMemory
    以及如何在各种场景中使用它的信息，请访问 JetBrains 的官方 How-To 文档，网址为 [https://www.jetbrains.com/help/dotmemory/Examples.html](https://www.jetbrains.com/help/dotmemory/Examples.html)。
- en: In the next section, we will look at how to track down and fix a UI freeze using
    dotTrace.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 dotTrace 追踪和修复 UI 冻结。
- en: Finding the cause of a UI freeze with dotTrace
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 dotTrace 寻找 UI 冻结的原因
- en: In this section, we will be using dotTrace to hunt down the reason for a UI
    freeze so that we can fix it. Again, to save time, we will use a project that
    has already been provided for you. Obtain the book's source code from the URL
    specified in the *Technical requirements* section. In the source code for `CH05`,
    you will find a project called `CH05_BatchFileProcessing`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 dotTrace 来追踪 UI 冻结的原因，以便我们可以修复它。再次强调，为了节省时间，我们将使用已经为你提供的项目。从 *技术要求*
    部分指定的 URL 获取书籍的源代码。在 `CH05` 的源代码中，你会找到一个名为 `CH05_BatchFileProcessing` 的项目。
- en: This project opens a number of text files specified by the user and then reverses
    each of the strings it finds. When the user clicks on the `BackgroundWorker` thread
    is started that runs on a separate thread. In the left-hand corner, the progress
    of file processing is displayed. This changes to **All files were successfully
    processed when done**. However, a problem exists whereby the UI freezes while
    the files are being processed.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目打开用户指定的多个文本文件，然后反转它找到的每个字符串。当用户点击 `BackgroundWorker` 线程时，它将在一个单独的线程上运行。在左上角，显示文件处理的进度。这会变为
    **所有文件已成功处理**。然而，存在一个问题，即在文件处理过程中 UI 会冻结。
- en: 'To find the source of this UI freeze and fix it, we are going to use timeline
    profiling, which is available using dotTrace:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到这个 UI 冻结的源头并修复它，我们将使用时间线分析，这是 dotTrace 提供的功能：
- en: Build the **CH05_BatchFileProcessing** project in **Release** mode.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **发布** 模式下构建 **CH05_BatchFileProcessing** 项目。
- en: Open dotTrace.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 dotTrace。
- en: 'Select **Profile Local App** | **.NET Core Application** | **Timeline**, and
    select the executable you just compiled. Make sure to tick **Collect profiling
    data from start**. *Figure 5.37* shows dotTrace being configured before we start
    running it:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**配置文件本地应用** | **.NET Core 应用程序** | **时间线**，并选择您刚刚编译的可执行文件。请确保勾选**从开始收集分析数据**。*图
    5.37* 展示了在运行 dotTrace 之前对其进行配置的情况：
- en: '![Figure 5.37 – dotTrace prior to us running the Timeline profiler'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.37 – 在我们运行时间线分析器之前 dotTrace'
- en: '](img/Figure_5.37_B16617.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.37_B16617.jpg](img/Figure_5.37_B16617.jpg)'
- en: Figure 5.37 – dotTrace prior to us running the Timeline profiler
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.37 – 在我们运行时间线分析器之前 dotTrace
- en: 'Click on the **Run** button to begin the timeline profiling. The profiler will
    be opened, as shown in *Figure 5.38*:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮开始时间线分析。分析器将被打开，如图 *图 5.38* 所示：
- en: '![Figure 5.38 – The dotTrace Timeline profiler'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.38 – dotTrace 时间线分析器'
- en: '](img/Figure_5.38_B16617.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.38_B16617.jpg](img/Figure_5.38_B16617.jpg)'
- en: Figure 5.38 – The dotTrace Timeline profiler
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.38 – dotTrace 时间线分析器
- en: 'The profiler will start the **CH05_BatchFileProcessor** program, as shown in
    *Figure 5.39*:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器将启动 **CH05_BatchFileProcessor** 程序，如图 *图 5.39* 所示：
- en: '![Figure 5.39 – The batch file processor'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.39 – 批处理文件处理器'
- en: '](img/Figure_5.39_B16617.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.39_B16617.jpg](img/Figure_5.39_B16617.jpg)'
- en: Figure 5.39 – The batch file processor
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.39 – 批处理文件处理器
- en: 'When the application has finished processing the files, the UI will be displayed,
    as shown in *Figure 5.40*:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序完成文件处理后，UI 将显示，如图 *图 5.40* 所示：
- en: '![Figure 5.40 – CH05_BatchFileProcessor'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.40 – CH05_BatchFileProcessor'
- en: '](img/Figure_5.40_B16617.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.40_B16617.jpg](img/Figure_5.40_B16617.jpg)'
- en: Figure 5.40 – CH05_BatchFileProcessor
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.40 – CH05_BatchFileProcessor
- en: 'Click on the **Get Snapshot** and **Wait** buttons on the timeline profiler.
    This will save the snapshot and open it in the dotTrace **Timeline Viewer** application,
    as shown in *Figure 5.41*:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击时间线分析器上的 **获取快照** 和 **等待** 按钮。这将保存快照并在 dotTrace **时间线查看器**应用程序中打开，如图 *图 5.41*
    所示：
- en: '![Figure 5.41 – The dotTrace Timeline Viewer application with a loaded timeline
    snapshot'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.41 – 加载了时间线快照的 dotTrace 时间线查看器应用程序'
- en: '](img/Figure_5.41.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.41.jpg](img/Figure_5.41.jpg)'
- en: Figure 5.41 – The dotTrace Timeline Viewer application with a loaded timeline
    snapshot
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.41 – 加载了时间线快照的 dotTrace 时间线查看器应用程序
- en: You can close the **CH05_BatchFileProcessor** and dotTrace profiler applications
    down. But keep the dotTrace **Timeline Viewer** application open.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以关闭 **CH05_BatchFileProcessor** 和 dotTrace 分析器应用程序。但请保持 dotTrace **时间线查看器**应用程序打开。
- en: All filter values are calculated for all currently visible threads. We are only
    interested in threads that have activity on them. So, hide all threads that have
    no activity on them by selecting them, right-clicking, and selecting **Hide**
    selected threads.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有过滤器值都是针对所有当前可见的线程计算的。我们只对有活动的线程感兴趣。因此，通过选择它们，右键单击并选择**隐藏所选线程**来隐藏所有没有活动的线程。
- en: 'Our **BackgroundWorker** thread is the **.NET ThreadPoolWorker** thread with
    an ID of **12764**, as shown in *Figure 5.42*:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 **BackgroundWorker** 线程是具有 ID **12764** 的 **.NET ThreadPoolWorker** 线程，如图
    *图 5.42* 所示：
- en: '![Figure 5.42 – The dotTrace Timeline Viewer application with our'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.42 – dotTrace 时间线查看器应用程序与我们的'
- en: BackgroundWorker thread highlighted
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: BackgroundWorker 线程突出显示
- en: '](img/Figure_5.42.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.42.jpg](img/Figure_5.42.jpg)'
- en: Figure 5.42 – The dotTrace Timeline Viewer application with our BackgroundWorker
    thread highlighted
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.42 – 带有突出显示的 BackgroundWorker 线程的 dotTrace 时间线查看器应用程序
- en: 'Zoom into the timeline for the **.NET ThreadPool Worker**. You can see that
    the timeline consists of three states. These states are **Running**, **Waiting
    for CPU**, and **Waiting**. You can see our thread''s timeline in *Figure 5.43*:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时间线放大到 **.NET ThreadPool Worker**。您可以看到时间线由三个状态组成。这些状态是**运行中**、**等待 CPU** 和
    **等待**。您可以在 *图 5.43* 中看到我们的线程时间线：
- en: '![Figure 5.43 – Our thread''s activity within the timeline trace'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.43 – 我们线程在时间线跟踪中的活动'
- en: '](img/Figure_5.43_B16617.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.43_B16617.jpg](img/Figure_5.43_B16617.jpg)'
- en: Figure 5.43 – Our thread's activity within the timeline trace
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.43 – 我们线程在时间线跟踪中的活动
- en: 'On the left-hand side of the screen, you will see the **Thread State** section
    within the **Filters** panel. Select each of the states in turn, and you will
    see the timeline highlighted accordingly. Have a play with all of the different
    filters available. Investigate what each option provides you. This is a good way
    to learn. The collapsed **Filters** panel is displayed in *Figure 5.44*:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的左侧，您将在 **过滤器** 面板中看到 **线程状态** 部分。依次选择每个状态，您将看到相应的时线被突出显示。尝试所有可用的不同过滤器。调查每个选项提供的内容。这是一种很好的学习方法。收起的
    **过滤器** 面板在 *图 5.44* 中显示：
- en: '![Figure 5.44 – The collapsed dotTrace Filters panel'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.44 – 收起的 dotTrace 过滤器面板'
- en: '](img/Figure_5.44_B16617.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.44_B16617.jpg)'
- en: Figure 5.44 – The collapsed dotTrace Filters panel
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.44 – 收起的 dotTrace 过滤器面板
- en: 'On the right-hand side of the screen, you will see the **Call Stack** panel
    and the **Source View** panel. If you click anywhere on the thread''s timeline,
    you will see the call stack at that point in time. The call tree will be displayed
    for that stack trace. If you click on an entry in the call stack, the code will
    be decompiled and displayed within the **Source View** tab. This functionality
    enables you to see what code is running at what point in time. Also, this view
    displays the full assembly''s name, namespace, and class name for the code you
    are looking at. *Figure 5.45* displays the **Call Stack** panel:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的右侧，您将看到 **调用栈** 面板和 **源视图** 面板。如果您在线程的时间线上点击任何位置，您将看到该时间点的调用栈。对于该堆栈跟踪，将显示调用树。如果您在调用栈中点击一个条目，代码将被反编译并在
    **源视图** 选项卡中显示。此功能使您能够看到在什么时间点运行什么代码。此外，此视图还显示了您正在查看的代码的完整程序集名称、命名空间和类名。*图 5.45*
    显示了 **调用栈** 面板：
- en: '![Figure 5.45 – The dotTrace Call Stack panel with the Backtraces tab displayed'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.45 – 显示 Backtraces 选项卡的 dotTrace 调用栈面板'
- en: '](img/Figure_5.45_B16617.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.45_B16617.jpg)'
- en: Figure 5.45 – The dotTrace Call Stack panel with the Backtraces tab displayed
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.45 – 显示 Backtraces 选项卡的 dotTrace 调用栈面板
- en: '*Figure 5.46* displays the **Source View** panel:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.46* 显示了 **源视图** 面板：'
- en: '![Figure 5.46 – The dotTrace Source View screen showing decompiled C# and IL
    source code'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.46 – 显示反编译的 C# 和 IL 源代码的 dotTrace 源视图屏幕'
- en: '](img/Figure_5.46_B16617.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.46_B16617.jpg)'
- en: Figure 5.46 – The dotTrace Source View screen showing decompiled C# and IL source
    code
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.46 – 显示反编译的 C# 和 IL 源代码的 dotTrace 源视图屏幕
- en: Note
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The colored bar that runs across the `String`. Depending on what is happening
    at a particular point in time, this line might be multicolored if multiple subsystems
    are in use. This bar is also useful for showing thread locks, among other things.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 横跨 `String` 的彩色条。根据特定时间点的发生情况，如果使用了多个子系统，则此行可能为多色。此条形也用于显示线程锁定等功能。
- en: 'Now we are ready to investigate why our UI is freezing. The purple lines in
    *Figure 5.47* represent moments in time when our UI is freezing:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备调查为什么我们的 UI 会冻结。*图 5.47* 中的紫色线条代表我们的 UI 冻结的时刻：
- en: '![Figure 5.47 – The dotTrace filtered view displaying our thread and highlighting
    UI freezes'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.47 – 显示我们的线程并突出显示 UI 冻结的 dotTrace 过滤视图'
- en: '](img/Figure_5.47_B16617.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.47_B16617.jpg)'
- en: Figure 5.47 – The dotTrace filtered view displaying our thread and highlighting
    UI freezes
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.47 – 显示我们的线程并突出显示 UI 冻结的 dotTrace 过滤视图
- en: The purple line that we are interested in is the last very long one.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的紫色线条是最后非常长的一条。
- en: In the **Filters** section, select **Events** | **.NET Memory Allocation**.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **过滤器** 部分选择 **事件** | **.NET 内存分配**。
- en: Then, select **Thread State** | **Running**.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 **线程状态** | **运行**。
- en: 'Select **Subsystems** | **User code**, and deselect everything else. You should
    see the following under **Methods and Subsystems**:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **子系统** | **用户代码**，并取消选择其他所有选项。您应该在 **方法和子系统** 下看到以下内容：
- en: '![Figure 5.48 – The dotTrace Methods and Subsystems screen highlighting problematic
    user code'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.48 – 突出显示有问题的用户代码的 dotTrace 方法和子系统屏幕'
- en: '](img/Figure_5.48_B16617.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.48_B16617.jpg)'
- en: Figure 5.48 – The dotTrace Methods and Subsystems screen highlighting problematic
    user code
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.48 – 突出显示有问题的用户代码的 dotTrace 方法和子系统屏幕
- en: 'Looking at the preceding highlighted method called `ProcessInProgress`, we
    are calling it 100% of the time during the time period when the UI freeze occurs.
    Clicking on `ProcessInProgress` will display the contents of the `MainWindow.xaml.cs`
    file. Our offending code is as follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面高亮的方法`ProcessInProgress`，我们在UI冻结发生的时间段内100%地调用它。点击`ProcessInProgress`将显示`MainWindow.xaml.cs`文件的內容。我们的违规代码如下：
- en: '[PRE29]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our code is updating the progress label with the value passed into the method,
    which is of the `ProgressChangedEventArgs` type. So, what is calling this method?
    It is the `ProcessFiles` method in the `FileProcessor` class:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码正在更新进度标签的值，该值是传递给方法的`ProgressChangedEventArgs`类型。那么，调用这个方法的是谁呢？它是`FileProcessor`类中的`ProcessFiles`方法：
- en: '[PRE30]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method iterates through the files that the user has selected. Each file
    is read along with each line, line by line. Each line has its text reversed. The
    problem is that we are calling this method far too often. So, the solution is
    to change `(j % 5 == 0)` to `(j% 1000 == 0)`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历用户选择的文件。每个文件逐行读取，一行一行地读取。每行文本都被反转。问题是，我们调用这个方法太频繁了。所以，解决方案是将`(j % 5 ==
    0)`改为`(j% 1000 == 0)`。
- en: Make the change to the code recompile and rerun the profiler. This time, there
    will be no lag. And you will see that the UI freeze has been fixed.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码进行更改后重新编译并重新运行分析器。这次，将不会有延迟。您将看到UI冻结已被修复。
- en: Now you have used dotTrace and the Timeline profile to track down and fix a
    UI freeze. In the final section, we will look at using dotTrace to optimize application
    performance and memory traffic.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用了dotTrace和Timeline配置文件来跟踪并修复了UI冻结。在最后一节中，我们将探讨如何使用dotTrace来优化应用程序性能和内存流量。
- en: Optimizing application performance and memory traffic with dotTrace
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dotTrace优化应用程序性能和内存流量
- en: 'In this section, we are going to continue tracing our `CH05_BatchFileProcessing`
    project. We have fixed the UI freeze and will be running another trace to see
    whether we can identify any further issues. When analyzing the trace, we will
    see that a lot of memory traffic is being generated that is affecting the performance
    of our application. So, we will address this issue and fix it:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续跟踪我们的`CH05_BatchFileProcessing`项目。我们已经修复了UI冻结，并将运行另一个跟踪以查看是否可以识别任何其他问题。在分析跟踪时，我们将看到产生了大量影响应用程序性能的内存流量。因此，我们将解决这个问题并修复它：
- en: Open dotTrace. Your previous session should be saved. Select it, and click on
    the **Run** button to start tracing. The sample application will then be started.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开dotTrace。您的前一个会话应该已保存。选择它，然后点击**Run**按钮以开始跟踪。然后，将启动示例应用程序。
- en: Select the text files, and click on the **Process Files** button.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文本文件，然后点击**Process Files**按钮。
- en: Once the files have been processed, kill the application. This will flush the
    data and load our trace in the trace viewer. Then, close dotTrace.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦处理完文件，终止应用程序。这将刷新数据并将我们的跟踪加载到跟踪查看器中。然后，关闭dotTrace。
- en: Once the trace snapshot has been loaded into **Timeline Viewer**, click on the
    button to **Show Snapshot**.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将跟踪快照加载到**Timeline Viewer**中，点击按钮以**显示快照**。
- en: In the **Filters** view, select **Events** | **.NET Memory Allocations and Thread
    State** | **Running**.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Filters**视图中，选择**Events** | **.NET Memory Allocations and Thread State**
    | **Running**。
- en: Hide all threads except our **.NET ThreadPool Worker** thread.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐藏除我们的**.NET ThreadPool Worker**线程之外的所有线程。
- en: 'In the `System.String` class. This will be the result of our `CH05_BatchFileProcessing.StringReverse.Reverse()`
    call. *Figure 5.49* shows the results of our trace in which we can see our methods
    and the percentages of memory traffic they generate:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`System.String`类中。这将是我们`CH05_BatchFileProcessing.StringReverse.Reverse()`调用的结果。*图5.49*显示了我们的跟踪结果，我们可以看到我们的方法和它们产生的内存流量百分比：
- en: '![Figure 5.49 – The dotTrace Timeline Viewer Call Stack screen showing our
    methods and memory traffic percentage'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.49 – The dotTrace Timeline Viewer Call Stack screen showing our
    methods and memory traffic percentage]'
- en: '](img/Figure_5.49_B16617.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.49_B16617.jpg]'
- en: Figure 5.49 – The dotTrace Timeline Viewer Call Stack screen showing our methods
    and memory traffic percentage
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.49 – The dotTrace Timeline Viewer Call Stack screen showing our
    methods and memory traffic percentage]'
- en: The two different MB sizes are our own memory allocation in this method excluding
    memory allocations in the child method calls from this method/the amount of memory
    allocated by this method or any child methods called from this method. As you
    can see, the memory allocation is `Reverse()` method and `ProcessFiles()` method.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，两个不同的MB大小是我们自己的内存分配，不包括从该方法中调用的子方法中的内存分配/该方法或任何从该方法中调用的子方法分配的内存量。正如你所看到的，内存分配是`Reverse()`方法和`ProcessFiles()`方法。
- en: 'Open this class in Visual Studio. The code for the `Reverse()` method is as
    follows:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开这个类。`Reverse()`方法的代码如下：
- en: '[PRE31]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, this method reverses a string by assigning it to an array. The
    array is then iterated backward, with each character assigned to a string using
    string concatenation. And herein lies the problem with our application's performance.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种方法通过将字符串分配给数组来反转字符串。然后，数组以反向迭代，每个字符通过字符串连接分配给字符串。这正是我们应用程序性能的问题所在。
- en: 'It is well documented that the most performant way to build up a string is
    to use the `StringBuilder` class. And we could do that here. However, there is
    another way to improve the performance of this method. Replace the existing `Reverse()`
    string method with the following version:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 有充分的文档记录表明，构建字符串的最高效方式是使用`StringBuilder`类。我们在这里也可以这样做。然而，还有另一种方法可以提高这个方法的表现。将现有的`Reverse()`字符串方法替换为以下版本：
- en: '[PRE32]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our revised code, we reverse the array and return a new string from the reverse
    array.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改后的代码中，我们反转数组，并从反转后的数组返回一个新的字符串。
- en: 'Build your project in **Release** mode and then run a new trace. *Figure 5.50*
    shows the results of the new trace:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发布**模式下构建你的项目，然后运行一个新的跟踪。*图5.50*显示了新跟踪的结果：
- en: '![Figure 5.50 – The new trace showing our improved performance'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.50 – 显示我们改进性能的新跟踪'
- en: '](img/Figure_5.50_B16617.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.50_B16617.jpg)'
- en: Figure 5.50 – The new trace showing our improved performance
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.50 – 显示我们改进性能的新跟踪
- en: We can see from our trace that the memory allocation for the `ProcessFiles`
    method went from **2.9 MB**/**255 MB**, generating **1.2%** of the memory traffic,
    to **3.8 MB**/**37 MB** of memory allocation, generating **10.1%** of the memory
    traffic.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的跟踪中我们可以看到，`ProcessFiles`方法的内存分配从**2.9 MB**/**255 MB**，生成**1.2%**的内存流量，到**3.8
    MB**/**37 MB**的内存分配，生成**10.1%**的内存流量。
- en: Plus, our `Reverse()` method went from allocating **73 MB**/**252 MB**, and
    generating **28.5%** of the memory traffic, to allocating **0 MB**/**19 MB** of
    memory, generating **0%** of the memory traffic.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`Reverse()`方法从分配**73 MB**/**252 MB**，生成**28.5%**的内存流量，到分配**0 MB**/**19
    MB**的内存，生成**0%**的内存流量。
- en: That is a good performance improvement!
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个很好的性能提升！
- en: In this chapter, we have covered various methods of measuring and analyzing
    code. With the data we obtained, we have managed to fix a memory leak caused by
    not unsubscribing to event handlers, fix a UI freeze caused by too frequent UI
    updates, and improve the application performance and memory traffic caused by
    the way we were batch processing string reversal. Now, it is time to summarize
    what we have learned.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了各种代码测量和分析的方法。通过我们获得的数据，我们成功地修复了由于未取消订阅事件处理程序而导致的内存泄漏，修复了由于UI更新过于频繁而导致的UI冻结，并改进了由于我们批量处理字符串反转的方式而引起的应用程序性能和内存流量。现在，是时候总结我们所学的知识了。
- en: Summary
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started with application profiling and tracing by looking at the various
    code metrics that are available to us. Various tools have different metrics available.
    These metrics cover the application, assemblies, namespaces, types, methods, and
    fields.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查看我们可用的各种代码指标开始，进行应用程序分析和跟踪。不同的工具有不同的指标可用。这些指标涵盖了应用程序、程序集、命名空间、类型、方法和字段。
- en: 'Then, we moved on to look at how we can perform static code analysis. We demonstrated
    static code analysis using Visual Studio 2022''s built-in code analysis tool.
    We saw how to generate the following metrics: the maintainability index, cyclomatic
    complexity, the depth of inheritance, class coupling, lines of source code, and
    lines of executable code.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续研究我们如何执行静态代码分析。我们使用Visual Studio 2022内置的代码分析工具演示了静态代码分析。我们看到了如何生成以下指标：可维护性指数、循环复杂度、继承深度、类耦合、源代码行数和可执行代码行数。
- en: The next thing we looked at was the generation of memory dumps and how to view
    them from within Visual Studio 2022\. We can view the dump time, the dump's location,
    the name of the process, the processor architecture, any exception information,
    the OS version, and the CLR version. Additionally, we can view loaded module names
    and their versions and physical paths.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来探讨了内存转储的生成以及如何在 Visual Studio 2022 中查看它们。我们可以查看转储时间、转储位置、进程名称、处理器架构、任何异常信息、操作系统版本和
    CLR 版本。此外，我们还可以查看已加载的模块名称及其版本和物理路径。
- en: Next, we looked at how to open the **Modules** window during a debugging session.
    The **Modules** window shows us the name and path of the module, whether the module
    is optimized, whether it is user code or system code, its symbol status, order,
    version, process, and AppDomain. We also saw the other options available in the
    **Debug** | **Windows** menu that add to our debugging capabilities.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了如何在调试会话期间打开 **模块** 窗口。**模块** 窗口显示了模块的名称和路径，模块是否已优化，是否为用户代码或系统代码，其符号状态、顺序、版本、进程和
    AppDomain。我们还看到了 **调试** | **窗口** 菜单中其他可用的选项，这些选项增加了我们的调试能力。
- en: Then, we looked at the tracing and diagnostics tools called Visual Studio 2022,
    JetBrains dotMemory, and JetBrains dotTrace. These tools provide an overall excellent
    debugging experience that provides all the information we need to track down any
    type of bug, including those that cause memory leakages and other memory-related
    issues.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了名为 Visual Studio 2022、JetBrains dotMemory 和 JetBrains dotTrace 的跟踪和诊断工具。这些工具提供了全面的优秀调试体验，为我们提供了追踪任何类型错误所需的所有信息，包括导致内存泄漏和其他内存相关问题的错误。
- en: Next, we looked at `dotnet-counters` and how to use this. We learned how to
    list the .NET processes that can be monitored. Then, we saw how to list the available
    well-known .NET counters. And our concluding section saw us collecting data and
    saving data to a file for post-analysis.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了 `dotnet-counters` 的使用方法。我们学习了如何列出可监控的 .NET 进程。然后，我们看到了如何列出可用的已知 .NET
    计数器。在我们的结论部分，我们收集数据并将数据保存到文件中，以便进行后续分析。
- en: Finally, we worked through three examples of using JetBrains dotMemory and JetBrains
    dotTrace to fix a memory leak and UI freeze, improve performance, and reduce memory
    traffic.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过三个示例来演示如何使用 JetBrains dotMemory 和 JetBrains dotTrace 修复内存泄漏和UI冻结问题，提高性能，并减少内存流量。
- en: In the next chapter, we will be taking a detailed look at the **Collections**
    framework. However, before then, take the time to further your reading and answer
    the following questions to reinforce what you have learned.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨 **集合** 框架。然而，在此之前，请花时间进一步阅读并回答以下问题，以巩固您所学的内容。
- en: Questions
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What aspects of our computer programs are covered by code metrics?
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码指标覆盖了我们计算机程序的哪些方面？
- en: What metrics does the Visual Studio 2022 static code analysis produce?
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 静态代码分析产生哪些指标？
- en: What kinds of things can we view from the Visual Studio-generated minidumps
    with heap?
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从 Visual Studio 生成的 minidumps 中查看哪些类型的事物？
- en: What columns are available in the **Modules** window?
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模块** 窗口中有哪些可用的列？'
- en: What are the names of the four debugging, profiling, and tracing tools for performing
    the various diagnostic operations that we mentioned earlier?
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行我们之前提到的各种诊断操作的四款调试、分析和跟踪工具的名称是什么？
- en: What operations did we carry out using .NET counters?
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 .NET 计数器执行了哪些操作？
- en: Further reading
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Debugging Visual Studio 2019: [https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2019).'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 Visual Studio 2019：[https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2019).
- en: 'Dump files in the Visual Studio debugger: https://docs.microsoft.com/visualstudio/debugger/using-dump-files?view=vs-2019.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 调试器中的转储文件：https://docs.microsoft.com/visualstudio/debugger/using-dump-files?view=vs-2019.
- en: '`dotnet-counters`: https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet-counters`: https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters.'
- en: '*.NET Core Counters internals: how to integrate counters in your monitoring
    pipeline*: [https://medium.com/criteo-engineering/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e#:~:text=dotnet-counters%3A%20collect%20the%20metrics%20corresponding%20to%20some%20performance,how%20to%20fetch%20them%20via%20the%20EventPipe%20infrastructure](https://medium.com/criteo-engineering/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e#:~:text=dotnet-counters%3A%20collect%20the%20metrics%20corresponding%20to%20some%20performance,how%20to%20fetch%20them%20v).'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.NET Core计数器内部机制：如何在监控管道中集成计数器: [https://medium.com/criteo-engineering/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e#:~:text=dotnet-counters%3A%20collect%20the%20metrics%20corresponding%20to%20some%20performance,how%20to%20fetch%20them%20via%20the%20EventPipe%20infrastructure](https://medium.com/criteo-engineering/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e#:~:text=dotnet-counters%3A%20collect%20the%20metrics%20corresponding%20to%20some%20performance,how%20to%20fetch%20them%20v).'
- en: '*JetBrains dotTrace*: https://www.jetbrains.com/profiler/.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JetBrains dotTrace*: https://www.jetbrains.com/profiler/.'
- en: '*JetBrains dotMemory*: [https://www.jetbrains.com/dotmemory/](https://www.jetbrains.com/dotmemory/).'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JetBrains dotMemory*: [https://www.jetbrains.com/dotmemory/](https://www.jetbrains.com/dotmemory/).'
- en: '*ndepend*: [https://www.ndepend.com/](https://www.ndepend.com/).'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ndepend*: [https://www.ndepend.com/](https://www.ndepend.com/).'
- en: '*Overview of .NET source code analysis*: [https://docs.microsoft.com/dotnet/fundamentals/code-analysis/overview](https://docs.microsoft.com/dotnet/fundamentals/code-analysis/overview).'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.NET源代码分析概述: [https://docs.microsoft.com/dotnet/fundamentals/code-analysis/overview](https://docs.microsoft.com/dotnet/fundamentals/code-analysis/overview).'
