- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: The One Where Processes Whisper
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程低语篇
- en: '*Interprocess* *Communication (IPC)*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程间* *通信 (IPC)*'
- en: In the previous chapter, we talked about input/output. Most of our attention
    was on files. Files are one of the first things that spring to mind when people
    think about sharing data with other systems. Another often-used method is networking.
    However, there are other ways systems can communicate with one another. Files
    are great if you want to keep data around for a more extended time. Network connections
    are an excellent way to connect more directly between systems on different machines.
    But files and networking are more about the underlying technology to transmit
    data. We also must decide how to connect to systems using those methods. That
    is what **interprocess communication** (**IPC**) in short, is all about. How can
    we have two systems talk to each other?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了输入/输出。我们的大部分注意力都集中在文件上。文件是人们想到与其他系统共享数据时首先想到的事情之一。另一种常用的方法是网络。然而，系统之间还有其他通信方式。如果你想要长时间保留数据，文件是很好的选择。网络连接是连接不同机器上系统之间更直接连接的绝佳方式。但文件和网络更多地关于传输数据的基础技术。我们还必须决定如何使用这些方法连接到系统。简而言之，这就是**进程间通信**（IPC）的全部内容。我们如何让两个系统相互交谈？
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is IPC?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 IPC？
- en: What considerations do we have to worry about when designing IPC?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 IPC 时，我们需要关注哪些考虑因素？
- en: Windows Messages – a Windows-native way of messaging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 消息 - 一种 Windows 原生的消息方式
- en: Pipes – both named and anonymous
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道 - 命名和无名
- en: Sockets – a network-based messaging system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字 - 一种基于网络的 messaging 系统
- en: Shared memory – a quick and simple local messaging system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存 - 一种快速简单的本地 messaging 系统
- en: '**Remote procedure call** (**RPC**) – controlling other machines'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程过程调用**（RPC）——控制其他机器'
- en: '**Google remote procedure call** (**gRPC**) – the newest kid on the block'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google 远程过程调用**（gRPC）——新加入的成员'
- en: Welcome to the beautiful world of whispering systems!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到迷人的低语系统世界！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will find all the code in this chapter in the following link: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter06](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter06).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到本章中所有的代码：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter06](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter06).
- en: Overview of IPC and its importance in modern computing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPC 概述及其在现代计算中的重要性
- en: Most software has a user interface. After all, that is how the user should interact
    with the application. The user clicks buttons, enters text, and reads the response
    on the screen. The screen is how data, the user, and the application exchange
    data and instructions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件都有用户界面。毕竟，用户应该通过这种方式与应用程序交互。用户点击按钮，输入文本，并在屏幕上读取响应。屏幕是数据、用户和应用程序交换数据和指令的方式。
- en: People do not use systems software. Other software does. So, it needs a different
    way to interact. I suppose it would technically be possible to write a regular
    user interface and use tricks to read or enter data, but that is not really efficient.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 人们不使用系统软件。其他软件会使用。因此，它需要不同的交互方式。我想技术上可能可以编写一个常规的用户界面并使用技巧来读取或输入数据，但这并不真正高效。
- en: Applications communicate differently when they are talking amongst themselves.
    They have their own language and their own protocols. This is what IPC is all
    about – the communication between processes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在相互交谈时会有不同的通信方式。它们有自己的语言和自己的协议。这就是进程间通信（IPC）的全部内容——进程之间的通信。
- en: Given the nature of systems, we must consider several key points when designing
    the interface between systems. We make different choices when designing this interface
    than if we were designing a user interface meant for people. There are many factors
    to consider here. Let’s go through them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统的性质，在设计系统之间的接口时，我们必须考虑几个关键点。在设计这个接口时，我们做出的选择与设计面向人的用户界面不同。这里有许多因素需要考虑。让我们逐一来看。
- en: '**Choose your language wisely:** Systems can use many different ways to talk
    to one another, and, just like human conversations, it helps tremendously if all
    parties involved speak the same language. This chapter describes how we can make
    the systems talk to each other, but there are many more. Some ways are better
    suited for a particular environment or use case than others, so you must think
    it through. Do not pick the one you feel most comfortable with because you know
    that solution. Think of all the use case scenarios and then pick the proper protocol.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明智地选择你的语言**：系统可以使用许多不同的方式相互通信，就像人类的对话一样，如果所有参与方都说同一种语言，这会极大地帮助。本章描述了我们可以如何让系统相互通信，但还有更多方法。某些方法可能比其他方法更适合特定的环境或用例，所以你必须仔细思考。不要选择你感到最舒适的那个，因为你已经知道那个解决方案。考虑所有的用例场景，然后选择合适的协议。'
- en: '**Security**: Security is a huge topic, especially in systems programming.
    We are dealing with data, and the systems are hidden deep in our computers. Most
    people do not know that multiple processes are running on their machines, so they
    are not very likely to inspect them and assess their level of security.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：安全性是一个巨大的话题，尤其是在系统编程中。我们正在处理数据，系统隐藏在我们的计算机深处。大多数人不知道他们的机器上正在运行多个进程，因此他们不太可能检查它们并评估其安全性水平。'
- en: '**Data format and serialization**: You must consider the best way to transform
    your data as it moves from one system to another. The data must be part of a package,
    envelope, or other transmitting method. There are many different formats and ways
    to serialize, but which one you choose depends on many factors. For instance,
    if you use a direct memory connection between two 64-bit processes on the same
    Windows machine, you can use a very efficient, lightweight binary representation.
    However, suppose you have to talk to a machine running a different operating system
    on the other side of the globe. In that case, you must devise a serialization
    mechanism both systems understand.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式和序列化**：当你的数据从一个系统转移到另一个系统时，你必须考虑最佳的数据转换方式。数据必须是包、信封或其他传输方式的一部分。有众多不同的格式和序列化方式，但你选择哪一种取决于许多因素。例如，如果你在同一个Windows机器上的两个64位进程之间使用直接内存连接，你可以使用一个非常高效、轻量级的二进制表示。然而，如果你必须与地球上另一侧运行不同操作系统的机器通信，那么你必须设计出两个系统都能理解的序列化机制。'
- en: '**Error handling and robustness**: Software can go wrong. We all know that.
    The problems with bugs and availability scale up exponentially if you are talking
    about multiple independent systems. So, you must be mindful of that. You also
    have to consider what your requirements are. Do you need guaranteed delivery?
    Do you need error recovery? Those two things might be handy, but they come with
    a price. Nothing comes for free, after all. You need to think about those scenarios.
    Usually, you must devise a solution you can get away with and not go overboard
    on error correction schemes.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理和健壮性**：软件可能会出错，我们都知道这一点。如果你在谈论多个独立的系统，那么错误和可用性的问题会呈指数级增长。因此，你必须对此保持警觉。你还必须考虑你的需求。你是否需要保证交付？你是否需要错误恢复？这两者可能很有用，但它们是有代价的。毕竟，没有什么是免费的。你需要考虑这些场景。通常，你必须设计一个可以应对的解决方案，而不是过度依赖错误纠正方案。'
- en: '**Performance and scalability**: Transferring blocks of memory inside a process
    is pretty quick. Moving data between processes can be really slow or even unimaginably
    slow. Moving a block of bits to another machine over a **Transmission Control
    Protocol** (**TCP**) connection is thousands of times slower than doing that in
    memory. Writing data to a disk, even a speedy SSD, is even slower than that.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和可扩展性**：在进程内部传输内存块是非常快的。在进程之间移动数据可能非常慢，甚至难以想象地慢。通过**传输控制协议**（**TCP**）连接将一个内存块移动到另一台机器比在内存中这样做慢数千倍。将数据写入磁盘，即使是快速的固态硬盘，也比这还要慢。'
- en: That means you must ensure optimal IO strategy for those use cases. Setting
    up a connection or creating a file is slow, but you have to do that only once
    for each transfer. Once you have that, you can write the data. If you have lots
    of tiny packets, you might want to bundle them so you only have to initiate it
    once. As we have stated before, it might be a good idea to compress data before
    transmitting. Yes, compression takes CPU cycles, but it might be worth it since
    transferring that data to another system is orders of magnitude slower.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着你必须确保这些用例的最佳I/O策略。建立连接或创建文件可能很慢，但你必须为每次传输只做一次。一旦你有了这个，你就可以写入数据。如果你有很多小数据包，你可能想将它们捆绑在一起，这样你只需要启动一次。正如我们之前所述，在传输之前压缩数据可能是个好主意。是的，压缩会占用CPU周期，但考虑到将数据传输到另一个系统要慢得多，这可能值得。
- en: '**Synchronization and deadlocks**: Once your data leaves your system, you no
    longer know what is happening to it. Other processes might also be asking for
    the recipient’s attention, or the recipient might be out of data. You have to
    be very careful to ensure the data is synchronized. Or not. It depends on your
    use case, of course. Also, deadlocks can occur. You might wait for an operation
    to finish on the recipient’s side, but if that one waits for your system, you
    have a problem. Be mindful of those problem areas.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步和死锁**：一旦你的数据离开你的系统，你就不再知道它发生了什么。其他进程可能也在请求接收方的注意，或者接收方可能已经没有数据了。你必须非常小心，以确保数据同步。或者不。这当然取决于你的用例。此外，死锁也可能发生。你可能会等待接收方完成某个操作，但如果那个操作在等待你的系统，你就遇到了问题。要留意那些问题区域。'
- en: '**Documentation and maintainability**: Sharing data with other systems means
    sharing your data structures with other developers. Do not forget that “other
    developers” could be yourself in six months when you look at what you did and
    wonder what you were thinking. Documenting your work, your thoughts, and the structures
    of your data saves you and your peers a lot of headaches further down the road.
    Do yourself a favor and document your data and its structure, what you did to
    satisfy all the constraints, and your assumptions. That makes your code much more
    maintainable. Of course, this applies to data-sharing scenarios and all software
    development, but it is so much more important when you need to share data with
    other systems. Do not skip on this!'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档和维护性**：与其他系统共享数据意味着与其他开发者共享你的数据结构。别忘了，“其他开发者”可能是六个月后的你自己，当你回顾你所做的一切并想知道你在想什么时。记录你的工作、你的想法和你的数据结构可以为你和你的同伴节省很多麻烦。做件好事，记录你的数据及其结构、你为了满足所有限制所做的工作，以及你的假设。这使得你的代码更容易维护。当然，这适用于数据共享场景和所有软件开发，但在你需要与其他系统共享数据时，这一点尤为重要。不要跳过这一步！'
- en: '**Platform and environment constraints**: You might not always be aware of
    the kind of hardware your data will be shared with. If you do not know this, you
    must consider all available options. Assume the worst and plan for that. For instance,
    if you transmit data packets of a couple of gigabytes, encrypted and wrapped in
    a compression algorithm, you might get complaints that the recipient is a very
    low-end IOT device with limited memory and CPU power.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台和环境限制**：你未必总是清楚你的数据将会与哪种硬件共享。如果你不知道这一点，你必须考虑所有可用的选项。假设最坏的情况，并为此做好准备。例如，如果你传输几个吉字节的数据包，加密并使用压缩算法包装，你可能会收到投诉，说接收方是一个非常低端的IOT设备，内存和CPU处理能力有限。'
- en: Not all platforms support all of the strategies I outline in this chapter. For
    instance, Windows Messages, which we discuss next, is only available on Windows.
    The name sort of gives it away, doesn’t it? Be aware of the platform and environment
    constraints and design your data sharing around those.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有平台都支持我在本章中概述的所有策略。例如，我们接下来要讨论的Windows消息，仅在Windows上可用。名字多少有点暗示，不是吗？要意识到平台和环境限制，并围绕这些限制设计你的数据共享。
- en: 'So, now that you know the considerations to take when choosing a communication
    method, let’s look at what methods we have available. We start with a classic:
    Windows Messages.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你已经知道了在选择通信方法时要考虑的因素，让我们看看我们有哪些可用方法。我们从一个经典的方法开始：Windows消息。
- en: Windows Messages
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows消息
- en: '**Windows Messages** are the oldest type of IPC in Windows. They may not be
    the best choice when writing systems software, but they can be helpful. More importantly,
    they are extremely fast and lightweight. However, as the name suggests, they are
    a Windows-only feature.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows消息**是Windows中最老类型的IPC。当编写系统软件时，它们可能不是最佳选择，但它们可能很有帮助。更重要的是，它们非常快且轻量级。然而，正如其名所示，它们是Windows特有的功能。'
- en: Messages work with windows. I do not mean the operating system; I am talking
    about the screens on your monitor. Almost everything on the GUI in Windows is
    a window. The windows obviously are, but so are buttons, edit boxes, text boxes,
    sliders, and so on. The operating system communicates with your application by
    sending messages to a window. Your application has at least one main window, which
    then distributes the message to the *subwindows* or handles the messages for those
    subwindows. However, each window can have its own message-handling logic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 消息与窗口一起工作。我说的不是操作系统；我指的是您监视器上的屏幕。Windows中的几乎所有GUI元素都是一个窗口。窗口显然是，但按钮、编辑框、文本框、滑块等等也都是。操作系统通过向窗口发送消息与您的应用程序通信。您的应用程序至少有一个主窗口，然后它会将消息分发到*子窗口*或处理那些子窗口的消息。然而，每个窗口都可以有自己的消息处理逻辑。
- en: Since messages work with graphical screen elements, such as buttons, labels,
    and list boxes, you might think they cannot be used on console applications or
    Windows services. That is technically correct, but we can get around that. We
    can create a hidden window that can receive the messages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息与图形屏幕元素（如按钮、标签和列表框）一起工作，你可能认为它们不能用于控制台应用程序或Windows服务。这在技术上是对的，但我们可以绕过这一点。我们可以创建一个隐藏的窗口来接收这些消息。
- en: A message is straightforward. It is nothing but a structure containing four
    numeric parameters. This is what the parameters are and what they are used for.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 消息很简单。它只是一个包含四个数字参数的结构。这就是参数是什么以及它们用于什么。
- en: '| **Name** | **Type /** **C# Type** | **Description** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型 /** **C# 类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `hWnd` | HWND / IntPtr | The unique handle of the window that is to receive
    the message |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `hWnd` | HWND / IntPtr | 要接收消息的窗口的唯一句柄 |'
- en: '| `Msg` | UINT / uint | The ID of the message |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Msg` | UINT / uint | 消息的ID |'
- en: '| `wParam` | WPARAM / IntPtr | An additional parameter, or pointer to a data
    structure |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `wParam` | WPARAM / IntPtr | 一个附加参数，或数据结构的指针 |'
- en: '| `lParam` | LPARAM / IntPtr | An additional parameter, or pointer to a data
    structure |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `lParam` | LPARAM / IntPtr | 一个附加参数，或数据结构的指针 |'
- en: 'Table 6.1: Parameters in a Windows Message'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：Windows消息中的参数
- en: That is all that a message has. The `wParam` and `lParam` pointers point to
    some memory containing the payload. They can also be just a number if that is
    all you want to send. In 16-bit Windows, `wParam` was 16 bits, and `lParam` was
    32\. In 32-bit versions of Windows, they are both 32-bit long, and in 64-bit versions,
    they are both 64-bit long. So, there is no real difference between `wParam` and
    `lParam` anymore regarding length.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 消息就这么多。`wParam` 和 `lParam` 指针指向包含有效载荷的内存。如果只想发送数字，它们也可以只是一个数字。在16位Windows中，`wParam`
    是16位，`lParam` 是32位。在Windows的32位版本中，它们都是32位长，在64位版本中，它们都是64位长。因此，在长度方面，`wParam`
    和 `lParam` 没有真正的区别了。
- en: These messages are all communications from the operating system to your application.
    If the user moves the mouse over your window, you get notified. Well, in the case
    of the mouse movement, you get hundreds of notifications. If the user presses
    a key, you get a message. If the user resizes the window, you get another message.
    Anything that happens on the operating system that might be interesting for your
    application is sent to you as a message. There are hundreds, if not thousands,
    of messages sent to your application all the time. Your application is required
    to listen to those messages. We shall see how that works shortly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息都是操作系统向您的应用程序发送的通信。如果用户将鼠标移到您的窗口上，您会收到通知。好吧，在鼠标移动的情况下，您会收到数百个通知。如果用户按下一个键，您会收到一个消息。如果用户调整窗口大小，您会收到另一个消息。操作系统上发生的任何可能对您的应用程序有趣的事情都会以消息的形式发送给您。您的应用程序会一直接收到数百甚至数千条消息。您的应用程序需要监听这些消息。我们很快就会看到它是如何工作的。
- en: The message identifier can be predefined; it can be a number you choose, or
    the operating system can generate it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 消息标识符可以是预定义的；它可以是您选择的数字，或者操作系统可以生成它。
- en: Let me explain what I mean by that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下我的意思。
- en: If Windows sends a message, it is one of the predefined ones. For instance,
    if the mouse has moved, you get the `WM_MOUSEMOVE` message. `WM_MOUSEMOVE` is
    a constant with the `0x0200` value. `wParam` contains information about the state
    of the mouse buttons and keys, such as the *Ctrl* key on your keyboard. You can
    decode these flags to see whether a button is pressed while the mouse moves. `lParam`
    contains both the *X* and the *Y* position of the mouse relative to the upper-left
    corner of the window that receives the message (the first half of `lParam` contains
    the *Y* coordinate, and the second half contains the *X* coordinate).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Windows 发送一个消息，它就是预定义的其中之一。例如，如果鼠标移动了，你会收到 `WM_MOUSEMOVE` 消息。`WM_MOUSEMOVE`
    是一个值为 `0x0200` 的常量。`wParam` 包含有关鼠标按钮和键的状态的信息，例如你键盘上的 *Ctrl* 键。你可以解码这些标志来查看鼠标移动时是否按下了按钮。`lParam`
    包含鼠标相对于接收消息的窗口（左上角）的 *X* 和 *Y* 位置。`lParam` 的前半部分包含 *Y* 坐标，后半部分包含 *X* 坐标。
- en: An interesting message is `WM_CLOSE`. This has the `0x0010` value. If a window
    receives that message, the user wants to close it. If that happens on your main
    window, the application ends.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的消息是 `WM_CLOSE`。它的值是 `0x0010`。如果一个窗口收到这个消息，用户想要关闭它。如果这发生在你的主窗口上，应用程序就会结束。
- en: 'You can also define your own message. There is a constant called `WM_USER`
    (with a value of `0x0400`). You can freely use any of the values between `WM_USER`
    and `0x7FFF` in your application to define your message. One caveat: you can only
    use them if you send those messages to your application’s other windows. You cannot
    use them to communicate with other applications. The reason is simple: you have
    no idea who uses those values outside your system.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义自己的消息。有一个名为 `WM_USER` 的常量（值为 `0x0400`）。你可以在你的应用程序中自由使用 `WM_USER` 和 `0x7FFF`
    之间的任何值来定义你的消息。有一个注意事项：你只能在你向应用程序的其他窗口发送这些消息时使用它们。你不能用它们与其他应用程序通信。原因很简单：你不知道系统外谁使用这些值。
- en: If you want to send messages to other applications, you need to register that
    with Windows. You can call an API to reserve a unique and reserved number as long
    as the computer stays on. If two applications reserve the same message name, they
    get the same ID. This is something you can use to communicate between processes,
    and that is precisely what we will be doing now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要向其他应用程序发送消息，你需要向 Windows 注册。你可以调用一个 API 来保留一个在计算机运行期间唯一的保留号码。如果两个应用程序保留了相同的消息名称，它们将获得相同的
    ID。这可以用来在进程之间进行通信，这正是我们现在要做的。
- en: A sample
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例
- en: To work with messages, we need to use a lot of Win32 APIs. The logic is not
    complex, but this sample requires a lot of setup.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理消息，我们需要使用大量的 Win32 API。逻辑并不复杂，但这个示例需要大量的设置。
- en: 'We can break it down as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其分解如下：
- en: '`Window` class. It’s just like object-oriented programming: you define a class
    first and then create instances. Windows are just like that.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Window` 类。它就像面向对象编程一样：首先定义一个类，然后创建实例。窗口就是这样。'
- en: '**Define the message loop method**: This method gets called as soon as a message
    is available.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义消息循环方法**：这个方法在消息可用时立即被调用。'
- en: '**Create the window**: As soon as that happens, the messages start flowing
    in.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建窗口**：一旦发生，消息就开始流动。'
- en: '`WM_CLOSE`, close the application. If you want to handle the message, do so.
    If not, pass it on to the default handler that all apps get.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WM_CLOSE`，关闭应用程序。如果你想处理这个消息，请这样做。如果不处理，就将其传递给所有应用程序都有的默认处理器。'
- en: That is all there is to it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。
- en: The source code on the GitHub repository for this book contains a sample. I
    have not included it here since the sample requires a lot of boilerplate code
    that takes up several pages. I decided to leave it out of this chapter since Windows
    Messages are not used except for certain specialized cases. However, if you are
    interested, just look at the sample code. With the preceding explanation, you
    can follow along just nicely.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的源代码包含一个示例。我没有在这里包含它，因为该示例需要大量的样板代码，占据了数页。我决定将其从本章中省略，因为除了某些特定情况外，Windows
    消息并未使用。然而，如果你感兴趣，只需查看示例代码。有了前面的解释，你可以很好地跟随。
- en: 'Now you know how Windows Messages work, we can take the next step and look
    into other means. We begin simple enough: pipes.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Windows 消息的工作原理，我们可以继续下一步，看看其他的方法。我们从一个简单的方法开始：管道。
- en: Working with pipes for local IPC
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地 IPC 中使用管道
- en: '**Pipes** originally came from Unix but have also found their way to other
    platforms. A pipe is like a direct connection between two systems. It is very
    lightweight and easy to set up. You can use them to communicate between processes
    on the same machine and between machines across a network. Theoretically, you
    can communicate between Linux and Windows using pipes. I said theoretically because
    since the implementation of the pipes on both platforms is so different, you have
    to jump through many loops to get that working. In fact, the work you must do
    to get it working is so intensive that you might as well use other ways, such
    as sockets, to achieve that same result. That will be much easier to pull off.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道**最初来自Unix，但也已经出现在其他平台上。管道就像两个系统之间的直接连接。它非常轻量级且易于设置。您可以使用它们在同一台机器上的进程之间以及通过网络在不同机器之间进行通信。从理论上讲，您可以使用管道在Linux和Windows之间进行通信。我说理论上是因为由于两个平台上的管道实现差异很大，您必须跳过许多步骤才能使其工作。实际上，您必须做的这项工作非常繁重，您可能更愿意使用其他方式，例如套接字，来实现相同的结果。这将更容易实现。'
- en: 'There are two types of pipes: **named pipe** and **anonymous pipe**. The named
    pipe is the simplest of them.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的管道：**命名管道**和**匿名管道**。命名管道是最简单的一种。
- en: Named pipes
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名管道
- en: '**Named pipes** are a great solution if you want to communicate from one process
    to another on the same machine. Communicating over a network is not complex but
    requires more thought concerning security and access rights.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名管道**是如果您想在同一台机器上的一个进程与另一个进程之间进行通信时的一个很好的解决方案。通过网络进行通信并不复杂，但需要更多关于安全和访问权限的思考。'
- en: In .NET, you can use the `NamedPipeServerStream` and `NamedPipeClientStream`
    classes to get this working.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，您可以使用`NamedPipeServerStream`和`NamedPipeClientStream`类来实现这一点。
- en: The code is straightforward. For example, let us look at a server waiting for
    a connection. We also added a client that connects to that server. As soon as
    the connection is established, the server sends a message to the client, which
    will be displayed on the screen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单。例如，让我们看看一个等待连接的服务器。我们还添加了一个连接到该服务器的客户端。一旦建立连接，服务器就会向客户端发送一条消息，该消息将在屏幕上显示。
- en: 'Here is the server code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是服务器代码：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Again, I am using my `Dump()` extension method here to colorize the messages
    on the screen quickly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我使用我的`Dump()`扩展方法在这里快速着色屏幕上的消息。
- en: First, I create an instance of `NamedPipeServerStream`. As a parameter, I give
    it a unique name. If I use a name that is already registered, I get access to
    that other named pipe. The names are unique on your machine but are gone once
    `NamedPipeServerStream` is disposed of.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我创建了一个`NamedPipeServerStream`的实例。作为一个参数，我给它提供了一个唯一的名称。如果我使用一个已经注册的名称，我将能够访问那个其他命名管道。这些名称在您的机器上是唯一的，但一旦`NamedPipeServerStream`被销毁，它们就会消失。
- en: Then, we wait for a connection. When a client connects, we create `StreamWriter`,
    give it the named pipe server stream, and write the data to the stream.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们等待连接。当客户端连接时，我们创建`StreamWriter`，将其命名为管道服务器流，并将数据写入流。
- en: 'We use `AutoFlush` on the writer: we don’t want data hanging around.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在写入器上使用`AutoFlush`：我们不希望数据悬挂在那里。
- en: 'Let’s look at the client code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看客户端代码：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code should look familiar. We create an instance of `NamedPipeClientStream`
    (instead of a server) and give it two parameters. The first is the name of the
    computer on the network (in our case, our own computer as specified by the dot).
    The second parameter is the name of the pipe. Obviously, this should be the same
    as we used for the server stream.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来应该很熟悉。我们创建了一个`NamedPipeClientStream`（而不是服务器）的实例，并给它提供了两个参数。第一个参数是网络上计算机的名称（在我们的例子中，是我们自己的计算机，由点指定）。第二个参数是管道的名称。显然，这应该与我们用于服务器流的名称相同。
- en: We connect the client to the pipe, create an instance of `StreamReader` with
    that client, and read the data. Lastly, we display the data coming from the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将客户端连接到管道，使用该客户端创建一个`StreamReader`实例，并读取数据。最后，我们显示来自服务器的数据。
- en: Anonymous pipes
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名管道
- en: '**Anonymous pipes** work more or less the same way as named pipes do. They
    provide a lightweight way of connecting processes to each other. However, there
    are differences between the named pipes and the anonymous pipes. The following
    table highlights the most important ones:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**匿名管道**的工作方式与命名管道大致相同。它们提供了一种轻量级的方式将进程连接起来。然而，命名管道和匿名管道之间存在一些差异。以下表格突出了其中最重要的几个：'
- en: '| **Feature** | **Named pipes** | **Anonymous pipes** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **命名管道** | **匿名管道** |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Identification** | Named. You can find them using the name. | Unnamed.
    You have to know the runtime handle to connect. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **识别** | 命名的。你可以通过名称找到它们。 | 未命名的。你必须知道运行时句柄才能连接。 |'
- en: '| **Communication** | Both local and networked. | Only local. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **通信** | 本地和网络通信。 | 只有本地通信。 |'
- en: '| **Peers** | Multiple clients per server. Can be set up to handle bidirectional
    conversations. | One-on-one only. Also, one way only |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **对等方** | 每个服务器可以有多个客户端。可以设置为处理双向对话。 | 只有一对一。也只有单向。 |'
- en: '| **Complexity** | More complex. Allows for asynchronous communications, also
    able to do fire-and-forget scenarios. | More simple. Straightforward one-way parent-child
    communication. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **复杂性** | 更复杂。允许进行异步通信，也能处理“发送后即忘”的场景。 | 更简单。直接的一对一父-子通信。 |'
- en: '| **Security** | Supports ACL to enable secure communications. | No security
    features are available. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **安全性** | 支持ACL以启用安全通信。 | 没有安全功能可用。 |'
- en: '| **Speed** | Slower due to more control. | Fast. Almost no overhead. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **速度** | 由于控制更多而较慢。 | 快速。几乎没有开销。 |'
- en: 'Table 6.2: Comparison of features between named pipes and anonymous pipes.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2：命名管道和匿名管道功能比较。
- en: 'The code to set up an anonymous pipe is actually quite simple. Let’s start
    with the server code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 设置匿名管道的代码实际上非常简单。让我们从服务器代码开始：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let me walk you through this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我带你了解这个过程。
- en: 'First, I create an instance of `AnonymousPipeServerStream`. This class handles
    all the setting up of the communication. We can tell that it can either send or
    receive code. We cannot use the supplied `PipeDirection.InOut` enum: that will
    throw an exception. Remember: anonymous pipes are one-way.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我创建了一个 `AnonymousPipeServerStream` 的实例。这个类处理所有通信的设置。我们可以看出它既可以发送也可以接收代码。我们不能使用提供的
    `PipeDirection.InOut` 枚举：这将抛出异常。记住：匿名管道是单向的。
- en: We need to make sure the handle can be inherited as well. This is because the
    client needs to “inherit” this handle. After all, this is the only way we can
    identify the pipe. There is no name; it is anonymous!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保句柄可以被继承。这是因为客户端需要“继承”这个句柄。毕竟，这是我们唯一能够识别管道的方式。没有名称；它是匿名的！
- en: We call `GetClientHandleAsString` so we know what to use on the client side.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `GetClientHandleAsString` 以确定客户端应使用的内容。
- en: When you create `AnonymousPipeServerStream`, it automatically creates a client
    as well. This can be handy if you want to communicate inside your process. However,
    if another process needs to talk to this server, you have a problem. Anonymous
    pipes are single-connection only. The call to `DisposeLocalCopyOfClientHandle`
    removes the local client, so we have room for another client.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 `AnonymousPipeServerStream` 时，它也会自动创建一个客户端。如果你想在进程内部进行通信，这会很有用。然而，如果另一个进程需要与这个服务器通信，你将遇到问题。匿名管道仅支持单连接。调用
    `DisposeLocalCopyOfClientHandle` 会移除本地客户端，这样我们就有空间为另一个客户端服务。
- en: Then, we create a stream, give it the pipe, and write to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个流，将其与管道关联，并向其写入。
- en: Finally, we call `WaitForPipeDrain`, a blocking call that only continues if
    the client has read all the data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `WaitForPipeDrain`，这是一个阻塞调用，只有当客户端读取完所有数据时才会继续。
- en: 'The client is even more simple:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端甚至更简单：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We read the handle from the console first. This is the output from our server,
    so we have that available. Then, we create the client by creating an instance
    of `AnonymousPipeClientStream`, telling it to be ready for incoming data, and
    giving it the handle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从控制台读取句柄。这是服务器的输出，所以我们有可用的内容。然后，我们通过创建 `AnonymousPipeClientStream` 的实例来创建客户端，告诉它准备接收数据，并给它句柄。
- en: Then, we create `stream` and read from it. That’s it!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建 `stream` 并从其读取。就这样！
- en: 'There is one big caveat. Suppose you write these two console applications and
    you run them. In that case, you see that as soon as you try to create an instance
    of that `AnonymousPipeClientStream`, you get an `InvalidHandle` exception. The
    reason is that Windows separates the processes, ensuring security is as high as
    possible. If you run two processes, they cannot reach each other’s handles. So,
    it cannot access the pipe, which means you cannot communicate. I am afraid there
    is nothing we can do about that. If you think about it, it does make sense, though.
    You can only have one-on-one communications. So, if multiple console apps connect
    to the server, how do you ensure this one-on-one behavior? The answer is: you
    cannot.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很大的注意事项。假设你编写了这两个控制台应用程序并运行它们。在这种情况下，你会看到，当你尝试创建`AnonymousPipeClientStream`的实例时，你会得到一个`InvalidHandle`异常。原因是Windows将进程分开，确保安全性尽可能高。如果你运行两个进程，它们无法相互访问句柄。因此，它无法访问管道，这意味着你无法通信。恐怕我们对此无能为力。如果你仔细想想，这确实是有道理的。你只能进行一对一的通信。所以，如果多个控制台应用程序连接到服务器，你怎么确保这种一对一的行为呢？答案是：你不能。
- en: If you want separate console apps, you should use named pipes instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要独立的控制台应用程序，你应该使用命名管道。
- en: 'However, if you want to use the example I supplied, you can ensure the client
    and the server run in the same address space. You do this by launching the client
    from the server. That looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想使用我提供的示例，你可以确保客户端和服务器在同一个地址空间中运行。你可以通过从服务器启动客户端来实现这一点。看起来是这样的：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Do not forget to change the client to get the handle from the `args` parameter
    given to the `Main` method instead of getting it from the user through the console.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将客户端更改为从`Main`方法提供的`args`参数中获取句柄，而不是通过控制台从用户那里获取。
- en: The secret here is the line where we set `UseShellExecute` to `False`. If it
    is `True`, the client starts in another shell, thus isolating it from the server.
    By setting this to `False`, we prevent that and can access the handle and, consequently,
    the pipe.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的秘密在于我们设置`UseShellExecute`为`False`的那一行。如果它是`True`，客户端将在另一个shell中启动，从而将其与服务器隔离开来。通过将其设置为`False`，我们防止了这种情况，并可以访问句柄，从而可以访问管道。
- en: If they fit your scenario, anonymous pipes are a great addition to your communications
    toolbelt. They are fast and lightweight, just the sort of thing we love as systems
    programmers. However, there are other ways to communicate that might even be better,
    although they are not as simple. Let’s talk about sockets…
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们适合你的场景，匿名管道是通信工具箱中的绝佳补充。它们速度快且轻量级，这正是我们作为系统程序员所喜欢的。然而，还有其他可能更好的通信方式，尽管它们并不那么简单。让我们来谈谈套接字…
- en: Using sockets to establish network-based IPC
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字建立基于网络的IPC
- en: Sockets are awesome. They are a bit like the Swiss Army knife for communications.
    The downsides of pipes and Windows messages are gone when you move to sockets.
    Of course, nothing comes for free, so be prepared to spend a lot of time thinking
    about error handling and memory management. Still, once you get the idea, sockets
    are not hard to use.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字很棒。它们有点像通信领域的瑞士军刀。当你转向套接字时，管道和Windows消息的缺点就消失了。当然，没有免费的午餐，所以请准备好花大量时间思考错误处理和内存管理。尽管如此，一旦你掌握了这个概念，套接字并不难使用。
- en: '**Sockets** are endpoints of a connection over a network between two systems.
    Of course, the systems can live on the same machine, but they can also be at different
    ends of the world. Thanks to all the hard work people have done building networks
    since the 1960s, we can now reach all sorts of machines worldwide.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**套接字**是两个系统之间通过网络连接的端点。当然，系统可以位于同一台机器上，但它们也可以位于世界的两端。多亏了自20世纪60年代以来人们为构建网络所做的大量工作，我们现在可以接触到全球的各种机器。'
- en: Networking 101
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络基础
- en: Computer networks have been around for a long time. However, each supplier had
    its own way of making machines talk to one another. Over time, standards emerged.
    As it goes with standards, there were many to choose from. These days, we have
    more or less standardized on setting up a network, so you no longer have to worry
    about that.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络已经存在很长时间了。然而，每个供应商都有自己的方式让机器相互通信。随着时间的推移，标准出现了。正如标准所做的那样，有好多可供选择。如今，我们在设置网络方面已经或多或少实现了标准化，所以你再也不必担心这个问题了。
- en: But before we dive into the specifics, we need to talk about **Open Systems
    Interconnection** (**OSI**) first.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入具体细节之前，我们需要先谈谈**开放系统互联**（**OSI**）。
- en: OSI is a layered architecture where you can describe how a network works. Each
    layer builds on top of the previous one (with the apparent exception of the first
    layer).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: OSI是一个分层架构，你可以用它来描述网络的工作方式。每一层都建立在上一层之上（第一层似乎是一个例外）。
- en: 'There are seven layers, and this is what they describe:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 共有七层，以下是它们的描述：
- en: '**Level 1 – Physical**: This is what describes the hardware. For example, what
    a cable looks like, how the switches are working, the electrical voltages that
    are applied, and so on.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1层 – 物理层**：这是描述硬件的部分。例如，电缆的外观，开关的工作方式，施加的电压等。'
- en: '**Level 2 – Data Link**: This describes how systems connect over the physical
    layers. Here, we describe how ethernet or Wi-Fi works. The MAC addresses (unique
    number per network device) are defined here.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2层 – 数据链路层**：这一层描述了系统如何在物理层上连接。在这里，我们描述了以太网或Wi-Fi的工作方式。MAC地址（每个网络设备的唯一编号）在这里定义。'
- en: '**Level 3 – Network**: This one is all about routing and addressing. There
    are several protocols defined on level 3, such as **Internet Control Message Protocol**
    (**ICMP**), which is used for network diagnostics and error reporting, **Address
    Resolution Protocol** (**ARP**), used for address resolution, Bluetooth, and,
    of course, **Internet Protocol** (**IP**), both v4 and v6.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3层 – 网络层**：这一层完全是关于路由和寻址。在第3层定义了几个协议，例如**互联网控制消息协议**（**ICMP**），用于网络诊断和错误报告，**地址解析协议**（**ARP**），用于地址解析，蓝牙，当然还有**互联网协议**（**IP**），包括v4和v6。'
- en: '**Level 4 – Transport**: This layer is responsible for end-to-end communication
    and reliability. TCP and **User Datagram Protocol** (**UDP**), the topics of this
    chapter, live in this layer.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第4层 – 传输层**：这一层负责端到端通信和可靠性。TCP和**用户数据报协议**（**UDP**），本章的主题，位于这一层。'
- en: '**Level 5 – Session**: this manages the sessions between applications.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5层 – 会话层**：这一层管理应用程序之间的会话。'
- en: '**Level 6 – Presentation**: This layer ensures the data is presented in a format
    other systems can understand.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6层 – 表示层**：这一层确保数据以其他系统可以理解的形式呈现。'
- en: '**Level 7 – Application**: here are the applications that use the network.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第7层 – 应用层**：这里列出了使用网络的程序。'
- en: The hardware and the operating system handle levels 1 through 4\. Levels 5 through
    7 are ours to take care of.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和操作系统处理第1层至第4层。第5层至第7层由我们来负责。
- en: Almost all systems use TCP as a transport layer, but sometimes people choose
    UDP. I start by explaining TCP and how to use it, and I move to UDP at the end
    of this part. IP is more or less a given. We could choose other network-level
    protocols, but that would make life unnecessarily complicated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有系统都使用TCP作为传输层，但有时人们会选择UDP。我先解释TCP及其使用方法，然后在本文这部分结束时转向UDP。IP几乎是既定的。我们可以选择其他网络层协议，但这会使生活变得不必要地复杂。
- en: 'Setting up the session (level 5) is where we write the code to set up the connection
    on the client or server. The presentation, level 6, is about how we package the
    data: how we serialize, what encoding to use, and so on. We have covered that
    already extensively. Level 7 is just our app; I leave that one to you.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 设置会话（第5层）是我们编写代码在客户端或服务器上建立连接的地方。表示层（第6层）是关于我们如何打包数据：我们如何序列化，使用什么编码等。我们已经对此进行了广泛的讨论。第7层只是我们的应用程序；我将这一层留给你。
- en: So, let’s write some level 5 code!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们编写一些第5层的代码！
- en: A TCP-based chat app
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于TCP的聊天应用程序
- en: 'The “hello-world” application for networking is a chat app. That sort of app
    allows us to investigate how systems can connect and exchange data without dealing
    with technicalities about what kind of data is passed between them. The type of
    data is part of the application, which we learned is level 7 in the OSI model.
    We do not care about that here. Level 6 is presentation, but for a simple chat
    application, we can get away with something straightforward: we take a string
    and encode that in UTF8 bytes (and back again, of course). Since the OS takes
    care of levels 1 up to 3, we only have to deal with 4 and 5.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的“hello-world”应用程序是一个聊天应用程序。这类应用程序使我们能够研究系统如何连接并交换数据，而不必处理它们之间传递的数据类型的技术细节。数据类型是应用程序的一部分，我们在OSI模型中了解到它是第7层。我们对此不感兴趣。第6层是表示层，但对于一个简单的聊天应用程序，我们可以简单地处理：我们取一个字符串并将其编码为UTF8字节（当然，也可以反向操作）。由于操作系统负责第1层至第3层，我们只需处理第4层和第5层。
- en: Let’s make it happen.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让它成为现实。
- en: I want to use TCP here, which is an excellent protocol that gives us reliability
    and guarantees the order in which the data arrives. It is also effortless to set
    up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里使用TCP，这是一个非常优秀的协议，它为我们提供了可靠性并保证了数据到达的顺序。它也非常容易设置。
- en: 'The server looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器看起来是这样的：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since so much is happening, I decided to use line numbers here. That makes it
    a bit easier to refer to what I am explaining.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发生了很多事情，我决定在这里使用行号。这使得引用我所解释的内容变得容易一些。
- en: 'In line 7, we create a new instance of the `TcpListener` class. This class
    handles all the details about communications, but it needs some information from
    us about that. We give the constructor two parameters that tell it all it needs
    to know. The first is the address we use. The address is the unique identifier
    for a network adapter, such as your ethernet or Wi-Fi adapter. This IP address
    is part of level 3, the network level of the OSI model. It is part of the IP specifications.
    However, multiple applications can simultaneously use a network adapter in a computer.
    We can specify a port number to ensure all the applications get the data they
    need and send it to the correct application on the other end of the line. This
    more or less arbitrary number decides what application connected to that IP address
    gets the data. This port number is part of level 4 of the OSI model. I said the
    number is more or less arbitrary. Technically, you can choose whatever number
    you desire, but there are conventions about these numbers. Since the port decides
    what application gets or sends the data, standards help ensure we all use the
    same ports for the same applications. Web servers, for instance, listen to port
    `80` unless they use the secure HTTPS protocol. That one uses port `443`. There
    are a lot of “reserved” numbers, but technically, nothing stops you from using
    port `80` for your chat application. I would not recommend doing so, though: it
    confuses other people.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7行，我们创建了一个新的`TcpListener`类实例。这个类处理所有关于通信的细节，但它需要我们从它那里获取一些信息。我们向构造函数提供了两个参数，告诉它所有需要知道的信息。第一个是我们使用的地址。地址是网络适配器的唯一标识符，例如您的以太网或Wi-Fi适配器。这个IP地址是OSI模型的第3层，即网络层的一部分。它是IP规范的一部分。然而，多个应用程序可以同时在一个计算机中使用网络适配器。我们可以指定端口号以确保所有应用程序都能获得它们所需的数据，并将其发送到线路另一端的正确应用程序。这个或多或少是任意选择的数字决定了连接到该IP地址的应用程序将获得哪些数据。这个端口号是OSI模型的第4层。我说这个数字或多或少是任意的。技术上，你可以选择你想要的任何数字，但关于这些数字有一些约定。由于端口号决定了哪个应用程序获取或发送数据，因此标准有助于确保我们所有人都为相同的应用程序使用相同的端口。例如，Web服务器默认监听端口`80`，除非它们使用安全的HTTPS协议。后者使用端口`443`。有很多“保留”的数字，但技术上，没有任何东西阻止你为你的聊天应用程序使用端口`80`。尽管如此，我不建议这样做：这会混淆其他人。
- en: I want to ensure our chat server listens on port `8080`, a “free to use” number.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我想确保我们的聊天服务器监听端口`8080`，这是一个“免费使用”的数字。
- en: 'I have used the word “listening” a few times here. Listening means that the
    application waits for another process, either on our machine or on an external
    one, to connect. Compare it to waiting for the phone to ring: you are listening
    for your ringtone and ready to pick it up if it goes.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里多次使用了“监听”这个词。监听意味着应用程序等待另一个进程连接，无论是我们机器上的还是外部机器上的。将其与等待电话响铃进行比较：你在等待你的铃声响起，并准备好接听。
- en: Since your machine can have multiple network adapters, you must specify which
    one you want to listen to. In this case, I chose a fixed IP address, `IPAddress.Loopback`,
    which translates to the `127.0.0.1` IPv4 address. This address is the local machine,
    not attached to any actual adapter. In other words, we only listen to connections
    from the same physical machine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的机器可以有多个网络适配器，您必须指定您想要监听哪一个。在这种情况下，我选择了一个固定的IP地址，`IPAddress.Loopback`，它对应于`127.0.0.1`
    IPv4地址。这个地址是本地机器，没有连接到任何实际的适配器。换句话说，我们只监听来自同一物理机器的连接。
- en: 'Line 8 is straightforward: we start the server. With the call to `AcceptTcpClienAsync`
    in line 14, we tell the server to accept any incoming connection.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行很简单：我们启动服务器。在第14行的`AcceptTcpClientAsync`调用中，我们告诉服务器接受任何传入的连接。
- en: 'Multiple clients can connect to the same server at the same time. The client
    here is what represents the connected client. We only expect one client, so we
    do not have to deal with sessions. Remember: session management is level 5 of
    the OSI model. We assume one and only one client, and we store that in the variable
    client. The type of client is `TcpClient`, in case you were wondering.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 多个客户端可以同时连接到同一个服务器。这里的客户端代表的是已连接的客户端。我们只期望有一个客户端，所以我们不需要处理会话。记住：会话管理是OSI模型的第5层。我们假设只有一个客户端，并将它存储在变量`client`中。客户端的类型是`TcpClient`，以防你有所疑问。
- en: This call is blocking, and only continues when a client is connected, something
    we tell the user with the message on line 15.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用是阻塞的，并且只有当客户端连接时才会继续，我们通过第15行的消息告诉用户这一点。
- en: As soon as we have established a connection, we open a stream to access the
    client’s data or to enable us to send data to that client. This stream, of the
    `NetworkStream` type, is bidirectional. We store that stream in the variable stream
    in line 17.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了连接，我们就打开一个流来访问客户端的数据或使我们能够向该客户端发送数据。这个流是`NetworkStream`类型，它是双向的。我们在第17行将这个流存储在变量`stream`中。
- en: Data comes in binary. Therefore, we use `ReadAsync` to read a buffer of data.
    I assume that no incoming data exceeds 1,024 bytes. You probably cannot make that
    assumption in a real-world application, so you must keep reading until you have
    all the data. Here, we store that data in a byte array of 1,024 bytes long (lines
    20 and 21) and convert that to a UTF8 string (lines 22). This is how our data
    is presented, which is level 6 of the OSI model. As soon as we have that string,
    we display it. If the string is “bye” we take it that the client wants to disconnect.
    Otherwise, we allow the user on the server end to enter a response and send that
    string to the client after converting it to another byte array. We use the same
    stream here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以二进制形式传入。因此，我们使用`ReadAsync`来读取一个数据缓冲区。我假设没有传入的数据超过1,024字节。在现实世界的应用中，你可能无法做出这个假设，所以你必须继续读取，直到你有了所有数据。在这里，我们将这些数据存储在一个长度为1,024字节的字节数组中（第20和21行），并将其转换为UTF8字符串（第22行）。这就是我们的数据呈现方式，它是OSI模型的第6层。一旦我们有了这个字符串，我们就显示它。如果字符串是“bye”，我们就认为客户端想要断开连接。否则，我们允许服务器端的用户输入一个响应，并在将其转换为另一个字节数组后将其发送给客户端。我们在这里使用相同的流。
- en: If the stream contains no more data or someone uses the word “bye” in the conversation,
    we close the connection (line 37) and stop listening (line 38).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流中没有更多数据，或者有人在对话中使用“bye”这个词，我们将在第37行关闭连接，并在第38行停止监听。
- en: 'The client is very similar in code. Here it is:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的代码非常相似。下面是代码：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In line 6, we create a new instance of the `TcpClient` class. Again, we have
    to give it an IP address and a port. This time, we have to use an actual number.
    We use `127.0.0.1`, so we are looking for a server on the same machine. The port
    is again `8080`; otherwise, our server never sees any connection coming in.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，我们创建了一个新的`TcpClient`类实例。同样，我们必须给它一个IP地址和一个端口号。这次，我们必须使用一个实际的数字。我们使用`127.0.0.1`，这意味着我们正在寻找同一台机器上的服务器。端口号仍然是`8080`；否则，我们的服务器将看不到任何进入的连接。
- en: This call is again blocking, so it will not continue until a connection has
    been made. We can access the stream once we have a connection, as in line 8\.
    This stream is, once again, of the `NetworkStream` type, so we have a bidirectional
    connection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用又是阻塞的，所以它不会继续，直到建立了一个连接。一旦我们有了连接，我们就可以访问流，就像第8行那样。这个流，再次，是`NetworkStream`类型，所以我们有一个双向连接。
- en: We do the same thing as we did for the server. We assume a message size of 1,024
    bytes or less. We convert strings to and from byte arrays using UTF8 as encoding.
    We use the word “bye” to signal a desire to stop talking, and we use `client.Close()`
    to finalize the connection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为服务器所做的同样的事情。我们假设消息大小为1,024字节或更少。我们使用UTF8作为编码将字符串转换为字节数组，并从字节数组转换回字符串。我们使用“bye”这个词来表示停止交谈的愿望，并使用`client.Close()`来最终化连接。
- en: 'As you can see, the code is very similar to the server’s. We simplified many
    things here: we do not consider having multiple clients connecting to one server.
    We make many assumptions about the message size and have to fall back or retry
    mechanisms in case things go wrong. When working with connections across machines,
    things go wrong often, so you must be aware of that and code accordingly. However,
    since that has nothing to do with the actual networking code, as I have shown
    you here, I can safely leave that to you to figure out.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码与服务器非常相似。我们在这里简化了许多事情：我们不考虑多个客户端连接到单个服务器的情况。我们对消息大小做了许多假设，并在出错时必须回退或重试机制。当跨机器工作连接时，事情出错是常有的事，所以你必须意识到这一点，并相应地编写代码。然而，由于这与实际的网络代码无关，正如我向你展示的那样，我可以安全地将这留给你去解决。
- en: UDP
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP
- en: 'TCP is a great protocol, but it is not the only one. **UDP** is more straightforward
    and lighter. Of course, that comes with disadvantages as well. I outline the differences
    between the two protocols in the following table:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是一个优秀的协议，但它并非唯一。**UDP** 更直接且更轻量。当然，这也伴随着一些缺点。以下表格中，我概述了这两种协议之间的差异：
- en: '| **Consideration** | **TCP** | **UDP** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **考虑因素** | **TCP** | **UDP** |'
- en: '| --- | --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Main objective | Reliability | Speed |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 主要目标 | 可靠性 | 速度 |'
- en: '| Ordering | Order guaranteed | No guarantee about the order of messages |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 顺序 | 保证顺序 | 不保证消息顺序 |'
- en: '| Handshaking | Yes | No |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 握手 | 是 | 否 |'
- en: '| Error Checking | Yes | No |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 错误检查 | 是 | 否 |'
- en: '| Congestion control | Yes | No |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 拥塞控制 | 是 | 否 |'
- en: '| Use case | Web browsing, chatting, file transfer, email | Video streaming,
    online gaming, VOIP |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | 网络浏览、聊天、文件传输、电子邮件 | 视频流、在线游戏、VOIP |'
- en: 'Table 6.3: TCP and UDP compared'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3：TCP 和 UDP 对比
- en: TCP is reliable. Message almost always arrives. When things go wrong, TCP tries
    to resend the data until it has been delivered. UDP doesn’t care about that. It
    just tries to get the data out there as fast as possible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是可靠的。消息几乎总是到达。当事情出错时，TCP 会尝试重新发送数据，直到数据被成功交付。UDP 不关心这一点。它只是尽可能快地将数据发送出去。
- en: 'TCP ensures that messages arrive in the same order as they have been sent.
    UDP, however, does not: messages could arrive at the destination in a different
    order than how they left the origin.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 确保消息按照发送的顺序到达。然而，UDP 并不保证：消息可能会以不同于离开源地的顺序到达目的地。
- en: TCP makes sure the other end is ready to communicate. UDP just starts sending
    data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 确保另一端准备好通信。UDP 只是开始发送数据。
- en: 'TCP checks the data to see whether errors have occurred during transmission
    and can even fix some. UDP does not care: as long as the data is sent, it is happy
    with it.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 检查数据以查看在传输过程中是否发生错误，甚至可以修复一些错误。UDP 并不关心：只要数据被发送，它就对此感到满意。
- en: If the network gets congested, TCP can slow down transmission to help alleviate
    that. UDP dumps data as fast as possible, regardless of network conditions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络拥塞，TCP 可以减慢传输速度以帮助缓解。UDP 会尽可能快地丢弃数据，而不考虑网络条件。
- en: 'TCP is best used when you must have a reliable, error-free way of transmitting
    data. For instance, with chat, the message must come across as intended, in the
    correct order. UDP, however, is all about speed. Video streaming comes to mind:
    if part of the data stream is lost sometimes, it is not a big deal. Slow streams,
    however, are killing the experience.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须有一个可靠、无错误的传输数据方式时，TCP 是最佳选择。例如，在聊天中，消息必须以预期的顺序正确传达。然而，UDP 完全是关于速度的。视频流就是一个例子：如果数据流中有时丢失了一部分，那并不是什么大问题。但是，缓慢的流会毁掉体验。
- en: UDP is not often used, but it can be a valuable tool in your belt.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 不常被使用，但它可以成为你工具箱中的一个宝贵工具。
- en: Using shared memory to exchange data between processes
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享内存在进程间交换数据
- en: 'So far, we have been sending messages to other processes on the same computer.
    With named pipes and sockets, we could have used other machines as well. That’s
    the beauty of those protocols: they are network agnostic. However, if you are
    sure you want to stay on the same machine, using pipes or sockets can be a burden.
    These methods are not the fastest way to communicate. In those cases, you might
    be better off using **shared memory**.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在向同一台计算机上的其他进程发送消息。使用命名管道和套接字，我们也可以使用其他机器。这正是这些协议的美丽之处：它们对网络是透明的。然而，如果你确定你只想留在同一台机器上，使用管道或套接字可能会成为一种负担。这些方法并不是最快的通信方式。在这种情况下，你可能更愿意使用
    **共享内存**。
- en: Shared memory is effortless to set up. And yes, of course, that comes with downsides.
    There is almost no way to secure the data or to prevent collisions. However, it
    is fast; really, really fast. So, let’s look at a sample.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存的设置非常简单。当然，这也伴随着一些缺点。几乎没有任何方法可以保证数据的安全或防止冲突。然而，它的速度非常快；真的，非常快。所以，让我们看看一个示例。
- en: 'First, we look at how to write data to shared memory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看如何将数据写入共享内存：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Shared memory is like having a file that only exists in memory. It’s a block
    reserved in memory. It has a name you can use to identify it. Again, it is just
    like a file. Here, we create a new instance of the `MemoryMappedFile` class, giving
    it a name and a size. (in our case, 1,024 bytes). If you want to use that file,
    you must get `MemoryMappedViewAccessor`. You can get that by calling `CreateViewAccessor`
    on the `MemoryMappedFile` instance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存就像有一个只存在于内存中的文件。它是在内存中预留的一块区域。它有一个你可以用来识别它的名称。再次强调，它就像一个文件。在这里，我们创建了一个新的`MemoryMappedFile`类的实例，给它一个名称和大小。（在我们的例子中，1,024字节）。如果你想使用那个文件，你必须获取`MemoryMappedViewAccessor`。你可以通过在`MemoryMappedFile`实例上调用`CreateViewAccessor`来获取它。
- en: You can then read and write data to and from that accessor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以从这个访问器中读取和写入数据。
- en: 'Reading from that shared file is just as easy. Here is the code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个共享文件中读取也同样简单。以下是代码：
- en: '[PRE8]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use almost the same code as the writer. However, instead of creating a new
    file in memory, we open an existing one. We do not have to specify the size but
    must know the name.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用几乎与写入者相同的代码。然而，我们不是在内存中创建一个新的文件，而是打开一个现有的文件。我们不需要指定大小，但必须知道名称。
- en: Once we have that file, we can use the same code to get an accessor. With that,
    we can read the data and display it. Simple, isn’t it?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了那个文件，我们就可以使用相同的代码来获取一个访问器。有了它，我们可以读取数据并显示它。简单，不是吗？
- en: Again, this is a speedy way to share data between processes on the same machine.
    However, the downsides are something to be aware of. For instance, any process
    that knows the name of the shared memory block can access it. There is no security
    whatsoever. Of course, you can circumvent that by using encryption.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一种在相同机器上的进程之间快速共享数据的方法。然而，也有一些缺点需要注意。例如，任何知道共享内存块名称的进程都可以访问它。没有任何安全性。当然，你可以通过使用加密来规避这一点。
- en: Another downside is that there is no built-in mechanism to notify processes
    of new or changed data. You have to use things such as semaphores and mutexes
    to do that. You can set up `FileSystemWatcher` with actual files to get notified,
    but that is not available for these shared files in memory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是没有内置的机制来通知进程新的或更改的数据。你必须使用像信号量（semaphores）和互斥锁（mutexes）这样的东西来做这件事。你可以使用实际的文件来设置`FileSystemWatcher`以获得通知，但这对内存中的这些共享文件不可用。
- en: Another potential downside is that it is Windows only. That might limit your
    options for deployment later on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的缺点是它仅适用于Windows。这可能会限制你以后部署的选择。
- en: But all in all, shared memory is a great way to quickly share large amounts
    of data across processes on the same Windows machine. Use it to your advantage!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但总的来说，共享内存是快速在相同Windows机器上的进程之间共享大量数据的好方法。利用它的优势！
- en: Overview of RPCs and how to use them for IPC
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC概述及其在IPC中的应用
- en: 'So far, we have looked at ways we can share data. In most cases, developers
    use this to do just data: send a payload from one system to another. However,
    the payload can also be something else. They can be commands to instruct a piece
    of software to do something. Instead of storing, transforming, and using data
    in systems, we can tell other systems to perform actions. In that case, we talk
    about RPC.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们探讨了我们可以共享数据的方法。在大多数情况下，开发者使用这种方法仅仅是为了数据：从一个系统向另一个系统发送有效载荷。然而，有效载荷也可以是其他东西。它们可以是指令，用来指示软件执行某些操作。我们不是在系统中存储、转换和使用数据，而是告诉其他系统执行操作。在这种情况下，我们谈论的是RPC。
- en: To control a system from the outside, establish a communication line, ensure
    your security is in order, and define a protocol.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要从外部控制系统，建立通信线路，确保你的安全措施到位，并定义一个协议。
- en: There are many ways to do this. In the old days, we used to have SOAP, DCOM,
    WCF, and other techniques to do so.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方法可以做到这一点。在以前，我们曾经使用过SOAP、DCOM、WCF和其他技术来做到这一点。
- en: RESTFul services versus RPC
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务与RPC
- en: You could consider RESTFul services to be some kind of RPC. However, they are
    not the same, and I do not want to go into RESTful services here. There are many
    similarities, but the basic idea behind RESTful services is that they are all
    about resources. Calls to web services are usually used to retrieve data from
    a server. Technically, you could set up RESTful services to accept commands only,
    in which way they are RPC. It’s like calling a calzone a pizza. Technically, that
    is correct, but there are enough differences in practice to warrant a different
    approach. Therefore, I have decided not to include RESTful services in this book.
    If you choose to use RESTful services to communicate with your system, by all
    means, be my guest.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 RESTful 服务视为某种 RPC。然而，它们并不相同，我不想在这里深入讨论 RESTful 服务。它们有很多相似之处，但 RESTful
    服务背后的基本理念是它们都是关于资源的。调用网络服务通常用于从服务器检索数据。技术上，你可以设置 RESTful 服务仅接受命令，这样它们就是 RPC。这就像把
    calzone 当作披萨。技术上，这是正确的，但在实践中存在足够的差异，需要采取不同的方法。因此，我决定不将 RESTful 服务包含在这本书中。如果你选择使用
    RESTful 服务与你的系统通信，请随意。
- en: 'Basically, it’s all very simple. You think of a way to structure and send commands
    over the line. This works fine as long as both parties understand what is going
    on. Of course, you don’t have to reinvent the wheel: several well-established
    standards exist to do this. Later in this chapter, I show you how to do this with
    gRPC. However, as with all standards, they come with a cost. Sometimes, you do
    not need the additional complexity an established framework gives you. Sometimes,
    you just want to send a simple command to a system. Suppose your scenario allows
    for a less secure and unknown protocol. In that case, you can improve your speed
    and memory by having your own protocol.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这非常简单。你想出一个方法来结构和发送命令。只要双方都理解发生了什么，这就可以正常工作。当然，你不必重新发明轮子：存在几个经过良好建立的标准来做这件事。在本章的后面部分，我会向你展示如何使用
    gRPC 来做这件事。然而，就像所有标准一样，它们都有代价。有时，你不需要一个已建立框架提供的额外复杂性。有时，你只想向系统发送一个简单的命令。假设你的场景允许一个不太安全和未知的协议。在这种情况下，你可以通过拥有自己的协议来提高速度和内存。
- en: JSON RPC is one of the most used ways to do this yourself. Let’s have a look.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: JSON RPC 是实现这一点的最常用方法之一。让我们看看。
- en: JSON RPC
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON RPC
- en: JSON RPC is just encapsulating your commands in a JSON structure, sending them
    off over the wire, intercepting them at the other end, and doing whatever the
    command tells the system to do.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JSON RPC 就是将你的命令封装在 JSON 结构中，通过网络发送它们，在另一端拦截它们，并执行命令告诉系统执行的操作。
- en: 'Let’s begin with defining a command we want to send:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们想要发送的命令开始：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I want the client to inform the server that it needs to print the current date.
    I might want to include the current time as well. So, this is the command we created:
    `ShowDateCommand` with the `IncludeTime` field.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让客户端通知服务器它需要打印当前的日期。我可能还想包括当前的时间。所以，这是我们创建的命令：带有 `IncludeTime` 字段的 `ShowDateCommand`。
- en: 'In my sample, I have put the client and the server in the same application,
    each running on a different task. I did that for the sake of simplicity. Of course,
    if you want to send commands to a different part of the same application, RPC
    is overkill. It’s not even correct: it’s not remote at all. However, for this
    demo, it works just fine.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，我将客户端和服务器放在了同一个应用程序中，每个都在不同的任务上运行。我这样做是为了简化。当然，如果你想向同一应用程序的另一个部分发送命令，RPC
    就过于冗余了。这甚至是不正确的：它根本不是远程的。然而，对于这个演示，它运行得很好。
- en: For communications, I have chosen a named pipe. It’s easy to set up and could
    be used to send messages across the network. Besides those considerations, I had
    no real reason to choose this option, so you can do whatever you want.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通信，我选择了一个命名管道。它很容易设置，可以用来在网络中发送消息。除了这些考虑因素，我实际上没有选择这个选项的真正原因，所以你可以做任何你想做的事情。
- en: 'The server part looks like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器部分看起来是这样的：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The class, called `Server`, has one method named `StartServer`. It creates
    an instance of `NamePipeServerStream` with the `CommandsPipe` name. Then, it waits
    for a client to connect. As soon as that happens, we read the data coming in.
    As soon as we get a string, we deserialize it to the correct format and perform
    the task it is told to perform: it prints out the current date and optionally
    includes the time.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为 `Server` 的类有一个名为 `StartServer` 的方法。它使用 `CommandsPipe` 名称创建一个 `NamePipeServerStream`
    实例。然后，它等待客户端连接。一旦发生这种情况，我们就读取传入的数据。一旦我们得到一个字符串，我们就将其反序列化为正确的格式并执行它告诉的任务：打印当前的日期，并可选地包括时间。
- en: 'The client looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端看起来像这样：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The client creates an instance of `ShowDateCommand` and sets `IncludeTime` to
    `true`. Then, it creates `NamedPipeClientStream` with the correct name and connects
    to the server. Finally, it sends the JSON over the wire. That’s all there is to
    it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端创建了一个`ShowDateCommand`的实例，并将`IncludeTime`设置为`true`。然后，它使用正确的名称创建了`NamedPipeClientStream`并连接到服务器。最后，它通过电线发送JSON。这就是全部内容。
- en: 'For completeness, I give you the code that initializes both the server and
    the client in the `Main` method of the program:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我在程序的`Main`方法中给出了初始化服务器和客户端的代码：
- en: '[PRE12]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I create instances of `Server` and `Client`, starting them in `Task.Run()` and
    wait for the user to press a key. In the background, `Server` and `Client` do
    their thing, telling you all about it with the calls to `Dump()`. Please pay attention
    to the thread IDs in `Dump` – they can be pretty informative for learning about
    threading (or refreshing your memory).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了`Server`和`Client`的实例，在`Task.Run()`中启动它们，并等待用户按下键。在后台，`Server`和`Client`执行它们的工作，通过调用`Dump()`告诉你所有关于它的事情。请注意`Dump`中的线程ID——它们对于了解线程（或刷新你的记忆）非常有信息量。
- en: 'This technique is simple and very fast. However, it only works if you know
    both ends of the equation: the server and the client must follow your proprietary
    protocol. If that is not the case, you are better off using a standard. One of
    those standards is gRPC. Let’s look at that next.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术简单且非常快。然而，它仅在你知道等式的两端：服务器和客户端必须遵循你的专有协议。如果不是这样，你最好使用一个标准。这些标准之一就是gRPC。让我们看看下一个。
- en: Overview of gRPC and how to use it for IPC
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC概述及其用于IPC的使用方法
- en: One of the leading ways to establish a straightforward way of communication
    between processes these days is gRPC. The acronym **gRPC** stands for either **Google
    remote procedure call** or the recursive name gRPC remote procedure call. You
    can pick whichever you like. Google developed it as a public version and improvement
    of their internal framework, Stubby.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 目前建立进程间直接通信的领先方式之一是gRPC。缩写**gRPC**代表**Google远程过程调用**或递归命名的**gRPC远程过程调用**。你可以选择你喜欢的。谷歌将其开发为一个公开版本和改进其内部框架Stubby的版本。
- en: gRPC uses **Protocol Buffers** (**Protobufs**). This is a format that describes
    the available commands, the messages, and the parameters you can pass. Protobufs
    are compiled into a binary form, resulting in faster data transfers. The system
    is built on HTTP/2, so we can use multiplexing (multiple requests over the same
    TCP connection). HTTP/2 has many more advantages over the older HTTP/1.x, most
    of which involve efficiency.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC使用**协议缓冲区**（**Protobufs**）。这是一种描述可用命令、消息和可以传递的参数的格式。Protobufs被编译成二进制形式，从而实现更快的数据传输。该系统建立在HTTP/2之上，因此我们可以使用多路复用（多个请求通过相同的TCP连接）。HTTP/2比旧的HTTP/1.x具有更多优势，其中大多数涉及效率。
- en: Cross-language and platform support was also one of the leading drivers. So,
    you can be sure gRPC can be used on many devices.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 跨语言和平台支持也是主要的驱动因素之一。因此，你可以确信gRPC可以在许多设备上使用。
- en: 'Suppose we want to rebuild our example of a system that can be remotely instructed
    to display the current date (with or without time). In that case, we first have
    to define the message structure. However, before we do that, we need to add a
    couple of NuGet packages to our server application:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要重新构建一个示例系统，该系统可以远程指示显示当前日期（带或不带时间）。在这种情况下，我们首先必须定义消息结构。然而，在我们这样做之前，我们需要向我们的服务器应用程序添加几个NuGet包：
- en: '| **Package** | **Description** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **描述** |'
- en: '| --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Google.Protobuf` | Handles the proto files |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `Google.Protobuf` | 处理proto文件 |'
- en: '| `Grpc.Core` | The core implementation of gRPC |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `Grpc.Core` | gRPC的核心实现 |'
- en: '| `Grpc.Tools` | Contains, amongst others, the compiler for proto files |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `Grpc.Tools` | 包含，例如，proto文件的编译器 |'
- en: '| `Grpc.AspNetCore` | Needed to host the server in our application |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `Grpc.AspNetCore` | 需要在我们的应用程序中托管服务器 |'
- en: 'Table 6.4: NuGet packages for our gRPC server'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.4：我们的gRPC服务器的NuGet包
- en: In a C# console application, add a new file called `displayer.proto`. This is
    just a text file. I like to put them in a separate folder, which I call `Protos`.
    The compiler takes this file and creates a lot of C# for us.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#控制台应用程序中，添加一个名为`displayer.proto`的新文件。这只是一个文本文件。我喜欢将它们放在一个单独的文件夹中，我称之为`Protos`。编译器会处理这个文件，为我们生成大量的C#代码。
- en: 'The file looks like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 文件看起来像这样：
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s dissect this.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下。
- en: First, we tell the system what format this is. We use `proto3`, which is the
    latest and recommended version.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉系统这是什么格式。我们使用`proto3`，这是最新也是推荐的版本。
- en: Then, we tell the system what namespace to put them in when it generates the
    C# files. As you can imagine, this option is C# only. It is a helper option that
    helps us keep our code organized.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们告诉系统在生成C#文件时将它们放在哪个命名空间中。正如你所想象的，这个选项仅限于C#。这是一个辅助选项，帮助我们保持代码的整洁。
- en: Then, we define the service. We have one service called `TimeDisplayer`. It
    has one RPC method called `DisplayTime`. It takes `DisplayTimeRequest` as a parameter
    and returns something of the `DisplayTimeReply` type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义服务。我们有一个名为`TimeDisplayer`的服务。它有一个名为`DisplayTime`的RPC方法。它以`DisplayTimeRequest`作为参数，并返回`DisplayTimeReply`类型的某个东西。
- en: '`DisplayTimeRequest` and `DisplayTimeReply` types are defined below that. They
    are messages, and they can contain parameters. I added a name to show you how
    to add a string. For the request, I also added a bool, indicating whether we want
    to show the time.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayTimeRequest`和`DisplayTimeReply`类型定义在下面。它们是消息，并且可以包含参数。我添加了一个名字来展示如何添加一个字符串。对于请求，我还添加了一个布尔值，表示我们是否想要显示时间。'
- en: The parameters need to be ordered and numbered. This way, if somehow the message
    gets scrambled, both systems still know what the data looked like initially.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 参数需要按顺序和编号。这样，如果消息以某种方式被打乱，两个系统仍然知道数据最初看起来是什么样子。
- en: 'Visual Studio usually knows how to handle this if you add a `.proto` file to
    your application. However, if this doesn’t happen (and I have seen it go wrong
    occasionally), you must instruct the compiler on how to handle this file. In your
    `csproj` file, just add the following section:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio通常知道如何处理这个，如果你在你的应用程序中添加了一个`.proto`文件。然而，如果这没有发生（我偶尔也看到它出错），你必须指导编译器如何处理这个文件。在你的`csproj`文件中，只需添加以下部分：
- en: '[PRE14]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That should be enough to get the compiler on the way.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以让编译器开始工作了。
- en: Let’s build the server!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建服务器！
- en: 'I have added the code for the server in my console application. Since the compiler
    takes our `.proto` file and compiles all the necessary code for us, we can use
    the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的控制台应用程序中添加了服务器的代码。由于编译器会为我们编译所有必要的代码，我们可以使用以下代码：
- en: '[PRE15]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `TimeDisplayerService` class is derived from the `TimeDisplayer.TimeDisplayerBase`
    base class. This base class is generated out of our `.proto` file. As you can
    see, the `TimeDisplayer` name matches what we have in that `.``proto` file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TimeDisplayerService`类是从`TimeDisplayer.TimeDisplayerBase`基类派生的。这个基类是由我们的`.proto`文件生成的。正如你所看到的，`TimeDisplayer`的名字与我们在那个`.proto`文件中的名字匹配。
- en: We have one method here, called `DisplayTime`. Again, this matches what we have
    in our `.proto` file. The code is pretty simple; it just takes an instance of
    `DisplayTimeRequest`, looks at the `WantsTime` parameter, and returns the result.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个名为`DisplayTime`的方法。再次，这与我们在`.proto`文件中的内容匹配。代码很简单；它只接受一个`DisplayTimeRequest`实例，查看`WantsTime`参数，并返回结果。
- en: 'Usually, gRPC servers run on some sort of webserver, and adding this code to
    an ASP.NET application is straightforward. But, of course, you can run it anywhere
    you want, which is something we, as systems programmers, really can use. So, if
    you’re going to run this code in a console application, you can set that up as
    follows. In the primary method of your program, add the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，gRPC服务器运行在一些类型的web服务器上，将此代码添加到ASP.NET应用程序中是直接的。但当然，你可以在任何你想运行它的地方运行它，这是我们作为系统程序员真正可以利用的事情。所以，如果你打算在控制台应用程序中运行此代码，你可以按照以下方式设置。在你的程序的主要方法中，添加以下内容：
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We create a new instance of the `Server` class. This comes from the `gRPC.Core`
    NuGet package we installed. We give it the services we want to use (in our case,
    `TimeDisplayerService`) and define the network address and port we decide to use.
    I do not care about credentials here, but you can use SSL, TLS, and other ways
    of security.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`Server`类实例。这来自于我们安装的`gRPC.Core` NuGet包。我们给它提供了我们想要使用的服务（在我们的例子中，是`TimeDisplayerService`）并定义了我们决定使用的网络地址和端口。在这里我不关心凭证，但你可以使用SSL、TLS和其他安全方式。
- en: We start the server and wait for the user to press any key. Then, we stop the
    server again.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动服务器并等待用户按下任意键。然后，我们再次停止服务器。
- en: 'Up next: the client.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来：客户端。
- en: 'Again, we need to add some NuGet packages to our console application. These
    are the ones you need:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要向我们的控制台应用程序添加一些NuGet包。这些是你需要的：
- en: '| **Package** | **Description** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **描述** |'
- en: '| --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Google.Protobuf` | Handles the proto files |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `Google.Protobuf` | 处理proto文件 |'
- en: '| `Grpc.Net.Client` | The client implementation for gRPC |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Grpc.Net.Client` | gRPC 的客户端实现 |'
- en: '| `Grpc.Tools` | Contains, amongst others, the compiler for proto files |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `Grpc.Tools` | 包含编译器，用于处理 proto 文件等 |'
- en: 'Table 6.5: NuGet packages for our gRPC client'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.5：我们的 gRPC 客户端所需的 NuGet 包
- en: First, we need a `.prot`o file. To be more precise, we need the same `.proto`
    file we used on the server. So, it is best to link to that file instead of recreating
    it. However, if you like typing, be my guest and create a new one. Just make sure
    these files remain in sync when you make changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个 `.prot`o 文件。更准确地说，我们需要与服务器上使用的相同的 `.proto` 文件。因此，最好链接到该文件而不是重新创建它。然而，如果你喜欢键入，请随意创建一个新的。只需确保在做出更改时这些文件保持同步即可。
- en: 'We do not need a specific client class; we only have to add the following code
    to our `Main` method in the program:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要特定的客户端类；我们只需在我们的程序 `Main` 方法中添加以下代码即可：
- en: '[PRE17]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We start with a wait for the user to press a key. Since I start the server and
    the client simultaneously in my solution, I might get timing issues if the client
    is slightly faster than the server in setting up the connection.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从等待用户按下一个键开始。由于我在解决方案中同时启动服务器和客户端，如果客户端在设置连接时比服务器快一点，我可能会遇到时序问题。
- en: Then, we call `GrpcChannel.ForAddress()` with the correct parameters to set
    up the connection. With that connection, we call the `DisplayTimeAsync` method
    with a correct `DisplayTimeRequest` setup. The result should come back and show
    you what the server did.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用正确的参数调用 `GrpcChannel.ForAddress()` 来设置连接。有了这个连接，我们使用正确的 `DisplayTimeRequest`
    设置调用 `DisplayTimeAsync` 方法。结果应该返回并显示服务器执行的操作。
- en: That is all there is to it! We now have a fully functional server and client
    application, talking to one another over gRPC.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！我们现在有一个完全功能的服务器和客户端应用程序，它们通过 gRPC 进行通信。
- en: Differences between JSON RPC and gRPC
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON RPC 和 gRPC 的差异
- en: As you saw, setting up a gRPC server and client is not too complicated. But
    still, it adds a bit of complexity to your code. If you do not need the advantages
    of gRPC, you can use JSON RPC instead. But when do you pick which one?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，设置 gRPC 服务器和客户端并不太复杂。但仍然，它会给你的代码增加一些复杂性。如果你不需要 gRPC 的优势，你可以使用 JSON RPC。但你在什么时候选择哪一个呢？
- en: If your messages get big, gRPC is the far better choice. Remember when I said
    IO takes a long time? Well, JSON files are usually much bigger than their binary
    equivalent. gRPC uses that smaller binary format, so data transmission is much
    faster when using that.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的消息变得很大，gRPC 是更好的选择。记得我之前说过 I/O 很慢吗？嗯，JSON 文件通常比它们的二进制等效文件大得多。gRPC 使用较小的二进制格式，因此使用该格式进行数据传输要快得多。
- en: However, JSON is more readable, more debuggable, and easier to interpret for
    humans. The code is also easier to set up. The `.proto` files are something you
    have to get used to. Next to that, the compiler needs to transform the `.proto`
    files into C# classes, and they make your system more complex.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JSON 更易于阅读，更易于调试，也更易于人类解释。代码也更容易设置。`.proto` 文件是你必须习惯的东西。除此之外，编译器需要将 `.proto`
    文件转换为 C# 类，这会使你的系统更加复杂。
- en: 'All in all, it depends on your scenario. However, for easy reference, I have
    outlined the differences between JSON RPC and gRPC in the following table:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这取决于你的场景。然而，为了便于参考，我在下表中概述了 JSON RPC 和 gRPC 之间的差异：
- en: '| **Feature** | **gRPC** | **RPC** **with JSON** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **gRPC** | **使用 JSON 的 RPC** |'
- en: '| --- | --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Serialization format** | Protobufs (binary format) | JSON (text format)
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **序列化格式** | Protobufs（二进制格式） | JSON（文本格式） |'
- en: '| **Performance** | Generally higher due to binary serialization, initial setup
    and connection might be slower | Lower than binary formats but quicker to set
    up (depending on the communication setup) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **性能** | 由于二进制序列化，通常更高，初始设置和连接可能较慢 | 低于二进制格式，但设置更快（取决于通信设置） |'
- en: '| **Protocol** | HTTP/2 | Typically HTTP/1.1 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **协议** | HTTP/2 | 通常为 HTTP/1.1 |'
- en: '| **Streaming** | Supports bidirectional streaming | Limited support, usually
    request-response only |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **流式传输** | 支持双向流 | 有限支持，通常是请求-响应 |'
- en: '| **Type safety** | Strongly-typed contracts (Protobuf) | Loosely typed, prone
    to runtime errors |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **类型安全** | 强类型合约（Protobuf） | 松散类型，容易在运行时出现错误 |'
- en: '| **Language** **interoperability** | High (supports many languages natively)
    | High (JSON is universally supported) |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **语言互操作性** | 高（原生支持许多语言） | 高（JSON 被普遍支持） |'
- en: '| **Network efficiency** | More efficient (smaller payload, HTTP/2 features)
    | Less efficient (larger payload, HTTP/1.1) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **网络效率** | 更高效（更小的负载，HTTP/2 特性） | 更低效（更大的负载，HTTP/1.1） |'
- en: '| **Error handling** | Rich error handling with explicit error codes | Typically
    relies on HTTP status codes |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **错误处理** | 丰富的错误处理，具有明确的错误代码 | 通常依赖于 HTTP 状态代码 |'
- en: '| **Deadline/timeouts** | Native support for specifying call deadlines | Usually
    managed at the application level |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **截止日期/超时** | 原生支持指定调用截止日期 | 通常在应用层管理 |'
- en: '| **Security** | Supports various authentication mechanisms | Varies, usually
    added at the application layer |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **安全性** | 支持各种身份验证机制 | 通常在应用层添加 |'
- en: 'Table 6.6: Differences between gRPC and JSON RPC'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.6：gRPC 和 JSON RPC 之间的差异
- en: As you can see, although gRPC and RPC with JSON share many features, each has
    their own use case. Pick whichever works best for your scenario.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管 gRPC 和使用 JSON 的 RPC 具有许多共同特性，但每个都有其特定的使用场景。选择最适合您场景的那个。
- en: Next steps
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: '*Everybody needs somebody*. That truth has even been the title of a song. The
    same goes for systems, especially those not meant to be used by humans. They need
    something to tell them what to do and what data to do it with. They need to communicate
    with each other. You have now seen the many ways you can use to set up communications.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个人都需要有人陪伴*。这个真理甚至成为了一首歌的标题。对于系统来说，尤其是那些不是为人类使用而设计的系统，也是如此。它们需要某种东西来告诉它们该做什么，以及使用什么数据来做。它们需要相互通信。您现在已经看到了许多可以用来设置通信的方法。'
- en: 'We have looked at Windows Messages, the old-school communication style (although
    Windows still uses it for internal communications). We have looked at both named
    and anonymous pipes. Then, we looked at the most used way for computers to talk
    to one another: sockets. While at it, we investigated the OSI model a bit to understand
    where we need to write code and where we can leave that to others.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 Windows 消息，这种传统的通信风格（尽管 Windows 仍然用于内部通信）。我们研究了命名管道和无名管道。然后，我们探讨了计算机之间最常用的通信方式：套接字。在这个过程中，我们还对
    OSI 模型进行了研究，以了解我们需要在哪里编写代码，以及我们可以将哪些留给他人。
- en: We also looked at a speedy way to share data on the same machine using shared
    memory.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了在相同机器上使用共享内存快速共享数据的方法。
- en: Finally, we investigated how we can issue commands by using JSON RPC and gRPC.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了如何通过使用 JSON RPC 和 gRPC 来发布命令。
- en: Now, we should be ready to take the next step. After all, besides talking to
    our code, we can use the operating system to help us. Windows offers many services
    we might need or can use to our advantage, which is the topic of the next chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该准备好迈出下一步。毕竟，除了与我们的代码进行交流外，我们还可以使用操作系统来帮助我们。Windows 提供了许多我们可能需要或可以利用的服务，这是下一章的主题。
