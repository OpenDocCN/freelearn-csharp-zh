- en: '*Chapter 12*: Procedural Storytelling with ink'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will review **procedural storytelling** using ink and Unity.
    Inkle, the company that created and maintains the narrative scripting language
    ink, has published multiple games that combine ink and Unity. These games use
    procedural storytelling to provide different experiences per session based on
    randomness and player choices. This chapter will introduce approaches to achieving
    this same general result: loading values in ink and coding collections in Unity.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first topic, we will review the term *procedural storytelling* more generally.
    Based on concepts initially introduced in [*Chapter 3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048),
    *Sequences, Cycles, and Shuffling Text*, we will learn how to use a shuffle in
    ink to create dynamic content based on simple rules.
  prefs: []
  type: TYPE_NORMAL
- en: Diving even deeper into ink, the second topic will demonstrate how to load values
    in ink. This process focuses on using ink to generate content for players based
    on simple rules.
  prefs: []
  type: TYPE_NORMAL
- en: In the final topic, we will switch the emphasis from ink to Unity. We will use
    Unity to load values and call functions in ink to process values instead. This
    approach uses more complex code in Unity, but simpler code in ink.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing procedural storytelling in ink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading values into ink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding collections in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples in this chapter can be found online on GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing procedural storytelling in ink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *procedural storytelling* takes its name from another term, *procedural
    generation*. The word "procedural" preceding "generation" means that content is
    created based on a sequence of *procedures*; that is, rules. When referring to
    generating assets such as 3D models or placing non-player characters within some
    world in a video game, the term *procedural generation* applies. When discussing
    planning, generating, or dynamically ordering content related to the story or
    experienced narrative of the player within an interactive project, the better
    term to use is **procedural storytelling**.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural storytelling occurs when a project uses rules to define how a player
    may interact with or encounter parts of its story content. For example, if a project
    has a set of rules to create dynamic names for its characters, a player in a science
    fiction setting may interact with a generated character name of *Neldronor*, while
    a different player might see the name *Vynear* for the same entity. Procedurally
    generating story content can also extend beyond substituting names to deciding
    which quests a player may have access to, when they encounter certain characters,
    or even the possible events that may happen in their play session.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will cover three examples of simple patterns for understanding
    procedural generation in ink based on randomness. The first, *Random encounters*,
    will explain how to combine the use of a shuffle and threads in ink to create
    a listing of possible encounters for a player. The second pattern, *Weighted randomness*,
    uses the same concepts as the first pattern but defines the weighted probability
    a player might see some content. Both patterns are easy ways to add simple procedural
    generation to an existing project without too much disruption to its existing
    structure. The last section and pattern, *Conditional content*, will cover using
    the previous actions and input from a player to influence which encounter a player
    sees. It does so by using concepts from the two previous patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Random encounters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many tabletop role-playing games use a concept known as a **random table**.
    In the material or book for the game, there is a table or list of possible things
    a player might encounter in a location or scene. The person running the game would
    roll some dice, consult the table to find the row matching the rolled number,
    and then tell the players what they encountered. This system creates the possibility
    for *random* encounters. Based on the random element of the dice, the player would
    see or interact with different things each time they used the same table to generate
    content for their game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translated into a digital setting, the random tables of tabletop games can
    become a set of possible encounters. In ink, we can create this using a shuffle
    and threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the shuffle will always pick one of its entries at random, each thread
    has the same probability of occurring. However, as is perhaps not as obvious,
    *each possible encounter is additional content*. Unlike a much more authored experience
    without any procedural storytelling functionality, even a simple addition such
    as a table of possible encounters means creating new content per possible encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Example 1* demonstrates using a shuffle in ink containing three different
    threads as a simple random encounter system. Each thread references a knot called
    `encounter` with a stitch named after the kind of encounter, such as `animal`.
    Based on random selection, the player would see one of three possible encounters.'
  prefs: []
  type: TYPE_NORMAL
- en: Using random encounters, as defined within a shuffle, is an easy way to add
    simple procedural storytelling in ink to a project. It does require adding extra
    content per entry in the shuffle, but such a pattern can be the least disruptive
    to an existing project. It is also possible to have additional sets and create
    more dynamic outcomes where a player might encounter any number of things across
    multiple settings, contexts, or levels where each usage is based on a shuffle
    and threads in ink.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine weighted probabilities as part of controlling
    the randomness of a set of encounters. Instead of all entries having an equal
    probability of occurring, as is the case when using a shuffle, there may be situations
    where certain encounters should occur more often for players.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted randomness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The shuffle is powerful functionality in ink. It allows us to create a set of
    possible entries and then randomly select one. As was seen in the *Random encounters*
    section, a simple set of possible encounters can be created; then, a shuffle can
    be used to select one as needed.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be situations where equally weighted probabilities are not
    wanted. For example, a developer may only want a player to encounter a character
    30% of the time when traveling through a forest area in a game. For these situations,
    we want to *weight* the randomness of encounters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ink, the `RANDOM()` function allows us to define the range of random whole
    numbers that are produced. If we wanted numbers between `1` and `10`, we could
    use `RANDOM(1,10)`. Based on the number that''s returned by the `RANDOM()` function,
    it is possible to test values and only act if its result is in a certain range:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In *Example 2*, the `brown_wizard` stitch is only encountered if the result
    from the use of `RANDOM(1, 10)` is less than or equal to `3`. This creates a 30%
    chance of the player encountering this character. This is an example of a *weighted*
    probability. Instead of an equal probability between the two encounters, one is
    weighted more than the other. The `travel` stitch is more likely to be encountered
    by the player than the other stitch, `brown_wizard`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, *Random encounters*, we learned how to create different
    content within stitches and select them with equal probability using a shuffle.
    In this section, we controlled this randomness using a weighted probability with
    the `RANDOM()` function in ink.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will combine this and the previous pattern for *conditional*
    content. Based on the previous options that were selected by a player, we can
    influence what the player encounters using both randomness and by comparing other
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In projects that don't use randomness, it is very common to use conditional
    blocks or choices to respond to what the player selects and how they are progressing
    through a story. As we saw in the *Random encounters* and *Weighted randomness*
    sections, we can also use shuffles and the `RANDOM()` function in ink to shape
    a story. In this section, we will look at an example of using both concepts together
    to create more complex procedures to generate connections between content for
    players.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, *Weighted randomness*, we saw how we can create a set
    of different conditional statements within a block to control what the player
    encounters next. In *Example 2*, this was the weighted outcomes of either the
    `brown_wizard` or `travel` stitch, with the `travel` stitch more likely to be
    seen by the player. However, players rarely want to only read the text in a game.
    They want to have some input over what happens as part of a story.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using labels with choices in ink, we can test whether a player selects a
    particular option and then influence the weighted outcome for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Example 3* is an updated form of *Example 2*. However, instead of merely showing
    text, the player is presented with two options within a weave. Depending on which
    one they select, the story then branches along two possible paths. In the first,
    if the player chooses to travel in the forest, there is a 30% chance they will
    encounter a character. In the second, if a player chooses to travel by the river,
    they will not encounter the character.'
  prefs: []
  type: TYPE_NORMAL
- en: While some projects might use shuffle or weighted options, many more incorporate
    player selections and past choices with randomness. This not only gives the player
    more control over what they are experiencing, but it also allows the author to
    craft a story, along with certain predictable outcomes. Instead of trying to account
    for multiple outcomes when only using a shuffle, the use of the weave and its
    limited number of options shapes the possible paths of future encounters. Because
    there are only two options in the wave, there are only two possible main branches,
    with the weighted randomness only affecting one and not the other.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we have examined three different patterns for introducing or
    adjusting simple procedural storytelling rules in ink projects. In the first section,
    *Random encounters*, we learned how to create a set of equally weighted entries
    using a shuffle with threads to pull in different story content. In the second
    section, *Weighted randomness*, we explored how to control randomness with weighted
    outcomes where one outcome was more likely than another.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, *Conditional content*, we combined randomness with the
    result of players selecting options and investigated how to create seemingly more
    advanced rules, where the number of choices within a weave has a stronger influence
    on the shape of the story than the randomness contained within any one branch.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will look at more complex patterns. For many projects,
    ink will be the driving force behind content generation and how the project uses
    procedural storytelling. We will look at how to load values into ink as part of
    examining how to write a grammar for stories, and then plan how players will encounter
    its different parts in dynamic ways.
  prefs: []
  type: TYPE_NORMAL
- en: Loading values into ink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *procedural* aspect of procedural storytelling can exist either primarily
    in ink or Unity. In this topic, we will examine the process of loading values
    into ink. We will center a design focused on letting ink make procedural decisions
    about what content a user might see or interact with during a play session.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, *Substitution grammars*, we will consider how to use what
    we learned in the previous section, *Introducing procedural storytelling in ink*,
    to build a set of possible events for a player. This will lead us into the next
    section, *Story planning*, where we will apply rules to the grammars themselves.
    This will allow us to control how different sets of encounters are influenced
    by previous ones, creating simple formulas for complex stories.
  prefs: []
  type: TYPE_NORMAL
- en: Substitution grammars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In linguistics, **grammar** describes the rules that define how a language works.
    For example, in English, there is a specific order of subject, verb, and object
    in sentences. In programming contexts, we can define what is called **substitution
    grammar**, where a set of rules describes how words or phrases are replaced with
    others. This can often be used to define a specific order, such as the use of
    subjects and verbs in an English sentence. In a programming context, dynamic constructions
    can be produced where dynamic or random values are *substituted* in specific places
    in the defined pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ink, we can create functions to return values based on shuffles. By writing
    a grammar – that is, rules for what order entries appear in – we can create a
    simple substitution pattern where random entries are used from specific sets to
    create a dynamic text interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In *Example 4*, the `getLocation()` and `getMarker()` ink functions provide
    the substitutions within the grammar of the sentence. By placing shuffles within
    the functions and surrounding them with quotation marks, the text's result can
    be returned; that is, where the functions are called. Because all functions are
    global, this also means they can be used multiple times in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Based on *Example 4*, it can be tempting to assume functions can also be used
    to generate possible divert targets using a shuffle. This is not the case. While
    variables can hold divert targets, functions are not allowed to divert in ink,
    and the language prevents combinations of calling functions and using the returned
    value to thread or divert to another section in a story.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in ink can be useful for generating and returning text. However,
    because of its design, ink does not allow functions to control story flow. In
    cases where each entry within a shuffle might also want to use diverting or threads,
    we can create an extended tunnel where each part of the tunnel acts as part of
    the grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Example 5* is a rewritten version of *Example 4* using an extended tunnel.
    For simple text substitution, the pattern shown in *Example 4*, which is using
    shuffles and functions, can be very useful. However, the pattern in *Example 5*,
    which is using knots and multi-line shuffles, allows each entry in the shuffle
    to potentially divert or use threads themselves. This is often the preferred pattern
    for creating a substitution grammar, where each part of the grammar can expand
    as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use substitution grammar for text and then
    a more advanced one for incorporating tunnels. In the next section, we will apply
    substitution grammar as part of a planning process for stories. Loops and other
    conditional aspects will be introduced to create more advanced substitution grammars.
  prefs: []
  type: TYPE_NORMAL
- en: Story planning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how substitution grammars can provide us with
    a specific order of events. By using shuffles, we can pick random entries for
    each part and create a dynamic experience for a player. In the examples shown
    in the previous section, there was also only one entry per part of the grammar.
    There was one for `location`, one for `marker`, and then the tunnel ended. This
    is useful, but many games will want to create dynamic patterns based on previous
    entries. In other words, it is also possible to base the range of future entries
    on previous ones within a grammar.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a formula where previous entries can affect future entries as
    part of advanced grammar, we are using a concept called **story planning**. In
    procedural storytelling, story planning occurs when the story is *planned* based
    on rules for generating more complex patterns than simple substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained in [*Chapter 3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048),
    *Sequences, Cycles, and Shuffling Text*, alternatives can be embedded inside each
    other. This means we can use alternatives inside of multi-line conditional blocks
    to create contexts where, based on previous values, random entries can be chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In *Example 6*, a new variable has been introduced based on the code from *Example
    5*. In this new version, the values of the `marker` knot are based on the `location_pick`
    variable. Within the extended tunnel moving from the `location` knot to the `marker`
    knot, the `location_pick` variable is changed. Depending on its value moving into
    the `marker` knot, different results can be produced. If the random entry from
    `location` is `"tower"`, the first two values, `grave` and `memorial` `stone`,
    are enabled. Otherwise, the `farmstead` and `ancient` `tree` values are.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we focused on loading and generating values in ink. In the first
    section, *Substitution grammars*, we learned how to create simple patterns. In
    this section, *Story planning*, we reviewed a simple example of story planning
    using a single variable for branching within the second part of a tunnel. Depending
    on the planning that's wanted, authors can create very complex grammars using
    different variables where previous values can branch out future calculations and
    ranges of entries in shuffles or other alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will move away from ink and back into Unity. When it comes
    to scripting narrative experiences, ink is an incredible language. However, ink
    does not work well with more complex value manipulations. In Unity, with the use
    of C#, we can perform much more complicated procedural storytelling approaches,
    where we can make decisions about which ink story to load and how to pass its
    values to make decisions internally.
  prefs: []
  type: TYPE_NORMAL
- en: Coding collections in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous topic, we examined ways to have ink create and plan content
    for a player. In this section, we move back into Unity. Often, in large projects,
    story and otherwise, narrative content will be one of several complex interlocking
    mechanics in a game. In these cases, procedural storytelling will be one of multiple
    systems, and Unity, as the game engine driving the project, will be programmed
    to use one story over another as part of more complex operations and planning.
    In these cases, the narrative content is stored in what C# names *collections*.
    These can be something as simple as an array or a much more complex data structure
    capable of sorting its internal elements based on patterns or the values of their
    internal elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, *Using multiple stories*, we will look at an example of
    moving the procedural storytelling aspect of a project from ink into Unity. Instead
    of working with shuffles in ink, we will use randomness in Unity to select between
    different possible stories within a collection and then remove them from future
    selections. This will allow us to concentrate on the story content in ink, creating
    dialog or player choices within separate files, and then use Unity to choose what
    to show a player.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section, *Conditionally choosing stories*, we will apply the concept
    of simple story planning, as shown in the *Story planning* subsection, using ink
    in Unity. Much like it did in ink, this will allow us to start to define a substitution
    grammar for how we want story content to appear to the player, but with the coded
    collections in Unity performing the work of selecting parts instead of ink.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple stories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we first explored in [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159),
    *Quest Tracking and Branching Narratives*, in the *Tracking progress across multiple
    quests* topic, it is possible to use multiple ink files as separate instances
    of the `Story` class in a project. In that topic, each file was a separate quest.
    However, it is also possible to use each file as a scene within a larger story.
    In these cases, each ink file would represent a separate narrative experience
    for a player. This could become part of a session or a longer story, upon being
    selected by Unity, to show the player in a random order.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 12*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174) examples
    on GitHub under the name `Chapter12-MultipleStories`. Only select parts of the
    code will be shown as they relate to the concepts being examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re using multiple ink files to break a story down into different
    scenes where each could be accessed independently of each other, the easiest way
    to approach this is to load them all at once. The following project uses a method
    named `GetFiles()` to process the compiled JSON files and create `Story` class
    instances. With each new object that''s created, it is added to a `List<Story>`
    collection named `Stories`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *Random encounter* section of the *Introducing procedural storytelling
    in ink* topic, a shuffle was used to pick between different threads. In C#, the
    `Random` class works similarly. It provides random data based on some range. Using
    its `Next()` method and the `Count` property of the collection, it provides an
    index to select between entries in the `List<Story>` collection, which is populated
    by the `GetFiles()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To prevent the same story from appearing again, the `RemoveAt()` method removes
    the entry from the `List<Story>` collection at random. This prevents the same
    story from being shown twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put together, the `Start()` method is used to call multiple other methods to
    parse the files and pick a random story. Based on the weave contained in the randomly
    picked `Story`, a method named `UpdateContent()`, which is called from `PickRandomStory()`,
    presents two options to the player as `Button` game objects. Clicking on either
    of these changes the value of a variable within the story. This is then shown
    to the player as updates to two variables, `violence` and `peace`, which are tracked
    in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While relatively simple, the project shown in this section illustrates an important
    aspect of balancing between ink and Unity as separate systems for procedural storytelling.
    The complexity of an ink story is not reflected in the C# code needed to pick
    it from a collection or show its contents. Simple code can be used in Unity to
    randomly select an ink story that, itself, uses randomness, substitution grammars,
    or its story planning in its design. In Unity, the C# `Random` class can be used
    without any knowledge of what an ink story is doing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will follow a similar movement to what we did in the
    *Introducing procedural storytelling in ink* topic. In this first section, we
    focused on using multiple ink stories with the C# `Random` class while picking
    between them equally. However, most projects will want to only select ink stories
    based on preconditions. In the next section, we will look at conditionally choosing
    between ink stories.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally choosing stories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how the C# `Random` class allows us to pick
    between objects based on the `Story` class as part of a collection, `List<Story>`.
    This has limited usefulness for most projects. Instead, most developers would
    prefer to have control over when an ink story is selected and the conditions under
    which it becomes available. In this section, we will look at a simple implementation
    of a system that checks the preconditions of a story before loading any of its
    contents. Values will be tracked across stories in the collection and, if the
    preconditions are met for the story, it will be considered available. If not,
    it will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 12*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174)
    examples on GitHub under the name `Chapter12-ConditionalStories`. Only select
    parts of the code will be shown as they relate to the concepts being examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the preconditions of ink stories, there needs to be a separate class,
    `ConditionalStory`, that contains the ink story and methods that originally appeared
    in the *Tracking quest values* subsection of the *Displaying and awarding player
    progression* section in [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159),
    *Quest Tracking and Branching Narratives*, including simplified versions of `ObserveVariables()`
    and `UpdateVariable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConditionalStory` class has a method called `Available()`. Internally,
    this uses the `EvaluateFunction()` method of the `Story` class to call an ink
    function named `check()`. Assuming the ink story contains the function, it will
    be called, and the result will be converted into a Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each story file has a conditional check that is fed back into the `Available()`
    method of the `ConditionalStory` class. If the `check()` ink function returns
    `true`, the story is available for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various changes have been made to the code shown in the previous section, *Using
    multiple stories*. The first is the use of `ConditionalStory` as a class containing
    an object based on the `Story` class. The second is the `SelectStories()` method.
    Unlike picking a random entry, it uses the `FindAll()` method of `List<ConditionalStory>`
    to search through its entries. If the `Available()` method, which is calling the
    `check()` ink function each time, reports `true`, it considers the story to be
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If each ink story defines how and if it is available for use in a larger project,
    this allows the ink and C# code in Unity to be developed separately. To become
    available so that it can be selected, the `check()` function in ink must report
    `true` to the `ConditionalStory` class in C#. This creates a simple but easily
    repeatable pattern for creating conditional stories in Unity based on understanding
    how its collections work by using the `FindAll()` method, as specified in this
    section, and the `Random` class, as specified in the previous section, in C# to
    access individual entries based on their indices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was not to solve all problems with procedural storytelling
    or to cover every possible algorithm. The first topic, *Introducing procedural
    storytelling in ink*, reviewed the important concepts, such as how randomness
    can play a role in selecting content in ink. The second section, *Loading values
    into ink*, looked at how more advanced concepts such as grammars and story planning
    can be used with ink. Finally, in the *Coding collections in Unity* topic, we
    saw how Unity can be used to randomly select ink stories in a collection in the
    first section, as well as how some simple conditional testing can be incorporated
    by communicating between ink stories and C# classes in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed the last chapter of this book and hope that you will walk
    away with different concepts to explore and with simple patterns to use for much
    more advanced projects. Procedural storytelling is a diverse and deep subject.
    Many researchers and developers have created and continue to explore possible
    ways to build substitution grammars, plan for stories, and use ink and Unity,
    either separately or together, to craft simple rules for complex stories and experiences
    for players.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is procedural storytelling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a random table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is weighted randomness?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is substitution grammar?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is story planning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
