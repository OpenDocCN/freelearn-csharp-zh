- en: Testing Your Code with Unit Test Cases and TDD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试用例和TDD测试您的代码
- en: When developing software, it is essential that you ensure that an application
    is bug-free and that it satisfies all specifications. This can be done by testing
    all the modules while they are being developed or when the overall application
    has been either completely or partially implemented.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，确保应用程序无错误并满足所有规范至关重要。这可以通过在开发过程中测试所有模块或在整体应用程序完全或部分实现后进行测试来实现。
- en: Performing all the tests manually is not a feasible option since most of the
    tests must be executed each time the application is modified, and, as explained
    throughout this book, modern software is being continuously modified to adapt
    the applications to the needs of a fast-changing market. This chapter discusses
    all the types of tests needed to deliver reliable software, and how to organize
    and automate them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数测试必须在每次修改应用程序时执行，手动执行所有测试不是一个可行的选项。正如本书中解释的那样，现代软件正在不断修改，以适应快速变化的市场需求。本章讨论了交付可靠软件所需的所有测试类型，以及如何组织和自动化它们。
- en: 'More specifically, this chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章涵盖了以下主题：
- en: Understanding automated tests and their usage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解自动化测试及其用法
- en: Understanding the basics of **test-driven development** (**TDD**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**测试驱动开发**（**TDD**）的基本原理
- en: Optimizing a software investment using TDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TDD优化软件投资
- en: Defining C# test projects in Visual Studio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中定义C#测试项目
- en: In this chapter, we'll see which types of tests are worth implementing, and
    what unit tests are. We'll see the different types of projects available and how
    to write unit tests in them. By the end of the chapter, the book use case will
    help us to execute our tests in Azure DevOps during the **Continuous Integration/Continuous
    Delivery** (**CI/CD**) cycle of our applications automatically.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解哪些类型的测试值得实施，以及单元测试是什么。我们将了解可用的不同类型的项目以及如何在其中编写单元测试。到本章结束时，书籍用例将帮助我们自动在Azure
    DevOps中执行应用程序的**持续集成/持续交付**（**CI/CD**）周期中的测试。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the 2019 free Community Edition with all database tools
    installed. It also requires a free Azure account; if you have not already created
    one, see the *Creating an Azure account* section in [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding
    the Importance of Software Architecture.*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装所有数据库工具的2019免费社区版。它还需要一个免费的Azure账户；如果您尚未创建，请参阅[第1章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)，*理解软件架构的重要性*中的*创建Azure账户*部分。
- en: All concepts in this chapter are clarified with practical examples based on
    the WWTravelClub book use case. The code for this chapter is available at: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都通过基于WWTravelClub书籍用例的实用示例进行了阐明。本章的代码可在以下网址找到：[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)。
- en: Understanding automated tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自动化测试
- en: 'Delaying the application testing until immediately after most of its functionalities
    have been completely implemented must be avoided for the following reasons:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 必须避免在大多数功能完全实现后立即进行应用程序测试，原因如下：
- en: If a class or module has been incorrectly designed or implemented, it might
    have already influenced the way other modules were implemented. Therefore, at
    this point, fixing the problem might have a very high cost.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类或模块设计或实现不当，它可能已经影响了其他模块的实现方式。因此，在此阶段，修复问题可能代价高昂。
- en: The possible combination of input that is needed to test all possible paths
    that execution can take grows exponentially with the number of modules or classes
    that are tested together. Thus, for instance, if the execution of a class method
    `A` can take three different paths, while the execution of another method `B`
    can take four paths, then testing `A` and `B` together would require 3 x 4 different
    inputs. In general, if we test several modules together, the total number of paths
    to test is the product of the number of paths to test in each module. If modules
    are tested separately, instead, the number of inputs required is just the sum of
    the paths needed to test each module.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要测试所有可能执行路径的输入组合的数量随着一起测试的模块或类的数量呈指数增长。例如，如果一个类方法`A`的执行可以采取三条不同的路径，而另一个方法`B`的执行可以采取四条路径，那么测试`A`和`B`一起就需要3
    x 4种不同的输入。一般来说，如果我们一起测试几个模块，需要测试的总路径数是每个模块测试路径数的乘积。相反，如果单独测试模块，所需的输入数量只是测试每个模块所需路径的总和。
- en: If a test of an aggregate made of N modules fails, then locating the origin
    of the bug among the N modules is usually a very time consuming activity.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由N个模块组成的聚合测试失败，那么在N个模块中定位错误源通常是一个非常耗时的活动。
- en: When N modules are tested together, we have to redefine all tests involving
    the N modules, even if just one of the N modules changes during the application's
    CI/CD cycle.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试N个模块时，我们必须重新定义涉及N个模块的所有测试，即使只是在应用程序的CI/CD周期中有一个N个模块发生变化。
- en: The preceding considerations show that it is more convenient to test each module
    method separately. Unluckily, a battery of tests that verifies all methods independently
    from their context is incomplete because some bugs may be caused by incorrect
    interactions between modules.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的考虑表明，单独测试每个模块的方法更为方便。不幸的是，一组独立于其上下文验证所有方法的测试是不完整的，因为一些错误可能是由模块之间不正确的交互引起的。
- en: 'Therefore, tests are organized into two stages:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试被组织成两个阶段：
- en: '**Unit tests**: These verify that all execution paths of each module behave
    properly. They are quite complete and usually cover all possible paths. This is
    feasible because there are not very many possible execution paths of each method
    or module compared to the possible execution paths of the whole application.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试验证每个模块的所有执行路径都表现正常。它们相当完整，通常覆盖所有可能的路径。这是可行的，因为与整个应用程序的可能执行路径相比，每个方法或模块的可能执行路径并不多。'
- en: '**Integration tests**: These are executed once the software passes all its
    unit tests. Integration tests verify all modules interact properly to get the
    expected results. Integration tests do not need to be complete since unit tests
    will have already verified that all execution paths of each module work properly.
    They need to verify all patterns of interaction, that is, all the possible ways
    the various modules may cooperate.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试在软件通过所有单元测试后执行。集成测试验证所有模块是否正确交互以获得预期结果。由于单元测试已经验证了每个模块的所有执行路径都正常工作，因此集成测试不需要完全覆盖。它们需要验证所有交互模式，即各种模块可能合作的所有可能方式。'
- en: 'Usually, each interaction pattern has more than one test associated with it:
    a typical activation of a pattern, and some extreme cases of activation. For instance,
    if a whole pattern of interaction receives an array as input, we will write a
    test for the typical size of the array, a test with a `null` array, a test for
    an empty array, and a test with a very big array. This way we verify that the
    way the single module was designed is compatible with the needs of the whole interaction
    pattern.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个交互模式都与多个测试相关联：一个典型的模式激活，以及一些激活的极端情况。例如，如果一个完整的交互模式接收一个数组作为输入，我们将为典型的数组大小编写一个测试，一个`null`数组的测试，一个空数组的测试，以及一个非常大的数组的测试。这样我们就可以验证单个模块的设计方式是否与整个交互模式的需求兼容。
- en: With the preceding strategy in place, if we modify a single module without changing
    its public interface, we need to change the unit tests for that module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施上述策略的情况下，如果我们修改单个模块而不改变其公共接口，我们需要更改该模块的单元测试。
- en: If, instead, the change involves the way some modules interact, then we also
    have to add new integration tests or to modify existing ones. However, usually,
    this is not a big problem since most of the tests are unit tests, so rewriting
    a large percentage of all integration tests does not require too big an effort.
    Moreover, if the application was designed according to the **Single Responsibility,
    Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion** (**SOLID**)
    principles, then the number of integration tests that must be changed after a
    single code modification should be small since the modification should affect
    just a few classes that interact directly with the modified method or class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it should be clear that both unit tests and integration tests
    must be reused during the entire lifetime of the software. That is why it is worth
    automating them. Automation of unit and integration tests avoids possible errors
    of manual test execution and saves time. A whole battery of several thousand automated
    tests can verify software integrity after each small modification in a few minutes,
    thus enabling the frequent changes needed in the CI/CD cycles of modern software.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: As new bugs are found, new tests are added to discover them so that they cannot
    reappear in future versions of the software. This way automated test always become
    more reliable and protect the software more form bugs added by new changes. Thus,
    the probability of adding new bugs (that are not immediately discovered) is greatly
    reduced.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The next section will give us the basics for organizing and designing automated
    unit and integration tests, as well as practical details on how to write a test
    in C# in the *C# Test Projects* section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Writing automated (unit and integration) tests
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests are not written from scratch; all software development platforms have
    tools that help us to both write tests and launch them (or some of them). Once
    the selected tests have been executed, all tools show a report and give the possibility
    to debug the code of all failed tests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, all unit and integration test frameworks are made of three
    important parts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Facilities for defining all tests: **They verify if the actual results correspond
    to expected results. Usually, a test is organized into test classes, where each
    test calls tests either a single application class or a single class method. Each
    test is split into three stages:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test preparation**: The general environment needed by the test is prepared.
    This stage doesn''t prepare the single input each method to test must be called
    with, but just the global environment, such as objects to inject in class constructors
    or simulations of database tables. Usually, the same preparation procedure is
    used in several tests, so test preparations are factored out into dedicated modules.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test execution**: The methods to test are invoked with adequate input and
    all results of their executions are compared with expected results with constructs
    such as `Assert.Equal(x, y)`, `Assert.NotNull(x)`, and so on.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tear-down**: The whole environment is cleaned up to avoid the execution of
    a test influencing other tests. This step is the converse of step 1.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mock facilities**: While integration tests use all (or almost all) classes
    involved in a pattern of objects cooperation, in unit tests the use of other application
    classes is forbidden. Thus, if a class under test, say, `A`, uses a method of
    another application class, `B`, that is injected in its constructor in one of
    its methods, `M`, then in order to test `M` we must inject a fake implementation
    of `B`. It is worth pointing out that only classes that do some processing are
    not allowed to use another class during unit tests, while pure data classes can.
    Mock frameworks contain facilities to define fake implementations of interfaces
    and interface methods that return data that can be defined in tests. Typically,
    fake implementations are also able to report information on all fake method calls.
    Such fake implementations do not need the definition of actual class files but
    are done online in the test code by calling methods such as `new Mock<IMyInterface>()`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution and reporting tool**: This is a visual configuration-based tool
    that the developer may use to decide which tests to launch and when to launch
    them. Moreover, it also shows the final outcome of the tests as a report containing
    all successful tests, all failed tests, each test''s execution time, and other
    information that depends on the specific tool and on how it was configured. Usually,
    execution and reporting tools that are executed in development IDEs such as Visual
    Studio also give you the possibility of launching a debug session on each failed
    test.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since mock frameworks can only create fake implementations of interfaces but
    not of classes, we should inject interfaces or pure data classes (that don't need
    to be mocked) in class constructors and methods; otherwise, classes cannot be
    unit tested. Therefore, for each cooperating class that we want to inject into
    another class, we must define a corresponding interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, classes should use instances that are injected in their constructors
    or methods, and not class instances available in the public static fields of other
    classes; otherwise, the hidden interactions might be forgotten while writing tests,
    and this might complicate the *preparation* step of tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The next section describes other types of test used in software development.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Writing acceptance and performance tests
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Acceptance tests define the contract between the project stakeholders and the
    development team. They are used to verify that the software developed actually
    behaves as agreed with them. Acceptance tests verify not only functional specifications
    but also constraints on the software usability and user interface. Since they also have
    the purpose of showing how the software appears and behaves on actual computer
    monitors and displays, they are never completely automatic but consist mainly
    of lists of recipes and verifications that must be followed by an operator.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试定义了项目利益相关者与开发团队之间的合同。它们被用来验证开发的软件是否确实按照与他们的约定行事。接受测试不仅验证功能规范，还验证软件可用性和用户界面的约束。由于它们的目的还包括展示软件在实际计算机显示器和显示设备上的外观和行为，因此它们永远不会完全自动化，主要由必须由操作员遵循的食谱和验证列表组成。
- en: Sometimes, automatic tests are developed to verify just the functional specifications,
    but such tests usually bypass the user interface and inject the test input directly
    in the logic that is immediately behind the user interface. For instance, in the
    case of an ASP.NET Core MVC application, the whole website is run in a complete
    environment that includes all the needed storage filled with test data; input
    is not provided to HTML pages but is injected directly in the ASP.NET Core controllers.
    Tests that bypass the user interface are called subcutaneous tests. ASP.NET Core
    supplies various tools to perform subcutaneous tests and also tools that automate
    the interaction with HTML pages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，自动测试的开发是为了验证仅功能规范，但此类测试通常绕过用户界面，直接将测试输入注入到用户界面后面的逻辑中。例如，在ASP.NET Core MVC应用程序的情况下，整个网站在一个完整的环境中运行，包括所有需要的存储空间，并填充了测试数据；输入不提供给HTML页面，而是直接注入到ASP.NET
    Core控制器中。绕过用户界面的测试被称为皮下测试。ASP.NET Core提供了各种工具来执行皮下测试，以及自动化与HTML页面交互的工具。
- en: 'Subcutaneous tests are usually preferred in the case of automated tests, while
    full tests are executed manually for the following reasons:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动测试的情况下，通常更倾向于使用皮下测试，而完整测试则手动执行，以下是一些原因：
- en: No automatic test can verify how the user interface appears and how usable it
    is.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有自动测试可以验证用户界面的外观和可用性。
- en: Automating the actual interaction with the user interface is a very time-consuming
    task.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化与用户界面的实际交互是一个非常耗时的工作。
- en: User interfaces are changed frequently to improve their usability and to add
    new features, and also small changes in a single application screen, may force
    a complete rewrite of all tests that operate on that screen.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面经常更改以提高其可用性并添加新功能，而且单个应用程序屏幕的微小更改也可能迫使对该屏幕上运行的全部测试进行完全重写。
- en: In a few words, user interface tests are very expansive and have low reusability,
    so it's rarely worth automating them. However, ASP.NET Core supplies the `Microsoft.AspNetCore.Mvc.Testing`
    NuGet package to run the whole website in a testing environment. Using it together
    with the `AngleSharp` NuGet package, which parses HTML pages into DOM trees, you
    can write automated full tests with an acceptable programming effort. The automated
    ASP.NET Core acceptance tests will be described in detail in [Chapter 20](e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml), *Automation
    for Software Testing*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，用户界面测试非常昂贵且可重用性低，因此很少值得自动化它们。然而，ASP.NET Core提供了`Microsoft.AspNetCore.Mvc.Testing`
    NuGet包，用于在测试环境中运行整个网站。使用它与`AngleSharp` NuGet包一起，该包将HTML页面解析成DOM树，您可以用可接受的编程工作量编写自动化全面测试。将在[第20章](e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml)中详细描述ASP.NET
    Core接受测试，*软件测试自动化*。
- en: Performance tests apply a fake load to an application to see if it is able to
    handle the typical production load, to discover its load limits, and to locate
    bottlenecks. The application is deployed in a staging environment that is a copy
    of the actual production environment in terms of hardware resources. Then, fake
    requests are created and applied to the system, and response times and other metrics
    are collected. Fake request batches should have the same composition as the actual
    production batches. They can be generated from the actual production request logs
    if they are available.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试向应用程序施加模拟负载，以查看其是否能够处理典型的生产负载，以发现其负载限制，并定位瓶颈。应用程序部署在一个预演环境中，该环境在硬件资源方面是实际生产环境的副本。然后，创建并应用模拟请求到系统中，并收集响应时间和其他指标。模拟请求批次应与实际生产批次具有相同的组成。如果可用，它们可以从实际生产请求日志中生成。
- en: If response times are not satisfactory, other metrics are collected to discover
    possible bottlenecks (low memory, slow storages, or slow software modules). Once
    located, a software component that is responsible for the problem can be analyzed
    in the debugger to measure the execution time of the various method calls involved
    in a typical request.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应时间不满意，将收集其他指标以发现可能的瓶颈（低内存、慢速存储或慢速软件模块）。一旦定位到负责问题的软件组件，就可以在调试器中分析它，以测量典型请求中涉及的各个方法调用的执行时间。
- en: Failures in the performance tests may lead either to a redefinition of the hardware
    needed by the application or to the optimization of some software modules, classes
    or methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试中的失败可能导致对应用程序所需硬件的重定义，或者对某些软件模块、类或方法的优化。
- en: Both Azure and Visual Studio offer tools to create fake loads and to report
    execution metrics. However, they have been declared obsolete and will be discontinued
    in quite a short time (about one year from writing this book), and so we will
    not describe them. As an alternative, there are both open source and third-party
    tools that can be used. Some of them are listed in the *Further reading* section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 和 Visual Studio 都提供了创建模拟负载和报告执行指标的工具。然而，它们已被宣布过时，并将很快停止使用（从写这本书起大约一年），因此我们不会描述它们。作为替代方案，有开源和第三方工具可以使用。其中一些在*进一步阅读*部分列出。
- en: The next section describes a software development methodology that gives a central
    role to tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将描述一种将测试置于核心位置的软件开发方法。
- en: Understanding test-driven development (TDD)
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试驱动开发（TDD）
- en: '**Test-driven development** (**TDD**) is a software development methodology
    that gives a central and central role to unit tests. According to this methodology,
    unit tests are a formalization of the specifications of each class, so they must
    be written before the code of the class. Actually, a full test that covers all
    code paths univocally defines the code behavior, so it can be considered a specification
    for the code. It is not a formal specification that defines the code behavior
    through some formal language, but a specification based on behavior examples.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种软件开发方法，它将单元测试置于核心和中心位置。根据这种方法，单元测试是每个类规范的正式化，因此必须在类的代码之前编写。实际上，一个覆盖所有代码路径的完整测试明确定义了代码行为，因此它可以被视为代码的规范。这不是通过某种正式语言定义代码行为的正式规范，而是一种基于行为示例的规范。'
- en: The ideal way to test software would be to write formal specifications of the
    whole software behavior and to verify with some completely automatic tools if
    the software that was actually produced conforms with them. In the past, some
    research effort was spent defining formal languages for describing code specifications,
    but expressing the behavior the developer has in mind with similar languages was
    a very difficult and error-prone task. Therefore, these attempts were quickly
    abandoned in favor of approaches based on examples. At that time, the main purpose
    was the automatic generation of code. Nowadays, automatic code generation has
    been substantially abandoned and survives in small application areas, such as
    the creation of device drivers. In these areas, the effort of formalizing the
    behavior in a formal language is worth the time saved in trying to test difficult-to-reproduce
    behaviors of parallel threads.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件的理想方式是编写整个软件行为的正式规范，并使用一些完全自动化的工具来验证实际产生的软件是否符合这些规范。在过去，一些研究工作被用于定义用于描述代码规范的正式语言，但使用类似语言表达开发者心中的行为是一个非常困难且容易出错的任务。因此，这些尝试很快就被放弃了，转而采用基于示例的方法。当时，主要目的是自动生成代码。如今，自动代码生成已被大量放弃，仅在小应用领域幸存，如设备驱动程序的开发。在这些领域，将行为在正式语言中形式化的努力值得在尝试测试难以重现的并行线程行为时节省的时间。
- en: Unit tests were initially conceived as a way to encode example-based specifications
    in a completely independent way, as a part of a specific agile development methodology
    called **Extreme Programming**. However, nowadays, TDD is used independently of
    Extreme Programming and is included as an obligatory prescription in other agile
    methodologies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试最初被构想为以完全独立的方式编码基于示例的规范，作为名为**极限编程**（**Extreme Programming**）的特定敏捷开发方法的一部分。然而，如今，TDD
    可以独立于极限编程使用，并被纳入其他敏捷方法中的强制规定。
- en: While it is undoubtedly true that unit tests refined after finding hundreds
    of bugs act as reliable code specifications, it is not obvious that developers
    can easily design unit tests that can be immediately used as reliable specifications
    for the code to be written. In fact, generally, you need an infinite or at least
    an immense number of examples to univocally define a code's behavior if examples
    are chosen at random.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然毫无疑问，在发现数百个错误后经过优化的单元测试可以作为可靠的代码规范，但开发者是否能够轻松设计出可以直接用作编写代码的可靠规范的单元测试并不明显。实际上，通常情况下，如果随机选择示例，你需要无限或至少是大量的示例来唯一地定义代码的行为。
- en: 'The behavior can be defined with an acceptable number of examples only after
    you have understood all possible execution paths. In fact, at this point, it is
    enough to select a typical example for each execution path. Therefore, writing
    a unit test for a method after that method has been completely coded is easy:
    it simply requires selecting a typical instance for each execution path of the
    already existing code. However, writing unit tests this way does not protect from
    errors in the design of the execution paths themselves. For instance, it doesn''t
    prevent the typical error of forgetting to test a variable for the `null` value
    before invoking a member. That is why TDD suggests writing unit tests before the
    application code.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你理解了所有可能的执行路径之后，才能用可接受数量的示例定义行为。实际上，在这个时候，选择每个执行路径的典型示例就足够了。因此，在完全编写完方法之后编写该方法的单元测试是很容易的：它只需要为现有代码的每个执行路径选择一个典型实例。然而，以这种方式编写单元测试并不能防止执行路径设计本身的错误。例如，它不能防止忘记在调用成员之前测试变量的`null`值的典型错误。这就是为什么TDD建议在编写应用程序代码之前编写单元测试。
- en: We may conclude that, while writing unit tests, the developer must forecast
    somehow all execution paths by looking for extreme cases and by possibly adding
    more examples than strictly needed. However, the developer can make mistakes while
    writing the application code, and he or she can also make mistakes in forecasting
    all possible execution paths while designing the unit tests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，在编写单元测试时，开发者必须通过寻找极端情况以及可能添加比严格需要的更多示例来预测所有可能的执行路径。然而，开发者可能在编写应用程序代码时犯错误，他们也可能在设计单元测试时预测所有可能的执行路径时犯错误。
- en: 'We have found the main drawback of TDD: unit tests themselves may be wrong.
    That is, not only application code, but also its associated TDD unit tests may
    be incoherent with the behavior the developer has in mind. Therefore, in the beginning,
    unit tests can''t be considered software specifications, but rather a possible
    wrong and incomplete description of the software behavior. Therefore, we have
    two descriptions of the behavior we have in mind, the application code itself
    and its TDD unit tests that were written before the application code.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了TDD的主要缺点：单元测试本身可能是错误的。也就是说，不仅应用程序代码，与其相关的TDD单元测试也可能与开发者心中的行为不一致。因此，在开始时，单元测试不能被视为软件规范，而更可能是一个可能的错误和不完整的软件行为描述。因此，我们有两个关于我们心中所想行为的描述，即应用程序代码及其在应用程序代码之前编写的TDD单元测试。
- en: What makes TDD work is that the probability of making exactly the same error
    while writing the tests and while writing the code is very low. Therefore, whenever
    a test fails there is an error either in the tests or in the application code,
    and, conversely, if there is an error either in the application code or in the
    test, there is a very high probability a test will fail. That is, the usage of
    TDD ensures that most of the bugs are immediately found!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TDD之所以有效，是因为在编写测试和编写代码时犯完全相同错误的概率非常低。因此，每当测试失败时，要么是测试中存在错误，要么是应用程序代码中存在错误，反之亦然，如果应用程序代码或测试中存在错误，那么有很高的概率测试会失败。也就是说，TDD的使用确保了大多数错误都能立即被发现！
- en: 'Writing a class method or a chunk of code with TDD is a loop composed of three
    stages:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD编写类方法或代码块是一个由三个阶段组成的循环：
- en: 'Red stage: In this stage, the developer designs new unit tests that must necessarily
    fail because at this time there is no code that implements the behavior they describe.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色阶段：在这个阶段，开发者设计新的单元测试，这些测试必然会失败，因为此时还没有代码实现他们所描述的行为。
- en: 'Green stage: In this stage, the developer writes the minimum code or makes
    the minimum modifications to existing code that are necessary to pass all unit
    tests.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色阶段：在这个阶段，开发者编写最少的代码或对现有代码进行必要的最小修改，以通过所有单元测试。
- en: 'Refactoring stage: Once the test is passed, code is refactored to ensure good
    code quality and the application of best practices and patterns. In particular,
    in this stage, some code can be factored out in other methods or in other classes.
    During this stage, we may also discover the need for other unit tests, because
    new execution paths or new extreme cases are discovered or created.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop stops as soon as all tests pass without writing new code or modifying
    the existing code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is very difficult to design the initial unit tests because it
    is quite difficult to imagine how the code might work and the execution paths
    it might take. In this case, you can get a better understanding of the specific
    algorithm to use by writing an initial sketch of the application code. In this
    initial stage, we need to focus just on the main execution path, completely ignoring
    extreme cases and input verifications. Once we get a clear picture of the main
    ideas behind an algorithm that should work we can enter the standard three-stage
    TDD loop.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will list all test projects available in Visual Studio
    and describe xUnit in detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Defining C# test projects
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio contains project templates for three types of unit testing frameworks,
    namely, MSTest, xUnit, and NUnit. Once you start the new project wizard, in order
    to visualize the version of all of them that is adequate for .NET Core C# applications,
    set Project type as Test, Language as C#, and Platform as Linux, since .NET Core
    projects are the only ones that can be deployed on Linux.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the selection that should appear:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e137b957-4a21-44f1-8824-b7e36823e952.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: All the preceding projects automatically include the NuGet package for running
    all the tests in the Visual Studio test user interface (Visual Studio test runner).
    However, they do not include any facility for mocking interfaces, so you need
    to add the `Moq` NuGet package that contains a popular mocking framework.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: All test projects must contain a reference to the project to be tested.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will describe xUnit, since it is probably the most popular
    of the three frameworks. However, all three frameworks are quite similar and differ
    mainly in the names of the methods and in the names of the attributes used to
    decorate various testing stuff.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Using the xUnit test framework
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In xUnit, tests are methods decorated with either with the `[Fact]` or with
    the `[Theory]` attributes. Tests are automatically discovered by the test runner
    that lists all of them in the user interface so the user can run either all of
    them or just a selection of them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: A new instance of the test class is created before running each test, so the
    *test preparation* code contained in the class constructor is executed before
    each test of the class. If you also need *tear-down* code, the test class must
    implement the `IDisposable` interface so that the tear-down code can be included
    in the `IDisposable.Dispose` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The test code invokes the methods to be tested and then tests the results with
    methods of the `Assert` static class, such as `Assert.NotNull(x)`, `Assert.Equal(x,
    y)`, and `Assert.NotEmpty(IEnumerable x)`. There are also methods that verify
    if a call throws an exception of a specific type, for instance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When an assertion fails, an exception is thrown. A test fails if a not-intercepted
    exception is thrown either by the test code or by an assertion.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a method that defines a single test:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `[Fact]` attribute is used when a method defines just one test, while the `[Theory]` attribute
    is used when the same method defines several tests, each on a different tuple
    of data. Tuples of data can be specified in several ways and are injected in the
    test as method parameters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code can be modified to test `MethodToTest` on several input as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each `InlineData` attribute specifies a tuple to be injected in the method
    parameters. Since just simple constant data can be included as attribute arguments,
    xUnit gives you also the possibility to take all data tuples from a class that
    implements `IEnumerable`, as shown in the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The type of the class that provides the test data is specified with the `ClassData`
    attribute.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to take data from a static method of a class that returns
    an `IEnumerable` with the `MemberData` attribute, as shown in the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `MemberData` attribute is passed the method name as the first parameter,
    and the class type in the `MemberType` named parameter. If the static method is
    part of the same test class the `MemberType` parameter can be omitted.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to deal with some advanced preparation and tear-down
    scenarios.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Advanced test preparation and tear-down scenarios
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the preparation code contains very time-consuming operations, such
    as opening a connection with a database, that don't need to be repeated before
    each test but can be executed once before all the tests contained in the same
    class. In xUnit, this kind of test preparation code can't be included in the test
    class constructor; since a different instance of the test class is created before
    every single test, it must be factored out in a separate class called a fixture
    class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: If we also need a corresponding tear-down code, the fixture class must implement
    `IDisposable`. In other test frameworks, such as NUnit, the test class instances
    are created just once instead, so they don't need the fixture code to be factored
    out in other classes. However, test frameworks that, like NUnit, do not create
    a new instance before each test may suffer from bugs because of unwanted interactions
    between test methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an xUnit fixture class that opens and closes
    a database connection:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since a fixture class instance is created just once before all tests associated
    with the fixture are executed and the same instance is disposed of immediately
    after the tests, then the database connection is created just once when the fixture
    class is created and is disposed of immediately after the tests when the fixture
    object is disposed of.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixture class is associated with each test class by letting the test class
    implement the empty `IClassFixture<T>` interface, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A fixture class instance is automatically injected in the test class constructor
    in order to make all data computed in the fixture test preparation available for
    the tests. This way, for instance, in our previous example we can get the database
    connection instance so that all test methods of the class can use it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to execute some test preparation code on all tests contained in
    a collection of test classes instead of a single test class, we must associate
    the fixture class to an empty class that represents the collection of test classes,
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `CollectionDefinition` attribute declares the name of the collection, and
    the `IClassFixture<T>` interface has been replaced with `ICollectionFixture<T>`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we declare that a test class belongs to the previously defined collection
    by applying it to the `Collection` attribute with the name of the collection,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Collection` attribute declares which collection to use, while the `DataBaseFixture`
    argument in the test class constructor provides an actual fixture class instance,
    so it can be used in all class tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to mock interfaces with the Moq framework.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Mocking interfaces with Moq
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking capabilities are not included in any of the test frameworks we listed
    in this section as they are not included in xUnit. Therefore, they must be provided
    by installing a specific NuGet package. The Moq framework available in the `Moq`
    NuGet package is the most popular mock framework available for .NET and .NET Core.
    It is quite easy to use and will be briefly described in this section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve installed the NuGet package, we need to add a `using Moq` statement
    in our test files. A mock implementation is easily defined, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The behavior of the mock dependency on specific input of the specific method
    can be defined with the `Setup/Return` method pair as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After `Return`, we may place another `Setup/Return` pair that defines either
    the behavior of different input of the same method or the behavior of a different
    method. This way we can specify an indefinite number of input/output behaviors.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of specific input values, we may also use wildcards that match a specific
    type as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once configured the mock dependency we may extract the mocked instance from
    its `Object` property and use it as if it were an actual implementation, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, mocked methods are usually called by the code under test, so we just
    need to extract the mocked instance and use it as an input in our tests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We may also mock properties and async methods as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With async methods, `Returns` must be replaced by `ReturnsAsync`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Each mocked instance records all calls to its methods and properties, so we
    may use this information in our tests. The following code shows an example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding statement asserts `MyMethod` that has been invoked with the given
    arguments at least twice. There are also `Times.Never`, a `Times.Once` (that asserts
    the method was called just once), and more.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The Moq documentation summarized up to now should cover 99% of the needs that
    may arise in your tests, but Moq also offers more complex options. The *Further
    reading* section contains the link to the complete documentation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to define in practice unit tests and how to run them
    both in Visual Studio and in Azure DevOps with the help of the book use case.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Use case – automating unit tests in DevOps Azure
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we add some unit test projects to the example application we
    built in [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml), *Presenting
    ASP.NET Core MVC*. If you don't have it, you can download it from the [Chapter
    13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml), *Presenting ASP.NET Core MVC*,
    section of the GitHub repository associated with the book. The [Chapter 4](049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml),
    *Deciding The Best Cloud-Based Solution*, section of the GitHub repository contains
    the code we will add in this section and all the instructions to add it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, let's make a new copy of the solution folder and name it `PackagesManagementWithTests`.
    Then open the solution and add it to xUnit .NET Core C# test project named `PackagesManagementTest`.
    Finally, add a reference to the ASP.NET Core project (`PackagesManagement`), since
    we will test it, and a reference to the last version of the `Moq` NuGet package,
    since we need mocking capabilities. At this point, we are ready to write our tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will write unit tests for the `Edit` method decorated with
    `[HttpPost]` of the `ManagePackagesController` controller, which is shown as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before writing our test methods, let's rename the test class that was automatically
    included in the test project as `ManagePackagesControllerTests`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test verifies that in case there are errors in `ModelState` the action
    method renders a view with the same model it received as an argument so that the
    user can correct all errors. Let''s delete the existing test method and write
    an empty `DeletePostValidationFailedTest` method, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The method must be `async` since the `Edit` method that we have to test is
    `async`. In this test, we don''t need mocked objects since no injected object
    will be used. Thus, as a preparation for the test we just need to create a controller
    instance, and we must add an error to `ModelState` as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we invoke the method, injecting `ViewModel` and a `null` command handler
    as its arguments since the command handler will not be used:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the verification stage, we verify that the result is `ViewResult` and that
    it contains the same model that was injected in the controller:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we also need a test to verify that in case there are no errors the command
    handler is called, and then the browser is redirected to the `Index` controller
    action method. We call the `DeletePostSuccessTest` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This time the preparation code must include the preparation of a command handler
    mock, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the handler `HandleAsync` method returns no `async` value, we can''t
    use `ReturnsAsync`, but we have to return just a completed `Task` (`Task.Complete`)
    with the `Returns` method. The method to test is called with both `ViewModel`
    and the mocked handler:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, the verification code is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As the first step, we verify that the command handler has actually been invoked
    once. A better verification should also include a check that it was invoked with
    a command that includes `ViewModel` passed to the action method. This can be done
    by extracting this information from `commandDependency.Invocations`. We will take
    it up as an exercise.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Then we verify that the action method returns `RedirectToActionResult` with
    the right action method name and with no controller name specified.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Once all tests are ready, if the test windows don't appear on the left bar of
    Visual Studio, we may simply select the Run all tests item from Visual Studio
    Test menu. Once the test window appears, further invocations can be launched from
    within this window.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If a test fails, we can add a breakpoint to its code, so we can launch a debug
    session on it by right-clicking on it in the test window and then by selecting
    Debug selected tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show how to connect our solution with an Azure DevOps repository,
    and we will define an Azure DevOps pipeline that builds the project and launches
    its tests. In this way, every day after that all developers have pushed their
    changes we can launch the pipeline to verify that the repository code compiles
    and passes all the tests:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, we need a free DevOps subscription. If you don't already have
    one, please create one by clicking the Start Free button on this page: [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/).
    Here, let's define an organization but stop before creating a project, since we
    will create the project from within Visual Studio.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure you are logged into Visual Studio with your Azure account (the same
    used in the creation of the DevOps account). At this point, you may create a DevOps
    repository for your solution by right-clicking on the solution and by selecting
    Configure continuous delivery to Azure.... In the window that appears, an error
    message will inform you that you have no repository configured for your code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dbc6d39a-7382-45bc-9bc0-9a16480889fd.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Click the Add to source control now link. After that, the DevOps screen will
    appear in the Visual Studio Team Explorer tab:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea638c5d-f9df-4efb-9900-55e2d82f91ac.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'Once you click the Publish Git Repo button, you will be prompted to select
    your DevOps organization and a name for the repository. After you successfully
    publish your code to a DevOps repository, the DevOps screen should change as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fee29f8b-e302-4bba-a4c0-f5e238a8360f.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: The DevOps screen shows a link to your online DevOps project. In future when
    you open your solution, if the link does not appear, please click the DevOps screen
    Connect button or the Manage connections link (whichever appears) to select and
    connect your project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Click this link to go to the online project. Once there, if you click the Repos item,
    on the left-hand menu, you will see the repository you just published.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, click the Pipelines menu item to create a DevOps pipeline to build and
    test your project. In the window that appears, click the button to create a new
    pipeline:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6b38797-da24-4450-9375-88d70a784da6.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'You will be prompted to select where your repository is:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/312d6a6e-71f3-4f9e-945c-df13b556ad9d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Select Azure Repos Git and then your repository. Then you will be prompted
    about the kind of project:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd35e542-279e-473b-9f8a-a6212f4fa607.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'Select ASP.NET Core. A pipeline for building and testing your project will
    be automatically created for you. Save it by committing the newly created `.yaml`
    file to your repository:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c97e7062-e8f8-4ee0-a7f9-ae78f5c77746.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'The pipeline can be run by selecting the Queue button, but since the standard
    pipeline scaffolded by DevOps has a trigger on the master branch of the repository,
    it is automatically launched each time changes to this branch are committed and
    each time the pipeline is modified. The pipeline can be modified by clicking the
    Edit button:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d650049-a388-41e8-8617-ac1603d5b610.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Once in edit mode, all pipeline steps can be edited by clicking the Settings link
    that appears above each of them. New pipeline steps can be added as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `task:` where the new step must be added and then accept one of the suggestions
    that appear while you are typing the task name.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have written a valid task name a Settings link appears above the new
    step, click it.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the desired task parameters in the window that appears and save.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to have our test working, we need to specify the criteria to locate
    all assemblies that contain tests. In our case, since we have a unique `.dll` file
    containing the tests, it is enough to specify its name. Click the Settings link
    of the `VSTest@2` test task, and replace the content that is automatically suggested
    for the Test files field with the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then click Add to modify the actual pipeline content. As soon as you confirm
    your changes in the Save and run dialog, the pipeline is launched, and if there
    are no errors, test results are computed. The results of tests launched during
    a specific build can be analyzed by selecting the specific build in the pipeline
    History tab and by clicking the Tests tab on the page that appears. In our case,
    we should see something like the following screenshot:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2f00596e-c2af-4fa5-94f6-fea25143eb4e.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'If you click the Analytics tab of the pipeline page, you will see analytics
    about all builds, including analytics about the test results:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3826cfb0-e925-40f6-b796-29ea9865b12a.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Clicking the test area of the Analytics page gets us a detailed report about
    all pipeline test results.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained why it is worth automating software tests, and
    then we focused on the importance of unit tests. We also listed all types of tests
    and their main features, focusing mainly on unit tests. We analyzed the advantages
    of TDD, and how to use it in practice. With this knowledge, you should be able
    to produce software that is both reliable and easy to modify.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we analyzed all test tools available for .NET Core projects, focusing
    on the description of xUnit and Moq and showed how to use them in practice both
    in Visual Studio and in Azure DevOps with the help of the book use case.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter looks at how to test and measure the quality of the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it worth automating unit tests?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main reason TDD is able immediately to discover most bugs?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `[Theory]` and `[Fact]` attributes of xUnit?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which xUnit static class is used in test assertions?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which methods allow the definition of the Moq mocked dependencies?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to mock async methods with Moq? If yes, how?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the documentation on xUnit included in the chapter is quite complete,
    it doesn't include the few configuration options offered by xUnit. The full xUnit
    documentation is available at [https://xunit.net/](https://xunit.net/). Documentation
    for MSTest and NUnit can be found at [https://github.com/microsoft/testfx](https://github.com/microsoft/testfx) and
    at [https://github.com/nunit/docs/wiki/NUnit-Documentation](https://github.com/nunit/docs/wiki/NUnit-Documentation) respectively.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管章节中包含的xUnit文档相当完整，但它并没有包括xUnit提供的少数配置选项。完整的xUnit文档可在[https://xunit.net/](https://xunit.net/)找到。MSTest和NUnit的文档分别可在[https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)和[https://github.com/nunit/docs/wiki/NUnit-Documentation](https://github.com/nunit/docs/wiki/NUnit-Documentation)找到。
- en: Moq full documentation is at [https://github.com/moq/moq4/wiki/Quickstart](https://github.com/moq/moq4/wiki/Quickstart).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Moq的完整文档可在[https://github.com/moq/moq4/wiki/Quickstart](https://github.com/moq/moq4/wiki/Quickstart)找到。
- en: 'Here are some links to performance test frameworks for web applications:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些针对Web应用程序的性能测试框架的链接：
- en: '[https://jmeter.apache.org/](https://jmeter.apache.org/) (free and open source)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jmeter.apache.org/](https://jmeter.apache.org/) (免费和开源)'
- en: '[https://www.neotys.com/neoload/overview](https://www.neotys.com/neoload/overview)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.neotys.com/neoload/overview](https://www.neotys.com/neoload/overview)'
- en: '[https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview](https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview](https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview)'
- en: '[https://www.microfocus.com/en-us/products/silk-performer/overview](https://www.microfocus.com/en-us/products/silk-performer/overview)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/en-us/products/silk-performer/overview](https://www.microfocus.com/en-us/products/silk-performer/overview)'
