<html><head></head><body>
<div id="_idContainer055">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.2.1">Implementing the API and BFF Gateway Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When building an application using the microservices architectural approach, we have come to realize that we will need to keep track of several API endpoints. </span><span class="koboSpan" id="kobo.3.2">We have effectively gone from one endpoint, which would have been made available through a monolith, to a series of endpoints. </span><span class="koboSpan" id="kobo.3.3">Some of these endpoints will be called by other APIs and some will integrate directly into the client applications that interact with the microservices.</span></p>
<p><span class="koboSpan" id="kobo.4.1">This becomes a challenge because we end up conflating the client application with custom logic to cater to integrating with the various services and possibly orchestrating inter-service communications. </span><span class="koboSpan" id="kobo.4.2">We want to keep the client application code as simple and extensible as possible, but integrating with each service does not support that notion.</span></p>
<p><span class="koboSpan" id="kobo.5.1">This is where we will consider implementing the API gateway pattern, which introduces a central point of contact between the client and the services. </span><span class="koboSpan" id="kobo.5.2">Our API gateway will keep a record of all the endpoints and expose a single API address where the endpoints will map to the various endpoints of the other microservices.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, we will look at various scenarios that will make an API gateway a good selection for our application and methods of implementation.</span></p>
<p><span class="koboSpan" id="kobo.7.1">After reading this chapter, we will be able to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Understand API gateways and why they are important</span></li>
<li><span class="koboSpan" id="kobo.9.1">Implement an API gateway using industry-leading technology and methods</span></li>
<li><span class="koboSpan" id="kobo.10.1">Properly implement the </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">backend for frontend</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.13.1">BFF</span></strong><span class="koboSpan" id="kobo.14.1">) pattern</span></li>
</ul>
<h1 id="_idParaDest-159"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">The code references used in this chapter can be found in this project’s repository, which is hosted on GitHub at </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch11"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch11</span></a><span class="koboSpan" id="kobo.18.1">.</span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.19.1">What is the API gateway pattern?</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To understand the API gateway pattern and why we need it, we need to review the fundamentals of the service-oriented </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.21.1">architecture and how we architect such solutions.</span></p>
<p><span class="koboSpan" id="kobo.22.1">The service-oriented architecture includes three main layers to an application:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.23.1">Client</span></strong><span class="koboSpan" id="kobo.24.1">: Also referred to as the fronted. </span><span class="koboSpan" id="kobo.24.2">This client app is what the user sees and is designed to consume its </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.25.1">data from an API. </span><span class="koboSpan" id="kobo.25.2">Its functionality is generally limited to functions that the API makes available, and a frontend developer can leverage several techniques to expose functionality to the end user.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.26.1">Server</span></strong><span class="koboSpan" id="kobo.27.1">: Also referred to as the backend. </span><span class="koboSpan" id="kobo.27.2">This section of the architecture houses the API and the </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.28.1">business logic. </span><span class="koboSpan" id="kobo.28.2">The client app is only as intelligent as the backend. </span><span class="koboSpan" id="kobo.28.3">The backend can be made up of one or more services, as would be the case with microservices.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.29.1">Database</span></strong><span class="koboSpan" id="kobo.30.1">: The database is the anchor of this entire application since it stores all the data being </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.31.1">used by the API backend and is displayed on the frontend.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">This application layout is popular in monolithic applications, where all the functionality that is needed on the frontend can be found in one API. </span><span class="koboSpan" id="kobo.32.2">This is an effective development method that has been at the helm of many successful and powerful applications. </span><span class="koboSpan" id="kobo.32.3">We have, however, explored the downsides to a monolithic approach, where the API might become bloated and difficult to maintain in the long run. </span><span class="koboSpan" id="kobo.32.4">The main advantage that we would seem to forsake in the pursuit of a microservices approach would be where we have a single point of entry for the client application, as opposed to several services each with requirements.</span></p>
<p><span class="koboSpan" id="kobo.33.1">While the microservices architecture leads us down the path of having an application that is implemented with the service-oriented architecture, we will need to account for the fact that our client will need to keep track of several backends or APIs and be intelligent enough to orchestrate calls for each user request. </span><span class="koboSpan" id="kobo.33.2">This is a lot of responsibility for the portion of the application that should be the least intelligent, based on the description provided.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.34.1">Figure 11.1</span></em><span class="koboSpan" id="kobo.35.1"> shows the client and microservices:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.36.1"><img alt="Figure 11.1 – The client app needs to be aware of all the endpoints of all the microservices and retain the knowledge of how each one works" src="image/Figure_11.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">Figure 11.1 – The client app needs to be aware of all the endpoints of all the microservices and retain the knowledge of how each one works</span></p>
<p><span class="koboSpan" id="kobo.38.1">This is where we introduce</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.39.1"> an API gateway. </span><span class="koboSpan" id="kobo.39.2">This gateway will sit between our services and the client app and simplify the communication between the two. </span><span class="koboSpan" id="kobo.39.3">For the client, it will expose a singular base URL, which the client will gladly interact with and see as one API service; to the microservices, it will act as a conduit, where it will forward requests coming in from the client to the appropriate microservice.</span></p>
<p><span class="koboSpan" id="kobo.40.1">Let us review the advantages of introducing an API gateway.</span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.41.1">Advantages of an API gateway</span></h2>
<p><span class="koboSpan" id="kobo.42.1">When a request comes in </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.43.1">from a client, it is received by the gateway, which interprets the request, transforms the data if necessary, and then forwards it to the appropriate microservice. </span><span class="koboSpan" id="kobo.43.2">In fact, for situations where multiple microservices may need to be called, we can implement orchestration and result aggregation and return more accurate representations of the data to the client as needed.</span></p>
<p><span class="koboSpan" id="kobo.44.1">Our API gateway also allows us to centralize the following tasks for our microservices:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Centralized Logging</span></strong><span class="koboSpan" id="kobo.46.1">: From the API gateway, we can centrally log all the traffic to our various endpoints and keep track of the success and error responses from the downstream services. </span><span class="koboSpan" id="kobo.46.2">This is advantageous because it spares us the need to implement logging in each service and potentially have a very chatty log. </span><span class="koboSpan" id="kobo.46.3">Using an API gateway allows us to centralize our implementation and prioritize what gets written to the log and can help us to better catalog the outcomes of synchronous operations. </span><span class="koboSpan" id="kobo.46.4">We can also use the gateway to track and log statistics and response times of calls to the downstream services.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.47.1">Caching</span></strong><span class="koboSpan" id="kobo.48.1">: Caching acts as a</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.49.1"> temporary data store that comes in handy when the main data source might be offline or when we need to reduce the number of times the services are called. </span><span class="koboSpan" id="kobo.49.2">We can use a caching layer in the gateway to stabilize our application and potentially increase the application’s performance. </span><span class="koboSpan" id="kobo.49.3">With proper coordination and customization, we can use this caching for high-speed read operations on endpoints that have high volumes of traffic and even use it to handle partial failure, where we use the cached data for a response when a service is unavailable.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.50.1">Security</span></strong><span class="koboSpan" id="kobo.51.1">: Securing microservices can be a tedious and technical task. </span><span class="koboSpan" id="kobo.51.2">Each service might have unique security requirements and may lead to development overhead when coordinating security measures and implementations. </span><span class="koboSpan" id="kobo.51.3">Using an API gateway, we can centralize security measures at the gateway level. </span><span class="koboSpan" id="kobo.51.4">This can remove the burden from the microservice to authenticate and authorize access to resources since the gateway will manage most of those requirements. </span><span class="koboSpan" id="kobo.51.5">We can also implement IP whitelisting at this level and limit access to an approved list of IP addresses.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Service Monitoring</span></strong><span class="koboSpan" id="kobo.53.1">: We can configure our API gateway to conduct health probes on the downstream services. </span><span class="koboSpan" id="kobo.53.2">As previously discussed, health checks or probes help us to ascertain the status of our services. </span><span class="koboSpan" id="kobo.53.3">Since the gateway will need to forward requests, it is important to be able to determine the health of a downstream service before attempting an operation. </span><span class="koboSpan" id="kobo.53.4">Since the gateway can determine the health of a service, it can be configured to gracefully handle failures and partial failures.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.54.1">Service Discovery</span></strong><span class="koboSpan" id="kobo.55.1">: Our gateway needs to know the addresses of all services and how to transform and forward requests as needed. </span><span class="koboSpan" id="kobo.55.2">For this, the gateway needs a register of all the downstream services. </span><span class="koboSpan" id="kobo.55.3">The gateway will simply act as a wrapper around the services endpoints and expose a singular address to the client application.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Rate Limiting</span></strong><span class="koboSpan" id="kobo.57.1">: Sometimes, we want to limit the number of requests that can be sent in quick succession, from the same source, on the suspicion that such activity might </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.58.1">be a </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">distributed denial-of-service</span></strong><span class="koboSpan" id="kobo.60.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.61.1">DDoS</span></strong><span class="koboSpan" id="kobo.62.1">) attack on a service endpoint. </span><span class="koboSpan" id="kobo.62.2">Using the </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.63.1">API gateway, we can implement generic rules that govern how often endpoints can be accessed.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.64.1">Once again, the most important aspect of the gateway’s implementation is that it takes much of the responsibility away from our client, making scaling and diversifying client code much easier.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.65.1">Figure 11.2</span></em><span class="koboSpan" id="kobo.66.1"> shows the client, a gateway, and microservices:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.67.1"><img alt="Figure 11.2 – With the gateway introduced, the client app now has one endpoint and doesn’t need to know about the underlying services" src="image/Figure_11.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.68.1">Figure 11.2 – With the gateway introduced, the client app now has one endpoint and doesn’t need to know about the underlying services</span></p>
<p><span class="koboSpan" id="kobo.69.1">Now that we have seen where the API gateway helps us to centralize access to several API endpoints and make it easier for the client application to integrate API operations, let us review some of the</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.70.1"> disadvantages of using this pattern.</span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.71.1">Disadvantages of an API gateway</span></h2>
<p><span class="koboSpan" id="kobo.72.1">While the </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.73.1">advantages are clear and irrefutable, we must also be aware of the downsides of introducing an API gateway. </span><span class="koboSpan" id="kobo.73.2">An API gateway may come in the form of another microservice and ironically so. </span><span class="koboSpan" id="kobo.73.3">The remedy for dealing with too many services is to build one to rule them all. </span><span class="koboSpan" id="kobo.73.4">This then introduces a single point of failure since when this is offline, our client app will have no way to send requests to the various services. </span><span class="koboSpan" id="kobo.73.5">Now, additional maintenance is required as our gateway service needs to morph alongside each service it interacts with to ensure the requests and responses are accurately interpreted. </span><span class="koboSpan" id="kobo.73.6">We also run the risk of increasing the roundtrip time for requests, since this new layer will need to be performant enough to receive the original request, forward it, and then retrieve and forward the response from the microservice.</span></p>
<p><span class="koboSpan" id="kobo.74.1">While we have obvious advantages that we can reference, we need to ensure that we know, accept, and mitigate the risks involved with implementing a gateway service for our microservices application.</span></p>
<p><span class="koboSpan" id="kobo.75.1">As we have seen, there are several cross-cutting and generic concerns that all APIs share. </span><span class="koboSpan" id="kobo.75.2">Implementing these generic requirements in each service can lead to bloat and attempting to build a singular service to implement them can lead to a monolithic application being created. </span><span class="koboSpan" id="kobo.75.3">It is easier to use a third-party application that is fortified with the main features that we require of an API gateway.</span></p>
<p><span class="koboSpan" id="kobo.76.1">Now, let us review the ways an API gateway could be implemented.</span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.77.1">Implementing the API gateway pattern</span></h1>
<p><span class="koboSpan" id="kobo.78.1">Certain </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.79.1">guidelines should be followed when implementing an API gateway. </span><span class="koboSpan" id="kobo.79.2">Given its description, we might be inclined to develop a new microservice, label it the gateway, and develop and maintain the API integrations ourselves.</span></p>
<p><span class="koboSpan" id="kobo.80.1">Surely, this is a viable approach, and it does give you full control over the implementation, rules, and features that you deem necessary for your application and downstream services. </span><span class="koboSpan" id="kobo.80.2">We can also implement specific business logic to govern certain operations by orchestrating requests and responses to the downstream services and aggregating and transforming data accordingly. </span><span class="koboSpan" id="kobo.80.3">However, this can lead to having a </span><em class="italic"><span class="koboSpan" id="kobo.81.1">thick API gateway</span></em><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">We will discuss this further in the next section.</span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.83.1">Thick API gateways</span></h2>
<p><span class="koboSpan" id="kobo.84.1">The expression </span><em class="italic"><span class="koboSpan" id="kobo.85.1">thick API gateway</span></em><span class="koboSpan" id="kobo.86.1"> is coined when we realize we are placing too much business operation logic into our API gateway. </span><span class="koboSpan" id="kobo.86.2">Our </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.87.1">gateway should act more as an abstraction layer between the client</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.88.1"> and the microservices, not the main hub for business logic. </span><span class="koboSpan" id="kobo.88.2">We should avoid placing business logic in the gateway, which will increase the complexity of the implementation and increase the maintenance effort required for the gateway.</span></p>
<p><span class="koboSpan" id="kobo.89.1">We can also call this an </span><em class="italic"><span class="koboSpan" id="kobo.90.1">overambitious gateway</span></em><span class="koboSpan" id="kobo.91.1"> and generally should try to avoid making the API gateway a</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.92.1"> central point for how our application behaves. </span><span class="koboSpan" id="kobo.92.2">We also risk implementing a monolith and ending up at square one with our microservices application. </span><span class="koboSpan" id="kobo.92.3">At the same time, we should not avoid such a gateway implementation entirely, since there are additional patterns that can be leveraged by having a gateway with some business logic.</span></p>
<p><span class="koboSpan" id="kobo.93.1">Earlier in this book, we</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.94.1"> reviewed the </span><em class="italic"><span class="koboSpan" id="kobo.95.1">Saga pattern</span></em><span class="koboSpan" id="kobo.96.1"> and, more specifically, the </span><em class="italic"><span class="koboSpan" id="kobo.97.1">orchestration pattern</span></em><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">Recall</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.99.1"> that the orchestration pattern hinges on the presence of a central service that has oversight of the downstream services, monitors the service responses, and decides to continue or terminate the saga accordingly. </span><span class="koboSpan" id="kobo.99.2">In this situation, a </span><em class="italic"><span class="koboSpan" id="kobo.100.1">thick API gateway</span></em><span class="koboSpan" id="kobo.101.1"> would be an asset in implementing this kind of behavior.</span></p>
<p><span class="koboSpan" id="kobo.102.1">Ultimately, we all have different needs in our applications, and these are, once again, guidelines that we should abide by in doing our implementations. </span><span class="koboSpan" id="kobo.102.2">We should always make the best decision for our application based on our needs.</span></p>
<p><span class="koboSpan" id="kobo.103.1">In a situation where all these factors might not be applicable and we need to minimize the amount of business logic that the gateway implements, we may look to existing tools and services that can help us to accomplish these with much less maintenance and development effort. </span><span class="koboSpan" id="kobo.103.2">At this point, we can begin thinking about </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Amazon API Gateway</span></em><span class="koboSpan" id="kobo.105.1">, </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Microsoft Azure API Management,</span></em><span class="koboSpan" id="kobo.107.1"> and open source solutions such as </span><em class="italic"><span class="koboSpan" id="kobo.108.1">Ocelot</span></em><span class="koboSpan" id="kobo.109.1">.</span></p>
<p><span class="koboSpan" id="kobo.110.1">In the next section, we will review implementing API gateway functionality using </span><em class="italic"><span class="koboSpan" id="kobo.111.1">Microsoft Azure API Management</span></em><span class="koboSpan" id="kobo.112.1">.</span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.113.1">Implementing an API gateway using Azure API Management</span></h2>
<p><span class="koboSpan" id="kobo.114.1">Microsoft Azure API Management is a cloud-based solution that can be found in the Microsoft Azure suite of development tools. </span><span class="koboSpan" id="kobo.114.2">It is designed to abstract, protect, accelerate, and observe </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.115.1">backend APIs. </span><span class="koboSpan" id="kobo.115.2">While doing this, it securely exposes APIs through service discovery, to internal and external clients, inside and outside of the Azure ecosystem.</span></p>
<p><span class="koboSpan" id="kobo.116.1"> It serves several purposes, including the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">API Gateway</span></strong><span class="koboSpan" id="kobo.118.1">: Allows</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.119.1"> controlled access to backend services and allows us to enforce throttling and access control policies. </span><span class="koboSpan" id="kobo.119.2">The gateway acts as a façade to the backend services, allowing API providers to reduce the attrition involved in making changes to the ever-evolving suite of services in the backend. </span><span class="koboSpan" id="kobo.119.3">The gateway provides consistent and powerful configuration options for security, throttling, monitoring, and even caching.</span></li>
<li><span class="koboSpan" id="kobo.120.1">While this is a cloud-based service, the API gateway can also be deployed in a local environment for customers who wish to self-host their APIs for performance and compliance reasons. </span><span class="koboSpan" id="kobo.120.2">This </span><em class="italic"><span class="koboSpan" id="kobo.121.1">self-hosted gateway</span></em><span class="koboSpan" id="kobo.122.1"> is packaged as a Docker container and is commonly deployed to Kubernetes.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.123.1">Developer Portal</span></strong><span class="koboSpan" id="kobo.124.1">: An automatically generated and fully customizable website. </span><span class="koboSpan" id="kobo.124.2">Third-party developers can use the developer portal to review API documentation and learn how to integrate it into their applications.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.125.1">Management Plane</span></strong><span class="koboSpan" id="kobo.126.1">: This section of Azure API Management allows us to provision and configure the service’s settings. </span><span class="koboSpan" id="kobo.126.2">We can define API schemas from several sources and configure support for different protocols and standards such as </span><em class="italic"><span class="koboSpan" id="kobo.127.1">OpenAPI specifications</span></em><span class="koboSpan" id="kobo.128.1">, </span><em class="italic"><span class="koboSpan" id="kobo.129.1">WebSockets</span></em><span class="koboSpan" id="kobo.130.1">, or </span><em class="italic"><span class="koboSpan" id="kobo.131.1">GraphQL</span></em><span class="koboSpan" id="kobo.132.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.133.1">Now, let us explore some of the steps required to set up our first Azure API Management service. </span><span class="koboSpan" id="kobo.133.2">For these exercises, you will need an </span><em class="italic"><span class="koboSpan" id="kobo.134.1">Azure subscription</span></em><span class="koboSpan" id="kobo.135.1"> and if you don’t already have one, you may create a free </span><em class="italic"><span class="koboSpan" id="kobo.136.1">Microsoft Azure account</span></em><span class="koboSpan" id="kobo.137.1"> before you begin.</span></p>
<p><span class="koboSpan" id="kobo.138.1">Our first action is to sign in to the Azure portal. </span><span class="koboSpan" id="kobo.138.2">You can then use the search feature and type in </span><em class="italic"><span class="koboSpan" id="kobo.139.1">API Management services</span></em><span class="koboSpan" id="kobo.140.1"> and select the matching option in the search results. </span><span class="koboSpan" id="kobo.140.2">The resulting page will list all the instances of the </span><em class="italic"><span class="koboSpan" id="kobo.141.1">API Management services</span></em><span class="koboSpan" id="kobo.142.1"> that you currently have. </span><span class="koboSpan" id="kobo.142.2">For this </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.143.1">exercise, you may proceed by clicking </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">Create</span></strong><span class="koboSpan" id="kobo.145.1">.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.146.1">Figure 11.3</span></em><span class="koboSpan" id="kobo.147.1"> shows the Azure API Management services search results:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.148.1"><img alt="Figure 11.3 – Proceed to create a new API Management service for this exercise" src="image/Figure_11.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">Figure 11.3 – Proceed to create a new API Management service for this exercise</span></p>
<p><span class="koboSpan" id="kobo.150.1">On the next screen, we can proceed to fill in the details of our service and select the following options:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.151.1">Subscription</span></strong><span class="koboSpan" id="kobo.152.1">: The subscription this new service will be provisioned under.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.153.1">Resource group</span></strong><span class="koboSpan" id="kobo.154.1">: The logical group of resources associated with the service being provisioned. </span><span class="koboSpan" id="kobo.154.2">A new one can be created for this exercise.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.155.1">Region</span></strong><span class="koboSpan" id="kobo.156.1">: The best geographical representation of where the bulk of the users of the services will be located.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Resource name</span></strong><span class="koboSpan" id="kobo.158.1">: A unique name for the instance that you will be provisioning. </span><span class="koboSpan" id="kobo.158.2">You will need to modify the name displayed in </span><em class="italic"><span class="koboSpan" id="kobo.159.1">Figure 11.4</span></em><span class="koboSpan" id="kobo.160.1"> to proceed.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.161.1">Organization name</span></strong><span class="koboSpan" id="kobo.162.1">: The name of your organization. </span><span class="koboSpan" id="kobo.162.2">This will be the name associated with ownership of the API service.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Administrator email address</span></strong><span class="koboSpan" id="kobo.164.1">: The email address to be used for all communication and notifications from API Management.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.165.1">Pricing tier</span></strong><span class="koboSpan" id="kobo.166.1">: This determines the level of service uptime that we prefer. </span><span class="koboSpan" id="kobo.166.2">For this instance, we will use the </span><em class="italic"><span class="koboSpan" id="kobo.167.1">Developer</span></em><span class="koboSpan" id="kobo.168.1"> tier, which isn’t for production use.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.169.1">Figure 11.4</span></em><span class="koboSpan" id="kobo.170.1"> shows the various </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.171.1">Azure API Management options:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.172.1"><img alt="Figure 11.4 – Minimum values needed to create the API Management service" src="image/Figure_11.4_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.173.1">Figure 11.4 – Minimum values needed to create the API Management service</span></p>
<p><span class="koboSpan" id="kobo.174.1">After creating the API Management service, we can begin importing our microservices into the management portal. </span><span class="koboSpan" id="kobo.174.2">Now, our API Management service will act as a façade in front of our services, allowing us to control access and transform data as needed. </span><span class="koboSpan" id="kobo.174.3">We can import APIs from any source if their API is discoverable across the internet or network.</span></p>
<p><span class="koboSpan" id="kobo.175.1">The API Management</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.176.1"> service will handle all communications between a client and the target service that maps to the requested endpoint, regardless of the technology used to implement the API.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.177.1">Figure 11.5</span></em><span class="koboSpan" id="kobo.178.1"> shows the APIs added to the Azure API Management service:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.179.1"><img alt="Figure 11.5 – The API Management service allows you to add APIs and map custom routes, that when called, will reroute the request to the mapped resource" src="image/Figure_11.5_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Figure 11.5 – The API Management service allows you to add APIs and map custom routes, that when called, will reroute the request to the mapped resource</span></p>
<p><span class="koboSpan" id="kobo.181.1">In </span><em class="italic"><span class="koboSpan" id="kobo.182.1">Figure 11.5</span></em><span class="koboSpan" id="kobo.183.1">, we can see where we have mapped our appointments and customer APIs to the API Management service and have defined a base URL based on the primary endpoint now available through the service.</span></p>
<p><span class="koboSpan" id="kobo.184.1">In </span><em class="italic"><span class="koboSpan" id="kobo.185.1">Figure 11.6</span></em><span class="koboSpan" id="kobo.186.1">, we can see where we can manage the request types that are allowed, as well as define our policies and transformations for each request type.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.187.1">Figure 11.6</span></em><span class="koboSpan" id="kobo.188.1"> also shows the </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.189.1">various request processing options in the Azure API Management service:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.190.1"><img alt="Figure 11.6 – The API Management service allows you to easily manage the request types that are allowed for each API and define transformation policies for requests and responses" src="image/Figure_11.6_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.191.1">Figure 11.6 – The API Management service allows you to easily manage the request types that are allowed for each API and define transformation policies for requests and responses</span></p>
<p><span class="koboSpan" id="kobo.192.1">Using Azure API Management, we gain many standard API gateway features out of the box and the further benefit of availability and service uptime guarantees when we have production-grade pricing tiers. </span><span class="koboSpan" id="kobo.192.2">If we</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.193.1"> choose not to self-host this application, we can take advantage of its </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Software-as-a-Service</span></strong><span class="koboSpan" id="kobo.195.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.196.1">SaaS</span></strong><span class="koboSpan" id="kobo.197.1">) model, where we have a greatly reduced responsibility to do any infrastructure work related to getting it up and running.</span></p>
<p><span class="koboSpan" id="kobo.198.1">We may end up in a situation where we need to self-host our gateway and API Management is not an option. </span><span class="koboSpan" id="kobo.198.2">In this situation, we can look to provide our own API gateway application. </span><span class="koboSpan" id="kobo.198.3">A great candidate for this implementation is </span><em class="italic"><span class="koboSpan" id="kobo.199.1">Ocelot</span></em><span class="koboSpan" id="kobo.200.1">, which is a lightweight API gateway package that can be installed directly into a standard ASP.NET Core project. </span><span class="koboSpan" id="kobo.200.2">We will discuss this further in the next section.</span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.201.1">Implementing an API gateway using Ocelot</span></h2>
<p><span class="koboSpan" id="kobo.202.1">Ocelot is an open source </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.203.1">API gateway developed on the .NET Core platform. </span><span class="koboSpan" id="kobo.203.2">It is a simple implementation of a gateway that unifies the communication to microservices through abstraction, as we have come to expect from a gateway. </span><span class="koboSpan" id="kobo.203.3">The Ocelot API gateway transforms incoming HTTP requests and forwards them to the appropriate microservice address based on preset configurations.</span></p>
<p><span class="koboSpan" id="kobo.204.1">It is a popular and widely used API gateway technology and can easily be installed into a .NET Core application using the NuGet package manager. </span><span class="koboSpan" id="kobo.204.2">Its configurations can be outlined in JSON format; here, we define </span><em class="italic"><span class="koboSpan" id="kobo.205.1">upstream</span></em><span class="koboSpan" id="kobo.206.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.207.1">downstream</span></em><span class="koboSpan" id="kobo.208.1"> routes. </span><em class="italic"><span class="koboSpan" id="kobo.209.1">Upstream</span></em><span class="koboSpan" id="kobo.210.1"> routes</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.211.1"> refer to the service address that is exposed to the client, while </span><em class="italic"><span class="koboSpan" id="kobo.212.1">downstream</span></em><span class="koboSpan" id="kobo.213.1"> routes are </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.214.1">the real addresses of the mapped microservices. </span><span class="koboSpan" id="kobo.214.2">We can also define the allowed protocols for each upstream service route, allowing robust control over the kind of traffic that we are willing to accept on a route.</span></p>
<p><span class="koboSpan" id="kobo.215.1">Let us set up an Ocelot API gateway application together. </span><span class="koboSpan" id="kobo.215.2">We will use a simple ASP.NET Web API project template and start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">Ocelot</span></strong><span class="koboSpan" id="kobo.217.1"> package via the NuGet package manager:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.218.1">
Install-Package Ocelot</span></pre>
<p><span class="koboSpan" id="kobo.219.1">Now that we have our package installed, we need to begin outlining our routing configurations. </span><span class="koboSpan" id="kobo.219.2">We can create a new configuration file and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">ocelot.json</span></strong><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">In this JSON file, we will outline all </span><em class="italic"><span class="koboSpan" id="kobo.222.1">upstream</span></em><span class="koboSpan" id="kobo.223.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.224.1">downstream</span></em><span class="koboSpan" id="kobo.225.1"> routes. </span><span class="koboSpan" id="kobo.225.2">This configuration will look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
{
     "Routes": [
    {
      "DownstreamPathTemplate": "/api/Patients",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5232
        }
      ],
      "UpstreamPathTemplate": "/Patients",
      "UpstreamHttpMethod": [
        "GET",
        "POST"
      ]
    },
    {
      "DownstreamPathTemplate": "/api/Patients/{id}",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5232
        }
      ],
      "UpstreamPathTemplate": "/Patients/{id}",
      "UpstreamHttpMethod": [
        "GET",
        "PUT"
      ]
    },
    {
      "DownstreamPathTemplate": "/api/Appointments",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5274
        }
      ],
      "UpstreamPathTemplate": "/Appointments",
      "UpstreamHttpMethod": [
        "POST",
        "PUT",
        "GET"
      ]
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": http://localhost:5245""
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.227.1">This configuration file is</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.228.1"> straightforward and once we pick up on the pattern, we can extend it as needed for the rest of our services. </span><span class="koboSpan" id="kobo.228.2">The sections are explained here:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.229.1">Routes</span></strong><span class="koboSpan" id="kobo.230.1">: This is the</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.231.1"> parent section of our JSON configuration, where we begin to define the upstream and downstream configurations.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">DownstreamPathTemplate</span></strong><span class="koboSpan" id="kobo.233.1">: This section</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.234.1"> outlines the address at which the microservice can be found.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.235.1">DownstreamScheme</span></strong><span class="koboSpan" id="kobo.236.1">: This outlines </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.237.1">the protocols that we will use to communicate to</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.238.1"> the microservice being defined.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.239.1">DownstreamHostAndPorts</span></strong><span class="koboSpan" id="kobo.240.1">: The host </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.241.1">address and port are defined in this section.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.242.1">UpstreamPathTemplate</span></strong><span class="koboSpan" id="kobo.243.1">: We outline the path that we expose to the client apps. </span><span class="koboSpan" id="kobo.243.2">By calling this defined route, Ocelot </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.244.1">will automatically reroute the request to the service defined in the </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">DownstreamPathTemplate</span></strong><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">Notice that in the preceding example, we can rename the route if we need to. </span><span class="koboSpan" id="kobo.246.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">Customers</span></strong><span class="koboSpan" id="kobo.248.1"> API endpoint originally found in the downstream API can only be reached via a </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">Patients</span></strong><span class="koboSpan" id="kobo.250.1"> endpoint address.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.251.1">UpstreamHttpMethod</span></strong><span class="koboSpan" id="kobo.252.1">: Here, we </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.253.1">define the methods that we will accept as legitimate requests from a client.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.254.1">GlobalConfiguration</span></strong><span class="koboSpan" id="kobo.255.1">: We outline the </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">BaseUrl</span></strong><span class="koboSpan" id="kobo.257.1"> in the configuration, where all request traffic </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.258.1">should be sent</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.259.1"> through.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.260.1">Now, let us configure our application to use these configurations and use the Ocelot package. </span><span class="koboSpan" id="kobo.260.2">We will start by adding the following lines to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Program.cs</span></strong><span class="koboSpan" id="kobo.262.1"> file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
builder.Configuration.AddJsonFile("ocelot.json", optional:
  false, reloadOnChange: true);
builder.Services.AddOcelot(builder.Configuration);</span></pre>
<p><span class="koboSpan" id="kobo.264.1">These lines add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">ocelot.json</span></strong><span class="koboSpan" id="kobo.266.1"> file to our global configuration at application startup and then register Ocelot as a service. </span><span class="koboSpan" id="kobo.266.2">Then, we need to add the Ocelot middleware, like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
await app.UseOcelot();</span></pre>
<p><span class="koboSpan" id="kobo.268.1">With these few configurations, we can now use the gateway URL as the API URL in our client apps.</span></p>
<p><span class="koboSpan" id="kobo.269.1">Ocelot is well-documented and extendable. </span><span class="koboSpan" id="kobo.269.2">It supports other features, such as the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.270.1">Built-in cache management</span></li>
<li><span class="koboSpan" id="kobo.271.1">A rate limiter</span></li>
<li><span class="koboSpan" id="kobo.272.1">Support for native .NET Core logging integrations</span></li>
<li><span class="koboSpan" id="kobo.273.1">Support </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.274.1">for </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">JSON Web Token</span></strong><span class="koboSpan" id="kobo.276.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.277.1">JWT</span></strong><span class="koboSpan" id="kobo.278.1">) authentication</span></li>
<li><span class="koboSpan" id="kobo.279.1">Retry and circuit breaker policies (using </span><em class="italic"><span class="koboSpan" id="kobo.280.1">Polly</span></em><span class="koboSpan" id="kobo.281.1">)</span></li>
<li><span class="koboSpan" id="kobo.282.1">Aggregating</span></li>
<li><span class="koboSpan" id="kobo.283.1">Pre- and post-downstream request transformations</span></li>
</ul>
<p><span class="koboSpan" id="kobo.284.1">Now that we </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.285.1">have learned how to set up a simple gateway with Ocelot, let us look into extending this functionality. </span><span class="koboSpan" id="kobo.285.2">We will begin by adding cache management.</span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.286.1">Adding cache management</span></h2>
<p><span class="koboSpan" id="kobo.287.1">Caches act as temporary data stores in between requests to a more reliable data store. </span><span class="koboSpan" id="kobo.287.2">This means that a</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.288.1"> cache will temporarily store data based on the last set of data it was given. </span><span class="koboSpan" id="kobo.288.2">Good cache management would suggest that we flush our cache based on an interval and refresh it with a newer version of the data.</span></p>
<p><span class="koboSpan" id="kobo.289.1">Caching comes in handy when we need to reduce the number of trips that are made to the main database, reducing latency and read/write costs that come with database calls. </span><span class="koboSpan" id="kobo.289.2">Ocelot has some support for caching, which is good for solving small caching concerns natively in the gateway application.</span></p>
<p><span class="koboSpan" id="kobo.290.1">This can be added with a fair amount of ease. </span><span class="koboSpan" id="kobo.290.2">We will begin by using NuGet Package Manager to execute the following command:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
Install-Package Ocelot.Cache.CacheManager</span></pre>
<p><span class="koboSpan" id="kobo.292.1">This package gives us the caching extensions that we need to then introduce an extension method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Program.cs</span></strong><span class="koboSpan" id="kobo.294.1"> file. </span><span class="koboSpan" id="kobo.294.2">This extension method looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
builder.Services.AddOcelot()
    .AddCacheManager(x =&gt;
    {
        x.WithDictionaryHandle();
    });</span></pre>
<p><span class="koboSpan" id="kobo.296.1">Finally, we add the following line to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">ocelot.json</span></strong><span class="koboSpan" id="kobo.298.1"> configuration file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
"FileCacheOptions": {
    "TtlSeconds": 20,
    "Region": "SomeRegionName"
  }</span></pre>
<p><span class="koboSpan" id="kobo.300.1">Now that we have</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.301.1"> introduced a configuration to govern how caching should occur in our gateway, we must outline that values should be cached for a maximum of 20 seconds. </span><span class="koboSpan" id="kobo.301.2">This will add native caching support for the downstream services that have been defined. </span><span class="koboSpan" id="kobo.301.3">Once that cache period has expired, requests will be forwarded as expected and then the new response values will be cached once again, for the defined period.</span></p>
<p><span class="koboSpan" id="kobo.302.1">Caching helps to reduce the amount of pressure that we place on a service, but it reasonably only imposes that limit for a short period. </span><span class="koboSpan" id="kobo.302.2">If we extend that period, then we run the risk of returning stale data for too long. </span><span class="koboSpan" id="kobo.302.3">Another layer of protection that we will want to implement is rate limiting. </span><span class="koboSpan" id="kobo.302.4">Let us explore this next.</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.303.1">Adding rate limiting</span></h2>
<p><span class="koboSpan" id="kobo.304.1">Rate limiting helps us to defend our application from the effects of DDoS attacks. </span><span class="koboSpan" id="kobo.304.2">Essentially, we impose rules on </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.305.1">how frequently our service endpoints can be accessed by the same resource. </span><span class="koboSpan" id="kobo.305.2">When the request frequency violates our rules, we reject other incoming requests. </span><span class="koboSpan" id="kobo.305.3">This helps to prevent probable service performance degradation. </span><span class="koboSpan" id="kobo.305.4">Our service will not be attempting to fulfill all requests, especially those that may look like attacks.</span></p>
<p><span class="koboSpan" id="kobo.306.1">Rate limiting works by recording the IP address of the originating request. </span><span class="koboSpan" id="kobo.306.2">For all other requests from the same IP address, we evaluate if it is legal and within the set constraints that govern how often a request should come from the same sender. </span><span class="koboSpan" id="kobo.306.3">When a rule violation is detected, we send a failure response and do not forward the request in the service.</span></p>
<p><span class="koboSpan" id="kobo.307.1">Ocelot allows us to configure rate limiting for the configured downstream services. </span><span class="koboSpan" id="kobo.307.2">This is good because it allows us to globally manage these rules and we do not need to implement these</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.308.1"> rules in each service.</span></p>
<p><span class="koboSpan" id="kobo.309.1">First, let us modify our code to implement rate limiting for a particular downstream service. </span><span class="koboSpan" id="kobo.309.2">We can add the following code to the service’s configuration file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
{
      "DownstreamPathTemplate": "/api/Patients",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5232
        }
      ],
      "UpstreamPathTemplate": "/Patients",
      "UpstreamHttpMethod": [
        "GET",
        "POST"
      ],
      "RateLimitOptions": {
        "ClientWhitelist": [],
        "EnableRateLimiting": true,
        "Period": "5s",
        "PeriodTimespan": 1,
        "Limit": 1
      }
    },</span></pre>
<p><span class="koboSpan" id="kobo.311.1">We have introduced a new section called </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">RateLimitingOptions</span></strong><span class="koboSpan" id="kobo.313.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">ocelot.json</span></strong><span class="koboSpan" id="kobo.315.1"> file. </span><span class="koboSpan" id="kobo.315.2">More specifically, we have added this new configuration to our patient’s downstream service configuration. </span><span class="koboSpan" id="kobo.315.3">This will now impose the following restrictions on how this</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.316.1"> downstream service can be accessed:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.317.1">ClientWhiteList</span></strong><span class="koboSpan" id="kobo.318.1">: List of allowed clients that are not subjected to the rate limiting restrictions.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.319.1">EnableRateLimiting</span></strong><span class="koboSpan" id="kobo.320.1">: A flag that indicates whether the rate-limiting restrictions should be enforced or not.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.321.1">Period</span></strong><span class="koboSpan" id="kobo.322.1">: This value specifies the amount of time that we use to determine if a client is making a request that violates the limiting options. </span><span class="koboSpan" id="kobo.322.2">We can use the following:</span><ul><li><span class="koboSpan" id="kobo.323.1">s for seconds</span></li><li><span class="koboSpan" id="kobo.324.1">m for minutes</span></li><li><span class="koboSpan" id="kobo.325.1">h for hours</span></li><li><span class="koboSpan" id="kobo.326.1">d for days</span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.327.1">The pattern is fairly easy to follow. </span><span class="koboSpan" id="kobo.327.2">In our example, we have a 5-second limit on requests.</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.328.1">PeriodTimeSpan</span></strong><span class="koboSpan" id="kobo.329.1">: This is like a cooldown period. </span><span class="koboSpan" id="kobo.329.2">For this period, subsequent requests from the client that violated the limiting restrictions will be rejected and the clock will restart. </span><span class="koboSpan" id="kobo.329.3">Once this period has elapsed, the client can continue making requests.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.330.1">Limit</span></strong><span class="koboSpan" id="kobo.331.1">: The number of requests that a client is allowed to make during the period. </span><span class="koboSpan" id="kobo.331.2">Here, we are defining that only one request should come in from the client every 5 seconds.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.332.1">Then, we can define global values that govern how the gateway will handle rate limiting. </span><span class="koboSpan" id="kobo.332.2">We can add a similar </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">RateLimitingOptions</span></strong><span class="koboSpan" id="kobo.334.1"> section to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">GlobalConfiguration</span></strong><span class="koboSpan" id="kobo.336.1"> section:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
"GlobalConfiguration": {
    "BaseUrl": http://localhost:5245"",
    "RateLimitOptions": {
      "DisableRateLimitHeaders": false,
      "QuotaExceededMessage": "Too many requests!!!",
      "HttpStatusCode": 429,
      "ClientIdHeader": "ClientId"
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.338.1">Now, we have some new options, which are as follows:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.339.1">DisableRateLimitHeaders</span></strong><span class="koboSpan" id="kobo.340.1">: A flag that determines whether we disable or enable rate-limiting headers. </span><span class="koboSpan" id="kobo.340.2">These</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.341.1"> header values are generally as follows:</span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.342.1">X-Rate-Limit</span></strong><span class="koboSpan" id="kobo.343.1">: Maximum number of requests available within the timespan</span></li><li><strong class="bold"><span class="koboSpan" id="kobo.344.1">Retry-After</span></strong><span class="koboSpan" id="kobo.345.1">: Indicates how long the client should wait before making a follow-up request</span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.346.1">QuotaExceededMessage</span></strong><span class="koboSpan" id="kobo.347.1">: Allows us to define a custom message to send to the client that has violated the limiting rules.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.348.1">HttpStatusCode</span></strong><span class="koboSpan" id="kobo.349.1">: This outlines the response code to be sent when the rules are violated. </span><span class="koboSpan" id="kobo.349.2">429TooManyRequests is the standard response for this situation.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.350.1">ClientIdHeader</span></strong><span class="koboSpan" id="kobo.351.1">: Specifies the header that should be used to identify the client making the request.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.352.1">With these minor changes, we have enforced rate limiting on all requests coming into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">/patients</span></strong><span class="koboSpan" id="kobo.354.1"> endpoint. </span><span class="koboSpan" id="kobo.354.2">We will respond with a </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">429TooManyRequests</span></strong><span class="koboSpan" id="kobo.356.1"> HTTP response if two or more requests come in within 5 seconds, from the same client address.</span></p>
<p><span class="koboSpan" id="kobo.357.1">Another consideration we might have when using Ocelot is to aggregate our responses. </span><span class="koboSpan" id="kobo.357.2">This allows us to string multiple calls along and reduce the client’s need to orchestrate these calls. </span><span class="koboSpan" id="kobo.357.3">We’ll learn how</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.358.1"> to add this next.</span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.359.1">Adding response aggregation</span></h2>
<p><span class="koboSpan" id="kobo.360.1">Response </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.361.1">aggregation is a method used for merging responses from multiple downstream services and sending one response accordingly. </span><span class="koboSpan" id="kobo.361.2">Essentially, an API gateway can achieve this by accepting a single request from a client and then making distributed parallel requests to several downstream services. </span><span class="koboSpan" id="kobo.361.3">Once all the responses are in from the downstream services, it will merge the data into a single object and return it to the client.</span></p>
<p><span class="koboSpan" id="kobo.362.1">Several benefits come with this approach. </span><span class="koboSpan" id="kobo.362.2">The most prevalent one is that we can reduce the number of requests that the client needs to make to get data from several services. </span><span class="koboSpan" id="kobo.362.3">The API gateway will handle that orchestration automatically. </span><span class="koboSpan" id="kobo.362.4">The client also only needs to know one schema. </span><span class="koboSpan" id="kobo.362.5">So, several potentially complex requests can be merged into a single request body, which will reduce the number of schemas that the client needs to track. </span><span class="koboSpan" id="kobo.362.6">This approach will also speed up the response times involved with calling several services. </span><span class="koboSpan" id="kobo.362.7">Since the calls will be made in parallel, we do not have to wait the entire period that would be required when making service calls one after the other.</span></p>
<p><span class="koboSpan" id="kobo.363.1">Ocelot allows us to configure aggregate calls with a fair amount of ease. </span><span class="koboSpan" id="kobo.363.2">We will decorate our downstream service configurations with keys that act as a point of reference for our aggregate configuration. </span><span class="koboSpan" id="kobo.363.3">If we want to aggregate a call that should return a patient and all the appointments that they have made, we would need to make the following modifications:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.364.1">
    {
      "DownstreamPathTemplate": "/api/Patients/{id}",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5232
        }
      ],
      "UpstreamPathTemplate": "/Patients/{id}",
      "UpstreamHttpMethod": [
        "GET",
        "PUT"
      ],
      "Key": "get-patient"
    }</span></pre>
<p><span class="koboSpan" id="kobo.365.1">We start by adding a new key to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">api/patients/{id}</span></strong><span class="koboSpan" id="kobo.367.1"> downstream service configuration. </span><span class="koboSpan" id="kobo.367.2">This key acts as an alias, which we will use later. </span><span class="koboSpan" id="kobo.367.3">We will also add a new downstream service </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.368.1">configuration for appointments and a new endpoint. </span><span class="koboSpan" id="kobo.368.2">The configuration looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
    {
      "DownstreamPathTemplate":
          "/api/user/Appointments/{id}",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5274
        }
      ],
      "UpstreamPathTemplate": "/Appointments/user/{id}",
      "UpstreamHttpMethod": [
        "GET"
      ],
      "Key": "get-patient-appointments"
    }</span></pre>
<p><span class="koboSpan" id="kobo.370.1">The matching endpoint that will be</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.371.1"> implemented in the appointments services looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
// GET: api/Appointments/user/{id}
        [HttpGet("user/{id}")]
        public async Task&lt;ActionResult&lt;List&lt;Appointment&gt;&gt;&gt;
            GetAppointmentsByUser(Guid id)
        {
            var appointments = await _context.Appointments
                .Where(q =&gt; q.PatientId == id)
                .ToListAsync();
            return appointments;
        }</span></pre>
<p><span class="koboSpan" id="kobo.373.1">Now that we have configured the new endpoints and modified the downstream service configurations, we need to add a new configuration for our aggregate orchestration:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
"Aggregates": [
    {
      "RouteKeys": [
        "get-patient",
        "get-patient-appointments"
      ],
      "UpstreamPathTemplate": "/get-patient-details/{id}"
    }
  ],</span></pre>
<p><span class="koboSpan" id="kobo.375.1">Now, we can use the endpoint as defined by the aggregate configuration and execute a single call that will return a patient’s record alongside all the appointments that they have made. </span><span class="koboSpan" id="kobo.375.2">This information comes from multiple services almost simultaneously. </span><span class="koboSpan" id="kobo.375.3">Our client no longer needs to make multiple calls to get this information.</span></p>
<p><span class="koboSpan" id="kobo.376.1">This simple and powerful technique helps us to better orchestrate API calls and present exactly the information that a client app needs. </span><span class="koboSpan" id="kobo.376.2">It promotes a more behavior-driven workflow when retrieving</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.377.1"> data and reduces the development overhead that each client application will need.</span></p>
<p><span class="koboSpan" id="kobo.378.1">Now that we have seen how we can implement API gateways using either our API project or Azure API Management, we have overcome a major hurdle in our microservices application. </span><span class="koboSpan" id="kobo.378.2">We no longer need to build client apps that need to keep track of all the addresses of our microservices.</span></p>
<p><span class="koboSpan" id="kobo.379.1">This now raises another cause for concern. </span><span class="koboSpan" id="kobo.379.2">Unfortunately, different devices might have different requirements for how they interact with our services. </span><span class="koboSpan" id="kobo.379.3">Mobile clients might need special security and caching considerations that web applications do not. </span><span class="koboSpan" id="kobo.379.4">This adds more complication to how we keep track of configurations in the central gateway, relative to the devices hosting the client apps.</span></p>
<p><span class="koboSpan" id="kobo.380.1">These considerations lead us down the path of implementing a gateway per type of service client. </span><span class="koboSpan" id="kobo.380.2">This method of implementation is called the </span><em class="italic"><span class="koboSpan" id="kobo.381.1">Backend for Frontend pattern</span></em><span class="koboSpan" id="kobo.382.1">, which we will discuss next.</span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.383.1">Backend for Frontend pattern</span></h1>
<p><span class="koboSpan" id="kobo.384.1">While API </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.385.1">gateways solve several problems, it is not a one size fits all solution. </span><span class="koboSpan" id="kobo.385.2">We still end up contending with the possibility of catering to multiple device types and, by extension, client applications. </span><span class="koboSpan" id="kobo.385.3">For example, we may need to use additional compression and caching rules with data </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.386.1">being consumed by a mobile client, whereas a website might not need many special considerations. </span><span class="koboSpan" id="kobo.386.2">The more devices become capable of interacting with APIs, the more we need to ensure that we can support integrations.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.387.1">Figure 11.7</span></em><span class="koboSpan" id="kobo.388.1"> shows multiple clients with one gateway:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.389.1"><img alt="Figure 11.7 – All client devices access the same gateway, leading to inefficient behavior for some devices" src="image/Figure_11.7_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">Figure 11.7 – All client devices access the same gateway, leading to inefficient behavior for some devices</span></p>
<p><span class="koboSpan" id="kobo.391.1">All these considerations make a good case for the </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">Backend for Frontend</span></strong><span class="koboSpan" id="kobo.393.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.394.1">BFF</span></strong><span class="koboSpan" id="kobo.395.1">) pattern. </span><span class="koboSpan" id="kobo.395.2">This pattern allows us to supply a service-per-device API approach. </span><span class="koboSpan" id="kobo.395.3">The BFF pattern allows us to </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.396.1">acutely define our API functionality based on the experience that we hope for a user to have on a particular user interface. </span><span class="koboSpan" id="kobo.396.2">This makes it easier for us to develop and maintain and adjust our API based on the client’s requirements and simplifies the process of delivering functionality across multiple clients.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.397.1">Figure 11.8</span></em><span class="koboSpan" id="kobo.398.1"> shows a BFF setup:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.399.1"><img alt="Figure 11.8 – Each client app has an endpoint to a gateway that is specially configured to optimize API traffic for the target device type" src="image/Figure_11.8_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.400.1">Figure 11.8 – Each client app has an endpoint to a gateway that is specially configured to optimize API traffic for the target device type</span></p>
<p><span class="koboSpan" id="kobo.401.1">Now, we can optimize each gateway instance to handle traffic for specific devices in the most efficient way possible. </span><span class="koboSpan" id="kobo.401.2">For instance, our mobile applications might require additional caching or </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.402.1">compression settings and we may need to rewrite request headers. </span><span class="koboSpan" id="kobo.402.2">We might even define additional header information to be provided from our mobile devices as we may need to track the device type and location. </span><span class="koboSpan" id="kobo.402.3">In a nutshell, we need to ensure that we are catering to each possible device as much as possible.</span></p>
<p><span class="koboSpan" id="kobo.403.1">Azure API Management has features that allow us to interrogate the incoming request and redirect or modify the request before forwarding it or modifying the response before it is sent to the requesting client. </span><span class="koboSpan" id="kobo.403.2">By defining these policies, we can implement a BFF-like mechanism where policies are defined to look for the type of device or, generally, the source of the request and modify it as optimally as possible for forwarding or returning.</span></p>
<p><span class="koboSpan" id="kobo.404.1">Ocelot might require a bit more potentially confusing logic to support policies of this nature. </span><span class="koboSpan" id="kobo.404.2">The more recommended way to implement this pattern using Ocelot is to use multiple implementations of Ocelot. </span><span class="koboSpan" id="kobo.404.3">In this implementation style, we would create multiple Ocelot projects, each with its specific purpose, such as mobile, web, and public gateways, and add each configuration for the allowed up and downstream services. </span><span class="koboSpan" id="kobo.404.4">We would also be able to specify the rate-limiting and caching options per implementation.</span></p>
<p><span class="koboSpan" id="kobo.405.1">Let us review how this </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.406.1">pattern can be implemented using Ocelot.</span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.407.1">BFF pattern using Ocelot</span></h2>
<p><span class="koboSpan" id="kobo.408.1">We have already </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.409.1">seen that we can configure Ocelot to be our API gateway. </span><span class="koboSpan" id="kobo.409.2">A simple enough extension to what we have done is to create </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.410.1">additional projects and configure them similarly. </span><span class="koboSpan" id="kobo.410.2">We can retain the gateway that we have already and use it exclusively for third-party application access. </span><span class="koboSpan" id="kobo.410.3">With the up and downstream services we have defined, we can restrict third parties to only be able to access those endpoints.</span></p>
<p><span class="koboSpan" id="kobo.411.1">We can then create a new Ocelot project and use it specifically for our web client. </span><span class="koboSpan" id="kobo.411.2">Let us say that we do not want rate limiting on the web client and can decrease the cache time to 10 seconds instead of 20. </span><span class="koboSpan" id="kobo.411.3">Given that this is our web application, we can lift most of these restrictions and allow for less strict interactions.</span></p>
<p><span class="koboSpan" id="kobo.412.1">This configuration file will simply look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
{
  "Routes": [
    {
      "DownstreamPathTemplate": "/api/Patients",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5232
        }
      ],
      "UpstreamPathTemplate": "/web/Patients",
      "UpstreamHttpMethod": [
        "GET",
        "POST"
      ]
    },
   // omitted for brevity   ],
  "FileCacheOptions": {
    "TtlSeconds": 10,
    "Region": "SomeRegionName"
  },
  "GlobalConfiguration": {
    "BaseUrl": http://localhost:5245""
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.414.1">This looks similar to what we have already done with the previous gateway, but note that now, we have the unique opportunity to define custom paths that match with the web entry point that we are implementing while adding/removing configurations as we deem necessary for the web </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.415.1">client. </span><span class="koboSpan" id="kobo.415.2">Also, notice that it will broadcast from a separate address, which will prevent any reference </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.416.1">overlaps between the clients.</span></p>
<p><span class="koboSpan" id="kobo.417.1">We may also want to implement a mobile client that has fewer restrictions similar to what we have outlined in the web gateway, but we may also want to customize the aggregation operation. </span><span class="koboSpan" id="kobo.417.2">So, for our mobile client gateway, we can add the following aggregator definition to the Ocelot configuration:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
  "Aggregates": [
    {
      "RouteKeys": [
        "get-patient",
        "get-patient-appointments"
      ],
      "UpstreamPathTemplate": "/get-patient-details/{id}",
      "Aggregator": "PatientAppointmentAggregator"
    }
  ],</span></pre>
<p><span class="koboSpan" id="kobo.419.1"> In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Program.cs</span></strong><span class="koboSpan" id="kobo.421.1"> file, we add the following line to register the aggregator:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
builder.Services.AddOcelot().AddSingletonDefinedAggregator&lt;
  PatientAppointmentAggregator&gt;()</span></pre>
<p><span class="koboSpan" id="kobo.423.1">Now, we need to define a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">PatientAppointmentAggregator</span></strong><span class="koboSpan" id="kobo.425.1">, which will implement our custom aggregation logic. </span><span class="koboSpan" id="kobo.425.2">This custom aggregator will intercept the responses from the</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.426.1"> downstream server and allow </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.427.1">us to interrogate and modify what is returned:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">
public class PatientAppointmentAggregator :
  IDefinedAggregator
{
    public async Task&lt;DownstreamResponse&gt;
        Aggregate(List&lt;HttpContext&gt; responses)
    {
        var patient = await responses[0].Items.Downstream
          Response().Content.ReadAsStringAsync();
        var appointments = await responses[1]
          .Items.DownstreamResponse()
            .Content.ReadAsStringAsync();
        var contentBuilder = new StringBuilder();
        contentBuilder.Append(patient);
        contentBuilder.Append(appointments);
        var response = new StringContent
          (contentBuilder.ToString())
        {
            Headers = { ContentType = new
              MediaTypeHeaderValue("application/json") }
        };
        return new DownstreamResponse(response,
          HttpStatusCode.OK, new List&lt;KeyValuePair&lt;string,
            IEnumerable&lt;string&gt;&gt;&gt;(), "OK");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.429.1">This aggregator code receives a list of responses, where each entry represents the response from the downstream services in the order they were defined in the configuration. </span><span class="koboSpan" id="kobo.429.2">We then extract</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.430.1"> the response as a string and append it in one string value. </span><span class="koboSpan" id="kobo.430.2">We also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">ContentType</span></strong><span class="koboSpan" id="kobo.432.1"> header to the ultimate response, which is sent with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">200OK</span></strong><span class="koboSpan" id="kobo.434.1"> HTTP response. </span><span class="koboSpan" id="kobo.434.2">This is a simple </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.435.1">example, but it shows how easy it is for us to customize the default aggregation behavior and, by extension, for a specific BFF gateway.</span></p>
<p><span class="koboSpan" id="kobo.436.1">The BFF pattern allows us to further diversify our development teams and their efforts in maintaining the various microservices. </span><span class="koboSpan" id="kobo.436.2">Teams can now manage their gateways and implement gateway methods and features that are unique to the devices they are catering to.</span></p>
<p><span class="koboSpan" id="kobo.437.1">Now that we understand </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.438.1">API gateways, the BFF pattern, and how we can implement either one of these using industry-standard software, let us review</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.439.1"> what we have learned in this chapter.</span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.440.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.441.1">This chapter has reviewed the need for an API gateway. </span><span class="koboSpan" id="kobo.441.2">When building a monolith, we have a single point of entry to our application’s supporting API and this single point of entry can be used for any type of client.</span></p>
<p><span class="koboSpan" id="kobo.442.1">The downside to this is that we might end up with an API that becomes increasingly difficult to improve on and scale as the demands change. </span><span class="koboSpan" id="kobo.442.2">We also need to consider the fact that different devices have different needs from the API in terms of caching, compression, and authentication to name a few.</span></p>
<p><span class="koboSpan" id="kobo.443.1">We then attempt to diversify our application’s capabilities into multiple services or microservices and then implement only what is needed per service. </span><span class="koboSpan" id="kobo.443.2">This approach simplifies each service’s code base while complicating the code base of the client applications. </span><span class="koboSpan" id="kobo.443.3">Where there was one service endpoint, we now have several to keep track of.</span></p>
<p><span class="koboSpan" id="kobo.444.1">API gateways will sit on top of all the microservices and expose a single point of entry and allow us to implement several instances, which can cater to the direct needs of the client applications that will use them. </span><span class="koboSpan" id="kobo.444.2">This adjustment is called BFF, and it allows us to curate backend services specifically for the client applications that need them.</span></p>
<p><span class="koboSpan" id="kobo.445.1">The major downside here is that we have reintroduced a single point of failure by providing the gateway layer, which can introduce potential performance issues. </span><span class="koboSpan" id="kobo.445.2">The goal, however, is to reduce the need for our client apps to have intimate knowledge of the complex web of services that they need to interact with, and this layer of abstraction also helps us to maintain our services with less effect on the client applications.</span></p>
<p><span class="koboSpan" id="kobo.446.1">We also learned that when attempting to add the BFF pattern, we introduce the need for more services and more code to maintain. </span><span class="koboSpan" id="kobo.446.2">Ideally, we would like to have a single implementation that can be provisioned multiple times, all with their specific configurations. </span><span class="koboSpan" id="kobo.446.3">This is where technology such as Docker will help, but we will review that later in this book.</span></p>
<p><span class="koboSpan" id="kobo.447.1">Now that we have seen the pros and cons of the API gateway pattern, we need to explore security for our APIs. </span><span class="koboSpan" id="kobo.447.2">In the next chapter, we will explore API security using bearer tokens.</span></p>
</div>
</body></html>