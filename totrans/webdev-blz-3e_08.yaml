- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to add **authentication** and **authorization**
    to our blog because we don’t want just anyone to be able to create or edit blog
    posts.
  prefs: []
  type: TYPE_NORMAL
- en: Covering authentication and authorization could take a whole book, so we will
    keep things simple here. This chapter aims to get the built-in authentication
    and authorization functionalities working, building on the already existing functionality
    that’s built into ASP.NET. That means that there is not a lot of Blazor magic
    involved here; many resources already exist that we can take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every system today has some way to log in, whether it is an admin interface
    (like ours) or a member login portal. There are many different login providers,
    such as Google, Twitter, and Microsoft. We can use all of these providers since
    we will just be building on existing architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Some sites might already have a database for storing login credentials, but
    for our blog, we will use a service called Auth0 to manage our users. It is a
    very powerful way to add many different social providers (if we want to), and
    we don’t have to manage the users ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: We can check the option to add authentication when creating our project. The
    authentication works differently when it comes to Blazor Server, Blazor WebAssembly,
    and the API, which we will look at in more detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Blazor Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Blazor WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have followed the previous chapters or use the `Chapter07` folder
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s end result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of built-in functionalities when it comes to authentication.
    The easiest way to add authentication is to select an authentication option when
    creating a project.
  prefs: []
  type: TYPE_NORMAL
- en: We need to implement authentication separately for the Blazor Server project
    and the Blazor WebAssembly project because they work differently.
  prefs: []
  type: TYPE_NORMAL
- en: But there are still things we can share between these two projects. First, we
    need to set up Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Auth0** is a service that can help us with handling our users. There are
    many different services like this, but Auth0 is a good fit for us. We can connect
    one or more social connectors, which will allow our users to log in with Facebook,
    Twitter, Twitch, or whatever we add to our site.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though all of this can be achieved by writing code ourselves, integration
    like this is a great way to add authentication quickly and also get a very powerful
    solution. Also, authentication is complex, so don’t write this unless you are
    sure of what you are doing. Auth0 is free for up to 7,000 users (which our blog
    probably won’t reach, especially not the admin interface).
  prefs: []
  type: TYPE_NORMAL
- en: 'It also has great functionality to add data to our users that we have access
    to. We will do that later in the chapter when we add roles to our users. You’ll
    need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Head over to [https://auth0.com](https://auth0.com) and create an account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create Application** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it’s time to name our application. Use `MyBlog`, for example. Then, it’s
    time to select what kind of application type we are using. Is it a native app?
    Is it a **single-page web application**, **regular web application**, or **machine-to-machine
    application**?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This depends on what hosting model we are going to run.
  prefs: []
  type: TYPE_NORMAL
- en: The beautiful thing with how we have the project set up right now is that the
    server is going to handle all the authentication and hand that over to WebAssembly
    (if we have a component that is running in InteractiveAuto or InteractiveWebAssembly).
    But it won’t limit the functionality, only what we need to configure when setting
    up our application.
  prefs: []
  type: TYPE_NORMAL
- en: If we intend to only run as Blazor Server (InteractiveServer), we should use
    a regular web application. But we might want to change to running everything in
    InteractiveWebAssembly, so let’s not limit ourselves here.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Single Page Application**, that way we get the option to use our authentication
    in any hosting model.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will choose what technology we are using for our project. We have Apache,
    .NET, Django, Go, and many other choices, but we don’t have a choice for Blazor
    specifically, at least not at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Just skip this and click the **Setting** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will set up our application. There are a couple of values we need to
    save and use later. You need to make sure that you write down the `Domain`, `Client
    ID`, and `Client Secret`, as we will use those in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: If we scroll down, we can change the logo, but we will skip that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave `Application Login URI` empty. Starting with .NET 6, the port numbers
    are random, so make sure you add your application’s port number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Allowed callback URLs`: `https://localhost:PORTNUMBER/callback`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Allowed logout URLs`: `https://localhost:PORTNUMBER/`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Allowed callback URLs are the URLs `Auth0` will make a call to after the user
    authentication and allowed logout URLs are where the user should be redirected
    after logging out.
  prefs: []
  type: TYPE_NORMAL
- en: Now, press **Save Changes** at the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our Blazor app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are done with configuring Auth0\. Next, we will configure our Blazor application.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to store secrets in .NET (a file that is not checked in,
    Azure Key Vault, etc.). You can use the one that you are most familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: We will keep it very simple and store secrets in our `appsettings.json`. Make
    sure to remember to exclude the file when you check in. You don’t check the secrets
    in source control. You can right-click on the file and select **Git**, **Ignore
    and Untrack Item**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure our Blazor project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `BlazorWebApp.Client` project, in the root, add a new class called `UserInfo.cs`,
    and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is taken from the Blazor template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `BlazorWebApp` project, open `appsettings.json` and add the following
    code to the root of the existing app settings object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the values we made a note of in the previous section. Replace the
    values with our own values from `Auth0`.
  prefs: []
  type: TYPE_NORMAL
- en: Since our site is an ASP.NET site with some added Blazor functionality, this
    means we can use a NuGet package to get some of the functionality out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, add a reference to the `Auth0.AspNetCore.Authentication
    NuGet` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the root of the project, create a new class named `PersistingServerAuthenticationStateProvider.cs`,
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I have taken this file from the Blazor template (when we choose to add authentication
    right away). I added roles to it so if `Auth0` delivers any roles, they will be
    stored in the state as well. Right now, `Auth0` won’t give us any roles, so we
    will get back to roles in a bit. What is happening is when we log in, it will
    save the logged-in user in the `PersistentComponentState` so that we can easily
    transfer the user over to WebAssembly. The server will render the data on the
    DOM, and WebAssembly will then pick that up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Program.cs` and add the following at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code just before `WebApplication app = builder.Build();`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In previous versions of Blazor, we had to first make sure that when our components
    asked for `AuthenticationStateProvider`, we sent back an instance of our `PersistingServerAuthenticationStateProvider`.
    We also add a call to `AddCascadingAuthenticationState`, which will make sure
    to always send an `AuthenticationState` to all our components regardless of hosting
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, add the following code just after `app.UseAntiforgery();`. This code
    will allow us to secure our site:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add the following code just before `app.Run()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When our site redirects to `authentication/login`, the Minimal API endpoint
    will kick off the login functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a similar functionality for logging out. Add the following code
    below the previous endpoint from *Step 7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It needs to sign out twice, once for the `Auth0` authentication scheme and once
    for the cookie authentication scheme. The configuration is all set. Now, we need
    something to secure.
  prefs: []
  type: TYPE_NORMAL
- en: Securing our Blazor app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor uses `App.razor` for routing. To enable securing Blazor, we need to add
    a couple of components in the app component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add `CascadingAuthenticationState`, which will send the authentication
    state to all the components that are listening for it. We also need to change
    the route view to `AuthorizeRouteView`, which can have different views depending
    on whether or not you are authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `BlazorWebApp` project, open `Components/_Imports.razor` and add the
    namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Components/Routes.razor` component and replace everything inside
    the `Router` component with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In previous versions of Blazor, we had to surround the code with `<CascadingAuthenticationState>`,
    but with .NET 8, that is handled automatically by adding the call to `AddCascadingAuthenticationState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, only two things remain: a page that we can secure and a login link display.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Components` folder, add a new Razor component called `LoginStatus.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`LoginStatus` is a component that will show a login link if we are not authenticated
    and a logout link if we are authenticated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Components/Layout/MainLayout.razor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the about link with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, our layout page will show us whether or not we’re logged in and give us
    the opportunity to log in or log out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SharedComponents` and the `BlazorWebApp.Client` project, in the `_Imports`
    file of each project, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `authorize` attribute to the component we wish to secure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the following components in the `SharedComponents` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Pages/Admin/BlogPostEdit.razor`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pages/Admin/BlogPostList.razor`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pages/Admin/CategoryList.razor`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pages/Admin/TagList.razor (in the BlazorWebApp.Client project)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In each of the preceding components, add the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is all it takes, some configuration, and then we are all set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start our `BlazorWebApp` and see if you can access the `/admin/blogposts`
    page (spoiler: you shouldn’t be able to); log in (create a user) and see if you
    can access the page now.'
  prefs: []
  type: TYPE_NORMAL
- en: Our admin interface is secured.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will secure the Blazor WebAssembly version of our blog
    and the API.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Blazor WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous editions of this book, we built two versions of the blog, one
    for Blazor Server and one for Blazor WebAssembly. In this edition, the whole point
    is that we don’t have to choose one over the other. As previously mentioned, there
    are two projects, `BlazorWebApp` and `BlazorWebApp.Client`. In the client project,
    we add all the components we want to be able to run as WebAssembly. Here is the
    really cool part. We have our `TagList` component in the client project. If we
    are running it as InteractiveAuto, it will first render on the server using SignalR
    using the configuration found in the `BlazorWebApp` project. But the next time
    the site runs, it will load the WebAssembly version and use the configuration
    in the `BlazorWebApp.Client` project. So, the same component can use a different
    dependency injection. In one case, it will use direct data access, and in the
    other, it will use the API client we created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to be able to access our API, we need to set up `HttpClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to get authentication information from the server. WebAssembly
    doesn’t really log in; it gets the information from the server and uses the authentication
    cookie for additional calls to the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the server project, we added a `PersistingServerAuthenticationStateProvider`
    to store information about the logged-in user. On the client, we need to get that
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp.Client` project, add a new class in the root called `PersistentAuthenticationStateProvider.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is also taken from the Blazor template (with authentication). Only minor
    modifications appear here, like adding roles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `BlazorWebApp.Client` project, in `Program.cs`, add the following lines
    just above `builder.Build().RunAsync()`;:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will enable authentication, add cascading `authentication state` to our
    components, and get the logged-in user from the `Persistent Component State`.
    The name of the `HttpClient` is “`Api"`; this is the name we used in *Chapter
    7*, *Creating an API*.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to set up dependency injection so that when we ask for an `IBlogAPI`,
    we will get the `BlogApiWebClient` that we created in *Chapter 7*, *Creating an
    API*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add the following code below the `builder.Services.AddSingleton<AuthenticationStateProvider,
    PersistentAuthenticationStateProvider>();` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when we ask for an `IBlogApi`, we will get the API web client that accesses
    the data through an API. The really cool thing here is that, depending on whether
    the component is rendered on the server (Static, InteractiveServer), the client
    (InteractiveWebAssembly), or a combination (InteractiveAuto), it will choose the
    right client for that scenario. We have the ability to choose the one that is
    best suited.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to add the required namespaces as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, everything is prepared for us to secure when running in WebAssembly mode.
  prefs: []
  type: TYPE_NORMAL
- en: This sample is about securing WebAssembly when running with an ASP.NET backend.
    In *Chapter 16*, *Going Deeper into WebAssembly*, we will take a look at how to
    secure a Blazor WebAssembly app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp.Client` project, open the `Pages/Admin/TagList.razor`.
    We have been running our component with the InteractiveServer render mode up to
    this point. Now, let’s change that and run it as InteractiveWebAssembly instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `@rendermode InteractiveServer` to `@rendermode InteractiveWebAssembly`.
    That’s it! Now, our component will first render on the server (since we are running
    server pre-rendering), and then WebAssembly will take over and render the component
    again. It will pick up the authentication information stored in the component
    state and use our web API to retrieve the data from our API. This is because the
    WebAssembly application is configured to use `BlogApiWebClient` when we ask for
    an instance of `IBlogApi`. So, the same component is first prerendered on the
    server using direct data access, then again using the web API. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the project, navigate to `/Admin/Tags`, and try to edit some tags.
    This component is now running on WebAssembly. You can try to change it to `@rendermode
    InteractiveAuto`. To see the behavior, this will first hook up SignalR and then,
    on the next load, switch to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: But what if different users have different permissions?
  prefs: []
  type: TYPE_NORMAL
- en: That is where roles come in.
  prefs: []
  type: TYPE_NORMAL
- en: Adding roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor Server and Blazor WebAssembly handle roles a bit differently; it’s nothing
    major, but we need to do different implementations. In this chapter, we will take
    a look at implementing it for our current project (per component) and return to
    roles in *Chapter 16*, *Going Deeper into WebAssembly*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Auth0 by adding roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by adding roles in Auth0:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to `Auth0`, navigate to **User Management** | **Roles**, and click **Create
    Role**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name `Administrator` and the description `Can do anything` and press
    **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Users** tab, click **Add Users**, search for your user, and then
    click **Assign**. You can also manage roles from the **Users** menu on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, roles won’t be sent to the client, so we need to enrich the data
    to include roles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do that by adding an action.
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Actions**, and then **Flows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flows are a way to execute code in a particular flow.
  prefs: []
  type: TYPE_NORMAL
- en: We want `Auth0` to add our roles when we log in.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Login**, and there we will see the flow; in our case, we don’t have
    anything yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right-hand side, click **Custom** and the plus sign. As a small pop-up
    menu appears, select **Build from scratch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the action `Add Roles`, leave **Trigger**and **Runtime** as is, and press
    **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will see a window where we can write our action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace all the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click **Deploy** and then **Back to flow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Custom** again, and we will see our newly created action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Add Roles** action to the arrow between **Start** and **Complete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have an action that will add the roles to our login token.
  prefs: []
  type: TYPE_NORMAL
- en: Our user is now an administrator. It’s worth noting that roles are a paid feature
    in Auth0 and will only be free during the trial.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s set up Blazor to use this new role.
  prefs: []
  type: TYPE_NORMAL
- en: Adding roles to Blazor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are using the Auth0 library, the setup is almost done for Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify a component to show whether the user is an administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Components` project, open `Shared/NavMenu.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the component, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run our BlazorWebApp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we log in, we should be able to see text to the left saying **Hi Admin!**
    in black text on top of dark blue, so it might not be very visible. We will take
    care of this in *Chapter 9*, *Sharing Code and Resources*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to add authentication to our existing site.
    It is easier to add authentication when creating a project. Still, now we have
    a better understanding of what is going on under the hood and how to handle adding
    an external source for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we have shared components between the different hosting
    models.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at sharing even more things, like static files
    and CSS, and try to make everything look nice.
  prefs: []
  type: TYPE_NORMAL
