<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-353"><a id="_idTextAnchor671"/>16</h1>
<h1 id="_idParaDest-354"><a id="_idTextAnchor672"/>Error Handling, Monitoring, and Observability</h1>
<p>In <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a>, we introduced how to use logging in ASP.NET Core web API applications. Logging is a critical part of application development that helps developers understand what’s happening in their applications. However, logging is not enough – we need more tools to monitor and observe how our application is running. In this chapter, we will explore the following topics:</p>
<ul>
<li>Error handling</li>
<li>Health checks</li>
<li>Monitoring and observability</li>
</ul>
<p>After reading this chapter, you will be able to understand how to monitor ASP.NET Core web API applications. You will have gained knowledge of observability and <strong class="bold">OpenTelemetry</strong>, as well as how to use some tools, such as Prometheus and Grafana, to monitor applications.</p>
<h1 id="_idParaDest-355"><a id="_idTextAnchor673"/>Technical requirements</h1>
<p>The code samples for this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16</a>. You can use VS 2022 or VS Code to open the solutions.</p>
<h1 id="_idParaDest-356"><a id="_idTextAnchor674"/>Error handling</h1>
<p>When an <a id="_idIndexMarker1768"/>exception occurs in an ASP.NET Core web API application, the application will throw an exception. If this exception is not handled, the application will crash and cause a 500 error. The response body will contain the stack trace of the exception. Displaying the stack trace to the client is acceptable during development. However, we should never expose the stack trace to the client in production. The stack trace contains sensitive information about the application that can be used by attackers to attack the application.<a id="_idTextAnchor675"/></p>
<h2 id="_idParaDest-357"><a id="_idTextAnchor676"/>Handling exceptions</h2>
<p>Let’s look<a id="_idIndexMarker1769"/> at an example. The <code>MyWebApiDemo</code> sample application has a controller named <code>UsersController</code>, which has an action to get a user by their user ID. This action looks as follows:</p>
<pre class="source-code">
[HttpGet("{id:int}")]public ActionResult&lt;User&gt; Get(int id)
{
    var user = Users.First(u =&gt; u.Id == id);
    if (user == null)
    {
        return NotFound();
    }
    return Ok(user);
}</pre>
<p>It is not advisable to use <code>First</code> in this instance as it will result in an exception being thrown if the user is not found in the collection. To illustrate how to handle exceptions in the application, we will use this example.</p>
<p>Run the application and send a <code>GET</code> request to the <code>https://localhost:5001/users/100</code> endpoint. You can test it in the Swagger UI directly. The application will return a 500 error because no user with an ID of 100 will be found. The response body will look as follows:</p>
<div><div><img alt="Figure 16.1 – The response body contains the stack trace" src="img/B18971_16_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – The response body contains the stack trace</p>
<p>Regardless <a id="_idIndexMarker1770"/>of whether the application is running in the development environment, the response body contains the stack trace. We should never show the stack trace for the production environment. Additionally, the response body is not a valid JSON payload, making it difficult for the client to parse it.</p>
<p>ASP.NET Core provides a built-in exception handling middleware to handle exceptions and return an error payload. The exception handling middleware can return a valid JSON payload to the client. This kind of JSON payload for error and exceptions is called <strong class="bold">Problem Details</strong> and is defined in RFC7807: <a href="https://datatracker.ietf.org/doc/html/rfc7807">https://datatracker.ietf.org/doc/html/rfc7807</a>.</p>
<p>A problem details object can have the following properties:</p>
<ul>
<li><code>type</code>: A URI reference that’s used to identify the problem type. This reference provides helpful documentation in a human-readable format, which can assist clients in understanding the error.</li>
<li><code>title</code>: A summary that describes the problem’s type in a human-readable format.</li>
<li><code>status</code>: An HTTP status code generated by the original server to indicate the status of the problem.</li>
<li><code>detail</code>: A human-readable description of the problem.</li>
<li><code>instance</code>: A URI reference that provides a specific occurrence of the problem, allowing for a more precise understanding of the issue.</li>
</ul>
<p>The client <a id="_idIndexMarker1771"/>can parse the problem details object and display a user-friendly error message. This object can be extended to include additional information about the error, though the existing properties should be sufficient for most cases.</p>
<p>To use the exception handling middleware, we need to create a controller to show the problem details. Create a new controller named <code>ErrorController</code> and add the following code:</p>
<pre class="source-code">
[ApiController][ApiExplorerSettings(IgnoreApi = true)]
public class ErrorController(ILogger&lt;ErrorController&gt; logger) : ControllerBase
{
    [Route("/error-development")]
    public IActionResult HandleErrorDevelopment(
        [FromServices] IHostEnvironment hostEnvironment)
    {
        if (!hostEnvironment.IsDevelopment())
        {
            return NotFound();
        }
        var exceptionHandlerFeature =
            HttpContext.Features.Get&lt;IExceptionHandlerFeature&gt;()!;
        logger.LogError(exceptionHandlerFeature.Error, exceptionHandlerFeature.Error.Message);
        return Problem(
            detail: exceptionHandlerFeature.Error.StackTrace,
            title: exceptionHandlerFeature.Error.Message);
    }
    [Route("/error")]
    public IActionResult HandleError()
    {
        var exceptionHandlerFeature =
            HttpContext.Features.Get&lt;IExceptionHandlerFeature&gt;()!;
        logger.LogError(exceptionHandlerFeature.Error, exceptionHandlerFeature.Error.Message);
        return Problem();
    }
}</pre>
<p>The preceding<a id="_idIndexMarker1772"/> code comes from Microsoft’s official documentation: <a href="https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors">https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors</a>.</p>
<p>There are several things to note in the <code>ErrorController</code> class:</p>
<ul>
<li>The controller is marked with the <code>[ApiExplorerSettings(IgnoreApi = true)]</code> attribute. This attribute is used to hide this endpoint from the OpenAPI specification and Swagger UI.</li>
<li>The controller has two actions. The first action is used to show a detailed error message in the development environment, so it provides the route <code>/error-development</code> that shows the stack trace of the exception. The second action is used to show a generic error message in the production environment, so it provides the <code>/error</code> route that has no additional information about the exception.</li>
<li>In the <a id="_idIndexMarker1773"/>actions, we use the <code>IExceptionHandlerFeature</code> interface to get the exception information. The <code>IExceptionHandlerFeature</code> interface is a feature containing the exception of the original request to be examined by an exception handler. We can log the exception information or return it to the client.</li>
</ul>
<p>Next, we need to register the exception handling middleware in the application. Open the <code>Program.cs</code> file and call the <code>UseExceptionHandler</code> method to add the exception handling middleware:</p>
<pre class="source-code">
if (app.Environment.IsDevelopment()){
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseExceptionHandler("/error-development");
}
else
{
    app.UseExceptionHandler("/error");
}</pre>
<p>For the development environment, we can use the /<code>error-development</code> endpoint to show the detailed error message. For the production environment, we can use the /<code>error</code> endpoint to show the generic error message. It is a good practice to hide the stack trace in the production environment.</p>
<p>Run the application and send a <code>GET</code> request to the <code>https://localhost:5001/users/100</code> endpoint. The application will return a 500 error. The response body will look as follows:</p>
<div><div><img alt="Figure 16.2 – The response body contains the problem details alongside the stack trace in the development environment" src="img/B18971_16_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – The response body contains the problem details alongside the stack trace in the development environment</p>
<p>The response<a id="_idIndexMarker1774"/> body now contains a problem details JSON payload. It also contains the stack trace of the exception for troubleshooting in the development environment. The client can parse the response body and display a user-friendly error message. Meanwhile, the response headers contain the <code>Content-Type</code> header with a value of <code>application</code>/<code>problem+json</code>. This indicates that the response body is a problem details JSON payload.</p>
<p>If you run the application in the production environment, the response body will not contain the stack trace of the exception. The response body will look as follows:</p>
<div><div><img alt="Figure 16.3 – The response body contains a general error message in the production environment" src="img/B18971_16_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – The response body contains a general error message in the production environment</p>
<p>The default problem details object can be extended to include additional information about the error. We will discuss how to customize the problem details in the next secti<a id="_idTextAnchor677"/>on.</p>
<h3>Model validation</h3>
<p>When a <a id="_idIndexMarker1775"/>client sends a request to the application, the application needs to validate the request. For example, when a user updates their profile, the <code>Email</code> property must be a valid email address. If the value of the <code>Email</code> property is invalid, the application should return an HTTP 400 response with a problem details object that contains the validation error message.</p>
<p>ASP.NET Core offers a built-in model validation feature to validate the request model. This feature is enabled using validation attributes, which are defined in the <code>System.ComponentModel.DataAnnotations</code> namespace. The following table outlines some available validation attributes:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-11">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Attribute name</p>
</td>
<td class="No-Table-Style">
<p>Description</p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Required</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies that a data field is required</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Range</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies that a numeric field must be in a specified range</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>StringLength</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the minimum and maximum length of a <code>string</code> field</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>EmailAddress</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies that a data field must be a valid email address</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>RegularExpression</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies that a data field must match the specified regular expression</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Url</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies that a data field must be a valid URL</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.1 – Common model validation attributes</p>
<p>We can apply these validation attributes as follows:</p>
<pre class="source-code">
public class User{
    public int Id { get; set; }
    [Required]
    [StringLength(50, MinimumLength = 3, ErrorMessage = "The length of FirstName must be between 3 and 50.")]
    public string FirstName { get; set; } = string.Empty;
    [Required]
    [StringLength(50, MinimumLength = 3, ErrorMessage = "The length of LastName must be between 3 and 50.")]
    public string LastName { get; set; } = string.Empty;
    [Required]
    [Range(1, 120, ErrorMessage = "The value of Age must be between 1 and 120.")]
    public int Age { get; set; }
    [Required]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;
    [Required]
    [Phone]
    public string PhoneNumber { get; set; } = string.Empty;
}</pre>
<p>Run the application and send a <code>POST</code> request to the <code>/users</code> endpoint with an invalid request body, like this:</p>
<pre class="source-code">
{  "firstName": "ab",
  "lastName": "xy",
  "age": 20,
  "email": "user-example.com",
  "phoneNumber": "abcxyz"
}</pre>
<p>The application <a id="_idIndexMarker1776"/>will return an HTTP 400 response with a problem details object, as follows:</p>
<pre class="source-code">
{  "type": "https://tools.ietf.org/html/rfc9110#section-15.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "Email": [
      "The Email field is not a valid e-mail address."
    ],
    "LastName": [
      "The length of LastName must be between 3 and 50."
    ],
    "FirstName": [
      "The length of FirstName must be between 3 and 50."
    ],
    "PhoneNumber": [
      "The PhoneNumber field is not a valid phone number."
    ]
  },
  "traceId": "00-8bafbe8952051318d15ddb570d2872b0-369effbb9978122b-00"
}</pre>
<p>In this way, the<a id="_idIndexMarker1777"/> client can parse the response body and display a user-friendly error message so that the user can correct the input<a id="_idTextAnchor678"/>.</p>
<h3>Using FluentValidation to validate models</h3>
<p>The <a id="_idIndexMarker1778"/>previous section discussed the use of built-in validation attributes. However, these have certain limitations:</p>
<ul>
<li>The validation attributes are tightly coupled with the model. The models are polluted with validation attributes.</li>
<li>The validation attributes cannot validate complex validation rules. If one property has dependencies on other properties, or the validation needs external services, the validation attributes cannot handle this.</li>
</ul>
<p>To solve these problems, we can use <code>FluentValidation</code> to validate the models. <code>FluentValidation</code> is a popular open-source library for building strongly typed validation rules, allowing us to separate the validation logic from the models. It also supports complex validation rules.</p>
<p>To use <code>FluentValidation</code>, we need to install the <code>FluentValidation.AspNetCore</code> NuGet package. Run the following command in the terminal to install the package:</p>
<pre class="console">
dotnet add package FluentValidation</pre> <p class="callout-heading">Important note</p>
<p class="callout">Previously, <code>FluentValidation</code> provided a separate package for ASP.NET Core named <code>FluentValidation.AspNetCore</code>. However, this package is deprecated. It is recommended to use the <code>FluentValidation</code> package directly and use manual validation instead of using the ASP.NET Core validation pipeline. This is because the ASP.NET Core validation pipeline does not support asynchronous validation.</p>
<p>Next, we <a id="_idIndexMarker1779"/>need to create a validator for the <code>User</code> model. Create a new class named <code>UserValidator</code> and add the following code:</p>
<pre class="source-code">
public class UserValidator : AbstractValidator&lt;User&gt;{
    public UserValidator()
    {
        RuleFor(u =&gt; u.FirstName)
            .NotEmpty()
            .WithMessage("The FirstName field is required.")
            .Length(3, 50)
            .WithMessage("The length of FirstName must be between 3 and 50.");
        // Omitted other rules for brevity
        // Create a custom rule to validate the Country and PhoneNumber. If the country is New Zealand, the phone number must start with 64.
        RuleFor(u =&gt; u)
            .Custom((user, context) =&gt;
            {
                if (user.Country.ToLower() == "new zealand" &amp;&amp; !user.PhoneNumber.StartsWith("64"))
                {
                    context.AddFailure("The phone number must start with 64 for New Zealand users.");
                }
            });
    }
}</pre>
<p>In the<a id="_idIndexMarker1780"/> preceding code, we use fluent syntax to specify validation rules for each property. We can also create a custom rule for dependent properties. In this example, we’re creating a custom rule to validate the <code>Country</code> and <code>PhoneNumber</code> properties. If the country is New Zealand, we can create a custom rule that requires the phone number to start with 64. This is just one example of how to validate properties that depend on other properties; built-in validation attributes cannot handle this type of validation.</p>
<p>Next, we need to register the validator in the application. Add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.AddScoped&lt;IValidator&lt;User&gt;, UserValidator&gt;();</pre> <p>The preceding code looks straightforward. But what if we have many validators? We can register all validators in a specific assembly. To do this, we need to install the <code>FluentValidation.DependencyInjectionExtensions</code> NuGet package. Run the following command in the terminal to install the package:</p>
<pre class="console">
dotnet add package FluentValidation.DependencyInjectionExtensions</pre> <p>Then, we can register all validators, as follows:</p>
<pre class="source-code">
builder.Services.AddValidatorsFromAssemblyContaining&lt;UserValidator&gt;();</pre> <p>Now, we can validate the model in the controller. Update the <code>Post</code> action, as follows:</p>
<pre class="source-code">
[HttpPost]public async Task&lt;ActionResult&lt;User&gt;&gt; Post(User user)
{
    var validationResult = await _validator.ValidateAsync(user);
    if (!validationResult.IsValid)
    {
        return BadRequest(new ValidationProblemDetails(validationResult.ToDictionary()));
    }
    user.Id = Users.Max(u =&gt; u.Id) + 1;
    Users.Add(user);
    return CreatedAtRoute("", new { id = user.Id }, user);
}</pre>
<p>In the<a id="_idIndexMarker1781"/> preceding code, we utilize the <code>ValidateAsync()</code> method to validate the model. If the model is invalid, we return an HTTP <code>400</code> response containing a problem details object that contains the associated validation error message.</p>
<p>Send a <code>POST</code> request to the <code>/users</code> endpoint with the following payload:</p>
<pre class="source-code">
{  "firstName": "ab",
  "lastName": "xy",
  "age": 20,
  "email": "user-example.com",
  "country": "New Zealand",
  "phoneNumber": "12345678"
}</pre>
<p>The application <a id="_idIndexMarker1782"/>will return a 400 error with the following problem details object:</p>
<pre class="source-code">
{  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "FirstName": [
      "The length of LastName must be between 3 and 50."
    ],
    "LastName": [
      "The length of LastName must be between 3 and 50."
    ],
    "Email": [
      "The Email field is not a valid e-mail address."
    ],
    "": [
      "The phone number must start with 64 for New Zealand users."
    ]
  }
}</pre>
<p>As we can see, the custom validation rule is executed and the error message is returned to the client.</p>
<p><code>FluentValidation</code> has more features than just built-in validation attributes. If you have complex validation rules, you can consider using <code>FluentValidation</code>. For more details, please refer to the official documentation: <a href="https://docs.fluentvalidation.net/en/latest/index﻿.html">https://docs.fluentvalidation.net/en/latest/index.html</a>.</p>
<h1 id="_idParaDest-358"><a id="_idTextAnchor680"/>Health checks</h1>
<p>To monitor the application, we need to know whether the application is running correctly or not. We can perform health checks to monitor the application. Normally, a health check is an endpoint that returns the health status of the application. This status can be <em class="italic">Healthy</em>, <em class="italic">Degraded</em>, or <em class="italic">Unhealthy</em>.</p>
<p>A <a id="_idIndexMarker1783"/>health check is a critical part of the microservice architecture. In the microservice architecture, one API service may have multiple instances and also have dependencies on other services. A load balancer or orchestrator can be used to distribute the traffic to different instances. If one instance is unhealthy, the load balancer or orchestrator can stop sending traffic to the unhealthy instance. For example, Kubernetes – a popular container orchestrator – can use health checks to determine whether a container is healthy or not. If a container is not live, Kubernetes will restart the container.</p>
<p>We won’t discuss the details of Kubernetes in this book. Instead, we will focus on how to implement health checks for Kubernetes in ASP.NET Core web API applic<a id="_idTextAnchor681"/>ations.</p>
<h2 id="_idParaDest-359"><a id="_idTextAnchor682"/>Implementing a basic health check</h2>
<p>ASP.NET Core<a id="_idIndexMarker1784"/> provides a straightforward way to configure health checks. We can use the <code>AddHealthChecks</code> method to add health checks to the application. Open the <code>Program.cs</code> file and add the following code:</p>
<pre class="source-code">
builder.Services.AddHealthChecks();var app = builder.Build();
app.MapHealthChecks("healthcheck");</pre>
<p>The preceding code adds a basic health check to the application. The health check’s endpoint is <code>/healthcheck</code>. Run the application and send a <code>GET</code> request to the <code>/healthcheck</code> endpoint. If successful, the application will return a <code>200</code> response with <code>Healthy</code> in plain text in the response body.</p>
<p>However, this health check is too simple. In the real world, a web API application may be more complex. It may have multiple dependencies, such as databases, message queues, and other services. We<a id="_idIndexMarker1785"/> need to check the health status of these dependencies. If some core dependencies are unhealthy, the application should be unhealthy. Let’s see how to implement a more complex heal<a id="_idTextAnchor683"/>th check.</p>
<h3>Implementing a complex health check</h3>
<p>A health check<a id="_idIndexMarker1786"/> implementation class implements the <code>IHealthCheck</code> interface. The <code>IHealthCheck</code> interface is defined as follows:</p>
<pre class="source-code">
public interface IHealthCheck{
    Task&lt;HealthCheckResult&gt; CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default);
}</pre>
<p>We can create a custom health check implementation to ensure the proper functioning of our API. For instance, if the API depends on another service, we can create a health check implementation to verify the health status of the dependent service. If the dependent service is unhealthy, the API won’t be able to function correctly. Here is an example of a health check implementation:</p>
<pre class="source-code">
public class OtherServiceHealthCheck(IHttpClientFactory httpClientFactory) : IHealthCheck{
    public async Task&lt;HealthCheckResult&gt; CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default)
    {
        var client = httpClientFactory.CreateClient("JsonPlaceholder");
        var response = await client.GetAsync("posts", cancellationToken);
        return response.IsSuccessStatusCode
            ? HealthCheckResult.Healthy("A healthy result.")
            : HealthCheckResult.Unhealthy("An unhealthy result.");
    }
}</pre>
<p>In the<a id="_idIndexMarker1787"/> preceding code, we create a health check implementation to check the health status of the <a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a> endpoint. If the endpoint returns a 200 response, the health check returns healthy. Otherwise, the health check returns unhealthy.</p>
<p>Next, we need to register the health check implementation in the application. Open the <code>Program.cs</code> file and add the following code:</p>
<pre class="source-code">
builder.Services.AddHealthChecks()    .AddCheck&lt;OtherServiceHealthCheck&gt;("OtherService");
// Omitted other code for brevity
app.MapHealthChecks("/other-service-health-check",
    new HealthCheckOptions() { Predicate = healthCheck =&gt; healthCheck.Name == "OtherService" });</pre>
<p>This code is similar to the previous health check. First, we use the <code>AddHealthChecks</code> method to register the strongly typed health check implementation. Then, we use the <code>MapHealthCheck</code> method to map the <code>/other-service-health-check</code> endpoint to the health check implementation. We also use the <code>HealthCheckOptions</code> object to specify the name of the health check, which is used to filter the health checks. If we do not specify the name of the health check, all health check implementations will be executed.</p>
<p>Run the application and send a <code>GET</code> request to the <code>/other-service-health-check</code> endpoint. If the dependent service, <code>https://jsonplaceholder.typicode.com/posts</code>, is healthy, the application will return a 200 response with <code>Healthy</code> in plain text in the response body.</p>
<p>Sometimes, we <a id="_idIndexMarker1788"/>need to check multiple dependent services. We can register multiple health check implementations with a specific tag, at which point we can use this tag to filter the health checks. The following code shows how to register multiple health check implementations:</p>
<pre class="source-code">
builder.Services.AddHealthChecks()    .AddCheck&lt;OtherServiceHealthCheck&gt;("OtherService", tags: new[] { "other-service" })
    .AddCheck&lt;OtherService2HealthCheck&gt;("OtherService2", tags: new[] { "other-service" });
    .AddCheck&lt;OtherService3HealthCheck&gt;("OtherService3", tags: new[] { "other-service" });</pre>
<p>In the preceding code, we register three health check implementations with the same tag – that is, <code>other-service</code>. Now, we can use the tag to filter the health checks. The following code shows how to filter the health checks:</p>
<pre class="source-code">
app.MapHealthChecks("/other-services-health-check",    new HealthCheckOptions() { Predicate = healthCheck =&gt; healthCheck.Tags.Contains("other-service") });</pre>
<p>Like the <code>Name</code> property, we can use the <code>Tags</code> property to filter the health checks. When we send a <code>GET</code> request to the <code>/other-services-health-check</code> endpoint, the application will return a <code>200 OK</code> response with <code>Healthy</code> in plain text in the response body if all dependent services are healthy. But if one of the dependent services is unhealthy, the health check will return a <code>503 Service Unavailable</code> response with <code>Unhealthy</code> in plain text in the response body.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If the <code>MapHealthChecks()</code> method does not use the <code>HealthCheckOptions</code> parameter, the health check endpoint will run all registered health checks<a id="_idTextAnchor684"/> by default.</p>
<h3>Implementing a database health check</h3>
<p>In the<a id="_idIndexMarker1789"/> previous section, we discussed how to implement a health check for a dependent service. As databases are a common component of web API applications, this section will focus on how to implement a database health check.</p>
<p>The approach to implementing a database health check is similar to what we covered in the previous section: we need to connect to the database and execute a simple query to check if the database is healthy. If you use EF Core to access the database, you can use the <code>Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore</code> package to implement a database health check. This package provides a health check implementation for EF Core, so we do not need to write the health check implementation ourselves. Run the following command in the terminal to install the package:</p>
<pre class="source-code">
dotnet add package Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore</pre> <p>In the sample project, we have an <code>InvoiceDbContext</code> class to access the database. The following code shows how to register the <code>InvoiceDbContext</code> class in the application:</p>
<pre class="source-code">
builder.Services.AddDbContext&lt;InvoiceDbContext&gt;(options =&gt;    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));</pre>
<p>Once you’ve done this, register the EF Core <code>DbContext</code> health check implementation, as follows:</p>
<pre class="source-code">
builder.Services.AddHealthChecks().AddDbContextCheck&lt;InvoiceDbContext&gt;("Database", tags: new[] { "database" });</pre> <p>Similarly, assign a tag to the health check implementation so that we can filter the health checks. Then, we can map the health check endpoint to the health check’s implementation, as follows:</p>
<pre class="source-code">
app.MapHealthChecks("/database-health-checks",    new HealthCheckOptions() { Predicate = healthCheck =&gt; healthCheck.Tags.Contains("database") });</pre>
<p>Run the<a id="_idIndexMarker1790"/> application and send a <code>GET</code> request to the <code>/database-health-checks</code> endpoint. If the database is healthy, the application will return a <code>200 OK</code> response with <code>Healthy</code> in plain text in the response body. Additionally, you can register multiple health checks for different databases if necessary.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you are using other ORMs to access the database, you can create a custom health check implementation following the previous section. This can be done by executing a simple query, such as <code>SELECT 1</code>, to determine whether the database is functio<a id="_idTextAnchor685"/>ning properly.</p>
<h3>Understanding readiness and liveness</h3>
<p>In the previous sections, we discussed how to implement health checks for ASP.NET Core web API applications. In the real world, we may need to deploy the applications to a container orchestrator, such as Kubernetes. Kubernetes is a popular container orchestrator that can manage containerized applications, monitor health statuses, and scale up or down <a id="_idIndexMarker1791"/>based on workload. Kubernetes uses the term <strong class="bold">probe</strong>, which is similar to health checks, to monitor the health status of the applications. While this book does not cover the details of Kubernetes, it will discuss how to implement Kubernetes probes in ASP.NET Core web API applications.</p>
<p>Kubernetes has three types of probes: <em class="italic">readiness</em>, <em class="italic">liveness</em>, and <em class="italic">startup</em>. Let’s take a closer look:</p>
<ul>
<li><code>liveness</code>: This probe <a id="_idIndexMarker1792"/>indicates whether the application is running correctly. Kubernetes performs a <code>liveness</code> probe every few seconds. If the application does not respond to the <code>liveness</code> probe for a specified period, the container will be killed and Kubernetes will create a new one to replace it. The <code>liveness</code> probe can execute either an HTTP request, a command, or a TCP socket check. It also supports gRPC health checks.</li>
<li><code>readiness</code>: This <a id="_idIndexMarker1793"/>probe is used to determine whether the application is ready to receive traffic. Some applications need to perform some initialization tasks before they can receive traffic, such as connecting to the database, loading configuration, checking the dependent services, and so on. During this period, the application cannot receive traffic, but this does not mean that the application is unhealthy. Kubernetes should not kill the application and restart it. After the initialization is complete and all dependent services are healthy, the <code>readiness</code> probe will inform Kubernetes that the application is ready to receive traffic.</li>
<li><code>startup</code>: This<a id="_idIndexMarker1794"/> probe is similar to the <code>readiness</code> probe. However, the difference is that the <code>startup</code> probe is only executed once the application starts. It is used to determine whether the application has completed the initialization process. If this probe is configured, the <code>liveness</code> and <code>readiness</code> probes will not be executed until the <code>startup</code> probe is successful.</li>
</ul>
<p>Configuring the probes incorrectly may cause cascading failures. For example, service A depends on service B and service B depends on service C. If the <code>liveness</code> probes are misconfigured incorrectly to check the dependent services when service C is unhealthy, service A and service B will be restarted, which does not solve the problem. This is a cascading failure. In this case, service A and service B should not be restarted. Instead, only service C should be restarted.</p>
<p>Here’s an <a id="_idIndexMarker1795"/>example of a <code>liveness</code> HTTP probe configuration for Kubernetes:</p>
<pre class="source-code">
livenessProbe:  httpGet:
    path: /liveness
    port: 8080
    httpHeaders:
    - name: Custom-Header
      value: X-Health-Check
  initialDelaySeconds: 3
  periodSeconds: 5
  timeoutSeconds: 1
  successThreshold: 1
  failureThreshold: 3</pre>
<p>In the configuration, we<a id="_idIndexMarker1796"/> define the following properties:</p>
<ul>
<li><code>path</code>, <code>port</code>, and <code>httpHeaders</code>: These properties are used to configure the HTTP request. In the preceding example, we specify a custom HTTP header called <code>Custom-Header</code> with a value of <code>X-Health-Check</code>. The application can use this HTTP header to identify whether the request is a health check request. If the request does not have this HTTP header, the application can deny the request.</li>
<li><code>initialDelaySeconds</code>: This property is used to specify the number of seconds after the container has started before the first probe is executed. The default value is 0. Do not use a high value for this property. You can use the <code>startup</code> probe to check the initialization of the application instead.</li>
<li><code>periodSeconds</code>: This property is used to specify the number of seconds between each probe. The default value is 10. The minimum value is 1. You can adjust this value based on your scenarios. Make sure Kubernetes can discover the unhealthy container as soon as possible.</li>
<li><code>timeoutSeconds</code>: This property is used to specify the number of seconds after which the probe times out. The default value is 1 and the minimum value is also 1. Make sure the probe is fast.</li>
<li><code>successThreshold</code>: This property is used to determine the number of consecutive successful responses required for a probe to be considered successful after having previously failed. The value must be 1 for liveness probes.</li>
<li><code>failureThreshold</code>: This property is used to specify the number of consecutive failures for the probe to be considered failed after having succeeded. Do not use a high value for this property; otherwise, Kubernetes needs to wait a long time to restart the container.</li>
</ul>
<p>Keep in mind <a id="_idIndexMarker1797"/>that the <code>liveness</code> probe should not depend on other services. In other words, do not check the health status of other services in the <code>liveness</code> probe. Instead, this probe should only check whether the application can respond to the request.</p>
<p>An example<a id="_idIndexMarker1798"/> of a <code>readiness</code> HTTP probe’s configuration is as follows:</p>
<pre class="source-code">
readinessProbe:  httpGet:
    path: /readiness
    port: 8080
    httpHeaders:
    - name: Custom-Header
      value: X-Health-Check
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 1
  successThreshold: 3
  failureThreshold: 2</pre>
<p>There are a few different considerations for the <code>readiness</code> probe:</p>
<ul>
<li><code>successThreshold</code>: The default value is 1. However, we can increase this value to make sure the application is ready to receive traffic.</li>
<li><code>failureThreshold</code>: After at least <code>failureThreshold</code> probes have failed, Kubernetes will stop sending traffic to the container. As the application may have temporary problems, we can allow a few failures before the application is <a id="_idIndexMarker1799"/>considered unhealthy. However, do not use a high value for this property.</li>
</ul>
<p>If the application takes a long time to initialize, we can use the <code>startup</code> probe to check the initialization of the application. An example of a <code>startup</code> HTTP probe configuration<a id="_idIndexMarker1800"/> is shown here:</p>
<pre class="source-code">
startupProbe:  httpGet:
    path: /startup
    port: 8080
    httpHeaders:
    - name: Custom-Header
      value: X-Health-Check
  periodSeconds: 5
  timeoutSeconds: 1
  successThreshold: 1
  failureThreshold: 30</pre>
<p>In this configuration, the <code>startup</code> probe will be executed every 5 seconds, and the application will have a maximum of 150 seconds (5 * 30 = 150 seconds) to complete the initialization. <code>successThreshold</code> must be 1 so that once the <code>startup</code> probe is successful, the <code>liveness</code> and <code>readiness</code> probes will be executed. If the <code>startup</code> probe fails after 150 seconds (about 2 and a half minutes), Kubernetes will kill the container and start a new one. So, ensure that the <code>startup</code> probe has enough time to complete the initialization.</p>
<p>Configuring Kubernetes probes is not a simple task. We need to consider many factors. For example, should we check the dependent services in the <code>readiness</code> probe? If the application can partially operate without a specific dependent service, it can be considered as <a id="_idIndexMarker1801"/>degraded instead of unhealthy. In this case, if the application has mechanisms to handle transient failures gracefully, it might be acceptable to omit specific dependent services in the <code>readiness</code> probe. So, please consider your scenarios carefully; you may need a compromise when configuring the probes.</p>
<p>This section is not intended to cover all the details of Kubernetes probes. For more details, please refer to the following official documentation:</p>
<ul>
<li>Kubernetes documentation: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a>.</li>
<li>Health checks in ASP.NET Core: <a href="https://learn.microsoft.com/en-us/aspnet/core/host-﻿and-deploy/health-checks">https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks</a>.</li>
</ul>
<h1 id="_idParaDest-360"><a id="_idTextAnchor687"/>Monitoring and observability</h1>
<p>In the real world, building <a id="_idIndexMarker1802"/>an application is just the first step. We also need to monitor and observe how the application is performing. This is where the concept of <em class="italic">observability</em> comes in. In this section, we will discuss observability and how to use OpenTelemetry to monitor<a id="_idTextAnchor688"/> and observe applications.</p>
<h2 id="_idParaDest-361"><a id="_idTextAnchor689"/>What is observability?</h2>
<p>In <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a>, we introduced<a id="_idIndexMarker1803"/> logging in ASP.NET Core web API applications. We learned how to use the built-in logging framework to log messages to different logging providers. <strong class="bold">Observability</strong> is a more comprehensive concept than logging. Besides logging, observability allows us to gain a deeper understanding of how the application is performing. For instance, we can determine how many requests are processed in a given hour, what the request latency is, and how requests are handled by multiple services in a microservice architecture. All of these are part of observability.</p>
<p>In general, observability has three pillars:</p>
<ul>
<li><strong class="bold">Logs</strong>: Logs<a id="_idIndexMarker1804"/> are used to record what is happening within the application, such as incoming requests, outgoing responses, important business logic executions, exceptions, errors, warnings, and so on.</li>
<li><strong class="bold">Metrics</strong>: Metrics<a id="_idIndexMarker1805"/> are used to measure the performance of the application, such as the number of requests, the request latency, error rates, resource usage, and so on. These metrics can be used to trigger alerts when the application is not performing well.</li>
<li><strong class="bold">Traces</strong>: Traces <a id="_idIndexMarker1806"/>are used to track the flow of requests across multiple services to identify where the time is spent or where the errors occur. This is especially useful in the microservice architecture.</li>
</ul>
<p>To summarize, observability is the practice of understanding the application’s internal state and operational characteristics by analyzing its logs, metrics, and traces. There are a few different ways to implement observability in ASP.NET Core web API applications – we can update the source code to add logging, metrics, and traces or use tools to monitor and observe the application without changing the code. In this section, we will discuss the first approach by using OpenTelemetry to implement observability in ASP.NET Core web API applications. This gives us more flexibility to custo<a id="_idTextAnchor690"/>mize the observability aspect.</p>
<h3>Using OpenTelemetry to collect observability data</h3>
<p>OpenTelemetry<a id="_idIndexMarker1807"/> is a <a id="_idIndexMarker1808"/>popular cross-platform, open-source standard for collecting observability data. It provides a set of APIs, SDKs, and tools to instrument, generate, collect, and export <a id="_idIndexMarker1809"/>telemetry data so that we can analyze the application’s performance and behavior. It supports many platforms and languages, as well as popular cloud providers. You can find more details <a id="_idIndexMarker1810"/>about OpenTelemetry at <a href="https://opentelemetry.io/">https://opentelemetry.io/</a>.</p>
<p>The .NET OpenTelemetry implementation consists of the following components:</p>
<ul>
<li><strong class="bold">Core API</strong>: The<a id="_idIndexMarker1811"/> core API is a set of interfaces and classes that define the OpenTelemetry API. It is a platform-independent API that can be used to instrument the application.</li>
<li><strong class="bold">Instrumentation</strong>: This is a <a id="_idIndexMarker1812"/>set of libraries that can be used to collect instrumentation from the application. This component includes multiple packages for different frameworks and platforms, such as ASP.NET Core, gRPC, HTTP calls, SQL database operations, and so on.</li>
<li><strong class="bold">Exporters</strong>: Exporters are <a id="_idIndexMarker1813"/>used to export the collected telemetry data to different targets, such as console and <strong class="bold">Application Performance Monitoring</strong> (<strong class="bold">APM</strong>) systems, including Prometheus, Zipkin, and so on.</li>
</ul>
<p>In <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a>, we<a id="_idIndexMarker1814"/> introduced using <em class="italic">Serilog</em> and <em class="italic">Seq</em> to <a id="_idIndexMarker1815"/>collect logs. In the next few sections, we will focus on how to use OpenTelemetry to collect metrics and traces. We will use <em class="italic">Prometheus</em> to collect metrics and <em class="italic">Grafana</em> to visualize the metrics. We will also use <em class="italic">Jaeger</em> to collect traces. All these tools are open-source. In addition, we will explore Azure Application Insights, a pow<a id="_idTextAnchor691"/>erful APM system provided by Microsoft.</p>
<h3>Integrating OpenTelemetry with ASP.NET Core web API applications</h3>
<p>In this section, we<a id="_idIndexMarker1816"/> will explore how to use metrics in ASP.NET Core web API applications. In<a id="_idIndexMarker1817"/> the sample project, we have an <code>InvoiceController</code> class to manage invoices. We want to know how many requests are executed and the duration of each request. We have several steps to perform:</p>
<ol>
<li>Define the metrics for these activities.</li>
<li>Generate and collect instrumentation data.</li>
<li>Visualize the data in a dashboard.</li>
</ol>
<p>To start, we need to install some NuGet packages using the following commands:</p>
<pre class="console">
dotnet add package OpenTelemetry.Instrumentation.AspNetCore --prereleasedotnet add package OpenTelemetry.Instrumentation.Http --prerelease
dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
dotnet add package OpenTelemetry.Exporter.Console
dotnet add package OpenTelemetry.Extensions.Hosting</pre>
<p>These <a id="_idIndexMarker1818"/>packages include the required .NET OpenTelemetry implementations. Note that at the time of writing, some packages did not have stable versions available, so we needed to use the <code>--prerelease</code> option to install the latest preview versions. If you are reading this book when the stable versions are available, you can omit the <code>--</code><code>prerelease</code> option.</p>
<p>Next, we <a id="_idIndexMarker1819"/>must define the metrics. In this example, we want to know how many requests are executed for each action for the <code>/api/Invoices</code> endpoint. Create a new class named <code>InvoiceMetrics</code> in the <code>\OpenTelemetry\Metrics</code> folder. The following code shows how to define the metrics:</p>
<pre class="source-code">
public class InvoiceMetrics{
    private readonly Counter&lt;long&gt; _invoiceCreateCounter;
    private readonly Counter&lt;long&gt; _invoiceReadCounter;
    private readonly Counter&lt;long&gt; _invoiceUpdateCounter;
    private readonly Counter&lt;long&gt; _invoiceDeleteCounter;
    public InvoiceMetrics(ImeterFactory meterFactory)
    {
        var meter = meterFactory.Create("MyWebApiDemo.Invoice");
        _invoiceCreateCounter = meter.CreateCounter&lt;long&gt;("mywebapidemo.invoices.created");
        _invoiceReadCounter = meter.CreateCounter&lt;long&gt;("mywebapidemo.invoices.read");
        _invoiceUpdateCounter = meter.CreateCounter&lt;long&gt;("mywebapidemo.invoices.updated");
        _invoiceDeleteCounter = meter.CreateCounter&lt;long&gt;("mywebapidemo.invoices.deleted");
    }
    public void IncrementCreate()
    {
        _invoiceCreateCounter.Add(1);
    }
    public void IncrementRead()
    {
        _invoiceReadCounter.Add(1);
    }
    // Omitted other methods for brevity
}</pre>
<p>The <code>IMeterFactory</code> interface<a id="_idIndexMarker1820"/> is registered in ASP.NET Core’s DI<a id="_idIndexMarker1821"/> container by default and is used to create a meter. This meter, which is called <code>MyWebApiDemo.Invoice</code>, is used to record the metrics. Additionally, four counters are created to record the number of requests for each action. To facilitate this, four public methods are exposed to increment the counters.</p>
<p>The name of each metric must be unique. When we create a metric or a counter, it is recommended to follow the OpenTelemetry naming guidelines: <a href="https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines">https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines</a>.</p>
<p>Next, we need to register the metrics in the application. Add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.AddOpenTelemetry()    .ConfigureResource(config =&gt;
    {
        config.AddService(nameof(MyWebApiDemo));
    })
    .WithMetrics(b =&gt;
    {
        b.AddConsoleExporter();
        b.AddAspNetCoreInstrumentation();
        b.AddMeter("Microsoft.AspNetCore.Hosting",
            "Microsoft.AspNetCore.Server.Kestrel",
            "MyWebApiDemo.Invoice");
    });
builder.Services.AddSingleton&lt;InvoiceMetrics&gt;();</pre>
<p>In the<a id="_idIndexMarker1822"/> preceding code, we used the <code>AddOpenTelemetry()</code> method to register the <a id="_idIndexMarker1823"/>OpenTelemetry services. The <code>ConfigureResource()</code> method registers the service name. Inside the <code>WithMetrics()</code> method, we use the <code>AddConsoleExporter()</code> method to add a console exporter. This console exporter is useful for local development and debugging. We also added three meters, including the ASP.NET Core hosting and Kestrel server, so that we can collect the metrics from the ASP.NET Core web API framework. Finally, we registered the <code>InvoiceMetrics</code> class in the dependency injection container as a singleton.</p>
<p>Next, we can use the <code>InvoiceMetrics</code> class to record the metrics. Open the <code>InvoiceController</code> class and call the <code>IncrementCreate()</code> method in the <code>Post</code> action, as follows:</p>
<pre class="source-code">
[HttpPost]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; Post(Invoice invoice)
{
    // Omitted for brevity
    await dbContext.SaveChangesAsync();
    // Instrumentation
    _invoiceMetrics.IncrementCreate();
    return CreatedAtAction(nameof(Get), new { id = invoice.Id }, invoice);
}</pre>
<p>The <a id="_idIndexMarker1824"/>other <a id="_idIndexMarker1825"/>actions are similar. Before we check the metrics in the console, we need to install <a id="_idIndexMarker1826"/>the <strong class="bold">dotnet-counters</strong> tool, a command-line tool for viewing live metrics. Run the following command in the terminal to install the tool:</p>
<pre class="console">
dotnet tool install --global dotnet-counters</pre> <p>Then, we can use the <code>dotnet counters</code> command to view the metrics. We can check the metrics from <code>Microsoft.AspNetCore.Hosting</code> using the following command:</p>
<pre class="console">
dotnet-counters monitor -n MyWebApiDemo --counters Microsoft.AspNetCore.Hosting</pre> <p>Run the application and send some requests to the <code>/api/Invoices</code> endpoint. You will see the following metrics:</p>
<pre class="source-code">
Press p to pause, r to resume, q to quit.    Status: Running
[Microsoft.AspNetCore.Hosting]
    http.server.active_requests ({request})
        http.request.method=GET,url.scheme=https                           0
        http.request.method=POST,url.scheme=https                          0
    http.server.request.duration (s)
        http.request.method=GET,http.response.status_code=200,ht           0.006
        http.request.method=GET,http.response.status_code=200,ht           0.006
        http.request.method=GET,http.response.status_code=200,ht           0.006
        http.request.method=POST,http.response.status_code=201,h           0.208
        http.request.method=POST,http.response.status_code=201,h           0.208
        http.request.method=POST,http.response.status_code=201,h           0.208</pre>
<p>Here, you<a id="_idIndexMarker1827"/> can see the metrics for the HTTP actions, including the active requests and the request <a id="_idIndexMarker1828"/>duration. You can use this tool to observe more performance metrics, such as CPU usage or the rate of exceptions being thrown in the application. For more information about this tool, please refer to the official documentation: <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters">https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters</a>.</p>
<p>To check the custom metrics via <code>InvoiceMetrics</code>, you need to specify the <code>--counters</code> option in the command, as follows:</p>
<pre class="source-code">
dotnet-counters monitor -n MyWebApiDemo --counters MyWebApiDemo.Invoice</pre> <p>The output may look like this:</p>
<pre class="source-code">
Press p to pause, r to resume, q to quit.    Status: Running
[MyWebApiDemo.Invoice]
    mywebapidemo.invoices.created (Count / 1 sec)                    0
    mywebapidemo.invoices.read (Count / 1 sec)                       0</pre>
<p>Here, you<a id="_idIndexMarker1829"/> can<a id="_idIndexMarker1830"/> see the metrics we defined in the <code>invoiceMetrics</code> class. Note that you can include multiple counters in the <code>--counters</code> option, separated by commas. For example, you can use the following command to check the metrics for both <code>Microsoft.AspNetCore.Hosting</code> and <code>MyWebApiDemo.Invoice</code>:</p>
<pre class="console">
dotnet-counters monitor -n MyWebApiDemo --counters Microsoft.AspNetCore.Hosting,MyWebApiDemo.Invoice</pre> <p>In the <code>InvoiceMetrics</code> class, we defined four counters. There are more types of instruments in OpenTelemetry, such as <code>Gauge</code>, <code>Histogram</code>, and others. Here are some of the different types of instruments that are available:</p>
<ul>
<li><code>Counter</code>: A counter is used to track a value that can only increase over time – for example, the number of requests after the application starts.</li>
<li><code>UpDownCounter</code>: An up-down counter is similar to a counter, but it can increase or decrease over time. An example of this is the number of active requests. When a request starts, the counter increases by 1. When the request ends, the counter decreases by 1. It can also be used to monitor the size of a queue.</li>
<li><code>Gauge</code>: A gauge measures a current value at a specific point in time, such as CPU usage or memory usage.</li>
<li><code>Histogram</code>: A histogram measures the statistical distribution of values using aggregations. For example, a histogram can measure how many requests are processed longer than a specific duration.</li>
</ul>
<p>We can <a id="_idIndexMarker1831"/>define more <a id="_idIndexMarker1832"/>metrics to monitor the application. Define an <code>UpDownCounter</code> instrument to track how many active requests there are for the <code>/api/Invoices</code> endpoint. Update the <code>InvoiceMetrics</code> class, as follows:</p>
<pre class="source-code">
private readonly UpDownCounter&lt;long&gt; _invoiceRequestUpDownCounter;public InvoiceMetrics(IMeterFactory meterFactory)
{
    // Omitted for brevity
    _invoiceRequestUpDownCounter = meter.CreateUpDownCounter&lt;long&gt;("mywebapidemo.invoices.requests");
}
public void IncrementRequest()
{
    _invoiceRequestUpDownCounter.Add(1);
}
public void DecrementRequest()
{
    _invoiceRequestUpDownCounter.Add(-1);
}</pre>
<p>Then, update the <code>InvoiceController</code> class so that it increments and decrements the counter. For<a id="_idIndexMarker1833"/> simplicity, we’ll just call the <code>IncrementRequest()</code> and <code>DecrementRequest()</code> methods in the controller. In the real world, it is recommended to use an ASP.NET Core middleware to handle this. The following code shows how to update the <code>InvoiceController</code> class:</p>
<pre class="source-code">
[HttpGet("{id}")]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; Get(Guid id)
{
    _invoiceMetrics.IncrementRequest();
    // Omitted for brevity
    _invoiceMetrics.DecrementRequest();
    return Ok(result);
}</pre>
<p>An example<a id="_idIndexMarker1834"/> of <code>Histogram</code> is shown here:</p>
<pre class="source-code">
private readonly Histogram&lt;double&gt; _invoiceRequestDurationHistogram;public InvoiceMetrics(IMeterFactory meterFactory)
{
    // Omitted for brevity
    _invoiceRequestDurationHistogram = meter.CreateHistogram&lt;double&gt;("mywebapidemo.invoices.request_duration");
}
public void RecordRequestDuration(double duration)
{
    _invoiceRequestDurationHistogram.Record(duration);
}</pre>
<p>Then, update the <code>InvoiceController</code> class so that it records the request’s duration. Similarly, we <a id="_idIndexMarker1835"/>can just use the <code>RecordRequestDuration()</code> method in the controller. The following code shows how to update the <code>InvoiceController</code> class:</p>
<pre class="source-code">
[HttpGet("{id}")]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; Get(Guid id)
{
    var stopwatch = Stopwatch.StartNew();
    // Omitted for brevity
    // Simulate a latency
    await Task.Delay(_random.Next(0, 500));
    // Omitted for brevity
    stopwatch.Stop();
    _invoiceMetrics.RecordRequestDuration(stopwatch.Elapsed.TotalMilliseconds);
    return Ok(result);
}</pre>
<p>Here, we <a id="_idIndexMarker1836"/>use a <code>Task.Delay()</code> method to simulate latency. Run the application and send some requests to the <code>/api/Invoices</code> endpoint. Then, check the metrics using the <code>dotnet-counters</code> tool. You will see the metrics, as follows:</p>
<pre class="source-code">
Press p to pause, r to resume, q to quit.    Status: Running
[Microsoft.AspNetCore.Hosting]
    http.server.active_requests ({request})
        http.request.method=GET,url.scheme=https                           0
        http.request.method=POST,url.scheme=https                          0
    http.server.request.duration (s)
        http.request.method=GET,http.response.status_code=200,ht           0.075
        http.request.method=GET,http.response.status_code=200,ht           0.24
        http.request.method=GET,http.response.status_code=200,ht           0.24
        http.request.method=POST,http.response.status_code=201,h           0.06
        http.request.method=POST,http.response.status_code=201,h           0.06
        http.request.method=POST,http.response.status_code=201,h           0.06
[MyWebApiDemo.Invoice]
    mywebapidemo.invoices.created (Count / 1 sec)                          0
    mywebapidemo.invoices.read (Count / 1 sec)                             0
    mywebapidemo.invoices.request_duration
        Percentile=50                                                     74.25
        Percentile=95                                                    239.5
        Percentile=99                                                    239.5
    mywebapidemo.invoices.requests                                         0</pre>
<p>In the <a id="_idIndexMarker1837"/>preceding output, the histogram instruments are shown as <code>Percentile=50</code>, <code>Percentile=95</code>, and <code>Percentile=99</code>. This is the default configuration for the <code>dotnet-counters</code> tool. We can use other tools, such as Prometheus and Grafana, to provide more vis<a id="_idTextAnchor692"/>ualization<a id="_idIndexMarker1838"/> options. We will discuss this in the next section.</p>
<h3>Using Prometheus to collect and query metrics</h3>
<p><strong class="bold">Prometheus</strong> is a <a id="_idIndexMarker1839"/>widely used open-source monitoring system. Prometheus was <a id="_idIndexMarker1840"/>originally developed by SoundCloud (<a href="https://soundcloud.com/">https://soundcloud.com/</a>), then joined <a id="_idIndexMarker1841"/>the Cloud Native <a id="_idIndexMarker1842"/>Computing Foundation (<a href="https://cncf.io/">https://cncf.io/</a>) in 2016. Prometheus is capable of collecting metrics from a variety of sources, including applications, databases, operating systems, and more. It also offers a powerful query language for querying the collected metrics, as well as a dashboard to visualize them.</p>
<p>In this section, we <a id="_idIndexMarker1843"/>will use Prometheus to collect metrics from the ASP.NET Core web API application and visualize the metrics.</p>
<p>To <a id="_idIndexMarker1844"/>install Prometheus, navigate to the official website: <a href="https://prometheus.io/download/">https://prometheus.io/download/</a>. Download the latest version of Prometheus for your operating system.</p>
<p>Next, we need to configure the ASP.NET web API application to export metrics for Prometheus. Install the <code>OpenTelemetry.Exporter.Prometheus.AspNetCore</code> package in the ASP.NET Core web API project using the following command:</p>
<pre class="console">
dotnet add package OpenTelemetry.Exporter.Prometheus.AspNetCore --prerelease</pre> <p>Then, register <a id="_idIndexMarker1845"/>the Prometheus<a id="_idIndexMarker1846"/> exporter in the <code>Program.cs</code> file, as follows:</p>
<pre class="source-code">
builder.Services.AddOpenTelemetry()    .ConfigureResource(config =&gt;
    {
        config.AddService(nameof(MyWebApiDemo));
    })
    .WithMetrics(metrics =&gt;
    {
        metrics.AddAspNetCoreInstrumentation()
            .AddMeter("Microsoft.AspNetCore.Hosting")
            .AddMeter("Microsoft.AspNetCore.Server.Kestrel")
            .AddMeter("MyWebApiDemo.Invoice")
            .AddConsoleExporter()
            .AddPrometheusExporter();
    });
// Omitted for brevity
// Add the Prometheus scraping endpoint
app.MapPrometheusScrapingEndpoint();</pre>
<p>Now, we have two exporters: the console exporter and the Prometheus exporter. If you don’t need the console exporter, you can remove it. We’re also using the <code>MapPrometheusScrapingEndpoint()</code> method to map the <code>/metrics</code> endpoint for the Prometheus exporter. This endpoint is used by Prometheus to scrape metrics from the application.</p>
<p>Next, we need to <a id="_idIndexMarker1847"/>configure Prometheus to collect metrics from the ASP.NET Core web API application. Find the port number of the ASP.NET Core web API application. In the sample project, we use port number 5125 for HTTP. You can find the relevant port numbers in the <code>launchSettings.json</code> file.</p>
<p>Open the <code>prometheus.yml</code> file in the Prometheus folder. Add a job at the end of the file, as follows:</p>
<pre class="source-code">
<strong class="bold">- job_name: 'MyWebApiDemo'</strong><strong class="bold">  scrape_interval: 5s # Set the scrape interval to 5 seconds so we can see the metrics update immediately.</strong>
<strong class="bold">  static_configs:</strong>
<code>]</code></pre>
<p>The <code>scrape_interval</code> property is set to specify the interval at which metrics should be scrapped. For testing purposes, this can be set to 5 seconds so that you can view metrics<a id="_idIndexMarker1848"/> immediately. However, in production scenarios, it is recommended to set this to a higher value, such as 15 seconds. Additionally, ensure that the <code>targets</code> property is set to the correct port number before saving the file.</p>
<p>If you use HTTPS for the ASP.NET Core web API application, you need to specify the <code>schema</code> property, as follows:</p>
<pre class="source-code">
- job_name: 'MyWebApiDemo'  scrape_interval: 5s # Set the scrape interval to 5 seconds so we can see the metrics update immediately.
  scheme: https
  static_configs:
    - targets: ['localhost:7003']</pre>
<p>Run the application and send some requests to the <code>/api/Invoices</code> endpoint. Navigate to the <code>/metrics</code> endpoint; you will see the relevant metrics:</p>
<div><div><img alt="Figure 16.4 – Metrics for Prometheus" src="img/B18971_16_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Metrics for Prometheus</p>
<p>Now, we can<a id="_idIndexMarker1849"/> run Prometheus by executing the <code>prometheus.exe</code> file. In the output, you will find the following line:</p>
<pre class="source-code">
ts=2023-10-14T10:44:55.133Z caller=web.go:566 level=info component=web msg="Start listening for connections" address=0.0.0.0:9090</pre> <p>This means that Prometheus is running on port <code>9090</code>. Navigate to <code>http://localhost:9090</code>. You will see the Prometheus dashboard, as follows:</p>
<div><div><img alt="Figure 16.5 – Prometheus dashboard" src="img/B18971_16_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – Prometheus dashboard</p>
<p>Prometheus <a id="_idIndexMarker1850"/>will start to scrape metrics from the ASP.NET Core web API application we configured in the <code>prometheus.yml</code> file. Click <strong class="bold">Status</strong> | <strong class="bold">Targets</strong> at the top. You will see the following page, which shows the status of the ASP.NET Core web API application:</p>
<div><div><img alt="Figure 16.6 – Prometheus targets" src="img/B18971_16_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6 – Prometheus targets</p>
<p>Click <strong class="bold">Graph</strong> in<a id="_idIndexMarker1851"/> the top menu. You will see the following page, which shows the available metrics. Click the <strong class="bold">Open Metrics Explorer</strong> button (highlighted in <em class="italic">Figure 16</em><em class="italic">.7</em>) to open <strong class="bold">Metrics Explorer</strong>:</p>
<div><div><img alt="Figure 16.7 – Prometheus Metrics Explorer" src="img/B18971_16_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.7 – Prometheus Metrics Explorer</p>
<p>Choose one <a id="_idIndexMarker1852"/>metric, such as <code>mywebapidemo_invoices_read_total</code>, and click the <strong class="bold">Execute</strong> button. Then, click the <strong class="bold">Graph</strong> tab; you will see the following page, which shows the metric graph:</p>
<div><div><img alt="Figure 16.8 – Prometheus graph" src="img/B18971_16_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.8 – Prometheus graph</p>
<p>Prometheus<a id="_idIndexMarker1853"/> provides a powerful query language to query the metrics. For example, we can use the following query to get the <code>mywebapidemo.invoices.read</code> counter per minute:</p>
<pre class="source-code">
rate(mywebapidemo_invoices_read_total[1m])</pre> <p>You will <a id="_idIndexMarker1854"/>see the following graph:</p>
<div><div><img alt="Figure 16.9 – Requests per minute" src="img/B18971_16_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.9 – Requests per minute</p>
<p>The<a id="_idIndexMarker1855"/> following<a id="_idIndexMarker1856"/> query can get the requests that take longer than 100 milliseconds:</p>
<pre class="source-code">
histogram_quantile(0.95, sum(rate(mywebapidemo_invoices_request_duration_bucket[1m])) by (le)) &gt; 100</pre> <p><em class="italic">Figure 16</em><em class="italic">.10</em> shows the result:</p>
<div><div><img alt="Figure 16.10 – Requests that take longer than 100 milliseconds" src="img/B18971_16_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.10 – Requests that take longer than 100 milliseconds</p>
<p>This section<a id="_idIndexMarker1857"/> provided a <a id="_idIndexMarker1858"/>brief introduction to Prometheus. For more information about the querying language syntax, please refer to the official documentation: <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">https://prometheus.io/docs/prometheus/latest/querying/basics/</a>.</p>
<p>Prometheus is a powerful tool for collecting and querying metrics. To gain better visualization of these metrics, Grafana can be used to create dashboards. In the following section, we will explore how to use<a id="_idTextAnchor693"/> Grafana to read metrics from Prometheus and create informative dashboards.</p>
<h3>Using Grafana to create dashboards</h3>
<p><strong class="bold">Grafana</strong> is a <a id="_idIndexMarker1859"/>popular opensource<a id="_idIndexMarker1860"/> analytics and dashboarding tool. It can visualize metrics from <a id="_idIndexMarker1861"/>multiple data sources, such as Prometheus, Elasticsearch, Azure Monitor, and others. Grafana can create beautiful dashboards to help us understand the application’s performance and behavior. In this section, we will use Grafana to create dashboards for the ASP.NET Core web API application.</p>
<p>Grafana also provides a managed service <a id="_idIndexMarker1862"/>called <strong class="bold">Grafana Cloud</strong>. The free tier of Grafana Cloud has a limit of 10,000 metrics, 3 users, and 50 GB of logs. You can check the pricing here: <a href="https://grafana.com/pricing/">https://grafana.com/pricing/</a>. In this book, we will install Grafana locally. Download the latest version of Grafana from the official website: <a href="https://grafana.com/oss/grafana/">https://grafana.com/oss/grafana/</a>. Then, choose the version for your operating system.</p>
<p>Run Grafana by executing the <code>grafana-server.exe</code> file if you’re using Windows. You may see a Windows Security Alert dialog box. Click the <strong class="bold">Allow</strong> button to allow Grafana to communicate on these networks. You will find the following line in the output:</p>
<pre class="source-code">
INFO [10-15|12:31:31] Validated license token                  logger=licensing appURL=http://localhost:3000/ source=disk status=NotFound</pre> <p>This means that Grafana is running on port <code>3000</code>. Navigate to <code>http://localhost:3000</code>. The default username and password are both <code>admin</code>. Once you’ve logged in, you will be prompted to change the password.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The default theme of Grafana is dark. If you prefer a light theme, you can change it by going to the <strong class="bold">Preferences</strong> page. We’re using the light theme in this book for better readability.</p>
<p>Click <a id="_idIndexMarker1863"/>the <a id="_idIndexMarker1864"/>hamburger menu in the top-left corner, and then click <strong class="bold">Connections</strong>. This page shows the data sources that Grafana supports:</p>
<div><div><img alt="Figure 16.11 – Grafana data sources" src="img/B18971_16_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.11 – Grafana data sources</p>
<p>Search for <em class="italic">Prometheus</em> and click on it. Then, click the <strong class="bold">Create a Prometheus data source</strong> button<a id="_idIndexMarker1865"/> in the top-right corner. On the <strong class="bold">Settings</strong> page, we can configure the data source, as follows:</p>
<div><div><img alt="Figure 16.12 – Configuring the Prometheus data source" src="img/B18971_16_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.12 – Configuring the Prometheus data source</p>
<p>Use <code>http://localhost:9090</code> as the URL. Then, click the <code>Successfully queried the Prometheus API</code>. At this point, we can create dashboards to visualize the metrics.</p>
<p>Navigate to the <strong class="bold">Dashboards</strong> page and click the <strong class="bold">New</strong> button. From the drop-down list, click <strong class="bold">New Dashboard</strong>. You will be navigated to the new dashboard page. Click the <strong class="bold">Add visualization</strong> button, then choose Prometheus as the data source, as follows:</p>
<div><div><img alt="Figure 16.13 – Adding a visualization" src="img/B18971_16_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.13 – Adding a visualization</p>
<p>Then, we<a id="_idIndexMarker1868"/> can use the query language to <a id="_idIndexMarker1869"/>query the metrics. In the <code>mywebapidemo.invoices.read</code> requests for the <code>/</code><code>api/Invoices</code> endpoint:</p>
<div><div><img alt="Figure 16.14 – Querying the metrics" src="img/B18971_16_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.14 – Querying the metrics</p>
<p>Click the <strong class="bold">Run queries</strong> button; you will see the following output in the panel:</p>
<div><div><img alt="Figure 16.15 – Query result" src="img/B18971_16_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.15 – Query result</p>
<p>Then, click the <strong class="bold">Apply</strong> button; you will see the graph in the dashboard:</p>
<div><div><img alt="Figure 16.16 – Grafana dashboard" src="img/B18971_16_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.16 – Grafana dashboard</p>
<p>You can <a id="_idIndexMarker1870"/>adjust the size of the dashboard <a id="_idIndexMarker1871"/>as necessary. Feel free to add more dashboard panels to visualize the metrics. Before you leave the dashboard, click the <strong class="bold">Save</strong> button in the top-right corner to save it. You can also export the dashboard as a JSON file and import it later:</p>
<div><div><img alt="Figure 16.17 – Adding more panels" src="img/B18971_16_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.17 – Adding more panels</p>
<p>To simplify <a id="_idIndexMarker1872"/>the process of creating Grafana <a id="_idIndexMarker1873"/>dashboards, James Newton-King, the esteemed author of JSON.NET, has provided a Grafana dashboard template for ASP.NET Core web API applications. You can find the template here: <a href="https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md">https://github.com/JamesNK/aspnetcore-grafana/blob/main/README.md</a>. There are two dashboards in this repository:</p>
<ul>
<li><code>ASP.NET Core.json</code>: This dashboard shows an overview of the ASP.NET Core web API application</li>
<li><code>ASP.NET Core Endpoint.json</code>: This dashboard shows the details for specific endpoints</li>
</ul>
<p>Create a new dashboard and click the <code>ASP.NET Core.json</code> file or paste the content of the file into the textbox, as follows:</p>
<div><div><img alt="Figure 16.18 – Importing the dashboard" src="img/B18971_16_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.18 – Importing the dashboard</p>
<p>Click the <strong class="bold">Load</strong> button. On<a id="_idIndexMarker1874"/> the next page, choose<a id="_idIndexMarker1875"/> the Prometheus data source and click the <strong class="bold">Import</strong> button. You will see the following dashboard:</p>
<div><div><img alt="Figure 16.19 – ASP.NET Core dashboard provided by James Newton-King" src="img/B18971_16_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.19 – Overview of the ASP.NET Core dashboard provided by James Newton-King</p>
<p>This dashboard <a id="_idIndexMarker1876"/>provides an overview of the ASP.NET Core web API application. Here, you can see the number of requests, the request’s duration, the <a id="_idIndexMarker1877"/>number of active requests, and so on. You can also see the error rate, which is important for monitoring the application.</p>
<p><em class="italic">Figure 16</em><em class="italic">.20</em> shows the <strong class="bold">ASP.NET Core </strong><strong class="bold">Endpoint</strong> dashboard:</p>
<div><div><img alt="Figure 16.20 – The ASP.NET Core Endpoint dashboard provided by James Newton-King" src="img/B18971_16_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.20 – Overview of the ASP.NET Core Endpoint dashboard provided by James Newton-King </p>
<p>You can choose the endpoint from the drop-down list. Once you’ve done this, you will see the metrics for the endpoint. For example, <em class="italic">Figure 16</em><em class="italic">.20</em> shows the metrics for the <code>/</code><code>api/Invoices</code> endpoint.</p>
<p>Grafana offers many options to customize dashboards. On any dashboard panel, you can click the three dots in the top-right corner and then click <strong class="bold">Edit</strong> to edit the panel. You can change the title, the<a id="_idIndexMarker1878"/> visualization type, the query, and so on. You can also use the <strong class="bold">Builder</strong> or <strong class="bold">Code</strong> editor to edit the query, as shown in <em class="italic">Figure 16</em><em class="italic">.21</em> and <em class="italic">Figure 16</em><em class="italic">.22</em>, respectively. Here’s what the <strong class="bold">Builder</strong> editor looks like:</p>
<div><div><img alt="Figure 16.21 – Editing the query using the Builder editor" src="img/B18971_16_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.21 – Editing the query using the Builder editor</p>
<p>Here’s what<a id="_idIndexMarker1879"/> the <strong class="bold">Code</strong> editor looks like:</p>
<div><div><img alt="Figure 16.22 – Editing the query using the Code editor" src="img/B18971_16_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.22 – Editing the query using the Code editor</p>
<p>Grafana provides a better visualization of the metrics. You can learn more about Grafana by reading the official documentation: <a href="https://grafana.com/docs/grafana/latest/. ">https://grafana.com/docs/grafana/latest/.</a></p>
<p>In <a id="_idTextAnchor694"/>the next section, we will explore how to use OpenTelemetry and Jaeger to collect traces.</p>
<h3>Using Jaeger to collect traces</h3>
<p>Traces <a id="_idIndexMarker1880"/>are important for understanding how <a id="_idIndexMarker1881"/>requests are handled by the application. In a microservice<a id="_idIndexMarker1882"/> architecture, a request will be handled by multiple services. Distributed tracing can be used to track the flow of requests across multiple services. In this section, we will learn about the basic concepts of distributed tracing and how to use OpenTelemetry and Jaeger to collect traces.</p>
<p>For example, in a microservice architecture, service A calls service B, and service B calls service C and service D. When a client sends a request to service A, the request will be passed through service B, service C, and service D. In this case, if any of these services fails to process the request, or the request takes too long to process, we need to know which service is responsible for the failure and which part of the request contributes to the latency or errors. Distributed tracing can give us the big picture of how the request is processed by these services.</p>
<p>We have not discussed microservice architecture in detail in this book. To demonstrate distributed tracing, we added two web API projects to the sample project. You can find a controller named <code>OrdersController</code> in the <code>MyWebApiDemo</code> project. In this controller, we can call the <code>Post</code> action to create an order. The <code>Post</code> action will call two external services:</p>
<ul>
<li><code>CustomerService</code>: A service to check whether the customer exists</li>
<li><code>ProductService</code>: A service to check whether the product exists</li>
</ul>
<p>To create an order, we must ensure the customer ID is valid by calling the <code>/api/customers/{id}</code> endpoint of <code>CustomerService</code>. Additionally, we must verify that the products are valid by calling the <code>/api/products/{id}</code> endpoint of <code>ProductService</code>.</p>
<p>Note that these services are for demonstration purposes only and should not be used for production purposes. As such, there is no real database access layer; instead, a static list is used to store the temporary data. Additionally, there is no consideration for transaction and concurrency management.</p>
<p>First, let’s enable tracing in the <code>MyWebApiDemo</code> project. Open the <code>Program.cs</code> file and add the following code to the <code>MyWebApiDemo</code> project:</p>
<pre class="source-code">
builder.Services.AddOpenTelemetry()    .ConfigureResource(config =&gt;
    {
        config.AddService(nameof(MyWebApiDemo));
    })
    .WithMetrics(metrics =&gt;
    {
        // Omitted for brevity
    })
    .WithTracing(tracing =&gt;
    {
        tracing.AddAspNetCoreInstrumentation()
            .AddHttpClientInstrumentation()
            .AddConsoleExporter();
    });</pre>
<p>In the <a id="_idIndexMarker1883"/>preceding code, we enabled tracing in our<a id="_idIndexMarker1884"/> code using the <code>WithTracing</code> method. To further instrument our application, we added ASP.NET Core and HTTP client instrumentation. The HTTP client instrumentation is used to trace the HTTP calls to the external services. Finally, we added a console exporter to export the traces to the console.</p>
<p>Run the application and send some requests to the <code>api/orders</code> endpoint. You will see some tracing information in the terminal output:</p>
<p>In the <a id="_idIndexMarker1885"/>console trace, you will find two important <a id="_idIndexMarker1886"/>properties: <code>Activity.TraceId</code> and <code>Activity.SpanId</code>. The <code>Activity.TraceId</code> property is used to identify a trace, which is a collection of spans. A span is a unit of work in a trace. For example, if we send a <code>POST</code> request to the <code>api/Orders</code> endpoint to create an order, the application will call <code>ProductService</code> and <code>CustomerService</code>. Each call is a span. However, it is not convenient to search for a specific span in the console output. Next, we will use Jaeger to collect and visualize the traces.</p>
<p><strong class="bold">Jaeger</strong> is<a id="_idIndexMarker1887"/> an open-source distributed tracing platform that is used to monitor and troubleshoot distributed workflows and identify performance bottlenecks. Jaeger was originally developed by Uber Technologies (<a href="http://uber.github.io/">http://uber.github.io/</a>) and joined the Cloud Native Computing Foundation in 2017.</p>
<p>Install<a id="_idIndexMarker1888"/> Jaeger<a id="_idIndexMarker1889"/> from<a id="_idIndexMarker1890"/> the official website: <a href="https://www.jaegertracing.io/download/">https://www.jaegertracing.io/download/</a>. You can choose the version for your operating system or use the Docker image. In this book, we will use the executable binaries on Windows. Navigate to the Jaeger folder in the terminal and run the following command to start Jaeger:</p>
<pre class="console">
./jaeger-all-in-one --collector.otlp.enabled</pre> <p>The <code>jaeger-all-in-one</code> command is for quick local testing. It starts all the components of Jaeger, including the Jaeger UI, <code>jaeger-collector</code>, <code>jaeger-agent</code>, <code>jaeger-query</code>, and in-memory storage. The <code>--collector.otlp.enabled</code> option is used to specify that <code>jaeger-collector</code> should accept<a id="_idIndexMarker1891"/> traces in OTLP format. In the output, you can find the following line, which indicates that Jaeger is receiving data from OTLP:</p>
<pre class="source-code">
{"level":"info","ts":1697354213.8840668,"caller":"otlpreceiver@v0.86.0/otlp.go:83","msg":"Starting GRPC server","endpoint":"0.0.0.0:4317"}</pre> <p><code>jaeger-collector</code> utilizes port <code>4317</code> to receive data via the gRPC protocol and port <code>4318</code> via the HTTP protocol. This allows for efficient communication between <code>jaeger-collector</code> and other services.</p>
<p>Next, we need to configure the ASP.NET Core web API project so that it exports the OTLP traces to Jaeger. Open the <code>Program.cs</code> file and update the <code>WithTracing()</code> method, as follows:</p>
<pre class="source-code">
.WithTracing(tracing =&gt;{
    tracing.AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter()
        .AddOtlpExporter(options =&gt;
        {
            options.Endpoint = new Uri("http://localhost:4317");
        });
});</pre>
<p>We use the <code>AddOtlpExporter</code> method to add the exporter for Jaeger. As a best practice, it is<a id="_idIndexMarker1892"/> recommended to use the configuration system to set the URL, rather than hard-coding it. As an example, you can define it in the <code>appsettings.json</code> file.</p>
<p>Restart the three <a id="_idIndexMarker1893"/>applications and send some <code>POST</code> requests to the <code>/api/Orders</code> endpoint. Here is a payload example:</p>
<pre class="source-code">
{  "id": 0,
  "orderNumber": "string",
  "contactName": "string",
  "description": "string",
  "amount": 0,
  "customerId": 1,
  "orderDate": "2023-10-15T08:57:54.724Z",
  "dueDate": "2023-10-15T08:57:54.724Z",
  "orderItems": [
    {
      "id": 1,
      "orderId": 0,
      "productId": 1,
      "quantity": 0,
      "unitPrice": 0
    }
  ],
  "status": 0
}</pre>
<p>Navigate to <code>http://localhost:16686/</code>; you will see the Jaeger UI. In the <strong class="bold">Search</strong> tab, choose <strong class="bold">Service</strong>, then <strong class="bold">Operation</strong>, and then <a id="_idIndexMarker1894"/>click the <strong class="bold">Find Traces</strong> button. You will see the<a id="_idIndexMarker1895"/> traces, as shown here:</p>
<div><div><img alt="Figure 16.23 – Jaeger traces" src="img/B18971_16_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.23 – Jaeger traces</p>
<p>Click on a trace to view its details:</p>
<div><div><img alt="Figure 16.24 – A trace’s details" src="img/B18971_16_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.24 – A trace’s details</p>
<p>You will see <a id="_idIndexMarker1896"/>that this request includes three spans. The<a id="_idIndexMarker1897"/> parent is the inbound request, and it has two outbound requests to other services.</p>
<p>We can enable traces in the dependent services to better understand how these requests are processed. Configure <code>ProductService</code> and <code>CustomerService</code> following the same methods. These traces should be sent to one Jaeger instance so that Jaeger can correlate the requests across different services.</p>
<p>Check the Jaeger UI now. You will find that one <code>/api/Orders</code> call has five spans now:</p>
<div><div><img alt="Figure 16.25 – The traces across multiple services" src="img/B18971_16_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.25 – The traces across multiple services</p>
<p>We can also check the latency for each span, as shown in <em class="italic">Figure 16</em><em class="italic">.26</em>:</p>
<div><div><img alt="Figure 16.26 – The latency for each span" src="img/B18971_16_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.26 – The latency for each span</p>
<p>Using traces <a id="_idIndexMarker1898"/>can help us understand how <a id="_idIndexMarker1899"/>requests are handled by the application. We can also use traces to find performance bottlenecks. It is especially useful for microservice architectures. For more information about Jaeger, please refer to the official<a id="_idIndexMarker1900"/> documentation: <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter16/MyWebApiDemo</a>.</p>
<p>Next, we will recap logging and discuss how to propagate the trace context in the logs.</p>
<h3>Using HTTP logging</h3>
<p>In <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a>, we <a id="_idIndexMarker1901"/>discussed how to use the <code>ILogger</code> interface to<a id="_idIndexMarker1902"/> log messages. Sometimes, we want to log the HTTP requests and responses for troubleshooting purposes. In this section, we will discuss HTTP logging.</p>
<p>Follow <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a> to configure the logging system. You can use Serilog to send logs to Seq. To enable HTTP logging, we need to use the HTTP logging middleware. The middleware will log the inbound requests and outbound responses. The updated code is as follows:</p>
<pre class="source-code">
var logger = new LoggerConfiguration().WriteTo.Seq("http://localhost:5341").CreateLogger();builder.Logging.AddSerilog(logger);
builder.Services.AddHttpLogging(logging =&gt;
{
    logging.LoggingFields = HttpLoggingFields.All;
});
// Omitted for brevity
app.UseHttpLogging();</pre>
<p>In the<a id="_idIndexMarker1903"/> preceding code, we specify <code>HttpLoggingFields</code> to log all fields. Be careful when you use this option in production because<a id="_idIndexMarker1904"/> it may potentially impact the performance and log sensitive information. We should not log <strong class="bold">personally identifiable information</strong> (<strong class="bold">PII</strong>) and <a id="_idIndexMarker1905"/>any sensitive information. We’re using it for demonstration purposes only here.</p>
<p>We can also update the <code>appsettings.json</code> file to specify the log levels. Add the following code to the <code>LogLevel</code> section of the <code>appsettings.json</code> file so that we can see information logs:</p>
<pre class="source-code">
"Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware": "Information"</pre> <p>Configure the logging in the <code>CustomerService</code> and <code>ProductService</code> projects using the same methods.</p>
<p>Run the three applications and send some requests to the <code>/api/Orders</code> endpoint. You will see the following logs in the Seq dashboard:</p>
<div><div><img alt="Figure 16.27 – HTTP logging" src="img/B18971_16_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.27 – HTTP logging</p>
<p>In the logs, you will find <a id="_idIndexMarker1906"/>details about the HTTP requests and responses. If you want to change the logging fields, you can change the <code>LoggingFields</code> property of <code>HttpLoggingOptions</code> in the <code>AddHttpLogging()</code> method. The <code>LoggingFields</code> property is an enum. You can choose <code>RequestPath</code>, <code>RequestQuery</code>, <code>RequestMethod</code>, <code>RequestStatusCode</code>, <code>RequestBody</code>, <code>RequestHeaders</code>, <code>ResponseHeaders</code>, <code>ResponseBody</code>, <code>Duration</code>, and so on. The <code>HttpLoggingOptions</code> class has other properties, such as <code>RequestHeaders</code>, <code>ResponseHeaders</code>, <code>RequestBodyLogLimit</code>, <code>ResponseBodyLogLimit</code>, and others. You <a id="_idIndexMarker1907"/>can use these properties to configure the logging system.</p>
<p>Since we enabled HTTP logging for all requests, we can filter the logs by trace ID. Check the Jaeger UI and click on a trace. You will find the trace ID in the URL:</p>
<div><div><img alt="Figure 16.28 – The trace ID in Jaeger" src="img/B18971_16_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.28 – The trace ID in Jaeger</p>
<p>In the preceding screenshot, the trace ID is <code>8c7ab3bccf13135f27baf11c161e17ca</code>. Copy this trace ID and use the following query in the Seq dashboard:</p>
<pre class="source-code">
@TraceId = '8c7ab3bccf13135f27baf11c161e17ca'</pre> <p>Click the green <strong class="bold">Go</strong> button to filter the logs. You will see the logs for this trace:</p>
<div><div><img alt="Figure 16.29 – Filtering the logs by trace ID" src="img/B18971_16_29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.29 – Filtering the logs by trace ID</p>
<p><em class="italic">Figure 16</em><em class="italic">.29</em> provides<a id="_idIndexMarker1908"/> a comprehensive view of all the logs for the<a id="_idIndexMarker1909"/> trace, in<a id="_idTextAnchor695"/>cluding HTTP requests and responses for three services. This is an invaluable resource for troubleshooting.</p>
<h3>Using Azure Application Insights</h3>
<p>In the <a id="_idIndexMarker1910"/>preceding sections, we explored how<a id="_idIndexMarker1911"/> to use OpenTelemetry to collect metrics and traces. We also discussed how to leverage open-source tools such as Prometheus, Grafana, Jaeger, and Seq to visualize the metrics, traces, and logs. Now, we’ll look at how to use Azure Application Insights to create a unified dashboard for monitoring an ASP.NET Core web API application.</p>
<p>Azure Application Insights is an extensible APM service for monitoring applications. It can collect and analyze logs, metrics, and traces from multiple sources. To follow this section, you need to have an Azure subscription. If you do not have one, you can create a free account here: <a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a>.</p>
<p>Go to the<a id="_idIndexMarker1912"/> Azure <a id="_idIndexMarker1913"/>portal and create a new Application Insights resource. You can find the Application Insights service in the <strong class="bold">Monitoring</strong> category. Choose the <strong class="bold">Application Insights</strong> service and click the <strong class="bold">Create</strong> button. On the next page, you need to specify the resource group, name, region, and pricing tier, as shown in <em class="italic">Figure 16</em><em class="italic">.30</em>:</p>
<div><div><img alt="Figure 16.30 – Creating an Application Insights resource" src="img/B18971_16_30.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.30 – Creating an Application Insights resource</p>
<p>Once the <a id="_idIndexMarker1914"/>Application Insights resource has been created, navigate<a id="_idIndexMarker1915"/> to the <strong class="bold">Overview</strong> page. You will find the <strong class="bold">Instrumentation Key</strong> and <strong class="bold">Connection String</strong> values. <strong class="bold">Instrumentation Key</strong> is used to identify the Application Insights resource, while <strong class="bold">Connection String</strong> is used to connect to the Application Insights resource. We will use <strong class="bold">Connection String</strong> to configure the ASP.NET Core web API applications.</p>
<p>Open the <code>appsettings.json</code> file in the <code>MyWebApiDemo</code> project. Add the following setting:</p>
<pre class="source-code">
"APPLICATIONINSIGHTS_CONNECTION_STRING": "InstrumentationKey=xxxxx"</pre> <p>Please replace <a id="_idIndexMarker1916"/>the connection string with your<a id="_idIndexMarker1917"/> own value. This is for demonstration purposes only. It is recommended to use different Application Insights resources for different environments. This will ensure that metrics and traces are not mixed.</p>
<p>Next, we need to install the <code>Azure.Monitor.OpenTelemetry.AspNetCore</code> package using the following command:</p>
<pre class="console">
dotnet add package Azure.Monitor.OpenTelemetry.AspNetCore --prerelease</pre> <p>This package is used to export metrics and traces to Azure Application Insights. At the time of writing, the package was still in preview. If you are reading this book after the package has been released, you can omit the <code>--</code><code>prerelease</code> option.</p>
<p>Then, update the <code>Program.cs</code> file, as follows:</p>
<pre class="source-code">
<code>builder.Services.AddOpenTelemetry()</code><code>    // Omitted for brevity</code>
<code>    .UseAzureMonitor()</code></pre>
<p>This method will read the <code>APPLICATIONINSIGHTS_CONNECTION_STRING</code> setting from the configuration system and export the metrics and traces to Azure Application Insights.</p>
<p>Configure the <code>CustomerService</code> and <code>ProductService</code> projects using the same methods. Run the three applications and send some <code>POST</code> requests to the <code>/api/Orders</code> endpoint. Then, navigate to the Application Insights resource in the Azure portal. You will see the following output:</p>
<div><div><img alt="Figure 16.31 – Azure Application Insights" src="img/B18971_16_31.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.31 – Overview of Azure Application Insights</p>
<p>You can <a id="_idIndexMarker1918"/>find even more information<a id="_idIndexMarker1919"/> about logs, metrics, and traces. Click the <strong class="bold">Logs</strong> tab; you will see the following page:</p>
<div><div><img alt="Figure 16.32 – Azure Application Insights logs" src="img/B18971_16_32.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.32 – Azure Application Insights logs</p>
<p>In <em class="italic">Figure 16</em><em class="italic">.32</em>, we use <code>requests | where url !contains "metrics"</code> to query the logs. This query will filter the logs that do not contain the <code>metrics</code> keyword. You can also use <code>traces</code> to query the traces.</p>
<p>The <strong class="bold">Metrics</strong> tab shows the available metrics, as follows:</p>
<div><div><img alt="Figure 16.33 – Azure Application Insights metrics" src="img/B18971_16_33.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.33 – Azure Application Insights metrics</p>
<p>Here, you<a id="_idIndexMarker1920"/> can <a id="_idIndexMarker1921"/>find the metrics we defined for the <code>api/Invoices</code> endpoint. If you cannot see the metrics, send some requests to the <code>api/Invoices</code> endpoint and wait a few minutes.</p>
<p>Click the <strong class="bold">Application map</strong> tab; you will see the following page:</p>
<div><div><img alt="Figure 16.34 – Azure Application Insights application map" src="img/B18971_16_34.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.34 – Overview of the Azure Application Insights application map </p>
<p><em class="italic">Figure 16</em><em class="italic">.34</em> shows the<a id="_idIndexMarker1922"/> requests flow across multiple services. You can also find the latency for each service.</p>
<p>Upon clicking any <a id="_idIndexMarker1923"/>request in the diagram, you will see details such as the response time, dependency count, performance histogram, and dependencies, as follows:</p>
<div><div><img alt="Figure 16.35 – Azure Application Insights request details" src="img/B18971_16_35.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.35 – Overview of Azure Application Insights request details</p>
<p>Click the <strong class="bold">Performance</strong> tab; you <a id="_idIndexMarker1924"/>will see the overall <a id="_idIndexMarker1925"/>performance of the application:</p>
<div><div><img alt="Figure 16.36 – Azure Application Insights performance" src="img/B18971_16_36.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.36 – Overview of Azure Application Insights performance</p>
<p>Clicking on one operation, such as <code>POST api/Orders</code>, will allow you to view the performance of that operation. For further details, click the <strong class="bold">xx Samples</strong> button located under the <strong class="bold">Drill into...</strong> label in the bottom-right corner. You will see a list of all the requests for that operation on the right-hand side of the screen. Clicking on one of these requests will allow you to view the details of that request, including the request and response body, as shown in <em class="italic">Figure 16</em><em class="italic">.37</em>:</p>
<div><div><img alt="Figure 16.37 – Azure Application Insights end-to-end transaction details" src="img/B18971_16_37.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.37 – Azure Application Insights end-to-end transaction details</p>
<p>In <em class="italic">Figure 16</em><em class="italic">.37</em>, you <a id="_idIndexMarker1926"/>can see how the request is processed by <a id="_idIndexMarker1927"/>multiple services, similar to what the Jaeger UI does.</p>
<p>Azure Application Insights is a super powerful tool for monitoring applications. The benefits of using <a id="_idIndexMarker1928"/>Azure Application Insights are as follows:</p>
<ul>
<li>It is a managed service. You do not need to maintain the infrastructure.</li>
<li>It provides a unified dashboard for monitoring applications. You do not need to use multiple tools. Application Insights can provide a centralized view of the metrics, traces, and logs.</li>
<li>It is easy to integrate with your applications. Configuring one connection string is much easier than configuring multiple tools.</li>
<li>It provides a powerful query language to query metrics, traces, and logs. You can use the query language to create custom dashboards.</li>
<li>It offers more features, such as alerting, failure analysis, funnel analysis, user flows, and so on.</li>
</ul>
<p>Note that Azure Application Insights is not free. It is part of Azure Monitor, a comprehensive monitoring solution f<a id="_idTextAnchor696"/>or enterprise applications. You can find its pricing here: <a href="https://azure.microsoft.com/en-us/pricing/details/monitor/">https://azure.microsoft.com/en-us/pricing/details/monitor/</a>.</p>
<h1 id="_idParaDest-362"><a id="_idTextAnchor697"/>Summary</h1>
<p>In this chapter, we discussed monitoring and observability in ASP.NET Core web API applications. We explored how to handle errors and exceptions and return proper error responses. We also discussed how to implement health checks to determine the status of the application. Then, we learned about the basic concepts of observability, including logs, metrics, and traces, and how to integrate with OpenTelemetry and define custom metrics. We also explored some open-source tools, such as Prometheus, Grafana, Jaeger, and Seq, to collect and visualize metrics, traces, and logs. Finally, we introduced Azure Application Insights, a managed service for monitoring applications in one place.</p>
<p>Monitoring and observability are complex topics that require a deeper understanding of distributed systems and microservice architecture. In this chapter, we only introduced the basic concepts. To gain a more comprehensive understanding of these topics, further study is necessary.</p>
<p>In the next chapter, we will explore advanced topics related to architecture and design patterns. These include <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>), clean architecture, and cloud-native patterns such as CQRS, resilience patterns, and more. This will provide you with a comprehensive overview of the various approaches to architecture and design.</p>
</div>
</body></html>