- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Microservice Container Hosting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务容器托管
- en: Once we have completed a fair amount of development, our next major concern
    is **hosting**. Hosting comes with its own set of problems because there are many
    options, and the pros and cons of these options are relative to the application’s
    architecture and overall needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了一定量的开发工作，我们接下来的主要关注点是**托管**。托管带来了一系列问题，因为有许多选项，而这些选项的优缺点与应用程序的架构和整体需求相关。
- en: Typical hosting options for a web application would be a simple server and a
    singular point of entry to that server via an IP address or domain name. Now,
    we are building a microservices application where we pride ourselves on the fact
    that we can promote loose coupling and have all the parts of our application act
    autonomously and without direct dependency on each other. The challenge now becomes
    how we cater to a potentially heterogeneous application. Each service is autonomous
    and might have varied hosting and database requirements. We would then need to
    consider creating specific hosting environments for each technology, which can
    lead to massive cost implications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，典型的托管选项可能是一个简单的服务器，以及通过IP地址或域名进入该服务器的单一入口点。现在，我们正在构建一个微服务应用程序，我们引以为豪的是我们可以促进松散耦合，并且我们的应用程序的所有部分都可以独立运行，无需直接依赖彼此。现在的挑战是如何满足一个可能异构的应用程序。每个服务都是独立的，可能具有不同的托管和数据库需求。然后我们需要考虑为每种技术创建特定的托管环境，这可能导致巨大的成本影响。
- en: This is where we can take advantage of container hosting technologies and minimize
    the cost overheads of having several server machines. We can use containers as
    scaled-down imitations of the minimum hosting requirements for each technology
    and database that is being used in the microservices architecture, and we can
    configure endpoints by which each container can be accessed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们可以利用容器托管技术并最小化拥有多台服务器机器的成本超支的地方。我们可以使用容器作为每个正在使用的微服务架构中技术和数据库的最小托管要求的缩小版模仿，并且我们可以配置端点，通过这些端点可以访问每个容器。
- en: In this chapter, we will review how containers work, how they can benefit us,
    and why they are an essential tool for efficiently hosting a microservices application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾容器的工作原理，它们如何为我们带来好处，以及为什么它们是高效托管微服务应用程序的必备工具。
- en: 'We will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understand the use of Docker and containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Docker和容器的作用
- en: Learn how to use Dockerfiles and commands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Dockerfile和命令
- en: Learn how to use `docker-compose` and orchestrate Docker images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`docker-compose`并编排Docker镜像
- en: Learn how to deploy a microservices application in containers and to a container
    registry
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在容器中部署微服务应用程序并将其部署到容器注册库
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at this URL: [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch13](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch13).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在GitHub上的项目仓库中找到，网址为：[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch13](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch13)。
- en: Using containers in microservices development
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在微服务开发中使用容器
- en: Containers are all the rage in the development space. They present us with a
    lightweight application hosting option that allows us to deploy our applications
    in a clean and repeatable manner. They are not new, but their use in more commercial
    and accessible spaces has been made far more popular in recent years. What, however,
    is a container, and why should we care about how it works? Let us review that
    next.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在开发领域非常流行。它们为我们提供了一个轻量级的应用程序托管选项，使我们能够以干净和可重复的方式部署我们的应用程序。虽然它们不是新事物，但近年来在更商业化和易于访问的空间中的应用使得它们变得更加流行。然而，什么是容器，我们为什么应该关心它是如何工作的呢？让我们在下一节中回顾一下。
- en: What can containers do for me?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器能为我做什么？
- en: Traditionally speaking, whenever we have applications that have specific requirements
    for environments and software, we would resort to using servers to facilitate
    the requirements. The problem with servers and servers per application is that
    they come with costs. A server machine is generally not cheap, and then we must
    also factor in licensing and energy costs when new machines are introduced. Also,
    consider that if a machine goes down, we will need to reconfigure that machine
    to the original environmental specifications and reprovision several aspects of
    the original deployment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从传统意义上讲，每当我们的应用程序对环境和软件有特定要求时，我们就会求助于使用服务器来满足这些要求。服务器和每个应用程序的服务器的问题是它们带有成本。服务器机器通常不便宜，而且当我们引入新机器时，我们还必须考虑许可和能源成本。此外，考虑到如果一台机器出现故障，我们需要重新配置该机器以符合原始环境规格，并重新配置原始部署的几个方面。
- en: At this point, we begin to think about virtualization. This means that we now
    use **virtual machines** (**VMs**) for new servers and reuse the old infrastructure.
    This will go a long way in reducing the physical infrastructure requirements and
    costs and allow us to scale a bot more easily. We can also use snapshots of the
    machines to keep a quick recovery plan up our sleeves in times of failure. There
    are several virtualization solutions on the market, including popular ones such
    as **VMware, VirtualBox, and Microsoft Hyper-V**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们开始考虑虚拟化。这意味着我们现在使用**虚拟机**（**VMs**）来构建新服务器并重用旧基础设施。这将大大减少物理基础设施需求和成本，并使我们更容易扩展机器人。我们还可以使用机器的快照来在失败时保持一个快速的恢复计划。市场上有多款虚拟化解决方案，包括流行的如**VMware、VirtualBox和Microsoft
    Hyper-V**。
- en: '*Figure 13.1* shows a server with several VMs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13.1* 展示了一台服务器上有多个虚拟机：'
- en: '![Figure 13.1 – One machine is required to support multiple VMs on top of a
    hypervisor](img/Figure_13.1_B19100.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 一台机器需要支持在虚拟机管理程序上运行多个虚拟机](img/Figure_13.1_B19100.jpg)'
- en: Figure 13.1 – One machine is required to support multiple VMs on top of a hypervisor
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 一台机器需要支持在虚拟机管理程序上运行多个虚拟机
- en: 'This visualization approach seems like the silver bullet we need, except we
    have found more problems with this solution, which are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化方法看起来像是我们需要的那根救命稻草，但我们发现这个解决方案还有更多问题，如下所示：
- en: We will still need to factor in that we need very powerful machines to be able
    to handle multiple VMs
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍然需要考虑我们需要非常强大的机器来处理多个虚拟机
- en: We will still have the manual maintenance tasks required to keep our environments
    and operating systems up to date and secure
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍然需要进行手动维护任务，以保持我们的环境和操作系统更新和安全
- en: We must remember that there are several situations where we attempt to provision
    the same environment on different installations and encounter unforeseen differences
    each time
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须记住，在几种情况下，我们试图在不同的安装上配置相同的环境，但每次都会遇到预料之外的不同
- en: We cannot always rely on the machine environment to remain consistent with each
    instance
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能总是依赖机器环境与每个实例保持一致
- en: Now, this brings us to the most recent solution to this problem, which is containers.
    Containers build on the concept given to us VMs and allow us to downsize the overall
    space and resource requirements that an application might need. The use of containers
    to host our applications is called **containerization**—this is an approach in
    modern software development that allows us to package an application and all its
    dependencies and create a repeatable, testable, and reliable package called an
    **image**. This image can then be deployed directly to several places in a consistent
    way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这带我们来到了这个问题的最新解决方案，即容器。容器建立在为我们提供的虚拟机（VMs）的概念之上，使我们能够减少应用程序可能需要的整体空间和资源需求。使用容器来托管我们的应用程序被称为**容器化**——这是一种现代软件开发方法，允许我们将应用程序及其所有依赖项打包，创建一个可重复、可测试和可靠的包，称为**镜像**。然后，这个镜像可以直接以一致的方式部署到多个地方。
- en: This consistency is very important in how we distinguish the benefits of containers
    from VMs. We just reviewed that we cannot always be sure that each **operating
    system** (**OS**) instance of a server or VM will be the same. Containers strip
    away many of the variables that we contend with during deployments and provide
    an environment that is specifically tuned for the application that needs to be
    deployed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一致性对于我们在容器和虚拟机之间区分容器的好处非常重要。我们刚刚回顾了，我们并不能总是确信服务器或虚拟机的每个**操作系统**（**OS**）实例都是相同的。容器去除了我们在部署过程中所面临的许多变量，并为需要部署的应用程序提供了一个专门调优的环境。
- en: '*Figure 13.2* shows a server with several containers and apps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.2* 展示了一个服务器上有几个容器和应用程序：'
- en: '![Figure 13.2 – One machine can host several container apps and make better
    use of its resources](img/Figure_13.2_B19100.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 一台机器可以托管多个容器应用程序并更好地利用其资源](img/Figure_13.2_B19100.jpg)'
- en: Figure 13.2 – One machine can host several container apps and make better use
    of its resources
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 一台机器可以托管多个容器应用程序并更好地利用其资源
- en: Another benefit, as seen in *Figure 13.2*, is that we can now maximize the resource
    usage of a physical server since we no longer need to provide a set amount of
    RAM, CPU, and storage for entire instances of operating systems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处，如*图13.2* 所示，是我们现在可以最大化物理服务器的资源利用率，因为我们不再需要为整个操作系统的实例提供固定数量的RAM、CPU和存储。
- en: Containers also provide isolation from each other on a shared operating system,
    so we do not need to worry about heterogenous requirements across containers.
    In simpler terms, it will be acceptable to run one container in a Linux environment
    alongside one that needs a Windows-based environment. Using containers will make
    our applications more scalable and reliable. We can easily provision new instances
    of containers as needed and run multiple identical instances.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还可以在共享操作系统上相互隔离，因此我们无需担心容器之间的异构需求。用简单的话说，在Linux环境中运行一个容器的同时，也可以运行需要基于Windows环境的容器。使用容器可以使我们的应用程序更具有可扩展性和可靠性。我们可以根据需要轻松地配置新的容器实例，并运行多个相同的实例。
- en: There is a major security risk in using VMs that need to communicate with each
    other. They generate metadata files that contain very sensitive information about
    the data being exchanged and how it is exchanged. With this information, an attacker
    could seek to replay operations and insert malicious information into the mix.
    Containers do not transfer this risk and will support inter-container communication
    in a far more secure manner.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用需要相互通信的虚拟机存在一个主要的安全风险。它们生成包含关于正在交换的数据及其交换方式非常敏感信息的元数据文件。有了这些信息，攻击者可能会试图重放操作并在其中插入恶意信息。容器不会转移这种风险，并将以更安全的方式支持容器间的通信。
- en: Containers are not new, but they are becoming more and more popular for hosting
    isolated operations in consumer applications and improving efficiency for applications
    deployed to less powerful machines. To use containers, we need a container hosting
    solution such as Docker. We will review how we can get started with Docker and
    containers next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 容器并不新鲜，但它们正变得越来越流行，用于托管消费者应用程序中的隔离操作并提高部署到较不强大机器上的应用程序的效率。要使用容器，我们需要一个容器托管解决方案，如Docker。我们将在下一节中回顾如何开始使用Docker和容器。
- en: Understanding Docker
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Docker
- en: Before we dive into Docker and how it works, it is noteworthy that Docker is
    not the only application that handles containerization. There are several alternatives
    that follow the same **Open Container Initiative** (**OCI**) standards and allow
    us to containerize our applications. Docker, however, revolutionized and propelled
    containerization into mainstream access and exposure. It is a free (for development
    and open source) application that is available cross-platform and allows us to
    version control our containers and generally manage several container instances
    through either a **user interface** (**UI**) or a **command-line interface** (**CLI**).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨Docker及其工作原理之前，值得注意的是，Docker并不是唯一处理容器化的应用程序。有几个遵循相同**开放容器倡议**（**OCI**）标准的替代方案，允许我们容器化我们的应用程序。然而，Docker革命性地推动了容器化进入主流领域和曝光。它是一个免费（用于开发和开源）的应用程序，可在跨平台上使用，并允许我们通过**用户界面**（**UI**）或**命令行界面**（**CLI**）对容器进行版本控制并管理多个容器实例。
- en: Docker’s engine has a client-server implementation style, where both client
    and server run on the same hardware. The client is a CLI, and it interacts with
    the server via a REST API to send instructions and execute functions. The Docker
    server is a background job, or daemon, called `dockerd`. It is responsible for
    tracking the life cycle of our containers. We also have objects that need to be
    created and configured to support deployments. These objects can be networks,
    storage volumes, and plugins, to name a few. We create these objects on a case-by-case
    basis and deploy them as needed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的引擎采用客户端-服务器实现风格，客户端和服务器都运行在同一硬件上。客户端是一个命令行界面（CLI），它通过REST API与服务器交互，发送指令并执行功能。Docker服务器是一个后台任务，或称为守护进程，称为`dockerd`。它负责跟踪我们容器的生命周期。我们还需要创建和配置一些对象来支持部署。这些对象可以是网络、存储卷和插件等，仅举几例。我们会根据具体情况创建这些对象，并在需要时部署它们。
- en: So, let’s recap a bit. A container is a self-contained space that is prepared
    to host one application at a time. The definition of a container’s environment
    and dependencies is called an image. This image is a consistent blueprint for
    what the environment needs to look like. Images exist for several third-party
    applications as well, and this makes it easy for us to spin up an instance. It
    is good to have a central repository for images, and Docker provides *Docker Hub*
    for this reason.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们简要回顾一下。容器是一个自包含的空间，一次可以容纳一个应用程序。容器环境及其依赖的定义被称为镜像。这个镜像是一致的蓝图，描述了环境需要呈现的样子。为多个第三方应用程序也存在镜像，这使得我们能够轻松启动实例。拥有一个中央镜像仓库是件好事，Docker正是出于这个原因提供了*Docker
    Hub*。
- en: Docker Hub is a container registry that stores and distributes container images.
    We can use it to host our own images, and there is a public space for generally
    available and shared images for industry-leading applications. Note—Docker Hub
    is not the only registry. There are alternatives such as Microsoft **Azure Container
    Registry** (**ACR**), which allows us to integrate with other Azure services more
    seamlessly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是一个容器注册库，用于存储和分发容器镜像。我们可以用它来托管自己的镜像，并且有一个公共空间，用于存储和共享行业领先应用程序的通用和共享镜像。注意——Docker
    Hub不是唯一的注册库。还有其他替代方案，例如微软的**Azure Container Registry**（**ACR**），它允许我们与其他Azure服务更无缝地集成。
- en: We have mentioned container images a few times now. Let us discuss them a bit
    more in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到了容器镜像。让我们在下一节中更详细地讨论它们。
- en: Understanding container images
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解容器镜像
- en: A container image, as mentioned before, is a blueprint for the contents of a
    container. It is a portable package that materializes as an in-memory instance
    of a container. A key feature is that images are immutable. Once we have defined
    the image, it cannot be changed. Each container that is based on the image, or
    a specific version of that image, will be the same. This helps us to guarantee
    that the environment that worked in development and staging will be present in
    production. No longer will we need the *it worked on my machine* excuse during
    deployments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，容器镜像是一个容器内容的蓝图。它是一个可携带的包，表现为容器的一个内存实例。一个关键特性是镜像不可变。一旦我们定义了镜像，它就不能被更改。基于该镜像或该镜像特定版本的每个容器都将相同。这有助于我们保证在开发和预发布环境中工作过的环境将在生产环境中存在。在部署过程中，我们不再需要“在我的机器上它工作过”的借口。
- en: A base image is an image that acts as a foundation for other images. It starts
    off using Docker’s scratch image, which is an empty container image that does
    not create a filesystem layer. This means that the image assumes that the application
    we will be running will run directly from the operating system’s kernel.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像是一个作为其他镜像基础的镜像。它从Docker的scratch镜像开始，这是一个不创建文件系统层的空容器镜像。这意味着该镜像假定我们将运行的应用程序将直接从操作系统的内核运行。
- en: A parent image is a container image that is a foundational image for other images.
    It is usually based on an operating system and will host an application that is
    designed to run on that operating system. For instance, we might need a Redis
    cache instance on our machine. This Redis cache image will be based on Linux.
    That is the parent image.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 父镜像是一个作为其他镜像基础镜像的容器镜像。它通常基于操作系统，并将托管一个设计在操作系统上运行的应用程序。例如，我们可能在我们的机器上需要一个Redis缓存实例。这个Redis缓存镜像将基于Linux。这就是父镜像。
- en: In both cases, the images are reusable, but base images allow us to have more
    control over the final image. We can always add to the image, but we cannot subtract,
    since images are immutable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，镜像都是可重用的，但基础镜像使我们能够对最终镜像有更多的控制。我们总是可以向镜像中添加内容，但不能从中删除，因为镜像是不可变的。
- en: Docker Hub is a reliable and secure registry of popular and in-demand container
    images that can easily be pulled onto your machine. The Docker CLI provides a
    direct connection to Docker Hub, and with a few commands, we can pull images to
    the host machine from which it was executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是一个可靠的、安全的容器镜像注册中心，其中包含流行的和需求量大的容器镜像，可以轻松地拉取到您的机器上。Docker CLI提供了与Docker
    Hub的直接连接，通过几个命令，我们可以将镜像从执行它的主机机器上拉取。
- en: 'If we were to set up a Redis cache container, we could do so with a few simple
    steps. First, we should install Docker on our device, which you can get from [www.docker.com](https://www.docker.com).
    Once it is installed, we can proceed to run the following command in our CLI:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要设置一个Redis缓存容器，我们可以通过几个简单的步骤来完成。首先，我们应该在我们的设备上安装Docker，您可以从[www.docker.com](https://www.docker.com)获取。一旦安装完成，我们就可以在我们的命令行界面中运行以下命令：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will pull the latest Redis cache application image from the Docker Hub
    registry and create a container on your machine. Now that we have the image, we
    can create a container based on the image with a `docker run` command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从Docker Hub注册中心拉取最新的Redis缓存应用程序镜像，并在您的机器上创建一个容器。现在我们有了镜像，我们可以使用`docker run`命令根据镜像创建一个容器：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we have an instance of Redis cache running on the host machine, and we
    can connect using any Redis cache management tool. When we no longer need this
    container to be running, we can simply use the `docker stop` command, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在主机机器上运行了一个Redis缓存实例，我们可以使用任何Redis缓存管理工具进行连接。当我们不再需要这个容器运行时，我们可以简单地使用`docker
    stop`命令，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, this is an example of how we can quickly create an optimized environment
    for a third-party application, but a major part of why we use Docker is the fact
    that we can provide containers for our own applications. Before we explore how
    this is done, we should seek to appreciate the pros and cons of using containers.
    We will look at these next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个我们可以快速为第三方应用程序创建优化环境的例子，但我们使用Docker的主要原因之一是我们可以为我们的应用程序提供容器。在我们探索如何做到这一点之前，我们应该寻求欣赏使用容器的优缺点。我们将在下一部分查看这些内容。
- en: Pros and cons of containers
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的优缺点
- en: The benefits of using containerization in our applications are clear. We can
    take advantage of managing our hosting environments, consistency in how we deliver
    software, more efficient use of system resources, and software portability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用容器化的好处是显而易见的。我们可以利用管理我们的托管环境，软件交付的一致性，更有效地使用系统资源，以及软件的可移植性。
- en: Recall that containers will only require the exact resources needed for the
    hosted application to run. This means that we can rest assured that we are not
    overextending or over-provisioning resources to accommodate a container. We can
    also benefit from how easy it is to spin up new containers as needed. If we were
    using VMs, then each application might require an entire machine instance. Containers
    have a much smaller footprint and require far less to host a new application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，容器将仅需要托管应用程序运行所需的精确资源。这意味着我们可以放心，我们不会过度扩展或过度配置资源以适应容器。我们还可以从需要时快速启动新容器的好处中受益。如果我们使用虚拟机，那么每个应用程序可能需要一个完整的机器实例。容器具有更小的占用空间，并且需要更少的资源来托管新的应用程序。
- en: Amidst all these advantages, we need to be aware of the possible drawbacks of
    using this hosting and deployment method. Containers will share a single operating
    system and this shared reliance means that we now have a single point of failure
    or attack. This can be concerning for security teams. Monitoring our applications
    also becomes a bit more difficult since we have less to work with. Containers
    generally provide log information to give us insight into the health of the application,
    but we are not always aware of the additional resources and plugins that are at
    work, and this makes a total monitoring operation a bit more difficult.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些优点中，我们需要意识到使用这种托管和部署方法的潜在缺点。容器将共享单个操作系统，这种共享依赖性意味着我们现在有一个单一的故障点或攻击点。这对安全团队来说可能是个问题。由于我们可操作的内容较少，监控我们的应用程序也变得稍微困难一些。容器通常提供日志信息，以让我们了解应用程序的健康状况，但我们并不总是了解正在工作的额外资源和插件，这使得全面的监控操作变得稍微困难一些。
- en: Should we proceed to use containerization in our applications, we need to be
    familiar with how we author images for the sole purpose of hosting our application.
    In this case, we need to know and understand how to use a base image and deploy
    our own application to a new container. For this, we need a Dockerfile, and we
    will review how we can create one next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定在应用程序中使用容器化，我们需要熟悉如何编写用于仅托管我们的应用程序的镜像。在这种情况下，我们需要了解并理解如何使用基础镜像并将我们的应用程序部署到新的容器中。为此，我们需要一个Dockerfile，我们将回顾如何创建一个。
- en: Authoring a Dockerfile
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Dockerfile
- en: 'A **Dockerfile** is a text file that outlines how a Docker image should be
    built. The language used is **Yet Another Markup Language** (**YAML**), which
    is a popular markup language used for configuration files. This file usually contains
    the following elements:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile** 是一个文本文件，概述了如何构建Docker镜像。使用的语言是 **另一种标记语言** (**YAML**)，这是一种流行的用于配置文件的标记语言。此文件通常包含以下元素：'
- en: A base or parent image to base the new image on
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础或父镜像，用于构建新镜像
- en: Commands to update the operating system and additional software and plugins
    as needed
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要更新操作系统和额外的软件和插件
- en: Compiled application assets to be included in the image
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编译的应用程序资产包含在镜像中
- en: Additional container image assets for storage and networking needs
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为存储和网络需求提供额外的容器镜像资产
- en: A command to run the application when the container launches
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当容器启动时运行应用程序的命令
- en: In our case, we are building a microservices-based application with several
    web services. This means that we need to author Dockerfiles per web service. Since
    all our services are ASP.NET Core based, we can use the following example of a
    Dockerfile as a base example for our appointment web service and others.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们正在构建一个基于微服务的应用程序，包含多个Web服务。这意味着我们需要为每个Web服务编写Dockerfile。由于所有我们的服务都是基于ASP.NET
    Core的，我们可以使用以下Dockerfile的示例作为我们的预约Web服务和其他服务的基例。
- en: To add a Dockerfile to our project, we can use **Visual Studio** and simply
    right-click our project in **Solution Explorer**, go to **Add**, and then click
    **Docker Support…**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Dockerfile添加到我们的项目中，我们可以使用 **Visual Studio**，只需在 **解决方案资源管理器** 中右键单击我们的项目，转到
    **添加**，然后点击 **Docker支持…**。
- en: '*Figure 13.3* shows the **Docker Support…** option:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.3* 展示了 **Docker支持…** 选项：'
- en: '![Figure 13.3 – Adding Docker Support in Visual Studio 2022](img/Figure_13.3_B19100.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 在Visual Studio 2022中添加Docker支持](img/Figure_13.3_B19100.jpg)'
- en: Figure 13.3 – Adding Docker Support in Visual Studio 2022
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 在Visual Studio 2022中添加Docker支持
- en: In `docker-compose` support. Once we complete selecting our options, it will
    proceed to generate our files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker-compose` 支持中。一旦我们完成选项的选择，它将开始生成我们的文件。
- en: 'Both paths will produce two new files in the target project. We get a Dockerfile
    and a `.dockerignore` file. In the case of the appointments booking service project,
    if we complete the preceding steps, we end up with a Dockerfile that looks like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个路径将在目标项目中产生两个新文件。我们得到一个Dockerfile和一个`.dockerignore`文件。在预约预订服务项目的情况下，如果我们完成前面的步骤，我们将得到一个看起来像这样的Dockerfile：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This Dockerfile has instructions that will create an image for the target service
    and build the container. The instructions execute the following actions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此Dockerfile包含创建目标服务镜像和构建容器的指令。这些指令执行以下操作：
- en: Use the `mcr.microsoft.com/dotnet/aspnet:6.0` image as the base from which we
    will derive the rest of our new image.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mcr.microsoft.com/dotnet/aspnet:6.0` 镜像作为基础，我们将从中派生其余的新镜像。
- en: Define which ports we wish to expose from our container, which are the standard
    web traffic ports for HTTP (`80`) and HTTPS (`443`).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们希望从容器中公开的端口，这些是标准Web流量端口，即HTTP (`80`) 和HTTPS (`443`)。
- en: Define our own content in the image by copying the contents of key files and
    directories that we need for the app.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制我们为应用程序所需的键文件和目录的内容，在镜像中定义我们自己的内容。
- en: Perform *build*, *restore*, and *publish* operations to generate binaries, and
    after the publish operation, run and copy the files from the `publish` directory
    to the container space.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 *构建*、*还原* 和 *发布* 操作以生成二进制文件，发布操作完成后，运行并从 `发布` 目录复制文件到容器空间。
- en: Define *ENTRYPOINT* as the executing binary for the project that will launch
    our application.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *ENTRYPOINT* 定义为启动我们的应用程序的项目执行二进制文件。
- en: 'We also get a `.dockerignore` file that outlines files and directories that
    should not be included in the container when it is created. Its contents look
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到一个`.dockerignore`文件，概述了在创建容器时不应包含的文件和目录。其内容如下：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This file is simple to understand, and modifying it is not generally required.
    It is simply outlining the different areas of the project file composition that
    it doesn’t deem necessary to transport to the container once the application is
    built and deployed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件很容易理解，通常不需要修改。它只是概述了项目文件组成的不同区域，一旦应用程序构建和部署，它认为不需要将这些区域传输到容器中。
- en: Our Dockerfile is a starting point for our own container that will house the
    target web service. Just to recap on how containers are built, we start off with
    a *registry*, and this registry contains *images*. In this set of images, we have
    base images, which are a starting point for all subsequent images. In this case,
    our first line refers to a base image from which we wish to derive our web service
    container. Note that the origin and base images of the base image that we ended
    up using are not visible through this process. The truth is, we don’t know the
    hierarchy behind the `mcr.microsoft.com/dotnet/aspnet:6.0` base image, nor the
    hierarchy of those images. This approach helps us to make use of the various images
    that have contributed to our current base image, without needing to make direct
    references to them or bloat our file with references. We are simply making our
    own derivative henceforth. This ties in with the goal of keeping our container
    images small.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Dockerfile是我们自己的容器的起点，该容器将容纳目标Web服务。为了回顾一下容器是如何构建的，我们从一个*注册表*开始，这个注册表包含*镜像*。在这个镜像集中，我们有基础镜像，它们是所有后续镜像的起点。在这种情况下，我们的第一行引用了一个基础镜像，我们希望从中派生出我们的Web服务容器。请注意，我们通过这个过程看不到最终使用的基础镜像的来源和基础镜像。事实是，我们不知道`mcr.microsoft.com/dotnet/aspnet:6.0`基础镜像背后的层次结构，也不知道这些镜像的层次结构。这种方法帮助我们利用对当前基础镜像做出贡献的各种镜像，而无需直接引用它们或使文件因引用而膨胀。我们只是简单地创建了自己的衍生版本。这与保持我们的容器镜像小的目标是一致的。
- en: Now, let us explore how we can use this Dockerfile going forward.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何继续使用这个Dockerfile。
- en: Launching a containerized application
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动容器化应用程序
- en: Now that we have done this process for one of our services, we can easily repeat
    it for the others. By doing this, we will have completely and successfully containerized
    each of our web services and, by extension, our microservices application. It
    is noteworthy as well that Visual Studio and Visual Studio Code will always generate
    the best Dockerfile to suit the project type that you are working with. We can
    now also enjoy the new launch feature that gets introduced where we can launch
    our new containerized web service in a Docker container and still retain real-time
    analytics and debugging features as if it were running in a normal debugging setting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的一个服务完成了这个过程，我们可以轻松地为其他服务重复它。通过这样做，我们将完全成功地容器化每个Web服务，以及我们的微服务应用程序。值得注意的是，Visual
    Studio和Visual Studio Code将始终生成最适合你正在使用的项目类型的最佳Dockerfile。现在我们还可以享受新引入的启动功能，其中我们可以在一个Docker容器中启动我们的新容器化Web服务，并且仍然保留实时分析和调试功能，就像它在正常调试设置中运行一样。
- en: 'In `Properties`, and open the file called `launchSettings.json`. This is a
    JSON configuration file that comes as standard in every ASP.NET Core project,
    and unless you have a specific reason to, you wouldn’t normally open or modify
    this file. It was, however, modified and given a new launch profile, which informs
    *Visual Studio* that there is a new way to launch this application for debugging.
    The file now looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`属性`中，打开名为`launchSettings.json`的文件。这是一个JSON配置文件，它是每个ASP.NET Core项目中的标准配置文件，除非你有特殊原因，否则你通常不会打开或修改此文件。然而，它已被修改并赋予了一个新的启动配置文件，该配置文件通知*Visual
    Studio*有新的方式来启动此应用程序进行调试。文件现在看起来是这样的：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This new `Docker` section was created during our introduction of the Dockerfile,
    and it now allows us to select **Docker** as a launch option from Visual Studio.
    This will proceed to execute the instructions outlined in the Dockerfile where
    it will create a new image based on the base Microsoft image, build, restore,
    and publish our web project, and then move the files to a freshly created container
    and execute the application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`Docker`部分是在我们介绍Dockerfile时创建的，现在它允许我们从Visual Studio中选择**Docker**作为启动选项。这将执行Dockerfile中概述的指令，其中将基于基础Microsoft镜像创建一个新的镜像，构建、恢复并发布我们的Web项目，然后将文件移动到新创建的容器中并执行应用程序。
- en: The only major difference that we will see in this experience is that the UIs
    in Visual Studio or Visual Studio Code will show more information regarding the
    containers, such as their health, version, ports, environment variables, logs,
    and even the filesystem that the container is using.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个体验中，我们将看到的唯一主要区别是，Visual Studio或Visual Studio Code中的UI将显示有关容器的更多信息，例如它们的健康状态、版本、端口、环境变量、日志，甚至是容器正在使用的文件系统。
- en: '*Figure 13.4* shows the Visual Studio UI while using Docker for debugging:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.4*显示了使用Docker进行调试时的Visual Studio UI：'
- en: '![Figure 13.4 – We see Visual Studio in debug mode while containers are in
    use; it shows us information about the container during runtime](img/Figure_13.4_B19100.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 当容器在使用时，我们看到处于调试模式的Visual Studio；它显示了容器在运行时的信息](img/Figure_13.4_B19100.jpg)'
- en: Figure 13.4 – We see Visual Studio in debug mode while containers are in use;
    it shows us information about the container during runtime
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 当容器在使用时，我们看到处于调试模式的Visual Studio；它显示了容器在运行时的信息
- en: 'While we are debugging with our Docker containers, you may notice the containers
    in Docker’s **graphical UI** (**GUI**), and they show which ports are available
    for HTTP traffic. We will use these ports to handle the configured port mapping
    accordingly. If you want to see the running containers using the CLI, you can
    run this command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Docker容器进行调试时，你可能会注意到Docker的**图形用户界面**（**GUI**）中的容器，它们显示了可用于HTTP流量的端口。我们将使用这些端口来相应地处理配置的端口映射。如果你想通过CLI查看正在运行的容器，可以运行以下命令：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will produce a list of containers, showing their names, ports, and status.
    Docker has several commands that help us to automate our container operations,
    such as the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个容器列表，显示它们的名称、端口和状态。Docker有几个命令可以帮助我们自动化容器操作，例如以下命令：
- en: '`docker run` starts or creates a container. It takes a `-d` parameter, which
    is the name of the container to be started.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run`启动或创建一个容器。它接受一个`-d`参数，这是要启动的容器的名称。'
- en: '`docker pause` will pause a running container and suspend all services and
    activities.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker pause`将暂停正在运行的容器并挂起所有服务和活动。'
- en: '`docker unpause` does the opposite of `docker pause`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker unpause`与`docker pause`相反。'
- en: '`docker restart` encapsulates the stop and start commands and will reboot a
    container.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker restart`封装了停止和启动命令，并将重新启动容器。'
- en: '`docker stop` sends a termination signal to a container and the processes running
    in the container.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker stop`向容器及其内部运行的进程发送终止信号。'
- en: '`docker rm` removes a container and all data associated with the container.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker rm`删除容器及其所有相关数据。'
- en: The amazing thing to note here is that using containers has made our application
    extremely portable and deployable. Now, we do not need to make special configurations
    on a server and risk one server behaving differently from the other. We can more
    easily deploy the same environment through the container on any machine, and we
    can always expect the same outcome.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的神奇之处在于，使用容器使我们的应用程序变得极其便携和可部署。现在，我们不需要在服务器上进行特殊配置，从而降低一个服务器行为与其他服务器不同的风险。我们可以更容易地通过容器在任何机器上部署相同的环境，并且我们可以始终期待相同的输出。
- en: As of .NET 7, we can containerize our applications without needing a Dockerfile.
    We will review the steps that can be completed next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到.NET 7为止，我们可以无需Dockerfile即可容器化我们的应用程序。我们将回顾可以完成的下一步步骤。
- en: Using native .NET container support
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本机.NET容器支持
- en: With .NET 7, we have native support for containerization. This means that we
    can use .NET packages to add container support to our application and then publish
    our app directly to a container, all without needing Docker.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 7中，我们原生支持容器化。这意味着我们可以使用.NET包将容器支持添加到我们的应用程序中，然后直接将应用程序发布到容器中，而无需使用Docker。
- en: 'Container support is made available through the `Microsoft.NET.Build.Containers`
    package. We can add this package using the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 容器支持通过`Microsoft.NET.Build.Containers`包提供。我们可以使用以下命令添加此包：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have our package added, we can publish our application to a container
    and then use Docker to run the published application. Using the CLI, we can run
    the following commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了包，我们可以将应用程序发布到容器中，然后使用Docker运行已发布的应用程序。使用CLI，我们可以运行以下命令：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, our self-hosted container will run and listen for traffic on the configured
    `5010` port.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的自托管容器将运行并监听配置的`5010`端口。
- en: Now we see that we have several ways that can lead to us containerizing our
    applications, we do this for all our other services. This, however, brings a new
    challenge where we might need to launch our containerized web services in a specific
    order, or with default values and settings. For this, we need an orchestrator.
    We have mentioned orchestrators before in the form of Kubernetes, which is an
    industry-leading metaphorical glove for Docker images (the metaphorical hand)
    to fit in.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到，我们有几种方法可以引导我们容器化我们的应用程序，我们为所有其他服务都这样做。然而，这却带来了一个新的挑战，我们可能需要以特定的顺序启动我们的容器化网络服务，或者使用默认值和设置。为此，我们需要一个编排器。我们之前已经提到了编排器，即
    Kubernetes，它是 Docker 镜像（隐喻的手）的行业领先隐喻手套，以便与之匹配。
- en: Before we get to Kubernetes, though, Docker provides an orchestration engine
    that is defined by instructions outlined in a `docker-compose` file. We will explore
    how this works in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达 Kubernetes 之前，Docker 提供了一个由 `docker-compose` 文件中概述的指令定义的编排引擎。我们将在下一节中探讨它是如何工作的。
- en: Understanding docker-compose and images
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解docker-compose和镜像
- en: Before we explore `docker-compose` and how it compiles our images, we need to
    understand the concept of orchestration and why we need it. Container orchestration
    is an automated approach to launching containers and related services. In context,
    when we have a containerized application, we might end up with several containers
    between our application that has been containerized and third-party applications
    that we are using as containers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索 `docker-compose` 以及它是如何编译我们的镜像之前，我们需要了解编排的概念以及为什么我们需要它。容器编排是一种自动化的方法，用于启动容器及其相关服务。在上下文中，当我们有一个容器化的应用程序时，我们可能会在我们的容器化应用程序和第三方应用程序之间得到几个容器。
- en: In the context of our microservices application where we have several individual
    services, each one is containerized. We might also end up using a containerized
    cache server, and other supporting services such as email and logging applications.
    We now need a way to organize our list of containers and launch them in a particular
    order, such that the supporting applications are available before the dependent
    service containers are launched.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务应用程序的上下文中，我们拥有几个独立的服务，每个服务都是容器化的。我们也可能最终会使用一个容器化的缓存服务器，以及其他支持服务，如电子邮件和日志应用程序。我们现在需要一种方法来组织我们的容器列表，并按特定顺序启动它们，以确保在启动依赖服务容器之前，支持应用程序是可用的。
- en: 'This requirement introduces a considerable amount of complexity and can make
    a manual effort very difficult. Using container orchestration, we can make this
    operation manageable for development and operations. We now have a declarative
    way of defining the work that needs to be done and the order in which our containers
    should be launched and with which dependencies. We will now have the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求引入了相当多的复杂性，可能会使手动操作变得非常困难。使用容器编排，我们可以使这项操作对开发和运维变得可管理。我们现在有了定义需要完成的工作以及容器应启动的顺序及其依赖关系的声明式方法。现在我们将有以下几点：
- en: '**Simplified operations**: To reiterate, container orchestration vastly simplifies
    the recurring effort of launching containers in a specific order and with specific
    configurations.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化操作**：重申一下，容器编排极大地简化了以特定顺序和配置启动容器的重复性工作。'
- en: '**Resiliency**: Can be used to carry out our specific operations based on container
    health, system load, or scaling needs. Orchestration will manage our instances
    as needed and automate actions that should be taken in the best interest of the
    application’s stability.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：可以根据容器健康、系统负载或扩展需求执行我们的特定操作。编排将根据需要管理我们的实例，并自动化应采取的最佳利益行动，以确保应用程序的稳定性。'
- en: '**Security**: This automated approach helps us to reduce the chance of human
    error and ensure security in our application.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这种自动化方法有助于我们减少人为错误的可能性，并确保我们应用程序的安全性。'
- en: '`docker-compose` is the simplest form of orchestration that we can employ.
    Alternatives include Kubernetes and Docker Swarm, which are industry-leading options
    in the container orchestration space.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`是我们能采用的 simplest 形式的编排。其他选择包括 Kubernetes 和 Docker Swarm，它们是容器编排领域的行业领先选项。'
- en: '`docker-compose` is a tool that helps us to define multi-container applications.
    We can define a YAML file and define the containers that need to be launched,
    and their dependencies, and then we can launch the application with a single command.
    The major advantage of `docker-compose` is that we can define everything about
    our application’s stack in a file and have this defined at the root of our application’s
    folder.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 是一个帮助我们定义多容器应用程序的工具。我们可以定义一个 YAML 文件，并定义需要启动的容器及其依赖项，然后我们可以使用单个命令启动应用程序。`docker-compose`
    的主要优点是我们可以在一个文件中定义关于我们应用程序堆栈的所有内容，并在应用程序文件夹的根目录中定义它。'
- en: Another advantage here is that if our project is version controlled, we can
    easily allow for the evolution of this file through outside contributions, or
    we can share our containers and the launch steps for our application easily with
    others.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个优点是，如果我们的项目是版本控制的，我们可以轻松地允许通过外部贡献来演变此文件，或者我们可以轻松地与他人共享我们的容器以及我们的应用程序的启动步骤。
- en: Now, let us review the steps to add `docker-compose` support to our microservices
    application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下将 `docker-compose` 支持添加到我们的微服务应用程序的步骤。
- en: Adding docker-compose to a project
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 docker-compose 添加到项目
- en: Adding `docker-compose` support to our ASP.NET Core microservices application
    is easy. In Visual Studio, we can simply right-click one of our service projects,
    go to **Add**, and select **Container Orchestrator Support…**. This launches a
    window where we can confirm that we prefer **Docker Compose** and select **OK**.
    We can select either **Windows** or **Linux** as the target OS. Either OS option
    works since ASP.NET Core is cross-platform.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `docker-compose` 支持添加到我们的 ASP.NET Core 微服务应用程序非常简单。在 Visual Studio 中，我们可以简单地右键单击我们的服务项目之一，转到
    **添加**，然后选择 **容器编排器支持…**。这会打开一个窗口，我们可以确认我们更喜欢 **Docker Compose** 并选择 **确定**。我们可以选择
    **Windows** 或 **Linux** 作为目标操作系统。由于 ASP.NET Core 是跨平台的，所以任何操作系统选项都可以工作。
- en: '*Figure 13.5* shows the **Container Orchestrator Support…** option:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13.5* 显示了 **容器编排器支持…** 选项：'
- en: '![Figure 13.5 – Adding container orchestrator support using Visual Studio 2022](img/Figure_13.5_B19100.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 使用 Visual Studio 2022 添加容器编排器支持](img/Figure_13.5_B19100.jpg)'
- en: Figure 13.5 – Adding container orchestrator support using Visual Studio 2022
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 使用 Visual Studio 2022 添加容器编排器支持
- en: 'This introduces a new project to our solution where we have a `.dockerignore`
    file and a `docker-compose.yml` file. If we inspect the `docker-compose.yml` file,
    we will see that we have a version number and at least one service defined:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们的解决方案中引入了一个新的项目，其中包含一个 `.dockerignore` 文件和一个 `docker-compose.yml` 文件。如果我们检查
    `docker-compose.yml` 文件，我们会看到我们有一个版本号和至少一个服务定义：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Under the definition of our service, we define the containers that we wish
    to launch and state the name of the image and the Dockerfile that will be a reference
    point for the image definition. Following similar steps for the other services,
    Visual Studio will automatically append additional services to the file accordingly.
    If we proceed to do this with the additional services, we will end up with a `docker-compose`
    file like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们服务的定义下，我们定义了我们希望启动的容器，并声明了图像的名称和 Dockerfile，它将是图像定义的参考点。按照对其他服务的类似步骤，Visual
    Studio 将自动根据需要将额外的服务附加到文件中。如果我们继续对额外的服务执行此操作，我们将得到一个像这样的 `docker-compose` 文件：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have a `docker-compose` file that has a record of each container that
    needs to be launched in our microservices application. This file can now be extended
    to include additional containers as required by the entire application. If we
    need a Redis cache instance, we can add a command to this `docker-compose` file
    to launch a container for Redis. This is what it would look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个 `docker-compose` 文件，它记录了在我们的微服务应用程序中需要启动的每个容器。现在，我们可以根据整个应用程序的需求扩展此文件以包含额外的容器。如果我们需要一个
    Redis 缓存实例，我们可以在 `docker-compose` 文件中添加一个命令来启动 Redis 容器。这将是它的样子：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This addition to the file will simply spin up a Redis cache container using
    the defined base image. Note that the Redis cache image composition can be extended
    to use storage volumes, and we can pass specific configuration files to our image
    and indicate that we wish to persist the container’s information in a data volume.
    When we restart this image, the data from the last run will still be available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件添加将简单地启动一个使用定义的基础镜像的 Redis 缓存容器。请注意，Redis 缓存图像组合可以扩展以使用存储卷，我们可以将特定的配置文件传递给我们的图像，并指示我们希望在数据卷中持久化容器的信息。当我们重新启动此图像时，上一次运行的数据仍然可用。
- en: 'We might also want to indicate that some containers should be available before
    others are started. This could come in handy if a container has a dependency on
    the Redis cache container or even on another service. For this, we can add another
    node called `depends_on`, which will allow us to indicate the name of the container
    that should be launched before we attempt to launch the other. For example, our
    appointments service communicates with our patients service from time to time.
    It would be prudent of us to make sure that the patients service is launched before
    we attempt to launch the appointments service. We can modify the appointment container
    orchestration to look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能想要指出，某些容器应该在其他容器启动之前可用。如果容器依赖于Redis缓存容器或另一个服务，这可能很有用。为此，我们可以添加另一个节点`depends_on`，这将允许我们指示在尝试启动其他容器之前应该启动的容器名称。例如，我们的预约服务时不时地与我们的患者服务进行通信。我们确保在尝试启动预约服务之前启动患者服务是明智的。我们可以修改预约容器的编排，使其看起来像这样：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is possible for us to provide more specific configurations for each image
    and even provide more specific configurations for our image, without needing to
    directly repeat the Dockerfile execution. This is where the `docker-compose.override.yml`
    file comes into play. It is a nested child item that can be found under the `docker-compose.yml`
    file, and its contents look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个镜像提供更具体的配置，甚至为我们的镜像提供更具体的配置，而无需直接重复执行Dockerfile。这正是`docker-compose.override.yml`文件发挥作用的地方。它是一个嵌套的子项，可以在`docker-compose.yml`文件下找到，其内容如下：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we see that our API’s container will be launched with specific environment
    variables and will have preset ports and volumes. This file can be removed if
    you prefer to have more explicit control over your containers, but you need to
    make sure that the relevant values are configured in the Dockerfile.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的API容器将使用特定的环境变量启动，并具有预设的端口和卷。如果您更喜欢对容器有更明确的控制，可以删除此文件，但您需要确保在Dockerfile中配置了相关值。
- en: 'To revisit our `Backend for Frontend` pattern from a previous chapter, we outlined
    that we could provision multiple gateway projects and provide specific configurations
    for each instance. Now that we have containerization, we can remove the need for
    additional code projects and reuse the same project while using different configurations
    for each one. Let us add the following lines to the `docker-compose.yml` file
    and create two separate containers based on the same gateway image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们在上一章中提到的“后端为前端”模式，我们概述了我们可以配置多个网关项目并为每个实例提供特定的配置。现在有了容器化技术，我们可以移除对额外代码项目的需求，并重用相同的项目，同时为每个项目使用不同的配置。让我们向`docker-compose.yml`文件中添加以下行，并基于相同的网关镜像创建两个独立的容器：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have defined two new containers based on the same `ApiGateway`
    image definition, we can add to the `docker-override.yml` file and specify the
    sources of the specific configuration files that should be used in either case:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基于相同的`ApiGateway`镜像定义创建了两个新的容器，我们可以向`docker-override.yml`文件中添加内容，并指定在两种情况下应使用的特定配置文件的来源：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can specify the volume sources as the paths to the configuration files, but
    we also took the opportunity to define environment variable values relative to
    configurations that may vary or need to be set when the container is being created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将卷源指定为配置文件的路径，但我们还利用这个机会定义了相对于配置的环境变量值，这些配置可能会变化或在容器创建时需要设置。
- en: In general, we will also want to consider the need for other dependencies such
    as a database server, message bus provider (such as RabbitMQ), supporting web
    services and utilities, and so on. All the components of your microservices application
    can be containerized, and the containers can make direct reference to each other
    as needed. The `docker-compose.yml` file allows us to outline all these containers
    and their variables as needed, and we can easily plug in the values accordingly.
    With a few lines, we can get started, but there are many more avenues to explore
    and master.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们还会考虑其他依赖项的需求，例如数据库服务器、消息总线提供者（如RabbitMQ）、支持性Web服务和工具等。您的微服务应用的所有组件都可以容器化，并且容器可以根据需要直接相互引用。《docker-compose.yml》文件允许我们根据需要概述所有这些容器及其变量，我们可以轻松地插入相应的值。只需几行代码，我们就可以开始，但还有许多其他途径可以探索和掌握。
- en: Now, we can comfortably launch our entire microservices application and all
    the components with one click or command. If using Visual Studio, the button to
    start with debugging would traditionally have cited the name of one service at
    a time, or we would need to enable multiple projects to be run at debugging. Now,
    the presence of the `docker-compose.yml` file overrides the need to be that specific
    and gives us the ability to run the `compose` command and initialize all our containers
    in one go. Using the CLI, we can simply run `docker-compose up`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地通过一键或一条命令启动整个微服务应用程序及其所有组件。如果使用Visual Studio，传统的开始调试按钮会一次引用一个服务的名称，或者我们需要启用多个项目以进行调试。现在，`docker-compose.yml`文件的存在取代了这种具体的需求，并赋予我们运行`compose`命令并一次性初始化所有容器的能力。使用CLI，我们可以简单地运行`docker-compose
    up`。
- en: Now, we have a fully containerized application, and we can simply adjust the
    parameters used to launch our containers and remain agile and scalable in how
    we handle our application hosting and deployments. It also makes it easier to
    share our applications with our development team and have the members run our
    applications with only Docker installed as a dependency.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有一个完全容器化的应用程序，我们可以简单地调整用于启动容器的参数，从而在处理应用程序托管和部署时保持敏捷和可扩展。这也使得与我们的开发团队分享应用程序变得更加容易，团队成员只需安装Docker作为依赖项即可运行我们的应用程序。
- en: We have also seen that there are base images that allow us to extend and create
    our own images. There will come a time when we have a particular application or
    our own version of an application that we wish to preserve and reshare beyond
    just our project. We can publish our container images to a central repository.
    We will review this concept next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，有一些基础镜像允许我们扩展并创建自己的镜像。总有一天，我们会遇到特定的应用程序或我们自己的应用程序版本，我们希望将其保存并重新分享，而不仅仅是我们的项目。我们可以将我们的容器镜像发布到中央仓库。我们将在下一节中回顾这一概念。
- en: Publishing containers to a container registry
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器发布到容器注册库
- en: A **container registry** is a centralized repository that stores several containers.
    It allows for remote access to these containers and comes in handy for general
    development and deployment needs when we need a consistent source for a container
    image for some applications. Container registries are generally connected directly
    to platforms such as Docker and Kubernetes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器注册库**是一个集中存储多个容器的仓库。它允许远程访问这些容器，并在我们需要为某些应用程序提供一个一致的容器镜像源时，对于一般开发和部署需求非常有用。容器注册库通常直接连接到Docker和Kubernetes等平台。'
- en: Registries can save developers time and effort in creating and delivering cloud-native
    solutions. Recall that a container image contains files and components that make
    up an application. By maintaining a registry, we can maximize our agile development
    efforts and deliver incremental image updates efficiently, and with the registry,
    we can store them in a central area for the team.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注册库可以节省开发者在创建和交付云原生解决方案中的时间和精力。回想一下，容器镜像包含构成应用程序的文件和组件。通过维护注册库，我们可以最大化我们的敏捷开发努力，并有效地交付增量镜像更新，并且通过注册库，我们可以将它们存储在团队的中心区域。
- en: A container registry can be private or public. We will discuss our options next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册库可以是私有的或公开的。我们将在下一节讨论我们的选项。
- en: Public versus private container registries
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公开与私有容器注册库
- en: A registry can be public or private. Public repositories are generally used
    by developers or teams of developers who either want to provision a registry as
    quickly as possible or want to publicly share containers that they have developed.
    These images are then used as base images by others and are sometimes tweaked.
    This is a great way to contribute to the open source collection of container images.
    Docker Hub is the largest public repository and community for containers and is
    the default source of our container images when we do a `docker pull` command.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注册库可以是公开的或私有的。公开仓库通常被开发者或开发者团队使用，他们要么希望尽快提供注册库，要么希望公开分享他们开发的容器。这些镜像随后被其他人用作基础镜像，有时会进行一些调整。这是为开源容器镜像集合做出贡献的绝佳方式。Docker
    Hub是最大的公开仓库和容器社区，也是我们执行`docker pull`命令时的默认容器镜像源。
- en: Private repositories provide a more secure and private way to host and maintain
    enterprise containers. These types of registries can be remote through established
    registries such as **Google Container Registry** (**GCR**), Microsoft ACR, or
    Amazon **Elastic Container Registry** (**ECR**).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 私有仓库提供了一种更安全和私密的方式来托管和维护企业容器。这些类型的仓库可以是远程的，通过如**Google Container Registry**（**GCR**）、Microsoft
    ACR或Amazon **Elastic Container Registry**（**ECR**）等已建立的仓库。
- en: 'When using a private container registry, we have more control over security
    and configuration, but we also take on more management responsibilities for access
    control and compliance within your organization. We need to maintain the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用私有容器仓库时，我们对安全和配置有更多的控制，但我们也承担了更多管理责任，包括在组织内部进行访问控制和合规性。我们需要维护以下内容：
- en: Support for several authentication options within our organization
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们组织内部支持多种身份验证选项
- en: '**Role-based access control** (**RBAC**) for images'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**（**RBAC**）对镜像的支持'
- en: Image versioning and maintenance against vulnerabilities
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像版本控制和针对漏洞的维护
- en: User activity auditing and logging
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户活动审计和日志记录
- en: We can properly control who is able to upload images through more strict controls
    and measures and prevent unauthorized access and contributions to the registry.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更严格的控制和措施来正确控制谁能够上传镜像，并防止对仓库的未授权访问和贡献。
- en: Recall that a container registry can be hosted locally. This means that we can
    stage a local instance of Docker Hub on a server and add configurations that are
    specific to our organization’s needs and policies. We can also leverage cloud-hosted
    container registry services. The advantage of using cloud-hosted solutions is
    that we can reduce the infrastructural consideration that comes with setting up
    a local server as well as taking advantage of a fully managed and geo-replicated
    solution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，容器仓库可以本地托管。这意味着我们可以在服务器上部署Docker Hub的本地实例，并添加针对我们组织需求和政策的特定配置。我们还可以利用云托管的容器仓库服务。使用云托管解决方案的优势在于，我们可以减少设置本地服务器时伴随的基础设施考虑，同时利用一个完全托管和地理复制的解决方案。
- en: Let us review how we can create a customized version of an image and upload
    it to a registry.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何创建一个自定义版本的图片并将其上传到仓库。
- en: Creating and uploading custom images
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和上传自定义图片
- en: We have already created several images to support our application. There are
    times when we might need a particular application to be deployed in a consistent
    and repeatable manner, and we don’t want to risk recreating the Dockerfile or
    `docker-compose.yml` file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了几个镜像来支持我们的应用程序。有时我们可能需要将特定的应用程序以一致和可重复的方式部署，而我们不想冒重新创建Dockerfile或`docker-compose.yml`文件的风险。
- en: In this case, we can pull a copy of the base image, add our own configurations
    and variables to it, and then push the image back to the registry with a new and
    unique name. Now, other team members—or even you in a future project—can pull
    this new image at will and leverage the preset environment as needed. For this
    exercise, we need to have an account on Docker Hub.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以拉取基本镜像的副本，向其中添加我们自己的配置和变量，然后将带有新且唯一的名称的镜像推送到仓库。现在，其他团队成员——甚至你未来的项目——可以随意拉取这个新镜像，并根据需要利用预设的环境。为此练习，我们需要在Docker
    Hub上有一个账户。
- en: 'Let us use an example of a SQL Server image. If we needed to create an image
    that has a default database as a starting point, then we could do this in a few
    steps. First, we pull the base image from Docker Hub with this command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个SQL Server镜像为例。如果我们需要创建一个以默认数据库为起点的镜像，我们可以通过以下步骤完成。首先，我们使用以下命令从Docker
    Hub拉取基本镜像：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'SQL Server images tend to be large, so this may take a while to download. Once
    downloaded, however, we can execute this command to run the container:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server镜像通常较大，因此下载可能需要一些时间。一旦下载完成，我们可以执行以下命令来运行容器：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first command is like what we have seen before, where we pull the image
    to our local machine. We then run the image and create an instance of SQL Server
    based on the latest image version and make it available through port `1434`. `1433`
    is the default port for SQL Server, so we can use a different port to avoid conflicts
    with other SQL instances that might be present. We also set default *sa* user
    credentials and accept the terms of use agreements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令类似于我们之前看到的，即从我们的本地机器拉取镜像。然后我们运行镜像，基于最新的镜像版本创建SQL Server的实例，并通过端口`1434`使其可用。`1433`是SQL
    Server的默认端口，因此我们可以使用不同的端口以避免与其他可能存在的SQL实例发生冲突。我们还设置了默认的`*sa*`用户凭据，并接受使用条款协议。
- en: 'Now that we have the instance of SQL Server up and running from our image,
    we can connect using **SQL Server Management Studio** (**SSMS**) or Microsoft
    Azure Studio and then run a script. We will keep it simple and create a database
    and a table:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从我们的镜像中启动并运行了 SQL Server 实例，我们可以使用 **SQL Server Management Studio** （**SSMS**）或
    Microsoft Azure Studio 连接，然后运行一个脚本。我们将保持简单，创建一个数据库和一个表：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the updated database, let us commit the updated image to a
    registry. We can use the Docker UI to see the name of the running container for
    SQL Server or use the `docker ps` command, which will list all the running containers.
    We then run this `docker commit` command using the name of the running SQL Server
    container:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更新的数据库，让我们将更新的镜像提交到注册表中。我们可以使用 Docker UI 查看运行中的 SQL Server 容器的名称，或者使用
    `docker ps` 命令，该命令将列出所有正在运行的容器。然后我们使用运行中的 SQL Server 容器的名称运行这个 `docker commit`
    命令：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates a local copy of the image based on the current state of the container.
    We add a `commit` message so that we can keep track of the change that was made
    and also add an author tag, state the name of the container on which we need to
    base the image, and then add our Docker Hub username and the new image’s name.
    Now, we can use the Docker UI and click the `docker images` command to list all
    the images that are currently on the system. You will now see the original SQL
    Server image as well as our recently committed image.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在容器当前状态下创建镜像的本地副本。我们添加一个 `commit` 消息，以便我们可以跟踪所做的更改，并添加一个作者标签，说明基于哪个容器的名称创建镜像，然后添加我们的
    Docker Hub 用户名和新的镜像名称。现在，我们可以使用 Docker UI 并点击 `docker images` 命令来列出系统上当前的所有镜像。您现在将看到原始的
    SQL Server 镜像以及我们最近提交的镜像。
- en: 'Now, we have successfully published our own image to our own local registry.
    If we want to make this image accessible on Docker Hub, we need to use the **Push
    to Hub** option that is available to us in the Docker UI. Alternatively, we can
    run the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功地将我们的镜像发布到了我们自己的本地注册表中。如果我们想使这个镜像在 Docker Hub 上可访问，我们需要使用 Docker UI
    中可用的 **推送到 Hub** 选项。或者，我们可以运行以下命令：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Going forward, if we needed to add this database image to our orchestration,
    we could modify our `docker-compose.yml` file like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，如果我们需要将这个数据库镜像添加到我们的编排中，我们可以像这样修改我们的 `docker-compose.yml` 文件：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we will always launch a SQL Server instance with this base database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将始终使用这个基础数据库启动 SQL Server 实例。
- en: We have not only containerized our application, but we have configured orchestration
    and created our very own custom image. Let us review all that we have learned
    in this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅容器化了我们的应用程序，还配置了编排并创建了我们的自定义镜像。让我们回顾一下本章所学到的所有内容。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have reviewed the pros and cons of containerization. We
    saw where containers help us to downsize some of the resource requirements that
    our applications have and created a portable version of these applications for
    development and deployment use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了容器化的优缺点。我们看到了容器如何帮助我们减少应用程序的资源需求，并为开发和部署创建了这些应用程序的便携式版本。
- en: Docker is an industry-leading containerization software that has a growing community
    of contributors. Docker can be installed on a machine and then used to manage
    images and containers as needed. We will also have access to Docker Hub, which
    is a popular repository for publicly accessible images.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个行业领先的容器化软件，拥有不断增长的贡献者社区。Docker 可以安装在机器上，然后根据需要用于管理镜像和容器。我们还将能够访问 Docker
    Hub，这是一个流行的公共镜像存储库。
- en: When we integrate Docker into our ASP.NET Core application, we open a new dimension
    to what it means to build and host our own applications. We can now guarantee
    that our services will behave in a more consistent manner regardless of the machine
    they are deployed on. This is because we will have created containers to host
    our services, and these containers will be optimized to the needs of the service
    and will never change unless we adjust their definitions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 Docker 集成到我们的 ASP.NET Core 应用程序中时，我们为构建和托管自己的应用程序开辟了新的维度。我们现在可以保证我们的服务将以更一致的方式运行，无论它们部署在哪个机器上。这是因为我们将创建容器来托管我们的服务，这些容器将根据服务的需求进行优化，并且除非我们调整它们的定义，否则它们永远不会改变。
- en: We also looked at container orchestration, which is where we can outline the
    containers that we need in one setting and launch them at once, or in a particular
    order according to the dependencies. This is perfect for our microservices application,
    which comprises several services and dependencies and would be tedious to launch
    individually.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了容器编排，这是我们可以在一个设置中概述所需的容器，并一次性启动它们，或者根据依赖关系以特定顺序启动。这对我们的微服务应用来说非常完美，因为我们的应用由多个服务和依赖关系组成，逐一启动会非常繁琐。
- en: Finally, we reviewed how to create our own image and host it on a local container
    registry. We could then publish the custom image to a public registry, Docker
    Hub, and have it accessible to all. Now, we can create specific containers with
    versions of our applications that we need to share with our teams, and we can
    better control the container versions that are distributed and used.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了如何创建自己的镜像并将其托管在本地容器注册库中。然后，我们可以将自定义镜像发布到公共注册库，如Docker Hub，使其对所有用户可访问。现在，我们可以创建具有我们需要与团队共享的应用程序版本的特定容器，并且我们可以更好地控制分发和使用的容器版本。
- en: In the next chapter, we will review a major cross-cutting concern in application
    development, which is log aggregation in microservices.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾应用开发中的一个主要横切关注点，即微服务中的日志聚合。
