<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-27" class="chapter-number"><a id="_idTextAnchor026"/>2</h1>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Expressions and Statements</h1>
			<p>Welcome to the first hands-on chapter of our journey! In this chapter, we are going to discuss expressions and statements, lambda expressions, and expression trees. These are the topics we <span class="No-Break">will cover:</span></p>
			<ul>
				<li>Understanding the difference between expressions <span class="No-Break">and statements</span></li>
				<li>Writing clear and declarative code <span class="No-Break">using expressions</span></li>
				<li>Utilizing expression-bodied members, lambda expressions, anonymous methods, and local <span class="No-Break">functions effectively</span></li>
				<li>Manipulating expressions at runtime using <span class="No-Break">expression trees</span></li>
			</ul>
			<p>Before we dive in, I want to tell you that I value your time, so most of the chapters will start with assessment tasks. These tasks are not meant to be solved all the time and are aimed to help you measure your existing understanding of the topic. If these tasks are no-brainers for you, you might want to skip the chapter for now. And vice versa, if the tasks are quite challenging for you, you might want to dedicate more time and effort to the chapter. At the end of each chapter with tasks, you will find the solutions section to check your answers. Now that you know the deal, let’s check the three tasks designed for <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Task 1 – Name and count all expressions and all statements</h1>
			<p>Name and<a id="_idIndexMarker041"/> count all <a id="_idIndexMarker042"/>expressions and all statements in the code <span class="No-Break">snippet below:</span></p>
			<pre class="source-code">
Tower mainTower = new(position: new Vector2(5, 5));
for (int level = 1; level &lt;= mainTower.MaxLevel; level++)
{
     double upgradeCost = 100 * Math.Pow(1.5, level - 1);
     Console.WriteLine($"Upgrading to level {level} costs {upgradeCost} gold");
     if (playerGold &gt;= upgradeCost)
     {
                  mainTower.Upgrade();
                  playerGold -= upgradeCost;
     }
}</pre>			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Task 2 – Use expressions instead of statements</h1>
			<p>Refactor the code<a id="_idIndexMarker043"/> below to use expressions instead <span class="No-Break">of statements:</span></p>
			<pre class="source-code">
string GetTowerDamageReport(IEnumerable&lt;Tower&gt; towers)
{
      int totalDamage = 0;
      foreach (Tower tower in towers)
      {
           if (tower.IsActive)
           {
                totalDamage += tower.Damage;
           }
      }
      return $"Active towers deal {totalDamage} total damage";
}</pre>			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Task 3 – Create an expression tree</h1>
			<p>Create an expression<a id="_idIndexMarker044"/> tree that is the lambda expression <strong class="source-inline">(baseDamage, level) =&gt; baseDamage * level</strong>. Then, compile and <span class="No-Break">invoke it.</span></p>
			<p>If you’re 100% sure that you know the answers to all three tasks, then you can confidently skip this chapter. However, there’s always a chance you might miss something useful, so instead of skipping the chapter entirely, you might want to save it for later. In any case, you can always come back and read it if you have any questions, or if anything <span class="No-Break">becomes uncle<a id="_idTextAnchor031"/>ar.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/>Understanding the difference between expressions and stateme<a id="_idTextAnchor033"/>nts</h1>
			<p>At its core, an <strong class="bold">expression</strong> in C# is just <a id="_idIndexMarker045"/>a piece of code that <a id="_idIndexMarker046"/>evaluates to a value. Simple expressions include constants, variables, and method calls. On the other hand, a <strong class="bold">statement</strong> is a standalone unit of code that performs an action. In essence, it is an executable instruction. The best way to understand something is through practice. So, let’s not delay anymore and look at expressions and statements <span class="No-Break">through exam<a id="_idTextAnchor034"/>ples.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Example of expressions</h2>
			<p>Consider<a id="_idIndexMarker047"/> the following <span class="No-Break">C# code:</span></p>
			<pre class="source-code">
var pagesPerChapter = 20;
var totalBookPages = pagesPerChapter<a id="_idTextAnchor036"/> * 10;</pre>			<p>In this snippet, 20, <strong class="source-inline">pagesPerChapter</strong>, <strong class="source-inline">10</strong>, and <strong class="source-inline">pagesPerChapter * 10</strong> are all expressions. Each of these pieces of code evaluates to <span class="No-Break">a <a id="_idTextAnchor037"/>value.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor038"/>Example of statements</h2>
			<p>Now, let’s <span class="No-Break">identify </span><span class="No-Break"><a id="_idIndexMarker048"/></span><span class="No-Break">statements:</span></p>
			<pre class="source-code">
var pagesPerChapter = 20;
var totalBookPages = pagesPerChapter * 10;</pre>			<p>Here, var pagesPerChapter = 20; and var totalBookPages = pagesPerChapter * 10; are statements. The first line instructs the program to declare a pagesPerChapter variable and initialize it with a value of 20. The second line instructs the program to multiply the value of pagesPerChapter by 10 and save it in the <strong class="source-inline">totalBookPages</strong> variable. Both are standalone code<a id="_idIndexMarker049"/> units that perform actions, fitting our definition of <span class="No-Break">a st<a id="_idTextAnchor039"/>atement.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor040"/>Key differences between expressions and statements</h2>
			<p>Although statements<a id="_idIndexMarker050"/> and expressions can sometimes look<a id="_idIndexMarker051"/> similar, remember that an expression produces a value and can be used in larger expressions. In contrast, a statement performs an action and serves as a part of a method or <span class="No-Break">program structure.</span></p>
			<p>In C#, every expression can be turned into a statement, but not every statement can be an expression. For example, <strong class="source-inline">x = y + 2</strong> is a statement where <strong class="source-inline">y + 2</strong> is an expression. However, a <strong class="source-inline">for</strong> loop or an <strong class="source-inline">if</strong> statement cannot <span class="No-Break">be ex<a id="_idTextAnchor041"/>pressions.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor042"/>Guided exercise – finding expressions and statements in sample code</h2>
			<p>Let’s exercise your knowledge. Can <a id="_idIndexMarker052"/>you find and count all the<a id="_idIndexMarker053"/> expressions and statements in a slightly more complex <span class="No-Break">code snippet?</span></p>
			<pre class="source-code">
int bookCount = 5;
for(int chapter = 1; chapter &lt;= bookCount; chapter++)
{
     var wordCount = chapter * 1000;
     Console.WriteLine($"Chapter {chapter} contains {wordCount} words.");
}</pre>			<p>Here, we have 8 expressions and 4 <span class="No-Break">statements. S<a id="_idTextAnchor043"/>pecifically:</span></p>
			<ul>
				<li><strong class="bold">Expressions</strong>: <strong class="source-inline">5</strong>, <strong class="source-inline">1</strong>, <strong class="source-inline">chapter</strong>, <strong class="source-inline">bookCount</strong>, <strong class="source-inline">chapter &lt;= bookCount</strong>, <strong class="source-inline">chapter++</strong>, <strong class="source-inline">1000</strong>, <strong class="source-inline">chapter * 1000</strong>, <strong class="source-inline">chapter</strong>, <strong class="source-inline">wordCount</strong>, and <strong class="source-inline">$"Chapter {chapter} contains {</strong><span class="No-Break"><strong class="source-inline">wordCount} words."</strong></span></li>
				<li><strong class="bold">Statements</strong>: <strong class="source-inline">int bookCount = 5;</strong>, <strong class="source-inline">for(int chapter = 1; chapter &lt;= bookCount; chapter++)</strong>, <strong class="source-inline">var wordCount = chapter * 1000;</strong>, and <strong class="source-inline">Console.WriteLine($"Chapter {chapter} contains {</strong><span class="No-Break"><strong class="source-inline">wordCount} words.");</strong></span></li>
			</ul>
			<p>Understanding the difference between expressions and statements helps you write better, clearer code. As you keep learning C#, you’ll get used to these basics and be able to make <a id="_idIndexMarker054"/>better<a id="_idIndexMarker055"/> software. Keep going with this knowledge, and let’s keep exploring <span class="No-Break">functiona<a id="_idTextAnchor044"/>l programming.</span></p>
			<h1 id="_idParaDest-37">How to use expressions for clear a<a id="_idTextAnchor045"/>nd simple code</h1>
			<p>Using short and clear<a id="_idIndexMarker056"/> code makes it easy to understand what it’s doing. It’s also easier for you and others to read later on. Using expressions in C# can help us do this. Let’s learn how to shape our code <span class="No-Break">wi<a id="_idTextAnchor046"/>th expressions.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor047"/>The power of expressions – improving readability and maintainability</h2>
			<p>Expressions support<a id="_idIndexMarker057"/> the idea of immutability, a cornerstone of functional programming. Since expressions evaluate to a value and don’t modify the state of our program, they allow us to write code that’s less prone to bugs, easier to reason about, and simple <span class="No-Break">to test.</span></p>
			<p>One day, Steve received a phone call from his old friend Irene, a renowned author of children’s books. She had begun to notice that books with longer titles seemed to be more popular. To test her theory, she gathered the titles of all the top-selling books and asked Steve to develop a program to calculate the average title length associated <span class="No-Break">with popularity.</span></p>
			<p>Initially, Steve created the program in the manner he was <span class="No-Break">accustomed to:</span></p>
			<pre class="source-code">
double averageLength = 0;
foreach (string title in bookTitles)
{
    int titleLength = title.Length;
    averageLength += titleLength;
}
averageLength /= bookTitles.Length;</pre>			<p>However, the code looked wordy, and he decided to practice a functional approach and rewrite the code. He replaced the <strong class="source-inline">foreach</strong> loop with a simple  <strong class="source-inline">Average</strong> expression that computes the average <span class="No-Break">character count:</span></p>
			<pre class="source-code">
var averageLength = bookTitles.Average(title =&gt; title.Length);</pre>			<p>With what almost<a id="_idIndexMarker058"/> seemed like magic, all these computations became just a single line of code. One line of more functional and concise code using expressions inste<a id="_idTextAnchor048"/>ad <span class="No-Break">of statements.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor049"/>Techniques to convert statements to expressions</h2>
			<p>A great step <a id="_idIndexMarker059"/>toward embracing functional programming<a id="_idIndexMarker060"/> in C# is turning your statements into expressions where possible. As we just saw, <strong class="bold">LINQ</strong> (which stands for <strong class="bold">Language INtegrated Query</strong>) can be <a id="_idIndexMarker061"/>a powerful tool in <span class="No-Break">this transformation.</span></p>
			<p>In the previous example, we used the <strong class="source-inline">Average</strong> method from LINQ. These are extension methods available for any <strong class="source-inline">IEnumerable&lt;T&gt;</strong>, allowing us to perform complex operations on collections with simple, <span class="No-Break">expressive code.</span></p>
			<p>We can further leverage other LINQ methods, such as <strong class="source-inline">Where</strong> for filtering, <strong class="source-inline">OrderBy</strong> for sorting, and <strong class="source-inline">Aggregate</strong> for reducing a collection to a <span class="No-Break">single value.</span></p>
			<p>Also, the code can be transformed to comply with the functional approach even without LINQ methods. For example, we can convert <strong class="source-inline">if</strong> statements into a <span class="No-Break">conditional operator:</span></p>
			<pre class="source-code">
// If-else statement
string bookStatus;
if (pageCount &gt; 300)
{
     bookStatus = "Long read";
}
else
{
     bookStatus = "Quick read";
}
// Conditional operator
string bookStatus = pageCount &gt; 300 ? "Long read" : "Quick read";</pre>			<p>Moreover, all <strong class="source-inline">for</strong>, <strong class="source-inline">while</strong>, <strong class="source-inline">foreach</strong>, and so on loops can be replaced with recursive methods, which will<a id="_idIndexMarker062"/> be expressions when run. In addition, we<a id="_idIndexMarker063"/> can use the <strong class="source-inline">Result</strong> type instead of exceptions and higher-order functions, which will be discus<a id="_idTextAnchor050"/>sed in <span class="No-Break">later chapters.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor051"/>Guided exercise – refactoring code using expressions</h2>
			<p>Emily approached<a id="_idIndexMarker064"/> Steve with a request to help her create <a id="_idIndexMarker065"/>a program that would display the view count of her YouTube videos. However, Emily’s channel comprises both private and public videos, and she was interested in counting views only for her <span class="No-Break">public ones.</span></p>
			<p>Steve wrote a program in which the primary method of counting views looked <span class="No-Break">like this:</span></p>
			<pre class="source-code">
string GetPublicVideosViewsMessage(IEnumerable&lt;Video&gt; videos)
{
     int totalPublicViews = 0;
     foreach (Video video in videos)
     {
          if (video.IsPublic)
          {
               totalPublicViews += video.Views;
          }
     }
     return $"Public videos have {totalPublicViews} views";
}</pre>			<p>Then, Steve thought he should use this chance to get better at using the functional approach and <a id="_idIndexMarker066"/>expressions instead of statements. So, he<a id="_idIndexMarker067"/> made changes to his code using expressions and LINQ methods to make the code clearer and shorter. Now the new version looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
string GetPublicVideosViewsMessage(IEnumerable&lt;Video&gt; videos)
{
     var totalPublicViews = videos
               .Where(v =&gt; v.IsPublic)
               .Sum(v =&gt; v.Views);
     return $"Public videos have {totalPublicViews} views";
}</pre>			<p>Here’s what <span class="No-Break">we changed:</span></p>
			<ul>
				<li>The <strong class="source-inline">if</strong> statement has been replaced with the <strong class="source-inline">Where</strong> method. This method filters out the elements that do not satisfy a certain condition – in this case, where <strong class="source-inline">v.IsPublic</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li>The loop that manually adds each video’s views to <strong class="source-inline">totalPublicViews</strong> has been replaced with the <strong class="source-inline">Select</strong> method. This method transforms each element – in this case, it takes each video (<strong class="source-inline">v</strong>) and transforms it into its view <span class="No-Break">count (</span><span class="No-Break"><strong class="source-inline">v.Views</strong></span><span class="No-Break">).</span></li>
				<li>Finally, the <strong class="source-inline">Sum</strong> method adds up the views from each of the public videos to get <span class="No-Break">the total.</span></li>
			</ul>
			<p>By using LINQ methods and expressions, the resulting code is clearer, more declarative, and more concise. We can now see at a glance what the code does – calculate the total number of views <a id="_idIndexMarker068"/>for<a id="_idIndexMarker069"/> all public videos – rather than how it does it. This is the power of expressions in C# – they allow for cleane<a id="_idTextAnchor052"/>r, more <span class="No-Break">human-readable code.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor053"/>Lambda expressions, expression-bodied members, and anonymous methods</h1>
			<p>Modern C# syntax offers a set of powerful tools for expressing complex functionality with elegance and brevity. Let’s take a closer look at these language features and how we can use them to make our code more functional,<a id="_idTextAnchor054"/> readable, <span class="No-Break">and maintainable.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor055"/>What are lambda expressions?</h2>
			<p>Lambda expressions, denoted<a id="_idIndexMarker070"/> by the <strong class="source-inline">=&gt;</strong> symbol, are a succinct way to create anonymous functions. Most likely, you use them daily when working with LINQ and similar functional <span class="No-Break">programming constructs.</span></p>
			<p>So, let’s look at the following example where we define a lambda to square <span class="No-Break">a number:</span></p>
			<pre class="source-code">
Func&lt;Book, int&gt; getWordCount = book =&gt; book.PageCount * 250;</pre>			<p>This defines a lambda expression that takes an integer, <strong class="source-inline">x</strong>, and returns its square. We can then use this function <span class="No-Break">like so:</span></p>
			<pre class="source-code">
int wordCount = getWordCount(book);</pre>			<p>Lambda expressions offer great flexibility in parameter types and return values. They can take multiple <a id="_idIndexMarker071"/>parameters, return complex objects, or even have no para<a id="_idTextAnchor056"/>meters or return value <span class="No-Break">at all.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor057"/>Multiple parameters in lambda expressions</h2>
			<p>Of course, methods <a id="_idIndexMarker072"/>in C# can contain more than one parameter, and lambda expressions can do so as well. In LINQ, one of the easiest methods to demonstrate it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">SelectMany</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
List&lt;Publisher&gt; publishers = GetPublishers();
List&lt;Book&gt; books = GetBooks();
var publisherBookPairs = publishers.SelectMany(
    publisher =&gt; books.Where(book =&gt; book.PublisherId == publisher.Id),
    (publisher, book) =&gt; new { PublisherName = publisher.Name, BookTitle = book.Title }
);</pre>			<p>Here, in addition to the collection of books and the one-parameter lambda expression, <strong class="source-inline">publisher =&gt; books.Where(book =&gt; book.PublisherId == publisher.Id)</strong>, this method also takes a two-parameter lambda expression, <strong class="source-inline">(publisher, book) =&gt; new { PublisherName = publisher.Name, BookTitle = book.Title }</strong>. As you can see, we just need to add parenthesis <a id="_idTextAnchor058"/>to use any number <span class="No-Break">of variables.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor059"/>Lambda expressions evolution</h2>
			<p>Being a teacher in <a id="_idIndexMarker073"/>online C# courses, I like to illustrate the “evolution” of lambda expressions to my students. The first thing you need to know here is that this type of expression is just syntactic sugar over methods. Let’s look at <span class="No-Break">this example:</span></p>
			<pre class="source-code">
bool IsBookPopular(Book book)
{
     if (book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000)
     {
          return true;
     }
     return false;
}</pre>			<p>This method calculates whether a book is popular or not and is written in an imperative way (tells how to do things, not what to do). To make it smaller, we can replace <strong class="source-inline">if</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">return</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
bool IsBookPopular(Book book)
{
     return book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000;
}</pre>			<p>To make it even<a id="_idIndexMarker074"/> shorter, let’s use expression-bodied <span class="No-Break">member syntax:</span></p>
			<pre class="source-code">
bool IsBookPopular(Book book) =&gt; book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000;</pre>			<p>If we try to use the same conditions in the LINQ <strong class="source-inline">Where</strong> function, it will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
books.Where(book =&gt; book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000)</pre>			<p>Do you see the similarities? This is basically one and the same, so we can use our function in the <span class="No-Break"><strong class="source-inline">Where</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
books.Where(book =&gt; IsBookPopular(book))</pre>			<p>Here is <span class="No-Break">another example:</span></p>
			<pre class="source-code">
books.Where(IsBookPopular)</pre>			<p>This happens because <strong class="source-inline">Where</strong> takes a <strong class="source-inline">Func&lt;T, bool&gt;</strong> type as its parameter, which is basically what our lambda <span class="No-Break">expression is.</span></p>
			<p>And now let me tell you that the example that we used to understand “lambda expressions evolution” is actually not a lambda expression. Lambda expressions are a syntactic sugar for <a id="_idIndexMarker075"/>anonymous methods, and we used an expression-bodied member here. So, let’s dig deeper and understand<a id="_idTextAnchor060"/> the difference between <span class="No-Break">those two.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor061"/>Understanding anonymous methods</h2>
			<p>Anonymous methods, as the <a id="_idIndexMarker076"/>name suggests, are methods without a name. This ability to write unnamed methods right at the place where they are used, especially as arguments to other methods, is a significant feature of functional programming languages. Here is an interesting fact: anonymous methods are one of the oldest features of C#; they were introduced with <span class="No-Break">version 2.0.</span></p>
			<p>Here is a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
List&lt;Video&gt; videos = GetVideos();
videos.ForEach(delegate(Video video)
     {
         Console.WriteLine($"{video.Title}: {video.Views} views");
     });</pre>			<p>In this example, <strong class="source-inline">delegate(Video video){...}</strong> is an anonymous method, and as you can see, it is used directly as<a id="_idTextAnchor062"/> an argument to the <span class="No-Break"><strong class="source-inline">ForEach</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor063"/>How do anonymous methods work?</h2>
			<p>Anonymous methods <a id="_idIndexMarker077"/>work by generating a hidden method at compile time. The compiler generates a unique name for the method that isn’t valid in the context of C# naming rules, ensuring no possi<a id="_idTextAnchor064"/>ble conflict with your <span class="No-Break">method names.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor065"/>When to use anonymous methods</h2>
			<p>The use of anonymous<a id="_idIndexMarker078"/> methods is particularly suitable when the logic of the method doesn’t justify a full method declaration. If the code is short, easily understandable, and used only in one place, an anonymous method is a <span class="No-Break">good choice.</span></p>
			<p>The most common scenarios for using anonymous methods include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Working with LINQ</strong>: LINQ heavily relies on delegates and anonymous methods, especially when filtering, ordering, or <span class="No-Break">projecting data</span></li>
				<li><strong class="bold">Event handling</strong>: Anonymous methods can be used when attaching events, especially when the event handling code <span class="No-Break">is simple</span></li>
				<li><strong class="bold">Asynchronous programming</strong>: Tasks an<a id="_idTextAnchor066"/>d threads often use <span class="No-Break">anonymous methods</span></li>
			</ul>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor067"/>Practical examples – applying these features in real code</h2>
			<p>Another day on the street, Steve met his old friend Konstatos, founder of a small game studio that develops mobile games. Konstatos said that he wanted to analyze the behavior of a group of players<a id="_idIndexMarker079"/> he called “new whales.” Usually, people who spend much more money than others on something are <a id="_idIndexMarker080"/>called “whales.” So, he needed to get this subset of players using two conditions: firstly, they must have been registered in a game not earlier than a year ago, and secondly, they must <a id="_idTextAnchor068"/>have spent at least $10,000 <span class="No-Break">since then.</span></p>
			<p>Steve happily agreed, and now, having practiced a lot on previous tasks, he came up with this <span class="No-Break">functional solution:</span></p>
			<pre class="source-code">
List&lt;string&gt; GetWhales(IEnumerable&lt;Player&gt; players, DateTime date, decimal minSpend)
{
     return players
     .Where(p =&gt; p.JoinDate &gt; date)
     .Where(p =&gt; p.Spend &gt; minSpend)
     .Select(p =&gt; p.Nickname)
     .ToList();
}</pre>			<p>Pay attention that the condition is broken down into<a id="_idIndexMarker081"/> two <strong class="source-inline">Where</strong> methods. You could do it with just one <span class="No-Break"><strong class="source-inline">Where</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
List&lt;string&gt; GetWhales(IEnumerable&lt;Player&gt; players, DateTime date, decimal minSpend)
{
     return players
     .Where(p =&gt; p.JoinDate &gt; date &amp;&amp; p.Spend &gt; minSpend)
     .Select(p =&gt; p.Nickname)
     .ToList();
}</pre>			<p>However, the cognitive load for <strong class="source-inline">Where</strong> with two conditions inside is greater, which is why the first approach is preferred. Plus, the first method reduces the number of affected lines when making further code changes, it’s easier to expand (you simply add new <strong class="source-inline">Where</strong> methods on new lines), and it causes fewer <span class="No-Break">merge conflicts.</span></p>
			<p>Okay, so now that we have seen anonymous methods, <a id="_idTextAnchor069"/>let’s look at <span class="No-Break">expression-bodied members.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor070"/>Expression-bodied members</h2>
			<p>Expression-bodied<a id="_idIndexMarker082"/> members are a syntax shortcut that allows methods, properties, and other members to be defined using a lambda-like syntax, where the body of the member is defined by a single expression following the <strong class="source-inline">=&gt;</strong> <span class="No-Break">operator.</span></p>
			<p>Consider the following traditional method for <span class="No-Break">calculating royalty:</span></p>
			<pre class="source-code">
public int CalculateRoyalty(Book book)
{
    if(book.CopiesSold &lt; 10000)
    {
        return book.CopiesSold * 0.2;
    }
    else
    {
        return book.CopiesSold * 0.3;
    }
}</pre>			<p>Now, let’s turn this into an <span class="No-Break">expression-bodied member:</span></p>
			<pre class="source-code">
public int CalculateRoyalty(Book book) =&gt;
    book.CopiesSold &lt; 10000
       ? book.CopiesSold * 2
       : book.CopiesSold * 3;</pre>			<p>We’ve condensed our method to a one-liner (a piece of functionality written in a single line), concise line. The improved brevity enhances readability, especially for simple methods and properties. It is important to remember that it is not obligatory for the code to use expression-bodied members to be considered functional style. In my work, I stick to the rule that only single-line expression-bodied members can exist. If the method body starts to contain two or more lines, it is better to have fewer merge conflicts and readability to use a regular syntax <span class="No-Break">for methods.</span></p>
			<p>In the next section, we<a id="_idIndexMarker083"/> will tackle the powerful concept of expression trees and uncover their utility in C#. But first, take some time to absorb these concepts and see how you can use them <a id="_idTextAnchor071"/>to write more expressive and <span class="No-Break">concise code.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor072"/>Exercise – implementing lambda expressions and anonymous methods</h2>
			<p>In order for you to <a id="_idIndexMarker084"/>have more practice with a functional <a id="_idIndexMarker085"/>approach, here is a challenge to refactor the following code using expression-bodied members, lambda expressions, and <span class="No-Break">anonymous methods:</span></p>
			<pre class="source-code">
public bool IsVideoTrending(Video video)
{
     int viewThreshold = CalculateViewThreshold(video.UploadDate);
     return video.Views &gt; viewThreshold;
}
private int CalculateViewThreshold(DateTime uploadDate)
{
     int daysOld = (DateTime.Now - uploadDate).Days;
     return 1000 * daysOld;
}</pre>			<p>While it is quite an<a id="_idIndexMarker086"/> easy task, it can help us to clarify the difference <a id="_idIndexMarker087"/>between standard methods and lambda expression<a id="_idTextAnchor073"/>s, making our code in a more <span class="No-Break">functional style.</span></p>
			<h1 id="_idParaDest-51">Expression trees and how to<a id="_idTextAnchor074"/> use them to manipulate expressions at runtime</h1>
			<p>Expression trees <a id="_idIndexMarker088"/>offer a unique capability in C#: the ability to treat code as data<a id="_idIndexMarker089"/> and manipulate it at runtime. They are central to the functionality of LINQ, allowing us to use the same query syntax for in-memory objects and external data sources. Let’s explore this fascinating feature. At a high level, an expression tree is a data structure that represents some code in a tree-like format, where each node is an expression. Expression trees are constructed from lambda expressions and allow you to inspect the code within the lambda <span class="No-Break">as data.</span></p>
			<p>To illustrate this, consider a simple <span class="No-Break">lambda expression:</span></p>
			<pre class="source-code">
Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b;</pre>			<p>Now, let’s rewrite it as a <span class="No-Break">binary expression:</span></p>
			<pre class="source-code">
ParameterExpression a = Expression.Parameter(typeof(int), "a");
ParameterExpression b = Expression.Parameter(typeof(int), "b");
ParameterExpression c = Expression.Parameter(typeof(int), "c");
BinaryExpression addExpression = Expression.Add(a, b);</pre>			<p>The difference <a id="_idIndexMarker090"/>might be not significant in code, but let’s look at the inner<a id="_idIndexMarker091"/> representation of our variables. Here is <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">add</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B21069_02_001.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>As you can see, it has only two fields: <strong class="source-inline">Target</strong>, the class in which this method is, and the <strong class="source-inline">Method</strong> field, with the method’s information. Not that much to look at. Now, let’s look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">addExpression</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B21069_02_002.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>As you can see, the<a id="_idIndexMarker092"/> expression <a id="_idIndexMarker093"/>has <strong class="source-inline">NodeType</strong> as <strong class="source-inline">Add</strong> and two parts: <strong class="source-inline">Left</strong> and <strong class="source-inline">Right</strong>. Visually, it can be represented <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B21069_02_003.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Not scary at all, <a id="_idTextAnchor075"/>right? If so, let’s move on to <span class="No-Break">expression trees.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor076"/>Building and manipulating expression trees</h2>
			<p>Building an expression tree manually provides a deeper understanding of its structure. Let’s recreate our <span class="No-Break">addition expression:</span></p>
			<pre class="source-code">
// Define parameters
ParameterExpression a = Expression.Parameter(typeof(int), "a");
ParameterExpression b = Expression.Parameter(typeof(int), "b");
// Define body
BinaryExpression body = Expression.Add(a, b);
// Combine them
Expression&lt;Func&lt;int, int, int&gt;&gt; addExpression = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(body, a, b);</pre>			<p>This code creates<a id="_idIndexMarker094"/> the <a id="_idIndexMarker095"/>same expression tree as before but shows the structure more clearly. The lambda is formed from a body, <strong class="source-inline">(a + b)</strong>, and a list of parameters, <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">a, b)</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B21069_02_004.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Now, our <a id="_idIndexMarker096"/>expression<a id="_idIndexMarker097"/> tree has two main branches, <strong class="source-inline">Body</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Parameters</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B21069_02_005.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>That looks more <a id="_idIndexMarker098"/>like a <a id="_idIndexMarker099"/>tree to me. However, it has only one operation in it and real expression trees usually contain multiple operations. Let’s add a <span class="No-Break">multiplication operation:</span></p>
			<pre class="source-code">
// Define parameters
ParameterExpression a = Expression.Parameter(typeof(int), "a");
ParameterExpression b = Expression.Parameter(typeof(int), "b");
ParameterExpression c = Expression.Parameter(typeof(int), "c");
// Define bodies for addition and multiplication
BinaryExpression addBody = Expression.Add(a, b);
BinaryExpression multiplyBody = Expression.Multiply(addBody, c);
// Combine them
Expression&lt;Func&lt;int, int, int, int&gt;&gt; combinedExpression = Expression.Lambda&lt;Func&lt;int, int, int, int&gt;&gt;(multiplyBody, a, b, c);</pre>			<p>This example is <a id="_idIndexMarker100"/>much<a id="_idIndexMarker101"/> more interesting, and its inner representation <span class="No-Break">is bigger:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B21069_02_006.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>And this is what our modified visual tree <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B21069_02_007.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>I hope that now<a id="_idIndexMarker102"/> you<a id="_idIndexMarker103"/> have a better understanding of what an expression tree looks like. This <a id="_idTextAnchor077"/>will help us to move forward to a more <span class="No-Break">complex example.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor078"/>Creating and manipulating complex expression trees</h2>
			<p>The other day, Irene <a id="_idIndexMarker104"/>asked Steve to meet her publisher. It appeared<a id="_idIndexMarker105"/> that the publisher wanted a program to easily filter popular books. Steve gladly agreed and created the advanced filter as an expression tree for <span class="No-Break">their system.</span></p>
			<p>The filter checks whether a book’s title contains a specific keyword, whether its number of pages is more than a particular limit, and whether its rating is above a certain threshold. Therefore, the expression tree has three <span class="No-Break">different expressions:</span></p>
			<pre class="source-code">
// Define parameters
ParameterExpression book = Expression.Parameter(typeof(Book), "book");
ParameterExpression keyword = Expression.Parameter(typeof(string), "keyword");
ParameterExpression minPages = Expression.Parameter(typeof(int), "minPages");
ParameterExpression minRating = Expression.Parameter(typeof(double), "minRating");
// Define body
MethodCallExpression titleContainsKeyword = Expression.Call(
    Expression.Property(book, nameof(Book.Title)),
    typeof(string).GetMethod("Contains", new[] { typeof(string) }),
    keyword
);
BinaryExpression pagesGreaterThanMinPages = Expression.GreaterThan(
    Expression.Property(book, nameof(Book.Pages)),
    minPages
);
BinaryExpression ratingGreaterThanMinRating = Expression.GreaterThan(
    Expression.Property(book, nameof(Book.Rating)),
    minRating
);
// Combine expressions with 'AND' logical operator
BinaryExpression andExpression = Expression.AndAlso(
    Expression.AndAlso(titleContainsKeyword, pagesGreaterThanMinPages),
    ratingGreaterThanMinRating
);
// Combine parameters and body into a lambda expression
Expression&lt;Func&lt;Book, string, int, double, bool&gt;&gt; filterExpression = Expression.Lambda&lt;Func&lt;Book, string, int, double, bool&gt;&gt;(
    andExpression,
    book, keyword, minPages, minRating
);</pre>			<p>The only thing they need to do in their publishing system is to use <strong class="source-inline">filterExpression</strong> to create a delegate for filtering books and <span class="No-Break">use it:</span></p>
			<pre class="source-code">
var filter = filterExpression.Compile();
var popularBooks = books
    .Where(book =&gt; filter(book, keyword, minPages, minRating))
    .ToList();</pre>			<p>The real power of expression trees comes from their ability to be manipulated at runtime. You can <a id="_idIndexMarker106"/>dynamically build, modify, or even compile and run<a id="_idIndexMarker107"/> expression trees. This is a powerful tool for runtime code generation and provides th<a id="_idTextAnchor079"/>e basis for technologies such as LINQ and <span class="No-Break">Entity Framework.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor080"/>Querying data with expression trees – LINQ and beyond</h2>
			<p>LINQ uses <a id="_idIndexMarker108"/>expression<a id="_idIndexMarker109"/> trees under the hood to enable the same <a id="_idIndexMarker110"/>query syntax for different types of data. When you write a LINQ query against an <strong class="source-inline">IQueryable&lt;T&gt;</strong>, you’re actually building an expression tree. This tree is then passed to the query provider, which translates it into the appropriate format (such as SQL for <span class="No-Break">a database).</span></p>
			<p>Here’s an example of a LINQ query that gets translated into SQL by Entity Framework (a popular tool to work with databases <span class="No-Break">in C#):</span></p>
			<pre class="source-code">
var youngCustomers = dbContext.Customers
    .Where(c =&gt; c.Age &lt; 30)
    .Select(c =&gt; new { c.Name, c.Age });</pre>			<p>When this query is run, Entity Framework generates an expression tree, converts it into SQL, sends it to<a id="_idTextAnchor081"/> the <a id="_idIndexMarker111"/>database, and materializes the<a id="_idIndexMarker112"/> results back <span class="No-Break">into objects.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor082"/>Guided exercise – constructing and manipulating expression trees</h1>
			<p>To help you<a id="_idIndexMarker113"/> understand expression trees better, let’s look at this <a id="_idIndexMarker114"/>exercise. Our goal is to create an expression tree representing the lambda expression <strong class="source-inline">(x, y) =&gt; x * y</strong>. This represents a multiplication operation. Afterward, we’ll compile and invoke this expression, effectively performing the multiplication of <span class="No-Break">two numbers.</span></p>
			<p>Let’s break down <span class="No-Break">the steps:</span></p>
			<ol>
				<li>Define the parameters for the lambda expression. These are <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>, which are both of the <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type:</span><pre class="source-code">
ParameterExpression x = Expression.Parameter(typeof(int), "x");
ParameterExpression y = Expression.Parameter(typeof(int), "y");</pre></li>				<li>Construct the body of the lambda expression. This is the <strong class="source-inline">x * </strong><span class="No-Break"><strong class="source-inline">y</strong></span><span class="No-Break"> operation:</span><pre class="source-code">
BinaryExpression body = Expression.Multiply(x, y);</pre></li>				<li>Now, we combine the parameters and the body into a <span class="No-Break">lambda expression:</span><pre class="source-code">
Expression&lt;Func&lt;int, int, int&gt;&gt; multiplyExpression = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(body, x, y);</pre></li>				<li>Now that we have our expression tree, we can compile it into <span class="No-Break">a delegate:</span><pre class="source-code">
Func&lt;int, int, int&gt; multiply = multiplyExpression.Compile();</pre></li>				<li>Invoke the delegate with <span class="No-Break">two numbers:</span><pre class="source-code">
int result = multiply(6, 7); // This returns 42</pre></li>			</ol>
			<p>Awesome! We have successfully created an expression tree that represents a lambda expression, compiled it, and invoked it. This is a fundamental step in understanding how expression trees in C# allow us to use code as data, opening up powerful, dynamic <span class="No-Break">programming possibilities.</span></p>
			<p>Keep practicing these steps with different lambda expressions. Mastery of expression trees lets you<a id="_idIndexMarker115"/> harness the full potential of C#, giving you capabilities<a id="_idIndexMarker116"/> such as dynamic code generation and manipulation, advance<a id="_idTextAnchor083"/>d querying abilities, and much more. Keep at it, you’re <span class="No-Break">doing great!</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor084"/>Problem sets and exercises</h1>
			<p>After reading<a id="_idIndexMarker117"/> about <a id="_idIndexMarker118"/>expressions<a id="_idIndexMarker119"/> and<a id="_idIndexMarker120"/> statements, lambda expressions, and expression trees, Steve wrote an email to Julia, asking for the best way to get more hands-on experience. Julia congratulated Steve and sent him the list with five points that from her understanding every person trying to learn this topic <span class="No-Break">should do:</span></p>
			<ol>
				<li><strong class="bold">Implement a Filter method</strong> that takes an <strong class="source-inline">IEnumerable&lt;T&gt;</strong> and a predicate in the form of an expression tree and returns the filtered results. Use it to filter a list of strings based on <span class="No-Break">their length.</span></li>
				<li><strong class="bold">Refactor a class</strong> with traditional methods into a version using expression-bodied members where appropriate. Compare the <span class="No-Break">two versions.</span></li>
				<li><strong class="bold">Write an application</strong> that takes a mathematical expression as a string at runtime, converts it into an expression tree, and evaluates it. The application should support operations such as addition, subtraction, multiplication, <span class="No-Break">and division.</span></li>
				<li><strong class="bold">Design a mini query language</strong> for querying in-memory objects. This language should support basic operations such as filtering and sorting. Use expression trees to <span class="No-Break">implement it.</span></li>
				<li><strong class="bold">Code review a project</strong>. Find an open source project on GitHub that uses C#, and examine the code to identify where these features (expression-bodied members, lambda expressions, and anonymous methods) are used. Analyze how they contribute <a id="_idIndexMarker121"/>to<a id="_idIndexMarker122"/> the<a id="_idIndexMarker123"/> code’s <a id="_idIndexMarker124"/>readability <span class="No-Break">and maintainability.</span></li>
			</ol>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor085"/>Exercises</h1>
			<p>In this section, you will help Steve to develop and refactor his tower defense game in a functional <span class="No-Break">programming way.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor086"/>Exercise 1</h2>
			<p>Name and count all expressions and all statements in the code <span class="No-Break">snippet below:</span></p>
			<pre class="source-code">
Tower mainTower = new(position: new Vector2(5, 5));
for (int level = 1; level &lt;= mainTower.MaxLevel; level++)
{
     double upgradeCost = 100 * Math.Pow(1.5, level - 1);
     Console.WriteLine($"Upgrading to level {level} costs {upgradeCost} gold");
     if (playerGold &gt;= upgradeCost)
     {
                  mainTower.Upgrade();
                  playerGold -= upgradeCost;
     }
}</pre>			<h2 id="_idParaDest-59"><a id="_idTextAnchor087"/>Exercise 2</h2>
			<p>Refactor the code below to use expressions instead <span class="No-Break">of statements</span></p>
			<pre class="source-code">
string GetTowerDamageReport(IEnumerable&lt;Tower&gt; towers)
{
      int totalDamage = 0;
      foreach (Tower tower in towers)
      {
           if (tower.IsActive)
           {
                totalDamage += tower.Damage;
           }
      }
      return $"Active towers deal {totalDamage} total damage";
}</pre>			<h2 id="_idParaDest-60"><a id="_idTextAnchor088"/>Exercise 3</h2>
			<p>Create an expression tree that is the lambda expression, <strong class="source-inline">(x, y) =&gt; x * y</strong>. Then, compile and invoke it to multiply <span class="No-Break">two numbers.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor089"/>Solutions</h1>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor090"/>Exercise 1</h2>
			<pre class="source-code">
Tower mainTower = new(position: new Vector2(5, 5));
for (int level = 1; level &lt;= mainTower.MaxLevel; level++)
{
     double upgradeCost = 100 * Math.Pow(1.5, level - 1);
     Console.WriteLine($"Upgrading to level {level} costs {upgradeCost} gold");
     if (playerGold &gt;= upgradeCost)
     {
                  mainTower.Upgrade();
                  playerGold -= upgradeCost;
     }
}</pre>			<p><span class="No-Break">Expressions:</span></p>
			<ul>
				<li><strong class="source-inline">new </strong><span class="No-Break"><strong class="source-inline">Vector2(5, 5)</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">5 (x-coordinate)</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">5 (y-coordinate)</strong></span></li>
				<li><strong class="source-inline">new(position: new </strong><span class="No-Break"><strong class="source-inline">Vector2(5, 5))</strong></span></li>
				<li><strong class="source-inline">1</strong></li>
				<li><span class="No-Break"><strong class="source-inline">level</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">mainTower.MaxLevel</strong></span></li>
				<li><strong class="source-inline">level &lt;= </strong><span class="No-Break"><strong class="source-inline">mainTower.MaxLevel</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">level++</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">100</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">1.5</strong></span></li>
				<li><strong class="source-inline">1</strong></li>
				<li><strong class="source-inline">level - 1</strong></li>
				<li><strong class="source-inline">Math.Pow(1.5, level - </strong><span class="No-Break"><strong class="source-inline">1)</strong></span></li>
				<li><strong class="source-inline">100 * Math.Pow(1.5, level - </strong><span class="No-Break"><strong class="source-inline">1)</strong></span></li>
				<li><strong class="source-inline">level (in </strong><span class="No-Break"><strong class="source-inline">string interpolation)</strong></span></li>
				<li><strong class="source-inline">upgradeCost (in </strong><span class="No-Break"><strong class="source-inline">string interpolation)</strong></span></li>
				<li><strong class="source-inline">$"Upgrading to level {level} costs {</strong><span class="No-Break"><strong class="source-inline">upgradeCost} gold"</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">playerGold</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">upgradeCost</strong></span></li>
				<li><strong class="source-inline">playerGold &gt;= </strong><span class="No-Break"><strong class="source-inline">upgradeCost</strong></span></li>
				<li><strong class="source-inline">upgradeCost (</strong><span class="No-Break"><strong class="source-inline">in subtraction)</strong></span></li>
			</ul>
			<p><span class="No-Break">Statements:</span></p>
			<ul>
				<li><strong class="source-inline">Tower mainTower = new(position: new </strong><span class="No-Break"><strong class="source-inline">Vector2(5, 5));</strong></span></li>
				<li><strong class="source-inline">for (int level = 1; level &lt;= </strong><span class="No-Break"><strong class="source-inline">mainTower.MaxLevel; level++)</strong></span></li>
				<li><strong class="source-inline">double upgradeCost = 100 * Math.Pow(1.5, level - </strong><span class="No-Break"><strong class="source-inline">1);</strong></span></li>
				<li><strong class="source-inline">Console.WriteLine($"Upgrading to level {level} costs {</strong><span class="No-Break"><strong class="source-inline">upgradeCost} gold");</strong></span></li>
				<li><strong class="source-inline">if (playerGold &gt;= </strong><span class="No-Break"><strong class="source-inline">upgradeCost)</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">mainTower.Upgrade();</strong></span></li>
				<li><strong class="source-inline">playerGold -= </strong><span class="No-Break"><strong class="source-inline">upgradeCost;</strong></span></li>
			</ul>
			<p>Total: 22 expressions and <span class="No-Break">7 statements</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor091"/>Exercise 2</h2>
			<pre class="source-code">
string GetTowerDamageReport(IEnumerable&lt;Tower&gt; towers) =&gt;
     $"Active towers deal {towers.Where(t =&gt; t.IsActive).Sum(t =&gt; t.Damage)} total damage";</pre>			<p>This refactored version uses LINQ expressions to filter active towers and sum their damage in a single line, eliminating the need for explicit loops and <span class="No-Break">conditional statements.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor092"/>Exercise 3</h2>
			<pre class="source-code">
ParameterExpression baseDamage = Expression.Parameter(typeof(int), "baseDamage");
ParameterExpression level = Expression.Parameter(typeof(int), "level");
BinaryExpression multiply = Expression.Multiply(baseDamage, level);
Expression&lt;Func&lt;int, int, int&gt;&gt; damageCalc = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(multiply, baseDamage, level);
// Compile the expression
Func&lt;int, int, int&gt; calculateDamage = damageCalc.Compile();
// Calculate tower damage
int towerDamage = calculateDamage(10, 5);
Console.WriteLine($"Tower damage: {towerDamage}");</pre>			<p>This solution creates an expression tree representing <strong class="source-inline">(baseDamage, level) =&gt; baseDamage * level</strong>, compiles it into a function, and then invokes that functio<a id="_idTextAnchor093"/>n to calculate a tower’s damage based on its base damage (10) and <span class="No-Break">level (5).</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor094"/>Summary</h1>
			<p>In this chapter, we dove into functional programming in C#, focusing on expressions and statements, and the powerful tools that C# provides to elevate your code. Let’s summarize the <span class="No-Break">key takeaways:</span></p>
			<ul>
				<li>We learned the difference between expressions and statements. Functional programming often prefers expressions for their simple and <span class="No-Break">direct style.</span></li>
				<li>We looked at expression-bodied members, which give a shorter and cleaner way to write methods <span class="No-Break">and properties.</span></li>
				<li>We studied lambda expressions and anonymous methods. Both help in writing clear, brief, and <span class="No-Break">contained code.</span></li>
				<li>We touched on expression trees, a special feature in C# that lets us handle code-like data. This is useful for things such as data queries <span class="No-Break">in LINQ.</span></li>
			</ul>
			<p>Throughout, our goal was to understand not just how to use these tools but also why and when <span class="No-Break">they’re helpful.</span></p>
			<p>Next, we’ll learn about pure functions, what makes a method “pure,” and what side <span class="No-Break">effects mean.</span></p>
		</div>
	</body></html>