<html><head></head><body>
        

                            
                    <h1 class="header-title">Mastering Practical Animations</h1>
                
            
            
                
<p>WPF offers a wide range of animation possibilities, from the simple to the really quite complex. In this chapter, we will thoroughly explore the WPF property animation system, yet focus primarily on those parts that can be suitably applied to real-world business applications. We'll investigate how to control running animations in real time and predominantly concentrate on XAML-based syntax. We'll then see how we can build animations right into our application framework.</p>
<p>In WPF, animations are created by repeatedly altering individual property values at regular intervals. Animations are comprised of a number of components: we need a timing system, an animation object that is responsible for updating the values of a particular type of object and a suitable property to animate.</p>
<p>In order to be able to animate a property, it must be a Dependency Property of a <kbd>DependencyObject</kbd> and its type must implement the <kbd>IAnimatable</kbd> interface. As most UI controls extend the <kbd>DependencyObject</kbd> class, this enables us to animate the properties of most controls.</p>
<p>Furthermore, an animation object for the relevant type of property must exist. In WPF, the animation objects also double up as the timing system, as they extend the <kbd>Timeline</kbd> class. Before investigating the various animation objects, let's first examine the timing system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Investigating timelines</h1>
                
            
            
                
<p>Animations require some kind of timing mechanism that is responsible for updating the relevant property values at the right time. In WPF, this timing mechanism is catered for by the abstract <kbd>Timeline</kbd> class, which in short, represents a period of time. All of the available animation classes extend this class and add their own animation functionality.</p>
<p>When a <kbd>Timeline</kbd> class is used for animations, an internal copy is made and frozen, so that it is immutable. Additionally, a <kbd>Clock</kbd> object is created to preserve the runtime timing state of the <kbd>Timeline</kbd> object and is responsible for the actual timing of the animated property updates. The <kbd>Timeline</kbd> object itself does little other than define the relevant period of time.</p>
<p>The <kbd>Clock</kbd> object will be automatically created for us when we define a <kbd>Storyboard</kbd> object, or call one of the <kbd>Animatable.BeginAnimation</kbd> methods. Note that we do not typically need to concern ourselves with these <kbd>Clock</kbd> objects directly, but it can be helpful to know about them in order to understand the bigger picture.</p>
<p>There are a number of different types of <kbd>Timeline</kbd> objects, from the <kbd>AnimationTimeline</kbd> class to the <kbd>TimelineGroup</kbd> and <kbd>ParallelTimeline</kbd> classes. However, for animation purposes, we predominantly utilize the <kbd>Storyboard</kbd> class, which extends the <kbd>ParallelTimeline</kbd> and the <kbd>TimelineGroup</kbd> classes and adds animation-targeting properties and methods for controlling the timeline. Let's first investigate the main properties of the base <kbd>Timeline</kbd> class.</p>
<p>The <kbd>Duration</kbd> property specifies the time that is represented by the associated <kbd>Timeline</kbd> object. However, a timeline can have repetitions, so a more accurate description of the <kbd>Duration</kbd> property might be that it specifies the time of a single iteration of the associated <kbd>Timeline</kbd> object.</p>
<p>The duration property is of type <kbd>Duration</kbd>, which contains a <kbd>TimeSpan</kbd> property that contains the actual time that specifies the value of the duration. However, WPF includes a type converter that enables us to specify this <kbd>TimeSpan</kbd> value in XAML in the following formats, where the square brackets highlight optional segments:</p>
<pre>Duration="[Days.]Hours:Minutes:Seconds[.FractionalSeconds]" 
Duration="[Days.]Hours:Minutes" </pre>
<p>However, the <kbd>Duration</kbd> structure also accepts other values in addition to the <kbd>TimeSpan</kbd> duration. There is a value of <kbd>Automatic</kbd>, which is the default value for component timelines that contain other timelines. In these cases, this value simply means that the parent timeline's duration will be as long as the longest duration of its children timelines. There is little purpose for us to explicitly use this value.</p>
<p>However, there is one further value that is very useful to us. The <kbd>Duration</kbd> structure also defines a <kbd>Forever</kbd> property that represents an infinite period of time. We can use this value to make an animation continue indefinitely, or more accurately, as long as its related View is being displayed:</p>
<pre>Duration="Forever" </pre>
<p>A <kbd>Timeline</kbd> object will stop playing when it reaches the end of its duration. If it has any child timelines associated with it, then they will also stop playing at this point. However, the natural duration of a timeline can be extended or shortened using other properties, as we will see shortly.</p>
<p>Some timelines, such as the <kbd>ParallelTimeline</kbd> and <kbd>Storyboard</kbd> classes, are able to contain other timelines and can affect their durations by setting their own values for the <kbd>Duration</kbd> property, which will override those set by the child timelines. Let's alter an earlier animation example from <a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, <em>Using the Right Controls for the Job</em> to demonstrate this:</p>
<pre>&lt;Rectangle Width="0" Height="0" Fill="Orange"&gt; 
  &lt;Rectangle.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard Duration="0:0:2.5"&gt; 
          &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="300.0" 
            Duration="0:0:2.5" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="300.0"
            Duration="0:0:5" /&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/Rectangle.Triggers&gt; 
&lt;/Rectangle&gt; </pre>
<p>In this preceding example, we have a <kbd>Rectangle</kbd> object with its dimensions initially set to zero. The <kbd>Storyboard</kbd> object contains two separate animation objects that will animate its dimensions from zero to three hundred pixels. The animation object that will animate the rectangle's width has a duration of two and a half seconds, while the animation object that will animate the height has a duration of five seconds.</p>
<p>However, the containing <kbd>Storyboard</kbd> object has a duration of two and a half seconds and so this will stop the timelines of the two child animation objects after two and a half seconds, regardless of their declared durations. The result of this will be that after the animation is complete, our <kbd>Rectangle</kbd> object will appear as a rectangle, instead of a square with equal height and width values.</p>
<p>If we had changed the duration of the storyboard to match that of the longer child animation, or changed that animation duration to match that of the shorter child animation, then our animated shape would end as a square, rather than as a rectangle.</p>
<p> </p>
<p>Another way to adjust the assigned duration of an animation element is to set its <kbd>AutoReverse</kbd> property. In effect, setting this property to <kbd>True</kbd> will usually double the length of time that is specified by the <kbd>Duration</kbd> property, as the timeline will play in reverse after it has completed its normal forwards iteration. Let's alter the storyboard from the previous example to demonstrate this:</p>
<pre>&lt;Storyboard Duration="0:0:5"&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="300.0"  
    Duration="0:0:2.5" AutoReverse="True" /&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="300.0"  
    Duration="0:0:5" /&gt; 
&lt;/Storyboard&gt; </pre>
<p>Now, both child timelines will have the same overall duration, as the first, previously shorter, timeline has effectively been doubled in length. However, this will result in the first timeline animating the width of the rectangle to three hundred pixels and then back to zero, so it will be invisible when the animations have completed. Also note that we had to set the parent storyboard duration to five seconds in order to see the difference in the child timelines.</p>
<p>Note again that properties set on timelines that contain other timelines will affect the values of those properties on the child timelines. As such, setting the <kbd>AutoReverse</kbd> property to <kbd>True</kbd> on the parent timeline (the <kbd>Storyboard</kbd> object) will double the total length of time that the child animations will run for; in our case, using the following example, the rectangle will now be animated for ten seconds in total:</p>
<pre>&lt;Storyboard Duration="0:0:5" AutoReverse="True"&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="300.0"  
    Duration="0:0:2.5" AutoReverse="True" /&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="300.0"  
    Duration="0:0:5" /&gt; 
&lt;/Storyboard&gt; </pre>
<p>The <kbd>RepeatBehavior</kbd> property is of type <kbd>RepeatBehavior</kbd> and can also affect the overall duration of a timeline. Unlike the <kbd>AutoReverse</kbd> property, it can also shorten the overall duration as well as lengthen it. Using the <kbd>RepeatBehavior</kbd> property, we can specify the value in a number of ways using different behaviors.</p>
<p> </p>
<p>The most simple is to provide a count of how many times we would like to multiply the original duration of the timeline. A pre-existing XAML type converter enables us to set the repeat count in XAML by specifying an <kbd>x</kbd> after the count, as can be seen in the following example. Note that we can also specify numbers with decimal places here, including values less than one:</p>
<pre>&lt;Storyboard Duration="0:0:5" AutoReverse="True" RepeatBehavior="2x"&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="300.0"  
    Duration="0:0:2.5" AutoReverse="True" /&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="300.0"  
    Duration="0:0:5" /&gt; 
&lt;/Storyboard&gt; </pre>
<p>In this example, the normal duration would be five seconds, but the <kbd>AutoReverse</kbd> property is set to <kbd>True</kbd> and so that duration is doubled. However, the <kbd>RepeatBehavior</kbd> property is set to <kbd>2x</kbd> and this will multiply the doubled ten seconds to twenty seconds. This multiplier value of two will be stored in the <kbd>Count</kbd> property of the <kbd>RepeatBehavior</kbd> structure.</p>
<p>An alternative to using the count option is to simply set the duration that we would like the animation to last for. The same XAML syntax that is used to set the <kbd>Duration</kbd> property can also be used to set the <kbd>RepeatBehavior</kbd> property. Similarly, the <kbd>RepeatBehavior</kbd> structure also defines a <kbd>Forever</kbd> property that represents an infinite period of time and we can use this value to make an animation continue indefinitely.</p>
<p>One further property that can affect the duration of an animation is the <kbd>SpeedRatio</kbd> property. This value is multiplied by the other related duration properties and so can both speed up and slow down the associated timeline. Let's update our example again to help to explain this property now:</p>
<pre>&lt;Storyboard Duration="0:0:5" AutoReverse="True" SpeedRatio="0.5"&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="300.0"  
    Duration="0:0:2.5" AutoReverse="True" /&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="300.0"  
    Duration="0:0:5" SpeedRatio="2" /&gt; 
&lt;/Storyboard&gt; </pre>
<p>Again, the normal duration here would be five seconds and the <kbd>AutoReverse</kbd> property is set to <kbd>True</kbd>, so the duration is doubled. However, the <kbd>SpeedRatio</kbd> property is set to <kbd>0.5</kbd> and so the doubled duration is again doubled to twenty seconds. Note that a <kbd>SpeedRatio</kbd> value of <kbd>0.5</kbd> represents half the normal speed and therefore twice the normal duration.</p>
<p> </p>
<p>The second child timeline also sets the <kbd>SpeedRatio</kbd> property, but it is set to <kbd>2</kbd> and so its speed is doubled and its duration halved. As its specified duration is twice that of its sibling timeline and its speed is now twice as fast, this has the effect of re-synchronizing the two child animations, so that the two dimensions now grow together, as a square, rather than as a rectangle.</p>
<p>There are two more speed-related properties that we can use to fine-tune our animations: the <kbd>AccelerationRatio</kbd> and <kbd>DecelerationRatio</kbd> properties. These properties adjust the proportion of time that the related animation takes to speed up and slow down respectively. While this effect can be subtle at times, it can also give our animations that professional touch when used correctly.</p>
<p>Acceptable values for both of these properties exist between zero and one. If both properties are used together, then the total sum of their values must still remain between zero and one. Failure to adhere to this rule will result in the following exception being thrown at runtime: </p>
<pre><strong>The sum of AccelerationRatio and DecelerationRatio must be less than or equal to one.</strong></pre>
<p>Entering values outside the acceptable range on either of these properties individually will also result in an error, although doing this will cause a compilation error instead:</p>
<pre><strong>Property value must be between 0.0 and 1.0.</strong></pre>
<p>Let's look at an example that highlights the difference between the different values of these two properties:</p>
<pre>&lt;StackPanel Margin="20"&gt; 
  &lt;StackPanel.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard RepeatBehavior="Forever" Duration="0:0:1.5"
          SpeedRatio="0.5" Storyboard.TargetProperty="Width"&gt;
          &lt;DoubleAnimation Storyboard.TargetName="RectangleA"
            AccelerationRatio="1.0" From="0" To="300" /&gt;
          &lt;DoubleAnimation Storyboard.TargetName="RectangleB"
            AccelerationRatio="0.8" DecelerationRatio="0.2" <br/>            From="0" To="300" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetName="RectangleC" 
            AccelerationRatio="0.6" DecelerationRatio="0.4" <br/>            From="0" To="300" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetName="RectangleD"
            AccelerationRatio="0.5" DecelerationRatio="0.5" <br/>            From="0" To="300" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetName="RectangleE"
            AccelerationRatio="0.4" DecelerationRatio="0.6" <br/>            From="0" To="300" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetName="RectangleF"
            AccelerationRatio="0.2" DecelerationRatio="0.8" <br/>            From="0" To="300" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetName="RectangleG"
            DecelerationRatio="1.0" From="0" To="300" /&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/StackPanel.Triggers&gt; 
  &lt;Rectangle Name="RectangleA" Fill="#FF0000" Height="30" /&gt; 
  &lt;Rectangle Name="RectangleB" Fill="#D5002B" Height="30" /&gt; 
  &lt;Rectangle Name="RectangleC" Fill="#AB0055" Height="30" /&gt; 
  &lt;Rectangle Name="RectangleD" Fill="#800080" Height="30" /&gt; 
  &lt;Rectangle Name="RectangleE" Fill="#5500AB" Height="30" /&gt; 
  &lt;Rectangle Name="RectangleF" Fill="#2B00D5" Height="30" /&gt; 
  &lt;Rectangle Name="RectangleG" Fill="#0000FF" Height="30" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>This code defines a number of <kbd>Rectangle</kbd> objects in a <kbd>StackPanel</kbd> control, each with its own associated <kbd>DoubleAnimation</kbd> element, that increases its width from zero to three hundred pixels over one and a half seconds.</p>
<p>Here, we've used the <kbd>Storyboard.TargetName</kbd> and <kbd>Storyboard.TargetProperty</kbd> properties to target the rectangles from a single <kbd>EventTrigger</kbd> to reduce the amount of code in the preceding example. We'll cover these Attached Properties in detail shortly, but for now, we'll just say that they are used to specify the target element and property to animate.</p>
<p>Each animation targets a different rectangle and has different values set for the <kbd>AccelerationRatio</kbd> and <kbd>DecelerationRatio</kbd> properties. The top rectangle's animation has its <kbd>AccelerationRatio</kbd> property set to <kbd>1.0</kbd> and the animation for the bottom rectangle has its <kbd>DecelerationRatio</kbd> property set to <kbd>1.0</kbd>.</p>
<p>The animations for the rectangles in between have varying values. The higher the rectangle, the higher the values for the <kbd>AccelerationRatio</kbd> property and the lower the values for the <kbd>DecelerationRatio</kbd> property and the lower the rectangle, the lower the values of the <kbd>AccelerationRatio</kbd> property and the higher the values for the <kbd>DecelerationRatio</kbd> property.</p>
<p> </p>
<p>When this example is run, we can clearly see the differences between the various ratio values. At one point near the start of each iteration, we can see that the top rectangles that are animated with higher <kbd>AccelerationRatio</kbd> values have not grown in size as much as the lower rectangles that are animated with higher <kbd>DecelerationRatio</kbd> values; however, all rectangles reach 300 pixels at approximately the same time:</p>
<div><img class="alignnone size-full wp-image-2027 image-border" src="img/f33a30c5-755c-4809-bba8-e632617ebdf1.png" style="width:30.17em;height:28.75em;"/></div>
<p>Another useful property in the <kbd>Timeline</kbd> class is the <kbd>BeginTime</kbd> property. As the name suggests, it sets the time to begin the animation; it can be thought of as a delay time that delays the start of its animation with relation to parent and sibling timelines.</p>
<p>The default value of this property is zero seconds and when it is set with a positive value, the delay occurs just once at the start of the timeline and is not affected by other properties that may be set on it. It is often used to delay the start of one or more animations until another animation has completed. Let's adjust our earlier example again to demonstrate this:</p>
<pre>&lt;Rectangle Width="0" Height="1" Fill="Orange"&gt; 
  &lt;Rectangle.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard&gt; 
          &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="300.0" 
            Duration="0:0:2" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="300.0" 
            Duration="0:0:2" BeginTime="0:0:2" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="0.0" 
            Duration="0:0:2" BeginTime="0:0:4" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="0.0"
            Duration="0:0:2" BeginTime="0:0:4" /&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/Rectangle.Triggers&gt; 
&lt;/Rectangle&gt; </pre>
<p>In this example, we have a single pixel high rectangle with a width that grows outward until it is three hundred pixels wide and then grows vertically until it is three hundred pixels high. At that point, its dimensions equally reduce in size until the shape shrinks to nothing.</p>
<p>This is achieved by delaying the last three animations while the width-increasing animation runs and then delaying the last two animations while the height-increasing animation runs. The <kbd>BeginTime</kbd> properties of the last two animations are set to the same value, so that they both start and run in synchronization with each other.</p>
<p>The last really useful timeline property is the <kbd>FillBehavior</kbd> property, which specifies what should happen to the data bound property value when the timeline reaches the end of its total duration, or its fill period. This property is of type <kbd>FillBehavior</kbd> and has just two values.</p>
<p>If we set this property to a value of <kbd>HoldEnd</kbd>, the data bound property value will remain at the final value that was reached just before the animation ended. Conversely, if we set this property to a value of <kbd>Stop</kbd>, which is the default value, the data bound property value will revert to the value that the property originally had before the animation started. Let's illustrate this with a simple example:</p>
<pre>&lt;StackPanel Margin="20"&gt; 
  &lt;StackPanel.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard Duration="0:0:1.5" SpeedRatio="0.5"  
          Storyboard.TargetProperty="Opacity"&gt; 
          &lt;DoubleAnimation Storyboard.TargetName="RectangleA" To="0.0"
            FillBehavior="HoldEnd" /&gt; 
          &lt;DoubleAnimation Storyboard.TargetName="RectangleB" To="0.0"
            FillBehavior="Stop" /&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/StackPanel.Triggers&gt; 
  &lt;Rectangle Name="RectangleA" Fill="Orange" Height="100"  
    HorizontalAlignment="Stretch" Margin="0,0,0,20" /&gt; 
  &lt;Rectangle Name="RectangleB" Fill="Orange" Height="100"  
    HorizontalAlignment="Stretch" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>In this example, the difference between the two <kbd>FillBehavior</kbd> enumeration instances is clearly demonstrated. We have two rectangles of identical size that have identical timelines set up to animate their <kbd>Opacity</kbd> property values, with the exception of their <kbd>FillBehavior</kbd> property values.</p>
<p>Both rectangles fade from being opaque to being invisible in the same amount of time, but once the two timelines are complete, the rectangle with the <kbd>FillBehavior</kbd> property set to <kbd>Stop</kbd> immediately becomes visible again, as it was prior to the start of the animation, while the other with the <kbd>FillBehavior</kbd> property set to <kbd>HoldEnd</kbd> remains invisible, as it was at the end of the animation.</p>
<p>While this covers the main properties that are exposed by the <kbd>Timeline</kbd> class directly, there are a few more properties that are declared by many of the animation classes that extend the <kbd>Timeline</kbd> class and are essential to fully understand. They are the <kbd>From</kbd>, <kbd>By</kbd> and <kbd>To</kbd> properties, which specify the start and end points of the animations.</p>
<p>Because the animation classes generate property values, there are different types of animation classes for different property types. For example, the animation class that generates <kbd>Point</kbd> values is called the <kbd>PointAnimation</kbd> class and all of the normal animation classes follow the same naming pattern, using the name of the related type in the form of <kbd>&lt;TypeName&gt;Animation</kbd>, for example <kbd>ColorAnimation</kbd>.</p>
<p>The normal animation classes, often referred to as the <kbd>From</kbd>, <kbd>By</kbd> and <kbd>To</kbd> animations, usually require two values to be specified, although one of these can sometimes be implicitly provided. The relevant property will then be animated along a path of automatically interpolated values between the two specified values.</p>
<p>It is most common to provide a starting value using the <kbd>From</kbd> property and an ending value using the <kbd>To</kbd> property. However, we can also specify a single starting, ending, or offset value and the second value will be taken from the current value of the animated property. We can set the offset value using the <kbd>By</kbd> property and this represents the exact amount the property value will change over the duration.</p>
<p>Specifying values for these different properties can have dramatically different effects on the resulting animations. Using the <kbd>From</kbd> property alone will start the animation at the desired value and will animate the property until it reaches the property's base value.</p>
<p>Using the <kbd>To</kbd> property alone will start animating the property from its current value and end at the specified value. Using only the <kbd>By</kbd> property will animate the property from its current value until the sum of that value with the specified offset amount has been reached.</p>
<p>Combinations of the three properties can be used to target just the right range of property values. Setting the <kbd>From</kbd> and <kbd>By</kbd> properties will start the animations from the value specified by the <kbd>From</kbd> property and animate the property until the offset specified by the <kbd>By</kbd> property has been reached.</p>
<p>Setting the <kbd>From</kbd> and <kbd>To</kbd> properties together will start the animations from the value specified by the <kbd>From</kbd> property and animate the property until the value specified by the <kbd>To</kbd> property. As the <kbd>By</kbd> and <kbd>To</kbd> properties both specify the ending value of the animation, the value specified by the <kbd>By</kbd> property will be ignored if they are both set on an animation element.</p>
<p>While these more common animations use one or two of the <kbd>From</kbd>, <kbd>By</kbd>, and <kbd>To</kbd> properties together to specify the range of values of the related property to be animated, there is another way to specify the target values. Let's now take a look at key-frame animations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing key-frames</h1>
                
            
            
                
<p>Key-frame animations enable us to do a number of things that we cannot do with the <kbd>From</kbd>, <kbd>By</kbd>, and <kbd>To</kbd> animations. Unlike those animations, with key-frame animations, we are able to specify more than two target values and animate objects in discrete steps that cannot normally be animated. As such, there are more <kbd>&lt;TypeName&gt;AnimationUsingKeyFrames</kbd> classes than <kbd>&lt;TypeName&gt;Animation</kbd> classes, for example: <kbd>RectAnimationUsingKeyFrames</kbd>, <kbd>SizeAnimationUsingKeyFrames</kbd>.</p>
<p>Each <kbd>&lt;TypeName&gt;AnimationUsingKeyFrames</kbd> class has a <kbd>KeyFrames</kbd> property that we populate with key-frames to specify various values that must be passed during the animation. Each key-frame has a <kbd>KeyTime</kbd> and a <kbd>Value</kbd> property to specify the value and the relative time that it should be reached.</p>
<p>If no key-frame is declared with a key time of zero seconds, the animation will start from the relevant property's current value. The animation will order the key-frames by the values of their <kbd>KeyTime</kbd> property, rather than the order that they were declared in, and will create transitions between the various values according to their interpolation methods, which we'll find out about momentarily.</p>
<p>Note that the <kbd>KeyTime</kbd> property is of type <kbd>KeyTime</kbd> and this enables us to set it using types of values, other than <kbd>TimeSpan</kbd> values. We are also able to specify percentage values, which determine the percentage of the specified animation duration that each key-frame will be allotted. Note that we need to use cumulative values, so that the final key-frame key time value will always be <kbd>100%</kbd>.</p>
<p>Alternatively, there are a number of special values that we can use. When we want an animation with a constant velocity, regardless of the specified values, we can specify the <kbd>Paced</kbd> value for each of the key-frames. This takes the change between each key-frame's value into consideration before spacing them across the duration of the parent timeline and creating a smooth, even transition.</p>
<p>In contrast to this method, we can also specify the <kbd>Uniform</kbd> value for each key-frame, which basically spaces the key-frames out evenly across the duration of the parent animation. To do this, it simply counts the number of key-frames and divides that number by the total duration length, so that each key-frame will last for the same amount of time.</p>
<p>There are different kinds of key-frames for different <kbd>&lt;TypeName&gt;AnimationUsingKeyFrames</kbd> classes and there are also different kinds of interpolation methods used. The naming convention of these key-frames follows the format, <kbd>&lt;InterpolationMethod&gt;&lt;TypeName&gt;KeyFrame</kbd>, for example: <kbd>LinearDoubleKeyFrame</kbd>.</p>
<p>There are three kinds of interpolation methods. The first is <kbd>Discrete</kbd>, which performs no interpolation and simply jumps from one value to another. This method is useful for setting <kbd>bool</kbd> or <kbd>object</kbd> values.</p>
<p>The next method is <kbd>Linear</kbd>, which performs a linear interpolation between the key-frame's value and the previous key-frame's value. This means that the animation will appear smooth, but speed up and slow down if your key-frame times are not evenly spaced out.</p>
<p>The last and most complicated interpolation method is <kbd>Spline</kbd>, but it also provides the user with the most control over the animation timing. It adds a further property named <kbd>KeySpline</kbd>, which enables us to specify two control points on a Bezier curve that extends from <kbd>0.0,0.0</kbd> to <kbd>1.0,1.0</kbd>. The first control point affects the first half of the curve, while the second point affects the second half.</p>
<p>Using these two control points, we can adjust the speed of the animation over its duration. As an example, using the first control point set to <kbd>0.0,1.0</kbd> and the second set to <kbd>1.0,0.0</kbd> will cause maximum distortion to the original linear curve and result in an animation that will quickly accelerate, before slowing almost to a stop in the middle and then dramatically speeding up again at the end.</p>
<p>With these two points, we can have full control over the speed of value change between each pair of key-frame values. This type of interpolation is most useful when attempting to create animations that are more realistic looking. Note that we are free to mix and match key-frames with different interpolation methods within each key-frame animation.</p>
<p>As an example, let's say that we wanted to animate a <kbd>Point</kbd> element. In this case we'd need to use the <kbd>PointAnimationUsingKeyFrames</kbd> class and would then have a choice of key-frame classes that represent the different interpolation methods. With this example, we could use any combination of the <kbd>DiscretePointKeyFrame</kbd>, <kbd>LinearPointKeyFrame</kbd>, and <kbd>SplinePointKeyFrame</kbd> classes.</p>
<p>Note that, as the <kbd>KeyFrames</kbd> property is set as the <kbd>name</kbd> input parameter in the <kbd>ContentPropertyAttribute</kbd> attribute that forms part of the declared class signature in each of the <kbd>&lt;TypeName&gt;AnimationUsingKeyFrames</kbd> classes, we do not need to explicitly declare this property in XAML and can declare the various key-frames directly inside these elements as shown in the following code:</p>
<pre>&lt;Ellipse Width="100" Height="100" Stroke="Black" StrokeThickness="3"&gt; 
  &lt;Ellipse.Fill&gt; 
    &lt;RadialGradientBrush&gt; 
      &lt;GradientStop Color="Yellow" Offset="0" /&gt; 
      &lt;GradientStop Color="Orange" Offset="1" /&gt; 
    &lt;/RadialGradientBrush&gt; 
  &lt;/Ellipse.Fill&gt; 
  &lt;Ellipse.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard RepeatBehavior="Forever"  
          Storyboard.TargetProperty="Fill.GradientOrigin"&gt; 
          &lt;PointAnimationUsingKeyFrames&gt; 
            &lt;DiscretePointKeyFrame Value="0.5, 0.5" KeyTime="0:0:0" /&gt; 
            &lt;LinearPointKeyFrame Value="1.0, 1.0" KeyTime="0:0:2" /&gt; 
            &lt;SplinePointKeyFrame KeySpline="0,0.25 0.75,0" Value="1.0, 0.0"
              KeyTime="0:0:4" /&gt; 
            &lt;LinearPointKeyFrame Value="0.0, 0.0" KeyTime="0:0:5" /&gt; 
            &lt;SplinePointKeyFrame KeySpline="0,0.75 0.25,0" Value="0.5, 0.5"
              KeyTime="0:0:8" /&gt; 
          &lt;/PointAnimationUsingKeyFrames&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/Ellipse.Triggers&gt; 
&lt;/Ellipse&gt; </pre>
<p>In this example, we declare an <kbd>Ellipse</kbd> shape with its <kbd>Fill</kbd> property set to an instance of the <kbd>RadialGradientBrush</kbd> class. The brush has a yellow center and is orange around the edges. Note that these brushes have a property named <kbd>GradientOrigin</kbd> that specifies the center point of the gradient and defaults to the point <kbd>0.5,0.5</kbd>. In this example, we animate this property, which has a similar effect to moving a light source around a 3D ball:</p>
<div><img class="alignnone size-full wp-image-2028 image-border" src="img/f8f14b19-6725-462a-83a9-1c62ec016528.png" style="width:13.42em;height:13.33em;"/></div>
<p>We use an <kbd>EventTrigger</kbd> with the <kbd>Loaded</kbd> event to start our animation and set the <kbd>RepeatBehavior</kbd> property to <kbd>Forever</kbd> on the associated storyboard. As mentioned, we set the <kbd>TargetProperty</kbd> property to the <kbd>GradientOrigin</kbd> property of the brush that is set as the <kbd>Fill</kbd> property.</p>
<p>Inside the storyboard, we declare a <kbd>PointAnimationUsingKeyFrames</kbd> element and directly inside it, we declare a number of various <kbd>&lt;InterpolationMethod&gt;&lt;Type&gt;KeyFrame</kbd> objects. As mentioned, we do not need to explicitly declare the <kbd>KeyFrames</kbd> property in order to declare these key-frame elements within it.</p>
<p>Note that the <kbd>DiscretePointKeyFrame</kbd> element that is used here is entirely optional and would not change anything if removed. This is because the point <kbd>0.5,0.5</kbd> is both the starting value of the animation and default value of the gradient brush and also the ending value of the animation. Furthermore, if we omit a zero time key-frame, one will be implicitly added for us with this value.</p>
<p>Next, we declare a <kbd>LinearPointKeyFrame</kbd> element, that will animate the gradient origin from the point <kbd>0.5,0.5</kbd> to the point <kbd>1.0,1.0</kbd> in a linear, even fashion. Following that, we have a <kbd>SplinePointKeyFrame</kbd> element that will animate the gradient origin from the previous point to the point <kbd>1.0,0.0</kbd>. Note the <kbd>KeySpline</kbd> property that adjusts the speed of the animation as it progresses.</p>
<p>From there, we use another <kbd>LinearPointKeyFrame</kbd> element to smoothly and evenly transition to the point <kbd>0.0,0.0</kbd> over one second. Finally, we use a second <kbd>SplinePointKeyFrame</kbd> element to animate the gradient origin back to the center of the circle and its starting position, taking the last three seconds of the total duration.</p>
<p>When this example is run, we can clearly see it animating the gradient origin point evenly during the periods of the two <kbd>LinearPointKeyFrame</kbd> elements and changing the speed during the periods of the two <kbd>SplinePointKeyFrame</kbd> elements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Telling stories</h1>
                
            
            
                
<p>While the various animation classes that extend the <kbd>Timeline</kbd> class can be used to animate control properties directly in code, in order to declare and trigger animations using XAML alone, we need to use the <kbd>Storyboard</kbd> class. This is what is known as a container timeline, as it extends the abstract <kbd>TimelineGroup</kbd> class that enables it to contain child timelines.</p>
<p>Another container timeline class that the <kbd>Storyboard</kbd> class extends is the <kbd>ParallelTimeline</kbd> class and these classes enable us to group child timelines and to set properties on them as a group. When creating more complex animations, if all we need to do is to delay the start of a group of child timelines, we should use the <kbd>ParallelTimeline</kbd> class rather than the <kbd>Storyboard</kbd> class, as it is more efficient.</p>
<p>We could rewrite our earlier <kbd>BeginTime</kbd> example to use a <kbd>ParallelTimeline</kbd> element to delay the start of our last two timelines. Let's see what that might look like:</p>
<pre>&lt;Storyboard&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="300.0"  
    Duration="0:0:2" /&gt; 
  &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="300.0"  
    Duration="0:0:2" BeginTime="0:0:2" /&gt; 
  &lt;ParallelTimeline BeginTime="0:0:4"&gt; 
    &lt;DoubleAnimation Storyboard.TargetProperty="Width" To="0.0"  
      Duration="0:0:2" /&gt; 
    &lt;DoubleAnimation Storyboard.TargetProperty="Height" To="0.0"  
      Duration="0:0:2" /&gt; 
  &lt;/ParallelTimeline&gt; 
&lt;/Storyboard&gt; </pre>
<p>As the <kbd>Storyboard</kbd> class is a <kbd>Timeline</kbd> object, it also has the same properties as the various animation objects. One additional property that it inherits from the <kbd>ParallelTimeline</kbd> class is the <kbd>SlipBehavior</kbd> property. This property is only really useful when we want to synchronize an animation timeline with the playback of a <kbd>MediaTimeline</kbd> element, but it's worth knowing about.</p>
<p>This property is of the enumeration type <kbd>SlipBehavior</kbd> and it only has two members. A value of <kbd>Grow</kbd> specifies that we do not need our animation timelines to be synchronized with our media timeline(s) and is the default value of this property.</p>
<p>Conversely, a value of <kbd>Slip</kbd> indicates that we want our animation timelines to slip, either forwards or backwards, whenever necessary in order to keep them in sync with the playing media. If the media takes time to load when using this setting, then the animation timelines within the storyboard will wait until the media is ready and continue at that point.</p>
<p>In addition to the properties that have been inherited from the various base classes, the <kbd>Storyboard</kbd> class also declares three important Attached Properties that are essential for targeting animations to individual UI elements and/or their properties.</p>
<p>The <kbd>Storyboard.Target</kbd> Attached Property specifies the UI control that should be animated, although setting this property alone is not enough, as it does not specify the target property. This property is of type <kbd>object</kbd>, although it can only be used with objects of type <kbd>DependencyObject</kbd>.</p>
<p>In order to use this property, we need to specify a binding path that references the target UI control. If the target element extends the <kbd>FrameworkElement</kbd> or <kbd>FrameworkContentElement</kbd> classes, then one way would be to name the target element and to use an <kbd>ElementName</kbd> binding to reference it:</p>
<pre>Storyboard.Target="{Binding ElementName=TargetControlName}" </pre>
<p>Most UI elements extend one of these two classes that declare the <kbd>Name</kbd> property. However, if we provide a name for the target control, then there is a simpler way to target it. Instead of using the <kbd>Storyboard.Target</kbd> property, we could use the <kbd>Storyboard.TargetName</kbd> Attached Property to specify the target element using just their declared name, without any binding:</p>
<pre>Storyboard.TargetName="TargetControlName" </pre>
<p> </p>
<p>We do not always need to specify this property value, as on occasion, the target element can be worked out implicitly. If the relevant storyboard was started with a <kbd>BeginStoryboard</kbd> element, the UI element that declared it will be targeted. Additionally, if the relevant storyboard is a child of another timeline, then the target of the parent timeline will be inherited.</p>
<p>The most important property that the <kbd>Storyboard</kbd> class declares is the <kbd>TargetProperty</kbd> Attached Property. We use this property to specify which property we want to animate on the target element. Note that in order for this to work, the target property must be a Dependency Property.</p>
<p>Occasionally, we may want to target objects that do not extend either of the framework classes mentioned earlier; in WPF, we are also able to target freezable classes that extend the <kbd>Freezable</kbd> class. In order to target one of these classes in XAML, we need to specify the name of the object using the <kbd>x:Name</kbd> directive instead, as they have no <kbd>Name</kbd> property.</p>
<p>As a side note, WPF classes that declare their own <kbd>Name</kbd> property actually map the name value through to the <kbd>x:Name</kbd> directive, which is part of the XAML specification. In these cases, we are free to use either of these to register a name for an element, but we must not set both.</p>
<p>Note that unnamed elements can still be referenced by our animations, although they need to be indirectly referenced. Instead of referencing them directly, we need to specify the name of the parent property or freezable object and then chain properties in the <kbd>TargetProperty</kbd> Attached Property until we reach the desired element. We used this method in the last example of the previous section:</p>
<pre>Storyboard.TargetProperty="Fill.GradientOrigin" </pre>
<p>In this case, we reference the <kbd>Fill</kbd> property, which is of type <kbd>RadialGradientBrush</kbd>, and then we chain to the <kbd>GradientOrigin</kbd> property of the brush from there. Note that if we had used an instance of the <kbd>SolidColorBrush</kbd> class here instead, this reference would fail, because there is no <kbd>GradientOrigin</kbd> property in that brush. However, while the animation would fail to work, this would not cause any errors to be raised.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Controlling storyboards</h1>
                
            
            
                
<p>In order to start a storyboard in XAML, we need to use a <kbd>BeginStoryboard</kbd> element. This class extends the <kbd>TriggerAction</kbd> class and if you remember, that is the type that we need to use in the <kbd>TriggerActionCollection</kbd> of the <kbd>EventTrigger</kbd> class and the <kbd>TriggerBase.EnterActions</kbd> and <kbd>TriggerBase.ExitActions</kbd> properties.</p>
<p>We specify the storyboard to use with the <kbd>BeginStoryboard</kbd> element by setting it to the <kbd>Storyboard</kbd> property in code. When using XAML, the <kbd>Storyboard</kbd> property is implicitly set to the storyboard that is declared within the <kbd>BeginStoryboard</kbd> element.</p>
<p>The <kbd>BeginStoryboard</kbd> action is responsible for connecting the animation timelines with the animation targets and their targeted properties and is also responsible for starting the various animation timelines within its storyboard. It does this by calling the <kbd>Begin</kbd> method of the associated <kbd>Storyboard</kbd> object, once its parent's trigger condition has been met.</p>
<p>If an already running storyboard is asked to begin again, either indirectly, using a <kbd>BeginStoryboard</kbd> action, or directly, using the <kbd>Begin</kbd> method, what happens will depend upon the value set by the <kbd>HandoffBehavior</kbd> property.</p>
<p>This property is of the enumeration type <kbd>HandoffBehavior</kbd> and has two values. The default value is <kbd>SnapshotAndReplace</kbd> and this will renew the internal clocks and essentially have the effect of replacing one copy of the timeline with another. The other value is more interesting: the <kbd>Compose</kbd> value will retain the original clocks when restarting the animation and append the new animation after the current one, performing some interpolation between them, resulting in a smoother join.</p>
<p>One problem with this method is that the retained clocks will continue to use system resources and this can end in memory problems if not handled correctly. However, this method produces much smoother and more natural and fluid animations that can be worth the extra resources. This is best demonstrated with a small example:</p>
<pre>&lt;Canvas&gt; 
  &lt;Rectangle Canvas.Top="200" Canvas.Left="25" Width="100" Height="100"  
    Fill="Orange" Stroke="Black" StrokeThickness="3"&gt; 
    &lt;Rectangle.Style&gt; 
      &lt;Style TargetType="{x:Type Rectangle}"&gt; 
        &lt;Style.Triggers&gt; 
          &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
            &lt;Trigger.EnterActions&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard&gt; 
                  &lt;DoubleAnimation Duration="0:0:2"
                    Storyboard.TargetProperty="(Canvas.Top)" To="0" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/Trigger.EnterActions&gt; 
            &lt;Trigger.ExitActions&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard&gt; 
                  &lt;DoubleAnimation Duration="0:0:2"
                    Storyboard.TargetProperty="(Canvas.Top)" To="200" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/Trigger.ExitActions&gt; 
          &lt;/Trigger&gt; 
        &lt;/Style.Triggers&gt; 
      &lt;/Style&gt; 
    &lt;/Rectangle.Style&gt; 
  &lt;/Rectangle&gt; 
  &lt;Rectangle Canvas.Top="200" Canvas.Left="150" Width="100" Height="100"  
    Fill="Orange" Stroke="Black" StrokeThickness="3"&gt; 
    &lt;Rectangle.Style&gt; 
      &lt;Style TargetType="{x:Type Rectangle}"&gt; 
        &lt;Style.Triggers&gt; 
          &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
            &lt;Trigger.EnterActions&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard&gt; 
                  &lt;DoubleAnimation Duration="0:0:2"
                    Storyboard.TargetProperty="(Canvas.Top)" To="0" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/Trigger.EnterActions&gt; 
            &lt;Trigger.ExitActions&gt; 
              &lt;BeginStoryboard HandoffBehavior="Compose"&gt; 
                &lt;Storyboard&gt; 
                  &lt;DoubleAnimation Duration="0:0:2"
                    Storyboard.TargetProperty="(Canvas.Top)" To="200" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/Trigger.ExitActions&gt; 
          &lt;/Trigger&gt; 
        &lt;/Style.Triggers&gt; 
      &lt;/Style&gt; 
    &lt;/Rectangle.Style&gt; 
  &lt;/Rectangle&gt; 
&lt;/Canvas&gt; </pre>
<p>In this example, we have two rectangles, each with its own animation. The only difference between them is that the <kbd>BeginStoryboard</kbd> element that starts the animation for the right rectangle has a <kbd>HandoffBehavior</kbd> of <kbd>Compose</kbd>, while the other uses the default value of <kbd>SnapshotAndReplace</kbd>.</p>
<p>When the example is run, each rectangle will move upwards when the mouse cursor is placed over it and move back downwards when the cursor is moved away from it. If we keep the mouse cursor within the bounds of each rectangle, moving it up to the top of the screen with the rectangle and then move the cursor away to let the rectangle fall, the two animations will appear identical.</p>
<p>However, if we move the mouse cursor from side to side across the two rectangles, we will start to see a difference between the two animations. We'll see that as the cursor enters the bounds of each rectangle, they each start their upwards movement. But once the cursor leaves the rectangle bounds, we see the difference.</p>
<p>The rectangle on the left, with the default value of <kbd>SnapshotAndReplace</kbd>, will stop moving up and immediately begin its downwards animation, while the other rectangle will continue to move upwards for a short time before commencing its downwards animation. This results in a much smoother, more natural looking transition between the two animations.</p>
<p>The difference between these two handoff behaviors though, is most clearly demonstrated by simply placing the mouse cursor on one of the rectangles and leaving it there. Doing this to the rectangle on the left will cause the rectangle to move upwards until the mouse cursor is no longer within its bounds and then it will immediately begin to move downwards again.</p>
<p>However, as the mouse cursor will then be within the bounds of the rectangle again, it will begin the upwards animation once more. This will cause the rectangle to move away from the mouse cursor again and so we will end with a repetitive loop of this behavior and it will result in what looks like a quick shaking, or stuttering, of the rectangle just above the position of the mouse.</p>
<p>On the other hand, the rectangle on the right, with the <kbd>HandoffBehavior</kbd> of <kbd>Compose</kbd>, will move upwards until the mouse cursor is no longer within its bounds, but will then continue to move upwards for a short time before starting to move downwards again. Once more, this creates a far smoother animation and will result in the rectangle bouncing gently above the mouse cursor, in sharp contrast to the other, stuttering rectangle.</p>
<p>There are several related <kbd>TriggerAction</kbd> derived classes that are suffixed with the word <kbd>Storyboard</kbd> and enable us to control various aspects of the related <kbd>Storyboard</kbd> element. By specifying the <kbd>Name</kbd> property value of the <kbd>BeginStoryboard</kbd> element in the <kbd>BeginStoryboardName</kbd> property of the other actions, we are able to further control the running storyboard.</p>
<p>We can use the <kbd>PauseStoryboard</kbd> element to pause a running storyboard and the <kbd>ResumeStoryboard</kbd> to resume a paused storyboard. The <kbd>PauseStoryboard</kbd> element does nothing if the related storyboard is not running and, similarly, the <kbd>ResumeStoryboard</kbd> action does nothing if the related storyboard is not already paused. Therefore, a storyboard cannot be started with a <kbd>ResumeStoryboard</kbd> trigger action.</p>
<p>The <kbd>StopStoryboard</kbd> action will stop a running storyboard, but does nothing if the related storyboard is not already running. Finally, there is a <kbd>RemoveStoryboard</kbd> trigger action that will remove a storyboard when its parent's trigger condition has been met. As storyboards consume resources, we should remove them when they are no longer required.</p>
<p>For example, if we use an <kbd>EventTrigger</kbd> with the <kbd>Loaded</kbd> event to start a timeline that has its <kbd>RepeatBehavior</kbd> property set to <kbd>Forever</kbd>, then we should use another <kbd>EventTrigger</kbd> element with a <kbd>RemoveStoryboard</kbd> action in the <kbd>Unloaded</kbd> event to remove the storyboard. This is somewhat analogous to calling the <kbd>Dispose</kbd> method on an <kbd>IDisposable</kbd> implementation.</p>
<p>Note that it is essential to remove a storyboard that was started by a <kbd>BeginStoryboard</kbd> action with its <kbd>HandoffBehavior</kbd> property set to <kbd>Compose</kbd>, as it could end with many internal clocks being instantiated, but not disposed of. Removing the storyboard will also result in the internally used clocks being disposed of. Let's see a practical example of how we might use these elements:</p>
<pre>&lt;StackPanel TextElement.FontSize="14"&gt; 
  &lt;TextBox Text="{Binding Name, UpdateSourceTrigger=PropertyChanged}"  
    Margin="20"&gt; 
    &lt;TextBox.Effect&gt; 
      &lt;DropShadowEffect Color="Red" ShadowDepth="0" BlurRadius="0"  
        Opacity="0.5" /&gt; 
    &lt;/TextBox.Effect&gt; 
    &lt;TextBox.Style&gt; 
      &lt;Style TargetType="{x:Type TextBox}"&gt; 
        &lt;Style.Triggers&gt; 
          &lt;DataTrigger Binding="{Binding IsValid}" Value="False"&gt; 
            &lt;DataTrigger.EnterActions&gt; 
              &lt;BeginStoryboard Name="GlowStoryboard"&gt; 
                &lt;Storyboard RepeatBehavior="Forever"&gt; 
                  &lt;DoubleAnimation Storyboard.
                    TargetProperty="Effect.(DropShadowEffect.BlurRadius)"
                    To="25" Duration="0:0:1.0" AutoReverse="True" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/DataTrigger.EnterActions&gt; 
          &lt;/DataTrigger&gt; 
          &lt;MultiDataTrigger&gt; 
            &lt;MultiDataTrigger.Conditions&gt; 
              &lt;Condition Binding="{Binding IsValid}" Value="False" /&gt; 
              &lt;Condition Binding="{Binding IsFocused,  
                RelativeSource={RelativeSource Self}}" Value="True" /&gt; 
            &lt;/MultiDataTrigger.Conditions&gt; 
            &lt;MultiDataTrigger.EnterActions&gt; 
              &lt;PauseStoryboard BeginStoryboardName="GlowStoryboard" /&gt; 
            &lt;/MultiDataTrigger.EnterActions&gt; 
          &lt;/MultiDataTrigger&gt; 
          &lt;Trigger Property="IsFocused" Value="True"&gt; 
            &lt;Trigger.EnterActions&gt; 
              &lt;PauseStoryboard BeginStoryboardName="GlowStoryboard" /&gt; 
            &lt;/Trigger.EnterActions&gt; 
            &lt;Trigger.ExitActions&gt; 
              &lt;ResumeStoryboard BeginStoryboardName="GlowStoryboard" /&gt; 
            &lt;/Trigger.ExitActions&gt; 
          &lt;/Trigger&gt; 
          &lt;DataTrigger Binding="{Binding IsValid}" Value="True"&gt; 
            &lt;DataTrigger.EnterActions&gt; 
              &lt;StopStoryboard BeginStoryboardName="GlowStoryboard" /&gt; 
            &lt;/DataTrigger.EnterActions&gt; 
          &lt;/DataTrigger&gt; 
          &lt;EventTrigger RoutedEvent="Unloaded"&gt; 
            &lt;EventTrigger.Actions&gt; 
              &lt;RemoveStoryboard BeginStoryboardName="GlowStoryboard" /&gt;
            &lt;/EventTrigger.Actions&gt; 
          &lt;/EventTrigger&gt; 
        &lt;/Style.Triggers&gt; 
      &lt;/Style&gt; 
    &lt;/TextBox.Style&gt; 
  &lt;/TextBox&gt; 
  &lt;TextBox Margin="20 0" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>This example has two textboxes, with the lower one existing solely to enable us to remove focus from the first one. The first textbox is data bound to a <kbd>Name</kbd> property in our View Model. Let's imagine that we have some validation code that will update a property named <kbd>IsValid</kbd> when the <kbd>Name</kbd> property is changed. We'll cover validation in depth in <a href="549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml">Chapter 9</a>, <em>Implementing Responsive Data Validation</em>, but for now, let's keep it simple:</p>
<pre>private string name = string.Empty; 
private bool isValid = false;

... 

public string Name 
{ 
  get { return name; } 
  set 
  { 
    if (name != value) 
    { 
      name = value; 
      NotifyPropertyChanged(); 
      IsValid = name.Length &gt; 2; 
    } 
  } 
} 
 
public bool IsValid 
{ 
  get { return isValid; } 
  set { if (isValid != value) { isValid = value;
    NotifyPropertyChanged(); } } 
} </pre>
<p>Here, we simply verify that the <kbd>Name</kbd> property has a value that has three or more characters in it. The basic idea in this example is that we have an animation that highlights the fact that a particular form field requires a valid value.</p>
<p>It could be a shaking, or growing and shrinking of the form field, or the animation of an adjacent element, but in our case, we have used a <kbd>DropShadowEffect</kbd> element to create a glowing effect around it.</p>
<p>In the <kbd>Triggers</kbd> collection of our style, we have declared a number of triggers. The first one is a <kbd>DataTrigger</kbd> and it data binds to the <kbd>IsValid</kbd> property in the View Model and uses the <kbd>BeginStoryboard</kbd> trigger action element named <kbd>GlowStoryboard</kbd> to make the glowing effect around the textbox grow and shrink when the property value is <kbd>false</kbd>.</p>
<p>While animations are great at attracting the eye, they can also be quite distracting. Skipping over the <kbd>MultiDataTrigger</kbd> momentarily, our animation will therefore be paused when the textbox is focused, so that the user can enter the details without distraction. We achieve this by declaring a <kbd>PauseStoryboard</kbd> action in the trigger with the condition that the <kbd>IsFocused</kbd> property is <kbd>true</kbd>.</p>
<p>Using the <kbd>EnterActions</kbd> collection of the trigger ensures that the <kbd>PauseStoryboard</kbd> action is run as the <kbd>IsFocused</kbd> property is set to <kbd>true</kbd>. Declaring the <kbd>ResumeStoryboard</kbd> action in the <kbd>ExitActions</kbd> collection of the trigger ensures that it will be run as the <kbd>IsFocused</kbd> property is set to <kbd>false</kbd>, or in other words, when the control loses focus.</p>
<p>When the user has entered a value, our View Model validates whether the provided value is indeed valid and, if so, it sets the <kbd>IsValid</kbd> property to <kbd>true</kbd>. In our example, we just verify that the entered string contains three or more characters in order for it to be valid. Setting the <kbd>UpdateSourceTrigger</kbd> property to <kbd>PropertyChanged</kbd> on the binding ensures this validation occurs on each keystroke.</p>
<p>Our example uses a <kbd>DataTrigger</kbd> to data bind to this property and when it is <kbd>true</kbd>, it triggers the <kbd>StopStoryboard</kbd> action, which stops the storyboard from running any further. As the <kbd>FillBehavior</kbd> property of our storyboard is not explicitly set, it will default to the <kbd>Stop</kbd> value and the animated property value will return to the original value that it had prior to being animated.</p>
<p><em>However, what should happen if the user entered three or more characters and then deleted them?</em> The data trigger would trigger the <kbd>StopStoryboard</kbd> action and the storyboard would be stopped. As they deleted the characters and the <kbd>IsValid</kbd> property would be set to <kbd>false</kbd> and the condition of the first <kbd>DataTrigger</kbd> would then trigger the initial <kbd>BeginStoryboard</kbd> action to start the storyboard again.</p>
<p>But this would occur while the focus was still on the textbox and while the animation on the effect should not be running. It is for this reason that we declared the <kbd>MultiDataTrigger</kbd> element that we skipped over earlier. In this trigger, we have two conditions. One is that the <kbd>IsFocused</kbd> property should be <kbd>true</kbd> and for this alone, we could have used a <kbd>MultiTrigger</kbd> instead.</p>
<p>However, the other condition requires that we data bind to the <kbd>IsValid</kbd> property from the View Model and for that, we need to use the <kbd>MultiDataTrigger</kbd> element. So, this trigger will run its <kbd>PauseStoryboard</kbd> action when the textbox is focused and as soon as the data bound value becomes invalid, or in other words, as the user deletes the third character.</p>
<p>The triggers are evaluated from top to bottom in the declared order in the XAML and as the user deletes the third character, the first trigger begins the animation. The <kbd>MultiDataTrigger</kbd> has to be declared after the first trigger, so that the storyboard will be started before it pauses it. In this case, the glow effect will start again once the user has moved focus from the first textbox as required.</p>
<p>Finally, this example demonstrates how we can use a <kbd>RemoveStoryboard</kbd> trigger action to remove the storyboard when it is no longer needed, freeing up its resources. The usual way to do this is by utilizing an <kbd>EventTrigger</kbd> in the <kbd>Unloaded</kbd> event of the relevant control.</p>
<p>While these are the only trigger action elements that control the running state of their associated storyboard elements, there are a further three actions that can control other aspects of, or set other properties of the storyboard.</p>
<p>The <kbd>SetStoryboardSpeedRatio</kbd> trigger action can set the <kbd>SpeedRatio</kbd> of the associated storyboard. We specify the desired ratio in its <kbd>SpeedRatio</kbd> property and this value will be applied when the action's related trigger condition is met. Note that this element can only work on a storyboard that has already been started, although it can work at any time after this point.</p>
<p>The <kbd>SkipStoryboardToFill</kbd> trigger action will move the current position of a storyboard to its fill period, if it has one. Remember that the <kbd>FillBehavior</kbd> property determines what should happen during the fill period. If the storyboard has child timelines, then their positions will also be forwarded to their fill periods at this point.</p>
<p>Last, but not least, there is a <kbd>SeekStoryboard</kbd> trigger action, which enables us to move the current position of storyboard to a location, relative to the position specified by the <kbd>Origin</kbd> property, which has a begin time of zero seconds by default. When declaring the <kbd>SeekStoryboard</kbd> action, we specify the desired seek position in the <kbd>Offset</kbd> property and optionally set the <kbd>Origin</kbd> property.</p>
<p>The <kbd>Offset</kbd> property is of type <kbd>TimeSpan</kbd> and we can use the time notation highlighted earlier to specify its value in XAML. The <kbd>Origin</kbd> property is of type <kbd>TimeSeekOrigin</kbd> and we can specify one of two values.</p>
<p>The first is the default value of <kbd>BeginTime</kbd>, which places the origin at the start of the timeline, while the second is <kbd>Duration</kbd>, which places it at the end of a single iteration of the timeline's natural duration. Note that the various speed ratio values are not taken into consideration when seeking through a timeline's duration.</p>
<p>That completes our look at the range of trigger actions that we can use to control our storyboards. Each of these trigger actions have corresponding methods in the <kbd>Storyboard</kbd> class that they call when their related trigger conditions are met.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Easing functions</h1>
                
            
            
                
<p>When declaring animations with WPF, we are able to utilize a powerful capability that helps us to define more specialized animations. While we normally provide a start and end value for our animations and let WPF interpolate the intermediate values, there is a way that we can affect this interpolation process.</p>
<p>There are a number of mathematical functions that provide complex animation paths and are known as easing functions. For example, these can accurately replicate the movement of a spring, or the bounce of a ball.</p>
<p>We can simply declare the appropriate easing function within the <kbd>EasingFunction</kbd> property of the animation. Each easing function extends the <kbd>EasingFunctionBase</kbd> class and has its own specific properties. For example, the <kbd>BounceEase</kbd> element provides <kbd>Bounces</kbd> and <kbd>Bounciness</kbd> properties, while the <kbd>ElasticEase</kbd> class declare the <kbd>Oscillations</kbd> and <kbd>Springiness</kbd> properties.</p>
<p>All easing functions inherit the <kbd>EasingMode</kbd> property from the base class. This property is of the enumeration type <kbd>EasingMode</kbd> and gives us three options. The <kbd>EaseIn</kbd> option follows the normal mathematical formula associated with each easing function. The <kbd>EaseOut</kbd> option uses the inverse of the mathematical formula.</p>
<p>The <kbd>EaseInOut</kbd> option uses the standard formula for the first half and the inverse formula for the second half. While not strictly true, this can be somewhat thought of as <kbd>EaseIn</kbd> affects the start of the animation, <kbd>EaseOut</kbd> affects the end of the animation, and <kbd>EaseInOut</kbd> affects both the start and the end of the animation. Let's see an example of a bouncing ball animation to demonstrate this ability:</p>
<pre>&lt;Canvas&gt; 
  &lt;Ellipse Width="50" Height="50" Fill="Orange" Stroke="Black"  
    StrokeThickness="3"&gt; 
    &lt;Ellipse.Triggers&gt; 
      &lt;EventTrigger RoutedEvent="Loaded"&gt; 
        &lt;BeginStoryboard&gt; 
          &lt;Storyboard RepeatBehavior="Forever"&gt; 
            &lt;Storyboard Storyboard.TargetProperty="(Canvas.Top)"&gt; 
              &lt;DoubleAnimation Duration="00:00:3" From="0" To="200"&gt; 
                &lt;DoubleAnimation.EasingFunction&gt; 
                  &lt;BounceEase EasingMode="EaseOut" Bounces="10" 
                    Bounciness="1.5" /&gt; 
                &lt;/DoubleAnimation.EasingFunction&gt; 
              &lt;/DoubleAnimation&gt; 
            &lt;/Storyboard&gt; 
            &lt;Storyboard Storyboard.TargetProperty="(Canvas.Left)"&gt; 
              &lt;DoubleAnimation Duration="00:00:3.5" From="0" To="200"
                DecelerationRatio="0.2" /&gt; 
            &lt;/Storyboard&gt; 
          &lt;/Storyboard&gt; 
        &lt;/BeginStoryboard&gt; 
      &lt;/EventTrigger&gt; 
    &lt;/Ellipse.Triggers&gt; 
  &lt;/Ellipse&gt; 
  &lt;Line Canvas.Top="250" Canvas.Left="25" X1="0" Y1="1.5" X2="225" Y2="1.5"
    Stroke="Black" StrokeThickness="3" /&gt; 
&lt;/Canvas&gt; </pre>
<p> </p>
<p>Here, we have a <kbd>Canvas</kbd> panel that contains two shapes: an ellipse and a line. The line is simply to give the impression of the ground. The <kbd>Ellipse</kbd> element defines some basic appearance properties and then an <kbd>EventTrigger</kbd> element that starts our eased animation when the shape object is loaded. We have an outer <kbd>Storyboard</kbd> element that is set to repeat forever and contains two inner storyboards.</p>
<p>The first of these inner storyboards targets the <kbd>Canvas.Top</kbd> Attached Property using the <kbd>Storyboard.TargetProperty</kbd>, while the second targets its <kbd>Canvas.Left</kbd> Attached Property. Note that we do not need to specify the <kbd>Storyboard.Target</kbd> property value here, as the storyboard resides within the target element, which will be implicitly set as the target for us. Also, remember that we need to wrap the Attached Property name with its class name in brackets for this to work.</p>
<p>The first storyboard is responsible for the vertical movement of our ball and so this is the animation that we want to use the <kbd>BounceEase</kbd> function with. In order to utilize this functionality, we simply declare the <kbd>BounceEase</kbd> object within the <kbd>DoubleAnimation.EasingFunction</kbd> property and set the desired property values.</p>
<p>The <kbd>Bounces</kbd> property determines how many times the ball should bounce, or rebound off the lower extent of the animation. Note that this does not include the final half-bounce that this easing function will perform. The <kbd>Bounciness</kbd> property specifies how bouncy the ball is. Strangely, the higher this value is, the less bouncy the ball will be. Also note that this value must be positive.</p>
<p>As physics determines that the horizontal velocity of the ball should remain constant for the most part, we do not need to apply an easing function to the second animation. Instead, we have added a small value for its <kbd>DecelerationRatio</kbd> property, which nicely simulates the sideways friction on the ball.</p>
<p>As can be seen, it is very easy to take advantage of these mathematical formulae to greatly increase the movement of our animations. While there is not enough space in this book for us to cover all of these easing functions, it is well worth investigating them yourselves. Let's take a look at another example, to see how we can simulate the movement of a spring using the <kbd>ElasticEase</kbd> class:</p>
<pre>&lt;Rectangle Canvas.Top="250" Canvas.Left="25" Width="25" Height="50"  
  Fill="Orange" Stroke="Black" StrokeThickness="3"&gt; 
  &lt;Rectangle.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard RepeatBehavior="Forever"&gt; 
          &lt;Storyboard Storyboard.TargetProperty="Height"&gt; 
            &lt;DoubleAnimation Duration="00:00:3" From="50" To="200"&gt; 
              &lt;DoubleAnimation.EasingFunction&gt; 
                &lt;ElasticEase EasingMode="EaseOut" Oscillations="6" 
                  Springiness="2" /&gt; 
              &lt;/DoubleAnimation.EasingFunction&gt; 
            &lt;/DoubleAnimation&gt; 
          &lt;/Storyboard&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/Rectangle.Triggers&gt; 
&lt;/Rectangle&gt; </pre>
<p>In this example, we have a thin <kbd>Rectangle</kbd> element that simulates the movement of a coiled spring using an <kbd>ElasticEase</kbd> function. The <kbd>Oscillations</kbd> property specifies the number of times that the rectangle will grow and shrink over the lifetime of the animation effect and the <kbd>Springiness</kbd> property determines the stiffness of the spring, where larger values equal more springiness.</p>
<p>While the two demonstrated easing functions are rather specialized and unsuitable to use in many cases, the vast majority of the remaining functions are all variations on standard circular, or exponential curves, or curves that use the formula <em>f(t) = t<sup>n</sup></em>, where <em>n</em> is either determined by the exact easing function used, or by the <kbd>Power</kbd> property of the <kbd>PowerEase</kbd> function.</p>
<p>For example, the <kbd>QuadraticEase</kbd> function uses the formula <em>f(t) = t<sup>2</sup></em>, the <kbd>CubicEase</kbd> function uses the formula <em>f(t) = t<sup>3</sup></em>, the <kbd>QuarticEase</kbd> function uses the formula <em>f(t) = t<sup>4</sup></em>, the <kbd>QuinticEase</kbd> function uses the formula <em>f(t) = t<sup>5</sup></em>, while the <kbd>PowerEase</kbd> function uses the formula <em>f(t) = t<sup>n</sup></em>, where <em>n</em> is determined by its <kbd>Power</kbd> property.</p>
<p>Apart from these variations of the standard acceleration/deceleration curve, there is one final useful easing function named <kbd>BackEase</kbd>. This has the effect of overshooting its starting or ending <kbd>From</kbd> or <kbd>To</kbd> values, dependent upon the value of the <kbd>EasingMode</kbd> property, and then reversing back to it. This is one of the more usable easing functions, so let's see an example of a <kbd>TextBox</kbd> element sliding on screen:</p>
<pre>&lt;Canvas ClipToBounds="True"&gt; 
  &lt;TextBox Canvas.Top="50" Canvas.Left="-150" Width="150" Height="25"&gt; 
    &lt;TextBox.Triggers&gt; 
      &lt;EventTrigger RoutedEvent="Loaded"&gt; 
        &lt;BeginStoryboard&gt; 
          &lt;Storyboard Storyboard.TargetProperty="(Canvas.Left)"
            Duration="00:00:2" RepeatBehavior="Forever"&gt;
            &lt;DoubleAnimation Duration="00:00:1" From="-150" To="50"&gt; 
              &lt;DoubleAnimation.EasingFunction&gt; 
                &lt;BackEase EasingMode="EaseOut" Amplitude="0.75" /&gt; 
              &lt;/DoubleAnimation.EasingFunction&gt; 
            &lt;/DoubleAnimation&gt; 
          &lt;/Storyboard&gt; 
        &lt;/BeginStoryboard&gt; 
      &lt;/EventTrigger&gt; 
    &lt;/TextBox.Triggers&gt; 
  &lt;/TextBox&gt; 
&lt;/Canvas&gt; </pre>
<p>In this example, we start with a <kbd>Canvas</kbd> object that has its <kbd>ClipToBounds</kbd> property set to <kbd>true</kbd>. This ensures that elements that are outside the bounds of the canvas will not be visible. Inside the canvas, we have declared a <kbd>TextBox</kbd> control that is initially placed totally outside the bounds of the canvas and so it will be invisible.</p>
<p>When the control is loaded, the <kbd>EventTrigger</kbd> element will start the animation that targets the <kbd>Canvas.Left</kbd> Attached Property. Note that the duration on the storyboard is one second longer than the duration on the animation and so the storyboard will wait for one second after the animation has completed before restarting. This gives us time to appreciate the effect of the applied easing function.</p>
<p>The animation will slide the textbox to its ending position from its initial off-screen position. By using the <kbd>BackEase</kbd> function, the textbox will slightly slide past its ending position and then reverse back into it. The amount past its ending position that it will slide to is determined by the value of its <kbd>Amplitude</kbd> property, with higher values extending the overshoot distance.</p>
<p>While we have only discussed using these easing functions with <kbd>From</kbd>, <kbd>By</kbd> and <kbd>To</kbd> animations so far, it is also possible to use them with key-frame animations as well. There are a number of classes that follow the <kbd>Easing&lt;Type&gt;KeyFrame</kbd> naming convention, such as the <kbd>EasingColorKeyFrame</kbd> class. These classes have an <kbd>EasingFunction</kbd> property that enables us to specify which function to use:</p>
<pre>&lt;TextBlock Text="The operation was successful" Margin="20"&gt; 
  &lt;TextBlock.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard Storyboard.TargetProperty="FontSize"&gt; 
          &lt;DoubleAnimationUsingKeyFrames Duration="00:00:2.5"&gt; 
            &lt;DiscreteDoubleKeyFrame KeyTime="0:0:0" Value="8" /&gt; 
            &lt;EasingDoubleKeyFrame KeyTime="0:0:1" Value="36"&gt; 
              &lt;EasingDoubleKeyFrame.EasingFunction&gt; 
                &lt;BounceEase EasingMode="EaseOut" Bounces="2" 
                  Bounciness="1.5" /&gt; 
              &lt;/EasingDoubleKeyFrame.EasingFunction&gt; 
            &lt;/EasingDoubleKeyFrame&gt; 
            &lt;EasingDoubleKeyFrame KeyTime="0:0:2" Value="8"&gt; 
              &lt;EasingDoubleKeyFrame.EasingFunction&gt; 
                &lt;ElasticEase EasingMode="EaseIn" Oscillations="2" 
                  Springiness="1.5" /&gt; 
              &lt;/EasingDoubleKeyFrame.EasingFunction&gt; 
            &lt;/EasingDoubleKeyFrame&gt; 
            &lt;EasingDoubleKeyFrame KeyTime="0:0:2.5" Value="36"&gt; 
              &lt;EasingDoubleKeyFrame.EasingFunction&gt; 
                &lt;BackEase EasingMode="EaseOut" Amplitude="2" /&gt; 
              &lt;/EasingDoubleKeyFrame.EasingFunction&gt; 
            &lt;/EasingDoubleKeyFrame&gt; 
          &lt;/DoubleAnimationUsingKeyFrames&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/TextBlock.Triggers&gt; 
&lt;/TextBlock&gt; </pre>
<p>In this example, we animate the size of the text in a <kbd>TextBlock</kbd> element using a number of key-frames. This creates the kind of transition effect that we might see on lines of text in Microsoft PowerPoint presentations and could be suitable to use in an application that presents textual information to the user.</p>
<p>We start by targeting the <kbd>FontSize</kbd> property and specifying a total duration of two and a half seconds. Our first key-frame simply sets our starting font size at zero seconds and so we can use a <kbd>DiscreteDoubleKeyFrame</kbd> for that. The second key-frame is an <kbd>EasingDoubleKeyFrame</kbd> element with a <kbd>BounceEase</kbd> easing function and a duration, or key time, of one second.</p>
<p>Following that, we have another <kbd>EasingDoubleKeyFrame</kbd> element that lasts for one second, but this one uses an <kbd>ElasticEase</kbd> function. Finally, we finish with one further <kbd>EasingDoubleKeyFrame</kbd> element with a <kbd>BackEase</kbd> easing function and a duration of half a second. Note that we have used small values for the <kbd>Bounces</kbd> and <kbd>Oscillations</kbd> properties, to keep the animation more usable.</p>
<p>Using these easing functions with key-frames enable us to chain any number of them together to create more complicated animated effects. However, it is easy to go overboard and create effects that are too much, as can be seen by increasing the values set for the <kbd>Bounces</kbd> and <kbd>Oscillations</kbd> properties in this example. In reality, even the modest values used here could be considered to be too much for practical use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating along a path</h1>
                
            
            
                
<p>There is one further method of animating property values in WPF. Using <kbd>PathFigure</kbd> and <kbd>PathSegment</kbd> objects, we can construct a <kbd>PathGeometry</kbd> object and then animate a property value according to the <kbd>X</kbd>, <kbd>Y</kbd> and/or rotation angle values of the path.</p>
<p>As this method is primarily used for animating objects along a complex path and therefore not aimed at typical business applications, we will cover only the basics of this functionality here. As with the other kinds of animation classes, there are different path animation types that manipulate different CLR types. Path animation classes follow the naming convention <kbd>&lt;Type&gt;AnimationUsingPath</kbd>.</p>
<p>Each <kbd>&lt;Type&gt;AnimationUsingPath</kbd> class has a <kbd>PathGeometry</kbd> property that we can use to specify a path to animate along, using an object of type <kbd>PathGeometry</kbd>. In order to take advantage of the ability to animate the path <kbd>X</kbd> and <kbd>Y</kbd> values in addition to the rotation angle, we need to use a <kbd>MatrixTransform</kbd> element. Let's see an example of this:</p>
<pre>&lt;TextBlock Margin="100,125" Text="Hello World" FontSize="18"&gt; 
  &lt;TextBlock.RenderTransform&gt; 
    &lt;MatrixTransform x:Name="MatrixTransform"&gt; 
      &lt;MatrixTransform.Matrix&gt; 
        &lt;Matrix /&gt; 
      &lt;/MatrixTransform.Matrix&gt; 
    &lt;/MatrixTransform&gt; 
  &lt;/TextBlock.RenderTransform&gt; 
  &lt;TextBlock.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="TextBlock.Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard&gt; 
          &lt;MatrixAnimationUsingPath  
            Storyboard.TargetName="MatrixTransform"  
            Storyboard.TargetProperty="Matrix" Duration="0:0:4"  
            RepeatBehavior="Forever" DoesRotateWithTangent="True"&gt; 
            &lt;MatrixAnimationUsingPath.PathGeometry&gt; 
              &lt;PathGeometry&gt; 
                &lt;PathFigure StartPoint="49.99,49.99"&gt;
                  &lt;ArcSegment Point="50,50" Size="50,50"  
                    SweepDirection="Clockwise" IsLargeArc="True" /&gt; 
                &lt;/PathFigure&gt; 
              &lt;/PathGeometry&gt; 
            &lt;/MatrixAnimationUsingPath.PathGeometry&gt; 
          &lt;/MatrixAnimationUsingPath&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/TextBlock.Triggers&gt; 
&lt;/TextBlock&gt; </pre>
<p>In this example, we animate a <kbd>TextBlock</kbd> element around a circular path using a <kbd>MatrixAnimationUsingPath</kbd> element. The circular path is defined by a single <kbd>ArcSegment</kbd> element within a single <kbd>PathFigure</kbd> element. We set the <kbd>PathFigure.StartPoint</kbd> property value to almost match the <kbd>ArcSegment.Point</kbd> value so that the two ends of the ellipse meet.</p>
<p>In order to animate the rotation of the text element from the <kbd>MatrixAnimationUsingPath</kbd> element, we need to set its <kbd>DoesRotateWithTangent</kbd> property to <kbd>true</kbd>. If this property was set to <kbd>false</kbd>, or simply omitted, then the text element would still be animated in a circular motion, but it would no longer rotate in line with the tangent of the circular path, instead remaining upright.</p>
<p>In addition to the <kbd>MatrixAnimationUsingPath</kbd> class, we can also use either of the <kbd>DoubleAnimationUsingPath</kbd> or <kbd>PointAnimationUsingPath</kbd> classes to animate objects on a path. However, rather than providing examples for these alternative methods, let's now move on to find out how we can include every day animations in our application framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating everyday animations</h1>
                
            
            
                
<p>After covering the wide range of animations that WPF provides, we can see that many of them were designed to enable us to perform animations that emulate real-world situations, rather than to animate form fields in a standard business application. As such, some of the techniques discussed in this chapter are inappropriate for use in our application framework.</p>
<p>However, this does not mean that we cannot create animations to use in our everyday applications. As long as we remember that less is more when it comes to animations in business applications, we can certainly build simple animations into our application framework. One of the best ways to encapsulate these basic animations in our framework is to write one or more custom-animated panels. Let's look at a simple example of an animated <kbd>StackPanel</kbd>:</p>
<pre>using System; 
using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Media; 
using System.Windows.Media.Animation; 
 
namespace CompanyName.ApplicationName.Views.Panels 
{ 
  public class AnimatedStackPanel : Panel 
  { 
    public static DependencyProperty OrientationProperty =  
      DependencyProperty.Register(nameof(Orientation),  
      typeof(Orientation), typeof(AnimatedStackPanel),  
      new PropertyMetadata(Orientation.Vertical)); 
 
    public Orientation Orientation 
    { 
      get { return (Orientation)GetValue(OrientationProperty); } 
      set { SetValue(OrientationProperty, value); } 
    } 
 
    protected override Size MeasureOverride(Size availableSize) 
    { 
      double x = 0, y = 0; 
      foreach (UIElement child in Children) 
      { 
        child.Measure(availableSize); 
        if (Orientation == Orientation.Horizontal) 
        { 
          x += child.DesiredSize.Width; 
          y = Math.Max(y, child.DesiredSize.Height); 
        } 
        else 
        { 
          x = Math.Max(x, child.DesiredSize.Width); 
          y += child.DesiredSize.Height; 
        } 
      } 
      return new Size(x, y); 
    } 
 
    protected override Size ArrangeOverride(Size finalSize) 
    { 
      Point endPosition = new Point(); 
      foreach (UIElement child in Children) 
      { 
        if (Orientation == Orientation.Horizontal)<br/>        {<br/>          child.Arrange(new Rect(-child.DesiredSize.Width, 0, <br/>            child.DesiredSize.Width, finalSize.Height));<br/>          endPosition.X += child.DesiredSize.Width;<br/>        }<br/>        else<br/>        {<br/>          child.Arrange(new Rect(0, -child.DesiredSize.Height,<br/>            finalSize.Width, child.DesiredSize.Height));<br/>          endPosition.Y += child.DesiredSize.Height;<br/>        }<br/>        AnimatePosition(child, endPosition, <br/>          TimeSpan.FromMilliseconds(300));
      } 
      return finalSize; 
    } 
 
    private void AnimatePosition(UIElement child, Point endPosition,  
      TimeSpan animationDuration) 
    { 
      if (Orientation == Orientation. Vertical)  
        GetTranslateTransform(child).BeginAnimation( 
        TranslateTransform.YProperty, 
        new DoubleAnimation(endPosition.Y, animationDuration)); 
      else GetTranslateTransform(child).BeginAnimation( 
        TranslateTransform.XProperty,
        new DoubleAnimation(endPosition.X, animationDuration)); 
    } 
 
    private TranslateTransform GetTranslateTransform(UIElement child) 
    { 
      return child.RenderTransform as TranslateTransform ??  
        AddTranslateTransform(child); 
    } 
 
    private TranslateTransform AddTranslateTransform(UIElement child) 
    { 
      TranslateTransform translateTransform = new TranslateTransform(); 
      child.RenderTransform = translateTransform; 
      return translateTransform; 
    } 
  } 
} </pre>
<p>As with all custom panels, we just need to provide the implementation for the <kbd>MeasureOverride</kbd> and <kbd>ArrangeOverride</kbd> methods. However, in our case, we want to recreate the functionality of the original <kbd>StackPanel</kbd> control and so we have also declared an <kbd>Orientation</kbd> Dependency Property of type <kbd>System.Windows.Controls.Orientation</kbd>, with a default value of <kbd>Vertical</kbd>.</p>
<p>In the <kbd>MeasureOverride</kbd> method, we iterate through each of the panel's children, calling their <kbd>Measure</kbd> method, passing in the <kbd>availableSize</kbd> input parameter. Note that this sets their <kbd>DesiredSize</kbd> property, which will be set to a size of <kbd>0,0</kbd> until this point.</p>
<p>After calling the <kbd>Measure</kbd> method on each child, we are able to use their <kbd>DesiredSize</kbd> property values to calculate the total size required to properly display the rendered items, depending on the value of the <kbd>Orientation</kbd> property.</p>
<p>If the <kbd>Orientation</kbd> property is set to <kbd>Vertical</kbd>, we use the <kbd>Math.Max</kbd> method to ensure that we keep account of the size of the widest element and if it is set to <kbd>Horizontal</kbd>, then we use it to find the height of the tallest element. Once each child has been measured and the overall required size of the panel has been calculated, we return this size value from the <kbd>MeasureOverride</kbd> method.</p>
<p class="mce-root">In the <kbd>ArrangeOverride</kbd> method, we again iterate through the collection of children, but this time we call the <kbd>Arrange</kbd> method on each child, positioning each just outside the bounds of the panel, which will be the starting point of their animations.</p>
<p class="mce-root">If the <kbd>Orientation</kbd> property is set to <kbd>Horizontal</kbd>, we position the children one child’s width to the left of the origin point and set their height to the height of the panel. If the <kbd>Orientation</kbd> property is set to <kbd>Vertical</kbd>, we position them one child’s height above the origin point and set their width to the width of the panel.</p>
<p class="mce-root">This has the effect of stretching each item across the height or width of the panel, depending upon the value of the <kbd>Orientation</kbd> property, as neatly aligned items with uniform dimensions look tidier and more professional than items with uneven edges. In this way, we can build these kinds of decisions right into our framework controls.</p>
<p class="mce-root">Next, we calculate the desired end position of each child after animation with the <kbd>endPosition</kbd> variable and then call the <kbd>AnimatePosition</kbd> method, passing in the child, the end position and the duration of the animation. We end the method by returning the unchanged <kbd>finalSize</kbd> input parameter.</p>
<p>In the <kbd>AnimatePosition</kbd> method, we call the <kbd>GetTranslateTransform</kbd> method to get the <kbd>TranslateTransform</kbd> object that we will use to move each child across the panel. If the <kbd>Orientation</kbd> property is set to <kbd>Vertical</kbd>, we animate the <kbd>TranslateTransform.YProperty</kbd> property to the value of the <kbd>endPosition.Y</kbd> property, otherwise we animate the <kbd>TranslateTransform.XProperty</kbd> property to the value of the <kbd>endPosition.X</kbd> property.</p>
<p>In order to animate these property values, we use the <kbd>BeginAnimation</kbd> method on the <kbd>UIElement</kbd> object with the property to be added. There are two overloads of this method, but we are using one that accepts the key of the Dependency Property to animate and the animation object. The other overload enables us to specify the <kbd>HandoffBehavior</kbd> to use with the animation.</p>
<p>For our animation, we are using a <kbd>DoubleAnimation</kbd>, with a constructor that accepts the <kbd>To</kbd> value and the duration of the animation, although there are several other overloads that we could have used, had we needed to specify further properties, such as the <kbd>From</kbd> and <kbd>FillBehavior</kbd> values.</p>
<p>In order to animate the movement of the items in the panel, we need to ensure that they have a <kbd>TranslateTransform</kbd> element applied to the <kbd>RenderTransform</kbd> property of the container item of each child. Remember that different <kbd>ItemsControl</kbd> classes will use different container items, for example, a <kbd>ListBox</kbd> control will use <kbd>ListBoxItem</kbd> container elements.</p>
<p>Therefore, if an item does not already have a <kbd>TranslateTransform</kbd> element applied, we must add one. Once each element has a <kbd>TranslateTransform</kbd> element, we can use its <kbd>X</kbd> and <kbd>Y</kbd> properties to move the item.</p>
<p>In the <kbd>GetTranslateTransform</kbd> method, we simply return the existing <kbd>TranslateTransform</kbd> element from the <kbd>RenderTransform</kbd> property of each child if one exists, or call the <kbd>AddTranslateTransform</kbd> method to return a new one otherwise. In the <kbd>AddTranslateTransform</kbd> method, we just initialize a new <kbd>TranslateTransform</kbd> element and set it to the <kbd>RenderTransform</kbd> property of the <kbd>child</kbd> input parameter, before returning it.</p>
<p>We've now created a basic animated panel and with just around seventy lines of code. The developers that use our application framework can now animate the entry of items in any <kbd>ItemsControl</kbd>, or any of its derived collection controls, by simply specifying it in a <kbd>ItemsPanelTemplate</kbd> as the <kbd>ItemsPanel</kbd> value:</p>
<pre> 
... 
&lt;ListBox ItemsSource="{Binding Users}"&gt; 
  &lt;ListBox.ItemsPanel&gt; 
    &lt;ItemsPanelTemplate&gt; 
      &lt;Panels:AnimatedStackPanel /&gt; 
    &lt;/ItemsPanelTemplate&gt; 
  &lt;/ListBox.ItemsPanel&gt; 
&lt;/ListBox&gt; </pre>
<p>However, our panel currently only provides one type of animation, albeit in two possible directions, and only works as new items are added. Animating objects' exit is somewhat trickier, because they are normally removed immediately from the panel's <kbd>Children</kbd> collection when the <kbd>Remove</kbd> method is called on the data bound collection.</p>
<p>In order to accomplish working exit animations, we'll need to implement a number of things. We'll need to update our data Model classes to provide them with new properties to identify which stage of the animation that they're currently in and new events to raise when the current status changes.</p>
<p>We'll need an <kbd>IAnimatable</kbd> interface and an <kbd>Animatable</kbd> class that provides the implementation for each data Model. Let's first see the interface:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Interfaces 
{ 
  public interface IAnimatable 
  { 
    Animatable Animatable { get; set; } 
  } 
} </pre>
<p>Note that there is already an <kbd>Animatable</kbd> class and an <kbd>IAnimatable</kbd> interface defined in the <kbd>System.Windows.Media.Animation</kbd> namespace. While it can be unwise to create classes and interfaces with the same names as existing ones, for the limited purposes of this book, we will use these names and be mindful to prevent conflicts.</p>
<p>Now let's move on, to see the implementation of our <kbd>Animatable</kbd> class:</p>
<pre>using System; 
using CompanyName.ApplicationName.DataModels.Enums; 
using CompanyName.ApplicationName.DataModels.Interfaces; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class Animatable 
  { 
    private AdditionStatus additionStatus = AdditionStatus.ReadyToAnimate; 
    private RemovalStatus removalStatus = RemovalStatus.None;  
    private TransitionStatus transitionStatus = TransitionStatus.None; 
    private IAnimatable owner; 
 
    public Animatable(IAnimatable owner) 
    { 
      Owner = owner; 
    } 
 
    public Animatable() { } 
 
    public event EventHandler&lt;EventArgs&gt; OnRemovalStatusChanged;  
    public event EventHandler&lt;EventArgs&gt; OnTransitionStatusChanged; 
 
    public IAnimatable Owner 
    { 
      get { return owner; } 
      set { owner = value; } 
    } 
 
    public AdditionStatus AdditionStatus 
    { 
      get { return additionStatus; } 
      set { additionStatus = value; } 
    } 
 
    public TransitionStatus TransitionStatus 
    { 
      get { return transitionStatus; } 
      set 
      { 
        transitionStatus = value; 
        OnTransitionStatusChanged?.Invoke(this, new EventArgs()); 
      } 
    } 
 
    public RemovalStatus RemovalStatus 
    { 
      get { return removalStatus; } 
      set 
      { 
        removalStatus = value; 
        OnRemovalStatusChanged?.Invoke(this, new EventArgs()); 
      } 
    } 
  } 
} </pre>
<p>This class needs little explanation, other than to note that the <kbd>OnTransitionStatusChanged</kbd> and <kbd>OnRemovalStatusChanged</kbd> events get raised when the values of the <kbd>TransitionStatus</kbd> and <kbd>RemovalStatus</kbd> properties are changed respectively and that the class passes itself in as the <kbd>sender</kbd> input parameter in each case. Let's see the three new enumeration classes that are used in our <kbd>Animatable</kbd> class:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Enums 
{ 
  public enum AdditionStatus 
  { 
    None = -1, ReadyToAnimate = 0, DoNotAnimate = 1, Added = 2 
  } 
 
  public enum TransitionStatus 
  { 
    None = -1, ReadyToAnimate = 0, AnimationComplete = 1 
  }

  public enum RemovalStatus 
  { 
    None = -1, ReadyToAnimate = 0, ReadyToRemove = 1 
  } 
} </pre>
<p>We then need to implement this interface in each data Model class that we want to animate:</p>
<pre>public class User : ... , IAnimatable 
{ 
  private Animatable animatable;

  ...
 
  public User(Guid id, string name, int age) 
  { 
    Animatable = new Animatable(this); 
    ... 
  } 
 
  public Animatable Animatable 
  { 
    get { return animatable; } 
    set { animatable = value; } 
  } 

  ... 
} </pre>
<p>The next thing that we need to do is to stop the <kbd>Remove</kbd> method from actually removing each item when called. We'll need to update our <kbd>BaseCollection&lt;T&gt;</kbd> class, or add a new <kbd>BaseAnimatableCollection&lt;T&gt;</kbd> class, so that it triggers the animation instead of removing the item directly. Here is a cut down example showing one way that we might do this:</p>
<pre>using System; 
using System.Collections.Generic; 
using System.ComponentModel; 
using System.Linq; 
using CompanyName.ApplicationName.DataModels.Enums; 
using CompanyName.ApplicationName.DataModels.Interfaces; 
 
namespace CompanyName.ApplicationName.DataModels.Collections 
{ 
  public class BaseAnimatableCollection&lt;T&gt; : BaseCollection&lt;T&gt;  
    where T : class, IAnimatable, INotifyPropertyChanged, new() 
  { 
    private bool isAnimatable = true; 
 
    public BaseAnimatableCollection(IEnumerable&lt;T&gt; collection) 
    { 
      foreach (T item in collection) Add(item); 
    } 
 
    ... 

    public bool IsAnimatable  
    { 
      get { return isAnimatable; } 
      set { isAnimatable = value; } 
    } 
 
    public new int Count =&gt; IsAnimatable ? 
      this.Count(i =&gt; i.Animatable.RemovalStatus == RemovalStatus.None) :
      this.Count(); 
 
    public new void Add(T item) 
    { 
      item.Animatable.OnRemovalStatusChanged +=
        Item_OnRemovalStatusChanged; 
      item.Animatable.AdditionStatus = AdditionStatus.ReadyToAnimate; 
      base.Add(item); 
    } 
 
    public new virtual void Add(IEnumerable&lt;T&gt; collection) 
    { 
      foreach (T item in collection) Add(item); 
    } 
 
    public new virtual void Add(params T[] items) 
    { 
      Add(items as IEnumerable&lt;T&gt;); 
    } 
 
    public new void Insert(int index, T item) 
    { 
      item.Animatable.OnRemovalStatusChanged += 
        Item_OnRemovalStatusChanged; 
      item.Animatable.AdditionStatus = AdditionStatus.ReadyToAnimate; 
      base.Insert(index, item); 
    } 
 
    protected override void ClearItems() 
    { 
      foreach (T item in this) item.Animatable.OnRemovalStatusChanged -=
        Item_OnRemovalStatusChanged; 
      base.ClearItems(); 
    } 
 
    public new bool Remove(T item) 
    { 
      item.Animatable.RemovalStatus = RemovalStatus.ReadyToAnimate; 
      return true; 
    } 
 
    public void Item_OnRemovalStatusChanged(object sender, EventArgs e) 
    { 
      Animatable animatable = (Animatable)sender; 
      if (animatable.RemovalStatus == RemovalStatus.ReadyToRemove ||  
        (animatable.RemovalStatus == RemovalStatus.ReadyToAnimate &amp;&amp; 
        !IsAnimatable)) 
      { 
        base.Remove(animatable.Owner as T); 
        animatable.RemovalStatus = RemovalStatus.None; 
      } 
    } 
  } 
} </pre>
<p>Bear in mind that this is a basic example that could be improved in many ways, such as adding checks for <kbd>null</kbd>, enabling addition, removal and insertion capabilities that do not trigger animations and adding other useful properties.</p>
<p>In this class, we start by specifying that the generic <kbd>T</kbd> type parameter must implement the <kbd>IAnimatable</kbd> interface. As with our other base collection classes, we ensure that all added and inserted items call a new <kbd>Add</kbd> method that attaches our animation related handlers. We show an example of this in the constructor, but skip the other constructor declarations to save space.</p>
<p>We then declare an <kbd>IsAnimatable</kbd> property that we can use to make this collection work without animation. This property is used in the overridden (or <kbd>new</kbd>) <kbd>Count</kbd> property, to ensure that items that are due to be removed are not included in the count of the collection's children.</p>
<p>In the new <kbd>Add</kbd> method, we attach a reference of our <kbd>Item_OnRemovalStatusChanged</kbd> handler to the <kbd>OnRemovalStatusChanged</kbd> event of the <kbd>Animatable</kbd> object of the item being added. We then set the <kbd>AdditionStatus</kbd> property of the <kbd>Animatable</kbd> object to the <kbd>ReadyToAnimate</kbd> member to signal that the object is ready to begin its entrance animation.</p>
<p>As this base collection is extending another base class, we need to remember to call its <kbd>Add</kbd> method, passing in the item, so that it can attach its own handler for the item's <kbd>PropertyChanged</kbd> event. The other <kbd>Add</kbd> overloads enable multiple items to be added to the collection, but both internally call the first <kbd>Add</kbd> method. The <kbd>Insert</kbd> method does the same as the first <kbd>Add</kbd> method.</p>
<p>The <kbd>ClearItems</kbd> method iterates through each item in the collection, detaching the reference to the <kbd>Item_OnRemovalStatusChanged</kbd> handler from each before calling the <kbd>ClearItems</kbd> method of the base class. As it is, this method could be reserved for removing all items from the collection without animation, but it would be easy to call the <kbd>Remove</kbd> method with each item to include animations.</p>
<p>The <kbd>Remove</kbd> method in this class enables us to animate the exit of each item; it doesn't actually remove the item from the collection, but instead sets the <kbd>RemovalStatus</kbd> property of the item's <kbd>Animatable</kbd> object to the <kbd>ReadyToAnimate</kbd> member to signal that the object is ready to begin its exit animation. It then returns true from the method to signify successful removal of the item.</p>
<p>Finally, we get to the <kbd>Item_OnRemovalStatusChanged</kbd> event handler, which is the next major part in enabling exit animations. In it, we cast the <kbd>sender</kbd> input parameter to an instance of our <kbd>Animatable</kbd> class. Remember that it passes itself as the <kbd>sender</kbd> parameter when raising the event.</p>
<p>We then check whether the <kbd>RemovalStatus</kbd> property of the <kbd>Animatable</kbd> instance is set to the <kbd>ReadyToRemove</kbd> member, or both its <kbd>RemovalStatus</kbd> property is set to <kbd>ReadyToAnimate</kbd> and the collection is not animatable. If either condition is true, we finally call the <kbd>Remove</kbd> method of the base class to actually remove the item from the collection and set the <kbd>RemovalStatus</kbd> property to <kbd>None</kbd>.</p>
<p>In this way, when the collection is set to be not animatable and the <kbd>Remove</kbd> method is called, the item is immediately removed and the <kbd>Animatable</kbd> object's <kbd>RemovalStatus</kbd> property is set to the <kbd>None</kbd> member in the <kbd>Item_OnRemovalStatusChanged</kbd> handler. If you remember, the <kbd>OnRemovalStatusChanged</kbd> event gets raised when the <kbd>RemovalStatus</kbd> property value is changed.</p>
<p>However, we're still missing part of this puzzle. <em>What sets the</em> <kbd>Animatable</kbd> <em>object's</em> <kbd>RemovalStatus</kbd> <em>property to the</em> <kbd>ReadyToRemove</kbd> <em>member to remove each item?</em> We will need to update our animated panel to accomplish this task, and to do this, it will need to maintain a collection of the elements that need to be removed and signal the collection to remove them once their exit animations complete:</p>
<pre>private List&lt;UIElement&gt; elementsToBeRemoved = new List&lt;UIElement&gt;();</pre>
<p>We can use the <kbd>Storyboard.Completed</kbd> event to notify us when the animation is complete and then signal to remove the item at that point, by setting the <kbd>Animatable</kbd> object's <kbd>RemovalStatus</kbd> property to the <kbd>ReadyToRemove</kbd> member. Let's take a look at the required changes to our animated panel. First, we need to add the following using declarations:</p>
<pre>using System.Collections.Generic; 
using CompanyName.ApplicationName.DataModels.Enums; 
using Animatable = CompanyName.ApplicationName.DataModels.Animatable; 
using IAnimatable = 
  CompanyName.ApplicationName.DataModels.Interfaces.IAnimatable; </pre>
<p>Next, we need to replace the call to the <kbd>AnimatePosition</kbd> method from the original <kbd>ArrangeOverride</kbd> method with the following line:</p>
<pre>BeginAnimations(child, finalSize, endPosition); </pre>
<p>We then need to add the following additional methods after the <kbd>ArrangeOverride</kbd> method:</p>
<pre>private void BeginAnimations(UIElement child, Size finalSize, 
  Point endPosition) 
{ 
  FrameworkElement frameworkChild = (FrameworkElement)child; 
  if (frameworkChild.DataContext is IAnimatable) 
  { 
    Animatable animatable =
      ((IAnimatable)frameworkChild.DataContext).Animatable; 
    animatable.OnRemovalStatusChanged -= Item_OnRemovalStatusChanged; 
    animatable.OnRemovalStatusChanged += Item_OnRemovalStatusChanged; 
    if (animatable.AdditionStatus == AdditionStatus.DoNotAnimate) 
    { 
      child.Arrange(new Rect(endPosition.X, endPosition.Y,  
        frameworkChild.ActualWidth, frameworkChild.ActualHeight)); 
    } 
    else if (animatable.AdditionStatus == AdditionStatus.ReadyToAnimate) 
    { 
      AnimateEntry(child, endPosition); 
      animatable.AdditionStatus = AdditionStatus.Added;  
      animatable.TransitionStatus = TransitionStatus.ReadyToAnimate; 
    } 
    else if (animatable.RemovalStatus == RemovalStatus.ReadyToAnimate)
      AnimateExit(child, endPosition, finalSize);  
    else if (animatable.TransitionStatus == 
      TransitionStatus.ReadyToAnimate) 
      AnimateTransition(child, endPosition); 
  } 
} 
 
private void Item_OnRemovalStatusChanged(object sender, EventArgs e) 
{ 
  if (((Animatable)sender).RemovalStatus == RemovalStatus.ReadyToAnimate)  
    InvalidateArrange(); 
} 
 
private void AnimateEntry(UIElement child, Point endPosition) 
{ 
  AnimatePosition(child, endPosition, TimeSpan.FromMilliseconds(300)); 
} 
 
private void AnimateTransition(UIElement child, Point endPosition) 
{ 
  AnimatePosition(child, endPosition, TimeSpan.FromMilliseconds(300)); 
} 
 
private void AnimateExit(UIElement child, Point startPosition,
  Size finalSize) 
{ 
  SetZIndex(child, 100); 
  Point endPosition = 
    new Point(startPosition.X + finalSize.Width, startPosition.Y); 
  AnimatePosition(child, startPosition, endPosition,  
    TimeSpan.FromMilliseconds(300), RemovalAnimation_Completed); 
  elementsToBeRemoved.Add(child); 
} 
 
private void AnimatePosition(UIElement child, Point startPosition,
  Point endPosition, TimeSpan animationDuration,
  EventHandler animationCompletedHandler) 
{ 
  if (startPosition.X != endPosition.X) 
  { 
    DoubleAnimation xAnimation = new DoubleAnimation(startPosition.X,  
      endPosition.X, animationDuration); 
    xAnimation.AccelerationRatio = 1.0; 
    if (animationCompletedHandler != null)  
      xAnimation.Completed += animationCompletedHandler; 
    GetTranslateTransform(child).BeginAnimation(
      TranslateTransform.XProperty, xAnimation); 
  } 
  if (startPosition.Y != endPosition.Y) 
  { 
    DoubleAnimation yAnimation = new DoubleAnimation(startPosition.Y,  
      endPosition.Y, animationDuration); 
    yAnimation.AccelerationRatio = 1.0; 
    if (startPosition.X == endPosition.X &amp;&amp; animationCompletedHandler !=
      null) yAnimation.Completed += animationCompletedHandler;
    GetTranslateTransform(child).BeginAnimation( 
      TranslateTransform.YProperty, yAnimation); 
  } 
} 
 
private void RemovalAnimation_Completed(object sender, EventArgs e) 
{ 
  for (int index = elementsToBeRemoved.Count - 1; index &gt;= 0; index--) 
  { 
    FrameworkElement frameworkElement =  
      elementsToBeRemoved[index] as FrameworkElement; 
    if (frameworkElement.DataContext is IAnimatable) 
    { 
      ((IAnimatable)frameworkElement.DataContext).Animatable.RemovalStatus
        = RemovalStatus.ReadyToRemove; 
      elementsToBeRemoved.Remove(frameworkElement); 
    } 
  } 
} </pre>
<p>Let's examine this new code. First, we have the <kbd>BeginAnimations</kbd> method, in which we cast the container control to a <kbd>FrameworkElement</kbd>, so that we can access its <kbd>DataContext</kbd> property. Our data object is accessed from this property and we cast it to an <kbd>IAnimatable</kbd> instance, so that we can access the <kbd>Animatable</kbd> object via its <kbd>Animatable</kbd> property.</p>
<p>We then remove our <kbd>Item_OnRemovalStatusChanged</kbd> event handler from the <kbd>OnRemovalStatusChanged</kbd> event before re-attaching it, to ensure that only a single handler is attached, regardless of how many times each child passes through this method.</p>
<p>If the <kbd>AdditionStatus</kbd> property is set to <kbd>DoNotAnimate</kbd>, we arrange the item at its end position immediately and without animation, while if it is set to <kbd>ReadyToAnimate</kbd>, we call the <kbd>AnimateEntry</kbd> method and then set the <kbd>AdditionStatus</kbd> property to <kbd>Added</kbd>. Finally, if the <kbd>RemovalStatus</kbd> property is set to <kbd>ReadyToAnimate</kbd>, we call the <kbd>AnimateExit</kbd> method.</p>
<p>In the <kbd>Item_OnRemovalStatusChanged</kbd> event handler, we call the panel's <kbd>InvalidateArrange</kbd> method if the <kbd>RemovalStatus</kbd> property is set to <kbd>ReadyToAnimate</kbd>. This is another essential part of the exit animation strategy and it requests the layout system to call the <kbd>ArrangeOverride</kbd> method, thereby triggering the starting of the exit animation(s).</p>
<p>Remember that the <kbd>OnRemovalStatusChanged</kbd> event gets raised when the value of the <kbd>RemovalStatus</kbd> property is changed. Also recall that the <kbd>RemovalStatus</kbd> property is set to the <kbd>ReadyToAnimate</kbd> member in the <kbd>Remove</kbd> method of the <kbd>BaseAnimatableCollection&lt;T&gt;</kbd> class. That raises the event and this event handler starts the animations in response.</p>
<p>The <kbd>AnimateEntry</kbd> method simply calls the original, unchanged <kbd>AnimatePosition</kbd> method from our first animated panel attempt. The <kbd>AnimateExit</kbd> method takes an additional <kbd>startPosition</kbd> input parameter, which represents the current position of each item within the panel.</p>
<p>We start by setting the <kbd>Panel.SetZIndex</kbd> Attached Property to a value of <kbd>100</kbd> for each child, to ensure that their animated departure is rendered above, or over the top of, the remaining items. We then calculate the end position of the animation using the start position and the size of the panel.</p>
<p>Next, we call an overload of the <kbd>AnimatePosition</kbd> method, passing in our child, start and end positions, animation duration and an event handler as parameters. After the child item's position animation has been started, the child is added to the <kbd>elementsToBeRemoved</kbd> collection.</p>
<p>In the <kbd>AnimatePosition</kbd> method, we first check that our start and end positions are different, before creating and starting our <kbd>DoubleAnimation</kbd> objects. If the <kbd>X</kbd> values are different and the event handler input parameter is not <kbd>null</kbd>, then we attach it to the <kbd>Completed</kbd> event of the <kbd>xAnimation</kbd> object before starting its animation.</p>
<p>If the <kbd>Y</kbd> values are different and the event handler input parameter is not <kbd>null</kbd> and the event handler was not already attached to the <kbd>xAnimation</kbd> object, then we attach it to the <kbd>Completed</kbd> event of the <kbd>yAnimation</kbd> object before starting its animation. Note that we only need to attach one handler to this event, because we only have one object to remove from the collection.</p>
<p>Also note that we set the <kbd>AccelerationRatio</kbd> property to <kbd>1.0</kbd> in this overload, so that the item accelerates off screen. However, in a business application framework, we would want to keep our animation properties in sync and so, we would probably set the <kbd>AccelerationRatio</kbd> property to <kbd>1.0</kbd> on the animation objects in the original <kbd>AnimatePosition</kbd> method as well.</p>
<p>The last piece of the puzzle is the <kbd>RemovalAnimation_Completed</kbd> event handling method. This method gets called when the exit animation has completed and iterates through the <kbd>elementsToBeRemoved</kbd> collection. If any element to remove implements the <kbd>IAnimatable</kbd> interface, its <kbd>Animatable</kbd> object's <kbd>RemovalStatus</kbd> property is set to the <kbd>ReadyToRemove</kbd> member.</p>
<p>If you remember, this raises the <kbd>OnRemovalStatusChanged</kbd> event, which is handled by the <kbd>Item_OnRemovalStatusChanged</kbd> event handler in the <kbd>BaseAnimatableCollection</kbd> class. In that method, the <kbd>Animatable</kbd> object's <kbd>RemovalStatus</kbd> property is checked for the <kbd>ReadyToRemove</kbd> member and if found, the owning item is actually removed from the collection.</p>
<p>And so, to summarize; the <kbd>Remove</kbd> method of the animation collection is called, but instead of removing the item, it sets a property on it, which raises an event that is handled by the animated panel; the panel then starts the exit animation and when completed, it raises an event that is handled by the collection class and results in the item actually being removed from the collection.</p>
<p>While this animated panel is entirely usable as it is, there are many ways that it could be further improved. One important thing that we could do would be to extract all of the properties and animation code from this class and put them into a base <kbd>AnimatedPanel</kbd> class. In this way, we could reuse this class when creating other types of animated panel, such as an <kbd>AnimatedWrapPanel</kbd>.</p>
<p>We could then further extend the base class by exposing additional animation properties, so that users of our panel could have more control over the animations that it provides. For example, we could declare <kbd>VerticalContentAlignment</kbd> and <kbd>HorizontalContentAlignment</kbd> properties to dictate how our panel items should be aligned in the panel.</p>
<p>Additionally, we could add <kbd>EntryAnimationDirection</kbd> and <kbd>ExitAnimationDirection</kbd> properties to specify which direction to animate our panel items as they are added and removed from the panel. We could also enable different types of animation, such as fading or spinning, by animating the <kbd>Opacity</kbd> property, or the <kbd>Angle</kbd> property of a <kbd>RotationTransform</kbd> element.</p>
<p>Furthermore, we could add <kbd>EntryAnimationDuration</kbd> and <kbd>ExitAnimationDuration</kbd> properties to specify the length of time that each animation should take, rather than hardcoding values directly into our panel. There really is no limit to what functionality that we can provide with our application framework panels, other than the limitations dictated by the end users' computer hardware.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we've investigated the variety of animation possibilities that WPF provides us with, primarily focusing on XAML and the more usable options. We've discovered the finer details of timelines and also explored how we can incorporate animation into our application framework, so that its users can easily leverage the power of animations without having to know anything about them.</p>
<p>In the next chapter, we will look at a number of ways that we can improve the overall look and feel of our applications, from providing consistent application styles and icons to examining a number of techniques for creating rich graphics.</p>


            

            
        
    </body></html>