- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Understanding Basic Blazor Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本 Blazor 组件
- en: In this chapter, we will look at the components that come with the Blazor template
    and start to build our own components. Knowing the different techniques used for
    creating Blazor websites will help us when we start building our components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看 Blazor 模板中提供的组件，并开始构建我们自己的组件。了解用于创建 Blazor 网站的不同的技术将有助于我们开始构建自己的组件。
- en: Blazor uses components for most things, so we will use the knowledge from this
    chapter throughout the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 使用组件来完成大多数事情，因此我们将在这本书的整个过程中使用本章的知识。
- en: We will start this chapter with theory and end by creating a component to show
    some blog posts using the API we created previously, in *Chapter 3*, *Managing
    State – Part 1*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节的理论开始，并以创建一个组件来展示一些博客文章结束，这些博客文章使用我们在 *第 3 章*，*管理状态 – 第 1 部分* 中创建的 API。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索组件
- en: Learning Razor syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Razor 语法
- en: Understanding dependency injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解依赖注入
- en: Changing the Render mode
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改渲染模式
- en: Figuring out where to put the code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定代码放置的位置
- en: Lifecycle events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期事件
- en: Parameters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: Writing our first component
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个组件
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have followed the previous chapters or use the `Chapter03` folder
    as the starting point.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经跟进了前面的章节，或者使用 `Chapter03` 文件夹作为起点。
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04)
    找到本章结果的源代码。
- en: Exploring components
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索组件
- en: In Blazor, a `component` is a `.razor` file containing a small, isolated functionality
    (code and markup), or it can be used as a page. A component can host other components
    as well. This chapter will show us how components work and how to use them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 中，一个 `component` 是一个包含小而独立的函数（代码和标记）的 `.razor` 文件，或者它可以作为一个页面使用。组件还可以托管其他组件。本章将向我们展示组件是如何工作的以及如何使用它们。
- en: 'There are three different ways we can create a component:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种不同的方式可以创建一个组件：
- en: Using Razor syntax, with the code and HTML sharing the same file
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Razor 语法，代码和 HTML 在同一个文件中共享
- en: Using a code-behind file together with a `.razor` file
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码后文件与 `.razor` 文件一起使用
- en: Using only a code-behind file
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用代码后文件
- en: In this chapter, we will go through the different options. First, we’ll go through
    the components in the template we used to create the project; these all use the
    first option, `.razor` files, where we have a mix of code and HTML in the same
    file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的选项。首先，我们将探讨我们用于创建项目的模板中的组件；这些组件都使用了第一个选项，即 `.razor` 文件，其中我们在同一个文件中混合了代码和
    HTML。
- en: 'The components in the template are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的组件如下：
- en: '**Counter**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**'
- en: '**Weather**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天气**'
- en: Counter
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数器
- en: The `counter` page shows a button and a counter; if we click the button, the
    counter increases. We will now break the page apart, making it easier to understand.
    It is located in the `BlazorWebApp.Client` project, inside the `Pages` folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter` 页面显示了一个按钮和一个计数器；如果我们点击按钮，计数器会增加。现在我们将把这个页面拆分开来，使其更容易理解。它位于 `BlazorWebApp.Client`
    项目中的 `Pages` 文件夹内。'
- en: 'At the top of the page is the `@page` directive, which makes it possible to
    route to the component directly, as we can see in this code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 页面顶部是 `@page` 指令，这使得我们可以直接路由到组件，正如我们在这段代码中看到的那样：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we start the `BlazorWebApp` project and add `/counter` to the end of the
    URL, we see that we can directly access the component by using its route. We can
    also make the route take parameters, but we will return to that later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动 `BlazorWebApp` 项目，并将 `/counter` 添加到 URL 的末尾，我们可以直接通过其路由访问组件。我们还可以使路由接受参数，但我们将稍后回到这一点。
- en: 'Beneath that, we have the render mode:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，我们有渲染模式：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the way we can set the render mode on a specific component. This means
    that when we use this component, it will first render the page using Blazor Server
    (with SignalR) and, in the background, download the WebAssembly version so that
    the next time we load the page, it will then run the WebAssembly version instead.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以在特定组件上设置渲染模式的方法。这意味着当我们使用这个组件时，它将首先使用 Blazor 服务器（带有 SignalR）渲染页面，并在后台下载
    WebAssembly 版本，以便下次我们加载页面时，它将运行 WebAssembly 版本。
- en: 'Next, let’s explore the code. To add code to the page, we use the `@code` statement,
    and within that statement, we can add ordinary C# code, as shown:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索一下代码。要向页面添加代码，我们使用 `@code` 语句，并在该语句中可以添加普通的 C# 代码，如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code block, we have a private `currentCount` variable set to
    `0`. Then, we have a method called `IncrementCount()`, which increments the `currentCount`
    variable by `1`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有一个设置为 `0` 的私有 `currentCount` 变量。然后，我们有一个名为 `IncrementCount()` 的方法，该方法将
    `currentCount` 变量增加 `1`。
- en: 'We show the current value by using the `@` sign. In Razor, the `@` sign indicates
    that it is time for some code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `@` 符号来显示当前值。在 Razor 中，`@` 符号表示是时候编写一些代码了：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, Razor is very smart because it understands when the code stops
    and the markup continues, so there is no need to add something extra to transition
    from the code to the markup (more on that in the next section).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Razor 非常智能，因为它能理解代码何时停止，标记何时继续，因此不需要添加额外的内容来从代码过渡到标记（更多内容将在下一节中介绍）。
- en: 'As we can see in the preceding example, we are mixing HTML tags with `@currentCount`
    and Razor understands the difference. Next, we have a button that is the trigger
    for changing the value:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们在 HTML 标签和 `@currentCount` 之间混合，Razor 能够理解这种区别。接下来，我们有一个按钮，它是改变值的触发器：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an HTML button with a `Bootstrap` class (to make it look a bit nicer).
    `@onclick` binds the button’s `onclick` event to the `IncrementCount()` method.
    If we were to use `onclick` without the `@`, it would refer to the JavaScript
    event and not work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有 `Bootstrap` 类（使其看起来更美观）的 HTML 按钮。`@onclick` 将按钮的 `onclick` 事件绑定到 `IncrementCount()`
    方法。如果我们不使用 `@` 符号来使用 `onclick`，它将引用 JavaScript 事件而不会工作。
- en: 'So, when we click the button, it will call the `IncrementCount()` method (depicted
    by `1` in *Figure 4.1*), the method increments the variable (depicted by `2`),
    and due to changing the variable, the UI will automatically be updated (depicted
    by `3`), as shown in *Figure 4.1*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们点击按钮时，它将调用 `IncrementCount()` 方法（在 *图 4.1* 中表示为 `1`），该方法增加变量（在 *图 4.1*
    中表示为 `2`），由于变量发生了变化，UI 将自动更新（在 *图 4.1* 中表示为 `3`），如图所示：
- en: '![Figure 4.1 – The flow of the counter component ](img/B21849_04_01.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 计数组件的流程](img/B21849_04_01.png)'
- en: 'Figure 4.1: The flow of the counter component'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：计数组件的流程
- en: The `counter` component is implemented inside the `BlazorWebApp.Client` project,
    which is the WebAssembly project. In that project, we should put all the components
    that we want to run as WebAssembly. The `BlazorWebApp` project is then referencing
    the `BlazorWebApp.Client` project, so that it finds all the components and can
    run them as Blazor Server components if we want to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter` 组件是在 `BlazorWebApp.Client` 项目中实现的，这是一个 WebAssembly 项目。在那个项目中，我们应该放置所有我们想要作为
    WebAssembly 运行的组件。然后 `BlazorWebApp` 项目引用 `BlazorWebApp.Client` 项目，这样它就能找到所有组件，并且如果我们想的话，可以将其作为
    Blazor 服务器组件运行。'
- en: Weather
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 天气
- en: The next component we will take a look at is the `Weather` component. It’s located
    in the `Components/Pages/Weather.razor` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的组件是 `Weather` 组件。它位于 `Components/Pages/Weather.razor` 文件夹中。
- en: 'The `Weather` components introduces the new streaming rendering functionality.
    The file initially looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Weather` 组件介绍了新的流式渲染功能。文件最初看起来是这样的：'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just as with the `Counter` component, we first define a route. There is no render
    mode attribute on this page. The component will be rendered using **Server-Side
    Rendering** (**SSR**). This is the default behavior for all the components unless
    specified, like the Counter component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Counter` 组件一样，我们首先定义一个路由。这个页面上没有渲染模式属性。该组件将使用 **服务器端渲染**（**SSR**）进行渲染。这是所有组件的默认行为，除非指定，就像
    `Counter` 组件一样。
- en: When we started the project, we set **Interactivity location** to **Per Page/Component**.
    This means that when we want interactivity, we need to specify that. But with
    the `[StreamRendering(true)]` attribute, we will get a feeling of interactivity.
    The page will first load, showing loading text. Then, using the same request,
    we get the rest of the data, like a `…` well, stream. So, we will get fast loading
    without waiting for the data, with no need to add interactivity using WebAssembly
    or SignalR, but still get some loading progress happening. We will dive into this
    some more in a later section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始项目时，我们将 **交互位置** 设置为 **每页/组件**。这意味着当我们想要交互时，我们需要指定这一点。但是，有了 `[StreamRendering(true)]`
    属性，我们将获得一种交互感。页面首先加载，显示加载文本。然后，使用相同的请求，我们获取其余的数据，就像一个 `…` 好吧，流。所以，我们将获得快速加载，无需等待数据，无需使用
    WebAssembly 或 SignalR 添加交互性，但仍有一些加载进度。我们将在稍后的章节中进一步探讨这一点。
- en: 'The HTML part of the `Weather` component looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Weather` 组件的 HTML 部分看起来像这样：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we don’t have any forecasts, it will show “Loading…” and as soon as we have
    some data, it will render a table showing the data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有任何预报，它将显示“加载中...”，一旦我们有了数据，它将渲染一个显示数据的表格。
- en: 'The code section that generates some mock data looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一些模拟数据的代码部分看起来像这样：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the page is initialized, the `WeatherForecast` array is filled with random
    data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面初始化时，`WeatherForecast` 数组会被填充随机数据。
- en: This reminds me that someone (as a joke) added a bug report to one of Dan Roth’s
    repos on GitHub, reporting “Weather forecast is unreliable.”
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起有人（作为玩笑）向 Dan Roth 在 GitHub 上的一个仓库提交了一个错误报告，报告称“天气预报不可靠。”
- en: 'The conversation continued, “The weather forecast feature was completely accurate
    during my trip to London but has proven to be misleading in California. Counter
    and overall purpleness are great.” With Dan Roth replying: “Thanks for the feedback!
    I’ll get in touch with the folks on the .NET core framework team to make sure
    that `System.Random` does a better job of taking California weather patterns into
    account.”'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对话继续，“在我的伦敦之行中，天气预报功能完全准确，但在加利福尼亚却证明是误导性的。计数和整体紫色很棒。”Dan Roth 回复道：“感谢您的反馈！我会联系
    .NET 核心框架团队，确保 `System.Random` 能更好地考虑加利福尼亚的天气模式。”
- en: This is one of many reasons why I love the .NET community.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我喜欢 .NET 社区的原因之一。
- en: As we can see, by using the Razor syntax, we are seamlessly mixing code with
    HTML. The code checks whether there is any data – if so, it will render the table;
    if not, it will show a loading message. The component will update automatically
    once we have data. We have full control over the HTML, and Blazor will not add
    anything to the generated HTML.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用 Razor 语法，我们可以无缝地将代码与 HTML 混合。代码会检查是否有任何数据——如果有，它将渲染表格；如果没有，它将显示一个加载信息。一旦我们有了数据，组件将自动更新。我们对
    HTML 有完全的控制权，Blazor 不会向生成的 HTML 中添加任何内容。
- en: There are component libraries that can make this process a bit simpler, which
    we will look at in the next chapter, *Chapter 5*, *Creating Advanced Blazor Components*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些组件库可以使这个过程变得简单一些，我们将在下一章，*第五章*，*创建高级 Blazor 组件*中探讨。
- en: Now that we know how the sample template is implemented, it is time to dive
    deeper into the Razor syntax.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了示例模板是如何实现的，是时候深入探讨 Razor 语法了。
- en: Learning Razor syntax
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Razor 语法
- en: One of the things I like about the Razor syntax is that it is easy to mix code
    and HTML tags. By having the code close to the markup, it is, in my opinion, easier
    to follow and understand. The syntax is very fluid; the razor parser understands
    when the code stops and markup begins, which means we don’t need to think about
    it that much. It is also not a new language; instead, we can leverage our existing
    C# and HTML knowledge to create our components. This section will contain a lot
    of theory to help us understand the Razor syntax.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 Razor 语法的其中一个原因是它很容易混合代码和 HTML 标签。由于代码靠近标记，我认为它更容易跟随和理解。语法非常流畅；Razor 解析器理解代码何时停止，标记何时开始，这意味着我们不需要过多地考虑它。它也不是一门新语言；相反，我们可以利用我们现有的
    C# 和 HTML 知识来创建我们的组件。本节将包含大量理论，帮助我们理解 Razor 语法。
- en: 'To transition from HTML to code (C#), we use the `@` symbol. There are a handful
    of ways we can add code to our file, which we’ll explore in the following sections:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 HTML 转换到代码（C#），我们使用 `@` 符号。我们可以用几种方法将代码添加到我们的文件中，我们将在接下来的章节中探讨这些方法：
- en: Razor code blocks
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Razor 代码块
- en: Implicit Razor expressions
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式 Razor 表达式
- en: Explicit Razor expressions
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式 Razor 表达式
- en: Expression encoding
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式编码
- en: Directives
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: Razor code blocks
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razor代码块
- en: 'We have already seen some code blocks. A code block looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些代码块。一个代码块看起来像这样：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we wish, we can skip the `code` keyword like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以省略`code`关键字，如下所示：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside those curly braces, we can mix HTML and code like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些花括号内，我们可以像这样混合HTML和代码：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how the `RenderName()` method transitions from code into the paragraph
    tags and back to code; this is an implicit transition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`RenderName()`方法如何从代码过渡到段落标签，然后再回到代码；这是一个隐式过渡。
- en: 'If we want to output text without having an HTML tag, we can use the `text`
    tag instead of using the paragraph tags, as shown in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要输出没有HTML标签的文本，我们可以使用`text`标签而不是段落标签，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This would render the same result as the previous code but without the paragraph
    tags, and the `text` tag wouldn’t be rendered.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染与之前代码相同的结果，但没有段落标签，并且`text`标签不会被渲染。
- en: Implicit Razor expressions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式Razor表达式
- en: '**Implicit Razor expressions** are when we add code inside HTML tags.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式Razor表达式**是指我们在HTML标签内添加代码。'
- en: 'We have already seen this in the `Weather` example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`Weather`示例中看到了这个：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start with a `<td>` tag, then use the `@` symbol to switch to C#, and switch
    back to HTML with the end tag. We can use the `await` keyword together with a
    method call, but other than that, implicit Razor expressions cannot contain any
    spaces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个`<td>`标签开始，然后使用`@`符号切换到C#，再使用结束标签切换回HTML。我们可以将`await`关键字与方法调用一起使用，但除此之外，隐式Razor表达式不能包含任何空格。
- en: We cannot call a generic method using implicit expressions since `<>` would
    be interpreted as HTML. Hence, to solve this issue, we can use explicit expressions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`<>`会被解释为HTML，因此我们不能使用隐式表达式调用泛型方法。因此，为了解决这个问题，我们可以使用显式表达式。
- en: Explicit Razor expressions
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式Razor表达式
- en: 'We can use explicit Razor expressions if we want to use spaces in the code.
    Write the code with the `@` symbol followed by parentheses `( )`. So, it would
    look like this: `@()`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在代码中使用空格，我们可以使用显式Razor表达式。用`@`符号后跟括号`()`编写代码。所以，它看起来像这样：`@()`。
- en: 'In this sample, we subtract `7` days from the current date:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们从当前日期减去`7`天：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also use explicit Razor expressions to concatenate text; for example,
    we can concatenate text and code like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用显式Razor表达式来连接文本；例如，我们可以像这样连接文本和代码：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output would then be `<td>Temp42</td>`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果将是 `<td>Temp42</td>`。
- en: 'Using explicit expressions, we can easily call generic methods by using this
    syntax:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式表达式，我们可以通过使用此语法轻松调用泛型方法：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Razor engine knows whether we are using code or not. It also makes sure
    to encode strings to HTML when outputting it to the browser, called **expression
    encoding**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Razor引擎知道我们是否在使用代码。它还确保在输出到浏览器时将字符串编码为HTML，这被称为**表达式编码**。
- en: Expression encoding
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式编码
- en: 'If we have HTML as a string, it will be escaped by default. Take this code,
    for example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将HTML作为字符串，它默认会被转义。以下代码为例：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The rendered HTML would look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的HTML将看起来像这样：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To output the actual HTML from a string (something we will do later, in *Chapter
    5*, *Creating Advanced Blazor Components*), you can use this syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串输出实际的HTML（我们将在第5章*创建高级Blazor组件*中这样做），可以使用以下语法：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using `MarkupString`, the output will be HTML, showing the HTML tag span. In
    some cases, one line of code isn’t enough; then, we can use code blocks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MarkupString`，输出将是HTML，显示HTML标签`span`。在某些情况下，一行代码不够；然后，我们可以使用代码块。
- en: Directives
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令
- en: There are a bunch of directives that change the way a component gets parsed
    or can enable functionality. These are reserved keywords that follow the `@` symbol.
    We will go through the most common and useful ones.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多指令会改变组件的解析方式或启用功能。这些是跟随`@`符号的保留关键字。我们将介绍最常见和最有用的几个。
- en: I find that it is pretty nice to have the layout and the code inside of the
    same `.razor` file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现将布局和代码放在同一个`.razor`文件中非常方便。
- en: Note that we can use code-behind to write our code to get a bit more separation
    between the code and layout. Later in this chapter, we will look at how to use
    code-behind instead of Razor syntax for everything. For now, the following examples
    will look at how we would do the same directives using both Razor syntax and code-behind.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用代码隐藏来编写我们的代码，以便在代码和布局之间获得更多的分离。在本章的后面部分，我们将探讨如何使用代码隐藏而不是Razor语法来完成所有操作。现在，以下示例将展示如何使用Razor语法和代码隐藏来完成相同的指令。
- en: Adding an attribute
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加属性
- en: 'To add an attribute to our page, we can use the `attribute` directive:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的页面添加属性，我们可以使用`attribute`指令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we were using a code-behind file, we would use the following syntax instead:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是代码后端文件，我们将使用以下语法：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding an interface
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加接口
- en: 'To implement an interface (`IDisposable` in this case), we would use the following
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现接口（在这种情况下为`IDisposable`），我们会使用以下代码：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, we would implement the methods the interface needs in a `@code{}` section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在`@code{}`部分实现接口所需的方法。
- en: 'To do the same in a code-behind scenario, we would add the interface after
    the class name, as shown in the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码后端场景中执行相同操作时，我们会在类名后添加接口，如下例所示：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inheriting
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: 'To inherit another class, we should use the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要继承另一个类，我们应该使用以下代码：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To do the same in a code-behind scenario, we would add the class we want to
    inherit from after the class name:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码后端场景中执行相同操作时，我们会在类名后添加我们想要继承的类：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generics
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: We can define our component as a generic component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的组件定义为泛型组件。
- en: Generics allow us to define the data type, so the component works with any data
    type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许我们定义数据类型，因此组件可以与任何数据类型一起工作。
- en: 'To define a component as a generic component, we add the `@typeparam` directive;
    then, we can use the type in the code of the component like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要将组件定义为泛型组件，我们添加`@typeparam`指令；然后，我们可以在组件的代码中使用该类型，如下所示：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Generics are super-powerful when creating reusable components; this will make
    our components reusable for different data types. We will return to generics in
    *Chapter 6*, *Building Forms with Validation*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型在创建可重用组件时非常强大；这将使我们的组件对不同数据类型可重用。我们将在*第6章*，*使用验证构建表单*中回到泛型。
- en: Changing the layout
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改布局
- en: 'If we want to have a specific layout for a page (not the default one specified
    in the `Routes.razor` file), we can use the `@layout` directive:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为页面设置特定的布局（不是在`Routes.razor`文件中指定的默认布局），我们可以使用`@layout`指令：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This way, our component will use the specified layout (this only works for components
    with the `@page` directive).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的组件将使用指定的布局（这仅适用于具有`@page`指令的组件）。
- en: Setting a namespace
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置命名空间
- en: 'By default, the component’s namespace will be the name of the default namespace
    of our project, plus the folder structure. If we want our component to be in a
    specific namespace, we can use the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，组件的命名空间将是我们的项目默认命名空间加上文件夹结构。如果我们想让我们的组件位于特定的命名空间中，我们可以使用以下方法：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Setting a route
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置路由
- en: 'We have already touched on the `@page` directive. If we want our component
    to be directly accessed using a URL, we can use the `@page` directive:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了`@page`指令。如果我们想让我们的组件可以通过URL直接访问，我们可以使用`@page`指令：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The URL can contain parameters, subfolders, and much more, which we will return
    to later in this chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: URL可以包含参数、子文件夹等等，我们将在本章后面回到这一点。
- en: Adding a using statement
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加使用语句
- en: 'To add a namespace to our component, we can use the `@using` directive:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的组件添加命名空间，我们可以使用`@using`指令：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If there are namespaces that we use in several of our components, then we can
    add them to the `_Imports.razor` file instead. This way, they will be available
    in all the components we create.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在多个组件中使用相同的命名空间，那么我们可以将它们添加到`_Imports.razor`文件中。这样，它们将可用在我们创建的所有组件中。
- en: 'If you want to dive further into directives, you can find more information
    here: [https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives](https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步了解指令，你可以在这里找到更多信息：[https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives](https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives)
- en: Now we know more about how Razor syntax works. Don’t worry; we will have plenty
    of time to practice it. There is one more directive that I haven’t covered in
    this section, and that is `inject`. We first need to understand what **Dependency
    Injection** (**DI**) is and how it works, which we will see in the next section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Razor语法的运作方式有了更多的了解。不用担心；我们将有足够的时间来练习它。本节还有一个我没有涵盖的指令，那就是`inject`。我们首先需要了解**依赖注入**（DI）是什么以及它是如何工作的，这将在下一节中展示。
- en: Understanding dependency injection
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖注入
- en: DI is a software pattern and a technique to implement **Inversion of Control**
    (**IoC**).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是一种软件模式和实现**控制反转**（IoC）的技术。
- en: IoC is a generic term that means we can indicate that the class needs a class
    instance instead of letting our classes instantiate an object. We can say that
    our class wants either a specific class or a specific interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: IoC 是一个通用术语，意味着我们可以表明类需要一个类实例，而不是让我们的类实例化一个对象。我们可以说我们的类想要一个特定的类或一个特定的接口。
- en: The creation of the class is somewhere else, and it is up to IoC what class
    it will create.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类的创建在其他地方，IoC 决定它将创建哪个类。
- en: When it comes to DI, it is a form of IoC when an object (class instance) is
    passed through constructors, parameters, or service lookups.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 DI 时，如果对象（类实例）通过构造函数、参数或服务查找传递，它是一种 IoC 的形式。
- en: 'Here is a great resource if you want to dive deeper into DI in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解 .NET 中的 DI，这是一个很好的资源：[https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)。
- en: 'In Blazor, we can configure DI by providing a way to instantiate an object;
    this is a key architecture pattern that we should use. We have already seen a
    couple of references to it, for example, in `Program.cs`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 中，我们可以通过提供一种实例化对象的方法来配置 DI；这是一个我们应该使用的核心架构模式。我们已经看到一些关于它的引用，例如在 `Program.cs`
    中：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we say that if any class wants `IBlogApi`, the application should instantiate
    an object of the `BlogApiJsonDirectAccess` type. In this case, we are using an
    interface; instead, we could just say:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们说如果任何类需要 `IBlogApi`，应用程序应该实例化一个 `BlogApiJsonDirectAccess` 类型的对象。在这种情况下，我们使用了一个接口；相反，我们可以说：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, when we ask for a `BlogApiJsonDirectAccess` object, it will return
    an object of that type. If there only is one implementation of the thing we are
    building, there is no reason to create an interface for it. In the previous chapter,
    *Chapter 3*, *Managing State – Part 1*. We created an `IBlogApi` interface that
    returned an instance of `BlogApiJsonDirectAccess`. When we implement the WebAssembly
    version, DI will return another class instead.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们请求一个 `BlogApiJsonDirectAccess` 对象时，它将返回该类型的对象。如果我们所构建的东西只有一个实现，就没有必要为它创建一个接口。在上一章，*第3章*，*管理状态
    – 第1部分*。我们创建了一个 `IBlogApi` 接口，它返回一个 `BlogApiJsonDirectAccess` 的实例。当我们实现 WebAssembly
    版本时，DI 将返回另一个类。
- en: There are many advantages to using DI. Our dependencies are loosely coupled,
    so we don’t instantiate another class in our class. Instead, we ask for an instance,
    which makes it easier to write tests and change implementations depending on platforms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DI 有许多优点。我们的依赖关系是松散耦合的，所以我们不需要在我们的类中实例化另一个类。相反，我们请求一个实例，这使得编写测试和根据平台更改实现变得更加容易。
- en: Any external dependencies will be much more apparent since we must pass them
    into the class. We also can set the way we should instantiate the object in a
    central place. We configure the DI in `Program.cs`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 任何外部依赖都将更加明显，因为我们必须将它们传递到类中。我们还可以在中心位置设置我们应该如何实例化对象。我们在 `Program.cs` 中配置 DI。
- en: 'We can configure the creation of objects in different ways, such as the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以不同的方式配置对象的创建，例如以下几种：
- en: Singleton
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Scoped
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域
- en: Transient
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时
- en: Singleton
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: When we use a singleton, the object will be the same for all site users. The
    object will only be created once.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用单例时，对象将对所有网站用户都是相同的。对象只创建一次。
- en: 'To configure a singleton service, use the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置单例服务，请使用以下方法：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We should use a singleton when we want to share our object with all the users
    of our site, but beware because since the state is shared, it can lead to issues
    if the object stores data specific to an individual user or a session because
    once this data is changed by one user, the change is reflected for all users who
    might be using the application simultaneously. It may also lead to data being
    shared unintentionally.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要与我们的网站所有用户共享对象时，应该使用单例，但要注意，由于状态是共享的，如果对象存储了特定于单个用户或会话的数据，可能会导致问题，因为一旦这些数据被一个用户更改，更改将反映给所有可能同时使用应用程序的用户。这也可能导致数据无意中共享。
- en: Scoped
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: When we use scoped, a new object will be created once for each connection, and
    since Blazor Server needs a connection to work, it will be the same object as
    long as the user has a connection. WebAssembly does not have the concept of scoped,
    since there is no connection, so all the code runs inside the user’s web browser.
    If we use scoped, it will work the same way as a singleton for Blazor WebAssembly,
    since we only have one user and everything is running inside the browser. The
    recommendation is still to use scoped if the idea is to scope a service to the
    current user. This makes it easier to move code between Blazor Server and Blazor
    WebAssembly and gives a bit more context on how the service is supposed to be
    used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 scoped 时，每个连接都会创建一个新的对象，由于 Blazor Server 需要连接来工作，所以只要用户有连接，它就会是同一个对象。WebAssembly
    没有scoped的概念，因为没有连接，所以所有代码都在用户的网页浏览器内运行。如果我们使用 scoped，它将以与 Blazor WebAssembly 中的
    singleton 相同的方式工作，因为我们只有一个用户，所有内容都在浏览器内运行。建议如果想要将服务范围限定在当前用户，仍然使用 scoped。这使得在
    Blazor Server 和 Blazor WebAssembly 之间移动代码变得更加容易，并且对服务应该如何使用提供了更多上下文。
- en: 'To configure a scoped service, use the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置一个 scoped 服务，请使用以下方法：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We should use scoped if we have data that belongs to the user. We can keep the
    user’s state by using scoped objects. More on that in *Chapter 11*, *Managing
    State – Part 2*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有属于用户的数据，我们应该使用 scoped 对象来保持用户的状态。更多关于这一点的内容在 *第 11 章*，*管理状态 – 第 2 部分*。
- en: It’s worth mentioning here that the new “per component” model will create a
    SignalR connection if there is any component currently running in InteractiveServer
    mode. If we navigate to a new page without any `InteractiveServer` components,
    the connection will eventually be disconnected. This means that the state will
    also be removed. So, when using the “per component” model, we need to make sure
    not to save any important information in a scoped variable unless we persist it
    in some other way as well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得提一下，新的“按组件”模型会在任何组件当前以 InteractiveServer 模式运行时创建一个 SignalR 连接。如果我们导航到一个没有
    `InteractiveServer` 组件的新页面，连接最终会被断开。这意味着状态也会被移除。因此，当使用“按组件”模型时，我们需要确保不要在 scoped
    变量中保存任何重要信息，除非我们以其他方式持久化它。
- en: Transient
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Transient
- en: When we use transient, a new object will be created every time we ask for it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 transient 时，每次请求都会创建一个新的对象。
- en: 'To configure a transient service, use the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置一个 transient 服务，请使用以下方法：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can use transient if we don’t need to keep any state, and we don’t mind the
    object being created every time we ask for it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要保持任何状态，并且不介意每次请求时对象都被创建，我们可以使用 transient。
- en: Now that we know how to configure a service, we need to start using the service
    by injecting it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何配置服务，我们需要开始使用服务，通过注入它。
- en: Injecting the service
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入服务
- en: 'There are three ways to inject a service. We can use the `@inject` directive
    in the Razor file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式可以注入服务。我们可以在 Razor 文件中使用 `@inject` 指令：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will make sure we have access to `WeatherForecastService` in our component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们可以在组件中访问 `WeatherForecastService`。
- en: 'The second way is to create a property by adding the `Inject` attribute if
    we are using code-behind:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是在使用代码隐藏时通过添加 `Inject` 属性来创建一个属性：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The third way is for when we want to inject a service into another service
    – then, we need to inject the services using the constructor:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方式是在我们想要将服务注入到另一个服务时——这时，我们需要通过构造函数注入服务：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we know how DI works and why we should use it. In .NET 7, using a scoped
    service meant that the data was accessible as long as the connection (or circuit)
    was active. But with .NET 8, it changes just slightly depending on the render
    mode. Let’s look at that next.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了依赖注入的工作原理以及为什么我们应该使用它。在 .NET 7 中，使用 scoped 服务意味着只要连接（或电路）是活跃的，数据就可以访问。但到了
    .NET 8，它根据渲染模式略有变化。让我们接下来看看这一点。
- en: Changing the render mode
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变渲染模式
- en: The biggest change when it comes to .NET 8 is the ability to change render mode
    in the same app. In .NET 7, we had to choose one or the other, but with .NET 8,
    we can change it as we see fit. Perhaps if a specific page is not interactive,
    we can use the new **Server-Side Rendering** (**SSR**). This is very similar to
    WebForms or MVC. The page gets rendered on the server. No additional interactivity
    will work. We can set the render mode on each component, or we can do it when
    we use the component. When we create the project, we select what interactive render
    mode we want.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 .NET 8 时，最大的变化是能够在同一应用程序中更改渲染模式。在 .NET 7 中，我们必须选择一个或另一个，但使用 .NET 8，我们可以根据需要更改它。也许如果某个页面没有交互性，我们可以使用新的
    **服务器端渲染**（**SSR**）。这与 WebForms 或 MVC 非常相似。页面在服务器上渲染。没有额外的交互性将工作。我们可以在每个组件上设置渲染模式，或者在我们使用组件时进行设置。当我们创建项目时，我们选择我们想要的交互式渲染模式。
- en: 'Let’s take a look at the different options:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的选项：
- en: '**None** – No interactivity, only static rendered files, no SignalR, and no
    WebAssembly. Using this option, we can use both static SSR and streaming server-side
    rendering.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无** – 没有交互性，只有静态渲染文件，没有 SignalR 和 WebAssembly。使用此选项，我们可以使用静态 SSR 和流式服务器端渲染。'
- en: '**Server** – This will give us access to interactivity using Blazor Server,
    not WebAssembly.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器** – 这将使我们能够通过 Blazor 服务器使用交互性，而不是 WebAssembly。'
- en: '**WebAssembly** – This will give us access to interactivity using Blazor WebAssembly,
    not Blazor Server.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebAssembly** – 这将使我们能够通过 Blazor WebAssembly 使用交互性，而不是 Blazor 服务器。'
- en: '**Auto** (Server and WebAssembly) – Gives us the ability to use both Server
    and WebAssembly.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动**（服务器和 WebAssembly）- 允许我们同时使用服务器和 WebAssembly。'
- en: 'We also set **Interactivity location** to **Per page/component**, which means
    that the default behavior of the site is static, and we need to specify on each
    component if we want to use interactivity. We can also set it to **Global**, which
    will set the interactivity on the `Routes` component like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 **交互位置** 设置为 **每页/组件**，这意味着网站的默认行为是静态的，并且我们需要在每个组件上指定是否要使用交互性。我们也可以将其设置为
    **全局**，这将像这样在 `Routes` 组件上设置交互性：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To change the render mode per component, we can use the syntax above or use
    the attribute we saw in the Counter component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个组件更改渲染模式，我们可以使用上面的语法或使用我们在 Counter 组件中看到的属性：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By default, all components are rendered using server pre-rendering. This means
    that the component is first rendered on the server and then pushed to the web
    browser. SignalR or WebAssembly starts up, and the component is rendered again,
    making additional calls to the database, for example. I personally rarely use
    server pre-rendering. I like that the pages load by first sending what the server
    has ready and then, when database calls are done, sends the rest. We can also
    disable pre-rendering by doing it like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有组件都使用服务器预渲染。这意味着组件首先在服务器上渲染，然后推送到网页浏览器。SignalR 或 WebAssembly 启动，组件再次渲染，例如，对数据库进行额外的调用。我个人很少使用服务器预渲染。我喜欢页面首先发送服务器准备好的内容，然后，当数据库调用完成后，发送剩余的内容。我们也可以通过这样做来禁用预渲染：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We will have plenty of time to learn more about render modes during the course
    of the book. In .NET 7, we had more templates, but by using combinations of these
    settings, we can create the same scenarios.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的学习过程中，我们将有足够的时间学习更多关于渲染模式的知识。在 .NET 7 中，我们有更多的模板，但通过使用这些设置的组合，我们可以创建相同的场景。
- en: '| .NET 7 Template | .NET 8 Template | Interactive render mode | Interactivity
    location |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| .NET 7 模板 | .NET 8 模板 | 交互式渲染模式 | 交互位置 |'
- en: '| Blazor Server App | Blazor Web App | Server | Global |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Blazor 服务器应用程序 | Blazor Web 应用程序 | 服务器 | 全局 |'
- en: '| Blazor WebAssembly App | Blazor WebAssembly Standalone App |  |  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| Blazor WebAssembly 应用程序 | Blazor WebAssembly 独立应用程序 |  |  |'
- en: '| Blazor WebAssembly (ASP.NET Core Hosted) | Blazor Web App | WebAssembly |
    Global |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| Blazor WebAssembly (ASP.NET Core 托管) | Blazor Web 应用程序 | WebAssembly | 全局
    |'
- en: If you are new to Blazor, this table has no significance, but if you have worked
    with Blazor in .NET 7 and want to use a project template that you have used in
    .NET 7, this is how to do it. In this chapter, we have mentioned code-behind a
    couple of times. In the next section, we will look at how we can use code-behind
    with Razor files and skip the Razor files altogether.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触 Blazor，这个表格没有意义，但如果你在 .NET 7 中使用过 Blazor，并想使用你在 .NET 7 中使用的项目模板，这是如何操作的。在本章中，我们提到了几次代码后置。在下一节中，我们将探讨如何使用代码后置与
    Razor 文件一起使用，并完全跳过 Razor 文件。
- en: Figuring out where to put the code
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定代码放置的位置
- en: We have seen examples of writing code directly in the Razor file. I prefer doing
    that unless the code gets too long or too complicated. I always lean in favor
    of readability.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在Razor文件中直接编写代码的示例。除非代码变得过长或过于复杂，否则我更喜欢这样做。我总是倾向于可读性。
- en: 'There are four ways we can write our components:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四种编写组件的方法：
- en: In the Razor file
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Razor文件中
- en: In a partial class
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部分类中
- en: Inheriting a class
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承一个类
- en: Only code
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有代码
- en: Let’s go through each item on this list in more detail.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看这个列表上的每一项。
- en: In the Razor file
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Razor文件中
- en: If we are writing a file that is not that complex, it would be nice not to switch
    files when writing components. As we already covered in this chapter, we can use
    the `@code` directive to add code directly to our Razor file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写一个不太复杂的文件，那么在编写组件时不需要切换文件会很好。正如我们在本章中已经讨论过的，我们可以使用`@code`指令直接将代码添加到我们的Razor文件中。
- en: If we want to move the code to a code-behind file, then it is only the directives
    that we need to change. For the rest of the code, we can just move to the code-behind
    class. When I started with Blazor, writing code and markup in the same file felt
    strange, coming from an MVC world where the separation between code and markup
    is a big part of the way to use MVC. But I suggest you try it out when developing
    your web apps.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将代码移动到后置代码文件中，那么我们只需要更改指令。对于其余的代码，我们只需将其移动到后置代码类中。当我刚开始使用Blazor时，由于来自MVC世界，其中代码和标记的分离是使用MVC方式的一个重要部分，所以将代码和标记写在同一文件中感觉有些奇怪。但我建议你在开发你的Web应用时尝试一下。
- en: At work, we started using code-behind but switched to writing code in the `.razor`
    file instead, and we haven’t looked back since.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作中，我们开始使用后置代码，但后来改为在`.razor`文件中编写代码，并且从那时起就没有回头了。
- en: However, many developers prefer code-behind, separating code from the layout.
    For that, we can use a partial class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多开发者更喜欢后置代码，将代码与布局分离。为此，我们可以使用部分类。
- en: In a partial class
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在部分类中
- en: We can create a partial class with the same filename as the Razor file and add
    `.cs`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个与Razor文件同名的部分类，并添加`.cs`扩展名。
- en: If you have downloaded the source code (or you can check the code on GitHub),
    you can look at `WeatherCodeBehind.razor.cs` in the `Examples` folder. I have
    moved all the code to the code-behind file; the result when compiling this will
    be the same as if we kept the code in the Razor file. It is just a matter of preference.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经下载了源代码（或者你可以在GitHub上查看代码），你可以在`Examples`文件夹中查看`WeatherCodeBehind.razor.cs`。我已经将所有代码移动到后置代码文件中；编译此代码的结果将与我们保留代码在Razor文件中相同。这只是一种个人偏好的问题。
- en: 'The code-behind looks like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 后置代码看起来像这样：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we are using a partial class, there is no need to connect the razor with
    the code-behind. If it has the same name, it will just work. We can mix where
    we put the code; in this case, we have the `StreamingRendering` attribute in the
    code-behind, and we can keep it in the `.razor` file if we want to. If you prefer
    using code-behind, this is the way you want to do it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用部分类，因此不需要将razor与后置代码连接起来。如果它们具有相同的名称，它们将正常工作。我们可以混合放置代码的位置；在这种情况下，我们在后置代码中有`StreamingRendering`属性，如果我们想的话，我们也可以将其保留在`.razor`文件中。如果你更喜欢使用后置代码，这就是你想要的方式。
- en: This is not the only way to use a code-behind file; we can also inherit from
    a code-behind file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是使用后置代码文件的唯一方法；我们还可以从后置代码文件中继承。
- en: Inheriting a class
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承一个类
- en: We can also create a completely different class (the common pattern is to call
    it the same thing as the Razor file and add `Model` at the end) and inherit it
    in our Razor file. For that to work, we need to inherit from `ComponentBase`.
    In the case of a partial class, the class already inherits from `ComponentBase`,
    since the Razor file does that.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个完全不同的类（常见的模式是将它与Razor文件同名，并在末尾添加`Model`），并在我们的Razor文件中继承它。为了使其工作，我们需要从`ComponentBase`继承。在部分类的情况下，类已经从`ComponentBase`继承，因为Razor文件会这样做。
- en: Fields must be protected or public (not private) for the page to access the
    fields. I recommend using the partial class if we don’t need to inherit from our
    base class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 字段必须是受保护的或公共的（不是私有的），以便页面可以访问这些字段。如果我们不需要从我们的基类继承，我建议使用部分类。
- en: 'This is a snippet of the code-behind class declaration:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是后置代码类声明的代码片段：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ll need to inherit from `ComponentBase` or from a class that inherits from
    `ComponentBase`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`ComponentBase`或从继承自`ComponentBase`的类继承。
- en: 'In the Razor file, we will use the `@inherits` directive:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在Razor文件中，我们将使用`@inherits`指令：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Razor file will now inherit from our code-behind class (this was the first
    way available to create code-behind classes).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Razor文件将继承自我们的代码隐藏类（这是创建代码隐藏类的第一种可用方法）。
- en: Both the partial and inherit options are simple ways of moving the code to a
    code-behind file. Inheriting a model was the first available way, but as I mentioned,
    use partial classes instead if you prefer code-behind. But another option is to
    skip the Razor file and use only code entirely.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 部分和继承选项都是将代码移动到代码隐藏文件中的简单方法。继承模型是第一种可用的方法，但如我所述，如果你更喜欢代码隐藏，请使用部分类。但另一个选项是跳过Razor文件，完全使用代码。
- en: Only code
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只有代码
- en: Visual Studio will use source generators to convert the Razor code into C#.
    We will dig deeper into source generators in *Chapter 17*, *Examining Source Generators*.
    The Razor file will generate code at compile time. We can skip the Razor step
    if we want to and write our layout completely in code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio将使用源生成器将Razor代码转换为C#。我们将在第17章“检查源生成器”中深入了解源生成器。Razor文件将在编译时生成代码。如果我们想的话，可以跳过Razor步骤，完全用代码编写布局。
- en: This file (`CounterWithoutRazor.cs`) is available on GitHub.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件（`CounterWithoutRazor.cs`）可在GitHub上找到。
- en: 'The counter example would look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 反例看起来可能如下所示：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The Razor file will first be converted into something roughly the same as the
    previous code, and then the code is compiled. It adds the elements one by one,
    which, in the end, will render the HTML.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Razor文件首先会被转换成与之前代码大致相同的东西，然后代码被编译。它逐个添加元素，最终将渲染HTML。
- en: The numbers in the code are how Blazor keeps track of each element in the render
    tree. Some prefer to write the code as in the previous code block rather than
    using the Razor syntax; there are even efforts in the community to simplify the
    process of manually writing the `BuildRenderTree()` function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的数字是Blazor跟踪渲染树中每个元素的方式。有些人更喜欢像上一个代码块那样编写代码，而不是使用Razor语法；社区中甚至有简化手动编写`BuildRenderTree()`函数过程的努力。
- en: Some of Microsoft’s built-in components are built in this way.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的一些内置组件就是这样构建的。
- en: I recommend never writing this manually, but I’ve kept it in the book because
    it shows how Razor files get compiled. Now that we know how to use code-behind,
    let’s look at the lifecycle events of Blazor and when they get executed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议永远不要手动编写这个方法，但我将它保留在书中，因为它展示了Razor文件是如何被编译的。现在我们已经知道了如何使用代码隐藏，让我们来看看Blazor的生命周期事件以及它们何时被调用。
- en: Lifecycle events
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期事件
- en: We can use a couple of lifecycle events to run our code. In this section, we
    will go through them and see when we should use them. Most lifecycle events have
    two versions – synchronous and asynchronous.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些生命周期事件来运行我们的代码。在本节中，我们将逐一介绍它们，并了解何时应该使用它们。大多数生命周期事件都有两个版本——同步和异步。
- en: OnInitialized and OnInitializedAsync
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnInitialized 和 OnInitializedAsync
- en: The first time the component is loaded, `OnInitialized()` is called, then `OnInitializedAsync()`.
    This is a great method to load any data, as the UI has not yet been rendered.
    If we are doing long-running tasks (such as getting data from a database), we
    should put that code in the `OnInitializedAsync()` method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 组件第一次加载时，会调用`OnInitialized()`，然后是`OnInitializedAsync()`。这是一个加载任何数据的绝佳方法，因为此时UI尚未渲染。如果我们正在进行长时间运行的任务（例如从数据库获取数据），我们应该将那段代码放在`OnInitializedAsync()`方法中。
- en: These methods will only run once. If you want to update the UI when a parameter
    changes, see `OnParametersSet()` and `OnParametersSetAsync()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法只会运行一次。如果你想在参数更改时更新UI，请参阅`OnParametersSet()`和`OnParametersSetAsync()`。
- en: OnParametersSet and OnParametersSetAsync
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnParametersSet 和 OnParametersSetAsync
- en: '`OnParametersSet()` and `OnParametersSetAsync()` are called when the component
    is initialized (after `OnInitialized()` and `OnInitializedAsync()`) and whenever
    we change the value of a parameter.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件初始化时（在`OnInitialized()`和`OnInitializedAsync()`之后）以及每次我们更改参数值时，都会调用`OnParametersSet()`和`OnParametersSetAsync()`。
- en: If we, for example, load data in the `OnInitialized()` method but it uses a
    parameter, the data won’t be reloaded if the parameter is changed since `OnInitialized()`
    will only run once. We need to trigger a reload of the data in `OnParametersSet()`
    or `OnParametersSetAsync()` or move the loading to that method.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用`OnInitialized()`方法加载数据，但使用了参数，那么如果参数更改，数据不会重新加载，因为`OnInitialized()`只会运行一次。我们需要在`OnParametersSet()`或`OnParametersSetAsync()`中触发数据的重新加载，或者将加载移动到那个方法。
- en: OnAfterRender and OnAfterRenderAsync
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnAfterRender 和 OnAfterRenderAsync
- en: After the component renders, the `OnAfterRender()` and `OnAfterRenderAsync()`
    methods are called. When the methods are called, all the elements are rendered,
    so if we want/need to call any JavaScript code, we have to do that from these
    methods (we will get an error if we try to make a JavaScript interop from any
    of the other lifecycle event methods). This is a limitation of the prerendering.
    When the component prerenders, there is nothing connected to the web browser,
    and we will not be able to run any JavaScript. However, if we disable the prerendering,
    we can run JavaScript in the other lifecycle methods as well. We also have access
    to a `firstRender` parameter, so we can only run our code on the first render.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 组件渲染完成后，会调用`OnAfterRender()`和`OnAfterRenderAsync()`方法。当这些方法被调用时，所有元素都已渲染，因此如果我们想要/需要调用任何JavaScript代码，我们必须从这些方法中调用（如果我们尝试从任何其他生命周期事件方法中执行JavaScript互操作，将会得到错误）。这是预渲染的限制。当组件预渲染时，没有连接到网络浏览器，我们将无法运行任何JavaScript。然而，如果我们禁用预渲染，我们也可以在其他生命周期方法中运行JavaScript。我们还可以访问`firstRender`参数，因此我们只能在第一次渲染时运行我们的代码。
- en: ShouldRender
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ShouldRender
- en: '`ShouldRender()` is called when our component is re-rendered; if it returns
    `false`, the component will not be rendered again. The component will always render
    once, even if this method returns `false`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的组件重新渲染时，会调用`ShouldRender()`；如果它返回`false`，则组件将不会再次渲染。即使此方法返回`false`，组件也总会渲染一次。
- en: '`ShouldRender()` does not have an asynchronous option.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShouldRender()`没有异步选项。'
- en: Now we know when the different lifecycle events happen and in what order. A
    component can also have parameters, and that way, we can reuse them but with different
    data.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了不同的生命周期事件何时发生以及它们的顺序。组件也可以有参数，这样我们就可以以不同的数据重用它们。
- en: Parameters
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'A parameter makes it possible to send a value to a component. To add a parameter
    to a component, we use the `[Parameter]` attribute on the `public` property:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 参数使得将值发送到组件成为可能。要向组件添加参数，我们使用`public`属性上的`[Parameter]`属性：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The syntax for this is the same if we use a code-behind file. We can add a
    parameter to the route using the `@page` directive by specifying it in the route:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用代码后文件，此语法是相同的。我们可以通过在路由中指定它来使用`@page`指令将参数添加到路由中：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case, we have to have a parameter specified with the same name as the
    name inside the curly braces. To set the parameter in the `@page` directive, we
    go to `/parameterdemo/THEVALUE`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须指定一个与花括号内名称相同的参数。要在`@page`指令中设置参数，我们前往`/parameterdemo/THEVALUE`。
- en: 'There are cases where we want to specify another type instead of a string (string
    is the default). We can add the data type after the parameter name like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想要指定另一种类型而不是字符串（字符串是默认类型）。我们可以在参数名称后添加数据类型，如下所示：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will match the route only if the data type is an integer. We can also pass
    parameters using cascading parameters. We can also have more than one page directive
    per component if we want to handle more than one route.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当数据类型是整数时，这才会匹配路由。我们还可以使用级联参数传递参数。如果我们想要处理多个路由，我们可以在组件中拥有多个页面指令。
- en: Cascading parameters
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级联参数
- en: If we want to pass a value to multiple components, we can use a cascading parameter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将一个值传递给多个组件，我们可以使用级联参数。
- en: 'Instead of using `[Parameter]`, we can use `[CascadingParameter]` like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`[Parameter]`，我们可以使用`[CascadingParameter]`，如下所示：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To pass a value to the component, we surround it with a `CascadingValue` component
    like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值传递给组件，我们用`CascadingValue`组件将其包围，如下所示：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`CascadingValue` is the value we pass to the component, and `CascadingParameter`
    is the property that receives the value.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingValue`是我们传递给组件的值，而`CascadingParameter`是接收该值的属性。'
- en: 'As we can see, we don’t pass any parameter values to the `ComponentWithCascadingParameter`
    component; the cascading value will match the parameter with the same data type.
    If we have multiple parameters of the same type, we can specify the name of the
    parameter in the component with the cascading parameter like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们没有向`ComponentWithCascadingParameter`组件传递任何参数值；级联值将与相同数据类型的参数匹配。如果我们有多个相同类型的参数，我们可以在具有级联参数的组件中指定参数的名称，如下所示：
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can also do so for the component that passes `CascadingValue`, like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为传递`CascadingValue`的组件这样做，如下所示：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we know that the value won’t change, we can specify that by using the `IsFixed`
    property:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道值不会改变，我们可以通过使用`IsFixed`属性来指定这一点：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This way, Blazor won’t look for changes, which is more efficient if we know
    the values won’t change. The cascading values/parameters cannot be updated upward
    but are updated only downward. This means that to update a cascading value, we
    need to implement it in another way; updating it from inside the component won’t
    change any components that are higher in the hierarchy.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Blazor 就不会寻找更改，如果我们知道值不会改变，这会更高效。级联值/参数不能向上更新，只能向下更新。这意味着要更新级联值，我们需要以另一种方式实现它；在组件内部更新它不会改变任何在层次结构中更高的组件。
- en: In *Chapter 5*, *Creating Advanced Blazor Components*, we will look at events,
    which are one way to solve the problem of updating a cascading value.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第5章*，*创建高级 Blazor 组件* 中，我们将探讨事件，这是解决更新级联值问题的一种方式。
- en: Phew! This has been an information-heavy chapter, but now we know the basics
    of Blazor components. Now, it is time to build one!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁！这一章信息量很大，但现在我们知道了 Blazor 组件的基础知识。现在，是时候构建一个组件了！
- en: Writing our first component
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个组件
- en: The first component we will build shows all the blog posts on a site. To be
    fair, we haven’t written any blog posts yet, but we will temporarily solve that
    so we can start doing something fun.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的第一个组件将显示网站上所有的博客文章。公平地说，我们还没有写过任何博客文章，但我们将暂时解决这个问题，以便我们可以开始做一些有趣的事情。
- en: In *Chapter 3*, *Managing State – Part 1*, we created a JSON repository and
    an API (or interface); now, it is time to use them.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第3章*，*管理状态 – 第1部分* 中，我们创建了一个 JSON 存储库和一个 API（或接口）；现在是时候使用它们了。
- en: We will share the code between the `BlazorWebApp` project and the `BlazorWebApp.Client`
    project. We will even change the implementation of how they run depending on whether
    they run as WebAssembly or not.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `BlazorWebApp` 项目和 `BlazorWebApp.Client` 项目之间共享代码。我们甚至将根据它们是否作为 WebAssembly
    运行来更改它们的实现方式。
- en: There is a whole chapter on sharing (*Chapter 9*, *Sharing Code and Resources*),
    but let’s start now.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 关于共享有一个专门的章节（*第9章*，*共享代码和资源*），但现在我们就开始吧。
- en: Creating a components library
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建组件库
- en: The first thing we need to do is to create a new project and then add our components
    to that project. We could have added the components to the `BlazorWebApp` or the
    `BlazorWebApp.Client` project directly, but this demonstrates how we can build
    reusable components and distribute them as packages later on.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新的项目，然后将我们的组件添加到该项目中。我们本来可以直接将组件添加到 `BlazorWebApp` 或 `BlazorWebApp.Client`
    项目中，但这样做演示了我们可以如何构建可重用组件并在以后将它们作为包分发。
- en: 'To create our first component, follow these instructions:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的第一个组件，请按照以下说明操作：
- en: Right-click on the **MyBlog** solution and select **Add** | **New Project**.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **MyBlog** 解决方案并选择 **添加** | **新建项目**。
- en: Find the template **Razor Class Library** and click **Next**.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到模板 **Razor 类库** 并点击 **下一步**。
- en: Name the project `SharedComponents` and click **Next**.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `SharedComponents` 并点击 **下一步**。
- en: Select **.NET 8.0** and click **Create**.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **.NET 8.0** 并点击 **创建**。
- en: We now have a project called `SharedComponents`, where we can add all the components
    we want to share. Remove `Component1.razor` and `ExampleJsInterop.cs` that are
    created by default.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个名为 `SharedComponents` 的项目，我们可以添加所有我们想要共享的组件。删除默认创建的 `Component1.razor`
    和 `ExampleJsInterop.cs`。
- en: In the `SharedComponents` project, add a project reference to `Data.Models`
    and add the `Nuget` package reference to `Microsoft.AspNetCore.Components.Web`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，添加对 `Data.Models` 的项目引用，并添加对 `Microsoft.AspNetCore.Components.Web`
    的 Nuget 包引用。
- en: We have a new project. This is where we can share components. Right now, we
    don’t have any components to share, but that is what we will do next.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的项目。这是我们分享组件的地方。目前，我们还没有任何可以分享的组件，但这是我们接下来要做的。
- en: Using our components library
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的组件库
- en: We have a nice library, but for our project to trigger when we navigate to a
    route, we need to add additional assemblies to the router.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个很好的库，但为了我们的项目在导航到路由时触发，我们需要向路由器添加额外的程序集。
- en: 'To do that, we need to follow a couple of steps:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要遵循几个步骤：
- en: We already have a Home component in the `BlazorWebApp` project so let’s delete
    that one. In the `Components/Pages` folder, delete the `Home.razor` file.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经在 `BlazorWebApp` 项目中有一个名为 Home 的组件，所以让我们删除它。在 `Components/Pages` 文件夹中，删除
    `Home.razor` 文件。
- en: We need a component to navigate to. In the `SharedComponents` project, in the
    Pages folder, we need to create a new component. You can select the folder or
    project node in the solution explorer and press *Shift* + *F2*, type `Home.razor`,
    and press *Enter*. This is the fastest way to create new components.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个可以导航到的组件。在`SharedComponents`项目中，在`Pages`文件夹中，我们需要创建一个新的组件。您可以在解决方案资源管理器中选择文件夹或项目节点，然后按*Shift*
    + *F2*，输入`Home.razor`，然后按*Enter*。这是创建新组件最快的方法。
- en: In the `BlazorWebApp` project, add a project reference to the `SharedComponents`
    project.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp`项目中，将项目引用添加到`SharedComponents`项目中。
- en: Also in the `BlazorWebApp.Client` project, add a project reference to the `SharedComponents`
    project.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp.Client`项目中，将项目引用添加到`SharedComponents`项目中。
- en: Now, we have access to the shared components in both the WebAssembly project
    (`BlazorWebApp.Client`) and the `BlazorWebProject`. This means that we can run
    any component we put into the shared project (`SharedComponents`) as `InteractiveWebAssembly`
    or `InteractiveServer`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在WebAssembly项目（`BlazorWebApp.Client`）和`BlazorWebProject`中访问共享组件。这意味着我们可以运行我们放入共享项目（`SharedComponents`）中的任何组件，作为`InteractiveWebAssembly`或`InteractiveServer`。
- en: 'Open `Router.razor`. It looks like this:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Router.razor`。它看起来像这样：
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The router defines where to look for components. `AppAssembly` is where it
    will look first. We can also add additional assemblies, and as we can see, we
    already have an additional assembly. We are referencing the `BlazorWebbApp.Client`
    project so that we can pre - render and server render (SignalR) the Counter component.
    But now we want to add an additional assembly. Change the router to this:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由器定义了组件的查找位置。`AppAssembly`是它首先查找的地方。我们还可以添加额外的程序集，正如我们所看到的，我们已经有了一个额外的程序集。我们正在引用`BlazorWebbApp.Client`项目，以便我们可以预渲染和服务器渲染（SignalR）计数器组件。但现在我们想要添加一个额外的程序集。将路由器更改为以下内容：
- en: '[PRE54]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We add the new assembly to additional assemblies. The router will now look for
    components in the `SharedComponents` assembly as well.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将新的程序集添加到额外的程序集中。现在，路由器将同时在`SharedComponents`程序集中查找组件。
- en: 'We also have to add a row in `Program.cs`. In the `BlazorWebApp` project, open
    `Program.cs`. There, you will find these lines:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须在`Program.cs`中添加一行。在`BlazorWebApp`项目中，打开`Program.cs`。在那里，您将找到以下行：
- en: '[PRE55]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We need to add the new assembly there as well, like this:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也需要在那里添加新的程序集，如下所示：
- en: '[PRE56]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We need to add additional assemblies in the `Program.cs` as well to get server-side
    rendering to work. Great! We have all components in a separate library and are
    sharing the components between the `BlazorWebApp` and the `BlazorWebApp.Client`
    projects.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`Program.cs`中添加额外的程序集，以便服务器端渲染能够工作。太好了！我们所有的组件都在一个单独的库中，并且我们在`BlazorWebApp`和`BlazorWebApp.Client`项目之间共享组件。
- en: Creating our own component
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们自己的组件
- en: Now it’s time to start adding our own component!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始添加我们自己的组件了！
- en: 'OK, this is not completely true because we will continue working on `Home.razor`.
    Let’s start by creating a component that lists our blog posts:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不完全正确，因为我们将继续在`Home.razor`上工作。让我们先创建一个列出我们博客文章的组件：
- en: In the `SharedComponents` project, open `Home.razor`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，打开`Home.razor`。
- en: 'Replace the contents of that file with the following code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换该文件的内容：
- en: '[PRE57]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If we start from the top, we can see a page directive. It will ensure that the
    component is shown when the route is “`/`". Then, we have three `@using` directives,
    bringing in the namespaces so we can use them in the Razor file.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们从顶部开始，我们可以看到一个页面指令。它将确保当路由是“`/`”时显示组件。然后，我们有三个`@using`指令，引入了命名空间，这样我们就可以在Razor文件中使用它们。
- en: Then we inject our API (using DI) and name the instance `_api`.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们注入我们的API（使用DI），并将其命名为`_api`。
- en: 'Add a variable that holds all our posts. In the `code` section, add the following:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个变量来保存我们所有的文章。在`code`部分，添加以下内容：
- en: '[PRE58]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, we need to load the data.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要加载数据。
- en: 'To load posts, add the following in the `code` section:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要加载文章，请在`code`部分添加以下内容：
- en: '[PRE59]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, when the page loads, the posts will be loaded as well: `10` posts and
    page `0` (the first page).'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当页面加载时，文章也会被加载：`10`篇文章和页面`0`（第一页）。
- en: 'Under the `@inject` row, add the following code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@inject`行下面，添加以下代码：
- en: '[PRE60]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We add an **Unordered List** (**UL**); inside that, we loop over blog posts
    and show the title.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个**无序列表**（**UL**）；在其中，我们遍历博客文章并显示标题。
- en: Now, we can run the application by pressing *Ctrl* + *F5* (**Debug** | **Start
    Without Debugging**). Make sure you have the `BlazorWebApp` selected as the startup
    project.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过按*Ctrl* + *F5*（**调试** | **不调试启动**）来运行应用程序。确保您已将`BlazorWebApp`选为启动项目。
- en: Since we don’t have any blog posts, this would take us to an empty page. Luckily,
    there is a folder in the repo called `ExampleData`. If you download that, put
    those files in the `Data` folder that we created in *Chapter 3*, *Managing State
    – Part 1*, and reload the web, you should see a couple of posts.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有任何博客文章，这会带我们到一个空页面。幸运的是，在存储库中有一个名为 `ExampleData` 的文件夹。如果你下载它，将这些文件放入我们在
    *第 3 章*，*管理状态 – 第 1 部分* 中创建的 `Data` 文件夹，然后重新加载网页，你应该能看到几篇文章。
- en: Great job, we have created our first component!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，我们创建了我们的第一个组件！
- en: There are a few noteworthy things. The `SharedComponents` project knows nothing
    about the JSON repository implementation and only knows about the `IBlogApi` interface.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点值得注意。`SharedComponents` 项目对 JSON 存储库实现一无所知，只知道 `IBlogApi` 接口。
- en: The `Home` component asks for an instance of `IBlogApi`, and the `BlazorWebApp`
    project knows it should return an instance of `BlogApiJsonDirectAccess`. This
    is one of the things I love about Blazor; we can create components that only consume
    an interface and know nothing about the implementation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home` 组件请求 `IBlogApi` 的一个实例，而 `BlazorWebApp` 项目知道它应该返回 `BlogApiJsonDirectAccess`
    的一个实例。这是我非常喜欢 Blazor 的一个原因；我们可以创建只消费接口而不知道实现细节的组件。'
- en: We will return to this when we implement a web API for WebAssembly in *Chapter
    7*, *Creating an API*.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 7 章*，*创建 API* 中实现 WebAssembly 的 Web API 时回到这一点。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a lot about Razor syntax – something we will use
    throughout the book. We learned about DI, directives, and parameters and, of course,
    created our first component. This knowledge will help us understand how to create
    and reuse components.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了大量的 Razor 语法——这是我们将在整本书中使用的。我们学习了依赖注入（DI）、指令和参数，当然，我们还创建了我们的第一个组件。这些知识将帮助我们理解如何创建和重用组件。
- en: In the next chapter, we will look at more advanced component scenarios.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更多高级组件场景。
