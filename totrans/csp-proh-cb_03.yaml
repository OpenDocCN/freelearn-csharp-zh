- en: Chapter 3. Object-Oriented Programming in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to the foundation of C# and **object-oriented
    programming** (**OOP**). In this chapter, you will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance in C#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using abstraction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging encapsulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing polymorphism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility principle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During your career as a creator of software, you will hear the term OOP many
    times. This design philosophy allows for objects to exist independently and can
    be reused by different sections of code. This is all made possible by what we
    refer to as the four pillars of OOP, namely inheritance, encapsulation, abstraction,
    and polymorphism.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to grasp this, you need to start thinking of objects (which are basically
    instantiated classes) that perform a specific task. Classes need to adhere to
    the SOLID design principle. This principle is explained here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility** **principle** (**SRP**)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov substitution** **principle** (**LSP**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start off with an explanation of the four pillars of OOP, after which
    we will have a look at the SOLID principle in more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance in C#
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, inheritance is usually associated with the end of things.
    In OOP, however, it is associated with the beginning of something new and better.
    When we create a new class, we can take an already existing class and have our
    new class inherit from it. This means that our new object will have all the features
    of the inherited class, as well as the additional features added to the new class.
    This is at the root of inheritance. We call a class that inherits from another
    a derived class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the concept of inheritance, we will create a few classes that
    inherit from another to form new, more feature-rich objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class library by right-clicking on your solution and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_03_01.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter3`:![How to do it…](img/B05391_03_02.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your new class library will be added to your solution with a default name `Class1.cs`,
    which we renamed to `Recipes.cs` in order to distinguish the code properly. You
    can, however, rename your class to whatever you like if it makes more sense to
    you.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To rename your class, simply click on the class name in the **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_03_03.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to confirm the renaming of all references to the
    code element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_03_04.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s create a new class called `SpaceShip`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `SpaceShip` class will contain a few methods that describe the basics of
    a spaceship. Go ahead and add these methods to your `SpaceShip` class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`SpaceShip`类将包含一些描述飞船基本功能的方法。将这些方法添加到你的`SpaceShip`类中：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because the `SpaceShip` class forms part of all other intergalactic vessels,
    it becomes the blueprint for every other vessel.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为`SpaceShip`类是所有其他星际飞船的一部分，它成为了其他所有飞船的蓝图。
- en: 'Next, we want to create a `Destroyer` class. To accomplish this, we will create
    a `Destroyer` class and use a colon after the class name to indicate that we want
    to inherit from another class (the `SpaceShip` class). Therefore, the following
    needs to be added when creating the `Destroyer` class:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建一个`Destroyer`类。为了实现这一点，我们将创建一个`Destroyer`类，并在类名后使用冒号来表示我们想要从另一个类（`SpaceShip`类）继承。因此，在创建`Destroyer`类时需要添加以下内容：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also say that the `Destroyer` class is derived from the `SpaceShip` class.
    The `SpaceShip` class is therefore the base class of all other intergalactic vessels.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以说`Destroyer`类是从`SpaceShip`类派生出来的。因此，`SpaceShip`类是所有其他星际飞船的基类。
- en: 'Next, add a few methods to the `Destroyer` class that are unique to a destroyer.
    These methods belong only to the `Destroyer` class and not to the `SpaceShip`
    class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`Destroyer`类添加一些仅属于驱逐舰的独特方法。这些方法仅属于`Destroyer`类，而不属于`SpaceShip`类：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, create a third class called `Annihilator`. This is the most powerful
    intergalactic vessel and is used to wage war on planets. Let the `Annihilator`
    class inherit from the `Destroyer` class by creating the class and marking it
    as derived from the `Destroyer` class as follows `Annihilator : Destroyer`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，创建一个名为`Annihilator`的第三个类。这是最强大的星际飞船，用于在行星上发动战争。通过创建类并将它标记为从`Destroyer`类派生出来，让`Annihilator`类继承自`Destroyer`类，如下所示`Annihilator
    : Destroyer`：'
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, add a few methods to the `Annihilator` class that only belong to this
    type of `SpaceShip` class:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向`Annihilator`类添加一些仅属于此类飞船的方法：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inside the console application, add a reference to the `Chapter3` class library
    by right-clicking on **References** under the **CodeSamples** project and selecting
    **Add Reference** from the context menu:![How to do it…](img/B05391_03_05.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，通过在**CodeSamples**项目下的**References**上右键单击并从上下文菜单中选择**Add Reference**来添加对`Chapter3`类库的引用：![如何操作…](img/B05391_03_05.jpg)
- en: In the **Reference Manager** window, select the `Chapter3` solution under **Projects**
    | **Solutions**. This will allow you to use the classes we just created in your
    console application:![How to do it…](img/B05391_03_06.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Reference Manager**窗口中，选择**Projects** | **Solutions**下的`Chapter3`解决方案。这将允许你在控制台应用程序中使用我们刚刚创建的类：![如何操作…](img/B05391_03_06.jpg)
- en: What we see now is that when we create a new instance of the `SpaceShip` class,
    only the methods defined in that class are available to us. This is because the
    `SpaceShip` class does not inherit from any other class:![How to do it…](img/B05391_03_07.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们看到的是，当我们创建`SpaceShip`类的新实例时，只有在该类中定义的方法对我们可用。这是因为`SpaceShip`类没有从任何其他类继承：![如何操作…](img/B05391_03_07.jpg)
- en: 'Go ahead and create the `SpaceShip` class with its methods in the console application:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中创建包含其方法的`SpaceShip`类：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will see that these are the only methods available to us when instantiating
    a new instance of this class.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到，这些是我们实例化这个类的新实例时唯一可用的方法。
- en: Next, create a new instance of the `Destroyer` class. You will notice that the
    `Destroyer` class contains more methods than what we defined when we created the
    class. This is because the `Destroyer` class is inheriting the `SpaceShip` class
    and therefore inherits the methods of the `SpaceShip` class:![How to do it…](img/B05391_03_08.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`Destroyer`类的新实例。你会注意到`Destroyer`类包含的方法比我们在创建类时定义的方法要多。这是因为`Destroyer`类继承了`SpaceShip`类，因此继承了`SpaceShip`类的方法：![如何操作…](img/B05391_03_08.jpg)
- en: 'Go ahead and create the `Destroyer` class with all its methods in the console
    application:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中创建包含所有方法的`Destroyer`类：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, create a new instance of the `Annihilator` class. This class contains
    all the methods of the `Destroyer` class as well as the methods from the `SpaceShip`
    class. This is because `Annihilator` inherits from `Destroyer`, which, in turn,
    inherits from `SpaceShip`:![How to do it…](img/B05391_03_09.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`Annihilator`类的新实例。这个类包含了`Destroyer`类的所有方法以及`SpaceShip`类的方法。这是因为`Annihilator`类从`Destroyer`类继承，而`Destroyer`类又从`SpaceShip`类继承：![如何操作…](img/B05391_03_09.jpg)
- en: 'Go ahead and create the `Annihilator` class with all its methods in the console
    application:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中创建 `Annihilator` 类及其所有方法：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We can see that inheritance allowed us to easily extend our classes by reusing
    functionality that already exists within another class created earlier. You also
    need to be aware though that any changes to the `SpaceShip` class will be inherited
    up the stack to the top-most derived class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，继承使我们能够通过重用之前创建的另一个类中已经存在的功能来轻松扩展我们的类。但你也需要注意，对 `SpaceShip` 类的任何更改都将继承到最顶层的派生类。
- en: Inheritance is a very powerful feature of C#, which allows developers to write
    less code and reuse working and tested methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是 C# 的一个非常强大的功能，它允许开发者编写更少的代码并重用已编写和测试过的方法。
- en: Using abstraction
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象
- en: With abstraction, we take from the object we want to create the basic functionality
    that all objects derived from the abstracted object must have. To explain this
    in simple terms, we abstract the common functionality and put it in a single class
    that will be used to provide this shared functionality to all classes that inherit
    from it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过抽象，我们从想要创建的对象中提取基本功能，所有从抽象对象派生的对象都必须具备这些功能。用简单的话来说，我们抽象出共同的功能，并将其放入一个单独的类中，这个类将被用来为从它继承的所有类提供共享功能。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To explain abstraction, we will use abstract classes. Imagine that you are dealing
    with trainee space astronauts who need to progress through the ranks as they get
    trained. The truth is that once you as trainee learn a new skill, that skill is
    learned and will remain with you even though you learn more advanced ways to do
    things. You must also implement all the previous skills learned in the new object
    you create. Abstract classes demonstrate this concept very nicely.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释抽象，我们将使用抽象类。想象一下，你正在处理需要随着训练的进行而晋升等级的太空新兵。事实是，一旦你作为新兵学会一项新技能，这项技能就被学会了，即使你学会了更高级的做事方法，这项技能也会一直伴随着你。你必须在创建的新对象中实现所有之前学到的技能。抽象类很好地展示了这个概念。
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create an abstract class called `SpaceCadet`. This is the first type of astronaut
    you can be when starting with training. The abstract class and its members are
    defined using the `abstract` keyword. A thing to note is that abstract classes
    cannot be instantiated. The members represent the skills that `SpaceCadet` will
    have, such as negotiation and basic weapons training:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SpaceCadet` 的抽象类。这是你开始训练时可以成为的第一种宇航员类型。抽象类及其成员使用 `abstract` 关键字定义。需要注意的是，抽象类不能被实例化。成员代表
    `SpaceCadet` 将拥有的技能，例如谈判和基本武器训练：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, create another abstract class called `SpacePrivate`. This abstract class
    inherits from the `SpaceCadet` abstract class. What we are basically saying is
    that when a space cadet is trained as a space private, they will still have all
    the skills learned as a space cadet:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建另一个名为 `SpacePrivate` 的抽象类，这个抽象类从 `SpaceCadet` 抽象类继承。我们基本上是在说，当一名太空新兵被训练成太空列兵时，他们仍然会保留作为太空新兵时学到的所有技能：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To demonstrate this, create a class called `LabResearcher` and inherit the
    `SpaceCadet` abstract class. Inheriting from the abstract class is done by defining
    a colon and abstract class name after the newly created class name. This tells
    the compiler that the `LabResearcher` class inherits from the `SpaceCadet` class:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这一点，创建一个名为 `LabResearcher` 的类，并从 `SpaceCadet` 抽象类继承。从抽象类继承是通过在新建的类名后定义一个冒号和抽象类名称来完成的。这告诉编译器
    `LabResearcher` 类是从 `SpaceCadet` 类继承的：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because we are inheriting an abstract class, the compiler will underline the
    `LabResearcher` class name to warn us that the derived class does not implement
    any of the methods in the `SpaceCadet` abstract class.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在继承一个抽象类，编译器会在 `LabResearcher` 类名下划线以警告我们，派生类没有实现 `SpaceCadet` 抽象类中的任何方法。
- en: If you hover your mouse over the squiggly line, you will see that the lightbulb
    tip provides us with the issues discovered:![How to do it…](img/B05391_03_10.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在波浪线上方，你会看到灯泡提示为我们提供了发现的问题：![如何做到这一点…](img/B05391_03_10.jpg)
- en: Visual Studio does a great job of providing a solution to the issues discovered.
    By typing *Ctrl* + *.* (Control key and dot), you can let Visual Studio show you
    some potential fixes (in this case, only one fix) for the issues identified:![How
    to do it…](img/B05391_03_11.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 在提供解决方案以解决发现的问题方面做得很好。通过按 *Ctrl* + *.*（控制键和点），你可以让 Visual Studio
    显示一些潜在修复（在这种情况下，只有一个修复）以解决已识别的问题：![如何做到这一点…](img/B05391_03_11.jpg)
- en: 'After Visual Studio has added the required methods, you will see that these
    are the same methods defined in the `SpaceCadet` abstract class. Abstract classes,
    therefore, require the classes inheriting from the abstract class to implement
    the methods defined in the abstract class. You will also notice that the methods
    added to the `LabResearcher` class contain no implementation and will throw an
    exception if used as is:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 添加了所需的方法后，你会看到这些方法与 `SpaceCadet` 抽象类中定义的方法相同。因此，抽象类要求从抽象类继承的类实现抽象类中定义的方法。你还会注意到添加到
    `LabResearcher` 类中的方法没有任何实现，如果直接使用将会抛出异常：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create a class called `PlanetExplorer` and make this class inherit from
    the `SpacePrivate` abstract class. You will remember that the `SpacePrivate` abstract
    class inherited from the `SpaceCadet` abstract class:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `PlanetExplorer` 的类，并使这个类继承自 `SpacePrivate` 抽象类。你会记得 `SpacePrivate`
    抽象类是从 `SpaceCadet` 抽象类继承而来的：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Visual Studio will once again warn you that your new class does not implement
    the methods of the abstract class that you are inheriting from. Here, however,
    you will notice that the lightbulb tip informs you that you are not implementing
    any of the methods in the `SpacePrivate` and `SpaceCadet` abstract classes. This
    is because the `SpacePrivate` abstract class is inheriting from the `SpaceCadet`
    abstract class:![How to do it…](img/B05391_03_12.jpg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将再次警告你，你的新类没有实现你继承的抽象类中的方法。然而，在这里，你会注意到灯泡提示告诉你，你没有在 `SpacePrivate`
    和 `SpaceCadet` 抽象类中实现任何方法。这是因为 `SpacePrivate` 抽象类是从 `SpaceCadet` 抽象类继承而来的：![如何操作……](img/B05391_03_12.jpg)
- en: To fix the issues identified, type *Ctrl* + *.* (Control key and dot) and let
    Visual Studio show you some potential fixes (in this case, only one fix) for the
    issues identified:![How to do it…](img/B05391_03_13.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修复识别出的问题，请输入 *Ctrl* + *.*（控制键和点），让 Visual Studio 显示一些针对识别出的问题的潜在修复方案（在这种情况下，只有一个修复方案）：![如何操作……](img/B05391_03_13.jpg)
- en: 'After the fixes have been added to your code, you will see that the `PlanetExplorer`
    class contains all the methods in the `SpacePrivate` and `SpaceCadet` abstract
    classes:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将修复方案添加到你的代码后，你会看到 `PlanetExplorer` 类包含了 `SpacePrivate` 和 `SpaceCadet` 抽象类中的所有方法：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Abstraction has allowed us to define a common set of functionality that is to
    be shared among all the classes that derive from the abstract classes. The difference
    between inheriting from the abstract class and a normal class is that with an
    abstract class, you have to implement all the methods defined in that abstract
    class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象化使我们能够定义一组要在所有从抽象类派生的类之间共享的功能。从抽象类继承与从普通类继承之间的区别在于，使用抽象类时，你必须实现该抽象类中定义的所有方法。
- en: This makes the class easy to version and change. If you need to add new functionality,
    you can do so by adding that functionality to the abstract class without breaking
    any of the existing code. Visual Studio will require that all inherited classes
    implement the new method defined in the abstract class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得类易于版本控制和修改。如果你需要添加新功能，你可以通过将此功能添加到抽象类中来实现，而不会破坏任何现有代码。Visual Studio 将要求所有继承自抽象类的类实现抽象类中定义的新方法。
- en: You can, therefore, be assured that the change applied will be implemented in
    all your classes that derive from the abstract classes in your code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以确信所做的更改将应用于所有从你的代码中的抽象类派生的类。
- en: Leveraging encapsulation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用封装
- en: 'What is encapsulation? Simply put, it is hiding the inner workings of a class
    that aren''t necessary for the implementation of that class. Think of encapsulation
    as follows: most people who own a car know that it runs on gas. They don''t need
    to know the inner workings of an internal combustion engine to be able to use
    a car. They only need to know that they need to fill it up with gas when it is
    close to empty and that they need to check the oil and tyre pressure. Even then,
    it is usually not done by the car owner. This is true for classes and encapsulation.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是什么？简单来说，封装就是隐藏一个类内部不必要的实现细节。可以这样理解封装：大多数拥有汽车的人都知道汽车是靠汽油运行的。他们不需要了解内燃机的内部工作原理就能使用汽车。他们只需要知道当油快用完时需要加油，以及需要检查机油和轮胎压力。即使如此，通常也不是车主自己来做这些。对于类和封装来说，也是如此。
- en: The owner of the class is the one who uses it. The inner workings of that class
    need not be exposed to the developer using the class. The class is, therefore,
    like a black box. You know that the class will be consistent in its functionality,
    given the correct set of parameters. How exactly the class gets to the output
    is of no concern to the developer as long as the input is correct.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类的所有者是使用它的人。该类的内部工作原理不需要向使用该类的开发者公开。因此，该类就像一个黑盒。你知道，只要参数设置正确，类在功能上将是一致的。至于类如何得到输出，只要输入正确，对开发者来说并不重要。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To illustrate the concept of encapsulation, we will create a class that is somewhat
    complex in its inner workings. We need to calculate the **thrust to weight ratio**
    (**TWR**) of a space shuttle to determine whether it will be able to take off
    vertically. It needs to exert more thrust than its weight to counteract gravity
    and get into a stable orbit. This also depends on which planet the shuttle takes
    off from, because different planets exert different gravitational forces on objects
    on their surface. In simple terms, the TWR must be greater than one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明封装的概念，我们将创建一个在内部工作原理上相对复杂的类。我们需要计算航天飞机的**推重比**（**TWR**），以确定它是否能够垂直起飞。它需要施加比其重量更大的推力来对抗重力并进入稳定的轨道。这也取决于航天飞机起飞的行星，因为不同的行星对其表面的物体施加不同的重力。简单来说，TWR必须大于一。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create a new class called `LaunchSuttle`. Then, add the following private variables
    to the class for engine thrust; the mass of the shuttle; the local gravitational
    acceleration; the constant values for the gravity of the Earth, Moon, and Mars
    (these are constants because they will never change); the universal gravitational
    constant; and an enumerator for the planet we are dealing with:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`LaunchSuttle`的新类。然后，向该类添加以下私有变量，用于发动机推力；航天飞机的质量；局部重力加速度；地球、月球和火星的重力常量值（这些是常量，因为它们永远不会改变）；万有引力常数；以及我们正在处理的行星枚举器：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To our class, we will add three overloaded constructors that are essential to
    perform the calculation of the TWR based on the known facts at the time of instantiation
    (we assume that we will always know the engine thrust capability and mass of the
    shuttle). We will pass the gravitational acceleration for the first constructor.
    This is useful if we know beforehand what that value will be. For example, the
    gravitational acceleration of the Earth is 9.81 m/s².
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了我们的类，我们将添加三个重载构造函数，这些构造函数对于根据实例化时的已知事实计算TWR是必不可少的（我们假设我们总是会知道发动机推力能力和航天飞机的质量）。我们将为第一个构造函数传递重力加速度。如果我们事先知道这个值，这很有用。例如，地球的重力加速度是9.81
    m/s²。
- en: The second constructor will use the `Planet` enumerator to calculate the TWR
    that uses the constant variable values.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个构造函数将使用`Planet`枚举来计算使用常量变量值的TWR。
- en: 'The third constructor will use the radius and mass of the planet to calculate
    the gravitational acceleration when those values are knows to return the TWR:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个构造函数将使用行星的半径和质量来计算当这些值已知时返回TWR的重力加速度：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to use the second overloaded constructor that passes the `Planet`
    enumerator as a parameter to the class, we need to create another method that
    has been scoped as `private` to calculate the gravitational acceleration. We also
    need to set the `_LocalGravitationalAcceleration` variable to the specific constant
    that matches the enumerator value. This method is something that the user of the
    class does not need to see in order to use the class. It is, therefore, scoped
    as `private` in order to hide that functionality from the user:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用传递`Planet`枚举作为参数给类的第二个重载构造函数，我们需要创建另一个被范围限定为`private`的方法来计算重力加速度。我们还需要将`_LocalGravitationalAcceleration`变量设置为与枚举值匹配的特定常量。这个方法是对类用户来说不需要看到就能使用类的方法。因此，它被范围限定为`private`，以便从用户那里隐藏该功能：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Of the following methods, only one is defined as public and will, therefore,
    be visible to the user of the class. Create the private methods to set the universal
    gravitational constant, to calculate the TWR, and to calculate the gravitational
    acceleration. These are all scoped as private, because the developer does not
    need to know what these methods do in order to use the class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下方法中，只有一个被定义为公共的，因此对类的用户是可见的。创建私有方法来设置万有引力常数、计算TWR和计算重力加速度。这些方法都被设置为私有作用域，因为开发者不需要知道这些方法做什么，以便使用该类：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in your console application, create the following variables with their
    known vales:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在你的控制台应用程序中，创建以下具有已知值的变量：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new instance of the `LaunchShuttle` class and pass it the values needed
    to calculate the TWR:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`LaunchShuttle`类的新实例，并传递计算TWR所需的价值：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you use the dot operator on the `NasaShuttle1` variable, you will notice
    that IntelliSense only shows the `TWR` method. The class exposes nothing of the
    inner workings of how it gets to the calculated TWR value. The only thing that
    the developer knows is that the `LaunchShuttle` class will consistently return
    the correct TWR value, given the same input parameters:![How to do it…](img/B05391_03_14.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在`NasaShuttle1`变量上使用点操作符时，你会注意到IntelliSense只显示`TWR`方法。这个类没有暴露任何关于它是如何得到计算出的TWR值的内部工作原理。开发者唯一知道的是，给定相同的输入参数，`LaunchShuttle`类将始终返回正确的TWR值：![如何做…](img/B05391_03_14.jpg)
- en: 'To test this, create two more instances of the `LaunchShuttle` class and call
    a different constructor each time:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，创建`LaunchShuttle`类的两个更多实例，并且每次调用不同的构造函数：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run your console application, you will see that the same value is returned
    for the TWR. The value indicates that a shuttle weighing 16.12 tons with a rocket
    that puts out 220 kilonewtons of thrust will be able to lift off the surface of
    the Earth (if only just):![How to do it…](img/B05391_03_15.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行你的控制台应用程序，你会看到TWR的值是相同的。这个值表明，一个重16.12吨的航天飞机，如果火箭产生220千牛顿的推力，将能够从地球表面起飞（即使只是勉强）：![如何做…](img/B05391_03_15.jpg)
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The class uses the scoping rules to hide certain functionality inside the class
    from the developer using the class. As mentioned earlier, the developer does not
    need to know how the calculations are done to return the value for the TWR. This
    all aids in making the class more useful and easy to implement. Here is a list
    of the various scopes available in C#, along with their uses:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用作用域规则来隐藏类内部的一些功能，以防止类使用者访问。如前所述，开发者不需要知道如何进行计算，以便返回TWR的值。所有这些都帮助使类更有用且易于实现。以下是C#中可用的各种作用域及其用途列表：
- en: '`Public`: This is used with variables, properties, types, and methods and is
    visible anywhere.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Public`：这个关键字用于变量、属性、类型和方法，并且在任何地方都是可见的。'
- en: '`Private`: This is used with variables, properties, types, and methods and
    is visible only in the block where they are defined.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Private`：这个关键字用于变量、属性、类型和方法，并且仅在定义它们的代码块中可见。'
- en: '`Protected`: This is used with variables, properties, and methods. Don''t think
    of this in terms of public or private. The protected scope is only visible inside
    the class in which it is used, as well as in any inherited classes.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protected`：这个关键字用于变量、属性和方法。不要从公共或私有角度考虑这个问题。受保护的访问级别仅在其使用的类内部以及任何继承的类中可见。'
- en: '`Friend`: This is used with variables, properties, and methods and can only
    be used by code in the same project or assembly.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Friend`：这个关键字用于变量、属性和方法，并且只能由同一项目或程序集内的代码使用。'
- en: '`Protected Friend`: This is used with variables, properties, and methods and
    is a combination (as the name suggests) of the protected and friend scopes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protected Friend`：这个关键字用于变量、属性和方法，并且是受保护作用域和友元作用域的组合（正如其名称所暗示的）。'
- en: Implementing polymorphism
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多态性
- en: Polymorphism is a concept that is quite easy to grasp once you have looked at
    and understood the other pillars of OOP. Polymorphism literally means that something
    can have many forms. This means that from a single interface, you can create multiple
    implementations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你研究了并理解了OOP的其他支柱，多态性这个概念就很容易掌握了。多态性字面上意味着某物可以有多种形式。这意味着从一个单一接口，你可以创建多个实现。
- en: There are two subsections to this, namely static and dynamic polymorphism. With
    static polymorphism, you are dealing with the overloading of methods and functions.
    You can use the same method, but perform many different tasks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个子部分，即静态多态和动态多态。在静态多态中，您正在处理方法和函数的重载。您可以使用相同的方法，但执行许多不同的任务。
- en: With dynamic polymorphism, you are dealing with the creation and implementation
    of abstract classes. These abstract classes act as a blueprint that tells you
    what a derived class should implement. The following section looks at both.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态多态中，您正在处理抽象类的创建和实现。这些抽象类充当蓝图，告诉您派生类应该实现什么。下一节将探讨这两者。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will begin by illustrating the use of an abstract class, which is an example
    of dynamic polymorphism. We will then create overloaded constructors as an example
    of static polymorphism.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过展示抽象类的使用来阐述，这是一个动态多态的例子。然后，我们将创建重载构造函数作为静态多态的例子。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: 'Create an abstract class called `Shuttle` and give it a member called `TWR`,
    which is the calculation of the TWR of the shuttle:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Shuttle` 的抽象类，并给它一个名为 `TWR` 的成员，这是计算航天飞机的 TWR：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, create a class called `NasaShuttle` and have it inherit from the abstract
    class `Shuttle`, by putting the abstract class name after a colon at the end of
    the `NasaShuttle` class declaration:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `NasaShuttle` 的类，并使其继承自抽象类 `Shuttle`，通过在 `NasaShuttle` 类声明末尾冒号后放置抽象类名称来实现：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Visual Studio will underline the `NasaShuttle` class because you have told the
    compiler that the class inherits from an abstract class, but you have not yet
    implemented the members of that abstract class:![How to do it…](img/B05391_03_16.jpg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将下划线显示 `NasaShuttle` 类，因为您已告诉编译器该类继承自一个抽象类，但您尚未实现该抽象类的成员：![如何实现它…](img/B05391_03_16.jpg)
- en: To fix the issues identified, type *Ctrl* + *.* (Control key and dot) and let
    Visual Studio show you some potential fixes (in this case, only one fix) for the
    issues identified:![How to do it…](img/B05391_03_17.jpg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复已识别的问题，按 *Ctrl* + *.*（控制键和点）并让 Visual Studio 显示一些潜在的修复方案（在这种情况下，只有一个修复方案）以解决已识别的问题：![如何实现它…](img/B05391_03_17.jpg)
- en: 'Visual Studio then adds the missing implementation to your `NasaShuttle` class.
    By default, it will add it as not implemented, because you are required to provide
    implementation for the abstract member you overrode in the abstract class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 然后将缺失的实现添加到您的 `NasaShuttle` 类中。默认情况下，它将添加为未实现，因为您需要为在抽象类中重写的抽象成员提供实现：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create another class called `RoscosmosShuttle` and inherit from the same `Shuttle`
    abstract class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `RoscosmosShuttle` 的类，并使其继承自相同的 `Shuttle` 抽象类：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Visual Studio will underline the `RoscosmosShuttle` class because you have told
    the compiler that the class inherits from an abstract class, but you have not
    yet implemented the members of that abstract class:![How to do it…](img/B05391_03_18.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将下划线显示 `RoscosmosShuttle` 类，因为您已告诉编译器该类继承自一个抽象类，但您尚未实现该抽象类的成员：![如何实现它…](img/B05391_03_18.jpg)
- en: To fix the issues identified, type *Ctrl* + *.* (Control key and dot) and let
    Visual Studio show you some potential fixes (in this case, only one fix) for the
    issues identified:![How to do it…](img/B05391_03_19.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复已识别的问题，按 *Ctrl* + *.*（控制键和点）并让 Visual Studio 显示一些潜在的修复方案（在这种情况下，只有一个修复方案）以解决已识别的问题：![如何实现它…](img/B05391_03_19.jpg)
- en: 'The overridden method is then added to the `RoscosmosShuttle` class as not
    implemented. You have just seen an example of dynamic polymorphism in action:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被重写的方法随后被添加到 `RoscosmosShuttle` 类中，标记为未实现。您刚刚看到了动态多态的一个实际例子：
- en: '[PRE26]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see an example of static polymorphism, create the following overloaded constructor
    for `NasaShuttle`. The constructor name stays the same, but the signature of the
    constructor changes, which makes it overloaded:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看静态多态的示例，为 `NasaShuttle` 创建以下重载构造函数。构造函数名称保持不变，但构造函数的签名发生变化，这使得它成为重载：
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Polymorphism is something you will easily be using already by simply applying
    good object oriented principles to the design of your classes. With the abstract
    `Shuttle` class, we saw that the class took on the shape of the `NasaShuttle`
    class and the `RoscosmosShuttle` class when it was used to derive those new classes
    from its abstraction. The constructor of the `NasaShuttle` class was then overridden
    to provide the same method name, but implemented using different signatures.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是你可以通过简单地应用良好的面向对象原则到你的类的设计中而轻松使用的东西。通过使用抽象的`Shuttle`类，我们看到当它用来从其抽象中派生新类时，该类采取了`NasaShuttle`类和`RoscosmosShuttle`类的形状。然后，`NasaShuttle`类的构造函数被重写以提供相同的方法名，但使用不同的签名来实现。
- en: This is at the heart of polymorphism. Most likely, you have been using it without
    knowing about it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是多态性的核心。你很可能在使用它时并不知道。
- en: Single responsibility principle
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: When talking about SOLID principles, we will start off with the SRP. Here, we
    are actually saying that a class has a specific task that it needs to fulfil and
    it should not do anything else.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论SOLID原则时，我们将从SRP（单一职责原则）开始。在这里，我们实际上是在说一个类有一个特定的任务需要完成，它不应该做其他任何事情。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will create a new class and write code to log an error to the database when
    an exception is thrown on adding more troops to the star ship, causing it to be
    over capacity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个新的类，并编写代码在向星际飞船添加更多部队时抛出异常，导致其超负荷时，将错误记录到数据库中。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new class called `StarShip`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StarShip`的新类：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To your class, add a new method that will set the maximum troop capacity of
    the `StarShip` class:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向你的类中添加一个新方法，用于设置`StarShip`类的最大部队容量：
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside this method, add a `trycatch` clause that will attempt to set the maximum
    troop capacity, but for some reason, it will fail. Upon failure, it will write
    the error to the log table inside the database:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，添加一个`trycatch`子句，尝试设置最大部队容量，但出于某种原因，它将失败。失败后，它将错误写入数据库中的日志表：
- en: '[PRE30]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: If you have code that looks like the preceding one, you are in contravention
    of the SRP. The `StarShip` class is no longer responsible for just itself and
    things that have to do with star ships. It now has to fulfill the role of logging
    errors to the database too. You see the problem here is that the database-logging
    code does not belong in the `catch` clause of the `SetMaximumTroopCapacity` method.
    A better approach would be to create a separate `DatabaseLogging` class with methods
    to create connections and write exceptions to the appropriate log table. You will
    also find that you are going to have to write that logging code in multiple places
    (in every `catch` clause). If you are finding that you are repeating code (by
    copying and pasting from other areas), you probably need to put that code into
    a common class, and you have likely broken the SRP rule.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有的代码看起来像前面的代码，你违反了SRP（单一职责原则）。`StarShip`类不再只负责自身以及与星际飞船相关的事物。现在它还必须承担将错误记录到数据库的角色。你在这里看到的问题是，数据库记录代码不属于`SetMaximumTroopCapacity`方法的`catch`子句。更好的方法是将创建一个单独的`DatabaseLogging`类，其中包含创建连接和将异常写入适当日志表的方法。你还会发现你将不得不在多个地方（每个`catch`子句）编写那些记录代码。如果你发现自己正在重复代码（通过从其他区域复制粘贴），你可能需要将那些代码放入一个公共类中，你很可能已经违反了SRP规则。
- en: Open/closed principle
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: When creating classes, we need to ensure that the class prohibits any breaking
    modifications by needing to change internal code. We say that such a class is
    closed. If we need to change it somehow, we can do so by extending the class.
    This extensibility is where we say that the class is open for extensions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类时，我们需要确保类通过需要更改内部代码来禁止任何破坏性的修改。我们说这样的类是封闭的。如果我们需要以某种方式更改它，我们可以通过扩展类来实现。这种可扩展性就是我们所说的类对扩展是开放的。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will create a class that determines the skills of a trooper by looking at
    the class of trooper. We will show you the way many developers create such a class
    and the way it can be created using the open/closed principle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个类，通过查看士兵的类别来确定士兵的技能。我们将向你展示许多开发者创建此类的方式以及如何使用开放/封闭原则创建此类。
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a class called `StarTrooper`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StarTrooper`的类：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To this class, add an enumerator called `TrooperClass` to identify the type
    of trooper we want to return the skills of. Also, create a `List<string>` variable
    to contain the skills of the specific trooper class. Finally, create a method
    called `GetSkills` that returns the specific set of skills for the given trooper
    class.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向这个类添加一个枚举器`TrooperClass`，以标识我们想要返回技能的士兵类型。此外，创建一个`List<string>`变量来包含特定士兵类的技能。最后，创建一个名为`GetSkills`的方法，该方法返回给定士兵类的特定技能集。
- en: The class is quite straightforward, but the implementation of the code is something
    we see a lot. Sometimes, instead of a `switch` statement, you will see a whole
    lot of `if` `else` statements. While the functionality of the code is clear, it
    is not easy to add another class of trooper to the `StarTrooper` class without
    changing code. Assume that you now have to add an additional `Engineer` class
    to the `StarTrooper` class. You would have to modify the `TrooperClass` enumeration
    and the code in the `switch` statement.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类相当简单，但代码的实现是我们经常看到的。有时，您会看到大量的`if` `else`语句而不是`switch`语句。虽然代码的功能是清晰的，但在不更改代码的情况下很难向`StarTrooper`类添加另一个士兵类。假设您现在必须向`StarTrooper`类添加一个额外的`Engineer`类。您将不得不修改`TrooperClass`枚举和`switch`语句中的代码。
- en: 'This changing of code can cause you to introduce bugs into code that was previously
    working fine. We now see that the `StarTrooper` class is not closed and can''t
    be extended easily to accommodate additional `TrooperClass` objects:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种代码的更改可能会导致您在之前运行良好的代码中引入错误。我们现在看到`StarTrooper`类不是封闭的，并且不能轻松扩展以适应额外的`TrooperClass`对象：
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The solution to this problem is inheritance. Instead of having to change code,
    we extend it. Start off by rewriting the above `StarTrooper` class and create
    a `Trooper` class. The `GetSkills` method is declared as `virtual`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是继承。我们不需要更改代码，而是扩展它。首先，重写上面的`StarTrooper`类并创建一个`Trooper`类。`GetSkills`方法被声明为`virtual`：
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can easily create derived classes for the `Soldier`, `Medic`, and `Scientist`
    trooper classes available. Create the following derived classes that inherit from
    the `Trooper` class. You can see that the `override` keyword is used when creating
    the `GetSkills` method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地为可用的`Soldier`、`Medic`和`Scientist`士兵类创建派生类。创建以下从`Trooper`类继承的派生类。您可以看到，在创建`GetSkills`方法时使用了`override`关键字：
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code becomes extremely easy to implement when extending the class to add
    an additional class of `Trooper`. If we now want to add the `Engineer` class,
    we would simply override the `GetSkills` method after inheriting from the `Trooper`
    class created earlier:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当扩展类以添加额外的`Trooper`类时，代码变得极其容易实现。如果我们现在想添加`Engineer`类，我们只需在从之前创建的`Trooper`类继承后简单地重写`GetSkills`方法：
- en: '[PRE35]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The classes derived from the `Trooper` class are extensions of the `Trooper`
    class. We can say that each class is closed, because modifying it does not necessitate
    changing the original code. The `Trooper` class is also extensible because we
    have been able to easily extend the class by creating derived classes from it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Trooper`类派生的类是`Trooper`类的扩展。我们可以这样说，每个类都是封闭的，因为修改它不需要更改原始代码。`Trooper`类也是可扩展的，因为我们能够通过从它创建派生类来轻松扩展类。
- en: Another by-product of this design is smaller, more manageable code that is easier
    to read and understand.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的另一个副产品是更小、更易于管理的代码，它更容易阅读和理解。
