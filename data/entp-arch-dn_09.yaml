- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Exploring Domain-Driven Design and Semantics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索领域驱动设计和语义
- en: The previous chapter ended with a promise to provide a method to deal with a
    pivotal format and the design of an evolution-ready, functionally correct entity
    when no standard exists in this precise domain. This is the subject of our present
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章以提供一种处理关键格式和设计一个适应演变的、功能正确的实体的方法结束，当在这个精确领域没有标准时。这是我们本章的主题。
- en: 'In order to reach this objective, a very important prerequisite is to keep
    thinking in *functional terms*. I know most of you will certainly have a technical
    background and may wonder when we are finally going to get to the code. Having
    you wait this long without doing anything technical has been done on purpose and
    is part of the pedagogical journey provided by the reading of this book. You have
    to stick to functional and business-related concepts as long as you can because,
    as soon as you transform this knowledge into software, it gets solidified and
    way harder to modify afterward. I promise that, as soon as the next chapter, we
    will start getting our hands dirty with some technical decisions. Then, in a few
    chapters, we will put some code together to actually show in very concrete terms
    what all this translates into. But for now, let’s stick to business functions
    only and think about our format without any relationship to anything technical,
    just like we are taught by clean architecture. This is the main guarantee we have
    to build the right information system. Actually, if you remember only one thing
    from this whole book, I would love it to be this practice: think as long as you
    need to understand your problem from the functional point of view, and only then
    start thinking about how to deal with it from a technical point of view. Delay
    implementation as much as possible; think of data, not databases; think of models
    and business rules, not attributes and methods.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目标，一个非常重要的先决条件是始终以**功能**术语进行思考。我知道你们大多数人肯定有技术背景，可能会想知道我们何时才能最终接触到代码。让你们等待这么长时间而不进行任何技术操作是有意为之的，这也是本书阅读过程中提供的教学旅程的一部分。你们必须尽可能坚持功能和业务相关的概念，因为一旦将这种知识转化为软件，它就会变得固化，并且修改起来更加困难。我保证，从下一章开始，我们将开始做一些技术决策，然后，在接下来的几章中，我们将编写一些代码，以非常具体的方式展示这一切的含义。但就目前而言，让我们只关注业务功能，并像清洁架构所教导的那样，不考虑任何与技术相关的内容，仅仅从功能角度思考。这是我们构建正确信息系统的主要保证。实际上，如果你只从这本书中记住一件事，我希望那就是这个实践：从功能角度尽可能长时间地思考你的问题，然后才开始从技术角度思考如何处理它。尽可能推迟实施；考虑数据，而不是数据库；考虑模型和业务规则，而不是属性和方法。
- en: If you do so, you will soon have some questions about the vocabulary used in
    the business domain. A technical approach has the huge drawback of constraining
    the approach. But we should at least recognize that it pushes us into being extremely
    precise, as computers are as dumb as a box of rocks, so they oblige us to be explicit
    in information designation. Considering semantics and using a method called **domain-driven
    design** (**DDD**) will help us to be precise in functional terms, but without
    depending on anything technical that would hinder our evolution later on; this
    way, we get the best of both worlds.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你很快就会对业务领域中使用的词汇有所疑问。技术方法有一个巨大的缺点，那就是限制了方法。但我们应该至少认识到，它迫使我们非常精确，因为计算机就像一箱石头一样愚蠢，它们强迫我们在信息指定上明确表达。考虑语义并使用称为**领域驱动设计**（**DDD**）的方法将帮助我们从功能角度进行精确思考，但不会依赖于任何可能阻碍我们未来发展的技术；这样，我们就能兼得两者之利。
- en: Once the principles of this method are understood, again, we will turn back
    to our long-run example and apply DDD to our sample information system in order
    to draw its bounded contexts and describe its ubiquitous language (we will soon
    explain these two important concepts).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解了这种方法的原则，我们再次回到我们的长期示例，并将DDD应用于我们的示例信息系统，以绘制其边界上下文并描述其通用语言（我们很快将解释这两个重要概念）。
- en: Finally, the chapter will explain how all of this applies to clean information
    systems as we try to design them, and what the links to the concepts of service
    and API are, which we have exposed in the previous chapter. There, we will talk
    about the importance of the life cycle analysis of a business entity and discuss
    a few recent orientations in information systems architecture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章将解释所有这些如何应用于我们试图设计的清洁信息系统，以及服务与API概念的联系，这些联系我们在上一章中已经介绍。在那里，我们将讨论业务实体生命周期分析的重要性，并讨论信息系统架构的一些最近趋势。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A functional approach to a functional problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能问题的功能方法
- en: The importance of semantics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义的重要性
- en: DDD
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD
- en: Application to clean information system architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用到清洁信息系统架构
- en: Link to the API and services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到API和服务
- en: A functional approach to a functional problem
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能问题的功能方法
- en: As explained in the introduction, it is of utmost importance to use a functional
    approach to solve the problem of designing a pivotal format. In the four-layer
    CIGREF map, all layers are a consequence of the one above. Hence, starting with
    layer 3 (software) without having a correct design of the context studied in layer
    2 (business capabilities) is bound to create malfunctioning software. This is
    made much worse by the fact that once turned into software, the error will be
    fixed in code and possibly shared through APIs used by many users and machines
    all over your information system or external ones, which may make it almost impossible
    to correct the design error.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，使用功能方法来解决设计关键格式的问题至关重要。在四层CIGREF映射中，所有层都是上一层的后果。因此，在没有正确设计第二层（业务能力）中研究的上下文的情况下，就开始从第三层（软件）开始，这必然会导致软件出现故障。更糟糕的是，一旦变成软件，错误将在代码中修复，并且可能通过被整个信息系统或外部系统中的许多用户和机器使用的API共享，这几乎使得纠正设计错误变得不可能。
- en: 'The vast majority of IT problems come from this lack of business alignment
    that we have talked about a lot and, right now, we are at the root of the problem:
    the design of the business entities. When we do not have any dedicated standard
    to rely on and spare us of a complex reasoning process, filled with risks of misunderstandings
    that may have important consequences, we will have to pay particular attention
    to any details, which, in practice, means extensive and guaranteed access to experts
    of the business domain.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IT问题都源于我们经常谈论的业务对齐不足，而现在，我们正处在问题的根源：业务实体的设计。当我们没有专门的规范可以依赖并避免复杂的推理过程，其中充满了可能导致重大后果的误解风险时，我们必须特别注意任何细节，在实践中，这意味着对业务领域专家的广泛和保证的访问。
- en: A standard is generally expressed in technical terms in order to be extremely
    precise and irrefutable, but it represents, in a shared, acknowledged way, a functional
    concept. For example, RFC 7519 describes what a JSON Web Token is, and what the
    issuer, subject, expiration time, and all other attributes are for, but it does
    so in a very constrained way (with a precise definition of `iss`, `sub`, and `exp`,
    for the information we have cited previously. This way, we can say that a norm
    both lives in layers 2 and 3 of the CIGREF map and binds them together. This is
    why norms and standards are so important because they are the concrete actors
    of business/IT alignment. To give a second example, OpenAPI is also a great illustration
    of how norms and standards bridge the potential gap between functional and software
    approaches, by providing a list of all functions that should be accessible through
    an API on a given business domain, while, at the same time, giving a precise JSON
    or YAML-based technical description of what this means in the data streams that
    will be exchanged between servers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标准通常用技术术语表达，以便非常精确和无可辩驳，但它以共享和公认的方式代表了一个功能概念。例如，RFC 7519描述了JSON Web Token是什么，以及发行者、主题、过期时间以及所有其他属性的作用，但它以非常受限的方式（对之前引用的信息的`iss`、`sub`和`exp`有精确的定义）。这样，我们可以说规范既存在于CIGREF映射的2层和3层，又将它们联系在一起。这就是为什么规范和标准如此重要的原因，因为它们是业务/IT对齐的具体行动者。以第二个例子来说，OpenAPI也是规范和标准如何弥合功能方法和软件方法之间潜在差距的一个很好的说明，它提供了一份所有应在特定业务域的API上可访问的功能列表，同时，它还给出了关于这意味着在服务器之间交换的数据流中的精确JSON或YAML技术描述。
- en: A pivotal format should aim at the same result by joining the functional aspect
    and the technical representation of it. This is why it is important to describe
    it with technical means, whatever they are. These technical means can be XML Schema
    or DTD if you are using SOAP web services, or OpenAPI if you are designing API
    and their components; they can even be a simple Excel file showing the exact names
    and structures of the data messages you intend to move around your system. The
    only important thing is that it is technically written, but not technically restrictive.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关键格式应通过结合其功能方面和技术表示来达到相同的结果。这就是为什么无论使用什么技术手段来描述它都很重要的原因。这些技术手段可以是XML Schema或DTD，如果你正在使用SOAP
    Web服务；或者OpenAPI，如果你正在设计API及其组件；甚至可以是一个简单的Excel文件，显示你打算在系统中传输的数据消息的确切名称和结构。唯一重要的是，它必须是技术性的书写，但不能具有技术限制性。
- en: The phrase “technically written, but not technically restrictive,” may seem
    paradoxical, so, let me explain this. The technical writing of the norm is important
    because it ensures preciseness (nobody wants a vague description of something
    important). This is why a new API has got to be described in an OpenAPI contract.
    This way, there is no place for argument over how an attribute is written, with
    capital letters or not, or only the first one; for example, it is written in computerized
    text in the OpenAPI JSON or YAML, so there is no possible discussion. However,
    at the same time, attention should be paid to the fact that the pivotal format
    (like any norm) should never be constrained by any technical issues. We all agree
    that a norm to represent, say, countries, would not make any sense if the authors
    of the norm used some Java primitives that would make it difficult to use the
    norm with another platform. It would be a limited, technical way of doing it,
    but definitely not a real norm. The same should be applied to your pivotal format
    design and it should never expose anything from your technical implementation,
    even if it is expressed in a functional way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “技术上撰写，但技术上不具限制性”这个短语可能看似矛盾，所以让我来解释一下。规范的撰写技术很重要，因为它确保了精确性（没有人希望对重要事物有一个模糊的描述）。这就是为什么新的API必须用OpenAPI合同来描述。这样，就不会有关于属性如何书写的争论，无论是用大写字母还是不用，或者只使用第一个字母；例如，在OpenAPI
    JSON或YAML中的计算机化文本中书写，因此不可能有讨论。然而，同时，应注意关键格式（就像任何规范一样）绝不应受到任何技术问题的限制。我们都同意，如果规范的作者使用了某些会使规范难以与其他平台一起使用的Java原语，那么用于表示国家等的规范就没有任何意义。这将是一种有限的、技术性的实现方式，但绝对不是真正的规范。同样的原则也应适用于你的关键格式设计，它绝不应暴露出你的技术实现中的任何内容，即使是以功能方式表达。
- en: 'By the way, this is yet another reason for always designing from the functional
    point of view before thinking of software. If you force yourself during this period
    to let go of the database choice, for example, you reduce the possibility of creating
    a pivotal format that is bound to your database orientation. I understand this
    might sound a bit unrealistic and you might wonder how someone could bind the
    design of data to a database. Well, the devil lies in details and there are sadly
    many ways—some subtler than others—to fall into this trap:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这也是在设计软件之前始终从功能角度出发的另一个原因。如果你在这个阶段强迫自己放弃数据库选择，例如，你会减少创建与你的数据库方向绑定的关键格式的可能性。我理解这听起来可能有点不切实际，你可能想知道有人如何将数据设计绑定到数据库上。好吧，魔鬼藏在细节中，不幸的是，有许多方式——有些比其他方式更微妙——会陷入这个陷阱：
- en: One might express data attributes with types that are only available in some
    databases and not others. If we are used to talking about `VARCHAR(n)`, for example,
    we might imply in our data design that there is a limit to the size of an attribute,
    though it is not justified from the functional point of view. Everyone has seen
    an application that truncates family names when they are too long, although this
    creates an incorrect data value.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们可能会使用仅在某些数据库中可用而在其他数据库中不可用的类型来表示数据属性。例如，如果我们习惯于谈论`VARCHAR(n)`，那么在我们的数据设计中可能会暗示属性的大小有限制，尽管从功能角度来看并不合理。每个人都见过一个应用程序在姓氏过长时截断姓氏，尽管这会创建一个错误的数据值。
- en: The same can happen for date formats. The norm-referenced ISO 8601 (also nicknamed
    as ISO-Time) makes a clear difference between administrative dates and instants,
    but most databases do not. If we think in SQL terms, we might miss this essential
    difference.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，日期格式也可能发生这种情况。参考ISO 8601（也称为ISO-Time）的规范在行政日期和瞬间之间做出了明确区分，但大多数数据库并没有。如果我们从SQL的角度思考，我们可能会错过这个基本区别。
- en: Identifiers can be badly influenced by the well-known standard database mechanisms.
    The autogeneration of identifiers by SQL databases, based on counters, is quite
    practical but these identifiers scale very poorly and are one cause for the lack
    of distribution of such databases. **Globally unique identifiers** (**GUIDs**)
    are better and, quite often, used by more modern systems such as NoSQL databases.
    However, both will definitely be the wrong choice if you need to assign a unique
    identifier for an entity representing a patient in a health information system
    since the largely acknowledged (and sometimes legally required) identifier in
    this particular case is a national security number.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符可能会受到众所周知的数据库机制的影响。基于计数的SQL数据库自动生成标识符相当实用，但这些标识符的可扩展性非常差，这是这些数据库缺乏分布的一个原因。**全局唯一标识符**（**GUIDs**）更好，并且通常被更现代的系统如NoSQL数据库所使用。然而，如果你需要为一个在健康信息系统中代表患者的实体分配一个唯一的标识符，这两种选择都将绝对不合适，因为在这个特定情况下，广泛认可的（有时是法律要求的）标识符是国家安全号码。
- en: There are actually so many other cases where some technical knowledge can waste
    the design of a pivotal format that I have personally formed the habit of always
    designing them by animating groups only made of Product Owners, even going as
    far as detecting those with a technical background and excluding them from the
    design group in some cases. I still could badly influence the process, as I have
    a technical approach, but I generally help design pivotal formats on business
    domains I do have not much experience with, so, it is easy to play the role of
    a complete beginner, knowing nothing about the business domain and then focusing
    only on this comprehension. Also, I know from experience how early technical thinking
    can have a negative impact, so I always think of what could go wrong because of
    this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有很多其他情况，一些技术知识可能会浪费关键格式的设计，我因此养成了习惯，总是通过仅由产品所有者组成的团队来设计这些格式，甚至在一些情况下，我会检测到那些有技术背景的人并将他们排除在设计团队之外。尽管我仍然可能严重影响到这个过程，因为我有技术方法，但通常我帮助设计我在业务领域没有太多经验的临界格式，因此，扮演一个完全的初学者角色，对业务领域一无所知，然后只专注于这种理解。此外，我根据经验知道，早期技术思维可能会产生负面影响，所以我总是思考因为这一点可能会出什么问题。
- en: Sometimes, the coupling can be extremely subtle. For example, let’s take a URL
    such as `https://demoeditor.com/library/books/978-2409002205`. It sounds like
    a great identifier, since it is based on norms only (URLs, ISBNs for books, and
    a DNS for the host) and there is apparently nothing else. However, one could argue
    that prefixing with the (`https://`) scheme is already a hint for how we are going
    to technically access these functional entities, in this case, through web-based
    APIs. Luckily, a solution always exists and, in this case, this is through resorting
    to `urn:com:demoeditor:library:books:978-2409002205`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，耦合可能非常微妙。例如，让我们以一个URL为例，如`https://demoeditor.com/library/books/978-2409002205`。它听起来像是一个很好的标识符，因为它仅基于规范（URL、书籍的ISBN和主机的DNS）并且显然没有其他内容。然而，有人可能会争辩说，使用（`https://`）方案作为前缀已经暗示了我们将如何技术性地访问这些功能实体，在这种情况下，通过基于网络的API。幸运的是，总有一个解决方案，在这种情况下，就是通过求助于`urn:com:demoeditor:library:books:978-2409002205`。
- en: At this point in the book, you should hopefully be convinced that taking the
    functional point of view on a problem is always the best option and that the technical
    aspects should come afterward. This being said we need some method to analyze
    a problem from a functional point of view only, and this is how semantics can
    be used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，你可能会希望相信，从功能的角度来看待问题总是最佳选择，而技术方面应该在之后考虑。话虽如此，我们需要一种方法来仅从功能的角度分析问题，这就是语义可以发挥作用的地方。
- en: The importance of semantics
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义的重要性
- en: 'In the previous section, we demonstrated how to use a technically-backed but
    not technically-coupled approach to define entity formats that will be precise.
    However, we have not yet touched upon the functional analysis itself and, looking
    at our example URN, `urn:com:demoeditor:library:books:978-2409002205`, we can
    spot what needs further analysis in the different parts of the string:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何使用技术支持但不耦合的技术方法来定义精确的实体格式。然而，我们还没有涉及到功能分析本身，观察我们的示例 URN，`urn:com:demoeditor:library:books:978-2409002205`，我们可以在字符串的不同部分中找到需要进一步分析的内容：
- en: '`urn`: This is the scheme of the URI. It is here just to state that this is
    a unified resource name.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urn`：这是URI的方案。它在这里只是为了说明这是一个统一资源名称。'
- en: '`com:demoeditor`: This is the reverse of `demoeditor.com`, the domain name
    of our sample company. The information is there to serve as a prefix to differentiate
    the entities from another vendor that would have entities with the same name,
    and it is reversed in order to keep the information in a logical reading order
    from the coarsest to the most granular.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com:demoeditor`：这是`demoeditor.com`的逆序，即我们示例公司的域名。信息的存在是为了作为前缀，以区分具有相同名称的另一个供应商的实体，并且它被逆序是为了保持从最粗略到最细粒度的逻辑阅读顺序。'
- en: '`978-2409002205`: This is a sample ISBN. Again, as soon as we can, and this
    is essential inside pivotal formats, we turn it back to an existing standard.
    There are norms for virtually every single piece of information!'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`978-2409002205`：这是一个示例ISBN。再次强调，一旦可能，并且这在关键格式中至关重要，我们就将其转换回现有的标准。几乎每一条信息都有规范！'
- en: '`library` and `books` are the parts of the URN that bear some functional value
    and we have not yet explained where they come from. Let’s say for now that `library`
    is the domain (the management unit of books and other entities related) and `books`
    is the chosen name to talk about these resources that `DemoEditor` manages. We
    will come back later to this.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`library`和`books`是URN中具有某些功能价值的部分，我们尚未解释它们的来源。现在我们先假设`library`是域（书籍和其他相关实体的管理单位）而`books`是用于描述`DemoEditor`管理的这些资源的名称。我们稍后会回到这个问题。'
- en: '`x24b72` instead of `books` and they would not mind at all; whereas introducing
    misunderstanding in the terms used by your information system is bound to create
    problems at some point.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`x24b72`代替`books`，他们根本不会介意；而使用你信息系统中的术语引入误解，最终必然会在某个时刻造成问题。'
- en: 'Let me tell you of an anecdote on this: I was consulting at a company in the
    information domain and one of the workshops I had with them was about designing
    a pivotal format around the people who bought the information. Marketing people
    and salespersons were there and, at some point, their voices started to rise as
    they disagreed on terms that were used differently. Their argument was about the
    relationship between a *prospect* and a *customer*. Marketing explained that customers
    are the best prospects since they already know the company, whereas the salespersons
    replied that the commercial pipe was quite clear concerning the fact that a cold
    lead becomes a hot lead, then a prospect, and then a customer if he buys something,
    leaving—by definition—the status of prospect. In fact, they both were right and
    something was simply missing in the model: the fact that “customer” and “prospect”
    are not names of entities, but business rules. If one includes in the model the
    notion of product proposition, then things get clearer: a customer of a given
    product is indeed a great prospect for another product in the catalog of the same
    company, but they are still not a customer for this second product.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你讲一个关于这个的轶事：我在一家信息领域公司担任顾问，与他们进行的一次研讨会是关于围绕购买信息的个人设计一个关键格式。营销人员和销售人员都在场，在某个时刻，他们的声音开始升高，因为他们对使用的术语有不同的看法。他们的争论是关于**潜在客户**和**客户**之间的关系。营销人员解释说，客户是最佳的潜在客户，因为他们已经了解公司，而销售人员则回答说，商业管道在事实上的确很清晰，一个冷线索变成热线索，然后变成潜在客户，最后如果购买了东西，就变成了客户，从而——根据定义——失去了潜在客户的状态。实际上，他们两个都是对的，模型中只是缺少了某些东西：即“客户”和“潜在客户”不是实体的名称，而是商业规则。如果模型中包含产品提案的概念，那么事情就会变得清晰：特定产品的客户确实是同一公司目录中另一产品的绝佳潜在客户，但他们仍然不是第二个产品的客户。
- en: Reading this, you might say that this situation was benign and that no harm
    was done since the discussion cleared out the problem. This would lead to ignoring
    two things. First, this misunderstanding created some real tensions between marketing
    and commerce and incomplete future sales reports, which lasted for months before
    I had the chance to spot the problem in the workshop organized by the CTO of the
    company. Second, when there is just an oral misunderstanding, this is indeed fine,
    but the real problem is that this mistake has been solidified into the information
    system (remember that you should never start working on layer 3 before having
    a good understanding of the analysis context in layer 2). If this was just a mistake
    in a single company, that would not be so bad, but even ERP editors (I will not
    cite any names) make the same mistake right into their default database models!
    Several of them sport data tables named `customers` and `suppliers`, which can
    cause lots of trouble.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这些内容，你可能会说这种情况是无害的，并且没有造成伤害，因为讨论澄清了问题。这会导致忽视两件事。首先，这种误解在营销和商业之间造成了一些真正的紧张关系，以及不完整的未来销售报告，这些问题持续了几个月，直到我有机会在公司CTO组织的工作坊中发现问题。其次，当只有口头误解时，这确实是好的，但真正的问题是这个错误已经被固化到信息系统（记住，你应在了解第二层的分析背景之后再开始处理第三层）。如果这只是单个公司的错误，那倒不是什么大问题，但即使是ERP编辑（我将不提及任何名字）也会在他们的默认数据库模型中犯同样的错误！其中一些拥有名为`customers`和`suppliers`的数据表，这可能会引起很多麻烦。
- en: '![Figure 9.1 – Bad semantics](img/B21293_09_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 错误的语义](img/B21293_09_01.jpg)'
- en: Figure 9.1 – Bad semantics
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 错误的语义
- en: 'What happens in this case when a given company you work with is not only one
    of your customers but also one of your suppliers? This happens very often in the
    negotiation market, and, generally, people would not make this mistake. However,
    in this ERP, which I will not cite, the editor clearly did not do the job of understanding
    all of the markets they wanted to address and tried to propose a generic model
    that was not adapted to any company where this situation would happen. Of course,
    how do you think the consultants handled the problem when discovered? You got
    it: they tried to compensate for the layer 2 problem using layer 3 tricks. In
    a particular case, I remember, the consultants first started creating a database
    trigger that, when a customer changed address or bank coordinates, would replicate
    the modified information into the `suppliers` data table. Then, a few months later
    since the problem happened, they implemented the same trigger to modify the `customers`
    data table when a supplier was the modifier and created an infinite loop that
    crashed the database!'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你合作的公司不仅是你的客户，也是你的供应商时，这种情况会发生什么？这在谈判市场中非常常见，而且通常人们不会犯这个错误。然而，在这个我将不提及的ERP系统中，编辑显然没有理解他们想要覆盖的所有市场，并试图提出一个通用的模型，该模型不适合任何可能发生这种情况的公司。当然，当你发现这个问题时，你认为顾问们是如何处理的？答案是：他们试图使用第三层技巧来弥补第二层的问题。我记得，顾问们首先创建了一个数据库触发器，当客户更改地址或银行坐标时，会将修改后的信息复制到`suppliers`数据表中。然后，几个月后，当问题发生时，他们实施了相同的触发器来修改`customers`数据表，当供应商是修改者时，创建了一个无限循环，导致数据库崩溃！
- en: Things would have been so much easier if the data tables had been designed with
    a single `actors` data table (or `individuals` or `organizations` if you only
    deal with this kind of actors; again, semantics matters). The notion of a customer
    would simply arise from a business rule that states that an *actor* is a *customer*
    if a record exists in the `orders` data table pointing at this actor, and with
    a value date not older than 18 months. The same would be applicable to a supplier,
    which would be a business rule stating that an *actor* is a *supplier* if a record
    exists in the `incoming-orders` data table linked to this actor, or if an entry
    in the `equipment` data table has a guaranteed owner pointing at this actor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据表是设计成一个单独的`actors`数据表（或者如果你只处理这类演员，可以是`individuals`或`organizations`），事情将会简单得多。客户的观念将简单地由一条业务规则产生，该规则指出，如果一个记录存在于指向此演员的`orders`数据表中，并且日期值不超过18个月，则该*演员*是一个*客户*。同样的规则也适用于供应商，即如果存在指向此演员的`incoming-orders`数据表中的记录，或者`equipment`数据表中的条目有一个保证所有者指向此演员，则该*演员*是一个*供应商*。
- en: '![Figure 9.2 – Correct semantics](img/B21293_09_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 正确的语义](img/B21293_09_02.jpg)'
- en: Figure 9.2 – Correct semantics
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 正确的语义
- en: 'Those business rules are, of course, purely arbitrary ones, but notice that
    the entity schema does not change a bit if the rules evolve. This may be the most
    important thing in this model. If, at some point, marketing decides that the rule
    should be that the customers list contains only the actors with whom we have done
    business in the past 12 months instead of 18, what will happen? Here starts the
    real problems in the bad design, as you will have to create a migration routine
    to get your customers out of the table and activate the archive procedure. Since
    you may have orders pending, the risk is to lose a pointer to the right data and
    so many other things can go awry. With the right model design, on the other hand,
    what should we do? Well, simply modify the business rule! If it is in code, you
    can change `18` to `12` and recompile. If you were careful enough beforehand,
    this business rule is in a custom property somewhere and you will not even have
    to recompile or deploy anything. Also, if you had a reporting API producing the
    list of customers, then it is your lucky day: you modify this implementation and,
    without any other action, the behavior is changed everywhere in your system!'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那些业务规则当然是纯粹任意的，但请注意，即使规则发生变化，实体模式也不会有任何改变。这可能是这个模型中最重要的东西。如果营销部门在某个时刻决定规则应该是客户列表只包含过去12个月内与我们有过业务往来的演员，而不是18个月，会发生什么？这标志着糟糕设计中的真正问题开始出现，因为你将不得不创建一个迁移程序来将客户从表中移除并激活存档程序。由于你可能有一些待处理的订单，风险是失去指向正确数据的指针，以及许多其他事情可能会出错。另一方面，如果有一个正确的模型设计，我们应该怎么做？嗯，简单地修改业务规则！如果它在代码中，你可以将`18`改为`12`并重新编译。如果你事先足够小心，这个业务规则可能在某个自定义属性中，你甚至不需要重新编译或部署任何东西。此外，如果你有一个生成客户列表的报表API，那么你今天真是太幸运了：你修改了这个实现，而无需采取任何其他行动，系统的每个地方的行为都会改变！
- en: 'You might think that these examples are too easy and that this approach will
    not stand the complexity of a real system; it is actually quite the contrary because
    this approach is based on designing the business complexity in the software model.
    In the preceding example, for instance, we could very well have a different business
    definition of the addresses and the owner of the information system could decide
    that addresses should not be shared between customers and suppliers, or maybe
    only in some cases. For example, some addresses would be used only for the customers,
    such as the delivery address. No problem: we would adjust the model by keeping
    the addresses separate from the actors, and then add the “type” information to
    them, in order for the delivery address to be pointed at by the actors only when
    they are customers. We could even add some authorization rules on this to ensure
    that this address is never even read when the actor is seen as a supplier! Again,
    a good design would have allowed all this to be smooth but you have to get this
    clean design. Also, this happens to be one of the hardest bits of your architect
    job – gathering domain experts and coming up with something close to perfection.
    Fortunately, methods exist to structure this job. It is time to introduce DDD.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这些例子太简单了，并且这种方法无法应对真实系统的复杂性；实际上，恰恰相反，因为这个方法是基于在软件模型中设计业务复杂性。例如，在前面的例子中，我们完全可以有一个不同的业务定义地址和信息系统的所有者可以决定地址不应该在客户和供应商之间共享，或者可能只在某些情况下共享。例如，一些地址将仅用于客户，如交货地址。没问题：我们会通过将地址与演员分开来调整模型，然后为它们添加“类型”信息，以便在演员是客户时，只有交货地址才能被指向。我们甚至可以添加一些授权规则来确保当演员被视为供应商时，这个地址甚至不会被读取！再次强调，良好的设计本应允许这一切顺利，但你必须获得这种清晰的设计。此外，这恰好是你架构师工作中最困难的部分之一——汇集领域专家并得出接近完美的结果。幸运的是，存在一些方法来结构化这项工作。是时候介绍DDD了。
- en: DDD
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDD
- en: 'DDD (please note the last *D* is *not* for *development*, but indeed *design*)
    is a complete method for functional design that has been created and documented
    by Eric Evans, in his foundational book, *Domain-Driven Design: Tackling Complexity
    in the Heart of Software*, released in 2003 and, since then, has been famously
    known as *the blue book*. This important piece of work has influenced many software
    designers, despite it being quite a difficult read. Through its hundreds of pages,
    this book dispenses lots of best practices in modeling data and functional design.
    It is oriented towards software but everything it says can help, even before the
    first line of code, and it is a wealth of advice for understanding your business
    functions before you even start thinking about automating them through IT solutions.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: DDD（请注意，最后一个 *D* 并非指 *开发*，而是指 *设计*）是由埃里克·埃文斯创建并记录在其基础书籍《领域驱动设计：软件核心的复杂性处理》（2003年发布，自那时起，它就广为人知为
    *蓝皮书*）中的一种完整的功能设计方法。尽管这本书相当难读，但它对许多软件设计师产生了影响。通过其数百页的内容，这本书提供了大量关于数据建模和功能设计的最佳实践。它面向软件，但它所说的每一件事都可以在编写第一行代码之前提供帮助，并且它是在你甚至开始考虑通过IT解决方案自动化业务功能之前，理解你的业务功能的宝贵建议。
- en: 'That being said, our goal here is not to talk too much about the book, or to
    unroll the complete method. You have to read it yourself if you want to get the
    full advantage of such a seminal work, or watch Eric Evans’ excellent presentation
    at [https://youtu.be/lE6Hxz4yomA](https://youtu.be/lE6Hxz4yomA), where the expert
    explains the essentials of the method, which are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们在这里的目标不是过多地谈论书籍，或者展开完整的方法。如果你想充分利用这部开创性作品的全部优势，你必须自己阅读它，或者观看埃里克·埃文斯在[https://youtu.be/lE6Hxz4yomA](https://youtu.be/lE6Hxz4yomA)上的出色演讲，专家在那里解释了该方法的核心要素，如下所示：
- en: Creative collaboration of domain experts and software experts
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域专家和软件专家的创造性协作
- en: Exploration and experimentation
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索与实验
- en: Emerging models shaping and reshaping the ubiquitous language
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形成和重塑通用语言的模型
- en: Explicit context boundaries
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确的上下文边界
- en: Focus on the core domain
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于核心领域
- en: 'What we will now do is show how some tools from the book can be used in order
    to help our design of a pivotal format, aiming at a nice business/IT alignment.
    Going back to our sample company, how could we describe what we are doing from
    a general point of view? One could say we are in the business domain called *book
    edition*. We need a subdomain for authoring and another one for selling. These
    two can be considered core domains since this is the bread and butter of our sample
    company: supervising the writing of books and selling them. There will also be
    some supporting subdomains such as human resources or accounting: those are not
    directly implicated in the core value-addition work of the company but are nonetheless
    absolutely necessary for it to work correctly.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要展示的是，如何将书中的一些工具用于帮助我们的关键格式设计，以实现良好的业务/IT 对齐。回到我们的样本公司，从一般的角度来看，我们正在做什么？有人可能会说，我们处于名为
    *书版* 的业务领域。我们需要一个用于创作的子领域和一个用于销售的子领域。这两个可以被认为是核心领域，因为这是我们样本公司的主营业务：监督书籍的编写和销售。还有一些辅助子领域，如人力资源或会计：这些领域虽然不直接涉及公司的核心增值工作，但对于其正确运作却是绝对必要的。
- en: 'The word “edition” here refers to literature in general but editors and salespeople
    do not have the same vocabulary for books: the former talk about a *work* and
    the latter about a *product*. Still, this is a similar entity. Also, they will
    not use the same attributes. Editors will be very interested in the number of
    chapters, the progress made in the writing, and other such attributes of a book,
    which is mostly a work in progress for them (when they go to sales, their job
    is basically done). On the other hand, a salesperson will check attributes such
    as the price of the book and maybe even the weight to calculate the transportation
    fees. Again, there are attributes, however, that are of interest for both roles:
    the number of pages, the ISBN of the book, the date of publication, and so on.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“版”一词指的是一般性的文学，但编辑和销售人员对于书籍的词汇并不相同：前者谈论的是 *作品*，而后者谈论的是 *产品*。尽管如此，这仍然是一个相似的实体。此外，他们也不会使用相同的属性。编辑将非常关注章节数量、写作进度以及其他类似的书籍属性，因为对于他们来说，书籍大多是一个正在进行中的作品（当他们去销售时，他们的工作基本上就完成了）。另一方面，销售人员将检查诸如书籍价格和可能甚至重量以计算运输费用等属性。再次强调，尽管如此，对于这两个角色都有兴趣的属性：页数、书籍的ISBN、出版日期等等。
- en: To solve these apparent paradoxes in the naming and potential difficulties in
    the separated management of attributes, DDD proposes two concepts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决命名中的这些明显悖论以及在属性分离管理中可能遇到的潜在困难，DDD提出了两个概念。
- en: The first one is the concept of **ubiquitous language**. DDD recognizes that
    different names can be used in different contexts for the same functional entity,
    and thus can account for local jargon while keeping a unique name shared between
    all actors of the information system. In our example, that could be “books,” which
    is something sufficiently significant and still widely accepted to designate what
    editors call “works” and salespeople call “products.” To be perfectly clear, DDD
    does not recommend finding a single expression for each concept and abandoning
    all others, but rather deciding on a given expression that will be shared by all
    actors of the model (hence the ubiquitous qualification). Local jargons are not
    forbidden, because they are generally useful for fast communication inside a given
    context, but the *standard* expression should be used every time there is the
    slightest risk related to misunderstanding.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个概念是**通用语言**。DDD认识到，对于同一功能实体，在不同的上下文中可以使用不同的名称，因此可以解释地方行话，同时保持信息系统所有参与者之间共享的唯一名称。在我们的例子中，这可能是“书籍”，这是一个足够重要且广泛接受的名称，可以用来指代编辑所说的“作品”和销售人员所说的“产品”。为了完全清楚，DDD不推荐为每个概念找到一个单一的表达式并放弃所有其他表达，而是决定一个将由模型的所有参与者共享的表达式（因此有“通用”的称号）。地方行话不是被禁止的，因为它们通常在特定上下文内的快速沟通中很有用，但每次有轻微误解风险时，都应该使用*标准*表达式。
- en: The second concept introduced by DDD is the **bounded context**, which is the
    perimeter containing entities and business rules, inside of which the vocabulary
    is consistent. We talked about this context in which the alternate vocabulary
    can be used without causing trouble if limited to the actors of this context only;
    this context is indeed what is called the bounded context. Finding the bounded
    context in a complete business domain is important because it helps define where
    the interactions are and, as a consequence, where it is most important to be perfectly
    clear on the language. Bounded contexts can be aligned to business subdomains,
    but this is not mandatory. As we will see in the next chapter, the question of
    the entity life cycle has to be taken into account as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: DDD引入的第二个概念是**边界上下文**，它包含实体和业务规则的范围，在这个范围内，词汇是一致的。我们讨论了这种上下文，其中可以无障碍地使用替代词汇，前提是仅限于该上下文的参与者；这个上下文确实就是所谓的边界上下文。在完整的业务域中找到边界上下文很重要，因为它有助于定义交互在哪里，因此，在哪里对语言的完美清晰性最为重要。边界上下文可以与业务子域对齐，但这不是强制性的。正如我们将在下一章中看到的，还必须考虑实体生命周期的问题。
- en: 'To summarize this graphically, see *Figure 9**.3* for bounded contexts for
    our edition domain:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了图形化地总结这一点，请参阅*图9.3*中的我们版本域的边界上下文：
- en: '![Figure 9.3 – Bounded contexts in Edition DDD](img/B21293_09_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 版本DDD中的边界上下文](img/B21293_09_03.jpg)'
- en: Figure 9.3 – Bounded contexts in Edition DDD
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 版本DDD中的边界上下文
- en: Since we obey an **Agile approach** to the design and development of our sample
    information system, we will not go further into the design than this very first
    step for now. Once we have applied this first level of knowledge to the creation
    of a first version of the data referential (see [*Chapter 10*](B21293_10.xhtml#_idTextAnchor344)),
    we will dig a bit deeper as needed. Indeed, trying to cover the whole business
    domain would take too long and too many pages without adding anything to the understanding
    of the method. Before we move on, let us refresh our knowledge of **data referential**.
    Data referential is a service that is dedicated to handling data for a particular
    functional entity but also metadata, data history, authorization, governance,
    and many other functions as a complement to the traditional database that only
    handles persistence. Data referential is the basis for good **master** **data
    management**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对样本信息系统的设计和开发遵循**敏捷方法**，我们现在不会进一步深入设计，只会进行这一非常初步的步骤。一旦我们将这一层次的知识应用于创建数据参照的第一版（见[*第10章*](B21293_10.xhtml#_idTextAnchor344)），我们将在需要时进一步深入。实际上，试图涵盖整个业务域会花费太多时间和篇幅，而且不会增加对方法理解的帮助。在我们继续之前，让我们回顾一下**数据参照**的知识。数据参照是一种专门用于处理特定功能实体数据的服务，但也包括元数据、数据历史、授权、治理以及许多其他功能，作为仅处理持久性的传统数据库的补充。数据参照是良好**主数据管理**的基础。
- en: Application to clean information system architecture
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用于清洁的信息系统架构
- en: Now that we are clear on the semantics and the domain decomposition of our business
    model, we can take a step forward in the design (though technical questions will
    only be introduced in the next chapter) and start envisioning how these entities
    are going to be introduced to the IT system. Until now, everything we said could
    be applied to a non-software-based information system. Starting from this section,
    we will admit the reality of there not being any such information systems in design
    anymore and that *every* company is now a software company. Since we are talking
    about entities, and their pivotal format is considered as designed, the next step
    is to talk about the way they will be manipulated—and thus stored—by the information
    system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚了我们业务模型的语义和领域分解，我们可以向前迈出一大步（尽管技术问题将在下一章介绍）并开始设想这些实体将如何被引入IT系统。到目前为止，我们所说的所有内容都可以应用于非基于软件的信息系统。从本节开始，我们将承认在设计中不再存在这样的信息系统，并且*每个*公司现在都是一个软件公司。既然我们在谈论实体，并且它们的关键格式被认为是设计的，下一步就是讨论信息系统将如何操作（因此存储）它们。
- en: Using entities in referential applications
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在指代应用中使用实体
- en: The very first question about storing and manipulating functional entities is
    about their decomposition. Since complex business attributes may have hundreds
    of attributes to qualify them, it is of course necessary to at least categorize
    them, and, if possible, create a tree-like structure to classify them. Entities
    always have some base attributes that are used by everyone in the information
    system, and the rest of the data attributes are mostly related to one subdomain,
    or, at least, one of these domains can be selected for each as the ideal maintainer
    of the data quality. This decomposition is often used to represent data referential
    as flowers (see *Figure 9**.4*), with the core of the flower containing the shared
    data and the petals around the core containing the subdomain-related data. As
    a petal is always attached to the core, *Figure 9**.4* shows that peripheral data
    has no meaning without identifying the core data of an entity. It also states
    that petals can be independent and that a flower without some of the petals might
    still be useful to some users. Finally, the metaphor shows that, if the core of
    the flower is thrown away, the petals go away with it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于存储和操作功能实体的第一个问题就是它们的分解。由于复杂的业务属性可能有数百个属性来界定它们，当然有必要至少对它们进行分类，如果可能的话，创建一个树状结构来分类它们。实体总是有一些基础属性，这些属性被信息系统中的每个人使用，其余的数据属性大多与一个子域相关，或者至少，每个子域都可以被选为数据质量的理想维护者。这种分解通常用于将数据指代表示为花（参见*图9.4*），花的中心包含共享数据，而围绕中心的瓣片包含与子域相关的数据。由于瓣片总是附着在中心，*图9.4*显示，没有识别实体的核心数据，外围数据就没有意义。它还指出，瓣片可以是独立的，而且即使缺少一些瓣片，某些用户仍然可能觉得花是有用的。最后，这个隐喻表明，如果花的中心被丢弃，瓣片也会随之而去。
- en: 'The application of this approach to our `book` entity should be quite obvious,
    following what we had said before:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法应用于我们的`book`实体应该是相当明显的，根据我们之前所说的：
- en: '![Figure 9.4 – Metaphor of a flower for referential](img/B21293_09_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 指代的花的隐喻](img/B21293_09_04.jpg)'
- en: Figure 9.4 – Metaphor of a flower for referential
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 指代的花的隐喻
- en: Though we had only talked about the two main petals before, there might be some
    others around the flower, such as the one about the physical production of the
    books, and the one about the storage of the printed units. Again, since this book
    is about the method and not about designing an IT system for a real book editing
    company, we will not go into these details; but you should definitely at least
    get to know all the petals in an entity flower when you design one for real, even
    if you do not get all the details of each petals in your first analysis.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前只讨论了两个主要的花瓣，但花周围可能还有一些其他的花瓣，例如关于书籍物理生产的那个，以及关于印刷单元存储的那个。再次强调，由于这本书是关于方法而不是关于为真正的图书编辑公司设计IT系统，我们不会深入这些细节；但当你真正设计一个实体花时，你绝对至少应该了解所有花瓣，即使你第一次分析中不能了解每个花瓣的所有细节。
- en: Managing the life cycle of entities
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理实体的生命周期
- en: Also, since we question the design of the storage, it is important to include
    time in the equation, as was explained in [*Chapter 4*](B21293_04.xhtml#_idTextAnchor121).
    A common mistake once an entity is designed is to think that we need to store
    and manipulate the data attributes that have appeared during this phase. However,
    there are many other things around the entity that have an impact on storage.
    Time is, of course, the first one and an important entity generally needs to have
    all its states in time persisted and not the last known one. In some cases, versions
    and branches of entities might have to be handled. Metadata on the entity (who
    created it, which state it is in, etc.) might be seen as a dedicated petal for
    history, but it generally is a complete set of data attached to the entity and
    available for all petals while still not being at the core of the flower, since
    it is not always necessary to have this metadata.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们质疑存储的设计，因此包含时间是重要的，正如在[*第4章*](B21293_04.xhtml#_idTextAnchor121)中解释的那样。一旦设计了一个实体，一个常见的错误就是认为我们需要存储和处理在此阶段出现的所有数据属性。然而，围绕实体的许多其他事物都会影响存储。时间当然是第一个，一个重要的实体通常需要在其整个生命周期中持久化所有状态，而不仅仅是最后已知的状态。在某些情况下，可能需要处理实体的版本和分支。实体的元数据（谁创建了它，它处于什么状态等）可能被视为历史的一个专用花瓣，但它通常是与实体相关联的完整数据集，对所有花瓣都可用，尽管它不是花朵的核心，因为并不总是需要这些元数据。
- en: 'If we stick to time, traceability of the data change is, of course, the obvious
    thing we think about, but taking time into account is much more than just storing
    the changes of each attribute each time they are modified: it is about modeling
    the evolution of the entity in time as an element of business knowledge as well
    and making it possible to understand not only how the data changed (addresses
    an array with index 1 removed and another entity added) but what was the functional
    reason behind it (e.g., the person moved out and recorded their change of address).
    This is what is called the **entity life cycle**. Designing it is harder than
    listing the attributes of an entity because it is not a usual design activity
    and also because there are many ways to introduce time, each one complementary
    to the others. For example, it may be used to think of the statuses the entity
    will go through in its lifetime (created, draft, valid, etc., until it reaches
    the archived state). However, there may be times when having a design closer to
    what would be the business process centered on an important entity will be easier
    to communicate.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们坚持时间，数据变化的可追溯性当然是显而易见的事情，但考虑时间不仅仅是每次修改时存储每个属性的更改：它还涉及到将实体的演变建模为业务知识的一个元素，并使其能够理解数据是如何变化的（例如，删除索引为1的数组元素并添加另一个实体），以及背后的功能原因是什么（例如，某人搬走并记录了他们的地址变更）。这就是所谓的**实体生命周期**。设计它比列出实体的属性更困难，因为它不是一个常规的设计活动，也因为引入时间的方式有很多，每一种都是相互补充的。例如，它可以用来思考实体在其生命周期中将经历的状态（创建、草案、有效等，直到达到存档状态）。然而，有时拥有一个更接近以重要实体为中心的业务流程的设计可能会更容易沟通。
- en: '*Figure 9**.5* shows how the time criteria could be introduced on the `book`
    entity and what the life cycle would look like if we start from different steps
    in the life of a book, from the edition domain point of view (not the reader,
    of course, as this would lead to a completely different information system):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.5* 展示了如何在“书籍”实体上引入时间标准，以及如果我们从书籍生命周期中的不同步骤开始，从版本域的角度来看（当然，不是从读者的角度，因为这会导致一个完全不同的信息系统）生命周期会是什么样子：'
- en: '![Figure 9.5 – The life cycle of a book](img/B21293_09_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 书籍的生命周期](img/B21293_09_05.jpg)'
- en: Figure 9.5 – The life cycle of a book
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 书籍的生命周期
- en: As you can see, the top part of the diagram shows what will happen in the lifetime
    of the book in the editing company. It always starts from an idea, even if this
    phase is extremely short, such as the idea coming from a meeting with a candidate
    author. In this case, the process will directly jump to the second phase. Phases
    look quite linear here, but that does not mean they have to be. For example, when
    a second edition is created, the writing and correcting phase will start again,
    but generally speaking, this diagram helps to envision the entity not only as
    the sum of data attributes but as a living object in the information system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，图表的上半部分显示了在编辑公司中书籍在其生命周期内会发生什么。它总是从一个想法开始，即使这个阶段非常短暂，比如来自与潜在作者会议的想法。在这种情况下，流程将直接跳到第二阶段。在这里，阶段看起来相当线性，但这并不意味着它们必须如此。例如，当创建第二版时，写作和校对阶段将再次开始，但一般来说，这个图表有助于将实体视为不仅数据的总和，而且是一个信息系统中的活生生的对象。
- en: 'The evolution of an entity in time, of course, has an impact on many aspects
    of its data, but also on the business rules that apply to it. In the diagram,
    I only showed a few examples of such impact:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实体随时间的变化，当然会影响其数据的许多方面，但也会影响适用于它的业务规则。在图表中，我只展示了这种影响的几个示例：
- en: Tags associated with the book in order to categorize them will evolve at first,
    but soon will be fixed and cannot evolve afterward, as it would create problems
    if the subject of a book evolved too much once the salespersons have started talking
    about it on salons, social media or to resellers.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与书籍相关联的标签，用于对其进行分类，最初会发生变化，但很快就会固定，之后不能再变化，因为如果一本书的主题在销售人员开始在其沙龙、社交媒体或向经销商谈论它之后变化太多，就会产生问题。
- en: 'Actors working on a book will, of course, evolve throughout its life cycle:
    marketing will create the vision of the book, editors will help the authors create
    it, and at some point, after the content is reviewed and validated, the main actors
    will be the salespersons, until the book reaches archiving, when editors will
    work a bit on the book again.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一本书的制作过程中，参与其中的角色当然会随着其生命周期而变化：市场营销将创造书籍的愿景，编辑将帮助作者创作，在内容经过审查和验证后，主要角色将变为销售人员，直到书籍达到存档阶段，此时编辑将再次对书籍进行一些工作。
- en: An example of a business rule has been provided, though there are always many
    in an important entity of the information system. In this diagram, I showed that
    the business rule is *public*, which is false as long as the book is not validated
    by the reviewers and becomes true after, with the particular case (not shown here)
    that, once public, a book cannot go back to being private, as people have been
    informed about it.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经提供了一个业务规则的示例，尽管在信息系统的重要实体中总是有许多这样的规则。在这个图表中，我展示了业务规则是*公开的*，只要书籍没有被审阅者验证，这就是错误的，之后，在特定情况下（此处未展示），一旦公开，一本书就不能再回到私有状态，因为人们已经了解它了。
- en: 'The notion of `status` attribute that an editor would change on the `book`
    entity instance. But it may also be bound to a business rule stating that a book
    can become *ready to publish* once the following tasks have been completed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑会在`book`实体实例上更改的`status`属性的概念。但它也可能与一条业务规则绑定，该规则指出一旦以下任务完成，一本书就可以变为*准备发布*状态：
- en: Its main editor or two editors have given their vote for it.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的主要编辑或两位编辑已经对其投了票。
- en: The author has signed their contract and, in particular, the financial amendments.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者已经签署了他们的合同，特别是财务修订条款。
- en: The printing company has approved the provided files.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 印刷公司已经批准了提供的文件。
- en: Business rules can also cascade on each other. For example, we could authorize
    payment of an author only if their bank details have been validated for less than
    three months, which means verifying the bank owning the account, which means,
    in turn, checking the SWIFT number is correct, and so on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 业务规则也可以相互级联。例如，我们只能授权支付给作者，如果他们的银行详细信息已经验证少于三个月，这意味着验证拥有该账户的银行，这意味着反过来检查SWIFT号码是否正确，等等。
- en: 'Finally, all of this is complicated further by the fact that some business
    rules may be stabilized as data at some point. This happens for performance reasons,
    where the computations are so long that it becomes acceptable that the result
    of the calculation is not always up-to-date (which happens when reading the value
    is more frequent than computing its result anew). There might also be some functional
    reasons as to why a state evolves against business rules and then gets fixed,
    without the possibility of going back for regulatory reasons (typically, this
    is what happens when an entity reaches an `archived` state: its content is then
    removed from the database and placed in archives, so, returning to an `active`
    state is not possible, since the data is now only accessible by archivists). In
    this case, the state overrides the business rule itself (or the business rule
    starts reading the recorded state and continues calculations if it is not overridden
    by this state).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有这些都因某些业务规则可能在某个时刻稳定为数据而变得更加复杂。这出于性能原因，计算过程如此之长，以至于计算结果不总是最新的（这发生在读取值比重新计算其结果更频繁时）。也可能有一些功能上的原因，导致状态违反业务规则并最终固定，而没有返回的可能性（通常，当一个实体达到“存档”状态时就会发生这种情况：其内容随后从数据库中删除并放入存档，因此返回“活跃”状态是不可能的，因为数据现在只能由档案保管员访问）。在这种情况下，状态覆盖了业务规则本身（或者业务规则开始读取记录的状态，并在没有此状态覆盖的情况下继续计算）。
- en: Relation between subdomains and time
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子域与时间的关系
- en: This notion of a life cycle is also important because it helps define important
    entities, and thus subdomains, in your information system. For example, a book
    is definitely a major entity in the domain because, as we have shown, it has a
    life cycle. Authors also have a life cycle in the information system because,
    as they are created in it, their contact data will change, they will hopefully
    write several books, and, at some point, will be erased from the database after
    a given time of inactivity (under which there is certainly a regulatory business
    rule, such as the GDPR in Europe, for example). However, tags are not an important
    entity, as they do not have a life cycle outside of books. Sure, a tag might disappear,
    but this will only be a result of there being no more books in this category.
    It is even easier to decide that the addresses of authors are definitely not a
    major entity, as they will never exist outside of an author, and they will always
    disappear with their parent entity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种生命周期概念同样重要，因为它有助于定义信息系统中重要的实体，以及子域。例如，一本书无疑是该领域的主要实体，因为我们已经展示过，它有一个生命周期。作者在信息系统中也有生命周期，因为他们在其中被创建时，他们的联系数据会发生变化，他们可能会写几本书，并在某个时间点，在一段不活跃时间后（在此期间，肯定存在一些监管业务规则，例如欧洲的
    GDPR），将从数据库中删除。然而，标签并不是一个重要的实体，因为它们在书籍之外没有生命周期。当然，一个标签可能会消失，但这只会是这个类别中没有更多书籍的结果。决定作者地址绝对不是主要实体甚至更容易，因为它们永远不会存在于作者之外，并且它们将始终随着其父实体消失。
- en: The definition of the entity itself can evolve over time, which is completely
    natural in an Agile approach where we do not try to have everything conceptualized
    at first as we know that things will get clearer in time, and we should just prepare
    for the changes that will be added in the next versions (while still knowing enough
    of the business to ensure compatibility and smooth evolution of the system). The
    cutting of subdomains should normally never evolve in time. Additional domains
    may appear following a change of strategy of the company owning the information
    system, but there should be something majorly important to justify such a low-level
    change.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的定义本身可能会随着时间的推移而演变，这在敏捷方法中是完全自然的，因为我们知道事情会在时间中变得更加清晰，我们应该只为下一个版本中将要添加的变化做准备（同时了解足够的业务知识，以确保系统的兼容性和平稳演变）。子域的切割通常永远不会随时间演变。信息系统的拥有公司改变战略后，可能会出现额外的领域，但应该有一些非常重要的事情来证明这种低级变化是合理的。
- en: Now that we have seen DDD in action and its relation to a correctly structured
    information system, we are going to talk more specifically about the consequence
    of all of this in the design of API contracts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 DDD 的实际应用及其与正确结构化信息系统之间的关系，我们将更具体地讨论所有这些在 API 合同设计中的后果。
- en: Link to the API and services
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接到 API 和服务
- en: We spent a lot of time talking about the entity from the point of view of its
    evolution and not with a data focus, but this is done on purpose because we generally
    take too much time defining the attributes and not enough thinking about the business
    entity as a whole, living object. Now that this is done, let’s use the final section
    of this chapter to come back to the notion of services and API that we have detailed
    in the previous chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多时间从实体的演变角度而不是数据角度来讨论实体，但这是故意的，因为我们通常花太多时间定义属性，而不是足够地思考整个业务实体，一个活生生的对象。现在这已经完成，让我们利用本章的最后部分回到我们在上一章详细说明的服务和API的概念。
- en: Including time in an API
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在API中包含时间
- en: 'One of the first consequences of thinking about the entity as a whole, including
    its history, is that the writing methods on a corresponding API should not work
    exactly the same. As reading methods, they are similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将实体视为一个整体（包括其历史）思考的第一个后果之一是，相应API上的编写方法不应完全相同。作为读取方法，它们类似于以下内容：
- en: '`GET on /api/entity`: This is used to read the list of entities'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET on /api/entity`: 这用于读取实体列表'
- en: '`GET on /api/entity/{id}`: This is used to read a given entity'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET on /api/entity/{id}`: 这用于读取给定实体'
- en: 'However, if you want to take action and be able to access history, you should
    add some methods such as the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想采取行动并能够访问历史记录，您应添加一些方法，如下所示：
- en: '`GET on /api/entity/{id}?valuedate={date}`: This is used to read a given entity
    state at a given date'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET on /api/entity/{id}?valuedate={date}`: 这用于读取给定实体的特定日期状态'
- en: '`GET on /api/entity/{id}/history`: This is used to read the full history of
    a given entity'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET on /api/entity/{id}/history`: 这用于读取给定实体的完整历史记录'
- en: 'Changes should also be made to the writing parts of the API, with one method
    that does not change:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应对API的编写部分进行修改，但有一个方法保持不变：
- en: '`POST on /api/entity`: This will always be about creating an entity instance.
    (Do not forget to follow the standards and send a `201` HTTP status code, together
    with a *Location* response header containing the URL of the resource just created.)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST on /api/entity`: 这始终是关于创建实体实例。（不要忘记遵循标准并发送`201` HTTP状态码，以及包含刚创建的资源URL的`Location`响应头。）'
- en: 'However, the traditional calls for an API are limited when you think in terms
    of a complete life cycle:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你从完整生命周期角度思考时，API的传统调用是有限的：
- en: '`PUT on /api/entity/{id}`: This should not be allowed as it destroys the eventual
    consistency and the ability to avoid locks, as was explained before.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT on /api/entity/{id}`: 这不应被允许，因为它会破坏最终一致性以及避免锁的能力，如前所述。'
- en: '`DELETE on /api/entity/{id}`: This should also be adjusted, not in its exposition
    but in how it works. Most of the time, since the resource is not really removed
    but only made unavailable by reaching an `archived` or `disabled` status, the
    equivalent modification call could be used in the same way and be more explicit.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE on /api/entity/{id}`: 这也应进行调整，不是在其表述上，而是在其工作方式上。大多数时候，由于资源并没有真正被删除，而是通过达到`存档`或`禁用`状态使其不可用，因此可以使用等效的修改调用以相同的方式进行，并且更加明确。'
- en: 'Also, an existing but lesser-known verb should be used in order to act on the
    state of the entity:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应使用一个现有但不太为人知的动词来对实体的状态进行操作：
- en: '`PATCH on /api/entity/{id}`: This together with a request body content, following
    `RFC 6902` (JSON Patch), should be used to write the data in a progressive, eventually
    consistent, and lock-free way (optimistic and pessimistic locks have been explained
    in [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164))'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH on /api/entity/{id}`: 这与请求体内容一起，遵循`RFC 6902`（JSON Patch），应用于以渐进的、最终一致的和无锁的方式（乐观锁和悲观锁已在[*第五章*](B21293_05.xhtml#_idTextAnchor164)中解释）写入数据'
- en: '`PATCH on /api/entity/{id}?valuedate={date}`: This can also be allowed in some
    cases where the history of the entity does not strictly follow the flow of orders
    in the API server, and the value date should be taken into account'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH on /api/entity/{id}?valuedate={date}`: 在某些情况下也可以允许，当实体的历史记录并不严格遵循API服务器的订单流程时，应考虑价值日期。'
- en: We will come back to these definitions in the next chapter, *Master Data Management*,
    and show the implementation of them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章，*主数据管理*中回到这些定义，并展示它们的实现。
- en: Aligning an API to subdomains and the consequences
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将API与子域对齐及其后果
- en: If you use a strict service architecture, all major entities, and thus all business
    subdomains, should have their dedicated process. However, since we said they should
    have their own API (minor entities will be under the major entities of the domain
    they are related to; for example, addresses will be in `/api/authors/{id}/addresses`),
    which equates to the fact that one API should always have its own process. Also,
    if you follow the rule of one process in one Docker container, you will have the
    equivalence of one API to one Docker service (scalability taken into account,
    as a service is a set of Docker containers of the same image).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用严格的服务架构，所有主要实体以及因此所有业务子域都应该有它们自己的流程。然而，由于我们说它们应该有自己的API（次要实体将位于它们相关的域的主要实体之下；例如，地址将在`/api/authors/{id}/addresses`中），这相当于一个API始终应该有自己的流程。此外，如果你遵循一个流程在一个Docker容器中的规则，你将有一个一个API对应一个Docker服务的等效性（考虑到可伸缩性，因为服务是一组相同镜像的Docker容器）。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker is the most known implementation of the principle of containerization
    for software installation. This technology allows the deployment of instances
    of self-contained **black boxes** of software, which contain every dependency
    needed and remain isolated from other instances, while not necessitating a heavy
    mechanism such as virtualization.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是软件安装中容器化原则最知名的实现。这项技术允许部署自包含的**黑盒**软件实例，这些实例包含所需的所有依赖项，并保持与其他实例的隔离，同时不需要像虚拟化这样的重型机制。
- en: If you consider that all calls should go through an API since they are the guarantee
    of unique business rules management and source of truth for a given API, then
    that means that nobody but the API exposition will ever access the application
    layer. In this case, why bother to separate these two layers? In the next chapter,
    we will follow this simple rule and implement API business codes directly inside
    the ASP.NET controllers. If you’re wondering about validations and how they can
    be done as soon as possible, then deserialization will take care of a good part
    of all this, and preconditions inside the implementation code will do the rest.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为所有调用都应该通过API进行，因为它们是唯一业务规则管理和给定API的真相来源，那么这意味着除了API展示之外，没有人会访问应用层。在这种情况下，为什么还要费力去分离这两个层呢？在下一章中，我们将遵循这个简单的规则，并将API业务代码直接实现在ASP.NET控制器中。如果你想知道验证以及它们如何尽快完成，那么反序列化将处理所有这些中的大部分，而实现代码中的先决条件将完成剩余的部分。
- en: We will, of course, keep things separated for everything that is a dependency,
    such as persistence and logging. However, as far as the business behavior is concerned,
    everything will be handled in the API code itself, in just one big block. This
    might seem like something that is not obvious given the principle of clear separation
    of responsibilities, but this has been done on purpose in this book and in particular
    in the code associated with it. It does not mean that cutting down into layers,
    as explained at [https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer](https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer),
    is useless, but simply that the first versions of a sound and evolving information
    system can very well start with a very simple implementation of a restricted API,
    leaving it to future versions to evolve to an extended API content and something
    more sophisticated for its implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将为所有依赖项，如持久性和日志记录，保持分离。然而，在业务行为方面，所有内容都将由API代码本身处理，仅在一个大块中。这可能会给人一种不明显的印象，考虑到责任分离的明确原则，但这是在本书及其相关代码中故意这样做的。这并不意味着像[https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer](https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer)中解释的那样，将系统分层是没用的，但仅仅是因为一个健全且不断发展的信息系统的前几个版本完全可以从一个非常简单的受限API实现开始，将其留给未来的版本去发展到扩展的API内容和更复杂的实现。
- en: API testability
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API可测试性
- en: 'One last thing on the API and its alignment with entities: nothing beats a
    nice Postman collection for manually testing the content of an API and then using
    these requests as the basis for a set of automated tests. There sure are other
    tools for specialized testing purposes but, in my personal experience, I have
    not yet found something as versatile as Postman for API discovery and testing.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于API及其与实体的对齐的最后一件事：没有比一个漂亮的Postman收集更好的方式来手动测试API的内容，然后使用这些请求作为一组自动化测试的基础。当然，还有其他用于特定测试目的的工具，但根据我的个人经验，我还没有找到像Postman一样在API发现和测试方面如此通用的工具。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Postman is the reference tool for API testing. A collection is a set of HTTP
    calls that can be tested manually or in an automatic, sequential way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是API测试的参考工具。一个收集是一组可以手动测试或自动、顺序测试的HTTP调用。
- en: If you can gather what your clients, internal team, and partners, external or
    public, do specifically with your API and integrate their code into your **quality
    assurance** (**QA**) Postman collections, then this is definitely the best way
    to ensure non-regression and backward compatibility. Sure, it will not replace
    unit tests and integration tests, but the former is a development tool, and the
    latter a QA tool. Everything in between will be beautifully held at the API level,
    which then becomes your interaction level but unifies with the testing interface
    of your model since it is aligned with the API. Whatever your level of interop,
    regression testing is best done at the API level.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够收集你的客户、内部团队和合作伙伴（无论是外部还是公众）如何具体使用你的API，并将他们的代码集成到你的 **质量保证** (**QA**) Postman
    收集中，那么这绝对是确保非回归和向后兼容的最佳方式。当然，它不能取代单元测试和集成测试，但前者是开发工具，后者是QA工具。所有介于两者之间的内容都将完美地保持在API级别，这使得API成为你的交互级别，并且与你的模型测试接口统一，因为它与API对齐。无论你的互操作性水平如何，回归测试最好在API级别进行。
- en: 'If you completely follow the preceding principles, you end up with a perfect
    alignment of the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全遵循前面的原则，最终你会得到以下内容的完美对齐：
- en: One business subdomain
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个业务子域
- en: One major entity
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主要实体
- en: One API contract (in OpenAPI format)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个API合同（以OpenAPI格式）
- en: One Git repository for the code implementing this API
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于实现此API的代码的 Git 仓库
- en: One process for the delivery of this code
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于交付此代码的过程
- en: One Docker image for the deployment
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于部署的 Docker 镜像
- en: One orchestrator service for the running of API calls in a coordinated way
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于协调执行API调用的 orchestrator 服务
- en: One Postman collection for the tests of the API
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于API测试的 Postman 收集
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Here we are, finally reaching the point where we will get into the code! The
    previous chapters paved the way for a global understanding of most of the constraints
    of creating an evolution-capable, feature-rich information system. In this chapter,
    we saw how we should enter details about the data of entities and also their life
    cycle to create a clean and future ready architecture.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到达了这一点，我们将开始进入代码！前几章为理解创建一个具有进化能力、功能丰富的信息系统的多数约束奠定了基础。在本章中，我们看到了我们应该如何详细说明实体的数据及其生命周期，以创建一个干净且面向未来的架构。
- en: DDD and the method shown previously using semantics will hopefully help you
    find the best way to structure important entities in your information system.
    The right schema makes exposing these entities through APIs easier and more loaded
    with functional value. This approach also allows the evolution of the system in
    the smoothest possible way, as technical evolutions and functional ones should
    be separated if the design has been correct. This way, not only is the information
    system better in its current form but it will also be much easier to evolve.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 和之前展示的基于语义的方法将有望帮助你找到在信息系统中结构化重要实体的最佳方式。正确的模式使得通过API暴露这些实体变得更加容易，并且功能价值更高。这种方法还允许系统以最平滑的方式进化，因为如果设计正确，技术进化与功能进化应该分离。这样，不仅信息系统在其当前形式上更好，而且它也将更容易进化。
- en: In the next chapter, we will see how the functional entities that we have designed
    are going to be implemented in the technical layers. We will not go into the code
    details right away, but we will start with how the data will be organized in the
    logical servers, how the entity life cycle that we talked about will be implemented
    in the software applications that will be put in place, and why master data management
    and data governance are important for ensuring that these nice functionally correct
    pivotal formats we designed in this chapter are efficiently exploited.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到我们设计的功能实体将如何在技术层中得到实现。我们不会立即深入代码细节，而是从数据如何在逻辑服务器中组织开始，我们将讨论我们之前提到的实体生命周期如何在将要部署的软件应用中得到实现，以及为什么主数据管理和数据治理对于确保我们在这章中设计的这些功能正确的关键格式能够高效利用是重要的。
