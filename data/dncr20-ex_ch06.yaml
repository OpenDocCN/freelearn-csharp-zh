- en: Testing and Deploying – The Let's Chat Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和部署 – Let's Chat 网络应用程序
- en: 'In the previous chapter, we developed the authentication module of our Let''s
    Chat web application. In this chapter, we will develop the Chat hub module using
    SignalR and wrap up the coding of our web application. After that, we will have
    a demonstration of how it works, and learn to test and deploy it. We will learn
    about Docker containers and how they may be helpful. Finally, we will develop
    an ASP.NET Core-based Chatbot and integrate it with the Let''s Chat application
    and Facebook. The motivation behind this chapter is to understand the testing
    deployment model of .NET Core applications, the Live Unit Testing feature of Visual
    Studio 2017, and containers, and get a sneak peek into developing a simple Bot,
    based on the Microsoft Bot Framework. In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开发了 Let's Chat 网络应用程序的认证模块。在本章中，我们将使用 SignalR 开发聊天中心模块，并完成网络应用程序的编码工作。之后，我们将演示其工作原理，并学习如何测试和部署它。我们将了解
    Docker 容器及其可能带来的帮助。最后，我们将开发一个基于 ASP.NET Core 的聊天机器人，并将其与 Let's Chat 应用程序和 Facebook
    集成。本章的动机在于理解 .NET Core 应用程序的测试部署模型、Visual Studio 2017 的实时单元测试功能、容器，以及预先了解基于 Microsoft
    Bot Framework 的简单机器人开发。在本章中，我们将涵盖以下内容：
- en: Chat hub module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天中心模块
- en: Testing overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试概述
- en: Introduction to containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器简介
- en: Bot 101
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人 101
- en: Chat hub module
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天中心模块
- en: Now that we have the authentication module in place, a user can log in to our
    Let's Chat web application using Facebook. We still need to develop the Chat module
    so that the user can see their friends online and chat with them. In this section,
    we will develop the Chat hub module using SignalR. We have already developed a
    Tic-Tac-Toe game using SignalR. Hence, we are already familiar with how to develop
    a SignalR hub and get the communication going back and forth between clients and
    server, so this should be relatively easier for us. On the client side, we will
    make use of Razor pages. ASP.NET Core 2.0 introduced a new feature called Razor
    pages, which makes the coding of page-focused scenarios much easier. If you have
    worked on earlier versions of ASP.NET, you will have seen or heard about ASP.NET
    Web forms (`.aspx`) applications, which had web forms at the heart of development.
    This is more or less on the same lines in the MVC world and makes it really productive
    to develop quick demos and **proof of concepts** (**PoCs**). We will quickly do
    a detour through Razor, views, and Razor pages, and then jump into the coding
    of the Chat hub module.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了认证模块，用户可以使用 Facebook 登录到我们的 Let's Chat 网络应用程序。我们仍然需要开发聊天模块，以便用户可以看到在线的朋友并与他们聊天。在本节中，我们将使用
    SignalR 开发聊天中心模块。我们已经使用 SignalR 开发了一个井字棋游戏。因此，我们已经熟悉了如何开发 SignalR 中心模块以及如何在客户端和服务器之间进行双向通信，所以这对我们来说应该相对容易。在客户端方面，我们将利用
    Razor 页面。ASP.NET Core 2.0 引入了一个名为 Razor 页面的新功能，这使得针对页面关注场景的编码变得更加容易。如果你之前使用过 ASP.NET
    的早期版本，你可能会看到或听说过 ASP.NET Web 表单（`.aspx`）应用程序，这些应用程序以 Web 表单为核心。在 MVC 世界中，这基本上是同样的概念，使得快速开发演示和
    **概念验证**（**PoCs**）变得非常高效。我们将快速浏览一下 Razor、视图和 Razor 页面，然后跳入聊天中心模块的编码工作。
- en: View, in a **Model-View-Controller** (**MVC**) pattern, handles the application
    data presentation and user interaction. Specifically, in the context of ASP.NET
    MVC, View is just an HTML template with Razor markup. Razor markup... huh!  Let's
    have a look at the Razor primer, before we understand View.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **模型-视图-控制器**（**MVC**）模式中，视图负责处理应用程序数据展示和用户交互。具体来说，在 ASP.NET MVC 的上下文中，视图只是一个带有
    Razor 标记的 HTML 模板。Razor 标记... 哼！在我们理解视图之前，让我们先看看 Razor 入门。
- en: Razor primer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Razor 入门
- en: 'Razor is a markup syntax for embedding server-based code in a web page. Developers
    familiar with PHP will find themselves at home while working with Razor, as the
    syntax is very similar. Razor syntax consists of Razor markup, C#, and HTML. Since
    it contains C# as well as HTML, files containing Razor syntax generally have a
    `.cshtml` extension. The `@` symbol is of great importance in Razor syntax and
    it is used to transition from HTML to C#. OK! But how does Razor work?  A `.cshtml`
    file can have Razor, C#, and HTML. The server first runs the Razor markup and
    C#, which ultimately would translate into HTML that the browser can understand
    and render. This HTML is then combined with the remaining HTML content and sent
    back to the browser. The following are reserved keywords in Razor:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Razor是一种用于在网页中嵌入基于服务器的代码的标记语法。熟悉PHP的开发者在使用Razor时会感到很自在，因为语法非常相似。Razor语法由Razor标记、C#和HTML组成。由于它包含C#和HTML，包含Razor语法的文件通常具有`.cshtml`扩展名。在Razor语法中，`@`符号非常重要，它用于从HTML过渡到C#。OK！但Razor是如何工作的呢？一个`.cshtml`文件可以包含Razor、C#和HTML。服务器首先运行Razor标记和C#，这最终会转换为浏览器可以理解和渲染的HTML。然后，这个HTML与剩余的HTML内容结合，并返回给浏览器。以下是在Razor中保留的关键字：
- en: '`functions`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functions`'
- en: '`inherits`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inherits`'
- en: '`model`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`'
- en: '`page`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`'
- en: '`section`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`section`'
- en: 'Language-specific keywords (for C# in `.cshtml` and VB in `.vbhtml`) remain
    as-is in Razor code blocks, and hence are not given special mention. It must be
    noted that when an `@` symbol is followed by a Razor reserved keyword, it gets
    translated into Razor-specific markup; otherwise, it transitions into plain C#.
     Let''s have a quick look at the Razor syntax:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 语言特定的关键字（对于`.cshtml`中的C#和`.vbhtml`中的VB）在Razor代码块中保持不变，因此没有特别提及。必须注意，当`@`符号后面跟着Razor保留关键字时，它会被转换为Razor特定的标记；否则，它将过渡到纯C#。让我们快速看一下Razor语法：
- en: '| **Point to learn** | **Example** | **Remarks** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **学习要点** | **示例** | **备注** |'
- en: '| `@` with Razor reserved keyword | `@model``@page` | When an `@` symbol is
    followed by a Razor reserved keyword, it transitions into Razor-specific markup.
    Otherwise, it transitions into plain C#. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `@`与Razor保留关键字 | `@model` `@page` | 当`@`符号后面跟着Razor保留关键字时，它会过渡到Razor特定的标记。否则，它将过渡到纯C#。
    |'
- en: '| Escape `@` character | `<span>@@Name</span>` is rendered in HTML as `<span>@Name</span>`
    | The HTML attributes and content containing email addresses don''t treat `@` as
    a transition character. To escape an `@` symbol in Razor markup, use a second `@` symbol.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 转义`@`字符 | `<span>@@Name</span>`在HTML中渲染为`<span>@Name</span>` | 包含电子邮件地址的HTML属性和内容不会将`@`视为过渡字符。要在Razor标记中转义`@`符号，请使用第二个`@`符号。
    |'
- en: '| Implicit Razor expression | `<p>@DateTime.Now</p>` | `@` followed by C# code.
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 隐式Razor表达式 | `<p>@DateTime.Now</p>` | `@`后跟C#代码。 |'
- en: '| Spaces not allowed | `@DateTime.Now - TimeSpan.FromDays(2)` | Rendered as
    `29/12/2017 – TimeSpan.FromDays(2)` as there are spaces between. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 空格不允许 | `@DateTime.Now - TimeSpan.FromDays(2)` | 由于存在空格，渲染为`29/12/2017 –
    TimeSpan.FromDays(2)`。 |'
- en: '| Generics are *not* supported | `<p>@SomeMethod<int>()</p>` | `<>` would be
    interpreted as an HTML tag, hence not supported in implicit expression. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 泛型不支持 | `<p>@SomeMethod<int>()</p>` | `<>`会被解释为HTML标签，因此在隐式表达式中不支持。 |'
- en: '| Explicit Razor syntax | `@(DateTime.Now.AddDays(1))` | Any content inside
    `@()` brackets is evaluated and rendered to output. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 显式Razor语法 | `@(DateTime.Now.AddDays(1))` | `@()`括号内的任何内容都会被评估并渲染到输出中。 |'
- en: '| Expression encoding | `@("<span>Hello DotNet 2.0 By Example</span>")` | Renders
    the HTML as `&lt;span&gt;Hello DotNet 2.0 By Example&lt;/span&gt;`, which is shown
    in the browser as `<span>Hello DotNet 2.0 By Example</span>`. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 表达式编码 | `@("<span>Hello DotNet 2.0 By Example</span>")` | 渲染的HTML为`&lt;span&gt;Hello
    DotNet 2.0 By Example&lt;/span&gt;`，在浏览器中显示为`<span>Hello DotNet 2.0 By Example</span>`。
    |'
- en: '| Without expression encoding | `@Html.Raw("<span> Hello .NET Core 2.0 </span>")`is
    rendered as `<span>Hello .NET Core 2.0</span>` | This results in security vulnerabilities
    such as malicious user input and cross site scripting and hence must be used with
    the utmost care. Make a rule of thumb to avoid using `@Html.Raw` unless you are
    110% sure that it can under no circumstances compromise on security and would
    never be user input. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 无表达式编码 | `@Html.Raw("<span> Hello .NET Core 2.0 </span>")`渲染为`<span>Hello
    .NET Core 2.0</span>` | 这会导致安全漏洞，如恶意用户输入和跨站脚本，因此必须极其小心地使用。请记住，除非你100%确信它不会在任何情况下损害安全，并且永远不会是用户输入，否则请避免使用`@Html.Raw`。
    |'
- en: '| Razor code blocks | `@{``ViewData["Title"] = "Let''s Chat";``}` | Razor code
    blocks start with `@` and are enclosed by` {}`. Unlike expressions, C# code inside
    code blocks isn''t rendered.  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| Razor 代码块 | `@{}` `ViewData["Title"] = "Let''s Chat";` | Razor 代码块以 `@` 开头，并由
    `{}` 包围。与表达式不同，代码块内的 C# 代码不会被渲染。 |'
- en: '| Explicit line transition | `@:Name: @User.Name`would render as `Name: <<Value
    of User.Name>>` | To render the rest of an entire line as HTML inside a code block,
    use the` @:` syntax. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 显式行转换 | `@:Name: @User.Name` 将渲染为 `Name: <<User.Name 的值>>` | 要在代码块内将整行内容渲染为
    HTML，请使用 `@:` 语法。 |'
- en: '| `@If-else if-else` | `@if (condition){``}else if (some condition) {``} else
    { }` | `@` is needed only before starting `if`. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `@If-else if-else` | `@if (condition){}` `else if (some condition) {}` `else
    {}` | 仅在开始 `if` 之前需要 `@`。 |'
- en: '| `@switch` | `@switch(value)``{ case 1:break;default:break;}` | Simple syntax
    for `switch` case. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `@switch` | `@switch(value)` `{ case 1:break;default:break;}` | `switch`
    情况的简单语法。 |'
- en: '| `@for` | `@for (var i = 0; i < array.Length; i++){}` | Use `@for`. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `@for` | `@for (var i = 0; i < array.Length; i++){}` | 使用 `@for`。 |'
- en: '| `@foreach` | `@foreach (var item in array) {}` | Use `@foreach`. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `@foreach` | `@foreach (var item in array) {}` | 使用 `@foreach`。 |'
- en: '| `@while` | `@{var i=0;}``@while (i < array.Length) {}` | Use `@while`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `@while` | `@{var i=0;}` `@while (i < array.Length) {}` | 使用 `@while`。 |'
- en: '| `@do while` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `@do while` |'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '| Use `@do...while`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 使用 `@do...while`. |'
- en: '| `@using` | `@using (Html.BeginForm()) {``@* Entire form content *@}@using
    System.Linq` | Used to create HTML helpers that contain additional content. The
    example renders a form tag.Can also be used as a `using` directive and it adds
    the C# `using` directive to the generated view.  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `@using` | `@using (Html.BeginForm()) {` `@* 整个表单内容 *@}` `@using System.Linq`
    | 用于创建包含额外内容的 HTML 辅助器。示例渲染了一个表单标签。也可以用作 `using` 指令，并将 C# 的 `using` 指令添加到生成的视图中。
    |'
- en: '| `@try`, `catch`, `finally` | `@try{}``catch(Exception ex){}``finally{}` |
    use `@try` and similar to C# syntax. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `@try`, `catch`, `finally` | `@try{}` `catch(Exception ex){}` `finally{}`
    | 使用 `@try` 和类似的 C# 语法。 |'
- en: '| `@lock` | `@lock(syncLock)``{// DO critical work here}` | Same as C#, to
    protect the critical region. Use `@lock.` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `@lock` | `@lock(syncLock)` `// 在此处执行关键工作` | 与 C# 相同，用于保护关键区域。使用 `@lock.`
    |'
- en: '| Comments |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 注释 |'
- en: '`<!-- HTML Comment-->`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<!-- HTML 注释-->`'
- en: '`/* C# Comment */// C# comment`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/* C# 注释 */// C# comment`'
- en: '`@* Razor multiline comment *@`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@* Razor 多行注释 *@`'
- en: '| Razor supports both HTML and C# comments. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Razor 支持 HTML 和 C# 注释。 |'
- en: '| `@model` | `@model HomeViewModel` | The `@model `directive specifies the
    type of the model passed to a view and is used extensively in strongly typed views.
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `@model` | `@model HomeViewModel` | `@model` 指令指定传递给视图的模型类型，并在强类型视图中广泛使用。
    |'
- en: '| `@inherits` | `@inherits BaseRazorPage`Now the view will have access to all
    the protected and public properties, fields and methods of the `BaseRazorPage`
    class | `@inherits` directive provides full control of the class the view inherits.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `@inherits` | `@inherits BaseRazorPage` 现在视图将能够访问 `BaseRazorPage` 类的所有受保护和公共属性、字段和方法。
    | `@inherits` 指令提供了对视图继承的类的完全控制。 |'
- en: '| `@inject` | `@inject IHtmlLocalizer` | The `@inject` directive enables the
    Razor page to inject a service from the service container into a view. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `@inject` | `@inject IHtmlLocalizer` | `@inject` 指令允许 Razor 页面从服务容器中注入服务到视图中。
    |'
- en: '| `@functions` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `@functions` |'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`<div> Current Time : @GetTime()</div>` | The `@functions` directive enables
    a Razor page to add function-level content to a view. |'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div> 当前时间 : @GetTime()</div>` | `@functions` 指令允许 Razor 页面向视图添加函数级内容。 |'
- en: '| `@section` | `@section Scripts { <script type="text/javascript" src="img/main.js"></script>
    }` | The `@section` directive is used in conjunction with the layout page to enable
    views to render contents in different parts of the HTML page such as  header,
    footer, body, and so on. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `@section` | `@section Scripts { <script type="text/javascript" src="img/main.js"></script>
    }` | `@section` 指令与布局页面结合使用，以允许视图在 HTML 页面的不同部分（如标题、页脚、主体等）中渲染内容。 |'
- en: Tag Helpers
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签助手
- en: 'Tag Helpers are a new feature introduced in ASP.NET Core that enables server-side
    code to participate in creating and rendering HTML elements in Razor files. Tag
    Helpers are C# classes that participate in view generation by manipulating HTML
    elements. By using Tag Helpers, we can add additional attributes to HTML elements,
    change the content, or replace them entirely. In simple terms, Tag Helper''s code
    that helps us to build our `.cshtml` forms without needing to write Razor syntax.
    For example, if we were to write an anchor tag in Razor we would write it like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Tag Helper 是 ASP.NET Core 中引入的新功能，它使服务器端代码能够参与在 Razor 文件中创建和渲染 HTML 元素。Tag Helper
    是参与视图生成的 C# 类，通过操作 HTML 元素来实现。通过使用 Tag Helper，我们可以向 HTML 元素添加额外的属性，更改内容，或完全替换它们。简单来说，Tag
    Helper 的代码帮助我们构建 `.cshtml` 表单，而无需编写 Razor 语法。例如，如果我们要在 Razor 中编写一个锚标签，我们会这样写：
- en: '`@Html.ActionLink("Read my book", "Read", "Book") `'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Html.ActionLink("Read my book", "Read", "Book")`'
- en: 'where `Read` is the action in `Book` controller and the text between anchor
    tag would be `"Read my book"`. Using Tag Helper, it becomes very easy to write
    the same anchor tag as:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read` 是 `Book` 控制器中的动作，锚标签之间的文本将是 `"Read my book"`。使用 Tag Helper，可以非常容易地写出相同的锚标签，如下所示：'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is both very easy to write as well as easy to understand, and looks more
    neat and easily maintainable as well, as it looks like HTML. Visual Studio has
    great tooling support for Tag Helpers and it highlights all the HTML elements
    that use Tag Helpers, thus making it easier to identify them and also provide
    rich intellisense to explore and use them as needed. Notice that all the Tag Helper
    attributes start with `asp-` and their naming is self-explanatory. There are a
    number of inbuilt Tag Helpers that come with the framework and writing a new one
    is also pretty straightforward. Let''s have a quick look at a few inbuilt Tag
    Helpers and then we will conclude this discussion by creating one custom Tag Helper
    as well. The following table lists a few of the inbuilt Tag Helpers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这既容易编写，又容易理解，看起来更整洁，也更容易维护，因为它看起来像 HTML。Visual Studio 为 Tag Helper 提供了出色的工具支持，它会突出显示所有使用
    Tag Helper 的 HTML 元素，从而使其更容易识别，并提供丰富的智能感知来探索和使用它们。请注意，所有 Tag Helper 属性都以 `asp-`
    开头，它们的命名是自解释的。框架中包含了许多内置的 Tag Helper，编写一个新的也非常直接。让我们快速查看一些内置的 Tag Helper，然后我们将通过创建一个自定义
    Tag Helper 来结束这次讨论。以下表格列出了几个内置的 Tag Helper：
- en: '| **Tag Helper** | **Example** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **Tag Helper** | **示例** |'
- en: '| Anchor | `<a asp-action="Index" asp-controller="Home">Back to Home</a>` anchor
    Tag Helper has few other properties that could be set, such as `asp-fragment`,
    `asp-route`, `asp-path`. This defines the anchor tag.  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 锚点 | `<a asp-action="Index" asp-controller="Home">Back to Home</a>` 锚点 Tag
    Helper 有一些其他属性可以设置，例如 `asp-fragment`、`asp-route`、`asp-path`。这定义了锚标签。 |'
- en: '| Label | `<label asp-for="Name"></label>` defines a label for a control. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | `<label asp-for="Name"></label>` 定义了一个控件的标签。 |'
- en: '| Input | `<input type="text" asp-for="Name"/>`Earlier we used to have multiple
    Razor helpers for different types of input (`checkbox`, `select`, `radio`, `text`).
    Now we have just two helper attributes `asp-for` and `asp-format`. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | `<input type="text" asp-for="Name"/>` 之前我们为不同类型的输入（`checkbox`、`select`、`radio`、`text`）使用了多个
    Razor 辅助函数。现在我们只有两个辅助属性 `asp-for` 和 `asp-format`。 |'
- en: '| Form | `<form asp-action="Create" asp-anti-forgery="true" asp-controller="Person"></form>``action`
    and `controller` are defined, as well as the `ValidateAntiForgeryToken` is taken
    care of ! Wonderful! |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 表单 | `<form asp-action="Create" asp-anti-forgery="true" asp-controller="Person"></form>`
    `action` 和 `controller` 被定义，同时 `ValidateAntiForgeryToken` 也得到了处理！太棒了！ |'
- en: '| Text area | `<textarea asp-for="Description"></textarea>`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 文本区域 | `<textarea asp-for="Description"></textarea>`。 |'
- en: '| Select | `<select asp-for="SelectedBook" asp-items="Model.Books"></select>`.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 选择 | `<select asp-for="SelectedBook" asp-items="Model.Books"></select>`。
    |'
- en: '| Image | `<img src="img/image.png" alt="profile image" asp-append-version="true"/>`Used
    for cache-busting the image as the Tag Helper appends the hash of the image as
    the query string parameter such as `<img src="img/image.png?v=Z6p6D366_nQ2fQqUso0F24gWy2ZekXjHz83WvYbaiOOk"
    alt="profile image"/>`. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 图片 | `<img src="img/image.png" alt="profile image" asp-append-version="true"/>`
    用于缓存破坏图片，因为 Tag Helper 会将图片的哈希值附加为查询字符串参数，例如 `<img src="img/image.png?v=Z6p6D366_nQ2fQqUso0F24gWy2ZekXjHz83WvYbaiOOk"
    alt="profile image"/>`。 |'
- en: '| Cache | `<cache expires-after="@TimeSpan.FromMinutes(5)"></cache> `The content
    inside the `cache` tag is cached in server memory unless explicitly disabled.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 缓存 | `<cache expires-after="@TimeSpan.FromMinutes(5)"></cache>` 缓存标签内的内容将存储在服务器内存中，除非明确禁用。
    |'
- en: '| Link and Script | These are the most interesting Tag Helpers of the lot as
    they have cache busting as well as fallback mechanisms implemented in them, such
    as  `<link rel="stylesheet" href="//ajax.aspnetcdn.com/ajax/bootstrap/3.0.0/css/bootstrap.min.css"
    asp-fallback-href="~/lib/bootstrap/css/bootstrap.min.css" asp-fallback-test-class="hidden"
    asp-fallback-test-property="visibility" asp-fallback-test-value="hidden" />`.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 链接和脚本 | 这些是所有Tag Helper中最有趣的，因为它们实现了缓存破坏以及回退机制，例如`<link rel="stylesheet"
    href="//ajax.aspnetcdn.com/ajax/bootstrap/3.0.0/css/bootstrap.min.css" asp-fallback-href="~/lib/bootstrap/css/bootstrap.min.css"
    asp-fallback-test-class="hidden" asp-fallback-test-property="visibility" asp-fallback-test-value="hidden"
    />`。 |'
- en: '| Validation | `<span asp-validation-for="Description"></span>`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 验证 | `<span asp-validation-for="Description"></span>`。 |'
- en: '| Environment | `<environment names="Staging,Production"></environment>`.This
    is a special helper as contents of helper gets rendered only if the deployed environment
    name matches the names property of the Environment tag.  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 环境 | `<environment names="Staging,Production"></environment>`。这是一个特殊的辅助器，因为辅助器的内容只有在部署的环境名称与`Environment`标签的`names`属性匹配时才会被渲染。 
    |'
- en: 'As we can see, Tag Helpers provide a great boost in productivity while coding `.cshtml`
    files. The Visual Studio tooling with IntelliSense makes this experience even
    more efficient. In ASP.NET Core 2.0, Application Insights is also enabled by using
    a Tag Helper in the background. Next let''s create a custom Tag Helper. Creating
    a custom Tag Helper needs these steps to be followed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Tag Helper在编写`.cshtml`文件时提供了极大的生产力提升。Visual Studio工具的IntelliSense使这一体验更加高效。在ASP.NET
    Core 2.0中，通过在后台使用Tag Helper，也启用了Application Insights。接下来，让我们创建一个自定义的Tag Helper。创建自定义Tag
    Helper需要遵循以下步骤：
- en: Create a custom class which derives from the `Microsoft.AspNet.Razor.TagHelper.TagHelper`
    class
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`Microsoft.AspNet.Razor.TagHelper.TagHelper`类派生的自定义类
- en: Create the properties in the class to hold the attribute values
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中创建属性以保存属性值
- en: Restrict the Tag Helper to be applicable only to a certain type of HTML element
    by decorating the class with the `HtmlTargetElement` attribute
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`HtmlTargetElement`属性装饰类，将Tag Helper限制为仅适用于特定类型的HTML元素
- en: Override the `ProcessAsync` method and set the attributes as needed
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`ProcessAsync`方法并设置所需的属性
- en: Add a line to `_ViewImports.cshtml` for the Razor views to recognize the Tag
    Helpers
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_ViewImports.cshtml`中添加一行，以便Razor视图能够识别Tag Helper
- en: Since we are not using Tag Helpers right now, we will not go into details, but
    as we can see, it's quite straightforward and easy. Now that we have visited the
    fundamentals of Razor syntax and Tag Helpers, we will quickly recap views.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在没有使用Tag Helper，所以不会深入细节，但正如我们所见，它相当直接且容易。现在我们已经了解了Razor语法和Tag Helper的基础知识，我们将快速回顾视图。
- en: Views
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'In the MVC pattern, a View is meant to display the application data to the
    user and handle user interaction. View helps us to implement the separation of
    concern design principle in MVC applications, by separating the user interface
    from business logic. It is an HTML page with additional Razor markup apart from
    the HTML markup, as we have seen earlier in this chapter. The `.cshtml` files
    are Views and treated as web pages. For example, if we create a simple MVC application,
    it creates a View under the `Views` folder and each View is associated with a
    controller. In the following example, `HomeController` is calling three Views—`Index`,
    `About`, and `Contact` . Inside the `Views` folder, we have a sub-folder with
    the controller name (`Home`) and this folder contains all views used in `HomeController`.
    This is shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC模式中，视图（View）的目的是向用户显示应用程序数据并处理用户交互。视图帮助我们实现MVC应用程序中的关注点分离设计原则，通过将用户界面与业务逻辑分离。它是一个HTML页面，除了HTML标记外，还包含额外的Razor标记，正如我们在本章前面所见。`.cshtml`文件是视图，被视为网页。例如，如果我们创建一个简单的MVC应用程序，它会在`Views`文件夹下创建一个视图，并且每个视图都与一个控制器相关联。在以下示例中，`HomeController`调用了三个视图——`Index`、`About`和`Contact`。在`Views`文件夹中，我们有一个以控制器名称（`Home`）命名的子文件夹，这个文件夹包含`HomeController`中使用的所有视图。这在上面的屏幕截图中显示：
- en: '![](img/f98c1128-2b21-400b-aee0-c185593b741d.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f98c1128-2b21-400b-aee0-c185593b741d.png)'
- en: 'The most commonly used components of Views are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 视图中最常用的组件包括：
- en: '**Layouts**: These are like the master page and are used to maintain consistency
    among all web pages. For example, we see common content used in all the pages
    such as header, footer, menu, and so on.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布局**：这些类似于母版页，用于在所有网页之间保持一致性。例如，我们看到在所有页面上都使用的一些常见内容，如页眉、页脚、菜单等。'
- en: '**Partial views**: Partial Views are useful for re-usability. If we have some
    content which needs to be displayed in more than one screen, or if we have a page
    which doesn''t have any logic or code to execute and has only content to display,
    we can have them as partial Views.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部分视图**：部分视图对于可重用性很有用。如果我们有一些需要在多个屏幕上显示的内容，或者如果我们有一个没有逻辑或代码要执行，只有内容要显示的页面，我们可以将它们作为部分视图。'
- en: '**View Components**: These are similar to partial Views and help us to reuse
    the code, but the difference is that a partial View only binds the model, and
    View components can interact with data and business logic, as they have a mini
    controller. A common example of a View component is the shopping cart of any e-commerce
    website. It renders content using database interaction.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视图组件**：这些与部分视图类似，帮助我们重用代码，但区别在于部分视图仅绑定模型，而视图组件可以与数据和业务逻辑交互，因为它们有一个迷你控制器。一个常见的视图组件示例是任何电子商务网站的购物车。它通过数据库交互来渲染内容。'
- en: Next, we will look into a new feature introduced in ASP.NET Core 2.0 called
    Razor pages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 ASP.NET Core 2.0 中引入的一个新特性，称为 Razor 页面。
- en: Razor pages
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Razor 页面
- en: 'Razor pages are lightweight pages with the added functionality of handling
    requests directly without a controller. This makes them extremely useful to create
    a quick application, or a proof of concept or for presenting cool demonstrations
    to an audience. To make a View page into a Razor page, we need to add the `@page`
    directive. It should be the first directive on the page. For example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 页面是轻量级页面，增加了直接处理请求的功能，无需控制器。这使得它们在创建快速应用、概念验证或向观众展示酷炫演示时非常有用。要将视图页面转换为
    Razor 页面，我们需要添加 `@page` 指令。它应该是页面上的第一个指令。例如：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Razor pages are useful when we need a View with small logic. For smaller logic,
    the return on investment would be better for Razor pages than that for creating
    a controller, actions, and view. In Razor pages, we can add logic inside the page
    or we can simply create code behind `page.cshtml.cs`, to write code. The question
    that came to my mind is: *Are we moving forward, or moving back to the web form
    code-behind world?*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要带有少量逻辑的视图时，Razor 页面很有用。对于较小的逻辑，Razor 页面的投资回报率会比创建控制器、操作和视图更好。在 Razor 页面中，我们可以在页面内添加逻辑，或者简单地创建
    `page.cshtml.cs` 后端代码，来编写代码。我心中产生了一个问题：*我们是向前发展，还是回到了 Web 表单后端代码的世界？*。
- en: 'Creating a Razor page is very simple. Right-click on the project and click
    Add | New Item and select Razor Page, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Razor 页面非常简单。右键单击项目，然后单击“添加”|“新建项”，选择“Razor 页面”，如图所示：
- en: '![](img/d4e2acfa-8214-4f03-9c82-392698964287.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4e2acfa-8214-4f03-9c82-392698964287.png)'
- en: In this example, the `DemoRazorPage.cshtml` has `DemoRazorPage.cshtml.cs` and
    `DemoRazorPageModel` associated with it. We can go ahead and write code as needed,
    without needing to worry about creating a controller, then its action methods,
    and finally adding a view in the specific location. Super productive!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DemoRazorPage.cshtml` 与 `DemoRazorPage.cshtml.cs` 和 `DemoRazorPageModel`
    相关联。我们可以继续编写所需的代码，无需担心创建控制器，然后是它的操作方法，最后在特定位置添加视图。超级高效！
- en: '![](img/92d9ff34-324d-4fea-bab5-9c08798c8f69.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92d9ff34-324d-4fea-bab5-9c08798c8f69.png)'
- en: In the  image, `DemoRazorPage.cshtml` file is the Razor page, and `DemoRazorPage.cshtml.cs`
    is the code behind the file of the Razor page, which uses `DemoRazorPageModel`
    as the model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，`DemoRazorPage.cshtml` 文件是 Razor 页面，而 `DemoRazorPage.cshtml.cs` 是 Razor
    页面的后端代码文件，它使用 `DemoRazorPageModel` 作为模型。
- en: With this, we have touched upon all the basic and most frequently used features
    of ASP.NET Core. We will now move on to code the Chat hub module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经触及了 ASP.NET Core 中所有基本和最常用的功能。现在，我们将继续编写 Chat 中心模块的代码。
- en: Coding the Chat hub module
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Chat 中心模块
- en: 'Now let''s code the Chat hub module for our Let''s Chat web application. We
    have already seen how to create a simple real-time web application using SignalR,
    while developing a Tic-Tac-Toe game, so we would not spend much time on things
    we have already seen. Recall that we already have authentication implemented using
    Facebook and we have user details, such as the display name and profile picture.
    We need to develop the following as part of our Chat hub module:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的 Let's Chat 网络应用程序编写 Chat 中心模块的代码。我们已经看到如何在开发井字棋游戏时使用 SignalR 创建一个简单的实时网络应用程序，所以我们不会在已经看到的内容上花费太多时间。回想一下，我们已经在
    Facebook 上实现了身份验证，并且我们有用户详情，例如显示名称和简介图片。我们需要在 Chat 中心模块中开发以下内容：
- en: List all online users connected to the Chat hub
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出连接到 Chat 中心的所有在线用户
- en: Update the online list of users, as and when someone joins or leaves the chat
    room
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时更新用户在线列表，当有人加入或离开聊天室时
- en: Any chat message sent in the room goes to all the connected users
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房间中发送的任何聊天消息都将发送给所有连接的用户
- en: 'Quite clearly, to meet these requirements, we would need to track the users,
    so that a connected user shows in the online list and disappears from the list
    when they leave the chat room. We would first create a class named `UserInformation`
    to hold the user details such as `name`, display picture URL (`imageURL`), and
    `connection identifier`, as defined here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，为了满足这些要求，我们需要跟踪用户，以便连接的用户在在线列表中显示，当他们离开聊天室时从列表中消失。我们首先创建一个名为`UserInformation`的类来保存用户详情，如`name`、显示图片URL（`imageURL`）和`connection
    identifier`，如下定义：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s create an interface named `IUserTracker` with three methods for
    user tracking:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为`IUserTracker`的接口，其中包含三个用于用户跟踪的方法：
- en: '**Get all online users**: This would be used to display all the users that
    are connected to the chat'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有在线用户**：这将用于显示所有连接到聊天的用户'
- en: '**Add user**: This would be used to add a user-to-user tracker data store and
    should be called when a user joins the chat room'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加用户**：这将用于添加用户到用户跟踪数据存储，并且应该在用户加入聊天室时调用'
- en: '**Remove user**: This would be used to remove a user from the user tracker
    data store and should be called when a user leaves the chat room'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除用户**：这将用于从用户跟踪数据存储中移除用户，并且应该在用户离开聊天室时调用'
- en: 'The code is as shown here and the comments should make the code comprehensive:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示，注释应该使代码更全面：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We created an interface so that we could leverage Dependency Injection to inject
    the user tracking component, wherever we need it. Though we have worked with SignalR
    already, we have not come across the `HubConnectionContext` class, which we have
    used in the interface. So, let''s have a quick look at it. The `HubConnectionContext`
    class resides in the `Microsoft.AspNetCore.SignalR.Core` assembly under the `Microsoft.AspNet.SignalR`
    namespace. It encapsulates all the information about a SignalR connection. The
    following code map diagram shows the `HubConnectionContext` class and its properties:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个接口，以便我们可以利用依赖注入来注入用户跟踪组件，无论何时需要它。尽管我们已经与SignalR合作过，但我们还没有遇到过`HubConnectionContext`类，我们在接口中使用过这个类。所以，让我们快速了解一下它。`HubConnectionContext`类位于`Microsoft.AspNetCore.SignalR.Core`程序集下的`Microsoft.AspNet.SignalR`命名空间中。它封装了有关SignalR连接的所有信息。以下代码映射图显示了`HubConnectionContext`类及其属性：
- en: '![](img/10caa2c6-74e0-44c4-a67b-828e6bdf1b27.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10caa2c6-74e0-44c4-a67b-828e6bdf1b27.png)'
- en: 'The code is as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There would be an extension method to get the `HttpContext` from `HubConnectionContext`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有一个扩展方法来从`HubConnectionContext`获取`HttpContext`。
- en: 'We use the `HubConnectionContext` class to keep track of the user and connection
    in our `UserTracker` class, which we will implement next. Let''s implement the
    `IUserTracker` interface in our `UserTracker` class, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`HubConnectionContext`类在`UserTracker`类中跟踪用户和连接，我们将在下一部分实现。让我们在`UserTracker`类中实现`IUserTracker`接口，如下所示：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this, our user tracker component is created. It has a backup store (concurrent
    dictionary), where we will add the connection and user details when a user joins
    the chat room, and remove the entry from it when the user leaves the chat room.
    We can keep the concurrent dictionary as `static` as well, but we will use dependency
    registration to register our `UserTracker` class as a singleton, so we can be
    sure that the same instance of class would be used for all the user connections.
    To register our `UserTracker` as a singleton, we would write the following lines
    of code in the `ConfigureServices` method of the `Startup.cs` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的用户跟踪组件就创建完成了。它有一个备份存储（并发字典），当用户加入聊天室时，我们将添加连接和用户详情，当用户离开聊天室时，我们将从其中删除条目。我们也可以将并发字典作为`static`，但我们将使用依赖注册来注册我们的`UserTracker`类作为单例，这样我们就可以确保所有用户连接都会使用同一个类的实例。为了将我们的`UserTracker`注册为单例，我们将在`Startup.cs`类的`ConfigureServices`方法中编写以下代码行：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will code the Chat hub, which will use the `UserTracker` class, and
    SignalR goodness to complete our chat room.  To do so, let''s create a class named
    `ChatHub` derived from the `Hub` class, with the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写Chat hub的代码，它将使用`UserTracker`类和SignalR的优点来完成我们的聊天室。为此，让我们创建一个名为`ChatHub`的类，它从`Hub`类派生，以下是其代码：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are important points to note here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的要点需要注意：
- en: The class `ChatHub` derives from the `Microsoft.AspNetCore.SignalR.Hub` class.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChatHub` 类继承自 `Microsoft.AspNetCore.SignalR.Hub` 类。'
- en: The class `ChatHub` is decorated with the `[Authorize]` attribute, which means
    only an authenticated and authorized user can access the hub.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChatHub` 类被 `[Authorize]` 属性装饰，这意味着只有经过身份验证和授权的用户才能访问中心。'
- en: The constructor of `ChatHub` uses `IUserTracker` as a dependency, which would
    be injected through Dependency Injection.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChatHub` 的构造函数使用 `IUserTracker` 作为依赖项，这将通过依赖注入进行注入。'
- en: 'The `Microsoft.AspNetCore.SignalR.Hub` class has a property called `Context`
    of type `HubCallerContext`, which contains the SignalR connection identifier,
    user claim information, and `HubConnectionContext`. We can leverage the `Context`
    property to extract the user information from our Chat hub. To do so, we would
    need a helper/extension method, which takes in `HubCallerContext` and returns
    the `UserInformation` object that we created earlier. The following code snippet
    shows a helper class, which contains a method to translate the `HubCallerContext`
    to `UserInformation`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.SignalR.Hub` 类有一个名为 `Context` 的属性，其类型为 `HubCallerContext`，它包含
    SignalR 连接标识符、用户声明信息和 `HubConnectionContext`。我们可以利用 `Context` 属性从我们的 Chat 中心提取用户信息。为此，我们需要一个辅助/扩展方法，该方法接受
    `HubCallerContext` 并返回我们之前创建的 `UserInformation` 对象。以下代码片段显示了一个辅助类，其中包含一个将 `HubCallerContext`
    转换为 `UserInformation` 的方法：'
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this structure, we are now in a position to track online users, as and
    when they join or leave our chat room, by overriding the `OnConnectedAsync` and
    `OnDiconnectedAsync` virtual methods, which are exposed by the `Microsoft.AspNetCore.SignalR.Hub`
    class. We would also need to add an additional method to fetch a list of all the
    connected users. We can do this easily by writing the following code in our `ChatHub`
    class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，我们现在可以跟踪在线用户，无论他们何时加入或离开我们的聊天室，通过重写由 `Microsoft.AspNetCore.SignalR.Hub`
    类公开的 `OnConnectedAsync` 和 `OnDiconnectedAsync` 虚拟方法。我们还需要添加一个额外的方法来获取所有已连接用户列表。我们可以在
    `ChatHub` 类中轻松编写以下代码：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code is simple to understand. However, for the sake of clarity and completeness,
    we will do a quick walk-through of the preceding code. There are four methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码易于理解。然而，为了清晰和完整，我们将快速浏览前面的代码。这里有四个方法：
- en: '`GetOnlineUsersAsync`: This method returns all the online users as stored in
    the `UserTracker` store. This method would be used to display online users in
    the chat room page.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetOnlineUsersAsync`：此方法返回存储在 `UserTracker` 存储中的所有在线用户。此方法将用于在聊天室页面上显示在线用户。'
- en: '`OnConnectedAsync`: This method is fired when a user connects to the Chat hub,
    that is, joins the chat room. In this method, we first fetch the user information
    by calling the `Helper` class method, `GetUserInformationFromContext,` passing
    the `Context` property of hub, which contains information about the current connection.
    After getting the user information, we add the connection and user information
    in the `UserTracker` store. Next, we need to notify all connected clients that
    a new user is now available for chat, so we fire the `UsersJoined` method on all
    the clients. We will see this method in a short while. This method takes an array
    of `UserInformation` as a parameter. This way, we can display to all the connected
    clients that a new user has joined the chat room. Finally, we need to update the
    list displaying the online users, so we invoke the client method, `SetUsersOnline`,
    on all the connected clients, passing in the list of connected users.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnConnectedAsync`：当用户连接到 Chat 中心，即加入聊天室时，此方法被触发。在这个方法中，我们首先通过调用 `Helper` 类的
    `GetUserInformationFromContext` 方法来获取用户信息，传递包含当前连接信息的 `Context` 属性。在获取用户信息后，我们将连接和用户信息添加到
    `UserTracker` 存储中。接下来，我们需要通知所有已连接客户端，现在有一个新的用户可供聊天，因此我们在所有客户端上触发 `UsersJoined`
    方法。我们将在稍后看到这个方法。此方法接受一个 `UserInformation` 数组作为参数。这样，我们可以向所有已连接客户端显示，有新用户加入了聊天室。最后，我们需要更新显示在线用户的列表，因此我们在所有已连接客户端上调用客户端方法
    `SetUsersOnline`，并传递已连接用户列表。'
- en: '`OnDisconnectedAsync`: This method is the exact opposite of the `OnConnectedAsync`
    method and is fired when a user disconnects from the Chat hub, that is, leaves
    the chat room. In this method, we first fetch the user information by calling
    the `Helper` class method, `GetUserInformationFromContext`, passing the `Context`
    property of hub, which contains information about the current connection. After
    getting the user information, we need to notify all the connected clients that
    the user is no longer available for chat, so we fire the `UsersLeft` method on
    all the clients. We will see this method in a short while. This method takes an
    array of `UserInformation` as a parameter. This way, we can display to all the
    connected clients that a user has left the chat room. Next, we remove the connection
    and user information from the `UserTracker` store. Finally, we need to update
    the list displaying the online users, so we invoke the client method, `SetUsersOnline`,
    on all the connected clients, passing in a list of connected users.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDisconnectedAsync`: 这个方法与 `OnConnectedAsync` 方法正好相反，当用户从 Chat hub 断开连接，即离开聊天室时触发。在这个方法中，我们首先通过调用
    `Helper` 类方法 `GetUserInformationFromContext` 获取用户信息，传入 hub 的 `Context` 属性，该属性包含有关当前连接的信息。在获取用户信息后，我们需要通知所有已连接的客户端该用户不再可用进行聊天，因此我们在所有客户端上触发
    `UsersLeft` 方法。我们将在稍后看到这个方法。这个方法接受一个 `UserInformation` 数组作为参数。这样，我们就可以向所有已连接的客户端显示一个用户已经离开了聊天室。接下来，我们从
    `UserTracker` 存储中删除连接和用户信息。最后，我们需要更新显示在线用户的列表，因此我们在所有已连接的客户端上调用客户端方法 `SetUsersOnline`，传入连接用户的列表。'
- en: '`Send`: The last method that we see is called `Send`. As the name suggests,
    this method is used to send the message to all the connected clients, along with
    the username and image URL. In this method, we first get the user information
    from the `Context` like we did in the preceding methods, and then invoke the client
    method, `Send`, on all connected clients, passing in the username and image URL
    of the user who has typed the message. We will see the details of the `Send` method
    shortly, when we explore client-side methods.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send`: 我们看到的最后一个方法被称为 `Send`。正如其名所示，这个方法用于将消息发送给所有已连接的客户端，同时包含用户名和图片 URL。在这个方法中，我们首先从
    `Context` 中获取用户信息，就像我们在前面的方法中所做的那样，然后对所有已连接的客户端调用客户端方法 `Send`，传入发送消息的用户名和图片 URL。当我们探索客户端方法时，我们将很快看到
    `Send` 方法的详细信息。'
- en: 'We will wrap our server-side coding of the Chat hub by configuring the HTTP
    pipeline to intercept and map any request having `chatHub` to our `ChatHub` class.
    To do so, we will write the following code in the `Configure` method of `Startup.cs`
    between `app.UseAuthentication` and `app.UseMvc`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过配置 HTTP 管道来拦截和映射任何具有 `chatHub` 的请求，将其映射到我们的 `ChatHub` 类，以此来封装我们的 Chat hub
    的服务器端编码。为此，我们将在 `Startup.cs` 的 `Configure` 方法中 `app.UseAuthentication` 和 `app.UseMvc`
    之间编写以下代码：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This wraps up our server-side coding. Next, we will look at the client-side
    coding that we will do in our View.  The user interface code is quite straightforward
    and so we will not go into details. The reader can browse the source code and
    see the user interface code and the used `.css` classes. We will look at the client-side
    JavaScript code that would be needed to complete the chat room experience. As
    a matter of best practice, all the JavaScript/jQuery coding should be done in
    a separate `.js` file and referenced in the View. For the sake of simplicity,
    I shall be showing the inline JavaScript in the View itself. So let''s code the
    client-side stuff:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的服务器端编码。接下来，我们将查看我们在视图中将进行的客户端编码。用户界面代码相当简单，所以我们不会深入探讨。读者可以浏览源代码，查看用户界面代码和使用的
    `.css` 类。我们将查看完成聊天室体验所需的客户端 JavaScript 代码。作为最佳实践，所有 JavaScript/jQuery 编码都应该在一个单独的
    `.js` 文件中完成，并在视图中引用。为了简化，我将在视图中直接展示内联 JavaScript。所以，让我们编写客户端代码：
- en: 'We begin by ensuring that the following references for CSS and JavaScript are
    present in the `_Layout.cshtml` file, so that they would be available in our View
    as well:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保在 `_Layout.cshtml` 文件中存在以下 CSS 和 JavaScript 引用，以便它们可以在我们的视图中使用。这样，它们就会在我们的视图中可用：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `Index.cshtml` of our `HomeController` class, create a `<script>` node
    and initialize the SignalR hub connection in the bottom of the page as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `HomeController` 类的 `Index.cshtml` 中，创建一个 `<script>` 节点，并在页面底部初始化 SignalR
    hub 连接，如下所示：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to define the following methods that we saw previously, while
    doing the server side coding:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们之前在服务器端编码中看到的以下方法：
- en: '`SetUsersOnline`: This method displays connected users in the left panel.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetUsersOnline`: 此方法在左侧面板显示连接的用户。'
- en: '`UsersJoined`: This method is fired when a user joins the chat room. This method
    displays information to the effect that the user has joined the room.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsersJoined`: 当用户加入聊天室时，此方法被触发。此方法显示用户已加入房间的信息。'
- en: '`UsersLeft`: This method is fired when a user leaves the chat room. This method
    displays information to the effect that the user has left the room.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsersLeft`: 当用户离开聊天室时，此方法被触发。此方法显示用户已离开房间的信息。'
- en: '`Send`: This method is called when a user types a message and clicks on the
    `Send` button.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send`: 当用户输入消息并点击“发送”按钮时，调用此方法。'
- en: 'The pseudo code for the preceding methods is as follows. The detailed and complete
    code can be seen from the source code repository URL ([https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example))
    shared with the book:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的伪代码如下。详细的完整代码可以从与本书共享的源代码仓库URL（[https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example)）中查看。
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While doing any client-side development or any web page/View design using Bootstrap,
    you can make use of Bootstrap theme sites such as [https://bootswatch.com/default/](https://bootswatch.com/default/),
    which gives the preceding code as needed, and can be used with minimal changes.
    We can spin up a web page or a complete site in a matter of hours. Do try it out!
    It's very handy!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何客户端开发或使用Bootstrap进行网页/视图设计时，你可以使用如[https://bootswatch.com/default/](https://bootswatch.com/default/)这样的Bootstrap主题网站，它提供所需的代码，并且可以最小化修改后使用。我们可以在几小时内启动一个网页或完整的网站。真的试试看！它非常方便！
- en: 'Once we are done with the user interface and client-side coding, our Let''s
    Chat application is ready to be used. Let''s run the application. This is what
    the user interface of the Let''s Chat application looks like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成用户界面和客户端编码，我们的Let's Chat应用程序就准备好使用了。让我们运行应用程序。这是Let's Chat应用程序的用户界面看起来像：
- en: '![](img/90af6620-da31-48e7-8ad8-3d3479e13857.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90af6620-da31-48e7-8ad8-3d3479e13857.png)'
- en: 'Let''s look at it from top to bottom:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下看看：
- en: It recognizes the logged in user and hence is able to display Hello `{User Name}`
    (Rishabh Verma in the screenshot), so our authentication module is working fine.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它识别已登录的用户，因此能够显示“你好 `{用户名}`”（截图中的Rishabh Verma），因此我们的认证模块工作良好。
- en: On the left, it displays Online Users, which lists just one name, so it is able
    to track users that are connected to the chat room.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，它显示在线用户，只列出一个名字，因此能够追踪连接到聊天室的用户。
- en: In the Chat area, we can see Rishabh Verma joined the chat room, Neha Shrivastava
    joined the chat room, so our `IUserTracker` class is working fine in conjunction
    with the authentication module.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在聊天区域，我们可以看到Rishabh Verma加入了聊天室，Neha Shrivastava加入了聊天室，因此我们的`IUserTracker`类与认证模块配合工作良好。
- en: The Facebook profile pictures of users display with their message.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的Facebook头像与他们的消息一起显示。
- en: It also displays text if a user leaves the chat room.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户离开聊天室，它也会显示文本。
- en: With this, our Let's Chat application code is complete. Next, we will do unit
    testing to ensure that issues or bugs in the code are caught at the time of development
    itself, and we thus ship and deploy a quality product. In the process, we will
    also learn about testing with reference to ASP.NET Core 2.0.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的Let's Chat应用程序代码就完成了。接下来，我们将进行单元测试，以确保在开发过程中就能捕捉到代码中的问题或错误，从而我们能够交付和部署一个高质量的产品。在这个过程中，我们还将学习如何使用ASP.NET
    Core 2.0进行测试。
- en: Testing overview
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试概述
- en: 'The famous Java programmer, Bruce Eckel, come up with a slogan which highlights
    the importance of testing software:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的Java程序员布鲁斯·艾克尔提出了一句强调测试软件重要性的口号：
- en: If it ain't tested, it's broken.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有经过测试，它就是有缺陷的。
- en: 'Though a confident programmer may challenge this, it beautifully highlights
    the ability to determine that code works as expected over and over again, without
    any exception. How do we know that the code that we are shipping to the end user
    or customer is of good quality and all the user requirements would work? By testing?
    Yes, by testing, we can be confident that the software works as per customer requirements
    and specifications. If there are any discrepancies between expected and actual
    behavior, it is referred to as a bug/defect in the software. The earlier the discrepancies
    are caught, the more easily they can be fixed before the software is shipped;
    and the results is good quality. No wonder  software testers are also referred
    to as quality control analysts in various software firms. The mantra for a good
    software tester would be:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自信的程序员可能会对此提出质疑，但它完美地突出了确定代码能够一次又一次地按预期工作，没有任何异常的能力。我们如何知道我们交付给最终用户或客户的代码是高质量的，并且所有用户需求都能得到满足？通过测试？是的，通过测试，我们可以确信软件按照客户的要求和规格工作。如果预期行为和实际行为之间存在任何差异，这被称为软件中的错误/缺陷。越早发现这些差异，就越容易在软件发货前修复它们；结果是高质量。难怪软件测试员在各种软件公司中也被称为质量控制分析师。一个好的软件测试员的座右铭可能是：
- en: In God we trust, the rest we test.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们信仰上帝，其余的我们都要测试。
- en: 'We will not go into types of testing in any depth, as that would make another
    chapter in itself. We will look at them briefly, and then write our unit tests,
    which every good developer should write after writing any software program. Software
    testing is conducted at various levels:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨测试类型，因为这本身就可以成为另一章的内容。我们将简要地了解它们，然后编写我们的单元测试，这是每个好的开发者编写任何软件程序后都应该写的。软件测试在不同的级别进行：
- en: '**Unit testing**: While coding, the developer conducts tests on a unit of a
    program to validate that the code they have written is error-free. We will write
    a few unit tests shortly.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在编码过程中，开发者会对程序的一个单元进行测试，以验证他们编写的代码是无错误的。我们很快就会编写一些单元测试。'
- en: '**Integration testing**: In a team where a number of developers are working,
    there may be different components that the developers are working on. Even if
    all developers perform unit testing and ensure that their units are working fine,
    there is still a need to ensure that, upon integration of these components, they
    work without any error. This is achieved through integration testing.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：在一个有多个开发者工作的团队中，开发者们可能正在处理不同的组件。即使所有开发者都执行了单元测试并确保他们的单元运行良好，仍然需要确保在将这些组件集成后，它们能够无错误地工作。这是通过集成测试实现的。'
- en: '**System testing**: The entire software product is tested as a whole. This
    is accomplished using one or more of the following:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：整个软件产品作为一个整体进行测试。这是通过以下一种或多种方法实现的：'
- en: '**Functionality testing**: Test all the functionality of the software against
    the business requirement document.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：测试软件的所有功能是否符合业务需求文档。'
- en: '**Performance testing**: To test how performant the software is. It tests the
    average time, resource utilization, and so on, taken by the software to complete
    a desired business use case. This is done by means of load testing and stress
    testing, where the software is put under high user and data load.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：测试软件的性能。它测试软件完成所需业务用例的平均时间、资源利用率等。这是通过负载测试和压力测试实现的，在这些测试中，软件被置于高用户和数据负载下。'
- en: '**Security testing**: Tests how secure the software is against common and well-known
    security threats.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全测试**：测试软件对常见和已知的网络安全威胁的防护能力。'
- en: '**Accessibility testing**: Tests if the user interface is accessible and user-friendly
    to specially-abled people or not.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性测试**：测试用户界面是否对有特殊需求的人友好和易于使用。'
- en: '**User acceptance testing**: When the software is ready to be handed over to
    the customer, it goes through a round of testing by the customer for user interaction
    and response.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户验收测试**：当软件准备交付给客户时，它将经历一轮由客户进行的测试，以检验用户交互和响应。'
- en: '**Regression testing**: Whenever a piece of code is added/updated in the software
    to add a new functionality or fix an existing functionality, it is tested to detect
    if there are any side-effects from the newly added/updated code.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：每当在软件中添加/更新一段代码以添加新功能或修复现有功能时，都会对其进行测试，以检测是否有任何由新添加/更新的代码引起的副作用。'
- en: Of all these different types of testing (and many more not listed here), we
    would focus on unit testing, as that is done by the developer coding the functionality.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些不同类型的测试（以及这里没有列出的许多其他测试）中，我们将重点关注单元测试，因为这是编写功能的开发者所执行的。
- en: Unit testing
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: .NET Core has been designed with testability in mind. .NET Core 2.0 has unit
    test project templates for VB, F#, and C#. We can also pick the testing framework
    of our choice amongst xUnit, NUnit, and MSTest.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 是以可测试性为设计理念的。.NET Core 2.0 为 VB、F# 和 C# 提供了单元测试项目模板。我们还可以在 xUnit、NUnit
    和 MSTest 中选择我们选择的测试框架。
- en: 'Unit tests that test single programming parts are the most minimal-level tests.
    Unit tests should just test code inside the developer''s control, and ought to
    not test infrastructure concerns, for example databases, filesystems, or network
    resources. Unit tests might be composed utilizing **test-driven development**
    (**TDD**) or they can be added to existing code to affirm its accuracy. The naming
    convention of `Test` class names should end with `Test` and reside in the same
    namespace as the class being tested. For instance, the unit tests for the `Microsoft.Example.AspNetCore`
    class would be in the `Microsoft.Example.AspNetCoreTest` class in the test assembly.
    Also, unit test method names must be descriptive about *what is being tested*, *under
    what conditions*, and *what the expectations are*. A good unit test has three
    main parts to it in the following specified order:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 测试单个编程部分的单元测试是最底层的测试。单元测试应该只测试开发者控制内的代码，并且不应该测试基础设施问题，例如数据库、文件系统或网络资源。单元测试可以使用
    **测试驱动开发**（**TDD**）编写，或者添加到现有代码中以验证其准确性。`Test` 类名的命名约定应以 `Test` 结尾，并位于被测试的类所在的同一命名空间中。例如，`Microsoft.Example.AspNetCore`
    类的单元测试将位于测试程序集中的 `Microsoft.Example.AspNetCoreTest` 类中。此外，单元测试方法名必须描述性，关于 *正在测试的内容*、*在什么条件下*
    和 *期望是什么*。一个好的单元测试有三个主要部分，以下指定顺序：
- en: Arrange
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安排
- en: Act
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行为
- en: Assert
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言
- en: 'We first arrange the code and then act on it and then do a series of asserts
    to check if the actual output matches the expected output. Let''s have a look
    at them in detail:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安排代码，然后对其采取行动，然后进行一系列断言以检查实际输出是否与预期输出匹配。让我们详细看看它们：
- en: '**Arrange: **All the parameter building, and method invocations needed for
    making a call in the act section must be declared in the arrange section.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安排：**在行为部分进行调用所需的所有参数构建和方法调用必须在安排部分声明。'
- en: '**Act:** The act stage should be one statement and as simple as possible. This
    one statement should be a call to the method that we are trying to test.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行为：**行为阶段应该是一个语句，尽可能简单。这个语句应该是调用我们试图测试的方法。'
- en: '**Assert:** The only reason method invocation may fail is if the method itself
    throws an exception, else, there should always be some state change or output
    from any meaningful method invocation. When we write the act statement, we anticipate
    an output and then do assertions if the actual output is the same as expected.
    If the method under test should throw an exception under normal circumstances,
    we can do assertions on the type of exception and the error message that should
    be thrown.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断言：**方法调用可能失败的唯一原因是方法本身抛出异常，否则，应该始终有一些状态变化或输出来自任何有意义的调用。当我们编写行为语句时，我们预期一个输出，然后如果实际输出与预期相同，则进行断言。如果被测试的方法在正常情况下应该抛出异常，我们可以对异常类型和应该抛出的错误消息进行断言。'
- en: We should be watchful, while writing unit test cases, that we don't inject any
    dependencies on the infrastructure. Infrastructure dependencies should be taken
    care of in integration test cases, not in unit tests. We can maintain a strategic
    distance from these shrouded dependencies in our application code by following
    the Explicit Dependencies Principle and utilizing Dependency Injection to request
    our dependencies on the framework. We can likewise keep our unit tests in a different
    project from our integration tests and guarantee our unit test project doesn't
    have references to the framework.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试用例时，我们应该警惕不要向基础设施注入任何依赖。基础设施依赖应在集成测试用例中处理，而不是在单元测试中。我们可以通过遵循显式依赖原则并利用依赖注入来请求框架的依赖，在我们的应用程序代码中保持对这些隐蔽依赖的战略距离。我们同样可以将我们的单元测试与集成测试放在不同的项目中，并确保我们的单元测试项目没有对框架的引用。
- en: Testing using xUnit
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 xUnit 进行测试
- en: 'In this section we will learn to write unit and integration tests for our controllers.
    There are a number of options available to us for choosing the test framework.
    We will use xUnit for all our unit tests and Moq for mocking objects. Let''s create
    a xUnit test project by doing the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为我们的控制器编写单元测试和集成测试。我们有多种选择可供选择测试框架。我们将使用xUnit进行所有单元测试，并使用Moq进行对象模拟。让我们通过以下步骤创建一个xUnit测试项目：
- en: Open the Let's Chat project in Visual Studio 2017
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2017 中打开 Let's Chat 项目
- en: Create a new folder named  `Test`
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Test` 的新文件夹
- en: Right-click the `Test` folder and click Add | New Project
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Test` 文件夹，然后点击 Add | New Project
- en: 'Select xUnit Test Project (.NET Core) under Visual C# project templates, as
    shown here:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual C#项目模板下选择 xUnit Test Project (.NET Core)，如图所示：
- en: '![](img/ecbd02c7-afd6-459a-a477-222ab220deb5.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecbd02c7-afd6-459a-a477-222ab220deb5.png)'
- en: Delete the default test class that gets created with the template
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除由模板创建的默认测试类
- en: Create a test class inside this project `AuthenticationControllerUnitTests`
    for the unit test
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此项目中创建一个测试类 `AuthenticationControllerUnitTests` 用于单元测试
- en: 'We need to add some NuGet packages. Right-click the project in VS 2017 to edit
    the project file and add the references manually, or use the NuGet Package Manager
    to add these packages:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一些 NuGet 包。在 VS 2017 中右键点击项目以编辑项目文件并手动添加引用，或者使用 NuGet 包管理器添加这些包：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this, we are now ready to write our unit tests. Let's start doing this,
    but before we do that, here's some quick theory about xUnit and Moq.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写我们的单元测试了。让我们开始做这件事，但在我们这样做之前，这里有一些关于 xUnit 和 Moq 的快速理论。
- en: 'The documentation from the xUnit website and Wikipedia tells us that xUnit.net
    is a free, open source, community-focused unit testing tool for the .NET Framework.
    It is the latest technology for unit testing C#, F#, Visual Basic .NET, and other
    .NET languages. All xUnit frameworks share the following basic component architecture:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 xUnit 网站和维基百科的文档告诉我们，xUnit.net 是一个针对 .NET Framework 的免费、开源、社区关注的单元测试工具。它是单元测试
    C#、F#、Visual Basic .NET 和其他 .NET 语言的最新技术。所有 xUnit 框架都共享以下基本组件架构：
- en: '**Test runner**: It is an executable program that runs tests implemented using
    an xUnit framework and reports the test results.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**：它是一个可执行程序，用于运行使用 xUnit 框架实现的测试，并报告测试结果。'
- en: '**Test case**: It is the most elementary class. All unit tests are inherited
    from here.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**：这是最基本类。所有单元测试都从这里继承。'
- en: '**Test fixtures:** Test fixures (also known as a test context) are the set
    of preconditions or state needed to run a test. The developer should set up a
    known good state before the tests, and return to the original state after the
    tests.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试装置**：测试装置（也称为测试上下文）是一组在运行测试之前需要的先决条件或状态。开发人员应在测试之前设置一个已知良好的状态，并在测试之后返回到原始状态。'
- en: '**Test suites:** It is a set of tests that all share the same fixture. The
    order of the tests shouldn''t matter.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：它是一组共享相同固定装置的测试。测试的顺序不应重要。'
- en: 'xUnit.net includes support for two different major types of unit test:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net 支持两种不同类型的单元测试：
- en: '**Facts**:Tests which are always true. They test invariant conditions, that
    is, data-independent tests.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事实**：总是为真的测试。它们测试不变条件，即数据无关的测试。'
- en: '**Theories**: Tests which are only true for a particular set of data*.*'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理论**：只有对于特定数据集才为真的测试。'
- en: '**Moq** is a mocking framework for C#/.NET. It is used in unit testing to isolate
    the class under test from its dependencies, and ensure that the proper methods
    on the dependent objects are being called.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**Moq** 是 C#/.NET 的模拟框架。它在单元测试中用于隔离被测试的类与其依赖项，并确保在依赖对象上调用正确的方法。'
- en: Recall that in unit tests, we only test a unit or a layer/part of the software
    in isolation and hence do not bother about external dependencies, so we assume
    they work fine and just mock them using the mocking framework of our choice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在单元测试中，我们只测试一个单元或软件的一个层/部分，因此不需要考虑外部依赖项，所以我们假设它们工作正常，并使用我们选择的模拟框架来模拟它们。
- en: 'Let''s put this theory into action by writing a unit test for the following
    action in `AuthenticationController`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个理论付诸实践，为 `AuthenticationController` 中的以下操作编写单元测试：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The unit test code depends on how the method to be tested is written. To understand
    this, let''s write a unit test for a `SignIn` action. To test the `SignIn` method,
    we need to invoke the `SignIn` action in `AuthenticationController`. To do so,
    we need an instance of the `AuthenticationController` class, on which the `SignIn`
    action can be invoked. To create the instance of `AuthenticationController`, we
    need a logger object, as the `AuthenticationController` constructor expects it
    as a parameter. Since we are only testing the `SignIn` action, we do not bother
    about the logger and so we can mock it. Let''s do it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试代码取决于要测试的方法的编写方式。为了理解这一点，让我们为`SignIn`操作编写一个单元测试。为了测试`SignIn`方法，我们需要在`AuthenticationController`中调用`SignIn`操作。要做到这一点，我们需要`AuthenticationController`类的一个实例，在该实例上可以调用`SignIn`操作。为了创建`AuthenticationController`的实例，我们需要一个日志对象，因为`AuthenticationController`构造函数期望它作为一个参数。由于我们只测试`SignIn`操作，所以我们不必担心日志，因此我们可以模拟它。让我们来做：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Reading the comments would explain the unit test code. The previous example
    shows how easy it is to write a unit test. Through depending upon the method to
    be tested, things can get complicated, but most of it would be around mocking
    the objects and, with some experience on the mocking framework and binging around,
    mocking should not be a difficult task. The unit test for the `SignOut` action
    would be a bit complicated in terms of mocking as it uses `HttpContext`. The unit
    test for the `SignOut` action is left to the reader as an exercise. Let's explore
    a new feature introduced in Visual Studio 2017 called Live Unit Testing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读注释可以解释单元测试代码。前面的例子展示了编写单元测试是多么容易。通过依赖于要测试的方法，事情可能会变得复杂，但大部分都会围绕模拟对象，并且有一些关于模拟框架和绑定的经验，模拟应该不会是一个困难的任务。对于`SignOut`操作的单元测试在模拟方面可能会比较复杂，因为它使用了`HttpContext`。`SignOut`操作的单元测试留作读者练习。让我们探索Visual
    Studio 2017中引入的新功能，称为实时单元测试。
- en: Live Unit Testing
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时单元测试
- en: It may disappoint you but **Live Unit Testing** (**LUT**) is available only
    in the Visual Studio 2017 Enterprise edition and not in the Community edition.
    What is Live Unit Testing? It's a new productivity feature, introduced in the
    Visual Studio 2017 Enterprise edition, that provides real-time feedback directly
    in the Visual Studio editor on how code changes are impacting unit tests and code
    coverage. All this happens live, while you write the code and hence it is called
    Live Unit Testing. This will help in maintaining the quality by keeping tests
    passing as changes are made. It will also remind us when we need to write additional
    unit tests, as we are making bug fixes or adding features.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让你失望，但**实时单元测试**（**LUT**）仅在Visual Studio 2017企业版中可用，而不是社区版。什么是实时单元测试？它是Visual
    Studio 2017企业版中引入的一个新生产力功能，它直接在Visual Studio编辑器中提供实时反馈，说明代码更改如何影响单元测试和代码覆盖率。所有这些都在你编写代码的同时实时发生，因此它被称为实时单元测试。这将有助于通过保持测试通过来维护质量。它还会在我们进行错误修复或添加功能时提醒我们需要编写额外的单元测试。
- en: 'To start Live Unit Testing:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实时单元测试：
- en: Go to the Test menu item
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“测试”菜单项
- en: Click Live Unit Testing
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击实时单元测试
- en: 'Click Start, as shown here:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“开始”，如图所示：
- en: '![](img/7fff37d1-b81e-4220-8dc7-74cd10389323.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fff37d1-b81e-4220-8dc7-74cd10389323.png)'
- en: 'On clicking this, your CPU usage may go higher as Visual Studio spawns the
    MSBuild and tests runner processes in the background. In a short while, the editor
    will display the code coverage of the individual lines of code that are covered
    by the unit test. The following image displays the lines of code in `AuthenticationController`
    that are covered by the unit test. On clicking the right icon, it displays the
    tests covering this line of code and also provides the option to run and debug
    the test:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮后，你的CPU使用率可能会升高，因为Visual Studio会在后台启动MSBuild和测试运行器进程。在短时间内，编辑器将显示由单元测试覆盖的各个代码行的代码覆盖率。以下图像显示了由单元测试覆盖的`AuthenticationController`中的代码行。单击右侧图标，它会显示覆盖此代码行的测试，并提供运行和调试测试的选项：
- en: '![](img/e66530b5-25c2-41af-bb11-b5b9327bbbd0.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e66530b5-25c2-41af-bb11-b5b9327bbbd0.png)'
- en: Similarly, if we open the test file, it will show the indicator there as well.
    Super cool, right!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们打开测试文件，它也会在那里显示指示器。太酷了，对吧！
- en: 'If we navigate to Test|Live Unit Testing now, we would see the options to Stop
    and Pause. So, in case we wish to save  our resources after getting the data once,
    we can pause or stop Live Unit Testing:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在导航到“测试|实时单元测试”，我们会看到停止和暂停的选项。所以，如果我们希望在获取数据后保存资源，我们可以暂停或停止实时单元测试：
- en: '![](img/24ba706b-894e-47a2-a1f0-0e6b2fa9501e.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24ba706b-894e-47a2-a1f0-0e6b2fa9501e.png)'
- en: 'There are numerous icons which indicates the code coverage status of individual
    lines of code. These are:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多图标表示单个代码行的代码覆盖率状态。这些是：
- en: '**Red cross**: Indicates that the line is covered by at least one failing test'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色交叉**：表示该行至少被一个失败的测试覆盖'
- en: '![](img/deaba7b9-0b62-4972-a9da-b408d0954e11.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/deaba7b9-0b62-4972-a9da-b408d0954e11.png)'
- en: '**Green check mark**: Indicates that the line is covered by only passing tests'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色勾选标记**：表示该行仅由通过测试覆盖'
- en: '![](img/9cc0d169-5bd9-4ed4-ba31-f6c14f26bfa0.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cc0d169-5bd9-4ed4-ba31-f6c14f26bfa0.png)'
- en: '**Blue dash**: Indicates that the line is not covered by any test'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝色破折号**：表示该行没有任何测试覆盖'
- en: '![](img/2f63d887-8e5b-4df0-8760-8a49a140bfea.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f63d887-8e5b-4df0-8760-8a49a140bfea.png)'
- en: If you see a clock-like icon just below any of these icons, it indicates that
    the data is not up to date. With this productivity enhancing feature, we conclude
    our discussion on basic unit testing. Next we will learn about containers and
    how we can do the deployment and testing of our .NET Core 2.0 applications in
    containers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这些图标下方有类似时钟的图标，它表示数据尚未更新。有了这个提高生产力的功能，我们结束了关于基本单元测试的讨论。接下来，我们将学习容器以及如何在容器中部署和测试我们的.NET
    Core 2.0应用程序。
- en: Introduction to containers
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简介
- en: 'Think of a container as just another process running in the machine; it''s
    just that they offer a lot more isolation than a normal process does. So, we define
    a container as an isolated process. A container can have its own filesystem, own
    network IP address, own hostname, own registry, own unique resources and so on.
    A question that would come to mind is: *Why Containers?* In the modern world,
    where new software comes in and changes overnight, there are numerous challenges
    in:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器想象成在机器上运行的另一个进程；只是它们提供的隔离性比普通进程要多得多。因此，我们将容器定义为隔离的进程。容器可以有自己的文件系统、自己的网络IP地址、自己的主机名、自己的注册表、自己独特的资源等等。一个可能会想到的问题是：**为什么是容器**？在现代社会，新的软件一夜之间出现并改变，在以下方面存在许多挑战：
- en: '**Discovering the software**: There is no single point at which to find all
    software. A few are available as executables on the developer sites, a few in
    platform-specific application stores, a few as package managers, and so on and
    so forth.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发现软件**：没有单一的地方可以找到所有软件。一些作为可执行文件在开发者网站上提供，一些在特定平台的应用程序商店中提供，一些作为包管理器提供，等等。'
- en: '**Installing the software**: Software can be installed on specific OS, CPU
    architectures, OS versions, and build versions with the relevant prerequisites.
    Over a period of time, this becomes messy and confusing.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装软件**：软件可以安装在特定的操作系统、CPU架构、操作系统版本和构建版本上，并具有相关的先决条件。随着时间的推移，这会变得混乱和令人困惑。'
- en: '**Running the software**: We have all faced the issue where *I am unable to
    find that software that I  downloaded*. Applications that are installed and updated
    in the registry are easy to find but the ones that run as stand alone executables
    are more likely to missed. On top of that, we have licensing, upgrades, documentation,
    paths, and so on to take care of if we wish to run the software. On top of it,
    are we 100% sure that the executable that we are running is secure and would not
    cause a security breach if it''s run on the machine?'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行软件**：我们都遇到过找不到下载的软件的问题。在注册表中安装和更新的应用程序很容易找到，但作为独立可执行文件运行的那些则更容易被遗漏。除此之外，如果我们想运行软件，我们还需要处理许可、升级、文档、路径等问题。更重要的是，我们是否100%确信我们正在运行的可执行文件是安全的，并且如果在机器上运行不会导致安全漏洞？'
- en: These slightly over exaggerated points highlight that there are challenges a
    plenty in discovering, installing, and running software. Containers are about
    software and relieve much of this pain. Just as shipping containers allow goods
    to be transported by ship, train, or truck regardless of the cargo inside, software
    containers act as a standard unit of software that can contain different code
    and dependencies. Containerizing software this way enables developers and IT professionals
    to deploy them across environments, with little or no modification. Containers
    also isolate applications from each other on a shared OS. Containerized applications
    run on top of a container host that in turn runs on the OS (Linux or Windows).
    Containers therefore have a significantly smaller footprint than **virtual machine**
    (**VM**) images. There is a myth that containers are replacements for VMs, which
    is incorrect. Containers require fewer resources than VMs, and hence a server
    can host more containers than VMs, making choice easier when there is a confusion.
    There are a number of containers available in the market today such as LXC, Docker,
    and so on. We will use Docker as our container, and will discuss it next.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些略微夸张的观点突显了在发现、安装和运行软件过程中存在许多挑战。容器关注软件，并缓解了许多这种痛苦。正如海运集装箱允许货物无论内部装载何种货物都能通过船只、火车或卡车运输一样，软件容器充当了一个标准的软件单元，可以包含不同的代码和依赖项。以这种方式容器化软件使得开发人员和IT专业人员能够在不同的环境中部署它们，几乎无需或只需很少的修改。容器还可以在共享的操作系统上隔离应用程序。容器化应用程序在容器宿主上运行，而容器宿主又运行在操作系统（Linux或Windows）上。因此，容器比**虚拟机**（**VM**）图像具有显著更小的占用空间。有一个误区认为容器是虚拟机的替代品，这是不正确的。容器比虚拟机需要更少的资源，因此服务器可以托管比虚拟机更多的容器，这使得在存在混淆时选择更加容易。目前市场上有很多容器，如LXC、Docker等。我们将使用Docker作为我们的容器，并在下一节中讨论它。
- en: Docker
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: 'Docker is an open source project for automating the deployment of applications
    as portable, self-sufficient containers that can run on the cloud or on-premise.
    Docker is also a company that promotes and evolves this technology. Docker works
    in collaboration with cloud, Linux, and Windows vendors, including Microsoft.
    Docker image containers run natively on Linux and Windows. Windows images run
    only on Windows hosts and Linux images run only on Linux hosts. The host is a
    server or a VM. Docker containers package an application with everything it needs
    to run: code, runtime, system tools, system libraries—anything we would install on
    a server for the application to run.  A container is an isolated place where an
    application can run without affecting the rest of the system, and vice versa.
    This makes them an ideal way to package and run applications in production environments. 
    Additionally, as discussed previously, Docker containers are lightweight which
    enables scaling applications quickly by spinning up new instances.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个开源项目，旨在自动化应用程序的部署，作为可移植的、自给自足的容器，可以在云或本地运行。Docker也是一个推广和演进这一技术的公司。Docker与云、Linux和Windows供应商合作，包括微软。Docker镜像容器在Linux和Windows上原生运行。Windows镜像只能在Windows宿主上运行，Linux镜像只能在Linux宿主上运行。宿主是一个服务器或虚拟机。Docker容器打包了一个应用程序运行所需的一切：代码、运行时、系统工具、系统库——任何我们会在服务器上安装以使应用程序运行的东西。容器是一个隔离的地方，应用程序可以在其中运行而不影响系统其他部分，反之亦然。这使得它们成为在生产环境中打包和运行应用程序的理想方式。此外，如前所述，Docker容器是轻量级的，这使得通过启动新实例快速扩展应用程序成为可能。
- en: 'Before we  deploy our Let''s Chat application in Docker, let''s get familiar
    with Docker terminology from Microsoft''s official documentation site, ([https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/container-docker-introduction/docker-terminology](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/container-docker-introduction/docker-terminology)):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署Let's Chat应用程序到Docker之前，让我们从微软官方文档网站熟悉一下Docker术语（[https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/container-docker-introduction/docker-terminology](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/container-docker-introduction/docker-terminology)）：
- en: '**Container image**: It is a package with all the dependencies and information
    needed to create a container. An image includes all the dependencies such as frameworks,
    deployment, and the execution configuration to be used by a container at runtime.
    An image is immutable once it has been created.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器镜像**：它是一个包含创建容器所需的所有依赖项和信息打包。镜像包括所有依赖项，如框架、部署和容器在运行时使用的执行配置。一旦创建，镜像就是不可变的。'
- en: '**Container**: An instance of a Docker image is called a container. It represents
    the execution of a single application, process, or service. It consists of the
    contents of a Docker image, an execution environment, and a standard set of instructions.
    When scaling a service, we create multiple instances of a container from the same
    image.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：Docker图像的实例称为容器。它代表单个应用程序、进程或服务的执行。它由Docker图像的内容、执行环境和一组标准指令组成。在扩展服务时，我们创建来自同一图像的多个容器实例。'
- en: '**Tag**: A mark or label applied to images, so that different images or versions
    can be identified.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：应用于图像的标记或标签，以便可以识别不同的图像或版本。'
- en: '**Dockerfile**: It is a text file that contains instructions to build a Docker
    image.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：它是一个包含构建Docker镜像指令的文本文件。'
- en: '**Build**: The action of building a container image, based on the information
    and context provided by its Docker file, and additional files in the folder where
    the image is built. We can build images with the Docker docker build command.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：基于Dockerfile提供的信息和上下文以及构建图像的文件夹中的附加文件来构建容器图像的操作。我们可以使用Docker的docker
    build命令来构建图像。'
- en: '**Repository**: A collection of related Docker images, labeled with a tag that
    indicates the image version.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储库**：一组相关的Docker图像，带有标签，指示图像版本。'
- en: '**Registry**: A service that provides access to repositories. The default registry
    for most public images is the Docker Hub (owned by Docker as an organization).
    A registry usually contains repositories from multiple teams. Companies often
    have private registries to store and manage images they''ve created; the Azure
    Container Registry is another example.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册表**：提供对存储库访问的服务。大多数公共图像的默认注册表是Docker Hub（由Docker组织拥有）。注册表通常包含来自多个团队的存储库。公司通常有自己的私有注册表来存储和管理他们创建的图像；Azure容器注册表是另一个例子。'
- en: '**Docker Hub**: A public registry to upload images and work with them. Docker
    Hub provides Docker image hosting, public or private registries, build triggers
    and web hooks, and integration with GitHub and Bitbucket.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：一个公共注册表，用于上传图像并与之交互。Docker Hub提供Docker镜像托管、公共或私有注册表、构建触发器和Web钩子，以及与GitHub和Bitbucket的集成。'
- en: '**Azure Container Registry**: A public resource for working with Docker images
    and its components in Azure. This provides a registry that is close to deployments
    in Azure and that gives control over access, making it possible to use Azure Active
    Directory groups and permissions.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure容器注册表**：在Azure中处理Docker图像及其组件的公共资源。这提供了一个与Azure部署接近的注册表，并提供了对访问的控制，使得可以使用Azure
    Active Directory组和权限。'
- en: '**Compose**: A command-line tool and YAML file format with metadata for defining
    and running multi-container applications. We define a single application based
    on multiple images with one or more `.yml` files that can override values depending
    on the environment. After creating the definitions, we can deploy the whole multi-container
    application with a single command (`docker-compose up`) that creates a container
    per image on the Docker host.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Compose**：一个命令行工具和YAML文件格式，用于定义和运行多容器应用程序。我们基于多个图像定义一个应用程序，使用一个或多个`.yml`文件，这些文件可以根据环境覆盖值。在创建定义后，我们可以使用单个命令（`docker-compose
    up`）部署整个多容器应用程序，该命令在Docker主机上为每个图像创建一个容器。'
- en: This is just a basic introduction to Docker to get us started. There is a lot
    to be learned, so much so that a complete book can be written on Docker itself.
    So, interested and curious readers should spend quality time in familiarizing
    themselves with Docker from the Docker documentation site, or Microsoft's documentation
    on Docker.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于Docker的基本介绍，以帮助我们开始。还有很多东西要学习，以至于可以写一本关于Docker本身的完整书籍。因此，对Docker感兴趣和好奇的读者应该在Docker文档网站上花些时间熟悉Docker，或者阅读微软关于Docker的文档。
- en: 'Now that we have some context about Docker, let''s try and deploy our Let''s
    Chat application in a Docker container, using the tooling provided by Visual Studio
    2017\. To do so, we will follow these steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Docker有一些了解，让我们尝试使用Visual Studio 2017提供的工具在Docker容器中部署我们的Let's Chat应用程序。为此，我们将遵循以下步骤：
- en: If you have used Visual Studio 2017 and worked along with the chapters thus
    far, you already have Docker support enabled with the Visual Studio installation.
    If not, you would need to modify the Visual Studio 2017 installation and choose
    the .NET Core cross-platform development workload.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经使用了Visual Studio 2017并且与到目前为止的章节一起工作，那么你已经在Visual Studio安装中启用了Docker支持。如果没有，你需要修改Visual
    Studio 2017安装并选择.NET Core跨平台开发工作负载。
- en: Next, we will need to install Docker for Windows from [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/).
    It's a simple installation in which you just need to do Next | OK | Finish stuff,
    so we will not discuss it here. As of writing this chapter, 17.12 is the latest
    version.[](https://docs.docker.com/docker-for-windows/install/)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要从[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)安装
    Docker for Windows。这是一个简单的安装过程，你只需要点击下一步 | 确定 | 完成，所以我们在这里不讨论它。截至编写本章时，17.12 是最新版本。[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
- en: 'Once the installation is successful, we would see a dialog as shown here:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，我们会看到一个对话框，如图所示：
- en: '![](img/08ae1984-ba70-4678-9a5c-9a92ecbdbcc0.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08ae1984-ba70-4678-9a5c-9a92ecbdbcc0.png)'
- en: 'Next, we would need to share the drive in our local machine with Docker, where
    the images can be built and run. To do this, right-click on the Docker system
    tray icon and click Settings, as shown here:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将本地机器上的驱动器与 Docker 共享，以便构建和运行镜像。为此，右键单击 Docker 系统托盘图标并点击设置，如图所示：
- en: '![](img/646112c7-3269-45ad-98aa-d51b30394747.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/646112c7-3269-45ad-98aa-d51b30394747.png)'
- en: Share the drive where the images will run from in the Shared Drives tab of Settings.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中的共享驱动器选项卡中共享将运行镜像的驱动器。
- en: Now, open the Let's Chat project in Visual Studio 2017.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 Visual Studio 2017 中打开 Let's Chat 项目。
- en: Right-click on `LetsChat.csproj` and choose Add | Docker Support.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`LetsChat.csproj`并选择添加 | Docker 支持。
- en: 'Visual Studio would do all the heavy lifting for us and add a Docker file amongst
    a few others as shown here:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将为我们做所有繁重的工作，并在其他几个文件中添加一个 Docker 文件，如图所示：
- en: '![](img/4c387b17-31b0-466a-a4c9-c860364e9ac9.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c387b17-31b0-466a-a4c9-c860364e9ac9.png)'
- en: 'We can also see that the  Start  button in the command bar has changed to Docker,
    as shown here:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以看到，命令栏中的“开始”按钮已更改为 Docker，如图所示：
- en: '![](img/7a3cde48-2eaa-4a2a-8937-6652f32d0366.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a3cde48-2eaa-4a2a-8937-6652f32d0366.png)'
- en: With this, we are done with our steps. Just click on the Docker button (or press
    *F5*) and the application will run in the Docker container.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，我们就完成了这些步骤。只需点击 Docker 按钮（或按 *F5*）即可在 Docker 容器中运行应用程序。
- en: We will see in [Chapter 10](ch10.html), *Functional Programming with F#* how
    we can deploy the application in the cloud, as well as how we can deploy Docker
    containers in Azure. This wraps up our discussion on Docker containers. We will
    conclude this chapter by learning to develop a FAQ Bot using the Microsoft Bot
    Framework.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 10 章](ch10.html)“使用 F# 的函数式编程”中，我们将看到如何将应用程序部署到云中，以及如何在 Azure 中部署 Docker
    容器。这总结了我们对 Docker 容器的讨论。我们将通过学习如何使用 Microsoft Bot Framework 开发一个 FAQ 机器人来结束本章。
- en: Bot 101
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人 101
- en: 'A Chatbot, also known as talkbot, chatterbot, Bot, or IM bot, is a computer
    program which conducts a conversation through auditory or textual methods. Such
    programs are often designed to convincingly simulate how a human would behave
    as a conversational partner, thereby passing the Turing test. Chatbots are typically
    used in dialog systems for various practical purposes, including customer service
    or information acquisition. You would have noticed that various sites offer live
    chat with agents as it helps them gain better customer experience and business.
    In this section, we will see how we can quickly create a simple Chatbot to answer
    the basic questions. This section is completely informational and just provides
    a basic 100-level awareness of how a simple Chatbot can be created and the related
    technology. Curious and enthusiastic readers can explore other avenues from this
    basic knowledge. Let''s learn to develop a simple FAQ Bot, which will answer simple
    queries like:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人，也称为对话机器人、聊天机器人、机器人或即时消息机器人，是一种通过听觉或文本方式进行对话的计算机程序。这些程序通常被设计成能够令人信服地模拟人类作为对话伙伴的行为，从而通过图灵测试。聊天机器人通常用于对话系统，用于各种实际目的，包括客户服务或信息获取。你可能会注意到，各种网站提供与代理的实时聊天，因为它有助于他们获得更好的客户体验和业务。在本节中，我们将看到如何快速创建一个简单的聊天机器人来回答基本问题。本节完全为信息性内容，仅提供关于如何创建简单聊天机器人和相关技术的基本
    100 级别认识。好奇和热情的读者可以从这些基础知识探索其他途径。让我们学习如何开发一个简单的 FAQ 机器人，它将回答像以下这样的简单查询：
- en: How do I use Let's Chat?
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何使用 Let's Chat？
- en: How are you?
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你好吗？
- en: Hello!
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你好！
- en: Bye!
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再见！
- en: 'The more you train the Bot and the more questions you put in its knowledge
    base, the better it will be, so let''s get started. First of all, we need to create
    a page that can be accessed anonymously, as this is **frequently asked questions**
    (**FAQ** ), and hence the user should not be required to be logged in to the system
    to access this page. To do so, let''s create a new controller called `FaqController`
    in our `LetsChat.csproj`. It will be a very simple class with just one action
    called `Index`, which will display the FAQ page. The code is as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您训练Bot的次数越多，放入其知识库的问题越多，它就会变得越好，所以让我们开始吧。首先，我们需要创建一个可以匿名访问的页面，因为这个是**常见问题解答**（**FAQ**），因此用户不应需要登录到系统中才能访问这个页面。为此，让我们在我们的`LetsChat.csproj`中创建一个新的控制器，名为`FaqController`。它将是一个非常简单的类，只有一个名为`Index`的操作，该操作将显示FAQ页面。代码如下：
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that we have used the `[AllowAnonymous]` attribute, so that  this controller
    can be accessed even if the user is not logged in. The corresponding `.cshtml`
    is also very simple. In the solution explore, right-click on the Views folder
    under the `LetsChat` project and create a folder named `Faq` and then add an `Index.cshtml`
    file in that folder. The markup of the `Index.cshtml` would look like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经使用了`[AllowAnonymous]`属性，因此即使用户未登录，也可以访问这个控制器。相应的`.cshtml`文件也非常简单。在解决方案探索中，在`LetsChat`项目下的`Views`文件夹上右键单击，创建一个名为`Faq`的文件夹，然后在那个文件夹中添加一个`Index.cshtml`文件。`Index.cshtml`的标记将如下所示：
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Nothing much here apart from the welcome message. The message displays the username
    if the user is authenticated, else it displays `Guest`. Now, we need to integrate
    the Chatbot stuff in this page. To do so, let's browse to [http://qnamaker.ai](http://qnamaker.ai).
    This is Microsoft's QnA (as in questions and answers) maker site which a free,
    easy-to-use, REST API and web-based service that trains **artificial intelligence**
    (**AI**) to respond to user questions in a more natural, conversational way. Compatible
    across development platforms, hosting services, and channels, QnA Maker is the
    only question and answer service with a graphical user interface—meaning you don’t
    need to be a developer to train, manage, and use it for a wide range of solutions.
    And that is what makes it incredibly easy to use. You would need to log in to
    this site with your Microsoft account (`@microsoft`/`@live`/`@outlook`).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里除了欢迎信息之外没有太多内容。如果用户已认证，信息会显示用户名，否则会显示`Guest`。现在，我们需要将聊天机器人的内容整合到这个页面中。为此，让我们浏览到[http://qnamaker.ai](http://qnamaker.ai)。这是微软的QnA（即问题和答案）创建网站，它提供了一个免费、易于使用的REST
    API和基于Web的服务，该服务训练**人工智能**（**AI**）以更自然、更对话的方式响应用户的问题。QnA Maker与开发平台、托管服务和渠道兼容，是唯一具有图形用户界面的问答服务——这意味着您不需要是开发者就可以训练、管理和使用它来解决各种问题。这正是它使用起来如此简单的原因。您需要使用您的微软账户（`@microsoft`/`@live`/`@outlook`）登录到这个网站。
- en: 'If you don''t have one, you should create one and log in. On the very first
    login, the site would display a dialog seeking permission to access your email
    address and profile information. Click Yes and grant permission:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有，您应该创建一个并登录。在第一次登录时，网站会显示一个对话框，请求访问您的电子邮件地址和配置文件信息。点击“是”并授予权限：
- en: '![](img/379293d3-5aea-441f-8dc5-381bb76224d8.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/379293d3-5aea-441f-8dc5-381bb76224d8.png)'
- en: 'You would then be presented with the service terms. Accept that as well. Then
    navigate to the Create New Service tab. A form will appear as shown here:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到服务条款。也接受这些条款。然后导航到“创建新服务”标签。将出现一个表单，如下所示：
- en: '![](img/db61900f-1dd1-4017-a5f1-439bae9bd77a.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db61900f-1dd1-4017-a5f1-439bae9bd77a.png)'
- en: 'The form is easy to fill in and provides the option to extract the question/answer
    pairs from a site or `.tsv`, `.docx`, `.pdf`, and `.xlsx` files. We don''t have
    questions handy and so we will type them; so do not bother about these fields.
    Just enter the service name and click the Create button. The service should be
    created successfully and the knowledge base screen should be displayed. We will
    enter probable questions and answers in this knowledge base. If the user types
    a question that resembles the question in the knowledge base, it will respond
    with the answer in the knowledge base. Hence, the more questions and answers we
    type, the better it will perform. So, enter all the questions and answers that
    you wish to enter, test it in the local Chatbot setup, and, once you are happy
    with it, click on Publish. This would publish the knowledge bank and share the
    sample URL to make the HTTP request. Note it down in a notepad. It contains the
    knowledge base identifier guide, hostname, and subscription key. With this, our
    questions and answers are ready and deployed. We need to display a chat interface,
    pass the user-entered text to this service, and display the response from this
    service to the user in the chat user interface. To do so, we will make use of
    the Microsoft Bot Builder SDK for .NET and follow these steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 表格填写简单，并提供从网站或 `.tsv`、`.docx`、`.pdf` 和 `.xlsx` 文件中提取问题/答案对的功能。我们手头没有现成的问题，所以我们将手动输入；因此，不要担心这些字段。只需输入服务名称并点击“创建”按钮。服务应该创建成功，并显示知识库屏幕。我们将在此知识库中输入可能的问题和答案。如果用户输入的问题与知识库中的问题相似，它将回答知识库中的答案。因此，我们输入的问题和答案越多，性能越好。所以，输入所有您希望输入的问题和答案，在本地聊天机器人设置中进行测试，一旦您对其满意，请点击“发布”。这将发布知识库，并分享用于HTTP请求的示例URL。在记事本中记录下来。它包含知识库标识符指南、主机名和订阅密钥。有了这些，我们的问题和答案就准备好了并部署了。我们需要显示聊天界面，将用户输入的文本传递给此服务，并在聊天用户界面中显示此服务对用户的响应。为此，我们将使用Microsoft
    Bot Builder SDK for .NET并遵循以下步骤：
- en: Download the `Bot Application` project template from [http://aka.ms/bf-bc-vstemplate.](http://aka.ms/bf-bc-vstemplate)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://aka.ms/bf-bc-vstemplate.](http://aka.ms/bf-bc-vstemplate)下载`Bot Application`项目模板。
- en: Download the `Bot Controller` item template from [http://aka.ms/bf-bc-vscontrollertemplate.](http://aka.ms/bf-bc-vscontrollertemplate)
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://aka.ms/bf-bc-vscontrollertemplate.](http://aka.ms/bf-bc-vscontrollertemplate)下载`Bot
    Controller`项目模板。
- en: Download the `Bot Dialog` item template from [http://aka.ms/bf-bc-vsdialogtemplate.](http://aka.ms/bf-bc-vsdialogtemplate)
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://aka.ms/bf-bc-vsdialogtemplate.](http://aka.ms/bf-bc-vsdialogtemplate)下载`Bot
    Dialog`项目模板。
- en: Next, identify the project template and item template directory for Visual Studio
    2017\. The project template directory is located at `%USERPROFILE%\Documents\Visual
    Studio 2017\Templates\ProjectTemplates\Visual C#\` and the item template directory
    is located at `%USERPROFILE%\Documents\Visual Studio 2017\Templates\ItemTemplates\Visual
    C#\`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确定Visual Studio 2017的项目模板和项目模板目录。项目模板目录位于`%USERPROFILE%\Documents\Visual
    Studio 2017\Templates\ProjectTemplates\Visual C#\`，项目模板目录位于`%USERPROFILE%\Documents\Visual
    Studio 2017\Templates\ItemTemplates\Visual C#\`。
- en: Copy the `Bot Application` project template to the project template directory.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Bot Application`项目模板复制到项目模板目录。
- en: Copy the `Bot Controller` ZIP and `Bot Dialog` ZIP to the item template directory.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Bot Controller` ZIP和`Bot Dialog` ZIP复制到项目模板目录。
- en: 'In the solution explorer of the `LetsChat` project, right-click on the solution
    and add a new project. Under Visual C#, we should now start seeing a `Bot Application`
    template as shown here:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LetsChat`项目的解决方案资源管理器中，右键单击解决方案并添加一个新的项目。在Visual C#下，我们现在应该开始看到如图所示的`Bot Application`模板：
- en: '![](img/97f782e4-e57f-4cba-8d7e-0e0dad251975.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97f782e4-e57f-4cba-8d7e-0e0dad251975.png)'
- en: Name the project `FaqBot` and click OK.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`FaqBot`并点击“确定”。
- en: A new project will be created in the solution, which looks similar to the MVC
    project template. Build the project, so that all the dependencies are resolved
    and packages are restored. If you run the project, it is already a working Bot,
    which can be tested by the Microsoft Bot Framework emulator. Download the BotFramework-Emulator
    setup executable from [https://github.com/Microsoft/BotFramework-Emulator/releases/.](https://github.com/Microsoft/BotFramework-Emulator/releases/tag/v3.5.34)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案中创建一个新的项目，其外观类似于MVC项目模板。构建项目，以便解决所有依赖关系并恢复包。如果您运行项目，它已经是一个可工作的聊天机器人，可以通过Microsoft
    Bot Framework模拟器进行测试。从[https://github.com/Microsoft/BotFramework-Emulator/releases/.](https://github.com/Microsoft/BotFramework-Emulator/releases/tag/v3.5.34)下载BotFramework-Emulator设置可执行文件。
- en: 'Let''s run the Bot project by hitting *F5*. It will display a page pointing
    to the default URL of `http://localhost:3979`. Now, open the Bot framework emulator
    and navigate to the preceding URL and append `api/messages`; to it, that is, browse
    to `http://localhost:3979/api/messages` and click Connect. On successful connection
    to the Bot, a chat-like interface will be displayed in which you can type the
    message. The following screenshot displays this step:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过按*F5*来运行Bot项目。它将显示一个指向默认URL `http://localhost:3979` 的页面。现在，打开Bot框架模拟器并导航到前面的URL，并在其后附加
    `api/messages`；即浏览到 `http://localhost:3979/api/messages` 并点击连接。在成功连接到Bot后，将显示一个类似聊天的界面，在其中您可以输入消息。以下截图显示了此步骤：
- en: '![](img/9001ba6a-df8a-4b4f-a3aa-e31e8ca3fe45.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9001ba6a-df8a-4b4f-a3aa-e31e8ca3fe45.png)'
- en: 'We have a working Bot in place which just returns the text along with its length.
    We need to modify this Bot, to pass the user input to our QnA Maker service and
    display the response returned from our service. To do so, we will need to check
    the code of `MessagesController` in the `Controllers` folder. We notice that it
    has just one method called `Post`, which checks the activity type, does specific
    processing for the activity type, creates a response, and returns it. The calculation
    happens in the `Dialogs.RootDialog` class, which is where we need to make the
    modification to wire up our QnA service. The modified code is shown here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个正在运行的Bot，它只是返回文本及其长度。我们需要修改这个Bot，将用户输入传递到我们的QnA Maker服务，并显示从我们的服务返回的响应。为此，我们需要检查`Controllers`文件夹中`MessagesController`的代码。我们注意到它只有一个名为`Post`的方法，该方法检查活动类型，对活动类型进行特定处理，创建响应，并返回它。计算发生在`Dialogs.RootDialog`类中，我们需要在这里进行修改以连接我们的QnA服务。修改后的代码如下所示：
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code is pretty straightforward. First, we add the QnA Maker service subscription
    key, host URL, and knowledge base ID in the `appSettings` section of `Web.config`.
    Next, we read these app settings into static variables so that they are available
    always. Next, we modify the `MessageReceivedAsync` method of the dialog to pass
    the user input to the QnA service and return the response of the service back
    to the user. The `QnAResult` class can be seen from the source code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。首先，我们在`Web.config`的`appSettings`部分添加QnA Maker服务的订阅密钥、主机URL和知识库ID。然后，我们将这些应用程序设置读取到静态变量中，以便它们始终可用。接下来，我们修改对话框的`MessageReceivedAsync`方法，将用户输入传递到QnA服务，并将服务的响应返回给用户。`QnAResult`类可以在源代码中看到。
- en: 'This can be tested in the emulator by typing in any of the questions that we
    have stored in our knowledge base, and we will get the appropriate response, as
    shown next:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以在模拟器中通过输入我们存储在知识库中的任何问题来测试，我们将得到适当的响应，如下所示：
- en: '![](img/9df01620-17e1-4d87-9b4c-829bba6e86ee.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9df01620-17e1-4d87-9b4c-829bba6e86ee.png)'
- en: Deploying it in our Let's Chat application would need a basic knowledge of Azure,
    which we have not touched on yet. We will continue deploying and integrating this
    Chatbot in our Let's Chat application later in [Chapter 10](https://cdp.packtpub.com/_net_core_2_0_by_example/wp-admin/post.php?post=174&action=edit#post_376), *Functional
    Programming with F#*, when we discuss and learn Azure fundamentals and will be
    deploying ASP.NET Core 2.0 applications in the cloud.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Let's Chat应用程序中部署它需要基本的Azure知识，我们尚未涉及。我们将在第10章[功能编程与F#](https://cdp.packtpub.com/_net_core_2_0_by_example/wp-admin/post.php?post=174&action=edit#post_376)中继续部署和集成这个Chatbot，届时我们将讨论和学习Azure基础知识，并将部署ASP.NET
    Core 2.0应用程序到云端。
- en: This concludes our awareness discussion on developing a basic Chatbot using
    the Microsoft Bot Framework, the QnA Maker service, and ASP.NET Core 2.0\. The
    Bot can be deployed in Azure and can be integrated to work with a variety of channels
    such as Skype, Facebook, web chat, and so on. With this, we conclude our chapter
    as well. In the next chapter, we would look into a new term that has sprung up
    over the last few years called microservices, with respect to ASP.NET Core 2.0.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们关于使用Microsoft Bot Framework、QnA Maker服务和ASP.NET Core 2.0开发基本Chatbot的认识讨论。该Bot可以部署到Azure，并且可以与Skype、Facebook、网页聊天等多种渠道集成。至此，我们也结束了本章。在下一章中，我们将探讨一个在最近几年涌现出的新术语，即微服务，与ASP.NET
    Core 2.0相关。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt about Razor syntax, Views, Razor pages, and Tag Helpers.
    We then coded the Chat hub module of our Let's Chat application. We also learnt
    the importance of testing and how we can write unit tests using Moq and xUnit.
    We saw a new productivity-enhancing feature introduced in Visual Studio 2017 Enterprise
    edition called Live Unit Testing and how it helps us write better-quality code.
    We also learnt about containers and how we can deploy our application in Docker
    from Visual Studio itself. We concluded the chapter by learning about developing
    a FAQ Bot using the Microsoft Bot Framework and ASP.NET Core 2.0\. We have not
    deployed our application in the cloud yet, which we will do in [Chapter 10](https://cdp.packtpub.com/_net_core_2_0_by_example/wp-admin/post.php?post=174&action=edit#post_376), *Functional
    Programming with F#*. In the next couple of chapters, we will delve into the new
    world of microservices.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Razor 语法、视图、Razor 页面和标签助手。然后我们为我们的 Let's Chat 应用程序编码了聊天模块。我们还学习了测试的重要性以及如何使用
    Moq 和 xUnit 编写单元测试。我们看到了 Visual Studio 2017 企业版中引入的一个新的提高生产力的功能，称为实时单元测试，以及它是如何帮助我们编写更高质量的代码的。我们还学习了容器以及如何从
    Visual Studio 本身部署我们的应用程序到 Docker。我们通过学习使用 Microsoft Bot Framework 和 ASP.NET Core
    2.0 开发 FAQ 机器人来结束本章。我们尚未将我们的应用程序部署到云端，这将在第 10 章[功能编程与 F#](https://cdp.packtpub.com/_net_core_2_0_by_example/wp-admin/post.php?post=174&action=edit#post_376)中完成。在接下来的几章中，我们将深入探讨微服务的新世界。
