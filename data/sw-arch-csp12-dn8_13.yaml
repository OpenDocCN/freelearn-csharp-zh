- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Interacting with Data in C# – Entity Framework Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中与数据交互 - Entity Framework Core
- en: 'As we mentioned in *Chapter 7*, *Understanding the Different Domains in Software
    Solutions*, software systems are organized into layers that communicate with each
    other through interfaces and classes that don’t depend on how the peculiarities
    of each layer are implemented. When the software is a business/enterprise system,
    it usually contains at least three layers: the data layer, the business layer,
    and the presentation layer, if the software is based on a classical layer architecture
    (see the *Classic layers architecture* section of *Chapter 7*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第7章中提到的，*理解软件解决方案中的不同领域*，软件系统被组织成层，通过接口和类进行通信，这些接口和类不依赖于每个层的实现特性。当软件是商业/企业系统时，它通常至少包含三个层：数据层、业务层和表示层，如果软件基于经典层架构（参见第7章的*经典层架构*部分）。
- en: If, instead, the application is based on an onion architecture, an outermost
    layer contains presentation logic, drivers, and testing logic, then there is an
    application layer, and finally, a domain layer (see the *Onion architecture* section
    of *Chapter 7*). While, in the onion architecture, layers are defined in a slightly
    different way, the functionalities of the three layers of the onion architecture
    are basically the same as the ones of the three layers of the classical layer
    architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序基于洋葱架构，最外层包含表示逻辑、驱动程序和测试逻辑，那么就有一个应用层，最后是一个领域层（参见第7章的*洋葱架构*部分）。虽然，在洋葱架构中，层被定义的方式略有不同，但洋葱架构的三个层的功能基本上与经典层架构的三个层相同。
- en: However, notwithstanding the differences among all possible architectural choices,
    experience has proved that the main functionalities needed to handle data efficaciously
    are quite standard.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管所有可能的架构选择之间都有所不同，但经验证明，处理数据所需的主要功能相当标准化。
- en: More specifically, in all architectures described in *Chapter 7**,* data-processing
    layers have the main purpose of mapping data from a data storage subsystem into
    objects and vice versa.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在第7章中描述的所有架构中，数据处理层的主要目的是将数据从数据存储子系统映射到对象，反之亦然。
- en: In the case of the classical data layer, these objects are plain objects with
    no methods, while in the case of the domain layer, they are rich objects whose
    methods implement the application’s domain logic. Data layers, instead, implement
    the application’s domain logic within repository classes that are associated with
    their plain objects (see the *The Repository and Unit of Work patterns* section
    of *Chapter 7*).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典数据层的情况下，这些对象是没有方法的普通对象，而在领域层的情况下，它们是具有实现应用程序领域逻辑的方法的丰富对象。相反，数据层在与其普通对象关联的仓储类中实现应用程序的领域逻辑（参见第7章的*仓储和单元工作模式*部分）。
- en: This led to the conception of general-purpose frameworks for implementing data
    layers in a substantially declarative way. These tools are called **Object-Relational
    Mapping** (**ORM**) tools since they are data storage subsystems based on relational
    databases. However, they also work well with modern non-relational storage classified
    as NoSQL databases (such as MongoDB and Azure Cosmos DB) since their data model
    is closer to the target object model than a purely relational model.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了通用框架的概念，以大量声明性方式实现数据层。这些工具被称为**对象关系映射**（**ORM**）工具，因为它们是基于关系数据库的数据存储子系统。然而，它们也与现代非关系存储（如MongoDB和Azure
    Cosmos DB）很好地协同工作，因为它们的数据模型比纯关系模型更接近目标对象模型。
- en: ORMs improve and simplify the whole development process since they factor out
    and take away the burden of mapping data into objects and vice versa, so developers
    can focus just on the peculiarity of the business domain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ORMs通过将映射数据到对象以及反之亦然的负担分离出来，从而改进并简化了整个开发过程，因此开发者可以专注于业务领域的特性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding ORM basics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ORM基础
- en: Configuring Entity Framework Core
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Entity Framework Core
- en: Entity Framework Core migrations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core迁移
- en: Compiled models
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译模型
- en: Querying and updating data with Entity Framework Core
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Entity Framework Core查询和更新数据
- en: Deploying your data layer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署你的数据层
- en: Understanding Entity Framework Core advanced features
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Entity Framework Core高级功能
- en: This chapter describes ORMs and how to configure them, and then focuses on Entity
    Framework Core, the ORM included in .NET 8.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将描述ORM及其配置方法，然后重点关注包含在.NET 8中的ORM：Entity Framework Core。
- en: Before delving into ORM basics, let’s look at the technical requirements needed
    to follow the practical examples in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究ORM基础知识之前，让我们看看遵循本章中实际示例所需的技术要求。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2022 Community Edition or better
    with all the database tools installed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费Visual Studio 2022 Community Edition或更高版本，并安装所有数据库工具。
- en: All the concepts in this chapter will be clarified with practical examples.
    You will find the code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都将通过实际示例进行阐明。您可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到本章的代码。
- en: Understanding ORM basics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ORM基础知识
- en: ORMs map relational DB tables into in-memory collections of objects where object
    properties correspond to DB table columns. Types from C#, such as Booleans, numeric
    types, and strings, have corresponding DB types. If GUIDs are not available in
    the mapped DB, then types such as GUIDs are mapped to their equivalent string
    representations. All date and time types are mapped either to C# `DateTime` when
    the date/time contains no time zone information, to `DateTimeOffset` when the
    date/time also contains explicit time zone information, to `DateOnly` when the
    type contains just date information, or to `TimeOnly` when the type contains just
    time information. Any DB time duration is mapped to a `TimeSpan`. Finally, single
    characters should not be mapped at all to DB fields.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ORM将关系数据库表映射到内存中的对象集合，其中对象属性对应于数据库表列。来自C#的类型，如布尔值、数值类型和字符串，都有对应的数据库类型。如果映射的数据库中没有GUID，则GUID类型将映射到其等效的字符串表示形式。所有日期和时间类型都映射到C#的`DateTime`，当日期/时间不包含时区信息时；映射到`DateTimeOffset`，当日期/时间包含显式时区信息时；映射到`DateOnly`，当类型仅包含日期信息时；或映射到`TimeOnly`，当类型仅包含时间信息时。任何数据库时间持续时间都映射到`TimeSpan`。最后，单字符不应映射到数据库字段。
- en: Since the string properties of most object-oriented languages have no length
    limits associated with them (while DB string fields usually have length limits),
    the DB limits are taken into account in the DB mapping configuration. In general,
    when the mapping between DB types and object-oriented language types needs options
    to be specified, these options are declared in the mapping configuration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数面向对象语言的字符串属性没有与之关联的长度限制（而数据库字符串字段通常有长度限制），因此在数据库映射配置中考虑了数据库限制。一般来说，当需要在数据库类型和面向对象语言类型之间指定选项时，这些选项在映射配置中声明。
- en: 'The way the whole configuration is defined depends on the specific ORM. Entity
    Framework Core offers three options:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 整个配置的定义方式取决于具体的ORM。Entity Framework Core提供了三种选项：
- en: Data annotations (property attributes)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据注释（属性属性）
- en: Name conventions
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定
- en: A fluent configuration interface based on configuration objects and methods
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于配置对象和方法的流畅配置接口
- en: While the fluent interface can be used to specify any configuration option,
    the data annotations and name conventions can be used for a smaller subset of
    them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然流畅式接口可以用来指定任何配置选项，但数据注释和命名约定可以用于其中较小的一部分。
- en: Personally, I prefer using the fluent interface for most settings. I use name
    conventions only for specifying the principal key with an ID property name since
    I find that relying on name conventions for more complex settings is very dangerous.
    In fact, there are no compilation-time checks on name conventions, so a re-engineering
    operation might erroneously change or destroy some ORM settings.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我更喜欢使用流畅式接口来设置大多数设置。我只使用命名约定来指定具有ID属性名的主体键，因为我发现依赖命名约定来设置更复杂的设置非常危险。实际上，在命名约定上没有编译时检查，因此重工程操作可能会错误地更改或破坏一些ORM设置。
- en: I use data annotations mainly for specifying constraints on the possible values
    of properties, such as the maximum length of a value or the fact that a property
    is obligatory and can’t be null. In fact, these constraints restrict the type
    specified in each property, so placing them next to the properties they are applied
    to increases the code’s readability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我主要使用数据注释来指定属性可能值的约束，例如值的最大长度或属性是必需的且不能为null的事实。实际上，这些约束限制了每个属性中指定的类型，因此将它们放置在它们应用的属性旁边可以增加代码的可读性。
- en: All other settings are better grouped and organized by using the fluent interface
    in order to increase code readability and maintainability.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用流畅接口更好地分组和组织所有其他设置，可以提高代码的可读性和可维护性。
- en: Each ORM adapts to a specific DB type (Oracle, MySQL, SQL Server, and so on)
    with DB-specific adapters called **providers** or **connectors**. Entity Framework
    Core has providers for most of the available DB engines.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ORM都通过称为**提供程序**或**连接器**的数据库特定适配器来适应特定的数据库类型（Oracle、MySQL、SQL Server等）。Entity
    Framework Core为大多数可用的数据库引擎提供了提供程序。
- en: A complete list of providers can be found at [https://docs.microsoft.com/en-US/ef/core/providers/](https://docs.microsoft.com/en-US/ef/core/providers/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序的全列表可以在[https://docs.microsoft.com/en-US/ef/core/providers/](https://docs.microsoft.com/en-US/ef/core/providers/)找到。
- en: Adapters are necessary for the differences in DB types, for the way transactions
    are handled, and for all other features that are not standardized by the SQL language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器对于数据库类型之间的差异、事务处理方式以及SQL语言未标准化的所有其他功能都是必要的。
- en: Relationships among tables are represented with object pointers. For instance,
    in a one-to-many relationship, the class that’s mapped to the *one* side of the
    relationship contains a collection that is populated with the related objects
    on the *many* side of the relationship. On the other hand, the class mapped to
    the *many* side of the relationship has a simple property that is populated with
    a uniquely related object on the *one* side of the relationship.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表之间的关系通过对象指针来表示。例如，在一对多关系中，映射到关系一端的类包含一个集合，该集合填充了关系多端的相关对象。另一方面，映射到关系多端的类有一个简单的属性，该属性填充了与关系一端唯一相关联的对象。
- en: While, in the case of a one-to-one relationship, both classes have a property
    populated with the companion object, in the case of many-to-many relationships,
    both classes contain a collection that is populated with the related objects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在一对一关系的情况下，两个类都有一个填充了伴随对象的属性，而在多对多关系的情况下，两个类都包含一个填充了相关对象的集合。
- en: The whole database (or just a part of it) is represented by an in-memory cache
    class that contains a collection for each mapped DB table. First, the query and
    update operations are performed on an instance of an in-memory cache class, and
    then this instance is synchronized with the database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数据库（或只是其中的一部分）由一个内存缓存类表示，该类包含每个映射的数据库表的集合。首先，在内存缓存类的实例上执行查询和更新操作，然后该实例与数据库同步。
- en: The in-memory cache class that’s used by Entity Framework Core is called `DbContext`
    and it also contains the mapping configuration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core使用的内存缓存类称为`DbContext`，它还包含映射配置。
- en: Developers can customize the `DbContext` class furnished by Entity Framework
    Core by inheriting from it and by adding their database-mapping instructions inside
    overridden methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过从它继承并在重写的方法中添加他们的数据库映射指令来自定义Entity Framework Core提供的`DbContext`类。
- en: Summing up, `DbContext` subclass instances contain partial snapshots of the
    DB that are synchronized with the database to get/update the actual data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`DbContext`子类实例包含与数据库同步的DB的部分快照，以获取/更新实际数据。
- en: DB queries are performed with a query language made of method calls on the collections
    of the in-memory cache class. The actual SQL is created and executed during the
    synchronization stage. For instance, Entity Framework Core performs **Language
    Integrated Query** (**LINQ**) queries on the collections mapped to the DB tables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存缓存类的集合上的方法调用执行数据库查询。实际的SQL是在同步阶段创建和执行的。例如，Entity Framework Core在映射到数据库表的集合上执行**语言集成查询**（**LINQ**）查询。
- en: 'In general, LINQ queries produce `IEnumerable` instances, that is, collections
    whose elements are not computed when the is created at the end of the query, but
    when you actually attempt to retrieve the collection elements from the. This is
    called lazy evaluation or deferred execution. It works as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，LINQ查询生成`IEnumerable`实例，即元素在查询结束时并未计算，而是在实际尝试从其中检索集合元素时才进行计算。这被称为延迟评估或延迟执行。其工作原理如下：
- en: LINQ queries that start from a mapped collection of a `DbContext` create a specific
    subtype of `IEnumerable` called `IQueryable`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`DbContext`的映射集合开始的LINQ查询创建了一个名为`IQueryable`的特定子类型`IEnumerable`。
- en: An `IQueryable` contains all the information that’s needed to issue a query
    to the database, but the actual SQL is produced and executed when the first element
    of the `IQueryable` is retrieved.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IQueryable`包含发出数据库查询所需的所有信息，但实际的SQL是在检索`IQueryable`的第一个元素时生成和执行的。'
- en: Typically, each Entity Framework query ends with a `ToListAsync` or `ToArrayAsync`
    operation that transforms the `IQueryable` into a list or array, thereby causing
    the actual execution of the query on the database.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，每个Entity Framework查询都以`ToListAsync`或`ToArrayAsync`操作结束，该操作将`IQueryable`转换为列表或数组，从而在数据库上实际执行查询。
- en: If the query is expected to return just a single element or no element at all,
    we typically execute a `SingleOrDefaultAsync` operation that returns a single
    element, if any, or `null`. This operation may be used also when several results
    are expected but we need just one. In this case, we might also use `LastOrDefaultAsync`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果预期查询将返回单个元素或没有任何元素，我们通常执行一个`SingleOrDefaultAsync`操作，该操作返回一个元素（如果有），或`null`。当预期有多个结果但只需要一个时，也可以使用此操作。在这种情况下，我们可能还会使用`LastOrDefaultAsync`。
- en: If we need just to count the total results, for instance, for adequately organizing
    paging information, we can use `CountAsync()`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们只需要计算总结果，例如，为了合理组织分页信息，我们可以使用`CountAsync()`。
- en: Also, updates, deletions, and the addition of new entities to a DB table are
    performed by mimicking these operations on a `DbContext` collection property that
    represents the database table. However, entities may only be updated or deleted
    this way after they have been loaded in that memory collection by means of a query.
    Typically, an update query requires the in-memory representation of the entity
    to be modified as needed, while a delete query requires the in-memory representation
    of the entity to be removed from its in-memory mapped collection. In Entity Framework
    Core, the removal operation is performed by calling the `Remove(entity)` method
    of the collection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对DB表中的新实体进行更新、删除以及添加操作是通过模拟在表示数据库表的`DbContext`集合属性上执行这些操作来完成的。然而，实体只能通过在内存集合中通过查询加载后以这种方式进行更新或删除。通常，更新查询需要根据需要修改实体的内存表示，而删除查询则需要从其内存映射集合中删除实体的内存表示。在Entity
    Framework Core中，删除操作是通过调用集合的`Remove(entity)`方法来执行的。
- en: The addition of a new entity has no further requirements. It is enough to add
    the new entity to the in-memory collection. Updates, deletions, and additions
    that are performed on various in-memory collections are actually passed to the
    database with an explicit call to a DB synchronization method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新实体没有其他要求。只需将新实体添加到内存集合中即可。对各种内存集合进行的更新、删除和添加操作实际上是通过显式调用DB同步方法传递到数据库中的。
- en: For instance, Entity Framework Core passes all the changes that are performed
    on a `DbContext` instance to the database when you call the `DbContext.SaveChangesAsync()`
    method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你调用`DbContext.SaveChangesAsync()`方法时，Entity Framework Core会将`DbContext`实例上执行的所有更改传递到数据库中。
- en: Changes that are passed to the database during a synchronization operation are
    executed in a single transaction. Moreover, for ORMs, such as Entity Framework
    Core, that have an explicit representation of transactions, if a synchronization
    operation is executed in the scope of a transaction then it uses that transaction
    instead of creating a new transaction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步操作期间传递到数据库中的更改是在单个事务中执行的。此外，对于具有显式事务表示的ORM，如Entity Framework Core，如果同步操作在事务的作用域内执行，则它将使用该事务而不是创建一个新事务。
- en: The remaining sections in this chapter explain how to use Entity Framework Core,
    along with some example code based on this book’s WWTravelClub use case.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分解释了如何使用Entity Framework Core，以及一些基于本书WWTravelClub用例的示例代码。
- en: Configuring Entity Framework Core
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Entity Framework Core
- en: Since, as detailed in *Chapter 7, Understanding the Different Domains in Software
    Solutions*, database handling is confined within a dedicated application layer,
    it is good practice to define your Entity Framework Core (`DbContext`) in a separate
    library. Accordingly, we need to define a .NET class library project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于，正如在第 7 章，*理解软件解决方案中的不同领域* 中详细说明的，数据库处理被限制在专用应用程序层内，因此将 Entity Framework Core
    (`DbContext`) 定义在单独的库中是一种良好的做法。因此，我们需要定义一个 .NET 类库项目。
- en: 'We have two different kinds of library projects: **.NET Standard** and **.NET
    Core**. Please refer to *Chapter 5, Implementing Code Reusability in C# 12,* for
    a discussion on the various kinds of libraries.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种不同类型的库项目：**.NET Standard** 和 **.NET Core**。请参阅第 5 章，*在 C# 12 中实现代码重用*，以了解各种库的讨论。
- en: While .NET libraries are tied to a specific .NET Core version, .NET Standard
    2.0 libraries have a wide range of applications since they work with any .NET
    version greater than 2.0 and also with the old .NET Framework 4.7 and above.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .NET 库与特定的 .NET Core 版本相关联，.NET Standard 2.0 库具有广泛的应用范围，因为它们可以与任何大于 2.0 的
    .NET 版本以及旧版的 .NET Framework 4.7 及以上版本一起工作。
- en: 'Since our library is not a general-purpose library (it’s just a component of
    a specific .NET 8 application), instead of choosing a .NET Standard library project,
    we can simply choose a .NET 8 library. Our .NET 8 library project can be created
    and prepared as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的库不是通用库（它只是特定 .NET 8 应用程序的一个组件），我们不必选择 .NET Standard 库项目，而可以直接选择 .NET 8
    库。我们的 .NET 8 库项目可以创建和准备如下：
- en: Open Visual Studio, click **Create new project** and then select **Class Library**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio，点击 **创建新项目** 然后选择 **类库**。
- en: Name the new project `WWTravelClubDB` and accept the same name for the whole
    Visual Studio solution.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新项目命名为 `WWTravelClubDB` 并接受整个 Visual Studio 解决方案使用相同的名称。
- en: In the window that follows, choose .NET 8 as the target framework.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的窗口中，选择 .NET 8 作为目标框架。
- en: We must install all Entity Framework Core-related dependencies. The simplest
    way to have all the necessary dependencies installed is to add the NuGet package
    for the provider of the database engine we are going to use – in our case, SQL
    Server – as we mentioned in *Chapter 10*, *Deciding on the Best Cloud-Based Solution*.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须安装所有与 Entity Framework Core 相关的依赖项。安装所有必要依赖项的最简单方法是将我们打算使用的数据库引擎（在我们的例子中是
    SQL Server）的 NuGet 包添加进来——正如我们在第 10 章，*选择最佳云解决方案* 中提到的。
- en: In fact, any provider will install all the required packages since it has all
    of them as dependencies. So, let’s add the latest stable version of `Microsoft.EntityFrameworkCore.SqlServer`.
    If you plan to use several database engines, you can also add other providers
    since they can work side by side. Later in this chapter, we will install other
    NuGet packages that contain tools that we need to process our Entity Framework
    Core configuration.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，任何提供程序都会安装所有必需的包，因为它将它们作为依赖项。所以，让我们添加最新稳定的 `Microsoft.EntityFrameworkCore.SqlServer`
    版本。如果您打算使用多个数据库引擎，您也可以添加其他提供程序，因为它们可以并行工作。在本章的后面部分，我们将安装其他包含我们需要的工具的 NuGet 包来处理我们的
    Entity Framework Core 配置。
- en: 'Let’s rename the default `Class1` class to `MainDbContext`. The `Class1` class
    is automatically added to the class library. Now, let’s replace its content with
    the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将默认的 `Class1` 类重命名为 `MainDbContext`。`Class1` 类会自动添加到类库中。现在，让我们用以下代码替换其内容：
- en: '[PRE0]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We inherit from `DbContext`, and we pass a `DbContextOptions` to the `DbContext`
    constructor. `DbContextOptions` contains creation options, such as the database
    connection string, which depends on the target DB engine.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 `DbContext` 继承，并将 `DbContextOptions` 传递给 `DbContext` 构造函数。`DbContextOptions`
    包含创建选项，例如数据库连接字符串，这取决于目标数据库引擎。
- en: All the collections that have been mapped to database tables will be added as
    properties of `MainDbContext`. The mapping configuration will be defined inside
    of the overridden `OnModelCreating` method with the help of the `ModelBuilder`
    object passed as a parameter.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有已映射到数据库表的集合都将作为 `MainDbContext` 的属性添加。映射配置将在重写的 `OnModelCreating` 方法中定义，该方法通过参数传递的
    `ModelBuilder` 对象进行帮助。
- en: The next step is the creation of all the classes that represent the tables.
    These are called entities. We need an entity class for each DB table we want to
    map. Let’s create a `Models` folder in the project root for all of them. The next
    subsection explains how to define all the required entities.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建代表表的所有类。这些被称为实体。我们需要为每个我们想要映射的数据库表创建一个实体类。让我们在项目根目录中创建一个`Models`文件夹来存放它们。下一小节将解释如何定义所有必需的实体。
- en: Defining DB entities
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据库实体
- en: 'DB design, like the whole application design, is organized in iterations (see
    *Chapter 1, Understanding the Importance of Software Architecture*). Let’s suppose
    that, in the first iteration, we need a prototype with two database tables: one
    for all the travel packages and another one for all the locations referenced by
    the packages. Each package covers just one location, while a single location may
    be covered by several packages, so the two tables are connected by a one-to-many
    relationship.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计，就像整个应用程序设计一样，是按迭代组织的（参见*第一章，理解软件架构的重要性*）。让我们假设在第一次迭代中，我们需要一个包含两个数据库表的原型：一个用于所有旅行套餐，另一个用于所有由套餐引用的位置。每个套餐只覆盖一个位置，而单个位置可能被多个套餐覆盖，因此这两个表通过一对一的关系连接。
- en: 'So, let’s start with the location database table. As we mentioned at the end
    of the previous section, we need an entity class to represent the rows of this
    table. Let’s call the entity class `Destination`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从位置数据库表开始。正如我们在上一节末尾提到的，我们需要一个实体类来表示这个表的行。让我们称这个实体类为`Destination`：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the code above, all the DB fields must be represented by read/write C# properties.
    Since both the `Name` and `Country` properties are obligatory but we are not going
    to define a constructor, we added the `required` keyword to instruct the compiler
    to signal an error whenever an instance is created without initializing them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，所有数据库字段都必须由可读/写的C#属性表示。由于`Name`和`Country`属性都是必需的，但我们没有定义构造函数，所以我们添加了`required`关键字来指示编译器，每当创建一个未初始化它们的实例时，都会发出错误信号。
- en: Suppose that each destination is something like a town or a region that can
    be defined by just its name and the country it is in and that all the relevant
    information is contained in its `Description`. In future iterations, we will probably
    add several more fields. `Id` is an auto-generated key.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个目的地就像一个城镇或地区，可以通过其名称和所在国家来定义，并且所有相关信息都包含在其`Description`中。在未来迭代中，我们可能会添加更多字段。`Id`是一个自动生成的键。
- en: However, now, we need to add information about how all the fields are mapped
    to DB fields. In Entity Framework Core, all the primitive types are mapped automatically
    to DB types by the DB engine-specific provider that’s used (in our case, the SQL
    Server provider).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，我们需要添加有关所有字段如何映射到数据库字段的信息。在Entity Framework Core中，所有原始类型都由特定于数据库引擎的提供程序自动映射到数据库类型（在我们的情况下，是SQL
    Server提供程序）。
- en: 'Our only preoccupations are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一关心的是以下几点：
- en: '**Length limits on the string**: They can be taken into account by applying
    adequate `MaxLength` and `MinLength` attributes to each string property. All the
    attributes that are useful for the entity’s configuration are contained in the
    `System.ComponentModel.DataAnnotations` and `System.ComponentModel.DataAnnotations.Schema`
    namespaces. Therefore, it’s good practice to add both of them to all the entity
    definitions.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串长度限制**：可以通过为每个字符串属性应用适当的`MaxLength`和`MinLength`属性来考虑。所有对实体配置有用的属性都包含在`System.ComponentModel.DataAnnotations`和`System.ComponentModel.DataAnnotations.Schema`命名空间中。因此，将它们都添加到所有实体定义中是一个好的实践。'
- en: '**Specifying which fields are obligatory and which ones are optional**: If
    the project is not using the new **Nullable Reference Type** feature, by default,
    all the reference types (such as all the strings) are assumed to be optional,
    while all the value types (numbers and GUIDs, for instance) are assumed to be
    obligatory. If we want a reference type to be obligatory, then we must decorate
    it with the `Required` attribute. On the other hand, if we want a `T` type property
    to be optional, and `T` is a value type, or the Nullable Reference Type feature
    is on, then we must replace `T` with `T?`. As a default, .NET 8 projects have
    the new Nullable Reference Type feature set.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定哪些字段是必需的，哪些是可选的**：如果项目没有使用新的**可空引用类型**功能，则默认情况下，所有引用类型（例如所有字符串）都被假定为可选的，而所有值类型（例如数字和GUID）都被假定为必需的。如果我们想使引用类型成为必需的，那么我们必须用`Required`属性来装饰它。另一方面，如果我们想使`T`类型属性成为可选的，而`T`是值类型，或者可空引用类型功能已开启，那么我们必须将`T`替换为`T?`。默认情况下，.NET
    8项目已启用新的可空引用类型功能。'
- en: '**Specifying which property represents the primary key**: The key may be specified
    by decorating a property with the `Key` attribute. However, if no `Key` attribute
    is found, a property named `Id` (if there is one) is taken as the primary key.
    In our case, there is no need for the `Key` attribute.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定哪个属性代表主键**：可以通过用`Key`属性装饰一个属性来指定键。然而，如果没有找到`Key`属性，则将名为`Id`的属性（如果有的话）视为主键。在我们的情况下，不需要`Key`属性。'
- en: 'Since each destination is on *one* side of a one-to-many relationship, it must
    contain a collection of the related package entities; otherwise, it will be difficult
    to refer to the related entities in the clauses of our LINQ queries. This collection
    will have a fundamental role in our LINQ queries and will be populated by Entity
    Framework Core. However, as we will see later in this chapter, it must be ignored
    in most of the database update operations. Therefore, the best option to avoid
    compiler warnings is to assign them the null-forgiving fake default value: `null!`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个目标都在一对一关系的**一侧**，它必须包含相关包实体的集合；否则，在LINQ查询的子句中引用相关实体将会很困难。这个集合在我们的LINQ查询中将扮演基本角色，并且将由Entity
    Framework Core填充。然而，正如我们将在本章后面看到的那样，在大多数数据库更新操作中必须忽略它。因此，为了避免编译器警告，最佳选项是将它们分配给null不可忽略的假默认值：`null!`。
- en: 'Putting everything together, the final version of the `Destination` class is
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合起来，`Destination`类的最终版本如下：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since the `Description` property has no length limits, it will be implemented
    with a SQL Server `nvarchar(MAX)` field of indefinite length. We can write the
    code for the `Package` class in a similar way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Description`属性没有长度限制，它将使用不定长度的SQL Server `nvarchar(MAX)`字段实现。我们可以以类似的方式编写`Package`类的代码：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each package has a duration in days, as well as optional start and stop dates
    in which the package offer is valid. `MyDestination` connects packages with their
    destinations in the many-to-one relationship that they have with the `Destination`
    entity, while `DestinationId` is the external key of the same relation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包都有持续的天数，以及可选的开始和结束日期，这些日期是包报价有效的。`MyDestination`通过它们与`Destination`实体之间的一对多关系将包与其目的地连接起来，而`DestinationId`是同一关系的外部键。
- en: While it is not obligatory to specify the external key, it is good practice
    to do so since this is the only way to specify some properties of the relationship.
    For instance, in our case, since `DestinationId` is an `int` (not nullable type),
    it is obligatory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然指定外部键不是必需的，但这是一个好习惯，因为这是指定关系某些属性的唯一方式。例如，在我们的情况下，由于`DestinationId`是`int`（非可空类型），因此它是必需的。
- en: Therefore, the relationship here is one-to-many and not (0, 1)-to-many. Defining
    `DestinationId` as `int?` instead of `int` would turn the one-to-many relationship
    into a (0, 1)-to-many relationship. Moreover, as we will see later in this chapter,
    having an explicit representation of the foreign key simplifies the update operations
    a lot, and some queries.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的关系是一对多，而不是（0，1）到多。将`DestinationId`定义为`int?`而不是`int`将使一对多关系变成（0，1）到多关系。此外，正如我们将在本章后面看到的那样，有一个外键的显式表示大大简化了更新操作和一些查询。
- en: In the next section, we will explain how to define the in-memory collection
    that represents the database tables.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何定义表示数据库表的内存集合。
- en: Defining the mapped collections
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义映射的集合
- en: 'Once we have defined all the entities that are object-oriented representations
    of the database rows, we need to define the in-memory collections that represent
    the database tables themselves. As we mentioned in the *Understanding ORM basics*
    section, all the database operations are mapped to the operations on these collections
    (the *Querying and updating data with Entity Framework Core* section of this chapter
    explains how). It is enough to add a `DbSet<T>` collection property to our `DbContext`
    for each entity, `T`. Usually, the name of each of these properties is obtained
    by pluralizing the entity name. Thus, we need to add the following two properties
    to our `MainDbContext`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了所有表示数据库行的面向对象实体，我们需要定义表示数据库表的内存集合。正如我们在*理解ORM基础*部分中提到的，所有数据库操作都映射到这些集合的操作（本章的*使用Entity
    Framework Core查询和更新数据*部分解释了这一点）。对于每个实体`T`，我们只需要在`DbContext`中添加一个`DbSet<T>`集合属性就足够了。通常，这些属性的名称是通过将实体名称复数化得到的。因此，我们需要向我们的`MainDbContext`添加以下两个属性：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Up until now, we’ve translated database stuff into properties, classes, and
    data annotations. However, Entity Framework needs further information to interact
    with a database. The next subsection explains how to provide it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将数据库内容转换成了属性、类和数据注释。然而，Entity Framework需要进一步的信息来与数据库交互。下一小节将解释如何提供这些信息。
- en: Completing the mapping configuration
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成映射配置
- en: 'The mapping configuration information that we couldn’t specify in the entity
    definitions must be added with configuration code based on a fluent interface.
    The simplest way to add this configuration information is to add it using the
    `OnModelCreating DbContext` method. Each piece of configuration information relative
    to an entity, `T`, starts with `builder.Entity<T>()` and continues with a call
    to a method that specifies that kind of constraint. Further nested calls specify
    further properties of the constraint. For instance, our one-to-many relationship
    may be configured as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实体定义中无法指定的映射配置信息必须通过基于流畅接口的配置代码添加。添加此类配置信息的最简单方法是通过使用`OnModelCreating DbContext`方法。与实体`T`相关的每一项配置信息都从`builder.Entity<T>()`开始，然后通过调用一个指定此类约束的方法继续。进一步嵌套的调用指定约束的进一步属性。例如，我们的多对一关系可以配置如下：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The two sides of the relationship are specified through the navigation properties
    that we added to our entities. `HasForeignKey` specifies the external key. Finally,
    `OnDelete` specifies what to do with packages when a destination is deleted. In
    our case, it performs a cascade delete of all the packages related to that destination.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关系的两侧通过我们添加到实体的导航属性来指定。`ForeignKey`指定外部键。最后，`OnDelete`指定在删除目标时对包的处理。在我们的例子中，它执行与该目标相关的所有包的级联删除。
- en: 'The same configuration can be defined by starting from the other side of the
    relationship, that is, starting with `builder.Entity<Package>()`. Clearly, the
    developer must choose just one of the options:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的配置也可以从关系的另一端开始定义，即从`builder.Entity<Package>()`开始。显然，开发者必须只选择这两种选项之一：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only difference is that the previous statement’s `HasMany-WithOne` methods
    are replaced by the `HasOne-WithMany` methods since we started from the other
    side of the relationship. Here, we can also choose the precision with which each
    decimal property is represented in its mapped database field. As a default, decimals
    are represented by 18 digits and 2 decimals. You can change this setting for each
    property with something like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，由于我们从关系的另一端开始，之前的`HasMany-WithOne`方法被`HasOne-WithMany`方法所取代。在这里，我们也可以选择每个十进制属性在映射的数据库字段中的表示精度。默认情况下，十进制数由18位数字和2位小数表示。您可以使用类似以下内容为每个属性更改此设置：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `ModelBuilder builder` object allows us to specify database indexes with
    something such as the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelBuilder builder`对象允许我们使用如下方式指定数据库索引：'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Multi-property indexes are defined as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 多属性索引的定义如下：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Starting from version 5, indexes can also be defined with attributes applied
    to the class. The following is the case of a single property index:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本5开始，索引也可以通过应用于类的属性来定义。以下是一个单属性索引的例子：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the case of a multi-property index:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个多属性索引的例子：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Configuration options that are specific to an entity can also be grouped into
    separate configuration classes, one for each entity:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 针对实体的特定配置选项也可以分组到单独的配置类中，每个实体一个：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each of these classes must implement the `IEntityTypeConfiguration<>` interface,
    whose unique method is `Configure`. Then, the configuration class can be declared
    with a class-level attribute:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类必须实现`IEntityTypeConfiguration<>`接口，该接口的唯一方法是`Configure`。然后，可以使用类级别属性声明配置类：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The configuration class can also be recalled from within the `OnModelCreating`
    method of the context class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 配置类也可以从上下文类的`OnModelCreating`方法中调用：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It is also possible to add all configuration information defined in the assembly
    with:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过以下方式添加在程序集中定义的所有配置信息：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we add all the necessary configuration information, then our `OnModelCreating`
    method will look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加所有必要的配置信息，那么我们的`OnModelCreating`方法将如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Together with the two configuration classes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与两个配置类一起：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I prefer to define just general configuration and relationships in the context
    class. It is also convenient to use data annotation just for restricting property
    values (maximum and minimum length, required fields, and so on). This way, entities
    don’t depend on the specific ORM used and can be exported outside of the data
    layer, if needed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢在上下文类中定义仅通用的配置和关系。使用数据注释仅用于限制属性值（最大和最小长度、必填字段等）也很方便。这样，实体不依赖于特定ORM的使用，如果需要，可以将其导出在数据层之外。
- en: The best place for other entity-specific configurations is the configuration
    class. I also avoid using the `EntityTypeConfiguration` attribute and call entity
    configuration classes from within the context class since this attribute ties
    the entity to a specific ORM.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其他实体特定配置的最佳位置是配置类。我也避免使用`EntityTypeConfiguration`属性，并在上下文类内部调用实体配置类，因为这个属性将实体绑定到特定的ORM。
- en: 'The previous example shows a one-to-many relationship, but Entity Framework
    Core 8 also supports many-to-many relationship:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了单向多对多的关系，但Entity Framework Core 8也支持多对多关系：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding case, the join entity and the database join table are created
    automatically, but you can also specify an existing entity as the join entity.
    In the previous example, the join entity might be the course that the teacher
    teaches in each classroom:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，连接实体和数据库连接表是自动创建的，但你也可以指定一个现有的实体作为连接实体。在先前的例子中，连接实体可能是教师在每个教室教授的课程：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you’ve configured Entity Framework Core, we can use all the configuration
    information we have to create the actual database and put all the tools we need
    in place in order to update the database’s structure as the application evolves.
    The next section explains how.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了Entity Framework Core，我们就可以使用我们拥有的所有配置信息来创建实际的数据库，并将所有需要的工具放置到位，以便随着应用程序的发展更新数据库的结构。下一节将解释如何操作。
- en: Entity Framework Core migrations
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Entity Framework Core迁移
- en: Now that we’ve configured Entity Framework and defined our application-specific
    `DbContext` subclass, we can use the Entity Framework Core design tools to generate
    the physical database and create the database structure snapshot that’s needed
    by Entity Framework Core to interact with the database.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Entity Framework并定义了我们的应用程序特定的`DbContext`子类，我们可以使用Entity Framework
    Core设计工具生成物理数据库并创建实体框架核心与数据库交互所需的数据库结构快照。
- en: 'Entity Framework Core design tools must be installed in each project that needs
    them as NuGet packages. There are two equivalent options:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core设计工具必须作为NuGet包安装在每个需要它们的项目中。有两种等效选项：
- en: '**Tools that work in any operating system console**: These are available through
    the `Microsoft.EntityFrameworkCore.Design` NuGet package. All Entity Framework
    Core commands are in `dotnet ef .....` format since they are contained in the
    `ef` command line’s .NET Core application.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在任何操作系统控制台中工作的工具**：这些工具可以通过`Microsoft.EntityFrameworkCore.Design` NuGet包获取。所有Entity
    Framework Core命令都采用`dotnet ef ......`格式，因为它们包含在`ef`命令行.NET Core应用程序中。'
- en: '**Tools that are specific to the Visual Studio Package Manager Console**: These
    are contained in the `Microsoft.EntityFrameworkCore.Tools` NuGet package. They
    don’t need the `dotnet ef` prefix since they can only be launched from the **Package
    Manager Console** inside Visual Studio.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定于Visual Studio包管理器控制台的工具**：这些工具包含在`Microsoft.EntityFrameworkCore.Tools`
    NuGet包中。它们不需要`dotnet ef`前缀，因为它们只能从Visual Studio中的**包管理器控制台**启动。'
- en: 'Entity Framework Core’s design tools are used within the design/update procedure.
    This procedure is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core的设计工具用于设计/更新过程中。该过程如下：
- en: We modify `DbContext` and the entities’ definitions as needed.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据需要修改`DbContext`和实体定义。
- en: We launch the design tools to ask Entity Framework Core to detect and process
    all the changes we made.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动设计工具，要求 Entity Framework Core 检测和处理我们所做的所有更改。
- en: Once launched, the design tools update the database structure snapshot and generate
    a new *migration*, that is, a file containing all the instructions we need in
    order to modify the physical database to reflect all the changes we made.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦发布，设计工具将更新数据库结构快照并生成一个新的*迁移*，即一个包含所有我们需要修改物理数据库以反映我们所做所有更改的指令的文件。
- en: We launch another tool to update the database with the newly created migration.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动另一个工具来更新数据库，使用新创建的迁移。
- en: We test the newly configured DB layer, and if new changes are necessary, we
    go back to *step 1*.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试新配置的数据库层，如果需要新的更改，我们回到*步骤 1*。
- en: When the data layer is ready, it is deployed in staging or production, where
    all the migrations are applied once more to the actual staging/production database.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据层准备就绪时，它将在预发布或生产环境中部署，此时所有迁移将再次应用到实际的预发布/生产数据库中。
- en: This is repeated several times in the various software project iterations and
    during the lifetime of the application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这在各种软件项目迭代和应用程序的生命周期中重复多次。
- en: If we operate on an already existing database, we need to configure `DbContext`
    and its models to reflect the existing structure of all the tables we want to
    map. This can be done automatically with the `Scaffold-DbContext` command (see
    [https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs](https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs)
    for more details).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个已经存在的数据库上操作，我们需要配置`DbContext`及其模型以反映我们想要映射的所有表的现有结构。这可以通过`Scaffold-DbContext`命令自动完成（有关更多详细信息，请参阅[https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs](https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs)）。
- en: All classes generated by .NET are partial classes, so the user can enrich them
    with further methods without modifying the scaffolded classes by adding the new
    methods to partial classes with the same names.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由 .NET 生成的所有类都是部分类，因此用户可以通过向具有相同名称的部分类添加新方法来丰富它们，而无需修改构建的类。
- en: Then, if we want to start using migration instead of continuing with direct
    database changes, we can call the design tools with the `IgnoreChanges` option
    so that they generate an empty migration. Also, this empty migration must be passed
    to the physical database so that it can synchronize a database structure version
    associated with the physical database with the version that’s been recorded in
    the database snapshot. This version is important because it determines which migrations
    must be applied to a database and which ones have already been applied.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们想开始使用迁移而不是继续直接修改数据库，我们可以使用`IgnoreChanges`选项调用设计工具，以便它们生成一个空迁移。此外，这个空迁移必须传递到物理数据库，以便它可以同步与物理数据库关联的数据库结构版本与数据库快照中记录的版本。这个版本很重要，因为它决定了哪些迁移必须应用到数据库以及哪些已经应用。
- en: However, developers may also choose to continue manually modifying the database
    and repeating the scaffold operation after each change.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发者也可以选择继续手动修改数据库，并在每次更改后重复构建操作。
- en: 'The whole design process needs a test/design database, and if we operate on
    an existing database, the structure of this test/design database must reflect
    the actual database – at least in terms of the tables we want to map. To enable
    design tools so that we can interact with the database, we must define the `DbContextOptions`
    options that they pass to the `DbContext` constructor. These options are important
    at design time since they contain the connection string of the test/design database.
    The design tools can be informed about our `DbContextOptions` options if we create
    a class that implements the `IDesignTimeDbContextFactory<T>` interface, where
    `T` is our `DbContext` subclass:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 整个设计过程需要一个测试/设计数据库，如果我们操作现有的数据库，这个测试/设计数据库的结构必须反映实际数据库——至少在我们想要映射的表方面。为了使设计工具能够与数据库交互，我们必须定义它们传递给`DbContext`构造函数的`DbContextOptions`选项。这些选项在设计时很重要，因为它们包含测试/设计数据库的连接字符串。如果我们创建一个实现`IDesignTimeDbContextFactory<T>`接口的类，其中`T`是我们的`DbContext`子类，设计工具就可以了解我们的`DbContextOptions`选项：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`connectionString` will be used by Entity Framework to create a new database
    in the local SQL Server instance that’s been installed in the development machine
    and connects with Windows credentials. You are free to change it to reflect your
    needs.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectionString`将由Entity Framework用于在开发机器上安装的本地SQL Server实例中创建一个新的数据库，并使用Windows凭据进行连接。您可以根据需要自由更改它。'
- en: 'Now, we are ready to create our first migration! Let’s get started:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建我们的第一个迁移了！让我们开始吧：
- en: Let’s go to the **Package Manager Console** and ensure that **WWTravelClubDB**
    is selected as our default project.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到**包管理器控制台**并确保**WWTravelClubDB**被选为我们的默认项目。
- en: Now, type `Add-Migration initial` and press *Enter* to issue this command. Verify
    that you added the `Microsoft.EntityFrameworkCore.Tools` NuGet package before
    issuing this command; otherwise, you might get an “unrecognized command” error:![Graphical
    user interface, text, application  Description automatically generated](img/B19820_13_01.png)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入`Add-Migration initial`并按*Enter*键执行此命令。在执行此命令之前，请验证您已添加了`Microsoft.EntityFrameworkCore.Tools`
    NuGet包；否则，您可能会收到“未识别的命令”错误：![图形用户界面，文本，应用程序  描述自动生成](img/B19820_13_01.png)
- en: 'Figure 13.1: Adding the first migration'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.1：添加第一个迁移
- en: '`initial` is the name we gave our first migration. So, in general, the command
    is `Add-Migration <migration name>`. When we operate on an existing database,
    we must add the `-IgnoreChanges` option to the first migration (and just to that)
    so that an empty migration is created. References to the whole set of commands
    can be found in the *Further reading* section.'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`initial`是我们给第一个迁移起的名字。所以，一般来说，命令是`Add-Migration <迁移名称>`。当我们操作现有数据库时，我们必须将`-IgnoreChanges`选项添加到第一个迁移（仅针对该迁移）以创建一个空迁移。有关所有命令的引用可以在*进一步阅读*部分找到。'
- en: If, after having created the migration but before having applied the migration
    to the database, we realize we made some errors, we can undo our action with the
    `Remove-Migration` command. If the migration has already been applied to the database,
    the simplest way to correct our error is to make all the necessary changes to
    the code and then apply another migration.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建迁移之后但在将迁移应用到数据库之前，如果我们意识到自己犯了一些错误，我们可以使用`Remove-Migration`命令撤销我们的操作。如果迁移已经被应用到数据库中，纠正我们错误的最简单方法是对代码进行所有必要的修改，然后应用另一个迁移。
- en: 'As soon as the `Add-Migration` command is executed, a new folder appears in
    our project:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行了`Add-Migration`命令，我们的项目中就会出现一个新的文件夹：
- en: '![](img/B19820_13_02.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_13_02.png)'
- en: 'Figure 13.2: Files created by the Add-Migration command'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：Add-Migration命令创建的文件
- en: '`20210924143018_initial.cs` is our migration expressed in an easy-to-understand
    language.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`20210924143018_initial.cs`是我们用易于理解的语言表达的迁移。'
- en: You may review the code to verify that everything is okay. You may also modify
    the migration content (only if you are enough of an expert to do it reliably)
    or simply undo the migration with the `in` `Remove-Migration Remove-Migration`
    command, which is the advised way to proceed when we discover errors.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查代码以验证一切是否正常。您还可以修改迁移内容（只有当您足够专业才能可靠地完成时），或者简单地使用`in` `Remove-Migration
    Remove-Migration`命令撤销迁移，这是我们发现错误时建议的进行方式。
- en: Each migration contains an `Up` method and a `Down` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每个迁移都包含一个`Up`方法和一个`Down`方法。
- en: The `Up` method implies the migration, while the `Down` method undoes its changes.
    Accordingly, the `Down` method contains the reverse actions of all the actions
    included in the `Up` method in reverse order.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Up`方法表示迁移，而`Down`方法则撤销其更改。相应地，`Down`方法包含`Up`方法中包含的所有操作的逆序操作。'
- en: '`20210924143018_initial.Designer.cs` is the Visual Studio designer code, which
    you must not modify, while `MainDbContextModelSnapshot.cs` is the overall database
    structure snapshot. If you add further migrations, new migration files and their
    designer counterparts will appear, and the unique `MainDbContextModelSnapshot.cs`
    database structure snapshot will be updated to reflect the database’s overall
    structure.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`20210924143018_initial.Designer.cs`是Visual Studio设计器代码，您必须不要修改它，而`MainDbContextModelSnapshot.cs`是整体数据库结构快照。如果您添加了进一步的迁移，新的迁移文件及其设计器对应文件将出现，并且唯一的`MainDbContextModelSnapshot.cs`数据库结构快照将被更新以反映数据库的整体结构。'
- en: The same command can be issued in an operating system console by typing `dotnet
    ef migrations add initial`. This command must be issued from within the project’s
    root folder (not from within the solution’s root folder).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的命令可以通过在操作系统控制台中输入 `dotnet ef migrations add initial` 来发出。此命令必须在项目的根目录内（而不是在解决方案的根目录内）发出。
- en: However, if `Microsoft.EntityFrameworkCore.Design` is installed globally with
    `dotnet tool install --global dotnet-ef`, then we can use it in a project after
    adding it to that project by typing `dotnet add package –-project <project path>
    Microsoft.EntityFrameworkCore.Design`. In this case, commands can be issued from
    any folder by specifying the `--project <project path>` option.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用 `dotnet tool install --global dotnet-ef` 全局安装了 `Microsoft.EntityFrameworkCore.Design`，那么我们可以在将其添加到项目后通过输入
    `dotnet add package –-project <project path> Microsoft.EntityFrameworkCore.Design`
    在项目中使用它。在这种情况下，可以通过指定 `--project <project path>` 选项从任何文件夹中发出命令。
- en: Migrations can be applied to the database by typing `Update-Database` in the
    Package Manager Console. The equivalent console command is `dotnet ef database
    update`. Let’s try using this command to create the physical database!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在包管理器控制台中输入 `Update-Database` 来将迁移应用到数据库。等效的控制台命令是 `dotnet ef database update`。让我们尝试使用此命令来创建物理数据库！
- en: The next subsection explains how to create database stuff that Entity Framework
    is unable to create automatically. After that, in the next section, we will use
    Entity Framework’s configuration and the database we generated with `dotnet ef
    database update` to create, query, and update data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节解释了如何创建实体框架无法自动创建的数据库内容。在那之后，在下一节中，我们将使用实体框架的配置和通过 `dotnet ef database
    update` 生成的数据库来创建、查询和更新数据。
- en: Understanding stored procedures and direct SQL commands
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解存储过程和直接 SQL 命令
- en: Some database structures, like, for instance, stored procedures, can’t be generated
    automatically by the Entity Framework Core commands and declarations we described
    previously. Stored procedures such as generic SQL strings can be included manually
    in the `Up` and `Down` methods through the `migrationBuilder.Sql("<sql command>")`
    method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库结构，例如存储过程，无法通过我们之前描述的实体框架核心命令和声明自动生成。例如，可以将通用 SQL 字符串通过 `migrationBuilder.Sql("<sql
    command>")` 方法手动包含在 `Up` 和 `Down` 方法中。
- en: The safest way to do this is by adding a migration without performing any configuration
    changes so that the migration is empty when it’s created. Then, we can add the
    necessary SQL commands to the empty `Up` method of this migration and their converse
    commands in the empty `Down` method. It is good practice to put all the SQL strings
    in the properties of resource files (`.resx` files).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最安全的方法是添加一个迁移，而不进行任何配置更改，这样在创建迁移时它就是空的。然后，我们可以将必要的 SQL 命令添加到这个迁移的空 `Up`
    方法中，以及它们的逆命令在空 `Down` 方法中。将所有 SQL 字符串放在资源文件的属性（`.resx` 文件）中是一种良好的做法。
- en: 'Stored procedures should replace `Entity` `Framework` commands in the following
    circumstances:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，存储过程应该替换 `Entity Framework` 命令：
- en: When we need to perform manual SQL optimizations to increase the performance
    of some operations.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要手动进行 SQL 优化以提高某些操作的性能时。
- en: When `Entity` `Framework` doesn’t support the SQL operation, we need to perform.
    A typical example is the increment or decrement of a numeric field that occurs
    in all booking operations (air travel, hotels, and so on). Actually, we might
    replace the increment/decrement operation with a database read, an in-memory increment/decrement,
    and finally, a database update, all enclosed in the same transaction scope. However,
    this might be overkill for performance.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `Entity Framework` 不支持我们需要的 SQL 操作时。一个典型的例子是在所有预订操作（航空旅行、酒店等）中发生的数值字段的增加或减少。实际上，我们可能用数据库读取、内存中的增加/减少，最后在同一个事务范围内进行数据库更新来替换增加/减少操作。然而，这可能对性能来说过于冗余。
- en: 'Before starting to interact with our database, we can perform a further optional
    step: model optimizations.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始与我们的数据库交互之前，我们可以执行一个进一步的可选步骤：模型优化。
- en: Compiled models
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译后的模型
- en: Starting from version 6, Entity Framework Core introduced the possibility to
    create precompiled data structures that improve Entity Framework Core’s performance
    by about 10 times in the case of models with hundreds of entities (see the reference
    in the *Further reading* section for more details). This step is accomplished
    by generating some code that, once compiled together with the data layer project,
    creates data structures that our context classes can use to improve performance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本6开始，Entity Framework Core引入了创建预编译数据结构的功能，这可以通过将数据层项目编译在一起来提高Entity Framework
    Core的性能，对于具有数百个实体的模型，性能可以提高约10倍（有关更多详细信息，请参阅*进一步阅读*部分的参考）。此步骤是通过生成一些代码来完成的，这些代码一旦编译，就可以创建我们的上下文类可以使用以提高性能的数据结构。
- en: The usage of pre-compilation is advised just after you verify the system experiences
    slow-downs and also on very simple queries. In other words, it is better to start
    without pre-compilation and then possibly add it in case of slow-downs caused
    by the EF infrastructure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在验证系统出现减速后以及非常简单的查询后使用预编译。换句话说，最好是先不使用预编译，然后在由于EF基础设施引起的减速情况下可能添加它。
- en: 'Code is generated with the `Optimize-DbContext` command provided by the `Microsoft.EntityFrameworkCore.Tool`
    NuGet package that we already installed. The command accepts the folder name to
    place the code and the namespace to place all classes. In our case, let’s choose
    the `Optimization` folder and the `WWTravelClubDB.Optimization` namespace:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是通过我们已安装的`Microsoft.EntityFrameworkCore.Tool` NuGet包提供的`Optimize-DbContext`命令生成的。该命令接受放置代码的文件夹名称和放置所有类的命名空间。在我们的情况下，让我们选择`Optimization`文件夹和`WWTravelClubDB.Optimization`命名空间：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `–Context` parameter must be passed the name of our context class.
    The `Optimization`folder is automatically created and filled with classes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，必须将`–Context`参数传递给我们的上下文类名。`Optimization`文件夹会自动创建并填充类。
- en: The optimization code depends on the ORM configuration, so the `Optimize-DbContext`
    command must be repeated each time a new migration is created.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码依赖于ORM配置，因此每次创建新的迁移时，都必须重复执行`Optimize-DbContext`命令。
- en: 'Optimizations are enabled by passing the root of our optimization model as
    an option when an instance of the context class is created. Let’s open the `LibraryDesignTimeDbContextFactory.cs`
    file and add the line below:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在创建上下文类实例时将我们的优化模型根作为选项传递，可以启用优化。让我们打开`LibraryDesignTimeDbContextFactory.cs`文件并添加以下行：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, you are ready to interact with the database through Entity Framework Core.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好通过Entity Framework Core与数据库进行交互。
- en: Querying and updating data with Entity Framework Core
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework Core查询和更新数据
- en: 'To test our DB layer, we need to add a console project based on the same .NET
    Core version as our library to the solution. Let’s get started:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的数据库层，我们需要将一个基于与我们的库相同.NET Core版本的控制台项目添加到解决方案中。让我们开始吧：
- en: Let’s call the new console project `WWTravelClubDBTest`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新的控制台项目命名为`WWTravelClubDBTest`。
- en: Now, we need to add our data layer as a dependency of the console project by
    right-clicking on the **Dependencies** node of the console project and selecting
    **Add Project Reference**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过右键点击控制台项目的**依赖项**节点并选择**添加项目引用**，将我们的数据层作为控制台项目的依赖项添加。
- en: 'Remove the content of the `Program.cs` file and start by writing the following:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Program.cs`文件的内容，并开始编写以下内容：
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, add the following namespaces at the top of the file:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在文件顶部添加以下命名空间：
- en: '[PRE24]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have finished preparing our test project, we can experiment with
    queries and data updates. Let’s start by creating some database objects, that
    is, some destinations and packages. Follow these steps to do so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了测试项目的准备工作，我们可以对查询和数据更新进行实验。让我们首先创建一些数据库对象，即一些目的地和包。按照以下步骤操作：
- en: 'First, we must create an instance of our `DbContext` subclass with an appropriate
    connection string. We can use the same `LibraryDesignTimeDbContextFactory` class
    that’s used by the design tools to get it:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用适当的连接字符串创建我们的`DbContext`子类的一个实例。我们可以使用设计工具使用的相同的`LibraryDesignTimeDbContextFactory`类来获取它：
- en: '[PRE25]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'New rows can be created by simply adding class instances to the mapped collections
    of our `DbContext` subclass. If a `Destination` instance has packages associated
    with it, we can simply add them to its `Packages` property:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过简单地将类实例添加到我们的`DbContext`子类的映射集合中，可以创建新行。如果一个`Destination`实例与包相关联，我们可以简单地将其添加到其`Packages`属性中：
- en: '[PRE26]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is no need to specify primary keys since they are auto-generated and will
    be filled in by the database. In fact, after the `SaveChangesAsync()` operation
    synchronizes our context with the actual DB, the `firstDestination.Id` property
    has a non-zero value. The same is true for the primary keys of `Package`. Key
    auto-generation is the default behavior for all integer types.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要指定主键，因为它们是自动生成的，将由数据库填充。实际上，在 `SaveChangesAsync()` 操作将我们的上下文与实际数据库同步后，`firstDestination.Id`
    属性有一个非零值。对于 `Package` 的主键也是如此。对于所有整数类型，键自动生成是默认行为。
- en: 'When we declare that an entity (in our case, `Package`) is a child of another
    entity (in our case, `Destination`) by inserting it in a parent entity collection
    (in our case, the `Packages` collection), there is no need to explicitly set its
    external key (in our case, `DestinationId`) since it is inferred automatically
    by Entity Framework Core. Once created and synchronized with the `firstDestination`
    database, we can add further packages in two different ways:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过将其插入父实体集合（在我们的例子中，是 `Packages` 集合）来声明一个实体（在我们的例子中，是 `Package`）是另一个实体（在我们的例子中，是
    `Destination`）的子实体时，不需要显式设置其外部键（在我们的例子中，是 `DestinationId`），因为 Entity Framework
    Core 会自动推断它。一旦创建并与 `firstDestination` 数据库同步，我们可以通过两种不同的方式添加更多的包：
- en: Create a `Package` class instance, set its `DestinationId` external key to `firstDestination.Id`,
    and add it to `context.Packages`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Package` 类实例，将其 `DestinationId` 外部键设置为 `firstDestination.Id`，然后将其添加到 `context.Packages`
- en: Create a `Package` class instance, with no need to set its external key, and
    then add it to the `Packages` collection of its parent `Destination` instance
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Package` 类实例，无需设置其外部键，然后将其添加到其父 `Destination` 实例的 `Packages` 集合中
- en: The latter approach should be preferred when the two entities do not belong
    to the same aggregate since, in this case, the whole aggregate must be loaded
    in memory before operating on it to be sure all business rules are correctly applied
    and to prevent incoherences caused by simultaneous operations on different parts
    of the same aggregates (see the *Aggregates* subsection of *Chapter 7, Understanding
    the Different Domains in Software Solutions*).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个实体不属于同一聚合时，应首选后者方法，因为在这种情况下，在操作之前必须将整个聚合加载到内存中，以确保所有业务规则都得到正确应用，并防止由于对同一聚合的不同部分同时操作而引起的矛盾（参见
    *第7章，理解软件解决方案的不同领域* 中的 *聚合* 子节）。
- en: Moreover, the latter option is the only possibility when a child entity (`Package`)
    is added with its parent entity (`Destination`) and the parent entity has an auto-generated
    principal key since, in this case, the external key isn’t available at the time
    we perform the additions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当子实体（`Package`）与其父实体（`Destination`）一起添加，并且父实体有一个自动生成的主键时，后者选项是唯一可能的选择，因为在这种情况下，外部键在我们执行添加操作时是不可用的。
- en: In most of the other circumstances, the former option is simpler since the second
    option requires the parent `Destination` entity to be loaded in memory, along
    with its `Packages` collection, that is, together with all the packages associated
    with the `Destination` object (by default, connected entities aren’t loaded by
    queries).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他情况下，前者选项更简单，因为后者选项需要将父 `Destination` 实体及其 `Packages` 集合（即与 `Destination`
    对象关联的所有包）加载到内存中，也就是说，在操作之前必须确保整个聚合加载到内存中，以确保所有业务规则都得到正确应用，并防止由于对同一聚合的不同部分同时操作而引起的矛盾（参见
    *第7章，理解软件解决方案的不同领域* 中的 *聚合* 子节）。
- en: 'Now, let’s say we want to modify the `Florence` destination and give a 10%
    increment to all `Florence` package prices. How do we proceed? Follow these steps
    to find out how:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要修改 `Florence` 目的地，并将所有 `Florence` 包的价格增加10%。我们该如何操作？按照以下步骤了解如何操作：
- en: 'First, comment out all previous instructions for populating the database while
    keeping the `DbContext` creation instruction:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，注释掉所有用于填充数据库的先前指令，同时保留创建 `DbContext` 的指令：
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, we need to load the entity into memory with a query, modify it, and call
    `await SaveChangesAsync()` to synchronize our changes with the database.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要通过查询将实体加载到内存中，修改它，并调用 `await SaveChangesAsync()` 以将我们的更改与数据库同步。
- en: 'If we want to modify, say, just its description, a query such as the following
    is enough:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只想修改其描述，如下的查询就足够了：
- en: '[PRE28]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We need to load all the related destination packages that are not loaded by
    default. This can be done with the `Include` clause, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要加载所有默认未加载的相关目的地包。这可以通过以下 `Include` 子句完成：
- en: '[PRE29]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, we can modify the description and package prices, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以修改描述和包价格，如下所示：
- en: '[PRE30]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If entities included with the `Include` method themselves contain a nested
    collection we would like to include, we can use `ThenInclude`, as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`Include`方法包含的实体本身包含我们想要包含的嵌套集合，我们可以使用`ThenInclude`，如下所示：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since Entity Framework always tries to translate each LINQ into a single SQL
    query, sometimes the resulting query might be too complex and slow. In such cases,
    starting from version 5, we can give Entity Framework the permission to split
    the LINQ query into several SQL queries, as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Entity Framework始终尝试将每个LINQ转换为单个SQL查询，有时生成的查询可能过于复杂和缓慢。在这种情况下，从版本5开始，我们可以允许Entity
    Framework将LINQ查询拆分为多个SQL查询，如下所示：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Performance issues can be addressed by inspecting the SQL generated by a LINQ
    query with the help of the `ToQueryString` method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查LINQ查询生成的SQL，可以使用`ToQueryString`方法来解决问题：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Starting from version 5, the included nested collection can also be filtered
    with `Where`, as shown here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本5开始，包含的嵌套集合也可以使用`Where`进行过滤，如下所示：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So far, we’ve performed queries whose unique purpose is to update the retrieved
    entities. Next, we will explain how to retrieve information that will be shown
    to the user and/or used by complex business operations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们执行了查询，其唯一目的是更新检索到的实体。接下来，我们将解释如何检索将显示给用户和/或用于复杂业务操作的信息。
- en: Returning data to the presentation layer
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据返回到表示层
- en: To keep the layers separated and to adapt queries to the data that’s actually
    needed by each *use case*, DB entities aren’t sent as they are to the presentation
    layer. Instead, the data is projected into smaller classes that contain the information
    that’s needed by the *use case*. These are implemented by the presentation layer’s
    `caller` method. Objects that move data from one layer to another are called **Data
    Transfer Objects** (**DTOs**).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持层之间的分离并使查询适应每个*用例*实际需要的数据，DB实体不会以原样发送到表示层。相反，数据被投影到包含所需信息的较小类中，这些类由表示层的`caller`方法实现。在层之间移动数据的对象被称为**数据传输对象**（**DTOs**）。
- en: 'As an example, let’s create a DTO containing the summary information that is
    worth showing when returning a list of packages to the user (we suppose that,
    if needed, the user can get more details by clicking the package they are interested
    in):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个DTO，其中包含在向用户返回包列表时值得显示的摘要信息（我们假设如果需要，用户可以通过点击他们感兴趣的包来获取更多详细信息）：
- en: 'Let’s add a DTO to our `WWTravelClubDBTest` project that contains all the information
    that needs to be shown in a list of packages:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`WWTravelClubDBTest`项目中添加一个DTO，其中包含需要在包列表中显示的所有信息：
- en: '[PRE35]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We don’t need to load entities in memory and then copy their data into the DTO,
    but database data can be projected directly into the DTO, thanks to the LINQ `Select`
    clause. This minimizes how much data is exchanged with the database.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要在内存中加载实体然后将它们的数据复制到DTO中，但数据库数据可以直接投影到DTO中，这得益于LINQ的`Select`子句。这最小化了与数据库交换的数据量。
- en: 'As an example, we can populate our DTOs with a query that checks all the packages
    that are available around August 10:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我们可以使用一个查询来填充我们的DTO，该查询检查所有8月10日左右可用的包：
- en: '[PRE36]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `Select` clause, we can also navigate to any related entities to get
    the data we need. For instance, the preceding query navigates to the related `Destination`
    entity to get the `Package` destination name.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Select`子句中，我们还可以导航到任何相关实体以获取所需的数据。例如，前面的查询导航到相关的`Destination`实体以获取`Package`目的地的名称。
- en: The programs stop at each `Console.ReadKey()` method, waiting for you to hit
    any key. This way, you have time to analyze the output that’s produced by all
    the code snippets that we added to the `Main` method.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序在每个`Console.ReadKey()`方法处停止，等待您按任意键。这样，您就有时间分析所有添加到`Main`方法的代码片段所产生的输出。
- en: Now, right-click on the `WWTravelClubDBTest` project in Solution Explorer and
    set it as the start project. Then, run the solution.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在解决方案资源管理器中右键单击`WWTravelClubDBTest`项目，将其设置为启动项目。然后，运行解决方案。
- en: Now, we will learn how to handle operations that can’t be efficaciously mapped
    to the immediate operations in the in-memory collections that represent the database
    tables.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何处理无法有效地映射到表示数据库表的内存集合中直接操作的运算。
- en: Issuing direct SQL commands
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接发出SQL命令
- en: 'Not all database operations can be executed efficiently by querying the database
    with LINQ and updating in-memory entities. For instance, counter increments can
    be performed more efficiently with a single SQL instruction. Moreover, some operations
    can be executed with acceptable performance if we define adequate stored procedures/SQL
    commands. In these cases, we are forced to either issue direct SQL commands to
    the database or call database-stored procedures from our Entity Framework code.
    There are two possibilities: SQL statements that perform database operations but
    do not return entities, and SQL statements that do return entities.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数据库操作都可以通过使用 LINQ 查询数据库并在内存中更新实体来高效执行。例如，计数器增加可以通过单个 SQL 指令更高效地执行。此外，如果我们定义了适当的存储过程/SQL
    命令，一些操作可以以可接受的性能执行。在这些情况下，我们被迫直接向数据库发出 SQL 命令或从我们的 Entity Framework 代码中调用数据库存储过程。有两种可能性：执行数据库操作但不返回实体的
    SQL 语句，以及返回实体的 SQL 语句。
- en: 'SQL commands that don’t return entities can be executed with the `DbContext`
    method as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回实体的 SQL 命令可以使用以下方式通过 `DbContext` 方法执行：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Parameters can be referenced in the string as `{0}, {1}, ..., {n}`. Each `{m}`
    is filled with the object contained at the `m` index of the `parameters` array,
    which is converted from a .NET type into the corresponding SQL type. The method
    returns the number of affected rows.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以在字符串中以 `{0}, {1}, ..., {n}` 的形式引用。每个 `{m}` 都用包含在 `parameters` 数组中 `m` 索引处的对象填充，该对象从
    .NET 类型转换为相应的 SQL 类型。该方法返回受影响的行数。
- en: 'SQL commands that return collections of entities must be issued through the
    `FromSqlRaw` method of the mapped collection associated with those entities:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 返回实体集合的 SQL 命令必须通过与那些实体关联的映射集合的 `FromSqlRaw` 方法发出：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Thus, for instance, a command that returns `Package` instances would look something
    like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，一个返回 `Package` 实例的命令看起来可能如下所示：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'SQL strings and parameters work like this in the `ExecuteSqlRaw` method. The
    following is a simple example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ExecuteSqlRaw` 方法中，SQL 字符串和参数是这样工作的。以下是一个简单的示例：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also use string interpolation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字符串插值：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In case the objects to be returned by the SQL query are not mapped objects
    represented by a collection added to the DB context, like `context.Packages`,
    we can use a new method added in .NET 7:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQL 查询要返回的对象不是添加到 DB 上下文中的集合所表示的映射对象，例如 `context.Packages`，我们可以使用 .NET 7
    中添加的新方法：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`SqlQueryRaw` is a method of the `Database` property of the `DbContext` object,
    and it accepts the class of the objects to return as a generic parameter (`TResult`).
    However, in this case, Entity Framework Core is able to transform the SQL tuples
    returned by the database into objects only if the column names in the tuples are
    equal to the property names in `TResult`. Name mismatches in some properties can
    be overcome by decorating these properties with the names of the columns they
    must be mapped from with the `[Column("<column name")]` attribute. This is also
    possible using fluent API configuration: `.HasColumnName(<column name")`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlQueryRaw` 是 `DbContext` 对象的 `Database` 属性的一个方法，它接受要返回的对象的类作为泛型参数 (`TResult`)。然而，在这种情况下，Entity
    Framework Core 能够将数据库返回的 SQL 元组转换为对象，前提是元组中的列名与 `TResult` 中的属性名相同。可以通过使用 `[Column("<column
    name")]` 属性装饰这些属性来克服某些属性中的名称不匹配问题，这些属性必须映射到它们必须从中映射的列的名称。这也可以使用流畅的 API 配置实现：`.HasColumnName(<column
    name")`。'
- en: It is good practice to put all the SQL strings in resource files and encapsulate
    all the `ExecuteSqlRawAsync` and `FromSqlRaw` calls inside the public methods
    that you defined in your `DbContext` subclasses, in order to keep the dependence
    from a specific database inside of your Entity Framework Core-based data layer.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有 SQL 字符串放入资源文件中，并将所有 `ExecuteSqlRawAsync` 和 `FromSqlRaw` 调用封装在您在 `DbContext`
    子类中定义的公共方法内，这是一种良好的实践，以保持对特定数据库的依赖性在您的基于 Entity Framework Core 的数据层内部。
- en: Handling transactions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事务
- en: 'All the changes that are made to a `DbContext` instance are passed in a single
    transaction at the first `SaveChangesAsync` call. However, sometimes, it is necessary
    to include queries and updates in the same transaction. In these cases, we must
    handle the transaction explicitly. Several Entity Framework Core commands can
    be included in a transaction if we put them inside a `using` block associated
    with a transaction object:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对`DbContext`实例所做的所有更改都在第一次`SaveChangesAsync`调用时作为一个单一的事务传递。然而，有时有必要在同一个事务中包含查询和更新。在这些情况下，我们必须显式处理事务。如果我们将几个Entity
    Framework Core命令放在与事务对象关联的`using`块内部，那么这些命令可以包含在一个事务中：
- en: '[PRE43]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, `context` is an instance of our `DbContext` subclass.
    Inside the `using` block, the transaction can be aborted and committed by calling
    its `Rollback` and `Commit` methods. Any `SaveChanges` calls that are included
    in the transaction block use the transaction they are already in, instead of creating
    new ones.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`context`是我们`DbContext`子类的实例。在`using`块内部，可以通过调用其`Rollback`和`Commit`方法来中止和提交事务。任何包含在事务块中的`SaveChanges`调用都将使用它们已经所在的同一个事务，而不是创建新的事务。
- en: Deploying your data layer
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署数据层
- en: When your database layer is deployed in production or in staging, usually, an
    empty database already exists, so you must apply all the migrations in order to
    create all the database objects. This can be done by calling `context.Database.Migrate()`.
    The `Migrate` method applies the migrations that haven’t been applied to the databases
    yet, so it may be called safely several times during the application’s lifetime.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库层在生产或预发布环境中部署时，通常已经存在一个空数据库，因此你必须应用所有迁移以创建所有数据库对象。这可以通过调用`context.Database.Migrate()`来完成。`Migrate`方法应用尚未应用到数据库中的迁移，因此它可以在应用程序的生命周期中安全地多次调用。
- en: '`context` is an instance of our `DbContext` class that must be passed through
    a connection string with enough privileges to create tables and perform all the
    operations included in our migrations. Thus, typically, this connection string
    is different from the string we will use during normal application operations.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`是我们`DbContext`类的实例，必须通过一个具有足够权限创建表和执行我们迁移中包含的所有操作的连接字符串来传递。因此，通常，这个连接字符串与我们在正常应用程序操作中使用的字符串不同。'
- en: During the deployment of a web application on Azure, we are given the opportunity
    to check migrations with a connection string we provide. We can also check migrations
    manually by calling the `context.Database.Migrate()` method when the application
    starts. This will be discussed in detail in *Chapter 18*, *Implementing Frontend
    Microservices with ASP.NET Core*, which is dedicated to frontend applications
    based on ASP.NET Core MVC.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Web应用程序部署到Azure的过程中，我们有权限使用我们提供的连接字符串来检查迁移。我们还可以在应用程序启动时通过调用`context.Database.Migrate()`方法手动检查迁移。这将在第18章“使用ASP.NET
    Core实现前端微服务”中详细讨论，该章节专门介绍基于ASP.NET Core MVC的前端应用程序。
- en: In some production environments, it is not possible to apply migrations during
    the application deployment because the person in charge of the deployment doesn’t
    have enough privileges to create a new database and/or to create and modify tables.
    In this case, we must transform migrations into SQL commands and pass them to
    the database administrator who, after having verified they will not damage the
    existing database and data, applies them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些生产环境中，由于负责部署的人员没有足够的权限创建新的数据库和/或创建和修改表，因此无法在应用程序部署期间应用迁移。在这种情况下，我们必须将迁移转换为SQL命令，并将它们传递给数据库管理员。数据库管理员在确认这些迁移不会损坏现有数据库和数据后，将它们应用。
- en: 'We can transform all migrations in a given interval into SQL with the `Script-Migration`
    command (see [https://learn.microsoft.com/en-us/ef/core/cli/powershell](https://learn.microsoft.com/en-us/ef/core/cli/powershell)):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Script-Migration`命令（见[https://learn.microsoft.com/en-us/ef/core/cli/powershell](https://learn.microsoft.com/en-us/ef/core/cli/powershell)）将给定时间间隔内的所有迁移转换为SQL：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For desktop applications, we can apply migrations during the installation of
    the application and its subsequent updates.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桌面应用程序，我们可以在应用程序安装及其后续更新期间应用迁移。
- en: At the first application installation and/or in subsequent application updates,
    we may need to populate some tables with initial data. For web applications, this
    operation can be performed at application startup, while for desktop applications,
    this operation can be included in the installation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次应用程序安装和/或后续应用程序更新时，我们可能需要用初始数据填充一些表。对于 Web 应用程序，此操作可以在应用程序启动时执行，而对于桌面应用程序，此操作可以包含在安装过程中。
- en: 'Database tables can be populated with Entity Framework Core commands. First,
    though, we need to verify whether the table is empty in order to avoid adding
    the same table rows several times. This can be done with the `Any()` LINQ method,
    as shown in the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表可以使用 Entity Framework Core 命令进行填充。首先，我们需要验证表是否为空，以避免多次添加相同的表行。这可以通过以下代码中的
    `Any()` LINQ 方法完成：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let’s take a look at a few advanced features that Entity Framework Core has
    to share.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Entity Framework Core 有哪些高级功能可以分享。
- en: How data and domain layers communicate with other layers
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据和领域层如何与其他层通信
- en: As discussed in *Chapter 7, Understanding the Different Domains in Software
    Solutions*, classical layer architectures use plain objects and repositories to
    communicate with the other layers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第 7 章“理解软件解决方案中的不同领域”中所述，经典层架构使用普通对象和存储库与其他层进行通信。
- en: Therefore, the entities that define Entity Framework Core configuration themselves
    can be used as they are to communicate with other layers, since they are just
    record-like lists of public properties, as prescribed for plain objects.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义 Entity Framework Core 配置的实体可以直接用于与其他层通信，因为它们只是按照普通对象的要求定义的具有公共属性的记录列表。
- en: The case of domain layers and onion architectures is slightly more complex,
    since, in this case, the domain layer communicates with the application layer
    through rich objects whose methods represent application domain rules. Accordingly,
    in general, the remainder of the application can’t access all domain layer objects’
    properties but is forced to modify them through their own methods, in order to
    enforce domain rules.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层和洋葱架构的情况稍微复杂一些，因为在这种情况下，领域层通过具有表示应用程序领域规则的方法的丰富对象与应用程序层进行通信。因此，通常，应用程序的其余部分无法访问所有领域层对象的属性，而是被迫通过它们自己的方法来修改它们，以强制执行领域规则。
- en: In other words, Entity Framework entities are record-like lists of public properties
    with almost no methods, while DDD entities should have methods that encode domain
    logic, more sophisticated validation logic, and read-only properties. While further
    validation logic and methods can be added without breaking Entity Framework’s
    operations, adding read-only properties that must not be mapped to database properties
    can create problems that must be handled adequately. Preventing properties from
    being mapped to the database is quite easy–all we need to do is decorate them
    with the `NotMapped` attribute or, using the fluent API, as `.Ignore(e => e.PropertyName).`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Entity Framework 实体是具有几乎无方法的记录列表的公共属性，而 DDD 实体应该具有编码领域逻辑、更复杂的验证逻辑和只读属性的方法。虽然可以添加进一步的验证逻辑和方法而不会破坏
    Entity Framework 的操作，但添加必须映射到数据库属性之外的只读属性可能会引起必须适当处理的问题。防止属性映射到数据库相当简单——我们只需要用
    `NotMapped` 属性装饰它们，或者使用流畅的 API，如 `.Ignore(e => e.PropertyName).`
- en: 'The issues that read-only properties have are a little bit more complex and
    can be solved in three fundamental ways:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 只读属性存在的问题稍微复杂一些，可以通过三种基本方法解决：
- en: '**Map Entity Framework entities to different classes**: Define the DDD entities
    as different classes and copy data to/from them when entities are returned/passed
    to repository methods. This is the easiest solution, but it requires that you
    write some code so that you can convert the entities between the two formats.
    DDD entities are defined in the domain layer, while the Entity Framework entities
    continue to be defined in the data layer. This is the cleaner solution, but it
    causes a non-trivial overhead in both code writing and maintenance. I recommend
    it when you have complex aggregates with several complex methods.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 Entity Framework 实体映射到不同的类**：将 DDD 实体定义为不同的类，并在实体返回/传递到存储库方法时，在它们之间复制数据。这是一个最简单的解决方案，但需要编写一些代码以便在两种格式之间转换实体。DDD
    实体在领域层中定义，而 Entity Framework 实体继续在数据层中定义。这是一个更干净的解决方案，但会在代码编写和维护方面造成非微不足道的开销。当您有包含多个复杂方法的复杂聚合时，我建议使用它。'
- en: '**Map table fields to private properties**: Let Entity Framework Core map fields
    to private class fields so that you can decide how to expose them to properties
    by writing custom getters and/or setters. It is sufficient to give either the
    `_<property name>` name or the `_<property name in camel case>` name to these
    private fields, and Entity Framework will use them instead of their associated
    properties. In this case, DDD entities defined in the domain layer are also used
    as data layer entities. The main disadvantage of this approach is that we can’t
    use data annotations to configure each property because DDD entities can’t depend
    on how the underlying data layer is implemented.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将表字段映射到私有属性**：让Entity Framework Core将字段映射到私有类字段，这样你就可以通过编写自定义的getter和/或setter来决定如何将它们暴露给属性。只需给出`_<属性名>`名称或`_<驼峰式属性名>`名称给这些私有字段，Entity
    Framework就会使用它们而不是它们关联的属性。在这种情况下，领域层中定义的DDD实体也被用作数据层实体。这种方法的缺点主要是我们无法使用数据注释来配置每个属性，因为DDD实体不能依赖于底层数据层的实现方式。'
- en: Therefore, we must configure all database mapping in the `OnModelCreating` `DbContext`
    method, or in configuration classes associated with each entity (see *Chapter
    13*, *Interacting with Data in C# – Entity Framework Core*). Both options look
    less readable than data annotations to me, so I don’t like this technique, but
    other professionals use it.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们必须在`OnModelCreating` `DbContext`方法中，或者在关联每个实体的配置类中配置所有数据库映射（参见 *第13章*，*在C#中使用Entity
    Framework Core与数据交互*）。在我看来，这两种选项的可读性都不如数据注释，所以我并不喜欢这种技术，但其他专业人士却在使用它。
- en: '**Hide Entity Framework entities behind interfaces**: Hide each Entity Framework
    entity with all its public properties behind an interface that, when needed, only
    exposes property getters. Entities are defined as `internal` so outer layers can
    access them just through the interfaces they implement. This way, we can force
    the usage of methods that implement business logic rules to modify entity properties.
    Also, `DbContext` is defined as `internal`, so it can be accessed through the
    `IUnitOfWork` interface that it implements from the outer levels. Interfaces can
    be defined in a different library for better decoupling from the outer layers.
    In terms of the onion architecture, the library that defines all interfaces is
    the next layer in from the Entity Framework layer. As usual, interfaces are coupled
    with their implementations in the dependency injection engine. This is the solution
    I prefer when there are several simple entities.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过接口隐藏Entity Framework实体**：将每个具有所有公共属性的Entity Framework实体隐藏在接口后面，该接口在需要时仅公开属性getter。实体被定义为`internal`，这样外部层就可以通过它们实现的接口来访问它们。这样，我们可以强制使用实现业务逻辑规则的方法来修改实体属性。此外，`DbContext`也被定义为`internal`，因此可以通过它实现的`IUnitOfWork`接口从外部层访问。接口可以在不同的库中定义，以更好地与外部层解耦。从洋葱架构的角度来看，定义所有接口的库是Entity
    Framework层外的一层。像往常一样，接口与其实现都在依赖注入引擎中耦合。当存在多个简单实体时，这是我更喜欢的解决方案。'
- en: 'Let’s suppose that we would like to define a DDD interface called `IDestination`
    for the `Destination` entity, and suppose we would like to expose the `Id`, `Name`,
    and `Country` properties as read-only since, once a destination is created, it
    can’t be modified anymore. Here, it is sufficient to let `Destination` implement
    `IDestination` and to define `Id`, `Name`, `Country`, and `Description` as read-only
    in `IDestination`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为`Destination`实体定义一个DDD接口，称为`IDestination`，并且假设我们希望将`Id`、`Name`和`Country`属性公开为只读，因为一旦创建了一个目的地，它就不能再修改了。在这里，让`Destination`实现`IDestination`并在`IDestination`中将`Id`、`Name`、`Country`和`Description`定义为只读就足够了：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Another difference between DDD with onion architectures and a classical data
    layer is that, in classical data layers, all operations and queries on data are
    exposed as repository methods, while in domain layers, repository methods just
    encode creations, deletions, and queries, while modification operations are performed
    by methods of the rich domain layer classes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: DDD与洋葱架构之间的另一个区别是，在经典数据层中，所有对数据的操作和查询都作为仓库方法公开，而在领域层中，仓库方法仅编码创建、删除和查询，而修改操作由丰富的领域层类的方法执行。
- en: A complete example of domain layer implementation is described in *Chapter 18*,
    *Implementing Frontend Microservices with ASP.NET Core*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层实现的完整示例在 *第18章*，*使用ASP.NET Core实现前端微服务* 中描述。
- en: Understanding Entity Framework Core advanced features
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Entity Framework Core高级功能
- en: An interesting Entity Framework advanced feature that is worth mentioning is
    global filters, which were introduced at the end of 2017\. They enable techniques
    such as soft delete and multi-tenant tables that are shared by several users,
    where each user just *sees* its records.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Entity Framework 的高级特性之一是全球过滤器，它们是在 2017 年底引入的。它们使诸如软删除和多租户表等技术成为可能，这些技术被多个用户共享，其中每个用户只是
    *看到* 自己的记录。
- en: 'Global filters are defined with the `modelBuilder` object, which is available
    in the `DbContext` `OnModelCreating` method. The syntax for this method is as
    follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 全局过滤器是通过 `modelBuilder` 对象定义的，该对象在 `DbContext` 的 `OnModelCreating` 方法中可用。此方法的语法如下：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For instance, if we add an `IsDeleted` property to our `Package` class, we
    may soft delete a `Package` without removing it from the database by defining
    the following filter:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们向我们的 `Package` 类添加一个 `IsDeleted` 属性，我们可能可以通过定义以下过滤器来软删除一个 `Package` 而不将其从数据库中删除：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, filters contain `DbContext` properties. Thus, for instance, if we
    add a `CurrentUserID` property to our `DbContext` subclass (whose value is set
    as soon as a `DbContext` instance is created), then we can add a filter like the
    following one to all the entities that refer to a user ID:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，过滤器包含 `DbContext` 属性。因此，例如，如果我们向我们的 `DbContext` 子类（其值在创建 `DbContext` 实例时设置）添加一个
    `CurrentUserID` 属性，那么我们可以向所有引用用户 ID 的实体添加如下过滤器：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With the preceding filter in place, the currently logged-in user can only access
    the documents they own (the ones that have their `UserId`). Similar techniques
    are very useful in the implementation of multi-tenant applications.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的过滤器设置后，当前登录的用户只能访问他们拥有的文档（具有其 `UserId` 的那些文档）。类似的技术在多租户应用程序的实现中非常有用。
- en: Another interesting feature that is worth mentioning is mapping entities to
    un-updatable database queries, which was introduced in version 5.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的有趣特性是将实体映射到不可更新的数据库查询，该特性是在版本 5 中引入的。
- en: 'When you define an entity, you can define explicitly either the name of the
    mapped database table or the name of a mapped updatable view:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个实体时，你可以明确地定义映射的数据库表名称或映射的可更新视图名称：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When an entity is mapped to a view, no table is generated by database migration,
    so the database view must be defined manually by the developer.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个实体映射到视图时，数据库迁移不会生成任何表，因此数据库视图必须由开发者手动定义。
- en: 'If the view we would like to map our entity in is not updatable, LINQ cannot
    use it to pass updates to the database. In this case, we can map the same entity
    simultaneously to a view and a table:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要映射实体的视图不可更新，LINQ 不能使用它来传递更新到数据库。在这种情况下，我们可以同时将相同的实体映射到视图和表中：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Entity Framework will use the view for the queries and the table for the updates.
    This is useful when we create a newer version of a database table but we want
    to also take data from the old version of the table in all queries. In this case,
    we may define a view that takes data from both the old and the new tables but
    passes all updates only on the new table.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 将使用视图进行查询，使用表进行更新。这在我们要创建数据库表的较新版本，但希望所有查询都从旧版本表中获取数据时很有用。在这种情况下，我们可能定义一个视图，该视图从旧表和新表中获取数据，但只将所有更新传递到新表中。
- en: 'The option to set property defaults is also interesting. This can be done by
    specifying an override for the `ConfigureConventions` `DbContext` method. For
    instance, we can set a default precision for all decimal properties:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性默认值的选项也很有趣。这可以通过指定 `ConfigureConventions` `DbContext` 方法的覆盖来实现。例如，我们可以为所有十进制属性设置默认精度：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Specifying a default maximum length for all string properties is also useful:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有字符串属性指定默认最大长度也很有用：
- en: '[PRE53]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Another interesting feature that was gradually introduced in the last versions
    of Entity Framework Core is the mapping of JSON database columns. In particular,
    JSON data contained in a single JSON column can be queried, and the JSON objects
    mapped to .NET types.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 Entity Framework Core 的最新版本中逐渐引入的有趣特性是映射 JSON 数据库列。特别是，可以查询单个 JSON 列中包含的
    JSON 数据，以及将 JSON 对象映射到 .NET 类型。
- en: 'Suppose that an `Author` class that must be mapped to a database table has
    a `Contact` property containing a complex object, and suppose we would like to
    store this object in a database JSON column of the `Author` table. We can do it
    with the help of the `OwnsOne` configuration method, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个必须映射到数据库表的 `Author` 类，它有一个包含复杂对象的 `Contact` 属性，并且假设我们希望将此对象存储在 `Author`
    表的数据库 JSON 列中。我们可以使用 `OwnsOne` 配置方法来完成此操作，如下所示：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After this configuration, the `contact` object can be queried as a standard
    navigation property:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置之后，可以像标准导航属性一样查询 `contact` 对象：
- en: '[PRE55]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can recursively also map sub-objects contained in the `contact` object,
    such as a collection of addresses, but in this case, we must use `OwnsMany`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以递归地映射 `contact` 对象中包含的子对象，例如地址集合，但在此情况下，我们必须使用 `OwnsMany`：
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After that, the nested Addresses JSON collection can also be queried with the
    usual LINQ syntax:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以使用常规 LINQ 语法查询嵌套的 Addresses JSON 集合：
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The above query returns all authors with a nonempty addresses list.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询返回所有具有非空地址列表的作者。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the essentials of ORM basics and why they are
    so useful. Then, we described Entity Framework Core. In particular, we discussed
    how to configure database mappings with class annotations and other declarations
    and commands that are included in `DbContext` subclasses, and in configuration
    classes associated with each entity.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 ORM 基础的要点以及为什么它们如此有用。然后，我们描述了 Entity Framework Core。特别是，我们讨论了如何使用类注解和其他包含在
    `DbContext` 子类以及与每个实体关联的配置类中的声明和命令来配置数据库映射。
- en: Then, we discussed how to create data structures for improving ORM performance
    and how to automatically create and update the physical database with the help
    of migrations, as well as how to query and pass updates to the database through
    Entity Framework Core. Finally, we learned how to pass direct SQL commands and
    transactions through Entity Framework Core, as well as how to deploy a data layer
    based on Entity Framework Core.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了如何创建数据结构以改进 ORM 性能，以及如何通过迁移自动创建和更新物理数据库，以及如何通过 Entity Framework Core
    查询和传递数据库更新。最后，我们学习了如何通过 Entity Framework Core 传递直接 SQL 命令和事务，以及如何基于 Entity Framework
    Core 部署数据层。
- en: This chapter also reviewed some advanced features that were introduced in the
    latest Entity Framework Core releases.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还回顾了在最新的 Entity Framework Core 版本中引入的一些高级功能。
- en: In the next chapter, we move on to microservices orchestrators and will learn
    how to deploy and manage microservices on Kubernetes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨微服务编排器，并学习如何在 Kubernetes 上部署和管理微服务。
- en: Questions
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does Entity Framework Core adapt to several different database engines?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework Core 如何适应几个不同的数据库引擎？
- en: How are primary keys declared in Entity Framework Core?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Entity Framework Core 中如何声明主键？
- en: How is a string field’s length declared in Entity Framework Core?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Entity Framework Core 中如何声明字符串字段的长度？
- en: How are indexes declared in Entity Framework Core?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Entity Framework Core 中如何声明索引？
- en: How are relations declared in Entity Framework Core?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Entity Framework Core 中如何声明关系？
- en: What are the two important migration commands?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个重要的迁移命令是什么？
- en: By default, are related entities loaded by LINQ queries?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，相关实体是否由 LINQ 查询加载？
- en: Is it possible to return database data in a class instance that isn’t a database
    entity? If yes, how?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有可能在不是数据库实体的类实例中返回数据库数据？如果是，如何操作？
- en: How are migrations applied in production and staging?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产环境和预览环境中如何应用迁移？
- en: Further reading
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More details about migration commands can be found at [https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index](https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index)
    and the other links contained there
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于迁移命令的更多详细信息可以在 [https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index](https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index)
    以及其中的其他链接中找到
- en: 'More details about Entity Framework Core compiled models can be found in the
    official Microsoft documentation: [https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models](https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Entity Framework Core 编译模型的更多详细信息可以在官方 Microsoft 文档中找到：[https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models](https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models)
- en: 'More details about Entity Framework Core can be found in the official Microsoft
    documentation: [https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Entity Framework Core 的更多详细信息可以在官方 Microsoft 文档中找到：[https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/)
- en: 'An exhaustive set of examples of complex LINQ queries can be found here: [https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/](https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/
    )'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂 LINQ 查询的详尽示例集可以在这里找到：[https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/](https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/
    )
- en: Learn more on Discord
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
