<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Data Parallelism"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Data Parallelism</h1></div></div></div><p>Concurrently performing a task or a set of operations on a collection of data is referred to as data parallelism. For example, if we have a list of files in a folder and we want to rename them all, we can create a <code class="literal">For</code> loop that goes through the collection and, during each iteration, the loop performs a rename command. We can also iterate through a collection datatype such as a <code class="literal">List</code> or <code class="literal">DataView</code> using a <code class="literal">foreach</code> statement. These are specialized <code class="literal">For</code> and <code class="literal">ForEach</code> statements that are part of the <span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>)<a id="id354" class="indexterm"/> in the <code class="literal">System.Threading.Tasks.Parallel</code> namespace.</p><p>The TPL provides the <code class="literal">Parallel</code> library to make it easy to perform concurrent operations on a dataset or data collection using the different overloads of the <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> methods.</p><p>In this chapter, we will learn how to process items of a data source in parallel using the <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> methods. We will also examine the <code class="literal">ParallelLoopState</code> class, which allows us to examine the results of a concurrent loop and perform actions with the results. Finally, we will learn how to cancel a concurrent loop before it has completed. In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Parallel data processing with <code class="literal">Parallel.For</code></li><li class="listitem" style="list-style-type: disc">Parallel data processing of <code class="literal">IEnumerable</code> collections</li><li class="listitem" style="list-style-type: disc">Using the results of concurrent data loops</li><li class="listitem" style="list-style-type: disc">Canceling a parallel loop operation</li></ul></div><div class="section" title="Parallel loop processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Parallel loop processing</h1></div></div></div><p>In this first section, we will <a id="id355" class="indexterm"/>examine the <code class="literal">Parallel.For</code> method and several variations of it. The most basic overload to this method takes a starting index, an ending index, and an <code class="literal">Action</code> delegate. In the <code class="literal">Parallel</code> method, the <code class="literal">Action</code> delegate can be implemented with a named method, anonymous method, or a lambda expression. The following is the basic syntax for each method:</p><div class="informalexample"><pre class="programlisting">        // Named method.
        Parallel.For(0, i, DoWork);

        // Anonymous method
        Parallel.For(0, i, delegate(int j)
        {
            // Do Work.
        });

        // Lambda expression.
        Parallel.For(0, i, j =&gt;
        {
            // Do Work
        });</pre></div><p>In each example, the method or <a id="id356" class="indexterm"/>lambda expression takes a single parameter that is the iteration value. If you need more control over the execution of the concurrent loop, there are overload methods that take a <code class="literal">ParallelLoopState</code> parameter that is internally generated by .NET. We will talk about this later in the chapter, but it allows us to do things such as canceling a parallel loop or performing an action for each iteration of the loop once it is completed.</p><p>Here is a list of all of the overloads of the <code class="literal">Parallel.For</code> method:</p><div class="mediaobject"><img src="graphics/8321EN_07_01.jpg" alt="Parallel loop processing"/><div class="caption"><p>MSDN reference—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.for(v=vs.110).aspx</p></div></div><p>Also, as well as a <code class="literal">ParallelLoopState</code> parameter, some overloads allow the method to return a thread-safe local variable.</p><p>Now, let's take a look at <a id="id357" class="indexterm"/>an example. We will build a simple <span class="strong"><strong>Windows Presentation Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>)<a id="id358" class="indexterm"/> application that takes an array of integer numbers, performs a calculation on them, and then updates the item in the array. This will be done concurrently instead of sequentially.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec69"/>How to do it</h2></div></div></div><p>For this example, we will create a WPF application that allows the user to enter numbers in 10 boxes and click on a button. Once the button is clicked, it will concurrently take each number and multiply it by the numbers 1 through 10 and sum the results. The result of each calculation will be placed back in each box. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open Visual Studio and create a WPF application named <code class="literal">ParallelMath1</code>.</li><li class="listitem">In the <code class="literal">MainWindow.xaml</code> design view, change the page title to <code class="literal">ParallelMath</code>:<div class="informalexample"><pre class="programlisting">Title="ParallelMath" Height="350" Width="525"&gt;</pre></div></li><li class="listitem">Now, create 10 textbox controls and place them in the <code class="literal">MainWindow.xaml</code> file with the names, <code class="literal">tb1</code>, <code class="literal">tb2</code>, <code class="literal">tb3</code>, <code class="literal">tb4</code>, <code class="literal">tb5</code>, <code class="literal">tb6</code>, <code class="literal">tb7</code>, <code class="literal">tb8</code>, <code class="literal">tb9</code>, and <code class="literal">tb10</code> respectively. Also, set their <code class="literal">Text</code> properties to <code class="literal">0</code>.</li><li class="listitem">Now, place a button control on the <code class="literal">MainWindow.xaml</code> file and set the <code class="literal">Content</code> property to <code class="literal">Calculate</code> and the <code class="literal">Name</code> property to <code class="literal">btnCalculate</code>.</li><li class="listitem">Next, create an event handler for the button's click event named <code class="literal">btnCalculate_Click</code>.</li><li class="listitem">Inside the class <a id="id359" class="indexterm"/>definition, place a line of code to create an array of 10 integers:<div class="informalexample"><pre class="programlisting">int[] numbers = new int[10];</pre></div></li><li class="listitem">Now, put the following code inside the <code class="literal">btnCalculate_Click</code> event handler:<div class="informalexample"><pre class="programlisting">            int[] numbers = new int[10];
            numbers[0] = Convert.ToInt32(tb1.Text);
            numbers[1] = Convert.ToInt32(tb2.Text);
            numbers[2] = Convert.ToInt32(tb3.Text);
            numbers[3] = Convert.ToInt32(tb4.Text);
            numbers[4] = Convert.ToInt32(tb5.Text);
            numbers[5] = Convert.ToInt32(tb6.Text);
            numbers[6] = Convert.ToInt32(tb7.Text);
            numbers[7] = Convert.ToInt32(tb8.Text);
            numbers[8] = Convert.ToInt32(tb9.Text);
            numbers[9] = Convert.ToInt32(tb10.Text);

            Parallel.For(0, 9, CalculateNumbers);

            tb1.Text = numbers[0].ToString();
            tb2.Text = numbers[1].ToString();
            tb3.Text = numbers[2].ToString();
            tb4.Text = numbers[3].ToString();
            tb5.Text = numbers[4].ToString();
            tb6.Text = numbers[5].ToString();
            tb7.Text = numbers[6].ToString();
            tb8.Text = numbers[7].ToString();
            tb9.Text = numbers[8].ToString();
         tb10.Text = numbers[9].ToString();</pre></div></li><li class="listitem">Finally, create a method named <code class="literal">CalculateNumbers</code> and put the following code into it:<div class="informalexample"><pre class="programlisting">        private void CalculateNumbers(int i)
        {
            int j = numbers[i];
            for (int k = 1; k &lt;= 10; k++)
            {
                j *= k;
            }

            numbers[i] = j;

        }</pre></div></li></ol></div><p>That should be all. Now, let's run our application and see what happens. Remember we have not put in any error handling. The application expects a number and only a number in each textbox when the <span class="strong"><strong>Calculate</strong></span> button is clicked. If it is not there, the application will throw an argument out of range exception.</p><p>You should see results <a id="id360" class="indexterm"/>similar to this before you click on the button:</p><div class="mediaobject"><img src="graphics/8321EN_07_02.jpg" alt="How to do it"/></div><p>Now, let's enter <a id="id361" class="indexterm"/>10 numbers into our textboxes so that the application looks something like the following:</p><div class="mediaobject"><img src="graphics/8321EN_07_03.jpg" alt="How to do it"/></div><p>Now, click on the <a id="id362" class="indexterm"/>
<span class="strong"><strong>Calculate</strong></span> button and you should see the following results very quickly since we are doing these calculations concurrently:</p><div class="mediaobject"><img src="graphics/8321EN_07_04.jpg" alt="How to do it"/></div></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/>How it works</h2></div></div></div><p>In the preceding<a id="id363" class="indexterm"/> exercise, we entered 10 numbers into 10 textboxes and then clicked on <span class="strong"><strong>Calculate</strong></span>. The program then took each number, multiplied it by the numbers 1 through 10, and summed them together. It then placed the result back in the textbox it came from.</p><p>This was all done concurrently. Each textbox was processed in parallel. This may have been on 10 separate threads or fewer, depending on the hardware we run the program on. Unlike using threads directly by using the <code class="literal">Parallel</code> class and TPL, .NET manages the threadpool and maximizes how many threads to perform the concurrent operation on, using the processing cores available on the machine.</p><p>Let's look at how the concurrent loop is executed. It is the single command <code class="literal">Parallel.For(0, 9, CalculateNumbers);</code>. This command queues 10 tasks to the threadpool and each task will execute the <code class="literal">CalculateNumbers</code> method with an integer parameter.</p><p>Now, let's look at the <code class="literal">Parallel.ForEach</code> command.</p></div></div></div>
<div class="section" title="Data parallelism on collections using Parallel.ForEach"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Data parallelism on collections using Parallel.ForEach</h1></div></div></div><p>The form of data <a id="id364" class="indexterm"/>parallelism that I <a id="id365" class="indexterm"/>find most helpful is performing concurrent operations on collections of data. This allows us to take data collections such as lists, dataviews, dictionaries, and so on and perform a task on each item in the collection in parallel with a single line of code! This makes using data parallelism simpler; you have to do nothing more than normal data processing. This is one of the reasons why the TPL is such a wonderful enhancement to .NET.</p><p>Much like the <code class="literal">Parallel.For</code> method, the structure of <code class="literal">Parallel.ForEach</code> looks like the following:</p><div class="informalexample"><pre class="programlisting">Parallel.ForEach(dataCollection, item =&gt; DoWork(item));</pre></div><p>There are two parameters in the most basic version of this method. There is a data collection and an <code class="literal">Action</code> delegate to perform a task on an item of the <code class="literal">dataCollection</code>. The <code class="literal">Action</code> delegate takes a single parameter that is an item in the collection. </p><p>The following are all of the different overloads of the <code class="literal">ForEach</code> method:</p><div class="mediaobject"><img src="graphics/8321EN_07_05.jpg" alt="Data parallelism on collections using Parallel.ForEach"/></div><div class="mediaobject"><img src="graphics/8321EN_07_06.jpg" alt="Data parallelism on collections using Parallel.ForEach"/><div class="caption"><p>Reference—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.foreach(v=vs.110).aspx</p></div></div><p>As you can see, there are<a id="id366" class="indexterm"/> many different <a id="id367" class="indexterm"/>overloads to this method. They allow us to use a <code class="literal">ParallelLoopState</code> object or a thread-safe local variable.</p><p>We will focus on the simple form of just performing concurrent processing on a data collection. To further reiterate this point, let's revisit a project we worked on earlier in the book. In <a class="link" href="ch04.html" title="Chapter 4. Advanced Thread Processing">Chapter 4</a>, <span class="emphasis"><em>Advanced Thread Processing</em></span>, we wrote an application that took a JPG image, divided it into separate bitmaps, and then performed parallel functions on each bitmap to find old stars. It then reassembled the individual bitmaps back into a single image.</p><p>We will rewrite this application using data parallelism and the TPL instead of threads directly. This will demonstrate how TPL can simplify multithreaded code development </p><p>No longer do we have to manage threads (start them, wait on them to complete, or track them). We no longer have to manage the number of processing cores our machine has to maximize performance without starting too many individual threads. All we have to do is separate our large image into a collection of smaller bitmaps and use a <code class="literal">Parallel.ForEach</code> concurrent loop to process each bitmap. That's it. Let's get started.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec71"/>How to do it</h2></div></div></div><p>We will take our<a id="id368" class="indexterm"/> original <code class="literal">OldStarsFinder</code> Windows Form application and change it. To do this let's perform the following<a id="id369" class="indexterm"/> steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's open our <code class="literal">OldStarsFinder</code> application in Visual Studio.</li><li class="listitem">Let's add a new <code class="literal">using</code> statement so we can access the <code class="literal">Parallel</code> library:<div class="informalexample"><pre class="programlisting">using System.Threading.Tasks;</pre></div></li><li class="listitem">At the beginning of the class definition, remove all of the old variable declarations and replace them with just these:<div class="informalexample"><pre class="programlisting">private int Count = 0;
// Number of bitmaps to break the original into and add to 
// the list of bitmaps.
private List&lt;Bitmap&gt; BitmapList;
        //List of bitmaps to use the ParallelForEach on.
        Bitmap OriginalBitmap;
private String prsOldStarsCount = "0";
//Old stars count using a lock to protect thread safety.</pre></div></li><li class="listitem">Replace the <code class="literal">CropBitmap</code> method with this method definition:<div class="informalexample"><pre class="programlisting">        private Bitmap CropBitmap(Bitmap proBitmap, Rectangle proRectangle)
        {
          // Create a new bitmap copying the portion of the 
          // original defined by proRectangle
            // and keeping its PixelFormat
            Bitmap loCroppedBitmap = proBitmap.Clone(proRectangle, proBitmap.PixelFormat);

            return loCroppedBitmap;
     }</pre></div></li><li class="listitem">You can leave the <code class="literal">IsOldStar</code> method as is.</li><li class="listitem">Change the <code class="literal">ThreadOldStarsFinder</code> method to look like this:<div class="informalexample"><pre class="programlisting">        private void ThreadOldStarsFinder(Bitmap loBitmap)
        {
            int liRow;                  // The pixel matrix (bitmap) row number (Y)
            int liCol;                  // The pixel matrix (bitmap) col number (X)
            Color loPixelColor;         // The pixel color

            // Iterate through each pixel matrix (bitmap) rows
            for (liRow = 0; liRow &lt; loBitmap.Height; liRow++)
            {
                // Iterate through each pixel matrix (bitmap) cols
                for (liCol = 0; liCol &lt; loBitmap.Width; liCol++)
                {
                    // Get the pixel Color for liCol and liRow
                    loPixelColor = loBitmap.GetPixel(liCol, liRow);
                    if (IsOldStar(loPixelColor))
                    {
                        // The color range corresponds to an old star
                        // Change its color to a pure blue
                        loBitmap.SetPixel(liCol, liRow, Color.Blue);

                        lock (prsOldStarsCount)
                        {
                            int i = Convert.ToInt32(prsOldStarsCount);
                            i = i + 1;
                            prsOldStarsCount = i.ToString();
                        }

                    }
                }
            }
  }</pre></div></li><li class="listitem">Then <a id="id370" class="indexterm"/>change<a id="id371" class="indexterm"/> the <code class="literal">ShowBitmapWithOldStars</code> method to look like this:<div class="informalexample"><pre class="programlisting">private void ShowBitmapWithOldStars()
        {
            int liThreadNumber;
            // Each bitmap portion
            Bitmap loBitmap;
            // The starting row in each iteration
            int liStartRow = 0;

            // Calculate each bitmap's height
            int liEachBitmapHeight = ((int)(OriginalBitmap.Height / Count)) + 1;

            // Create a new bitmap with the whole width and height
            loBitmap = new Bitmap(OriginalBitmap.Width, OriginalBitmap.Height);
            Graphics g = Graphics.FromImage((Image)loBitmap);
            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;

            for (liThreadNumber = 0; liThreadNumber &lt; Count; liThreadNumber++)
            {
                // Draw each portion in its corresponding absolute starting row
                g.DrawImage(BitmapList[liThreadNumber], 0, liStartRow);
                // Increase the starting row
                liStartRow += liEachBitmapHeight;
            }
            // Show the bitmap in the PictureBox picStarsBitmap
            picStarsBitmap.Image = loBitmap;
            //picStarsBitmap.Image.Save("c:\\packt\\resulting_image.png", ImageFormat.Png);

            tbCount.Text = prsOldStarsCount;

            g.Dispose();
    }</pre></div></li><li class="listitem">Now, change<a id="id372" class="indexterm"/> the <code class="literal">butFindOldStars_Click</code> event handler to have the following<a id="id373" class="indexterm"/> code:<div class="informalexample"><pre class="programlisting">private void butFindOldStars_Click(object sender, EventArgs e)
        {
            Count = Convert.ToInt32(tbTasks.Text);
            OriginalBitmap = new Bitmap(picStarsBitmap.Image);
            BitmapList = new List&lt;Bitmap&gt;(Count);

            int StartRow = 0;
            int EachBitmapHeight = ((int)(OriginalBitmap.Height / Count)) + 1;

            int HeightToAdd = OriginalBitmap.Height;
            Bitmap loBitmap;

            // Breakup the bitmap into a list of bitmaps.
            for (int i = 0; i &lt; Count; i++)
            {

                if (EachBitmapHeight &gt; HeightToAdd)
                {
                    // The last bitmap height perhaps is less than the other bitmaps height
                    EachBitmapHeight = HeightToAdd;
                }

                loBitmap = CropBitmap(OriginalBitmap, new Rectangle(0, StartRow, OriginalBitmap.Width, EachBitmapHeight));
                HeightToAdd -= EachBitmapHeight;
                StartRow += EachBitmapHeight;
                BitmapList.Add(loBitmap);               
            }

            //Iterate through the list of bitmaps with the Parallel.ForEach command.
            Parallel.ForEach(BitmapList, item =&gt; ThreadOldStarsFinder(item));

            ShowBitmapWithOldStars();
    }</pre></div></li><li class="listitem">Then add a <a id="id374" class="indexterm"/>label control with the text, <code class="literal">Number of bitmaps to divide into for processing:</code>.</li><li class="listitem">Also, add a <a id="id375" class="indexterm"/>textbox control and set its <code class="literal">Name</code> property to <code class="literal">tbTasks</code>. This will be used to allow you to designate the number of sections you want the bitmap divided into.</li><li class="listitem">Finally, we remove the <code class="literal">butFindOldStarsBatch</code> button because we do not need it in this application.</li></ol></div><p>That should be all you need to do to run this application using data parallelism with the Task Parallel Library.</p><p>Let's compile and run our application. You should get something like this:</p><div class="mediaobject"><img src="graphics/8321EN_07_07.jpg" alt="How to do it"/></div><p>Now, enter the <a id="id376" class="indexterm"/>number of bitmaps to <a id="id377" class="indexterm"/>divide the image into and click on the <span class="strong"><strong>Old Star Finder</strong></span> button. The application will now look like this:</p><div class="mediaobject"><img src="graphics/8321EN_07_08.jpg" alt="How to do it"/></div><p>What just happened? We<a id="id378" class="indexterm"/> entered <code class="literal">8</code> for the<a id="id379" class="indexterm"/> number of bitmaps to divide into. The application splits the JPG image into 8 equal-sized bitmaps and then into a list collection of bitmaps. Then it concurrently processes each bitmap looking for old stars. Finally, it reassembles the bitmaps into one image and redisplays it.</p><p>Let's take a closer look at what just happened.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec72"/>How it works</h2></div></div></div><p>If you compare the two<a id="id380" class="indexterm"/> versions of the<a id="id381" class="indexterm"/> program, you will see that the second version is much simpler with less code. If we examine the <code class="literal">butOldStarsFinder_Click</code> event handler method, we will see most of the work. First, we divide our image up into a <code class="literal">List</code> collection of smaller bitmaps based on the number we entered. Here is the code that does this:</p><div class="informalexample"><pre class="programlisting">            // Breakup the bitmap into a list of bitmaps.
            for (int i = 0; i &lt; Count; i++)
            {
                if (EachBitmapHeight &gt; HeightToAdd)
                {
                    // The last bitmap height perhaps is less than 
                    // the other bitmaps height
                    EachBitmapHeight = HeightToAdd;
                }

                loBitmap = CropBitmap(OriginalBitmap, new Rectangle(0, StartRow, OriginalBitmap.Width, EachBitmapHeight));
                HeightToAdd -= EachBitmapHeight;
                StartRow += EachBitmapHeight;
                BitmapList.Add(loBitmap);               
            }</pre></div><p>Next, we take our list collection, <code class="literal">BitmapList</code>, and use it in a parallel <code class="literal">ForEach</code> command in this line of code:</p><div class="informalexample"><pre class="programlisting">Parallel.ForEach(BitmapList, item =&gt; ThreadOldStarsFinder(item));</pre></div><p>Finally, when this loop has completed, we display the image with the old stars with this method:</p><div class="informalexample"><pre class="programlisting">ShowBitmapWithOldStars();</pre></div><p>That is it. We no longer have to find out how many cores the processor has and create that many threads. No matter how many items there are in our collection, .NET maximizes the threads in the threadpool to achieve optimal performance. It will create threads if needed or reuse existing threads if possible. This saves on the overhead of starting more threads than can be effectively used by the number of cores in the machine.</p><p>You can now see why writing multithreaded code using TPL is called lightweight concurrency. This version of the Old Stars Finder is definitely "lighter" on the code and logic than the previous<a id="id382" class="indexterm"/> version written directly <a id="id383" class="indexterm"/>with threads or heavyweight concurrency.</p></div></div>
<div class="section" title="Canceling a parallel loop"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Canceling a parallel loop</h1></div></div></div><p>Now that we have learned <a id="id384" class="indexterm"/>how to execute a parallel loop using a <code class="literal">Parallel</code> class library, let's take a look at how we can stop or break a loop if needed. With a normal <code class="literal">For</code> or <code class="literal">ForEach</code> loop we can use a <code class="literal">Continue</code> command to break from a loop.</p><p>If we break from a parallel loop, then we complete all iterations on the threads that are currently executing and then stop. If we <code class="literal">Stop</code> a parallel loop, then we stop all currently running iterations of the loop as soon as possible, but we do not run them to completion. In either case, we will not schedule tasks on the threadpool for the rest of the iterations of the parallel loop that we are yet to get started with.</p><p>To perform a break or a stop of a parallel loop, we need to use the <code class="literal">ParallelLoopState</code> object. This means that we have to use one of the overloads or the <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> method that takes a <code class="literal">ParallelLoopState</code> parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>What is the <code class="literal">ParallelLoopState</code> class? This class cannot be instantiated in your user code. It is provided by the TPL and .NET and hence is a special class. This object provides your parallel loop with a mechanism to interact with other iterations in the loop.</p></div></div><p>The <code class="literal">break</code> and <code class="literal">stop</code> methods are the methods you will use most often, as well as the <code class="literal">IsStopped</code> and <code class="literal">IsExceptional</code> properties. These properties allow you to check whether any iteration of the loop has called <code class="literal">Stop</code> or thrown an exception.</p><p>Now, we will take our <code class="literal">ParallelMath1</code> example and change it to stop the loop after seven iterations. This is arbitrary, for example purposes. But in a real example, there are many conditions where you will want to break or stop from a parallel loop.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec73"/>How to do it</h2></div></div></div><p>We just need to make a few adjustments to our previous program. Let's start by opening the <code class="literal">ParallelMath1</code> WPF application in Visual Studio and making the following changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new method called <code class="literal">CalculateNumbers2</code> and place the following code into it:<div class="informalexample"><pre class="programlisting">        private void CalculateNumbers2(int i, ParallelLoopState pls)
        {
            int j = numbers[i];

            if (i &lt; 7)
            {
                for (int k = 1; k &lt;= 10; k++)
                {
                    j *= k;
                }

                numbers[i] = j;
            }
                        
            else
            {
                pls.Stop();
                return;
            }
     }</pre></div></li><li class="listitem">Then change our <code class="literal">Parallel.For</code> command to call this new method:<div class="informalexample"><pre class="programlisting">Parallel.For(0, 9, CalculateNumbers2);</pre></div></li></ol></div><p>That's it. Now, let's run our <a id="id385" class="indexterm"/>application and put numbers in each of the boxes so that it looks like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_07_09.jpg" alt="How to do it"/></div><p>Now, click on the <span class="strong"><strong>Calculate</strong></span> <a id="id386" class="indexterm"/>button and your results should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_07_10.jpg" alt="How to do it"/></div><p>What do you see? Yes, after<a id="id387" class="indexterm"/> seven iterations of the parallel loop, the loop is stopped and the last three iterations are not finished. Let's examine why.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec74"/>How it works</h2></div></div></div><p>By adding the <code class="literal">ParallelLoopState</code> parameter to the method called by the parallel <code class="literal">For</code> method, we actually change the overload of the method that is called. We are now calling this overload:</p><div class="mediaobject"><img src="graphics/8321EN_07_11.jpg" alt="How it works"/></div><p>You will notice that we do not create this <code class="literal">ParallelLoopState</code> variable and pass it into the <code class="literal">CalculateNumbers2</code> method. It is done by .NET and we can just use it. Pretty handy!</p><p>Now, in our <code class="literal">Action</code> delegate, <code class="literal">CalculateNumbers2</code>, we call the <code class="literal">Stop</code> method of this object using the following command:</p><div class="informalexample"><pre class="programlisting">pls.Stop();</pre></div><p>Once this method is called, the rest of the iterations of the loop are not performed and the loop completes with the iterations it has already completed.</p><p>This is not a very practical example—why execute the loop for 10 iterations and just stop after seven? Why not execute the parallel for seven iterations in the first place? This is just an example for demonstration purposes. In your applications, you will find many conditions by which you will want to exit a parallel loop before completing all iterations, just like with a normal <code class="literal">For</code> loop.</p></div></div>
<div class="section" title="Handling exceptions in parallel loops"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Handling exceptions in parallel loops</h1></div></div></div><p>Well, no matter how hard we <a id="id388" class="indexterm"/>try to write error-free code, the real world<a id="id389" class="indexterm"/> intervenes and inevitably there are exceptions that our code will encounter, for example, file not found, argument out or range, and so on. When we are processing a parallel loop command, since all of the iterations are running on potentially different threads, we need a way to gather all of the exceptions that any of the iterations of the loop may produce.</p><p>.NET provides the <code class="literal">AggregateException</code> class for just this purpose. This allows us to collect all of the exceptions into the <code class="literal">AggregateException</code> object and then "catch" it once the loop has completed.</p><p>Think of this like you would a normal error-handling situation. Typically, you put a <code class="literal">try</code> block around a section of the code and then a <code class="literal">catch</code> block after it to process any exceptions that occurred in the <code class="literal">try</code> block of the code. This will behave the same way. We will put a <code class="literal">try</code> block around our parallel loop command and then catch the exceptions that occur in all of the iterations of the loop. Only in this case, our <code class="literal">catch</code> block will catch the <code class="literal">AggregateException</code>, which is just a collection of exceptions.</p><p>Also, in our <code class="literal">Action</code> delegate, we will catch any exceptions that occur and add them to the <code class="literal">AggregateException</code> object.</p><p>That is all there is to it! Let's try this for ourselves by modifying our <code class="literal">ParallelMath1</code> project to generate an exception if any of the iterations produce a sum of over 5 million.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec75"/>How to do it</h2></div></div></div><p>To start, let's<a id="id390" class="indexterm"/> open the <code class="literal">ParallelMath1</code> project in Visual <a id="id391" class="indexterm"/>Studio and make the following changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will be using a <code class="literal">Concurrent</code> queue to collect the exceptions, so add this <code class="literal">using</code> statement:<div class="informalexample"><pre class="programlisting">using System.Collections.Concurrent;</pre></div></li><li class="listitem">Then, we need to declare our <code class="literal">ConcurrentQueue</code> instance where it is visible to the entire class. Add the following line right after the declaration on the number's integer array:<div class="informalexample"><pre class="programlisting">ConcurrentQueue&lt;Exception&gt; exceptions = new ConcurrentQueue&lt;Exception&gt;();</pre></div></li><li class="listitem">Next, we will add a new method to be called by the <code class="literal">Action</code> delegate of our parallel loop command. We will call this method <code class="literal">CalculateNumbers3</code>. Add the following code to this method:<div class="informalexample"><pre class="programlisting">        private void CalculateNumbers3(int i, ParallelLoopState pls)
        {
            int j = numbers[i];

            try
            {
                for (int k = 1; k &lt;= 10; k++)
                {
                    j *= k;

                    if (j &gt; 5000000) throw new ArgumentException(String.Format("The value of text box {0} is {1}. ", i, j));
                }
            }
            catch(Exception e)
            {
                exceptions.Enqueue(e);
            }

            numbers[i] = j;

    }</pre></div></li><li class="listitem">Then, let's alter our <code class="literal">btnCalculate_Click</code> event handler. Change the code between the population of the numbers array and the population of the textboxes to include the following lines of code:<div class="informalexample"><pre class="programlisting">            try
            {
                Parallel.For(0, 10, CalculateNumbers3);

                if (exceptions.Count &gt; 0) throw new AggregateException(exceptions);
            }

            catch (AggregateException ae)
            {
                // This is where you can choose which exceptions to handle. 
                foreach (var ex in ae.InnerExceptions)
                {
                    if (ex is ArgumentException)
                    {
                        tbMessages.Text += ex.Message;
                        tbMessages.Text += "\r\n";
                    }
                    else
                        throw ex;
                }
     }</pre></div></li><li class="listitem">Finally, in<a id="id392" class="indexterm"/> the <code class="literal">MainWindow.xaml</code> designer <a id="id393" class="indexterm"/>view, add a textblock control; set its <code class="literal">Name</code> property to <code class="literal">tbMessages</code> and its <code class="literal">Text</code> property to an empty string.</li></ol></div><p>Now our changes are complete. When any of the iterations of the parallel loop reach above 5 million, we will throw an exception. All of the exceptions will be collected into a <code class="literal">ConcurrentQueue</code> and added to the <code class="literal">AggregateException</code> object. Once the parallel loop execution has completed, we will process the <code class="literal">AggregateException</code>, if there are any, and write their exception messages to the <code class="literal">Messages</code> textblock.</p><p>Build and run your<a id="id394" class="indexterm"/> application. Now, enter numbers in each of the boxes. You<a id="id395" class="indexterm"/> should have a screen that looks like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_07_12.jpg" alt="How to do it"/></div><p>Now, click on the <a id="id396" class="indexterm"/>
<span class="strong"><strong>Calculate</strong></span> button and you should see results that <a id="id397" class="indexterm"/>look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_07_13.jpg" alt="How to do it"/></div><p>As you can see from the output, every box that has a total that goes over 5 million has a line printed in our <span class="strong"><strong>Messages</strong></span> textblock. In this example, any number that goes over 5 million throws an exception. Once all of the iterations of the parallel loop have completed, we process these exceptions and print their messages to the <code class="literal">tbMessages</code> textblock.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec76"/>How it works</h2></div></div></div><p>The first thing we <a id="id398" class="indexterm"/>changed was adding an object that is in a concurrent<a id="id399" class="indexterm"/> queue, to hold all of our exceptions. This is done with this command:</p><div class="informalexample"><pre class="programlisting">ConcurrentQueue&lt;Exception&gt; exceptions = new ConcurrentQueue&lt;Exception&gt;();</pre></div><p>Next, in our <code class="literal">Action</code> delegate of the parallel <code class="literal">for</code> command, which in this version executes <code class="literal">CalculateNumbers3</code>, we check for numbers greater than 5 million through an exception using the following command:</p><div class="informalexample"><pre class="programlisting">if (j &gt; 5000000) throw new ArgumentException(String.Format("The value of text box {0} is {1}. ", i, j));</pre></div><p>We then catch this exception within the delegate and add it to our concurrent queue of exception objects using these statements:</p><div class="informalexample"><pre class="programlisting">            catch(Exception e)
            {
                exceptions.Enqueue(e);
            }</pre></div><p>We do this because we do not want to interrupt other iterations of the parallel loop running on different threads. We want the loop to finish processing and then handle the exceptions. Since each iteration of the loop is running concurrently and is designed not to affect other iterations, we should not interrupt all of the iterations because one has an issue.</p><p>Once the loop has completed, we want to check for any exceptions and process them. Here is the code that handles this functionality:</p><div class="informalexample"><pre class="programlisting">           try
            {
                Parallel.For(0, 10, CalculateNumbers3);

                if (exceptions.Count &gt; 0) throw new AggregateException(exceptions);
            }

            catch (AggregateException ae)
            {
                // This is where you can choose which exceptions to handle. 
                foreach (var ex in ae.InnerExceptions)
                {
                    if (ex is ArgumentException)
                    {
                        tbMessages.Text += ex.Message;
                        tbMessages.Text += "\r\n";
                    }
                    else
                        throw ex;
                }
            }</pre></div><p>If we see any<a id="id400" class="indexterm"/> exceptions in our <code class="literal">ConcurrentQueue</code> object, we<a id="id401" class="indexterm"/> throw an <code class="literal">AggregateException</code> and give it the whole queue of exceptions. Then we catch this <code class="literal">AggregateException</code> and process all of the exceptions it contains.</p><p>We could have also performed different actions based on the exception type of each exception. You can play with your code and try this.</p></div></div>
<div class="section" title="Using thread-local variables in parallel loops"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Using thread-local variables in parallel loops</h1></div></div></div><p>Once you are comfortable <a id="id402" class="indexterm"/>using parallel loops, stopping them, and <a id="id403" class="indexterm"/>performing exception handling with them, let's talk about how we can use thread-local variables to better coordinate results. If we want to sum the results of all the iterations of a parallel loop, how would we do that?</p><p>From what we have learned so far, we would create a class variable before the loop and access it by each iteration of the loop using a <code class="literal">lock</code> statement so that it remains thread-safe. This takes overhead and coordination time. To improve performance, we can implement our parallel loop using a thread-local variable.</p><p>The <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> loops both have overloads that implement a thread-local variable. What do we mean by a thread-local variable? This is a variable whose scope lasts the duration of the parallel loop, from just before the first iteration starts to the completion of the last iteration. Each iteration of the loop gets its own copy of the thread-local variable.</p><p>In these overloads of the parallel loop methods, there are three functions that get passed to the loop as well as the iteration parameters. For a <code class="literal">For</code> loop, the iteration parameters are the starting and ending values of the loop index, and for the <code class="literal">ForEach</code> loop, it is the source collection.</p><p>The first function will initialize the thread-local variable. The second function is the <code class="literal">Action</code> delegate that the loop performs. The third function is the <code class="literal">Action</code> delegate that gets executed when all iterations of the loop have completed, and it receives the thread-local variable for each loop iteration. It can then process the results, which usually means combining the results.</p><p>Let's examine one of the <code class="literal">ForEach</code> overloads:</p><div class="informalexample"><pre class="programlisting">ForEach&lt;TSource, TLocal&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TLocal&gt;, Func&lt;TSource, ParallelLoopState, TLocal, TLocal&gt;, Action&lt;TLocal&gt;)</pre></div><p>Let's dissect this for a <a id="id404" class="indexterm"/>minute. We will take each piece of the method<a id="id405" class="indexterm"/> definition and explain its role:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ForEach&lt;TSource, TLocal&gt;</code>: <code class="literal">TSource</code> is the <a id="id406" class="indexterm"/>datatype of the source collection, and <code class="literal">TLocal</code> is the datatype of the thread-local variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">IEnumerable&lt;TSource&gt;</code>: This <a id="id407" class="indexterm"/>is the source collection. Since we are using a <code class="literal">ForEach</code> example, the source collection has to be <code class="literal">IEnumerable</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Func&lt;TLocal&gt;</code>: This is <a id="id408" class="indexterm"/>the first function; it initializes the thread-local variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Func&lt;TSource, ParallelLoopState, TLocal, TLocal&gt;</code>: This is the second function; it is <a id="id409" class="indexterm"/>the <code class="literal">Action</code> delegate that is performed by each iteration of the loop.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Action&lt;TLocal&gt;</code>: This is<a id="id410" class="indexterm"/> the third function; it is the <code class="literal">Action</code> delegate that is performed on the local state of each iteration.</li></ul></div><p>Even though this is a fairly straightforward concept, it leads itself to a method overload that looks very complicated. To make sure we understand, let's go to our <code class="literal">ParallelMath1</code> project and see how it works in the sample application we have been building.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec77"/>How to do it</h2></div></div></div><p>To use a thread-local variable to sum up our textboxes once we have performed our parallel loop on them, let's open our <code class="literal">ParallelMath1</code> project and make a few changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">MainWindow.xaml</code> file in the designer view, let's add a label control and set the <code class="literal">Content</code> property to <code class="literal">Sum:</code>.</li><li class="listitem">Now, let's add a textbox control beside it and set the <code class="literal">Name</code> property to <code class="literal">tbSum</code> and make the <code class="literal">Text</code> property empty.</li><li class="listitem">In the <code class="literal">MainWindow.xaml.cs</code> file, add the following <code class="literal">using</code> statement so that we can use the <code class="literal">Interlocked.Add</code> method:<div class="informalexample"><pre class="programlisting">using System.Threading;</pre></div></li><li class="listitem">Also, add a class variable below our <code class="literal">ConcurrentQueue</code> declaration for a sum variable we will call <code class="literal">total</code>:<div class="informalexample"><pre class="programlisting">long total = 0;</pre></div></li><li class="listitem">Then, comment out our current <code class="literal">Parallel.For</code> command because we are going to use the new overloaded version needed for thread-local variables:<div class="informalexample"><pre class="programlisting">//Parallel.For(0, 10, CalculateNumbers3);</pre></div></li><li class="listitem">It is easier for this version of a <code class="literal">Parallel.For</code> to use a lambda expression instead of the named methods for the <code class="literal">Action</code> delegates. So, use the following <code class="literal">Parallel.For</code> command:<div class="informalexample"><pre class="programlisting">                Parallel.For&lt;long&gt;(0, 10, 
                            () =&gt; 0,
                            (i, loop, subtotal) =&gt; 
                            {
                                int j = numbers[i];
                                for (int k = 1; k &lt;= 10; k++)
                                {
                                    j *= k;
                                }

                                numbers[i] = j;
                                subtotal += j;
                                return subtotal; 
                            },
                            (finalResult) =&gt; Interlocked.Add(ref total, finalResult)
                         );</pre></div></li><li class="listitem">Finally, right <a id="id411" class="indexterm"/>after this statement, add the <a id="id412" class="indexterm"/>following statement so that we can see the total on the user interface:<div class="informalexample"><pre class="programlisting">tbSum.Text = total.ToString();</pre></div></li></ol></div><p>That is all the changes we need to make so that we can use our thread-local variable with the <code class="literal">Parallel.For</code> loop to calculate the sum of our textbox.</p><p>Once these changes have been <a id="id413" class="indexterm"/>made, build and run the <a id="id414" class="indexterm"/>application. Enter numbers in the textboxes and you should have a screen that looks like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_07_14.jpg" alt="How to do it"/></div><p>Now, click on the<a id="id415" class="indexterm"/> <span class="strong"><strong>Calculate</strong></span> button and see what happens. The <a id="id416" class="indexterm"/>results should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_07_15.jpg" alt="How to do it"/></div><p>As you can see<a id="id417" class="indexterm"/> from the example, we now have a sum<a id="id418" class="indexterm"/> of all of the boxes once the parallel loop has processed them. We are able to do this without having to continually lock the class variable in each iteration when it wants to update the loop. We can do the summing once at the end of the parallel loop using the thread-local value from each iteration of the loop.</p><p>Now, let's examine what just happened</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec78"/>How it works</h2></div></div></div><p>Just like in the previous versions of this project, we take the numbers in 10 different textboxes and multiply them by the numbers 1 through 10 and sum them. The result is then put back in the textbox. But this time, we take the new results in the 10 text boxes and sum them, and the final total is displayed in the <code class="literal">tbSum</code> textbox.</p><p>The only real difference in this version is the <code class="literal">Parallel.For</code> command. Let's take a deeper look at it:</p><div class="informalexample"><pre class="programlisting">                Parallel.For&lt;long&gt;(0, 10, 
                            () =&gt; 0,
                            (i, loop, subtotal) =&gt; 
                            {
                                int j = numbers[i];
                                for (int k = 1; k &lt;= 10; k++)
                                {
                                    j *= k;
                                }

                                numbers[i] = j;
                                subtotal += j;
                                return subtotal; 
                            },
                            (finalResult) =&gt; Interlocked.Add(ref total, finalResult)
                            );</pre></div><p>First, we now have<a id="id419" class="indexterm"/> a <code class="literal">TResult</code> parameter that is a<a id="id420" class="indexterm"/> long <code class="literal">Parallel.For&lt;long&gt;</code>. This tells us that the <code class="literal">Action</code> delegate that each iteration of the loop executes will return a value with the datatype <code class="literal">long</code>. This <code class="literal">Action</code> delegate is implemented as a lambda expression this time and is the fourth parameter of our <code class="literal">Parallel.For</code> method:</p><div class="informalexample"><pre class="programlisting">(i, loop, subtotal) =&gt; 
                            {
                                int j = numbers[i];
                                for (int k = 1; k &lt;= 10; k++)
                                {
                                    j *= k;
                                }

                                numbers[i] = j;
                                subtotal += j;
                                return subtotal; 
                            }</pre></div><p>Let's create a back up; the first two parameters are the starting and ending indices of our iteration, 0 and 10. The third parameter is our <code class="literal">Action</code> delegate that initializes the thread-local variable. It is implemented with a lambda expression:</p><div class="informalexample"><pre class="programlisting">() =&gt; 0</pre></div><p>Then, our final parameter to the <code class="literal">Parallel.For</code> method is the <code class="literal">Action</code> delegate that is executed on each iteration's thread-local variable:</p><div class="informalexample"><pre class="programlisting">(finalResult) =&gt; Interlocked.Add(ref total, finalResult)</pre></div><p>We chose to use<a id="id421" class="indexterm"/> lambda expression for the three <code class="literal">Action</code> delegates<a id="id422" class="indexterm"/> in this example instead of named or anonymous methods because it is easier for us to see what is going on and what is being passed to what. However, we can use named methods to achieve the same results.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we covered all aspects of imperative data parallelism. In <a class="link" href="ch10.html" title="Chapter 10. Parallel LINQ – PLINQ">Chapter 10</a>, <span class="emphasis"><em>Parallel LINQ – PLINQ</em></span>, we will cover declarative data parallelism with PLINQ discussion. Data parallelism using TPL in .NET really comes down to performing parallel loops using the <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> methods. These parallel loops allow us to iterate through a set or collection of data and perform the same function on each member of the set concurrently.</p><p>We learned how to perform a parallel loop on a set of data using <code class="literal">Parallel.For</code> and a collection of data using <code class="literal">Parallel.ForEach</code>. We then saw how to stop or break from a loop when a particular condition was reached; for this we used the <code class="literal">ParallelLoopState</code> object that .NET can generate.</p><p>Next, we explored error handling with parallel loops and the <code class="literal">AggregateException</code> object. We learned how to process all of the exceptions that might occur during the different iterations of the loop without affecting the other iterations.</p><p>In the last section, we saw how to use thread-local variables in our loops to have a thread-safe local copy of a variable and then use the results from all of these local copies at the end of the loop processing.</p><p>In the next chapter, we will take some time and explore the Visual Studio Debugger and the features it provides for debugging a parallel application that has multiple threads running at once.</p></div></body></html>