- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Dependency Injection in Minimal APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小API中的依赖注入
- en: In any software project, developers rarely craft the application entirely from
    scratch. At some level, generic libraries and toolsets will be absorbed into the
    application to accelerate and optimize the project. **ASP.NET** as a framework
    is no different. In fact, it requires that developers take on dependencies; third-party
    or independently created code that plays a key role in the smooth running of the
    system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何软件项目中，开发者很少从头开始构建应用程序。在某个层面上，通用库和工具集将被吸收到应用程序中，以加速和优化项目。**ASP.NET**作为一个框架也不例外。事实上，它要求开发者承担依赖项；第三方或独立创建的代码，这些代码在系统的平稳运行中起着关键作用。
- en: The result is a (hopefully) finely tuned and well-designed architecture, formed
    of modules and components, some of which run code that was written by developers
    on the project, and the rest being more generic, boilerplate code that was written
    and pre-compiled before the project started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个（希望是）精心调整和设计良好的架构，由模块和组件组成，其中一些运行由项目中的开发者编写的代码，其余的是更通用的、模板化的代码，这些代码在项目开始前编写并预编译。
- en: Keeping track of dependencies is one of the classic problems facing software
    developers, and the problems that arise from this can progress to a point that
    results in what the industry refers to as **dependency hell** – a nightmarish
    scenario in which developers are retracing their steps, trying to figure out where
    a dependency was introduced, and finding ways that they can overcome the challenge
    of conflicting dependencies across a potentially massive code base.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪依赖项是软件开发者面临的一个经典问题，由此产生的问题可能会发展到导致行业所说的**依赖地狱**——一个噩梦般的场景，其中开发者正在追溯他们的步骤，试图找出依赖项是如何被引入的，并找到克服跨可能庞大的代码库中冲突依赖项挑战的方法。
- en: '**Dependency injection** ( **DI** ) is a way of standardizing and simplifying
    the experience of consuming dependencies in software projects.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种在软件项目中标准化和简化消费依赖项体验的方法。'
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding DI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解DI
- en: Configuring DI in minimal APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最小API中配置DI
- en: DI best practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI最佳实践
- en: By the end of the chapter, you will have improved your understanding of DI principles,
    as well as the benefits they can bring to minimal APIs and ASP.NET projects in
    general.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将提高对DI原则的理解，以及它们可以为最小API和ASP.NET项目等一般项目带来的好处。
- en: You will also have gained practical experience in the configuration of DI containers
    and registration of services.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将获得配置DI容器和服务注册的实际经验。
- en: Let us start by improving our understanding of DI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从提高我们对DI的理解开始。
- en: Understanding DI
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解DI
- en: DI started out as a design pattern in software development, aimed at centralizing
    common dependencies and making them available to consumers in a consistent manner.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DI最初是软件开发中的一个设计模式，旨在集中管理常用依赖项，并以一致的方式提供给消费者。
- en: Using this approach, common development tasks such as testing, swapping out
    dependencies, modification of dependency logic, centralization of dependencies,
    and so on, can be easily achieved through one straightforward system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，常见的开发任务，如测试、替换依赖项、修改依赖项逻辑、集中依赖项等，都可以通过一个简单系统轻松实现。
- en: Over time, .NET made DI more of a feature rather than just a design pattern.
    In ASP.NET, there is a robust DI toolset that is simple to use and understand.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，.NET将DI从仅仅是一个设计模式转变为一个功能。在ASP.NET中，有一个强大且易于使用和理解的DI工具集。
- en: Developers can register their dependencies in a centralized location, making
    them available to *inject* into the constructors of classes as arguments when
    they are instantiated.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在一个集中位置注册他们的依赖项，使它们在实例化时可以作为参数注入到类的构造函数中。
- en: With DI, dependencies live within a *container* , making them centrally available
    to consuming classes. But what is a container?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DI，依赖项存在于一个*容器*中，使得它们对消费类中央可用。但什么是容器呢？
- en: The DI container
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DI容器
- en: On the startup of your application, dependencies are registered in the container.
    The **container** is simply a group of dependencies that have been registered
    for DI. Each of the dependencies has a lifetime specification that defines how
    they are instantiated when injected into a consuming class. We’ll explore dependency
    lifetimes in more detail later in the chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动时，依赖项会在容器中注册。**容器**只是已经注册用于 DI 的一组依赖项。每个依赖项都有一个生命周期规范，它定义了它们在注入到消费类时是如何实例化的。我们将在本章后面更详细地探讨依赖项的生命周期。
- en: When a class that has a dependency is instantiated, it reaches out to the container,
    which takes care of the business of resolving the dependency and instantiating
    it according to the lifetime setting that was configured when the dependency was
    registered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个具有依赖项的类被实例化时，它会向容器发出请求，容器会负责解决依赖项并根据在依赖项注册时配置的生命周期设置来实例化它。
- en: It might sound like this is an extra layer of complexity for something as simple
    as using a class within another, but there is good reason for mandating the use
    of DI as a best practice. Let us explore this in more detail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是使用另一个类中的类这样简单的事情的额外复杂性层，但强制使用 DI 作为最佳实践有很好的理由。让我们更详细地探讨这一点。
- en: The case for DI
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入的案例
- en: Think back to your career to date as a software engineer. Whether you’re still
    at the beginning, or you’ve been doing this for a while, you may have spent considerable
    time *newing up* dependencies in the form of classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你作为一名软件工程师的职业生涯。无论你还在起步阶段，还是已经从事这一行业一段时间，你可能已经花费了大量时间以类的形式“new”依赖项。
- en: Let’s say you’re building an API endpoint that needs to reach into a SQL database.
    (I’m deliberately not using Entity Framework for this example for simplicity.)
    You may have already created a class that abstracts away the specifics (we’ll
    call it **SqlHelper** ), such as creating an instance of **SqlConnection** , opening
    the connection, building **SqlCommand** , and so on. What do you think you’ll
    need to do each time you realize that you need this **SqlHelper** class?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个需要访问 SQL 数据库的 API 端点。（为了简化，我故意没有使用 Entity Framework。）你可能已经创建了一个抽象化具体细节的类（我们可以称之为
    **SqlHelper**），例如创建一个 **SqlConnection** 实例、打开连接、构建 **SqlCommand** 等。当你意识到需要这个
    **SqlHelper** 类时，你认为你需要做什么？
- en: 'The first thing you’ll notice is that you have to create a new instance of
    **SqlHelper** at any point that the need for interaction with your SQL Server
    arises. On the face of it, this sounds harmless enough, but from a design perspective,
    it’s problematic. Let’s look at the potential pitfalls of this approach a little
    more closely:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，每当需要与你的 SQL Server 交互时，你必须创建一个新的 **SqlHelper** 实例。表面上，这似乎无害，但从设计角度来看，这存在一些问题。让我们更仔细地看看这种方法的潜在陷阱：
- en: '**Tight coupling** : Without DI, you create a concrete implementation of **SqlHelper**
    each time you use it. Whenever you have a concrete implementation of a class,
    you run the risk of being forced to change each class that consumes it if you
    need to significantly change **SqlHelper** . This means that your consuming classes
    become tightly coupled to **SqlHelper** .'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合**：没有依赖注入（DI），每次使用 **SqlHelper** 时都会创建其具体实现。每当有一个类的具体实现时，如果你需要显著更改 **SqlHelper**，你就面临着被迫更改每个使用它的类的风险。这意味着你的消费类会紧密耦合到
    **SqlHelper**。'
- en: '**Difficulties in testing** : Being able to mock dependencies is critical to
    effective testing. Without DI, you will have to be more hands-on in ensuring that
    dependencies are properly instantiated, mocked, and then accessible for each test.
    The added need for manual instantiation increases the potential for mistakes in
    setting up the tests. This is problematic because it can make your tests unreliable.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试困难**：能够模拟依赖项对于有效的测试至关重要。没有 DI，你将需要更手动地确保依赖项被正确实例化、模拟，并且对每个测试都是可访问的。手动实例化的额外需求增加了设置测试时出现错误的可能性。这是一个问题，因为它可能会使你的测试变得不可靠。'
- en: '**Resource management issues** : When dependencies are using resources as **SqlHelper**
    is (it will have a connection to a SQL Server), there is always the risk that
    those resources are not managed effectively. In the case of something like a SQL
    connection, spinning up a lot of these connections over time without adequate
    disposal could exhaust the connections, leading to performance issues.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理问题**：当依赖使用资源时，例如**SqlHelper**（它将有一个与SQL Server的连接），总存在这些资源没有被有效管理的风险。在类似SQL连接的情况下，如果没有适当的释放，随着时间的推移创建大量这些连接可能会导致连接耗尽，从而引发性能问题。'
- en: '**Violation of single responsibility, open-closed principle, Liskov substitution,
    interface segregation principle, dependency inversion principle (SOLID) principles**
    : We’ve not yet explored SOLID principles in this book, but they are an important
    part of any object-oriented software system. One of the guiding principles of
    SOLID is *single responsibility* , in which we are expected to ensure that classes
    have a primary responsibility. In the case of a class consuming **SqlHelper**
    , their primary responsibility is to the logic that is requesting or manipulating
    data. Forcing the class to instantiate **SqlHelper** means you’re giving it a
    new responsibility; a responsibility of managing its own dependencies. DI removes
    this added responsibility, simply passing the dependencies into the class when
    the class is constructed.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**违反单一职责、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则（SOLID原则）**：本书中我们尚未探讨SOLID原则，但它们是任何面向对象软件系统的重要组成部分。SOLID的一个指导原则是**单一职责**，即我们期望确保类有一个主要职责。对于一个消费**SqlHelper**的类来说，它们的主要职责是对请求或操作数据的逻辑。迫使类实例化**SqlHelper**意味着你给它赋予了新的职责；管理其自身依赖的职责。依赖注入（DI）移除了这个附加的职责，简单地在类构造时将依赖传递给类。'
- en: Hopefully, this breakdown has painted a picture of how not using DI can make
    your code base inconsistent and messy. Now, let us explore how DI is achieved
    in ASP.NET.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这次分解已经描绘了不使用DI如何使你的代码库不一致和混乱的画面。现在，让我们探讨ASP.NET中如何实现DI。
- en: Configuring DI in minimal APIs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在最小API中配置DI
- en: As standard, ASP.NET offers a way for us to declare that a class we have created
    can be registered as a service. Converting a class into a service means it can
    be reused via DI. For example, say you’ve got a piece of logic that calculates
    overtime pay for any given employee. That logic is the same, but you’ll need it
    in many other areas of the code base. To avoid writing the same logic again, it’s
    obvious that you would simply call on the same logic, but as we’ve already discussed,
    creating a new instance of the class to get to this logic whenever you need it
    is messy; so, by registering the class as a service, we can cleanly inject it
    into any other class that needs it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准，ASP.NET提供了一种方法，允许我们声明我们创建的类可以被注册为服务。将类转换为服务意味着它可以通过DI进行重用。例如，假设你有一段逻辑，用于计算任何给定员工的加班费。这段逻辑是相同的，但你需要在代码库的许多其他区域使用它。为了避免再次编写相同的逻辑，显然你会调用相同的逻辑，但正如我们之前讨论的，每次需要时都创建类的新的实例以获取这段逻辑是混乱的；因此，通过将类注册为服务，我们可以干净地将其注入到任何需要它的其他类中。
- en: Moreover, DI allows us to control the life cycle of the service when it is injected.
    In essence, we can dictate how the dependency is instantiated on each injection
    and how long it should exist.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DI允许我们控制注入时服务的生命周期。本质上，我们可以指定依赖在每个注入中是如何实例化的，以及它应该存在多久。
- en: 'There are three built-in lifetime options in ASP.NET:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET中有三种内置的生命周期选项：
- en: '**Singleton** : The service is created once, as a single instance. This instance
    is then shared across the code base. This can be useful when you need to maintain
    state on a global scale. Logging is a good use case for this, as all log entries
    can be channeled through one single service that has access to the relevant output
    resource. For example, a logging service that creates logs in a file.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：服务被创建一次，作为一个单一实例。然后这个实例在代码库中被共享。当你需要在全球范围内维护状态时，这很有用。日志记录是一个很好的用例，因为所有日志条目都可以通过一个单一的服务进行通道，该服务可以访问相关的输出资源。例如，一个在文件中创建日志的日志服务。'
- en: '**Scoped** : The service is created once for every incoming request. This means
    that when a client makes a request to the API, a service is created when needed
    and that instance is in use for the duration of the request. This is ideal when
    you need to manage state within a request. It is also favorable if you do not
    want to share the same service between different requests.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域**：为每个传入的请求创建一次服务。这意味着当客户端向API发出请求时，需要时创建服务，该实例在整个请求期间处于使用状态。这在需要管理请求内的状态时是理想的。如果您不希望在不同请求之间共享相同的服务，这也是有利的。'
- en: '**Transient** : The service has an instance created every time it is injected.
    This means that regardless of the request being made to the API, each time a service
    is injected, that service will be a new instance. This is ideal for scenarios
    where state does not need to be maintained.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态**：每次注入服务时都会创建一个实例。这意味着无论对API发出的请求是什么，每次注入服务时，该服务都将是一个新实例。这在不需要维护状态的场景中是理想的。'
- en: Let’s set up a new minimal API project to use as an example of how we can benefit
    from DI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个新的最小API项目，作为我们如何从依赖注入（DI）中受益的示例。
- en: Please note, if you haven’t read them already, refer to the first two chapters
    to understand how you can create a new minimal API project. This will allow you
    to follow along with the examples in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您还没有阅读它们，请参考前两章了解您如何创建一个新的最小API项目。这将使您能够跟随本章中的示例。
- en: Setting up a scoped DI project
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个范围依赖注入（DI）项目
- en: For our new API project, we’re going to use the example of an order-processing
    API. It will contain a series of products or services that can be put together
    to create an order.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的新API项目，我们将以订单处理API为例。它将包含一系列可以组合成订单的产品或服务。
- en: 'First, we need models to represent products and orders. Create two classes,
    **Product** and **Order** . In the first code, we create the **Product** class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要模型来表示产品和订单。创建两个类，**Product**和**Order**。在第一段代码中，我们创建**Product**类：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following code, we create the **Order** class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们创建**Order**类：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to be able to refer to a collection of available products. Ordinarily,
    we would store this information in a database and then use either **SqlConnection**
    or an **Object Relational Mapping** ( **ORM** ) framework, such as Microsoft’s
    Entity Framework, to access the database, mapping the data to the models ( **Product**
    and **Order** ) we’ve created. However, database connections are not within the
    scope of this chapter and will be covered later in the book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够引用一组可用的产品。通常，我们会将此信息存储在数据库中，然后使用**SqlConnection**或**对象关系映射**（**ORM**）框架，例如微软的Entity
    Framework，来访问数据库，将数据映射到我们创建的模型（**Product**和**Order**）。然而，数据库连接不在本章的范围内，将在本书的后续章节中介绍。
- en: 'For now, and for simplicity, we will simply create a JSON file containing an
    array of objects that can be read into the project as text and deserialized into
    the strongly typed object, **Product** . I’ve created an example of five products
    that can be saved in JSON format, in the following code. Feel free to copy my
    examples or create your own. Whatever you do, save the products in a file called
    **Products.json** in an accessible location. Ensure that each project is a JSON
    object contained within a single JSON array and that the values you use match
    the data types of the properties in **Product** ; otherwise, it will not be possible
    to deserialize the JSON:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了简单起见，我们将简单地创建一个包含对象的JSON文件，这些对象可以作为文本读入项目，并反序列化为强类型对象**Product**。我已经创建了一个包含五个产品的示例，这些产品可以以JSON格式保存，以下代码。您可以随意复制我的示例或创建自己的示例。无论您做什么，请将产品保存在名为**Products.json**的文件中，并确保每个项目都是一个包含在单个JSON数组中的JSON对象，并且您使用的值与**Product**属性的数据类型相匹配；否则，将无法反序列化JSON：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let’s create a means of bringing these objects into memory when they are
    needed. (Again, not the most efficient example as we’re not using a database,
    but we will be covering database usage later in the book.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一种方法，在需要时将这些对象带入内存。（再次强调，这不是最有效率的示例，因为我们没有使用数据库，但我们将在本书的后续章节中介绍数据库的使用。）
- en: For this example, we’ll do this by creating a class, called **ProductRepository**
    . This class can be used to access a list of objects of type **Product** .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将通过创建一个名为**ProductRepository**的类来实现。这个类可以用来访问类型为**Product**的对象列表。
- en: 'Add the **ProductRepository** class as per the example here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下示例添加**ProductRepository**类：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, this is a very simple class that just holds a list of **Product**
    . We need to somehow populate this list with the JSON objects we’ve saved as text.
    We could very easily just fetch the items when we instantiate the class, but we
    want to do this using an injected service, so we’ll come back to **ProductRepository**
    shortly. Before that, let’s create a service that will have the responsibility
    of retrieving the products from the text file. We’ll call it **ProductRetrievalService**
    :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的类，它只包含一个 **Product** 列表。我们需要以某种方式填充这个列表，以包含我们已保存为文本的 JSON 对象。我们可以在实例化类时轻松地获取这些项目，但我们要使用注入的服务来做这件事，所以我们会很快回到
    **ProductRepository**。在那之前，让我们创建一个将负责从文本文件中检索产品的服务。我们将称之为 **ProductRetrievalService**：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple service reads the contents of the JSON file and uses the **JsonSerializer**
    class found within **System.Text.Json** to convert, or deserialize, the JSON content
    into the strongly typed **Product** type, putting each **Product** into the list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的服务读取 JSON 文件的全部内容，并使用 **System.Text.Json** 中找到的 **JsonSerializer** 类将 JSON
    内容转换或反序列化为强类型的 **Product** 类型，将每个 **Product** 放入列表中。
- en: Permissions on C:/
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C:/ 的权限
- en: If you have trouble writing or reading from **C:/** , you may not have permission
    to do so. You can work around this by creating a folder in a location to which
    you do have read/write permissions, and then change the path in the code to match
    the new one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写或读 **C:/** 时遇到麻烦，你可能没有权限这样做。你可以通过在具有读写权限的位置创建一个文件夹来解决这个问题，然后更改代码中的路径以匹配新的路径。
- en: At this point, the products have been retrieved. This means that we can simply
    call **LoadProducts()** and we will always get the latest data. However, how do
    we access **ProductRetrievalService** to do this? Our **ProductRepository** class
    will need this logic in order to populate its **Product** list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，产品已被检索。这意味着我们可以简单地调用 **LoadProducts()**，我们总是会得到最新的数据。然而，我们如何访问 **ProductRetrievalService**
    来做到这一点？我们的 **ProductRepository** 类需要这个逻辑来填充其 **Product** 列表。
- en: Here is where DI becomes useful. We can inject an instance of **ProductRetrievalService**
    any time we use **ProductRepository** . To make this possible, we first need to
    register **ProductRetreivalService** as a service.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，依赖注入变得有用。我们可以在使用 **ProductRepository** 的任何时候注入一个 **ProductRetrievalService**
    实例。为了使这成为可能，我们首先需要将 **ProductRetrievalService** 注册为服务。
- en: 'The following code demonstrates registration of this service for DI within
    **Program.cs** :'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了在 **Program.cs** 中注册此服务以进行依赖注入的示例：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By adding **ProductRetrievalService** as a scoped service, an instance will
    be created for the duration of the incoming request. Now that it is registered,
    we can inject **ProductRetrievalService** into **ProductRepository** when we instantiate
    it, via its constructor. Let us look at an example of this in an API endpoint
    example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 **ProductRetrievalService** 作为作用域服务添加，将为每个传入请求创建一个实例。现在它已注册，我们可以在实例化时通过其构造函数将
    **ProductRetrievalService** 注入到 **ProductRepository** 中。让我们通过一个 API 端点示例来看看这个例子。
- en: 'Create a new HTTP **GET** method, mapped onto the **getProductById** route,
    as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 HTTP **GET** 方法，映射到 **getProductById** 路由，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The endpoint takes an integer parameter in the form of the product ID. We can
    now use this to get the product with the matching ID. First things first, let’s
    add a new instance of **ProductRepository** to the endpoint:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 端点接受一个整数参数，即产品 ID。我们现在可以使用这个参数来获取具有匹配 ID 的产品。首先，让我们向端点添加一个新的 **ProductRepository**
    实例：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have a **ProductRepository** instance now, which has a list of **Product**
    , but this list is empty. We need to modify **ProductRepository** to inject **ProductRetreivalService**
    , to populate that list. The following code shows an example of how the service
    can be injected into **ProductRepository** via the constructor before being used
    to populate the products held within a **List<Product>** :'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 **ProductRepository** 实例，它有一个 **Product** 列表，但这个列表是空的。我们需要修改 **ProductRepository**
    以注入 **ProductRetreivalService** ，以填充这个列表。下面的代码展示了如何通过构造函数将服务注入到 **ProductRepository**
    中，以便在使用之前填充 **List<Product>** 中持有的产品：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we should be able to use some logic in the endpoint to get the relevant
    product from **ProductRepository** . However, we have a problem. If we try to
    instantiate a new instance of **ProductRepository** in the endpoint, we will see
    an error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够在端点中使用一些逻辑来从 **ProductRepository** 获取相关产品。然而，我们有一个问题。如果我们尝试在端点中实例化一个新的
    **ProductRepository** 实例，我们会看到一个错误。
- en: The reason we see an error is that we have changed the way **ProductRepository**
    is instantiated. It now requires a **ProductRetrievalService** to be passed as
    an argument to the constructor, but how are we supposed to get hold of this?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到错误的原因是我们改变了 **ProductRepository** 的实例化方式。现在它需要一个 **ProductRetrievalService**
    作为构造函数的参数，但我们应该如何获取这个服务呢？
- en: This is where minimal APIs allow us to, within an endpoint, take advantage of
    services registered within the DI container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，最小化 API 允许我们在端点内部利用 DI 容器中注册的服务。
- en: '**ProductRetreivalService** can be passed as an argument within the parameters
    we pass into the lambda expression within the body of the endpoint. This makes
    it the same as the ID parameter passed in by the client, except it’s not coming
    from the client, it’s coming from the DI container.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProductRetreivalService** 可以作为参数传递给端点体内部 lambda 表达式中的参数。这使得它和客户端传入的 ID 参数相同，只不过它不是来自客户端，而是来自
    DI 容器。'
- en: To make this possible, you need to prefix the **ProductRetrievalService** argument
    with an attribute that indicates that it was injected. This attribute is **[FromServices]**
    .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，您需要将 **ProductRetrievalService** 参数前缀为一个表示其被注入的属性。这个属性是 **[FromServices]**
    。
- en: 'Injecting **ProductRetrievalService** with this attribute will now allow us
    to pass the required **ProductRetrievalService** to the constructor of **ProductRepository**
    , as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此属性注入 **ProductRetrievalService** 现在将允许我们将所需的 **ProductRetrievalService**
    传递给 **ProductRepository** 的构造函数，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is also worth noting that the instance of **ProductRepository** we created
    in this example could itself be injected into the class using DI.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在本例中创建的 **ProductRepository** 实例本身也可以通过 DI 注入到类中。
- en: Let’s move on to our next example now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个例子。
- en: Creating a singleton DI project
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个单例 DI 项目
- en: Let’s look at another example, but this time, we’ll use a different life cycle
    for the dependency. In this use case, we will create an endpoint for creating
    an order. The incoming **Order** object will have a list of **Product** that can
    be used to submit a new customer order into the system. However, we also need
    to establish a delivery date.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子，但这次我们将使用不同的依赖生命周期。在这个用例中，我们将创建一个用于创建订单的端点。传入的 **Order** 对象将包含一个 **Product**
    列表，可以用来将新的客户订单提交到系统中。然而，我们还需要确定一个交货日期。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To avoid repeating ourselves, we can for this example, simply use a collection
    such as **List<DateTime>** rather than feeding them in from a JSON file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复，在这个例子中，我们可以简单地使用一个集合，例如 **List<DateTime>**，而不是从 JSON 文件中读取它们。
- en: Let’s imagine that there is a feed of upcoming available dates that are centrally
    managed. We could create a service that has the available context to be able to
    choose the next available date. This decouples the logic from the endpoint and
    can be reused in other endpoints.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设有一个即将可用的日期的流，这些日期是集中管理的。我们可以创建一个服务，它具有选择下一个可用日期的上下文。这将从端点逻辑中解耦，并可以在其他端点中重用。
- en: 'The code shows an example of this kind of service:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码展示了这种类型服务的示例：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This service allows requests to get the next available date, throwing an exception
    if there is no date available. We have a queue to hold the available dates so
    they can be removed as they are retrieved to ensure that the same date is not
    offered twice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务允许请求获取下一个可用日期，如果没有可用日期则抛出异常。我们有一个队列来保存可用日期，以确保在检索时不会重复提供相同的日期。
- en: We also must consider thread safety here. You could have multiple requests all
    trying to get an available date, which is very likely to lead to a race condition,
    where two requests end up dequeuing the same available date. To avoid this, we
    are using **ConcurrentQueue** , which will handle the business of ensuring thread
    safety between requests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须考虑线程安全性。可能会有多个请求都在尝试获取一个可用的日期，这很可能导致竞态条件，其中两个请求最终会出队相同的可用日期。为了避免这种情况，我们正在使用
    **ConcurrentQueue**，它将处理确保请求之间线程安全的事务。
- en: We now need to register this as a service that can be injected into the endpoint
    that posts the order. With multiple requests in mind, we want to ensure that all
    requests are retrieving dates from the same list. Therefore, we will register
    the service using **AddSingleton()** , which will ensure that only one instance
    of the service is used between threads and requests during injection.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将其注册为一个可以被注入到发布订单端点的服务。考虑到可能会有多个请求，我们想要确保所有请求都是从同一个列表中检索日期。因此，我们将使用**AddSingleton()**来注册此服务，这将确保在注入期间线程和请求之间只使用一个服务实例。
- en: 'Once the service has been registered in this way, **Program.cs** should look
    like the code shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式注册了服务，**Program.cs**应该看起来像下面的代码所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that the API has our second service registered, it is time to create the
    endpoint for creating an order.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在API已经注册了第二个服务，是时候创建创建订单的端点了。
- en: Seeing as we are creating a new record, we should use a **POST** method to achieve
    our goal. The **POST** method will take in a JSON object, which is implicitly
    parsed into an **Order** object within the endpoint parameter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个新的记录，我们应该使用**POST**方法来实现我们的目标。**POST**方法将接受一个JSON对象，该对象在端点参数内隐式解析为**Order**对象。
- en: Following this, we indicate that we are injecting **DeliveryDateBookingService**
    into the request.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们指出我们正在将**DeliveryDateBookingService**注入到请求中。
- en: Once this is done, we can complete the endpoint by adding the relevant logic
    to the body of the lambda expression.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以通过向lambda表达式的主体中添加相关逻辑来完成端点。
- en: 'The endpoint with logic for fetching the next delivery date is shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 获取下一个交货日期的逻辑端点如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Whilst we created a repository for **Product** , we have not yet created one
    for **Order** . Furthermore, we did not demonstrate saving entities to their respective
    repositories.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们为**Product**创建了一个仓库，但我们还没有为**Order**创建一个。此外，我们还没有演示将实体保存到各自的仓库中。
- en: 'This kind of logic will be covered later in the book as we explore design patterns
    (such as the repository pattern) and data sources, but for now, here is an example
    of how you can save the new order in the preceding endpoint:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨设计模式（如仓库模式）和数据源时，这种逻辑将在本书的后续部分进行介绍，但就目前而言，这里有一个例子说明你如何在先前的端点中保存新订单：
- en: 'Create an **OrderRetreivalService** class so we stay consistent in using a
    service to retrieve entities (as we did for products):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**OrderRetreivalService**类，以便我们保持使用服务检索实体的一致性（就像我们为产品所做的那样）：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Register **OrderRetrievalService** as a scoped service in the DI container
    within **Program.cs** :'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Program.cs**中注册**OrderRetrievalService**为一个作用域服务：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create an **OrderRespository** class that follows the same style as **ProductRespository**
    . The added difference is that a **SaveOrder()** method is added to allow for
    saving the **Order** from the **POST** endpoint. Also, the collection being used
    to hold the orders is **ConcurrentQueue<Order>** rather than a list. This is because
    we expect orders to be saved from multiple concurrent requests and we need to
    allow for thread safety:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个遵循与**ProductRespository**相同风格的**OrderRespository**类。添加的不同之处在于增加了一个**SaveOrder()**方法，允许从**POST**端点保存**Order**。此外，用于存储订单的集合是**ConcurrentQueue<Order>**而不是列表。这是因为我们预计订单将从多个并发请求中保存，并且我们需要允许线程安全：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Register **OrderRepository** as a singleton service in **Program.cs** so that
    we can always add to it on a single instance regardless of how many requests are
    saving orders:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Program.cs**中将**OrderRepository**注册为单例服务，这样无论保存订单的请求数量有多少，我们都可以始终添加到单个实例中：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The **POST** endpoint can now be updated to inject **OrderRepository** and
    to use it for saving the incoming order:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以将**POST**端点更新为注入**OrderRepository**并使用它来保存传入的订单：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that you have some experience creating dependencies as services and registering
    them for injection, let’s go over some basic best practices for using DI in minimal
    APIs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一些创建依赖项作为服务和注册它们以供注入的经验，让我们回顾一下在最小API中使用DI的一些基本最佳实践。
- en: DI best practices
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI最佳实践
- en: DI is integral to most ASP.NET projects, and minimal APIs are often particularly
    reliant on them. As a result, it’s important to ensure that we are following best
    practices when it comes to dependencies and the methods of accessing them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: DI对于大多数ASP.NET项目至关重要，而最小API通常特别依赖于它们。因此，确保我们在依赖关系及其访问方法方面遵循最佳实践非常重要。
- en: There are some simple rules of thumb when it comes to implementing DI in minimal
    APIs. We look at these rules in the next few sections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小化API中实现依赖注入（DI）时，有一些简单的经验法则。我们将在接下来的几节中探讨这些规则。
- en: Avoiding the service locator pattern
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用服务定位器模式
- en: There is an anti-pattern in minimal APIs known as the **service locator pattern**
    . In this pattern, instead of explicitly injecting your dependency, you inject
    **IServiceProvider** containing the dependency, and then you fish the service
    out of it within the body of your method or function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小化API中存在一种称为**服务定位器模式**的反模式。在这种模式中，你不是显式注入依赖项，而是注入包含依赖项的**IServiceProvider**，然后在你的方法或函数体中从其中提取服务。
- en: 'An example of the service locator pattern is shown in the following code, in
    which the **POST** method we made for creating orders is altered to use **IServiceProvider**
    :'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例展示了服务定位器模式的一个例子，其中我们为创建订单而创建的**POST**方法被修改为使用**IServiceProvider**：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A significant drawback to this practice is that it makes the code harder to
    read. It is less obvious from the parameter that you are injecting specific services,
    and you have to write extra lines of code to get the service of **IServiceProvider**
    .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的一个显著缺点是它使得代码更难阅读。从参数中不明显看出你正在注入特定的服务，你必须编写额外的代码来获取**IServiceProvider**的服务。
- en: It also makes it more difficult to write unit tests for your endpoints, because
    it is less clear which objects you need to instantiate for mocking.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使得为你的端点编写单元测试更加困难，因为不清楚你需要实例化哪些对象来进行模拟。
- en: Probably the most destructive aspect of this anti-pattern is the potential for
    runtime failures to be hard to diagnose. When injecting **IServiceProvider** ,
    the compiler doesn’t know if the service you actually need is registered, whereas
    if you attempt to explicitly inject your service and it isn’t registered, it will
    become apparent much more quickly, allowing for easier debugging.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式最具破坏性的方面可能是运行时故障难以诊断。当注入**IServiceProvider**时，编译器不知道你实际需要的服务是否已注册，而如果你尝试显式注入你的服务且它未注册，问题将更快地显现出来，从而便于调试。
- en: Registering services with an extension method
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展方法注册服务
- en: You can make your code more readable by creating an extension method on **IServiceCollection**
    . This means that within **Program.cs** , you can register all your services with
    just one line of code or group your services together in an appropriate way and
    register each group.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在**IServiceCollection**上创建扩展方法来使你的代码更具可读性。这意味着在**Program.cs**中，你可以用一行代码注册所有服务，或者以适当的方式将服务分组在一起并分别注册每个组。
- en: 'Here is an example of how you can write such an extension method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何编写此类扩展方法的示例：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After implementing the extension method, you can simply write the following
    in **Program.cs** to register all services:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实现扩展方法后，你可以在**Program.cs**中简单地写下以下内容来注册所有服务：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using sensible service lifetimes
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用合理的服务生命周期
- en: 'When registering services, it is important to consider the lifetime you are
    assigning to them. Here are some examples of when you would use each service lifetime:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册服务时，考虑分配给它们的生命周期很重要。以下是一些你可能会使用每种服务生命周期的例子：
- en: '**Transient** : Use this lifetime if your service is lightweight, stateless,
    and is only to be used for a short period of time.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transient**：如果你的服务轻量级、无状态，并且只用于短时间内，请使用此生命周期。'
- en: '**Scoped** : Use this lifetime when your service must maintain state within
    a single request, and the state needs to be unique to the current request.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scoped**：当你的服务必须在单个请求中维护状态，并且状态需要对于当前请求是唯一的时候，请使用此生命周期。'
- en: '**Singleton** : Use this lifetime when your service must maintain state across
    the whole application. It is also useful for situations where you need to create
    heavy services that are costly to create. Creating them once reduces the overhead.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Singleton**：当你的服务必须在整个应用程序中维护状态时，请使用此生命周期。在需要创建成本高昂的重型服务的情况下，这也很有用。一旦创建，就可以减少开销。'
- en: Making the effort to follow best practices when creating and managing dependencies
    is a long-term investment, and is a selfless act, ensuring that the code base
    is easy to maintain for other developers in the future.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和管理依赖项时努力遵循最佳实践是一种长期投资，这是一种无私的行为，确保代码库在未来对其他开发者来说易于维护。
- en: Let’s summarize what we’ve covered in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所涵盖的内容。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the chapter by exploring DI from a high level, gaining an understanding
    of the benefits it brings to minimal APIs by encouraging good design, loose coupling,
    and reusability across the code base.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从高层次开始本章，通过了解它如何通过鼓励良好的设计、松散耦合和代码库中的可重用性，为最小API带来好处。
- en: We then looked at how dependencies can be created in the form of services, before
    being registered for injection, using the example of an order processing API.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过一个订单处理API的例子，探讨了如何以服务的形式创建依赖项，并在注册后进行注入。
- en: It was demonstrated that parameter attributes can be used within a minimal API
    endpoint to inject services into the scope of an endpoint’s execution, and we
    covered the various lifetimes available to services when they are registered.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 已经证明，可以在最小的API端点中使用参数属性将服务注入到端点执行的范围中，我们还介绍了服务在注册时可以使用的各种生命周期。
- en: Finally, some best practices were outlined, helping you to ensure that your
    use of DI is productive, efficient, sustainable, and testable, whilst also being
    easy to read for other developers who may be less familiar with the project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们概述了一些最佳实践，帮助您确保您的依赖注入（DI）使用是高效、可持续、可测试的，同时对于可能不太熟悉项目的其他开发者来说也易于阅读。
- en: DI is a fundamental aspect of not only minimal APIs but software engineering
    in general. Having a good grounding in it will be essential for your success as
    a developer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）不仅是最小API的基本方面，也是软件工程的一般基础。对它的良好理解对于您作为开发者的成功至关重要。
- en: In this chapter, we also used some pretty unorthodox methods of storing and
    reading in data for use within the example API endpoints. There is good reason
    for this. Normally, we would use more standardized data sources to host and retrieve
    entities, which is something we are going to explore in detail in the next chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还使用了相当非正统的方法来存储和读取数据，以便在示例API端点中使用。这样做有很好的理由。通常，我们会使用更标准化的数据源来托管和检索实体，这是我们将在下一章中详细探讨的内容。
