<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-16">
    <a id="_idTextAnchor015">
    </a>
    
     1
    
   </h1>
   <h1 id="_idParaDest-17">
    <a id="_idTextAnchor016">
    </a>
    
     Unit Testing and Test-Driven Development
    
   </h1>
   <p>
    
     This chapter delves into the foundational concepts of unit testing and
    
    <strong class="bold">
     
      Test-Driven Development
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TDD
     
    </strong>
    
     ) within
    
    <a id="_idIndexMarker000">
    </a>
    
     Visual Studio 2022.
    
    
     You will learn about the significance of writing tests before code and explore the integration of testing frameworks.
    
    
     Practical examples will guide you through creating effective unit tests, ensuring code reliability, and fostering a
    
    
     
      test-driven mindset.
     
    
   </p>
   <p>
    
     We will embark on a journey to understand the essentials of unit testing and TDD.
    
    
     We’ll start by gaining an overview of these foundational concepts and exploring their significance in the software development
    
    
     
      life cycle.
     
    
   </p>
   <p>
    
     Following this introduction, we will delve into the practical aspects of setting up unit testing within Visual Studio Code.
    
    
     This section will guide you through the initial steps of configuring your development environment, laying the groundwork for the integration of testing frameworks into
    
    
     
      your workflow.
     
    
   </p>
   <p>
    
     Once the setup is complete, we will transition into creating our first test using IntelliTest, a feature of Visual Studio that automates the generation of unit tests.
    
    
     This hands-on experience will demonstrate how IntelliTest can streamline the testing process, making it more efficient and
    
    
     
      less time-consuming.
     
    
   </p>
   <p>
    
     Next, we will apply what we’ve learned in a real-world example, practicing TDD from the ground up.
    
    
     This section will walk you through the process of writing tests before code, a core principle of TDD, and how it can lead to more robust and
    
    
     
      reliable software.
     
    
   </p>
   <p>
    
     Finally, we will explore how to automate your testing process with Live Unit Testing, a feature that runs your unit tests in the background as you code.
    
    
     This section will show you how to enable and utilize Live Unit Testing to enhance your development workflow, ensuring that your code remains reliable and bug-free throughout the
    
    
     
      development process.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing unit testing
     
     
      
       and TDD
      
     
    </li>
    <li>
     
      Setting up unit testing in
     
     
      
       Visual Studio
      
     
    </li>
    <li>
     
      Creating tests
     
     
      
       with IntelliTest
      
     
    </li>
    <li>
     
      Practicing TDD with a
     
     
      
       real-world example
      
     
    </li>
    <li>
     
      Automating your tests with Live
     
     
      
       Unit Test
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-18">
    <a id="_idTextAnchor017">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     While writing this chapter, I used the following version of
    
    
     
      Visual Studio:
     
    
   </p>
   <ul>
    <li>
     
      Visual Studio Enterprise 2022
     
     
      
       version
      
     
     
      
       17.12.0
      
     
    </li>
    <li>
     
      
       Preview
      
     
     
      
       1.0
      
     
    </li>
   </ul>
   <p>
    
     The code files for this chapter can be found
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01">
     
      
       https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01
      
     
    </a>
   </p>
   <h1 id="_idParaDest-19">
    <a id="_idTextAnchor018">
    </a>
    
     Introducing unit testing and TDD
    
   </h1>
   <p>
    
     Before delving into
    
    <a id="_idIndexMarker001">
    </a>
    
     the usage of unit testing and the TDD approach
    
    <a id="_idIndexMarker002">
    </a>
    
     through Visual Studio, let’s begin with a refresher on what they are and why it’s valuable to consider them in
    
    
     
      your project.
     
    
   </p>
   <p>
    
     Unit testing is a focused software testing method that targets individual units or components within a software system.
    
    
     The primary aim of unit testing is to ensure that each software unit functions as intended, meeting specified requirements.
    
    
     Typically conducted by developers, unit testing takes place early in the development stage, preceding the integration and testing of the
    
    
     
      entire system.
     
    
   </p>
   <p>
    
     Automated unit tests are executed whenever code undergoes modification, ensuring that new changes do not disrupt existing functionality.
    
    
     These tests are meticulously crafted to validate the smallest conceivable unit of code, such as a function or method, in isolation from the broader system.
    
    
     This approach empowers developers to swiftly identify and address issues in the initial phases of development, thereby enhancing overall software quality and reducing the time needed for subsequent
    
    
     
      testing phases.
     
    
   </p>
   <h2 id="_idParaDest-20">
    <a id="_idTextAnchor019">
    </a>
    
     The F.I.R.S.T principles of unit testing
    
   </h2>
   <p>
    
     By
    
    <a id="_idIndexMarker003">
    </a>
    
     conscientiously
    
    <a id="_idIndexMarker004">
    </a>
    
     embracing the
    
    <strong class="bold">
     
      Fast, Isolated/Independent, Repeatable, Self-Validating, Timely
     
    </strong>
    
     (
    
    <strong class="bold">
     
      F.I.R.S.T.
     
    </strong>
    
     ) principles in unit testing, developers are guided in the meticulous crafting of effective tests.
    
    
     These principles serve as a compass, steering the testing process toward excellence by instilling key criteria that underpin the reliability and
    
    <a id="_idIndexMarker005">
    </a>
    
     robustness
    
    <a id="_idIndexMarker006">
    </a>
    
     of
    
    
     
      unit tests.
     
    
   </p>
   <p>
    
     Let’s look at each of the factors of F.I.R.S.T.
    
    
     in
    
    
     
      more detail:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Fast
      
     </strong>
     
      : The speed of execution is a fundamental characteristic of effective unit tests.
     
     
      It is imperative that unit tests run swiftly, as developers frequently execute them throughout the development process.
     
     
      A fast test suite provides rapid feedback, allowing developers to promptly identify and rectify issues.
     
     
      This not only accelerates the development cycle but also cultivates a culture of responsiveness, where developers are encouraged to run tests frequently.
     
     
      The ability to obtain quick feedback enhances the early detection of potential problems, fostering a proactive approach to
     
     
      
       software quality.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Isolated/independent
      
     </strong>
     
      : Independence is a cornerstone principle in unit testing.
     
     
      Each unit test should operate in isolation, devoid of dependencies on other tests.
     
     
      The order in which tests are executed or the success or failure of one test must not impact the results of another.
     
     
      This isolation ensures that developers can pinpoint and address issues in a focused manner, simplifying the debugging process.
     
     
      By adhering to the principle of independence, developers gain the advantage of precisely identifying the source of a problem, thereby expediting the
     
     
      
       resolution process.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Repeatable
      
     </strong>
     
      : The repeatability of unit tests is paramount for maintaining the integrity of the testing process.
     
     
      A unit test should consistently produce the same result every time it is executed.
     
     
      This consistency ensures reliability in the test results, facilitating a dependable and predictable testing environment.
     
     
      If a test fails, developers should be able to reproduce the failure consistently, enabling them to investigate and resolve issues with confidence.
     
     
      Repeatability is a cornerstone for establishing trust in the testing suite and the overall software
     
     
      
       development process.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Self-validating
      
     </strong>
     
      : Unit tests should possess self-contained criteria for success or failure, requiring no manual interpretation.
     
     
      A self-validating test ensures unambiguous results, reducing the potential for misinterpretation.
     
     
      Developers can quickly understand the state of the code based solely on the test results, streamlining the debugging and issue-resolution processes.
     
     
      The self-validating nature of unit tests contributes to the clarity and effectiveness of the testing suite, enabling developers to make informed decisions based on the unambiguous outcomes of
     
     
      
       each test.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Timely
      
     </strong>
     
      : Timeliness in test writing is a critical factor in the effectiveness of unit testing.
     
     
      Ideally, tests should be authored before the corresponding code is implemented.
     
     
      This proactive approach ensures that tests serve as a living specification for the desired behavior, guiding the implementation process.
     
     
      Writing tests in a timely manner establishes a foundation for a well-defined and controlled development cycle.
     
     
      Timely testing also plays a pivotal role in identifying and addressing issues early in the development cycle, reducing the likelihood of defects propagating to later stages of the software development process.
     
     
      Embracing timely testing enhances the overall efficiency and reliability of the software development
     
     
      
       life cycle.
      
     
    </li>
   </ul>
   <p>
    
     Now that
    
    <a id="_idIndexMarker007">
    </a>
    
     we’ve
    
    <a id="_idIndexMarker008">
    </a>
    
     established a foundational understanding of unit testing and its principles, let’s turn our attention to the broader context
    
    
     
      of TDD.
     
    
   </p>
   <h2 id="_idParaDest-21">
    <a id="_idTextAnchor020">
    </a>
    
     TDD – unifying principles for software quality
    
   </h2>
   <p>
    
     These F.I.R.S.T principles
    
    <a id="_idIndexMarker009">
    </a>
    
     seamlessly pave the way to an overarching methodology known as TDD.
    
    
     TDD merges design, development, and testing into a unified framework, providing developers with a comprehensive approach to not only crafting simple and clean code but also ensuring thorough testing.
    
    
     The incremental development approach systematically tests all facets of business logic, making TDD the gold standard for creating high-quality software.
    
    
     It embodies the best coding and design practices throughout the
    
    
     
      entire process.
     
    
   </p>
   <p>
    
     The main purpose of TDD is to achieve simpler and more reliable code.
    
    
     For that, TDD follows a simple and effective process, illustrated
    
    <a id="_idIndexMarker010">
    </a>
    
     by the
    
    
     <strong class="bold">
      
       red-green-refactor cycle
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 1.1 – The TDD cycle" src="img/B22218_01_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.1 – The TDD cycle
    
   </p>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker011">
    </a>
    
     understand this TDD cycle in
    
    
     
      more detail:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Red – writing a
      
     </strong>
     
      <strong class="bold">
       
        failing test
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       In the first phase
      
      <a id="_idIndexMarker012">
      </a>
      
       of TDD, known as the Red phase, developers embark on the journey by articulating their intent through the creation of a failing test.
      
      
       This test specifically targets a small unit of functionality that has not yet been implemented.
      
      
       It serves as a tangible expression of the desired behavior, essentially outlining the expectations for the code that is yet to be written.
      
      
       It is important to note that, at this stage, the test is expected to fail since the corresponding functionality is absent from the
      
      
       
        code base.
       
      
     </p>
     <p class="list-inset">
      
       The primary purpose of the Red phase is to set a clear objective for the subsequent development process.
      
      
       By initially focusing on the expected outcome without any code in place, developers define a roadmap for the functionality they are about to implement.
      
      
       This intentional act of writing a test before writing the code not only establishes a specification for the upcoming functionality but also helps solidify the developer’s understanding of the problem
      
      
       
        at hand.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       Green – writing the minimum amount of code to pass
      
     </strong>
     
      <strong class="bold">
       
        the test
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       Following the Red phase, the development process proceeds to the Green phase.
      
      
       Here, the developer crafts the minimal amount of code necessary to make the previously written test pass successfully.
      
      
       The emphasis during this phase is on simplicity and efficiency.
      
      
       The goal is not to create an elaborate solution but to address the immediate requirement highlighted by the
      
      
       
        failing test.
       
      
     </p>
     <p class="list-inset">
      
       By concentrating on the bare minimum code required for success, developers foster a culture of simplicity and avoid unnecessary complexities.
      
      
       This focused approach encourages the creation of code that meets the specific needs outlined by the test, laying the foundation for a solution that is both functional and concise.
      
      
       The
      
      <a id="_idIndexMarker013">
      </a>
      
       success of the test in this
      
      <a id="_idIndexMarker014">
      </a>
      
       phase signifies the achievement of the targeted functionality, validating the initial expectations set in the
      
      
       
        Red phase.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       Refactor – refactoring
      
     </strong>
     
      <strong class="bold">
       
        the code
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       With a passing test in place, the development process enters the Refactor phase.
      
      
       At this juncture, the developer takes a step back to review and enhance the code that has been implemented.
      
      
       The primary objectives during refactoring are to improve the maintainability, readability, and extensibility of the code without altering
      
      
       
        its functionality.
       
      
     </p>
     <p class="list-inset">
      
       Refactoring is a critical aspect of TDD as it ensures that the code base remains clean and adaptable to future changes.
      
      
       Developers strive to eliminate redundancies, improve naming conventions, and apply design patterns where appropriate.
      
      
       This phase reinforces the commitment to producing not only functional but also well-crafted code.
      
      
       The successful completion of this phase sets the stage for a code base that is not only effective but also sustainable in the
      
      
       
        long run.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       Repeat –
      
     </strong>
     
      <strong class="bold">
       
        iterative process
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       TDD follows an iterative approach, and the Repeat phase encapsulates the cyclical nature of this development methodology.
      
      
       The entire Red-Green-Refactor cycle is repeated for each new piece of functionality that needs to be implemented.
      
      
       This iterative process ensures a systematic and gradual evolution of the code base, with
      
      <a id="_idIndexMarker015">
      </a>
      
       each cycle contributing to the overall development of
      
      
       
        the software.
       
      
     </p>
    </li>
   </ul>
   <p>
    
     By repeating the cycle, developers continually refine and expand the application, responding to evolving requirements and ensuring that the code remains aligned with the project’s objectives.
    
    
     This iterative nature of TDD promotes adaptability and agility, making it a valuable methodology for projects with changing or
    
    
     
      evolving requirements.
     
    
   </p>
   <p>
    
     This approach not
    
    <a id="_idIndexMarker016">
    </a>
    
     only ensures the creation of functional software but also cultivates a mindset of continuous improvement and adaptability in the
    
    
     
      development process.
     
    
   </p>
   <h2 id="_idParaDest-22">
    <a id="_idTextAnchor021">
    </a>
    
     AAA pattern – a structured approach to testing
    
   </h2>
   <p>
    
     Building upon the
    
    <a id="_idIndexMarker017">
    </a>
    
     principles of TDD and F.I.R.S.T, another key methodology in the realm of unit testing is
    
    <a id="_idIndexMarker018">
    </a>
    
     the
    
    <strong class="bold">
     
      Arrange-Act-Assert
     
    </strong>
    
     (
    
    <strong class="bold">
     
      AAA
     
    </strong>
    
     ) pattern.
    
    
     This pattern provides a uniform structure for organizing tests within a suite.
    
    
     The AAA pattern contributes significantly to the readability and maintainability of test suites, aligning seamlessly with the overarching goals
    
    
     
      of TDD.
     
    
   </p>
   <p>
    
     The AAA pattern breaks down a test into three
    
    
     
      distinct sections:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Arrange
      
     </strong>
     
      : This section is about setting up the
     
     
      
       test environment.
      
     
     <p class="list-inset">
      
       In the Arrange section, the focus is on preparing the environment for the test.
      
      
       This involves setting up the objects to be tested, bringing the
      
      <strong class="bold">
       
        System under Test
       
      </strong>
      
       (
      
      <strong class="bold">
       
        SUT
       
      </strong>
      
       ) to a
      
      <a id="_idIndexMarker019">
      </a>
      
       specific state, and configuring any dependencies.
      
      
       Whether instantiating objects directly or preparing test doubles dependencies, the goal is to establish a controlled and consistent starting point for
      
      
       
        the test.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       Act
      
     </strong>
     
      : This section is about performing the action on
     
     
      
       the SUT.
      
     
     <p class="list-inset">
      
       The Act section is where the actual interaction with the SUT takes place.
      
      
       This involves invoking a method or action on the SUT, passing any required dependencies, and capturing the output value, if applicable.
      
      
       The Act phase is crucial for simulating the real-world usage of the system and observing
      
      
       
        its behavior.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       Assert
      
     </strong>
     
      : This section focuses on verifying the
     
     
      
       expected outcome.
      
     
     <p class="list-inset">
      
       In the Assert section, the test makes explicit claims about the expected outcome.
      
      
       This may include checking the return value, inspecting the final state of the SUT and its collaborators, or verifying the methods called on them.
      
      
       The Assert phase is
      
      <a id="_idIndexMarker020">
      </a>
      
       the culmination of the test, ensuring that the behavior aligns with the
      
      
       
        anticipated results.
       
      
     </p>
    </li>
   </ul>
   <p>
    
     The AAA pattern’s structured approach provides clarity and consistency across all tests in a suite.
    
    
     By adhering to this pattern, developers can easily comprehend and navigate through tests, ultimately reducing the maintenance cost of the entire test suite.
    
    
     Whether starting
    
    <a id="_idIndexMarker021">
    </a>
    
     with Arrange, Act, or Assert, the AAA
    
    <a id="_idIndexMarker022">
    </a>
    
     pattern accommodates different testing styles while promoting a unified and systematic
    
    
     
      testing methodology.
     
    
   </p>
   <p>
    
     Now that we’ve had a tour of unit testing and TDD, let’s dive in and see how to create a unit test project within
    
    
     
      Visual Studio.
     
    
   </p>
   <h1 id="_idParaDest-23">
    <a id="_idTextAnchor022">
    </a>
    
     Setting up unit testing in Visual Studio 2022
    
   </h1>
   <p>
    
     In this section, we
    
    <a id="_idIndexMarker023">
    </a>
    
     will first create a unit test project within Visual Studio.
    
    
     Once that is done, we’ll go through an overview of the
    
    <strong class="bold">
     
      Test Explorer
     
    </strong>
    
     view and its main options.
    
    
     The
    
    <strong class="bold">
     
      Test Explorer
     
    </strong>
    
     view serves as a central hub for all testing activities within the IDE, offering a comprehensive overview of our test suite’s status and performance.
    
    
     It allows us to easily navigate through test results, identify failures, and access detailed information about each
    
    
     
      test case.
     
    
   </p>
   <h2 id="_idParaDest-24">
    <a id="_idTextAnchor023">
    </a>
    
     Creating a unit test project
    
   </h2>
   <p>
    
     Visual
    
    <a id="_idIndexMarker024">
    </a>
    
     Studio and .NET support three
    
    
     
      testing
     
    
    
     <a id="_idIndexMarker025">
     </a>
    
    
     
      frameworks:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       MSTest
      
     </strong>
     
      : This is the default
     
     <a id="_idIndexMarker026">
     </a>
     
      testing framework provided by Microsoft for .NET applications.
     
     
      It’s fully integrated into Visual Studio and offers features for writing and running tests within
     
     
      
       the IDE.
      
     
    </li>
    <li>
     <strong class="bold">
      
       NUnit
      
     </strong>
     
      : This is a popular
     
     <a id="_idIndexMarker027">
     </a>
     
      open-source testing framework for .NET applications.
     
     
      It provides a flexible and extensible platform for writing and executing tests and is widely used in the .
     
     
      
       NET community.
      
     
    </li>
    <li>
     <strong class="bold">
      
       xUnit
      
     </strong>
     
      : This is another
     
     <a id="_idIndexMarker028">
     </a>
     
      open-source testing framework for .NET applications.
     
     
      It follows a more modern and flexible approach compared to MSTest and NUnit and is gaining popularity among .
     
     
      
       NET developers.
      
     
    </li>
   </ul>
   <p>
    
     First, you need to create a new project for your test set, in the solution containing the project we want to test.
    
    
     Right-click on your solution and select
    
    <strong class="bold">
     
      Add
     
    </strong>
    
     |
    
    <strong class="bold">
     
      New Project...
     
    </strong>
    
     .
    
    
     This will take you to the
    
    
     
      following screen:
     
    
   </p>
   <div><div><img alt="Figure 1.2 – Adding a new test project" src="img/B22218_01_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.2 – Adding a new test project
    
   </p>
   <p>
    
     I filtered this view by the three top dropdowns to keep displaying the template projects for testing available by default in Visual Studio.
    
    
     You may notice that the last two templates on the list
    
    <a id="_idIndexMarker029">
    </a>
    
     mention
    
    <strong class="bold">
     
      Playwright
     
    </strong>
    
     .
    
    
     Playwright is a library that enables end-to-end
    
    <a id="_idIndexMarker030">
    </a>
    
     testing for
    
    <a id="_idIndexMarker031">
    </a>
    
     modern web apps.
    
    
     With it, you can create unit tests to assess the functionality of your
    
    
     
      user interface.
     
    
   </p>
   <p>
    
     Since xUnit is the most used framework in the industry, we will focus on it for
    
    
     
      our examples.
     
    
   </p>
   <p>
    
     Another way to create your unit test project is by right-clicking directly on your class in your code base and selecting
    
    <strong class="bold">
     
      Create Unit Tests
     
    </strong>
    
     from
    
    
     
      the menu:
     
    
   </p>
   <div><div><img alt="Figure 1.3 – Selecting Create Unit Tests from the menu" src="img/B22218_01_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.3 – Selecting Create Unit Tests from the menu
    
   </p>
   <p>
    
     This action
    
    <a id="_idIndexMarker032">
    </a>
    
     will
    
    <a id="_idIndexMarker033">
    </a>
    
     open a menu that allows you to configure your unit
    
    
     
      test project:
     
    
   </p>
   <div><div><img alt="Figure 1.4 – The Create Unit Tests window" src="img/B22218_01_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.4 – The Create Unit Tests window
    
   </p>
   <p>
    
     By default, this allows you to create an MSTestv2 project, but you can install additional extensions to use other frameworks.
    
    
     If you already have a unit tests project created, you may add your test methods
    
    
     
      to it.
     
    
   </p>
   <p>
    
     Regardless of how
    
    <a id="_idIndexMarker034">
    </a>
    
     you create them, all the tests in this
    
    <a id="_idIndexMarker035">
    </a>
    
     project can be managed in the
    
    <strong class="bold">
     
      Test Explorer
     
    </strong>
    
     view and we will explore it in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-25">
    <a id="_idTextAnchor024">
    </a>
    
     Overview of the Test Explorer view
    
   </h2>
   <p>
    
     Test Explorer serves
    
    <a id="_idIndexMarker036">
    </a>
    
     as a powerful and
    
    <a id="_idIndexMarker037">
    </a>
    
     centralized tool in Visual Studio 2022, facilitating the management and execution of unit tests.
    
    
     This feature-rich window allows developers to seamlessly view, organize, and run their unit tests
    
    <a id="_idIndexMarker038">
    </a>
    
     within the
    
    <strong class="bold">
     
      Integrated Development
     
    </strong>
    
     <strong class="bold">
      
       Environment
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       IDE
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     To access Test Explorer, there are
    
    
     
      two options:
     
    
   </p>
   <ul>
    <li>
     
      You can navigate to the
     
     <strong class="bold">
      
       Test
      
     </strong>
     
      menu in Visual Studio or utilize the convenient keyboard shortcut accessed by pressing
     
     <em class="italic">
      
       Ctrl
      
     </em>
     
      +
     
     <em class="italic">
      
       E
      
     </em>
     
      , releasing them, and then
     
     
      
       pressing
      
     
     
      <em class="italic">
       
        T
       
      </em>
     
     
      
       .
      
     
    </li>
    <li>
     
      Since version 17.6, you can use
     
     <a id="_idIndexMarker039">
     </a>
     
      the
     
     <strong class="bold">
      
       all-in-one search
      
     </strong>
     
      feature to quickly access all the features provided by Visual Studio.
     
     
      Simply open an all-in-one search using the
     
     <em class="italic">
      
       Ctrl
      
     </em>
     
      +
     
     <em class="italic">
      
       Q
      
     </em>
     
      shortcut, type
     
     <strong class="source-inline">
      
       Test Explorer
      
     </strong>
     
      , then press
     
     <em class="italic">
      
       Enter
      
     </em>
     
      , and you’ll be directed to the
     
     <strong class="bold">
      
       Test
      
     </strong>
     
      <strong class="bold">
       
        Explorer
       
      </strong>
     
     
      
       window.
      
     
    </li>
   </ul>
   <p>
    
     Here’s a visualization of the
    
    <strong class="bold">
     
      Test
     
    </strong>
    
     <strong class="bold">
      
       Explorer
      
     </strong>
    
    
     
      window:
     
    
   </p>
   <div><div><img alt="Figure 1.5 – The Test Explorer window" src="img/B22218_01_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.5 – The Test Explorer window
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Test Explorer
     
    </strong>
    
     console
    
    <a id="_idIndexMarker040">
    </a>
    
     provides a
    
    <a id="_idIndexMarker041">
    </a>
    
     clear and organized view of all available tests, making it easy for developers to navigate through their test suites.
    
    
     This interface offers advanced functionality for test management, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Categorize and group tests
      
     </strong>
     
      : Utilize attributes and categories to group tests based on functional areas, features, or specific requirements.
     
     
      This helps in creating a logical hierarchy and makes it easier to focus on specific subsets of tests.
     
     
      By default, tests are grouped based on
     
     <strong class="bold">
      
       Project
      
     </strong>
     
      , followed by
     
     <strong class="bold">
      
       Namespace
      
     </strong>
     
      , and then
     
     <strong class="bold">
      
       Class
      
     </strong>
     
      .
     
     
      If you wish to modify the organization of your tests, simply click on
     
     <a id="_idIndexMarker042">
     </a>
     
      the
     
     <strong class="bold">
      
       Group By
      
     </strong>
     
      button in Test Explorer and choose a new
     
     
      
       grouping
      
     
     
      <a id="_idIndexMarker043">
      </a>
     
     
      
       criterion:
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 1.6 – Test Explorer – Group By" src="img/B22218_01_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.6 – Test Explorer – Group By
    
   </p>
   <p class="list-inset">
    
     Here is the description of the groups you can
    
    
     
      choose from:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Duration
      
     </strong>
     
      : Groups tests by execution time:
     
     <strong class="bold">
      
       Fast
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       Medium
      
     </strong>
     
      ,
     
     
      
       and
      
     
     
      <strong class="bold">
       
        Slow
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       State
      
     </strong>
     
      : Groups tests by execution results:
     
     <strong class="bold">
      
       Failed Tests
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       Skipped Tests
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       Passed Tests
      
     </strong>
     
      , and
     
     
      <strong class="bold">
       
        Not Run
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       Target Framework
      
     </strong>
     
      : Groups tests by the framework their
     
     
      
       projects’ target
      
     
    </li>
    <li>
     <strong class="bold">
      
       Namespace
      
     </strong>
     
      : Groups tests by the
     
     
      
       containing namespace
      
     
    </li>
    <li>
     <strong class="bold">
      
       Project
      
     </strong>
     
      : Groups tests by the
     
     
      
       containing project
      
     
    </li>
    <li>
     <strong class="bold">
      
       Class
      
     </strong>
     
      : Groups tests by the
     
     
      
       containing class
      
     
    </li>
   </ul>
   <ul>
    <li>
     <strong class="bold">
      
       Filtering and searching
      
     </strong>
     
      : With a large code base, locating specific tests can be challenging.
     
     
      Test
     
     <a id="_idIndexMarker044">
     </a>
     
      Explorer offers
     
     <a id="_idIndexMarker045">
     </a>
     
      filtering options and a powerful
     
     
      
       search functionality.
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 1.7 – Test Explorer – applying a search filter" src="img/B22218_01_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.7 – Test Explorer – applying a search filter
    
   </p>
   <p class="list-inset">
    
     You can enter a command in the textbox, such as
    
    <strong class="source-inline">
     
      Namespace:""
     
    </strong>
    
     or any other filter criteria you wish to use for your search.
    
    
     Additionally, you can directly click on the provided command to initiate
    
    
     
      your filtering.
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Creating a playlist
      
     </strong>
     
      : You can create and manage playlists of tests in Visual Studio to organize and run specific sets of tests.
     
     
      To create a playlist, select one or more tests in Test Explorer, right-click, and choose
     
     <strong class="bold">
      
       Add to Playlist
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        New Playlist
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 1.8 – Test Explorer – Add to Playlist" src="img/B22218_01_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.8 – Test Explorer – Add to Playlist
    
   </p>
   <p class="list-inset">
    
     The playlist opens in a new
    
    <strong class="bold">
     
      Test Explorer
     
    </strong>
    
     tab, where you can save it with a name and location.
    
    
     You can edit playlists by adding or removing tests, and you can use the
    
    <strong class="bold">
     
      Edit
     
    </strong>
    
     button to manage tests more conveniently with checkboxes.
    
    
     Playlists can be dynamic, and automatically updated based on the tests included or excluded.
    
    
     They can be saved as XML files and edited manually
    
    
     
      if needed.
     
    
   </p>
   <p>
    
     Now we
    
    <a id="_idIndexMarker046">
    </a>
    
     have had
    
    <a id="_idIndexMarker047">
    </a>
    
     an overview of the
    
    <strong class="bold">
     
      Test Explorer
     
    </strong>
    
     view, let’s explore a preview functionality of Visual Studio 2022 and create a test
    
    
     
      using it.
     
    
   </p>
   <h1 id="_idParaDest-26">
    <a id="_idTextAnchor025">
    </a>
    
     Creating a test with IntelliTest
    
   </h1>
   <p>
    
     In this section, our
    
    <a id="_idIndexMarker048">
    </a>
    
     goal is to explore how to use IntelliTest for creating tests.
    
    
     For that, we will first learn how to enable the IntelliTest functionality.
    
    
     Next, we will learn how to execute it and generate tests with it.
    
    
     At the end of the section, we will learn how to organize our generated unit tests by saving, executing, and
    
    
     
      reviewing them.
     
    
   </p>
   <p>
    
     IntelliTest offers characterization tests, allowing you to understand how code behaves through a suite of traditional unit tests.
    
    
     This suite can serve as a regression suite, aiding in handling the challenges of refactoring legacy or
    
    
     
      unfamiliar code.
     
    
   </p>
   <p>
    
     Through guided test input generation, IntelliTest employs an open-code analysis and constraint-solving approach to automatically produce precise test input values, often without requiring user intervention.
    
    
     It generates factories for complex object types and allows customization of these factories to meet specific requirements.
    
    
     Assertions specified as correctness properties in the code are utilized to further direct test
    
    
     
      input generation.
     
    
   </p>
   <p>
    
     Integrated seamlessly into the Visual Studio IDE, IntelliTest provides a cohesive environment for test suite generation.
    
    
     Information gathered during test suite creation, including automatically generated inputs, code outputs, and generated test cases, as well as their pass or fail statuses, is readily available within Visual Studio.
    
    
     This integration enables easy iteration between code refinement and IntelliTest reruns without leaving the IDE.
    
    
     Test results can be saved as a unit test project within the solution and are automatically recognized by Visual Studio
    
    
     
      Test Explorer.
     
    
   </p>
   <p>
    
     IntelliTest is available
    
    <a id="_idIndexMarker049">
    </a>
    
     in Visual Studio Enterprise Edition.
    
    
     It systematically explores the code base, generating test data and unit tests for each method to ensure comprehensive code coverage and validate code behavior.
    
    
     As of the time of writing, IntelliTest is a preview feature in Visual Studio 17.9, so you must enable it from the
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     menu by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Go to
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Options
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Manage
      
     </strong>
     
      <strong class="bold">
       
        Preview Features
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Check the
     
     <strong class="bold">
      
       IntelliTest support for NetFx and Net6 using Z3 v4
      
     </strong>
     
      option under
     
     
      <strong class="bold">
       
        Preview Features
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.9 – Enable Preview Features – Intellitest" src="img/B22218_01_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.9 – Enable Preview Features – Intellitest
    
   </p>
   <p>
    
     Once enabled, we
    
    <a id="_idIndexMarker050">
    </a>
    
     can explore how IntelliTest works.
    
    
     For example, I’ve created a public class implementing
    
    <strong class="source-inline">
     
      FizzBuzz
     
    </strong>
    
     .
    
    
     To generate tests with IntelliTest for the class, right-click on the class name, find the
    
    <strong class="bold">
     
      IntelliTest (Preview)
     
    </strong>
    
     option, and then select
    
    
     <strong class="bold">
      
       Generate Tests
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 1.10 – IntelliTest – Generate Tests" src="img/B22218_01_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.10 – IntelliTest – Generate Tests
    
   </p>
   <h2 id="_idParaDest-27">
    <a id="_idTextAnchor026">
    </a>
    
     IntelliTest execution and test generation
    
   </h2>
   <p>
    
     IntelliTest executes
    
    <a id="_idIndexMarker051">
    </a>
    
     our code multiple times using various inputs.
    
    
     Each execution is documented in a table, displaying the input test data along with the corresponding output or any exceptions
    
    
     
      that occur.
     
    
   </p>
   <div><div><img alt="Figure 1.11 – Generating tests with IntelliTest" src="img/B22218_01_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.11 – Generating tests with IntelliTest
    
   </p>
   <p>
    
     After test generation, we
    
    <a id="_idIndexMarker052">
    </a>
    
     can access the test project and examine the parameterized unit tests that have
    
    
     
      been generated.
     
    
   </p>
   <h2 id="_idParaDest-28">
    <a id="_idTextAnchor027">
    </a>
    
     Saving, executing, and reviewing unit tests
    
   </h2>
   <p>
    
     We may
    
    <a id="_idIndexMarker053">
    </a>
    
     choose
    
    <a id="_idIndexMarker054">
    </a>
    
     the unit tests we
    
    <a id="_idIndexMarker055">
    </a>
    
     want to keep and use the save option to
    
    
     
      save them.
     
    
   </p>
   <div><div><img alt="Figure 1.12 – IntelliTest’s save option" src="img/B22218_01_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.12 – IntelliTest’s save option
    
   </p>
   <p>
    
     The select box in the top-left corner of the window allows you to filter through all the methods of the class.
    
    
     The individual unit tests, associated with each row, are stored in the
    
    <strong class="source-inline">
     
      .g.cs
     
    </strong>
    
     file within the test project, while the parameterized unit test is stored in its respective
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       cs
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <div><div><img alt="Figure 1.13 – IntelliTest – unit test project" src="img/B22218_01_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.13 – IntelliTest – unit test project
    
   </p>
   <p>
    
     We can execute these unit tests and review the outcomes using Test Explorer, just as we would handle manually created
    
    
     
      unit tests.
     
    
   </p>
   <p>
    
     Similar to classic unit tests, we can generate the project without running IntelliTest first by choosing the option in
    
    
     
      the menu.
     
    
   </p>
   <p>
    
     Using IntelliTest to generate tests from your code base is a valuable tool, especially for legacy
    
    <a id="_idIndexMarker056">
    </a>
    
     projects
    
    <a id="_idIndexMarker057">
    </a>
    
     and non-regression
    
    <a id="_idIndexMarker058">
    </a>
    
     testing.
    
    
     Now, let’s move forward with a real-world example to illustrate how to implement TDD within
    
    
     
      Visual Studio.
     
    
   </p>
   <h1 id="_idParaDest-29">
    <a id="_idTextAnchor028">
    </a>
    
     Practicing TDD with a real-world example
    
   </h1>
   <p>
    
     In TDD, everything
    
    <a id="_idIndexMarker059">
    </a>
    
     begins with the specification and a thorough understanding of the intended functionality.
    
    
     It’s essential to grasp the meaning of what we want to accomplish in order to write effective tests.
    
    
     With that in mind, let’s establish a scenario for
    
    
     
      our example.
     
    
   </p>
   <p>
    
     We’ll create a
    
    <strong class="source-inline">
     
      ValidateMail
     
    </strong>
    
     method that will process email verification.
    
    
     Our goal here is to explore the tools available in Visual Studio to enhance our
    
    
     
      TDD experience.
     
    
   </p>
   <p>
    
     Now that we have outlined our requirements, our next step is to begin by creating our unit test project.
    
    
     For this, we’ll choose xUnit, as discussed earlier in this chapter.
    
    
     We will create an empty Class
    
    
     
      Library Project:
     
    
   </p>
   <ol>
    <li>
     
      We’ll start by writing a test, in our xUnit project, that specifies the behavior or functionality we want
     
     
      
       to implement:
      
     
     <pre class="source-code">
[Fact]
public void ValidateMail_NewUser_ReturnsTrue()
{
    // Arrange
    var user = new User();
    // Act
    bool result =
        user.ValidateMail("john@example.com");
    // Assert
    Assert.True(result);
}</pre>
    </li>
    <li>
     
      The first
     
     <a id="_idIndexMarker060">
     </a>
     
      thing we’ll notice when writing this code is that our test doesn’t compile because the
     
     <strong class="source-inline">
      
       User
      
     </strong>
     
      class doesn’t exist yet in our Class
     
     
      
       Library Project.
      
     
    </li>
    <li>
     
      We’ll leverage the power of IntelliSense to create our class and its method.
     
     
      IntelliSense is an integrated code completion tool within Visual Studio, offering various features such as List Members, Parameter Info, Quick Info, and Complete Word.
     
     
      These functionalities facilitate a deeper understanding of the code being utilized, assist in managing typed parameters, and enable the quick addition of calls to properties and methods with
     
     
      
       minimal keystrokes.
      
     
    </li>
    <li>
     
      Place the cursor on the
     
     <strong class="source-inline">
      
       User()
      
     </strong>
     
      class and expand the IntelliSense menu, selecting the
     
     <strong class="bold">
      
       Generate new type…
      
     </strong>
     
      
       quick action:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.14 – Generate new type..." src="img/B22218_01_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.14 – Generate new type...
    
   </p>
   <ol>
    <li value="5">
     
      This will
     
     <a id="_idIndexMarker061">
     </a>
     
      open a window where we can choose the accessibility (
     
     <strong class="bold">
      
       Default
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       Internal
      
     </strong>
     
      , or
     
     <strong class="bold">
      
       Public
      
     </strong>
     
      ), the kind (
     
     <strong class="bold">
      
       Class
      
     </strong>
     
      or
     
     <strong class="bold">
      
       Struct
      
     </strong>
     
      ), the project, and whether to create a new file or use an existing one.
     
     
      Since we selected our Class Library project, the accessibility of our new class is obviously set
     
     
      
       to
      
     
     
      <strong class="bold">
       
        Public
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.15 – The Generate Type window" src="img/B22218_01_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.15 – The Generate Type window
    
   </p>
   <ol>
    <li value="6">
     
      Now, in
     
     <a id="_idIndexMarker062">
     </a>
     
      the same way, we will use IntelliSense to create our
     
     
      <strong class="source-inline">
       
        ValidateMail()
       
      </strong>
     
     
      
       method:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.16 – Generate method ValidateMail’" src="img/B22218_01_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.16 – Generate method ValidateMail’
    
   </p>
   <ol>
    <li value="7">
     
      With that done, our test is built, but it still fails because we have yet to fix
     
     
      
       its behavior.
      
     
    </li>
   </ol>
   <p>
    
     Here’s our
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     class
    
    <a id="_idIndexMarker063">
    </a>
    
     with the minimum amount of code to make our
    
    
     
      test pass:
     
    
   </p>
   <pre class="source-code">
public class User
{
    public User()
    {
    }
    public bool ValidateMail(string mail)
    {
        return true;
    }
}</pre>
   <p>
    
     Now we have a
    
    <strong class="source-inline">
     
      ValidateMail
     
    </strong>
    
     method returning
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     that should respect the specification of
    
    
     
      our test.
     
    
   </p>
   <p>
    
     You can use the quick access feature, above your method, to run the unit test without going to the
    
    <strong class="bold">
     
      Test
     
    </strong>
    
     <strong class="bold">
      
       Explorer
      
     </strong>
    
    
     
      view.
     
    
   </p>
   <div><div><img alt="Figure 1.17 – Using the quick access tool to run a test" src="img/B22218_01_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.17 – Using the quick access tool to run a test
    
   </p>
   <p>
    
     Here we are; our first test is green.
    
    
     We can write the second testing class that will handle the cases
    
    <a id="_idIndexMarker064">
    </a>
    
     where our
    
    <strong class="source-inline">
     
      ValidateMail()
     
    </strong>
    
     must return
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     .
    
    
     For that, we will use the
    
    <strong class="source-inline">
     
      Theory
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      InlineData
     
    </strong>
    
     
      xUnit attributes:
     
    
   </p>
   <pre class="source-code">
[Theory]
[InlineData("invalidemail")]
[InlineData("invalidemail@")]
[InlineData("invalidemail@example")]
[InlineData("invalidemail@example.")]
[InlineData("invalidemail@.com")]
public void ValidateMail_InvalidEmail_ReturnsFalse(string email)
{
    // Arrange
    var userManager = new User();
    // Act
    bool result = userManager.ValidateMail(email);
    // Assert
    Assert.False(result);
}</pre>
   <p>
    
     We are up for another iteration, from red to green.
    
    
     Here’s the method with the minimum
    
    <a id="_idIndexMarker065">
    </a>
    
     amount of code to make the unit
    
    
     
      test pass:
     
    
   </p>
   <pre class="source-code">
public bool ValidateMail(string email)
{
    if (!email.Contains('@'))
        return false;
    if (email.EndsWith('@'))
        return false;
    if (!email.Contains('.'))
        return false;
    if (email.EndsWith('.'))
        return false;
    if (email.Contains("@."))
        return false;
    return true;
}</pre>
   <p>
    
     Here, we are checking each condition of our test method, with one
    
    <strong class="source-inline">
     
      If
     
    </strong>
    
     for each test to make
    
    
     
      it pass.
     
    
   </p>
   <p>
    
     As you can see, our approach maintains a naïve and simple perspective.
    
    
     Now, it’s time to enter the
    
    <a id="_idIndexMarker066">
    </a>
    
     refactor phase of our TDD process.
    
    
     For that, we will explore a feature of Visual Studio named Live
    
    
     
      Unit Test.
     
    
   </p>
   <h1 id="_idParaDest-30">
    <a id="_idTextAnchor029">
    </a>
    
     Automating your tests with Live Unit Test
    
   </h1>
   <p>
    
     In this section, we
    
    <a id="_idIndexMarker067">
    </a>
    
     will explore the capabilities of automating testing with Live Unit Test.
    
    
     First, we will learn how to configure Live Unit Testing.
    
    
     Then, we will see how to
    
    
     
      launch it
     
    
   </p>
   <p>
    
     Live Unit Testing revolutionizes the testing process by automatically executing unit tests in real-time as you make code changes.
    
    
     This dynamic feature provides developers with the ability to refactor and modify code with increased confidence.
    
    
     By automatically running all affected tests during code editing, Live Unit Testing ensures that any changes made do not
    
    
     
      introduce regressions.
     
    
   </p>
   <p>
    
     Furthermore, Live Unit Testing offers insights into the adequacy of test coverage for your code base.
    
    
     It visually presents code coverage in real-time, allowing developers to quickly identify areas where tests
    
    
     
      are lacking.
     
    
   </p>
   <p>
    
     Let’s activate this feature by navigating to
    
    <strong class="bold">
     
      Test
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Live Unit Testing
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       Start
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 1.18 – Start Live Unit Testing" src="img/B22218_01_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.18 – Start Live Unit Testing
    
   </p>
   <p>
    
     When you launch
    
    <a id="_idIndexMarker068">
    </a>
    
     Live Unit Testing for the first time, the configuration window will
    
    
     
      open up:
     
    
   </p>
   <div><div><img alt="Figure 1.19 – Configure Live Unit Testing" src="img/B22218_01_19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.19 – Configure Live Unit Testing
    
   </p>
   <h2 id="_idParaDest-31">
    <a id="_idTextAnchor030">
    </a>
    
     Configuring Live Unit Testing
    
   </h2>
   <p>
    
     When Live Unit Testing is
    
    <a id="_idIndexMarker069">
    </a>
    
     deactivated, you can access the setup wizard by navigating to
    
    <strong class="bold">
     
      Test
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Live Unit Testing
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Configure Live
     
    </strong>
    
     <strong class="bold">
      
       Unit Testing
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     During a Live Unit Testing operation, a workspace — a duplicate of the original repository — is established.
    
    
     Any modifications made in Visual Studio that are not yet saved are integrated into this workspace.
    
    
     Subsequently, Live Unit Testing initiates a build, conducts a test run, and furnishes the latest code
    
    
     
      coverage report.
     
    
   </p>
   <p>
    
     The initial setup in the wizard should address file copying origins
    
    
     
      and destinations.
     
    
   </p>
   <p>
    
     Let’s understand more about the settings in
    
    
     
      this wizard:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Repository root
      
     </strong>
     
      : This is the main folder that contains all the necessary files for Live Unit Testing.
     
     
      It should include all the source code, binaries, and tools required for testing.
     
     
      If the solution file is not located within this root folder, adjustments may need to be made to ensure
     
     
      
       proper setup.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Workspace folder
      
     </strong>
     
      : This (set, by default, to
     
     <strong class="bold">
      
       lut
      
     </strong>
     
      for Live Unit Testing) is where Live Unit Testing stores a copy of the repository.
     
     
      By default, this root is created in the user’s home folder, but it can be customized based on preference or
     
     
      
       specific requirements.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Excluded files
      
     </strong>
     
      : Exclude generated artifacts from being copied to the Live Unit Testing workspace to prevent interference with
     
     
      
       regular builds.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Build options
      
     </strong>
     
      : By default, Live Unit Testing utilizes multiple CPU cores for
     
     
      
       faster builds.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Test case timeout
      
     </strong>
     
      : This allows setting a specific time duration, after which tests are automatically aborted if they exceed the
     
     
      
       allotted time.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Use multiple processors
      
     </strong>
     
      : By default, Live Unit Testing attempts to utilize multiple processors for faster test execution.
     
     
      However, deselect this option if your machine
     
     <a id="_idIndexMarker070">
     </a>
     
      experiences slowdowns or if parallel test execution causes issues, such as
     
     
      
       file conflicts.
      
     
    </li>
   </ul>
   <p>
    
     If we select
    
    <strong class="bold">
     
      &lt;custom&gt;
     
    </strong>
    
     for the
    
    <strong class="bold">
     
      Excluded
     
    </strong>
    
     files, we can define our own rules.
    
    
     The setup wizard will bring us to the
    
    <strong class="bold">
     
      lutignore
     
    </strong>
    
     file editor without default values
    
    
     
      filled in.
     
    
   </p>
   <div><div><img alt="Figure 1.20 – Configure lutignore file" src="img/B22218_01_20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.20 – Configure lutignore file
    
   </p>
   <p>
    
     Let’s get an
    
    <a id="_idIndexMarker071">
    </a>
    
     overview of the
    
    <strong class="source-inline">
     
      lutignore
     
    </strong>
    
     file structure according to the
    
    
     
      Microsoft documentation.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      lutignore
     
    </strong>
    
     file follows the same format as a
    
    <strong class="source-inline">
     
      gitignore
     
    </strong>
    
     file.
    
    
     It should include rules that correspond to folders or files created during the build process, ensuring they are not copied into the workspace for Live Unit Testing.
    
    
     For most default project templates, the provided
    
    <strong class="source-inline">
     
      lutignore
     
    </strong>
    
     file
    
    
     
      is adequate:
     
    
   </p>
   <pre class="source-code">
[BB]IN
[OO]BJ</pre>
   <p>
    
     These rules prevent the copying of any
    
    <strong class="source-inline">
     
      BIN
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      OBJ
     
    </strong>
    
     folders to the Live Unit
    
    
     
      Testing workspace.
     
    
   </p>
   <p>
    
     If your repository has a single build folder, specify that folder in the
    
    
     <strong class="source-inline">
      
       ignore
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
[AA]RTIFACTS/</pre>
   <p>
    
     This rule ensures that the
    
    <strong class="source-inline">
     
      ARTIFACTS
     
    </strong>
    
     folder is not copied to the Live Unit
    
    
     
      Testing workspace.
     
    
   </p>
   <p>
    
     In cases where your repository contains additional tools within the build folder, those tools should also be excluded using
    
    
     
      matching patterns:
     
    
   </p>
   <pre class="source-code">
[AA]RTIFACTS/
![AA]RTIFACTS/TOOLS/</pre>
   <p>
    
     The first rule excludes the
    
    <strong class="source-inline">
     
      ARTIFACTS
     
    </strong>
    
     folder.
    
    
     The second ensures that the
    
    <strong class="source-inline">
     
      TOOLS
     
    </strong>
    
     subfolder
    
    <a id="_idIndexMarker072">
    </a>
    
     within
    
    <strong class="source-inline">
     
      ARTIFACTS
     
    </strong>
    
     is copied, which may contain necessary tools
    
    
     
      and utilities.
     
    
   </p>
   <h2 id="_idParaDest-32">
    <a id="_idTextAnchor031">
    </a>
    
     Launching Live Unit Testing
    
   </h2>
   <p>
    
     Now that we
    
    <a id="_idIndexMarker073">
    </a>
    
     have configured Live Unit Testing, it is open and awaiting a playlist of tests
    
    
     
      to run.
     
    
   </p>
   <div><div><img alt="Figure 1.21 – Live Unit Testing console" src="img/B22218_01_21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.21 – Live Unit Testing console
    
   </p>
   <p>
    
     Use the pen icon to add your set of tests.
    
    
     Alternatively, you can add all your tests by clicking on the link at the bottom of
    
    
     
      the message.
     
    
   </p>
   <p>
    
     Returning to our previous example and our
    
    <strong class="source-inline">
     
      ValidateMail()
     
    </strong>
    
     function, you can see green checkmarks on the left side of our code lines.
    
    
     These indicate that the code is covered by passing
    
    
     
      unit tests.
     
    
   </p>
   <div><div><img alt="Figure 1.22 – Live Unit Testing checkmarks" src="img/B22218_01_22.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.22 – Live Unit Testing checkmarks
    
   </p>
   <p>
    
     Now, we can proceed to the refactoring step of our
    
    
     
      TDD iteration.
     
    
   </p>
   <p>
    
     First, we will
    
    <a id="_idIndexMarker074">
    </a>
    
     concatenate all the conditions and intentionally let the
    
    
     
      tests fail:
     
    
   </p>
   <pre class="source-code">
        public bool ValidateMail(string email)
        {
            return !email.Contains('@') &amp;&amp;
                email.EndsWith('@') &amp;&amp;
                !email.Contains('.') &amp;&amp;
                email.EndsWith('.') &amp;&amp;
                email.Contains("@.");
        }</pre>
   <p>
    
     When we update the document, Live Unit Testing automatically rebuilds and updates the test status indicators, changing checkmarks to
    
    
     
      red crosses.
     
    
   </p>
   <div><div><img alt="Figure 1.23 – Live unit test red crosses" src="img/B22218_01_23.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.23 – Live unit test red crosses
    
   </p>
   <p>
    
     Now, we can fix our code and the checkmarks will
    
    
     
      appear automatically.
     
    
   </p>
   <p>
    
     In our case, the process is very smooth, but in a larger code base with more unit tests, they may not have finished running while we have already made changes to the code.
    
    
     For this issue, you
    
    <a id="_idIndexMarker075">
    </a>
    
     have an option in the top-level menu of Visual Studio:
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Live Unit Testing
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       General
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 1.24 – Additional configuration – Live Unit Testing" src="img/B22218_01_24.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.24 – Additional configuration – Live Unit Testing
    
   </p>
   <p>
    
     Thanks to this window, you can customize your Live Unit Testing experience according to
    
    
     
      your needs.
     
    
   </p>
   <p>
    
     We can see that Live Unit Testing offers a quick visualization of our code coverage.
    
    
     You can access a deeper analysis of the coverage of your code base in Visual Studio by navigating to the
    
    <strong class="bold">
     
      Test
     
    </strong>
    
     menu and selecting
    
    <strong class="bold">
     
      Analyze Code Coverage for All Tests
     
    </strong>
    
     .
    
    
     For more
    
    <a id="_idIndexMarker076">
    </a>
    
     information, you can consult the Microsoft documentation
    
    
     
      at
     
    
    <a href="https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&amp;tabs=csharp">
     
      
       https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&amp;tabs=csharp
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-33">
    <a id="_idTextAnchor032">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we covered the importance of unit testing as a non-regression or development process.
    
    
     We began with a reminder of good unit testing practices and TDD before exploring the functionalities offered by Visual Studio 2022 to enhance
    
    
     
      our productivity.
     
    
   </p>
   <p>
    
     We provided an overview of the
    
    <strong class="bold">
     
      Test Explorer
     
    </strong>
    
     view, demonstrating how to manage and organize unit tests.
    
    
     Then, we delved into the new IntelliSense feature, which provides tools to easily add non-regression tests to legacy code bases with minimal effort, freeing our minds for future refactoring.
    
    
     Finally, we learned how to leverage IntelliSense tools and Live Unit Testing to facilitate our
    
    
     
      TDD experience.
     
    
   </p>
   <p>
    
     In the next chapter, we will dive deeper into the world of debugging and explore all that Visual Studio 2022 offers for
    
    
     
      advanced strategies.
     
    
   </p>
  </div>
 </body></html>