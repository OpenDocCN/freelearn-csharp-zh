- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Dates, Times, and Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about some of the common types that are included with .NET.
    These include types to manipulate dates and times and implement internationalization,
    which includes globalization and localization.
  prefs: []
  type: TYPE_NORMAL
- en: When writing code to handle times, it is especially important to consider time
    zones. Bugs are often introduced because two times are compared in different time
    zones without taking that into account. It is important to understand the concept
    of **Coordinated Universal Time** (**UTC**) and to convert time values into UTC
    before performing time manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: You should also be aware of any **Daylight Saving Time** (**DST**) adjustments
    that might be needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with dates and times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with cultures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Noda Time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After numbers and text, the next most popular types of data to work with are
    dates and times. The two main types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DateTime`: Represents a combined date and time value for a fixed point in
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeSpan`: Represents a duration of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two types are often used together. For example, if you subtract one `DateTime`
    value from another, the result is a `TimeSpan`. If you add a `TimeSpan` to a `DateTime`,
    then the result is a `DateTime` value.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying date and time values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common way to create a date and time value is to specify individual values
    for the date and time components, like day and hour, as described in *Table 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Date/time parameter** | **Value range** |'
  prefs: []
  type: TYPE_TB
- en: '| `year` | 1 to 9,999 |'
  prefs: []
  type: TYPE_TB
- en: '| `month` | 1 to 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `day` | 1 to the number of days in that month |'
  prefs: []
  type: TYPE_TB
- en: '| `hour` | 0 to 23 |'
  prefs: []
  type: TYPE_TB
- en: '| `minute` | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: '| `second` | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: '| `millisecond` | 0 to 999 |'
  prefs: []
  type: TYPE_TB
- en: '| `microsecond` | 0 to 999 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Parameters for formatting date and time values'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to instantiate a `DateTime` that represents when .NET 9 might
    be released for **General Availability**, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: The preceding code example might make you think, “What time
    zone does the value represent?” This is the big problem with `DateTime` and why
    it is good practice to avoid it in favor of `DateTimeOffset`, which stores the
    time zone too. We will look at this issue in more detail later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to provide the value as a `string` to be parsed, but this
    can be misinterpreted depending on the default culture of the thread. For example,
    in the UK, dates are specified as day/month/year, whereas in the US, dates are
    specified as month/day/year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what you might want to do with dates and times:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithTime`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter07`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publish**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the project file, treat warnings as errors, and add an element to statically
    and globally import the `System.Console` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class file named `Program.Helpers.cs` and replace its contents, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    initialize some special date/time values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The date and time formats output are determined by the culture settings of your
    console app. We called the `ConfigureConsole` method to make sure we all see the
    same default output in US English.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, at the top of the statement that calls `ConfigureConsole`,
    set the parameter to not override your local computer’s culture, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code, and note the output is localized to your computer’s culture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, set the parameter to specify alternative languages, like French
    in Canada (`fr-CA`) or English in Great Britain (`en-GB`), as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: There is a table of common culture codes at the following
    link: [https://en.wikipedia.org/wiki/Language_localisation#Language_tags_and_codes](https://en.wikipedia.org/wiki/Language_localisation#Language_tags_and_codes)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the code, and note that the output is localized to the specified culture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reset the console configuration back to the default so that it uses US English
    culture, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Formatting date and time values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have just seen that dates and times have default formats based on the current
    culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take complete control of date and time formatting using custom format
    code, as shown in *Table 7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Date part separator. Varies by culture; for example, `en-US` uses `/`,
    but `fr-FR` uses `-` (dash). |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | Escape character. Useful if you want to use a special format code as
    a literal character; for example, `h \h m \m` would format a time of 9:30 am as
    `9 h 30 m`. |'
  prefs: []
  type: TYPE_TB
- en: '| `:` | Time part separator. Varies by culture; for example, `en-US` uses `:`,
    but `fr-FR` uses `.` (dot). |'
  prefs: []
  type: TYPE_TB
- en: '| `d`, `dd` | The day of the month, from `1` to `31`, or with a leading zero
    from `01` through `31`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ddd, dddd` | The abbreviated or full name of the day of the week, for example,
    `Mon` or `Monday`, localized for the current culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `f`, `ff`, `fff` | The tenths of a second, hundredths of a second, or milliseconds.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | The period or era, for example, `A.D.` |'
  prefs: []
  type: TYPE_TB
- en: '| `h`, `hh` | The hour, using a 12-hour clock from `1` to `12`, or from `01`
    to `12`. |'
  prefs: []
  type: TYPE_TB
- en: '| `H`, `HH` | The hour, using a 24-hour clock from `0` to `23`, or from `01`
    to `23`. |'
  prefs: []
  type: TYPE_TB
- en: '| `K` | Time zone information. `null` for an unspecified time zone, `Z` for
    UTC, and a value like `-8:00` for local time adjusted from UTC. |'
  prefs: []
  type: TYPE_TB
- en: '| `m`, `mm` | The minute, from `0` through `59`, or with a leading zero from
    `00` through `59`. |'
  prefs: []
  type: TYPE_TB
- en: '| `M`, `MM` | The month, from `1` through `12`, or with a leading zero from
    `01` through `12`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MMM`, `MMMM` | The abbreviated or full name of the month, for example, `Jan`
    or `January`, localized for the current culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `s`, `ss` | The second, from `0` through `59`, or with a leading zero from
    `00` through `59`. |'
  prefs: []
  type: TYPE_TB
- en: '| `t`, `tt` | The first or both characters of the AM/PM designator. |'
  prefs: []
  type: TYPE_TB
- en: '| `y`, `yy` | The year of the current century, from `0` through `99`, or with
    a leading zero from `00` through `99`. |'
  prefs: []
  type: TYPE_TB
- en: '| `yyy` | The year with a minimum of three digits, and as many as needed. For
    example, 1 A.D. is `001`. The first sacking of Rome was in `410`. The year this
    book was published is `2023`. |'
  prefs: []
  type: TYPE_TB
- en: '| `yyyy`, `yyyyy` | The year as a four- or five-digit number. |'
  prefs: []
  type: TYPE_TB
- en: '| `z`, `zz` | Hours offset from UTC, with no leading zeros, or with leading
    zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| `zzz` | Hours and minutes offset from UTC, with a leading zero, for example,
    `+04:30`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.2: Custom format code for date and time values'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: A full list of custom format code can be found at the
    following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply standard date and time formatting using simpler format code,
    like the `d` and `D` we used in the code example, as shown in *Table 7.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Short date pattern. Varies by culture; for example, `en-US` uses `M/d/yyyy`
    and `fr-FR` uses `dd/MM/yyyy`. |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Long date pattern. Varies by culture; for example, `en-US` uses `mmmm,
    MMMM d, yyyy` and `fr-FR` uses `mmmm, dd MMMM yyyy`. |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | Full date/time pattern (short time – hours and minutes). Varies by
    culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | Full date/time pattern (long time – hours, minutes, seconds, and AM/PM).
    Varies by culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `o, O` | A standardized pattern, suitable to serialize date/time values for
    roundtrips, for example, `2023-05-30T13:45:30.0000000-08:00`. |'
  prefs: []
  type: TYPE_TB
- en: '| `r`, `R` | RFC1123 pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | Short time pattern. Varies by culture; for example, `en-US` uses `h:mm
    tt` and `fr-FR` uses `HH:mm`. |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | Long time pattern. Varies by culture; for example, `en-US` uses `h:mm:ss
    tt` and `fr-FR` uses `HH:mm:ss`. |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | Universal sortable date/time pattern, for example, `2009-06-15 13:45:30Z`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | Universal full date/time pattern. Varies by culture; for example, `en-US`
    might be `Monday, June 15, 2009 8:45:30 PM`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.3: Standard format code for date and time values'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: A full list of format code can be found at the following
    link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to define Christmas Day in 2024 and display
    it in various ways, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Disable overriding your computer culture or pass a specific culture code, like
    French in France, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code, and note that the results should be localized to that culture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the console configuration back to the default of US English.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Date and time calculations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s try performing simple calculations on date and time values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to perform addition and subtraction with Christmas
    2024, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to define the time on Christmas Day that your children (or dog
    or cat or iguana?) might wake up to open presents, and display it in various ways,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Microseconds and nanoseconds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In earlier versions of .NET, the smallest unit of time measurement was a tick.
    A tick is 100 nanoseconds, so developers used to have to do the calculation for
    nanoseconds themselves. .NET 7 introduced millisecond and microsecond parameters
    to constructors, and microsecond and nanosecond properties to the `DateTime`,
    `DateTimeOffset`, `TimeSpan`, and `TimeOnly` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to construct a date and time value with more
    precision than was possible and to display its value, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Globalization with dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current culture controls how dates and times are formatted and parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace to work with globalization,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to show the current culture that is used to display date and
    time values, and then parse the United States’ Independence Day and display it
    in various ways, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Although you can create a `CultureInfo` instance using its
    constructor, unless you need to make changes to it, you should get a read-only
    shared instance by calling the `GetCultureInfo` method.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, set the culture to British English, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the current culture is *English (Great Britain)*, if a date is given as
    4 July 2024, then it is correctly parsed regardless of whether the current culture
    is British or American. But if the date is given as `7/4/2024`, then it is parsed
    as 7 April. You can override the current culture by specifying the correct culture
    as a provider when parsing, as shown in the third example above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements to loop from the year 2023 to 2028, displaying if the year is
    a leap year and how many days there are in February, and then showing if Christmas
    and Independence Day are during DST, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Complexities of Daylight Saving Time (DST)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DST is not used in all countries; it is also determined by hemisphere, and politics
    plays a role. For example, the United States is currently debating whether it
    should make DST permanent. They might decide to leave the decision up to individual
    states. It could all get extra confusing for Americans over the next few years.
  prefs: []
  type: TYPE_NORMAL
- en: Each country has its own rules for what day and what hour DST happens. These
    rules are encoded by .NET so that it can adjust automatically when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the US in springtime, the clocks “spring” forward one hour at 2 AM. In the
    fall, they “fall” back one hour at 2 AM. Wikipedia explains this at the following
    link: [https://en.wikipedia.org/wiki/Daylight_saving_time_in_the_United_States](https://en.wikipedia.org/wiki/Daylight_saving_time_in_the_United_States)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the UK in springtime, the clocks spring forward one hour at 1 AM. In the
    autumn, they fall back one hour at 2 AM. The UK government explains this at the
    following link: [https://www.gov.uk/when-do-the-clocks-change](https://www.gov.uk/when-do-the-clocks-change)'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you need to set an alarm to wake you up at 1:30 AM to catch a flight
    from Heathrow airport in the UK. Your flight happens to depart on the day that
    DST takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: In the UK spring, the clocks are at 12:59 AM, and then the next minute they
    spring forward to 2:00AM. 1:30 AM never happens, your alarm does not go off, and
    you miss your flight! 1:30 AM is an invalid time in .NET, and if you try to store
    that value in a variable, it will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: In the UK autumn, the clocks are at 1:59, and then the next minute, they fall
    back to 1:00 and repeat that hour. In this case, 1:30 AM happens twice.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing the DayOfWeek enum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DayOfWeek` is an `enum`, so it cannot be localized as you might expect or
    hope. Its `string` values are hardcoded in English, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are two solutions to this problem. First, you could apply the `dddd` date
    format code to a whole date value. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Second, you can use a helper method of the `DateTimeFormatInfo` class to convert
    a `DayOfWeek` value into a localized `string` for output as text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of the problem and solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to explicitly set the current culture to Danish,
    and then output the current day of the week in that culture, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with only a date or a time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 6 introduced some new types to work with only a date value or only a time
    value, named `DateOnly` and `TimeOnly`.
  prefs: []
  type: TYPE_NORMAL
- en: These are better than using a `DateTime` value with a zero time to store a date-only
    value because it is type-safe and avoids misuse. `DateOnly` also maps better to
    database column types, for example, a `date` column in SQL Server. `TimeOnly`
    is good for setting alarms and scheduling regular meetings or the opening hours
    for an organization, and it maps to a `time` column in SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use them to plan a release party for .NET 9, probably on Tuesday, November
    12, 2024, one week after the US presidential election:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to define the .NET 9 release party and a time
    for it to start, and then combine the two values to make a calendar entry so that
    we don’t miss it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting date/time formatting information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each culture has its own date/time formatting rules. These are defined in the
    `DateTimeFormat` property of a `CultureInfo` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s output some commonly used information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to get the date/time formatting information
    for the current culture and output some of its most useful properties, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the culture to something else, run the code, and note the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit testing with a time provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing unit tests for components that need the current time is tricky because
    the time is constantly changing!
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want visitors to your e-commerce website to get a 20% discount if
    they make an order at the weekend. During workdays, they pay full price. How can
    we test this functionality?
  prefs: []
  type: TYPE_NORMAL
- en: To control the time used in unit tests, .NET 8 introduces the `TimeProvider`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start defining a function to perform this calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chapter07` solution, add a new **Class Library**/`classlib` project
    named `TimeFunctionsLib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `TimeFunctionsLib` project, rename `Class1.cs` to `DiscountService.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `DiscountService.cs`, define a function to perform the calculation, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Chapter07` solution, add a new **xUnit Test Project**/`xunit` project
    named `TestingWithTimeProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `TestingWithTimeProvider` project, add a reference to the `TimeFunctionsLib`
    project, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `TestingWithTimeProvider` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `TestingWithTimeProvider` project, rename `Test1.cs` to `TimeTests.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `TimeTests.cs`, modify the statements to import the namespace for the discount
    service, and then define two tests, one for workdays and one for weekends, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the two tests, and note that only one can ever succeed at any one time.
    If you run the tests during workdays, the weekend test will fail. If you run the
    tests during the weekend, the workday test will fail!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you’ve seen the problem, how can we solve it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The way Microsoft solves it is by each team that creates .NET libraries defining
    its own internal `ISystemClock` interface with, at a minimum, a property named
    `UtcNow`, and sometimes other members, along with implementations that typically
    use the built-in system clock but are all slightly different. A typical example
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, with .NET 8, the core .NET team has introduced a proper equivalent
    of the preceding code with an implementation that uses the system clock. Unfortunately,
    they do not define an interface. Instead, they define an abstract class named
    `TimeProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TimeFunctionsLib` project, in `DiscountService.cs`, comment out the
    use of the `UtcNow` property, and add a statement to add a constructor-injected
    service, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TestingWithTimeProvider` project, in `TimeTests.cs`, add statements
    to both tests to show how we could use the new `TimeProvider` and its `System`
    property (which would still have a dependency on the system clock!), as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TestingWithTimeProvider` project, add a reference to `Moq`, a package
    to mock dependencies, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moq 4.18.4 was the last version released before a controversy erupted when
    the developer added obfuscated code that executed during builds. You can read
    more about this at the following link: [https://github.com/devlooped/moq/issues/1370](https://github.com/devlooped/moq/issues/1370).
    I plan to keep an eye on the situation over the next few months and then decide
    whether I should switch to an alternative.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `TimeTests.cs`, import the namespace to use the `Mock.Of<T>` extension method,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TestDiscountDuringWorkdays` method, comment out the statement that
    used the `System` provider, and replace it with statements to mock a time provider
    that always returns a fixed date and time during workdays, as highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TestDiscountDuringWeekends` method, comment out the statement that
    used the `System` provider and replace it with statements to mock a time provider
    that always returns a fixed date and time at the weekend, as highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the unit tests, and note that they both succeed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the code example about the .NET release party, using a `TimeOnly` was not
    actually a good idea because the `TimeOnly` value did not include information
    about the time zone. It is only useful if you are in the correct time zone. `TimeOnly`
    is, therefore, a poor choice for an event. For events, we need to understand and
    handle time zones.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DateTime and TimeZoneInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DateTime` class has many useful members related to time zones, as shown
    in *Table 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Now` property | A `DateTime` value that represents the current date and
    time in the local time zone. |'
  prefs: []
  type: TYPE_TB
- en: '| `UtcNow` property | A `DateTime` value that represents the current date and
    time in the UTC time zone. |'
  prefs: []
  type: TYPE_TB
- en: '| `Kind` property | A `DateTimeKind` value that indicates whether the `DateTime`
    value is `Unspecified`, `Utc`, or `Local`. |'
  prefs: []
  type: TYPE_TB
- en: '| `IsDaylightSavingTime` method | A `bool` that indicates if the `DateTime`
    value is during DST. |'
  prefs: []
  type: TYPE_TB
- en: '| `ToLocalTime` method | Converts a UTC `DateTime` value to the equivalent
    local time. |'
  prefs: []
  type: TYPE_TB
- en: '| `ToUniversalTime` method | Converts a local `DateTime` value to the equivalent
    UTC time. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.4: DateTime members related to time zones'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TimeZoneInfo` class has many useful members, as shown in *Table 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Id` property | A `string` that uniquely identifies the time zone. |'
  prefs: []
  type: TYPE_TB
- en: '| `Local` property | A `TimeZoneInfo` value that represents the current local
    time zone. Varies depending on where the code executes. |'
  prefs: []
  type: TYPE_TB
- en: '| `Utc` property | A `TimeZoneInfo` value that represents the UTC time zone.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `StandardName` property | A `string` for the name of the time zone when Daylight
    Saving is not active. |'
  prefs: []
  type: TYPE_TB
- en: '| `DaylightName` property | A `string` for the name of the time zone when Daylight
    Saving is active. |'
  prefs: []
  type: TYPE_TB
- en: '| `DisplayName` property | A `string` for the general name of the time zone.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BaseUtcOffset` property | A `TimeSpan` that represents the difference between
    this time zone and the UTC time zone, ignoring any potential Daylight Saving adjustments.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SupportsDaylightSavingTime` property | A `bool` that indicates whether this
    time zone has Daylight Saving adjustments. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConvertTime` method | Converts a `DateTime` value to another `DateTime`
    value in a different time zone. You can specify the source and destination time
    zones. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConvertTimeFromUtc` method | Converts a `DateTime` value in the UTC time
    zone to a `DateTime` value in a specified time zone. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConvertTimeToUtc` method | Converts a `DateTime` value in a specified time
    zone to a `DateTime` value in the UTC time zone. |'
  prefs: []
  type: TYPE_TB
- en: '| `IsDaylightSavingTime` method | Returns a `bool`, indicating whether the
    `DateTime` value is in Daylight Saving. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetSystemTimeZones` method | Returns a collection of time zones registered
    with the operating system. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.5: TimeZoneInfo useful members'
  prefs: []
  type: TYPE_NORMAL
- en: Some database providers for EF Core only allow you to store `DateTime` values
    that use the `Kind` property to determine whether it is UTC, so you might need
    to convert to and from `DateTimeOffset` if you need to work with these values.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring DateTime and TimeZoneInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `TimeZoneInfo` class to work with time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithTimeZones` to the `Chapter07` solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio 2022, set **Startup Project** to **Current selection**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Treat warnings as errors, and statically and globally import the `System.Console`
    class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents to define some helper methods to output a section title
    in a visually different way, output a list of all time zones in the current system,
    and output details about a `DateTime` or `TimeZoneInfo` object, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements. Add statements to output the
    current date and time in the local and UTC time zones, and then output details
    about the local and UTC time zones, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, including the time zones registered
    on your operating system (there are 141 on my Windows 11 laptop), and that it
    is currently 4:17 PM on 31 May 2022 in England, meaning I am in the GMT Standard
    Time zone. However, because DST is active, it is currently known as GMT Summer
    Time, which is one hour ahead of UTC, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BaseUtcOffset` of the **GMT Standard Time** zone is zero because normally
    Daylight Saving is not active. That is why it is prefixed with `Base`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to prompt the user to enter a time zone (using
    Eastern Standard Time as a default), get that time zone, output details about
    it, and then compare a time entered by the user with the equivalent time in the
    other time zone, and catch potential exceptions, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, press *Enter* for US East Coast, then enter `12:30pm`
    for the local time, and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: My local time zone is GMT Standard Time, so there is currently a five-hour time
    difference between me and the US East Coast. Your local time zone will be different.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app, copy one of the time zones to the clipboard, paste it
    at the prompt, and then press *Enter* for the local time. Note the results, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sydney, Australia, is currently nine hours ahead, so at about 5 PM for me, it
    is about 2 AM on the following day for them.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a lot to learn about dates, times, and time zones. But we aren’t done
    yet. Now, we need to look at the wider topic of cultures, which are a combination
    of language and region and do not just affect date and time formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cultures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internationalization is the process of enabling your code to correctly run all
    over the world. It has two parts, **globalization** and **localization**, and
    both of them are about working with cultures.
  prefs: []
  type: TYPE_NORMAL
- en: Globalization is about writing your code to accommodate multiple languages and
    region combinations. The combination of a language and a region is known as a
    culture. It is important for your code to know both the language and region because,
    for example, the date and currency formats are different in Quebec and Paris,
    despite them both using the French language.
  prefs: []
  type: TYPE_NORMAL
- en: There are **International Organization for Standardization** (**ISO**) codes
    for all culture combinations. For example, in the code `da-DK`, `da` indicates
    the Danish language and `DK` indicates the Denmark region, and in the code `fr-CA`,
    `fr` indicates the French language and `CA` indicates the Canada region.
  prefs: []
  type: TYPE_NORMAL
- en: 'ISO is not just an acronym. ISO is a reference to the Greek word *isos* (which
    means *equal*). You can see a list of ISO culture codes at the following link:
    [https://lonewolfonline.net/list-net-culture-country-codes/](https://lonewolfonline.net/list-net-culture-country-codes/).'
  prefs: []
  type: TYPE_NORMAL
- en: Localization is about customizing the user interface to support a language,
    for example, changing the label of a button to **Close** (`en`) or **Fermer**
    (`fr`). Since localization is more about the language, it doesn’t always need
    to know about the region, although, ironically enough, the words *standardization*
    (`en-US`) and *standardisation* (`en-GB`) suggest otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: I am not a professional translator of software user interfaces,
    so take all examples in this chapter as general guidance. My research into French
    user interface labeling common practice led me to the following links, but it
    would be best to hire a professional if you are not a native language speaker:
    [https://french.stackexchange.com/questions/12969/translation-of-it-terms-like-close-next-search-etc](https://french.stackexchange.com/questions/12969/translation-of-it-terms-like-close-next-search-etc)
    and [https://www.linguee.com/english-french/translation/close+button.html](https://www.linguee.com/english-french/translation/close+button.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and changing the current culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internationalization is a huge topic on which thousand-page books have been
    written. In this section, you will get a brief introduction to the basics, using
    the `CultureInfo` and `RegionInfo` types in the `System.Globalization` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithCultures` to the `Chapter07` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the project file, treat warnings as errors, and then statically and globally
    import the `System.Console` class, and globally import the `System.Globalization`
    namespace so that we can use the `CultureInfo` class, as shown in the following
    markup:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new class file named `Program.Helpers.cs`, and modify its contents to
    add a method to the partial `Program` class that will output information about
    the cultures used for globalization and localization, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, and add statements to set
    the output encoding of the console to support Unicode. Then, output information
    about the globalization and localization cultures. Finally, prompt the user to
    enter a new culture code and show how that affects the formatting of common values,
    such as dates and currency, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run an application, it automatically sets its thread to use the culture
    of the operating system. I am running my code in London, UK, so the thread is
    set to English (Great Britain).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code prompts the user to enter an alternative ISO code. This allows your
    applications to replace the default culture at runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application then uses standard format codes to output the day of the week
    using format code `dddd`, the number of minutes with thousand separators using
    format code `N0`, and the salary with the currency symbol. These adapt automatically,
    based on the thread’s culture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and enter `en-US` for the ISO code (or press *Enter*), and then
    enter some sample data, including a date in a format valid for US English, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again, and try Danish in Denmark (`da-DK`), as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, only the date and salary are globalized into Danish. The rest
    of the text is hardcoded as English. Later, we will translate that English text
    into other languages. For now, let’s see some other differences between cultures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code again, and try Polish in Poland (`pl-PL`). Note that the grammar
    rules in Polish make the day number possessive for the month name, so the month
    `styczeń` becomes `stycznia`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again, and try Persian in Iran (`fa-IR`). Note that dates in Iran
    must be specified as year/month/day, and that this year (2023) is the year 1401
    in the Persian calendar, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although I tried to confirm with a Persian reader whether this example is correct,
    due to factors like right-to-left languages being tricky to work with in console
    apps and copying and pasting from a console window into a word processor, I apologize
    in advance to my Persian readers if this example is all messed up!
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily using the invariant culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you might need to temporarily use a different culture without switching
    the current thread to that culture. For example, when automatically generating
    documents, queries, and commands that include data values, you might need to ignore
    your current culture and use a more standardized culture. For this purpose, you
    can use the invariant culture, which is based on US English.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might need to generate a JSON document with a decimal number
    value and format the number with two decimal places, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to execute this on a Slovenian computer, you would get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you then tried to insert this JSON document into a cloud database, it would
    fail because it would not understand the number format that uses commas for decimals
    and dots for groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'So you can override the current culture and specify the invariant culture only
    when outputting the number as a `string` value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to execute this on a Slovenian (or any other culture) computer,
    you would now get the following output, which would be successfully recognized
    by a cloud database and not throw exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s see how to translate text from one language to another so that the
    label prompts are in the correct language for the current culture.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing your user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A localized application is divided into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An assembly containing code that is the same for all locales and contains resources
    for when no other resource file is found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more assemblies that contain the user interface resources, which are
    different for different locales. These are known as **satellite assemblies**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This model allows the initial application to be deployed with default invariant
    resources, and over time, additional satellite assemblies can be deployed as the
    resources are translated. In the coding task, you will create a console app with
    embedded invariant culture, and satellite assemblies for Danish, French, French-Canadian,
    Polish, and Iranian (Persian). To add more cultures in the future, just follow
    the same steps.
  prefs: []
  type: TYPE_NORMAL
- en: User interface resources include any text for messages, logs, dialog boxes,
    buttons, labels, or even filenames of images, videos, and so on. Resource files
    are XML files with the `.resx` extension. The filename includes a culture code,
    for example, `PacktResources.en-GB.resx` or `PacktResources.da-DK.resx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a resource file or individual entry is missing, the automatic culture fallback
    search path for resources goes from specific culture (language and region) to
    neutral culture (language only) to invariant culture (supposedly independent but,
    basically, US English). If the current thread culture is `en-AU` (Australian English),
    then it will search for the resource file in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Australian English: `PacktResources.en-AU.resx`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Neutral English: `PacktResources.en.resx`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invariant: `PacktResources.resx`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining and loading resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To load resources from these satellite assemblies, we use some standard .NET
    types named `IStringLocalizer<T>` and `IStringLocalizerFactory`. Implementations
    of these are loaded from the .NET generic host as dependency services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithCultures` project, add package references to Microsoft extensions
    to work with generic hosting and localization, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `WorkingWithCultures` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project folder, create a new folder named `Resources`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Resources` folder, add a new XML file named `PacktResources.resx`,
    and modify the contents to contain default invariant language resources (usually
    equivalent to US English), as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `WorkingWithCultures` project folder, add a new class file named `PacktResources.cs`
    that will load text resources for the user interface, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the `GetEnterYourNamePrompt` method, I broke the implementation down into
    steps to get useful information, like checking if the resource string is found
    and showing the search path if not. The other method implementations use a simplified
    fallback to the key name for the resource string if the resource is not found.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, at the top, import the namespaces to work with hosting and
    dependency injection, and then configure a host that enables localization and
    the `PacktResources` service, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: By default, `ResourcesPath` is an empty string, meaning
    it looks for `.resx` files in the current directory. We are going to make the
    project tidier by putting resources into a subfolder.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After changing the current culture, add a statement to get the `PacktResources`
    service, and use it to output localized prompts for the user to enter their name,
    date of birth, and salary. Then, output their details, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing globalization and localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can run the console app and see the resources being loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the console app and enter `da-DK` for the ISO code. Note that the prompts
    are in US English because we currently only have invariant culture resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save time and to make sure you have the correct structure, you can copy,
    paste, and rename the `.resx` files instead of creating empty new ones. Or you
    could copy these files from the GitHub repository for the book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Resources` folder, add a new XML file named `PacktResources.da.resx`,
    and modify the contents to contain non-region-specific Danish language resources,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Resources` folder, add a new XML file named `PacktResources.fr.resx`,
    and modify the contents to contain non-region-specific French language resources,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Resources` folder, add a new XML file named `PacktResources.fr-CA.resx`,
    and modify the contents to contain the French language in Canada region resources,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Resources` folder, add a new XML file named `PacktResources.pl-PL.resx`,
    and modify the contents to contain the Polish language in Poland region resources,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Resources` folder, add a new XML file named `PacktResources.fa-IR.resx`,
    and modify the contents to contain the Farsi language in Iranian region resources,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and enter `da-DK` for the ISO code. Note that the prompts are
    in Danish, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and enter `fr-FR` for the ISO code. Note that the prompts are
    in French only, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and enter `fr-CA` for the ISO code. Note that the prompts are
    in French and English because Canada might have a requirement to support both
    as official languages, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and enter `fa-IR` for the ISO code. Note that the prompts are
    in Persian/Farsi and English, and there is the additional complication of a right-to-left
    language, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you need to work with Persian dates, then there are NuGet packages with open-source
    GitHub repositories that you can try, although I cannot vouch for their correctness,
    like [https://github.com/VahidN/DNTPersianUtils.Core](https://github.com/VahidN/DNTPersianUtils.Core)
    and [https://github.com/imanabidi/PersianDate.NET](https://github.com/imanabidi/PersianDate.NET).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Resources` folder, in `PacktResources.da.resx`, modify the contents
    to deliberately change the key for the prompt to enter your name, by appending
    `Wrong`, as highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and enter `da-DK` for the ISO code. Note that the prompts are
    in Danish, except for the `Enter your name` prompt in English, due to it falling
    back to the default resource file, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Resources` folder, in `PacktResources.resx`, modify the contents to
    deliberately change the key for the prompt to enter your name, by appending `Wrong`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, and enter `da-DK` for the ISO code. Note that the prompts are
    in Danish, except for the `Enter your name` prompt, which shows an error and uses
    the key name as a last - resort fallback, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `Wrong` suffix in both resource files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Solution Explorer**, toggle **Show All Files**, and expand the `bin/Debug/net8.0/da`
    folder, as shown in *Figure 7.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The satellite assembly folders for culture resources'
  prefs: []
  type: TYPE_NORMAL
- en: Note the satellite assembly named `WorkingWithCultures.resources.dll` for the
    neutral Danish resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any other culture resource assemblies are named the same but stored in folders
    that match the appropriate culture code. You can use tools like **ResX Resource
    Manager** (found at the following link: [https://dotnetfoundation.org/projects/resx-resource-manager](https://dotnetfoundation.org/projects/resx-resource-manager))
    to create many more `.resx` files, compile them into satellite assemblies, and
    then deploy them to users without needing to recompile the original console app.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Consider whether your application needs to be internationalized,
    and plan for that before you start coding! Think about all the data that will
    need to be globalized (date formats, number formats, and sorting text behavior).
    Write down all the pieces of text in the user interface that will need to be localized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft has an online tool (found at the following link: [https://www.microsoft.com/en-us/Language/](https://www.microsoft.com/en-us/Language/))
    that can help you translate text in your user interfaces, as shown in *Figure
    7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Microsoft user interface online text translation tool'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen lots of date and time features provided by the .NET BCL. Does
    it provide everything we need to handle internationalization? Unfortunately, no.
    That’s why you will likely want to use Noda Time.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Noda Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Noda Time** is for developers who feel that the built-in libraries for handling
    dates and times are not good enough. Noda Time is like Joda Time, a replacement
    date/time handling library for Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Noda Time 3.0 or later supports .NET Standard 2.0 and .NET 6 or later. This
    means that you can use it with legacy platforms like .NET Framework and Xamarin,
    as well as modern .NET.
  prefs: []
  type: TYPE_NORMAL
- en: To understand one of the core deficiencies with the built-in .NET date/time
    types, imagine that instead of defining separate types for numbers, like `int`
    (`System.Int32`), `double` (`System.Double`), and `decimal` (`System.Decimal`),
    the .NET team defined only a `System.Number` type with a property named `Kind`
    to indicate what kind of number it is, how it is stored in memory, how to handle
    it, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: That is what the team did with `System.DateTime`. That type has a `Kind` property
    that indicates if it is a local time, UTC time, or unspecified. It varies in behavior
    depending on how you treat it. This makes date/time values as implemented in .NET
    fundamentally tricky to work with and understand.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: Jon Skeet, the creator of Noda Time, has a lot more to
    say about the limitations of date/time support in .NET and `DateTime`, specifically
    in a 2011 blog post found at the following link: [https://blog.nodatime.org/2011/08/what-wrong-with-datetime-anyway.html](https://blog.nodatime.org/2011/08/what-wrong-with-datetime-anyway.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Important concepts and defaults in Noda Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The built-in `DateTime` type stores both global and local values, or values
    that are unspecified. Unless treated with great care, this opens the door to subtle
    bugs and misunderstandings.
  prefs: []
  type: TYPE_NORMAL
- en: The first big difference with Noda Time is that it forces you to make a choice
    at the type level. Noda Time, therefore, has more types and, at first, can seem
    more confusing. Types in Noda Time are global or local. Every person anywhere
    in the world would share the same global values at the same instant, whereas each
    person would have a different local value, depending on factors like their time
    zone.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in date/time types in .NET are only accurate to the tick, which is
    about 100 nanoseconds. Noda Time is accurate to 1 nanosecond, 100 times more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: The “zero” baseline in Noda Time is midnight at the start of 1 January 1970
    in the UTC time zone. The Noda Time `Instant` is the number of nanoseconds before
    (if a negative value) or since (if a positive value) that time and represents
    a point in time on the global timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default calendaring system in Noda Time is the ISO-8601 calendar because
    it is the standard, and you can read more about it at the following link: [https://en.wikipedia.org/wiki/ISO_8601](https://en.wikipedia.org/wiki/ISO_8601).
    Automatic conversions to other calendaring systems like Julian, Coptic, and Buddhist
    are supported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Noda Time has some common types that are like some .NET date/time types, as
    summarized in *Table 7.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Noda Time type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Instant` struct | Represents an instant on the global timeline, with nanosecond
    resolution. |'
  prefs: []
  type: TYPE_TB
- en: '| `Interval` struct | Two `Instant` values, an inclusive start and an exclusive
    end. |'
  prefs: []
  type: TYPE_TB
- en: '| `LocalDateTime` struct | A date/time value in a particular calendaring system,
    but it does not represent a fixed point on the global timeline. For example, midnight
    on New Year’s Eve 2023 happens for different people in different time zones. If
    you do not know the user’s time zone, you will likely have to use this type. |'
  prefs: []
  type: TYPE_TB
- en: '| `LocalDate` and `LocalTime` structs | Like `LocalDateTime` struct but only
    the date or time part. When prompting the user to enter date and time values,
    you often start with them separately and then combine them into a single `LocalDateTime`
    struct. |'
  prefs: []
  type: TYPE_TB
- en: '| `DateTimeZone` class | Represents a time zone. It is easy to convert from
    the .NET `TimeZoneInfo` using `BclDateTimeZone`. Use `DateTimeZoneProviders.Tzdb`
    to get a time zone, based on the standard names listed at the following link:
    [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ZonedDateTime` struct | A date/time value in a particular calendaring system
    and in a specific time zone, so it does represent a fixed point on the global
    timeline. |'
  prefs: []
  type: TYPE_TB
- en: '| `Offset` struct | Represents an offset. It is positive if the local time
    is ahead of UTC, and negative if the local time is behind UTC. |'
  prefs: []
  type: TYPE_TB
- en: '| `OffsetDateTime` struct | You might know the offset from UTC, but that does
    not always cleanly map to a single time zone. This type should be used in this
    scenario instead of `ZonedDateTime`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Duration` struct | A fixed number of nanoseconds. Has properties to convert
    to common time units like `Days`, `Hours`, `Minutes`, and `Seconds`, rounded down
    or up to zero because they return an `int`, and non-rounded properties like `TotalDays`,
    `TotalMinutes`, and so on, because they return a `double`. Used for calculations
    on `Instant` and `ZonedDateTime` values. Use this instead of the .NET `TimeSpan`
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Period` class | A variable duration because the “two months” represented
    by January and February 2024 are different lengths to the “two months” of June
    and July 2024, or even the “two months” represented by January and February in
    a non-leap year (2024 is a leap year, so February 2024 has 29 days). |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.6: Common Noda Time types'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use `Instant` to record the point in time when something
    happened. It is good for timestamps. It can then be represented to the user in
    their local time zone. Common types used to record a user-entered date/time value
    are the following: `ZonedDateTime`, `OffsetDateTime`, `LocalDateTime`, `LocalDate`,
    and `LocalTime`.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting between Noda Time date/time types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize common ways to convert between Noda Time types, review the following
    non-exhaustive diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Common ways to convert between Noda Time date/time types'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Node Time in a console app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithNodaTime` to the `Chapter07` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the project file, treat warnings as errors, then statically and globally
    import the `System.Console` class, and add a package reference for `NodaTime`,
    as shown in the following markup:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new class file named `Program.Helpers.cs`, and replace its contents,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, add statements to get the
    current instant in time, and convert it to various Noda Time types, including
    UTC, a couple of time zones, and local time, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, and note the results, including that “local” time does
    not take into account any DST offset; for example, in my case, living in the UK,
    I must use the London time zone to get British Summer Time (10:21am), not “local”
    time (9:21am), as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to explore what can be done with periods of
    time, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, including that at the time of running
    the console app on 1 June 2023, the modern .NET era has lasted 6 years, 11 months,
    and 4 days, the serialization format for the `Period` type, and how two periods
    can be compared and should be normalized before the comparison, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: Normalizing a `Period` with the `Normalize` method means
    multiplying any weeks by 7 and adding them to the number of days, then setting
    `Weeks` to zero, and other calculations. Learn more at the following link: [https://nodatime.org/3.1.x/api/NodaTime.Period.html#NodaTime_Period_Normalize](https://nodatime.org/3.1.x/api/NodaTime.Period.html#NodaTime_Period_Normalize)'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing and JSON serialization with Noda Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Noda Time has two optional packages to write unit tests (`NodaTime.Testing`)
    and work with JSON.NET (`NodaTime.Serialization.JsonNet`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation for Noda Time is found at the following link: [https://nodatime.org/](https://nodatime.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring the topics in this chapter with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the web to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between localization, globalization, and internationalization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the smallest measurement of time available in .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long is a “tick” in .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what scenario might you use a `DateOnly` value instead of a `DateTime` value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a time zone, what does its `BaseUtcOffset` property tell you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you get information about the local time zone in which your code executes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a `DateTime` value, what does its `Kind` property tell you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you control the current culture for your executing code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the ISO culture code for Welsh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do localization resource file fallbacks work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 7.2 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-7---handling-dates-times-and-internationalization](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-7---handling-dates-times-and-internationalization)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.3 – Learn from expert Jon Skeet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jon Skeet is a world-renowned expert on internationalization. Watch him present
    *Working with Time is Easy* at the following link: [https://www.youtube.com/watch?v=saeKBuPewcU](https://www.youtube.com/watch?v=saeKBuPewcU)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you:'
  prefs: []
  type: TYPE_NORMAL
- en: Explored dates and times, including the .NET 8 `TimeProvider` to improve unit
    tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to handle time zones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to internationalize your code using globalization and localization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explored some of the features of Noda Time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build web services using the ASP.NET
    Core Minimal API, and how to secure and protect them.
  prefs: []
  type: TYPE_NORMAL
