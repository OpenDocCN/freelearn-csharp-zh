<html><head></head><body>
<div id="_idContainer057">
<h1 class="chapter-number" id="_idParaDest-73"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.2.1">Refactoring at the Method Level</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the last chapter, we covered improving individual lines of code. </span><span class="koboSpan" id="kobo.3.2">We’ll expand on those lessons to cover refactoring entire methods and solving issues with how code comes together to form larger methods that then interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We saw a little of this in </span><a href="B21324_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.7.1"> when we covered the extract method refactoring. </span><span class="koboSpan" id="kobo.7.2">However, in this chapter, we’ll expand our set of tools covering the basics of refactoring methods and then move into more advanced areas as we cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Refactoring the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">flight tracker</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Refactoring methods</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Refactoring constructors</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Refactoring parameters</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">to functions</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Introducing static methods and </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">extension methods</span></span></li>
</ul>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">The starting code for this chapter is available from GitHub at </span><a href="https://github.com/PacktPublishing/Refactoring-with-CSharp"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Refactoring-with-CSharp</span></a><span class="koboSpan" id="kobo.21.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">Chapter04/Ch4BeginningCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.23.1"> folder.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.24.1">Refactoring the flight tracker</span></h1>
<p><span class="koboSpan" id="kobo.25.1">This chapter’s code focuses</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.26.1"> largely on a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.28.1"> class intended to track and display the outgoing flights from a commercial airport for passengers in the terminal, as pictured in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.29.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.30.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.32.1"><img alt="Figure 4.1 – FlightTracker displaying outbound flight statuses" src="image/B21324_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.33.1">Figure 4.1 – FlightTracker displaying outbound flight statuses</span></p>
<p><span class="koboSpan" id="kobo.34.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.36.1"> class </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.37.1">has a number of methods related to managing and displaying flights. </span><span class="koboSpan" id="kobo.37.2">It is supported by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">Flight</span></strong><span class="koboSpan" id="kobo.39.1"> class which represents an individual flight in the system and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">FlightStatus</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.41.1">enum</span></strong><span class="koboSpan" id="kobo.42.1"> which represents all relevant statuses of a flight, as shown in the class diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.43.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.46.1"><img alt="Figure 4.2 – A class diagram showing FlightTracker and supporting classes" src="image/B21324_04_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.47.1">Figure 4.2 – A class diagram showing FlightTracker and supporting classes</span></p>
<p><span class="koboSpan" id="kobo.48.1">We’ll explore these pieces of code throughout this chapter, but for now, we need to understand that the key responsibilities of </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.50.1"> include </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.52.1">Tracking a list </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">of flights</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">Scheduling new flights (adding them to </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">the list)</span></span></li>
<li><span class="koboSpan" id="kobo.56.1">Marking flights as arrived, departed, </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">or delayed</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">Displaying </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">all flights</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">Finding a flight by </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">its ID</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.62.1">This is a fairly simple flight tracker class, but we’ll see a slightly more complicated version of one in the</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.63.1"> next chapter as we explore </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">object-oriented refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">For now, let’s look at a few simple steps we can take to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">these methods.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.67.1">Refactoring methods</span></h1>
<p><span class="koboSpan" id="kobo.68.1">In this section, we’ll explore a number of refactorings related to methods and their interactions. </span><span class="koboSpan" id="kobo.68.2">We’ll start by discussing the access modifier of </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">a method.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.70.1">Changing method access modifiers</span></h2>
<p><span class="koboSpan" id="kobo.71.1">During my time as a professional C# instructor, I noticed my students often tended to not think about the </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">access modifiers</span></strong><span class="koboSpan" id="kobo.73.1"> they used in their code. </span><span class="koboSpan" id="kobo.73.2">Specifically, my students would</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.74.1"> usually do one of </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">two things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.76.1">They marked all </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.77.1">methods as </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">public</span></strong><span class="koboSpan" id="kobo.79.1"> by default unless someone (usually me) suggested they use a different </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">access modifier</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">They marked all </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.82.1">methods as </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">private</span></strong><span class="koboSpan" id="kobo.84.1"> by default (or omitted the access modifier entirely, defaulting to </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">private</span></strong><span class="koboSpan" id="kobo.86.1"> anyway) until the compiler gave them an issue requiring them to make a method </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">more accessible</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.88.1">Both approaches are insufficient for a simple reason: we want to explicitly declare the visibility level of our methods. </span><span class="koboSpan" id="kobo.88.2">This way, whenever you read code, you are reminded explicitly by the access modifier what other code can access the code you’re working with. </span><span class="koboSpan" id="kobo.88.3">This is particularly useful when working with non-private methods that can be referenced outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">the class.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.90.1">Access modifiers</span></p>
<p class="callout"><span class="koboSpan" id="kobo.91.1">C# has several access modifiers as of C# 12 that govern what other areas can refer to your code. </span><span class="koboSpan" id="kobo.91.2">The current access modifiers are </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">public</span></strong><span class="koboSpan" id="kobo.93.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">private</span></strong><span class="koboSpan" id="kobo.95.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">protected</span></strong><span class="koboSpan" id="kobo.97.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">internal</span></strong><span class="koboSpan" id="kobo.99.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">protected internal</span></strong><span class="koboSpan" id="kobo.101.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">private internal</span></strong><span class="koboSpan" id="kobo.103.1">, and the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">file</span></strong><span class="koboSpan" id="kobo.105.1"> access modifier that restricts access to something within a single source file. </span><span class="koboSpan" id="kobo.105.2">While these access modifiers all have their uses, I’m going to focus primarily on </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">public</span></strong><span class="koboSpan" id="kobo.107.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">private</span></strong><span class="koboSpan" id="kobo.109.1"> in this section for </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">simplicity’s sake.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">If we mark a method as </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">public</span></strong><span class="koboSpan" id="kobo.113.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">protected</span></strong><span class="koboSpan" id="kobo.115.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">internal</span></strong><span class="koboSpan" id="kobo.117.1">, there should be a good reason for that – typically related to the method being a primary way in which we intend for others to use </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.121.1"> class has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">public</span></strong><span class="koboSpan" id="kobo.123.1"> method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">FindFlightById</span></strong><span class="koboSpan" id="kobo.125.1"> that is used by most of the other methods in</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.126.1"> the class but nothing outside of the class. </span><span class="koboSpan" id="kobo.126.2">This method looks up the flight by </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">ID</span></strong><span class="koboSpan" id="kobo.128.1"> and returns it if one </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">is found:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.130.1">public</span></strong><span class="koboSpan" id="kobo.131.1"> Flight? </span><span class="koboSpan" id="kobo.131.2">FindFlightById(string id) {
  return _flights.Find(f =&gt; f.Id == id);
}</span></pre>
<p><span class="koboSpan" id="kobo.132.1">Given these circumstances, you might make an explicit decision to mark the method as </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">private</span></strong><span class="koboSpan" id="kobo.134.1">, restricting its usage within this class, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.136.1">private</span></strong><span class="koboSpan" id="kobo.137.1"> Flight? </span><span class="koboSpan" id="kobo.137.2">FindFlightById(string id) {
  return _flights.Find(f =&gt; f.Id == id);
}</span></pre>
<p><span class="koboSpan" id="kobo.138.1">By marking this method as </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">private</span></strong><span class="koboSpan" id="kobo.140.1">, you have greater freedom in the future to rename it, change how it works, modify its parameters, or remove </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">it entirely.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">Changing the access modifier is generally safe if nothing outside the class uses the method. </span><span class="koboSpan" id="kobo.142.2">Otherwise, this decision will cause </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">compiler errors.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.144.1">Renaming methods and parameters</span></h2>
<p><span class="koboSpan" id="kobo.145.1">Let’s </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.146.1">take a look at three </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.147.1">very similar methods for managing flights </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">FlightTracker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.151.1">
public Flight? </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">DelayFlight(string fId, DateTime newTime)</span></strong><span class="koboSpan" id="kobo.153.1"> {
  // Details omitted
}
public Flight? </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">MarkFlightArrived(DateTime time, string id)</span></strong><span class="koboSpan" id="kobo.155.1">{
  // Details omitted
}
public Flight? </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">MarkFlightDeparted(string id, DateTime t) </span></strong><span class="koboSpan" id="kobo.157.1">{
  // Details omitted
}</span></pre>
<p><span class="koboSpan" id="kobo.158.1">Each of these methods takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">DateTime</span></strong><span class="koboSpan" id="kobo.160.1"> and a flight identifier string. </span><span class="koboSpan" id="kobo.160.2">However, the naming of these parameters and </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.161.1">even these methods are not </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">incredibly consistent.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">DelayFlight</span></strong><span class="koboSpan" id="kobo.164.1"> calls its flight ID </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.165.1">variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">fId</span></strong><span class="koboSpan" id="kobo.167.1"> and its new departure time </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">newTime</span></strong><span class="koboSpan" id="kobo.169.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.171.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">time</span></strong><span class="koboSpan" id="kobo.173.1"> for the arrival time and </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">id</span></strong><span class="koboSpan" id="kobo.175.1"> for the flight identifier. </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">MarkFlightDeparted</span></strong><span class="koboSpan" id="kobo.177.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">id</span></strong><span class="koboSpan" id="kobo.179.1"> but chose </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">t</span></strong><span class="koboSpan" id="kobo.181.1"> to denote the </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">departure time.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">While some of these naming choices are better than others on their own, the lack of naming consistency in methods within the same class can hurt other people’s ability to work effectively with your code. </span><span class="koboSpan" id="kobo.183.2">This can lead them to feel less confident in your abilities and can even introduce bugs from misunderstandings of what parameters or methods represent – all due to a lack </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">of consistency.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">To fix this, we can use the </span><em class="italic"><span class="koboSpan" id="kobo.186.1">rename parameter</span></em><span class="koboSpan" id="kobo.187.1"> refactoring to rename individual parameters to ensure consistency. </span><span class="koboSpan" id="kobo.187.2">This can be done by right-clicking on a parameter and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">Rename…</span></strong><span class="koboSpan" id="kobo.189.1"> from the context menu, or pressing </span><em class="italic"><span class="koboSpan" id="kobo.190.1">Ctrl</span></em><span class="koboSpan" id="kobo.191.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.192.1">R</span></em><span class="koboSpan" id="kobo.193.1"> twice with the parameter selected. </span><span class="koboSpan" id="kobo.193.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.194.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 4.3 – Activating the rename parameter refactoring via the context menu" src="image/B21324_04_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 4.3 – Activating the rename parameter refactoring via the context menu</span></p>
<p><span class="koboSpan" id="kobo.199.1">Next, type the new name you want to use for the parameter and press </span><em class="italic"><span class="koboSpan" id="kobo.200.1">Enter</span></em><span class="koboSpan" id="kobo.201.1"> to complete the change. </span><span class="koboSpan" id="kobo.201.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.203.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.205.1"><img alt="Figure 4.4 – Renaming the parameter" src="image/B21324_04_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.206.1">Figure 4.4 – Renaming the parameter</span></p>
<p><span class="koboSpan" id="kobo.207.1">While choosing your names, you’ll want to pick something that is clear and consistent with the terminology and names you use in your class already. </span><span class="koboSpan" id="kobo.207.2">Avoid very short and single-letter parameters </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.208.1">wherever possible (excluding some cases, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">x</span></strong><span class="koboSpan" id="kobo.210.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">y</span></strong><span class="koboSpan" id="kobo.212.1"> for coordinates or other</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.213.1"> established usages of short </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">parameter names).</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">In the case of this code, I chose to rename all the flight identifiers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">id</span></strong><span class="koboSpan" id="kobo.217.1"> and chose to be more explicit about the names of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">DateTime</span></strong><span class="koboSpan" id="kobo.219.1"> parameters to indicate what the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">parameter represented.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">I also chose to use the same rename tool to rename the entire method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">DelayFlight</span></strong><span class="koboSpan" id="kobo.223.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">MarkFlightDelayed</span></strong><span class="koboSpan" id="kobo.225.1"> to be more consistent with the other methods in </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">this class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
public Flight? </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">MarkFlightDelayed(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.229.1">  string id, DateTime newDepartureTime)</span></strong><span class="koboSpan" id="kobo.230.1"> {
  // Details omitted
}
public Flight? </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">MarkFlightArrived(DateTime arrivalTime,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.232.1">  string id)</span></strong><span class="koboSpan" id="kobo.233.1"> {
  // Details omitted
}
public Flight? </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">MarkFlightDeparted(string id,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.235.1">  DateTime departureTime)</span></strong><span class="koboSpan" id="kobo.236.1"> {
  // Details omitted
}</span></pre>
<p><span class="koboSpan" id="kobo.237.1">Some of these names are perhaps a bit longer than I might like (particularly when trying to fit code onto a page in a book!), but </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.238.1">clear parameter and method names can save a lot of confusion and even </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.239.1">prevent certain bugs from </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">occurring later.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.241.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.242.1">If the inconsistent ordering of parameters annoys you, don’t worry. </span><span class="koboSpan" id="kobo.242.2">We’ll fix parameter ordering later on in </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">this chapter.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.244.1">Overloading methods</span></h2>
<p><span class="koboSpan" id="kobo.245.1">Let’s shift gears and talk about how methods </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.246.1">can work together in tandem. </span><span class="koboSpan" id="kobo.246.2">First, we’ll look at an example of </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">overloading</span></strong><span class="koboSpan" id="kobo.248.1"> and then an example </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">of </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.250.1">chaining</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Let’s start by looking at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ScheduleNewFlight</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
public Flight </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.257.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.258.1">string id, string dest,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.259.1">  DateTime depart, string gate</span></strong><span class="koboSpan" id="kobo.260.1">) {
  </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">Flight flight = new() {</span></strong><span class="koboSpan" id="kobo.262.1">
      Id = </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">id</span></strong><span class="koboSpan" id="kobo.264.1">,
      Destination = </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">dest</span></strong><span class="koboSpan" id="kobo.266.1">,
      DepartureTime = </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">depart</span></strong><span class="koboSpan" id="kobo.268.1">,
      Gate = </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">gate</span></strong><span class="koboSpan" id="kobo.270.1">,
      Status = FlightStatus.Inbound
  </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">}</span></strong><span class="koboSpan" id="kobo.272.1">;
  _flights.Add(flight);
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.273.1">This method takes in four parameters representing flight information. </span><span class="koboSpan" id="kobo.273.2">It uses them to instantiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Flight</span></strong><span class="koboSpan" id="kobo.275.1"> object, adds the flight to the private list of flights, and then returns the newly-created </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Flight</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">As the system grows, it’s reasonable to </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.279.1">expect that someone might want to provide their own </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Flight</span></strong><span class="koboSpan" id="kobo.281.1"> object. </span><span class="koboSpan" id="kobo.281.2">To accommodate that, you can overload the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">ScheduleNewFlight</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.283.1"> method.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.284.1">Overloading</span></p>
<p class="callout"><span class="koboSpan" id="kobo.285.1">Overloading is where you offer a method with the same name as another method but a different set of types of parameters that can be accepted by the method. </span><span class="koboSpan" id="kobo.285.2">For example, you can have a method that takes in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">int</span></strong><span class="koboSpan" id="kobo.287.1"> and another method that takes in two </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">strings</span></strong><span class="koboSpan" id="kobo.289.1">, but you can’t have two methods that both take in only a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">int</span></strong><span class="koboSpan" id="kobo.291.1">, even if the parameter names are different. </span><span class="koboSpan" id="kobo.291.2">From the compiler’s perspective, overloaded methods are entirely separate methods that just happen to have the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">same name.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">The overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.295.1"> method that takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Flight</span></strong><span class="koboSpan" id="kobo.297.1"> object might look something like </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
public Flight </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">ScheduleNewFlight(Flight flight)</span></strong><span class="koboSpan" id="kobo.301.1"> {
  _flights.Add(flight);
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.302.1">Overloading the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.304.1"> method is helpful because it helps people discover the different options for scheduling a flight based on Visual Studio’s suggestions, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.305.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.306.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.308.1"><img alt="Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight" src="image/B21324_04_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.309.1">Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight</span></p>
<p><span class="koboSpan" id="kobo.310.1">By providing overloads, following standard conventions, and having consistent and predictable methods and parameters, you help others discover how to use your classes safely </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">and effectively.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.312.1">Chaining methods</span></h2>
<p><span class="koboSpan" id="kobo.313.1">You may have noticed a few lines </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.314.1">of duplication between our two </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.316.1"> overloads. </span><span class="koboSpan" id="kobo.316.2">Let’s take a look at them side by side </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">for reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart, string gate) {
  Flight flight = new() {
      Id = id,
      Destination = dest,
      DepartureTime = depart,
      Gate = gate,
      Status = FlightStatus.Inbound
  };
</span><strong class="bold"><span class="koboSpan" id="kobo.319.1">  _flights.Add(flight);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.320.1">  return flight;</span></strong><span class="koboSpan" id="kobo.321.1">
}
public Flight ScheduleNewFlight(Flight flight) {
</span><strong class="bold"><span class="koboSpan" id="kobo.322.1">  _flights.Add(flight);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.323.1">  return flight;</span></strong><span class="koboSpan" id="kobo.324.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.325.1">While this duplication is very minimal, I could see new requirements come in that would necessitate changing both places. </span><span class="koboSpan" id="kobo.325.2">For example, the business might require that whenever a new flight is scheduled, a log entry should be written, or perhaps a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">LastScheduleChange</span></strong><span class="koboSpan" id="kobo.327.1"> property needs to be set to the </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">current time.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">When these types of changes occur, developers run the risk of introducing bugs unless they change all the affected areas. </span><span class="koboSpan" id="kobo.329.2">This means that code duplication, even minor code duplication such as this example, leads to additional work and additional sources of bugs if not every place with </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.330.1">similar logic </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">is updated.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">One thing that can</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.333.1"> help with this is </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">method chaining</span></strong><span class="koboSpan" id="kobo.335.1">. </span><span class="koboSpan" id="kobo.335.2">Method chaining is when one method calls another related method and has it accomplish its work </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">for it.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">In this case, we can modify our first </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.339.1"> method to be responsible for creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Flight</span></strong><span class="koboSpan" id="kobo.341.1"> object and then handing off that object to the other </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.343.1"> overload, </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.345.1">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart, string gate) {
  Flight flight = new() {
      Id = id,
      Destination = dest,
      DepartureTime = depart,
      Gate = gate,
      Status = FlightStatus.Inbound
  };
  </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">return ScheduleNewFlight(flight);</span></strong><span class="koboSpan" id="kobo.347.1">
}
public Flight ScheduleNewFlight(Flight flight) {
  _flights.Add(flight);
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Not only is this less code, but if we ever need to alter what happens when a new flight is scheduled, we now only have one place </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">to modify.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Now that we’ve covered some of the basics of refactoring methods, let’s look briefly at some parallels with </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">constructors</span></strong><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">After all, constructors </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.353.1">are essentially a special type of method that gets </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.354.1">called when an object </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">is instantiated.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.356.1">Refactoring constructors</span></h1>
<p><span class="koboSpan" id="kobo.357.1">When you think about the job</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.358.1"> of a constructor, its whole reason for being is to get the object into its correct initial position. </span><span class="koboSpan" id="kobo.358.2">Once the constructor completes, the object is generally considered ready for use by </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">other code.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">This means that constructors can be very handy for ensuring that certain pieces of information are </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">in place.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Right now, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Flight</span></strong><span class="koboSpan" id="kobo.364.1"> class is defined fairly minimally and only has the default constructor that .NET provides in the absence of any </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">explicit constructor:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Flight.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
public class Flight {
    public string Id { get; set; }
    public string Destination { get; set; }
    public DateTime DepartureTime { get; set; }
    public DateTime ArrivalTime { get; set; }
    public string Gate { get; set; }
    public FlightStatus Status { get; set; }
    public override string ToString() {
        return $"{Id} to {Destination} at {DepartureTime}";
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.368.1">The problem with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Flight</span></strong><span class="koboSpan" id="kobo.370.1"> class lacking any explicit constructor is that flights don’t make sense without some of these pieces </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">of information.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">While more recent versions of C# have given us things such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">required</span></strong><span class="koboSpan" id="kobo.374.1"> keyword, which we’ll explore in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.375.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.376.1">, the classic approach to requiring some piece of information at object creation</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.377.1"> has been to make the constructor take it in as a parameter. </span><span class="koboSpan" id="kobo.377.2">To demonstrate this, let’s add a parameterized </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">constructor next.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.379.1">Generating constructors</span></h2>
<p><span class="koboSpan" id="kobo.380.1">While we could </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.381.1">manually write a constructor, Visual Studio gives us some great code generation tools, including a </span><em class="italic"><span class="koboSpan" id="kobo.382.1">generate </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.383.1">constructor</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">To use this refactoring, select the class and open the </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.387.1"> menu. </span><span class="koboSpan" id="kobo.387.2">Then, select </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">Generate constructor…</span></strong><span class="koboSpan" id="kobo.389.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.390.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.391.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.393.1"><img alt="Figure 4.6 – Generating a constructor" src="image/B21324_04_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.394.1">Figure 4.6 – Generating a constructor</span></p>
<p><span class="koboSpan" id="kobo.395.1">This will open a dialog that will allow you to select what members get initialized from the constructor when creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Flight</span></strong><span class="koboSpan" id="kobo.397.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.398.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.399.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.401.1"><img alt="Figure 4.7 – Selecting required members for the constructor" src="image/B21324_04_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.402.1">Figure 4.7 – Selecting required members for the constructor</span></p>
<p><span class="koboSpan" id="kobo.403.1">In this case, I chose to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Id</span></strong><span class="koboSpan" id="kobo.405.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">Destination</span></strong><span class="koboSpan" id="kobo.407.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">DepartureTime</span></strong><span class="koboSpan" id="kobo.409.1"> part of the constructor and left the others unchecked. </span><span class="koboSpan" id="kobo.409.2">I also unchecked the </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">Add null checks</span></strong><span class="koboSpan" id="kobo.411.1"> checkbox to prevent the </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.412.1">generated code from being too complex for </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">This generated the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">following constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">Flight(string id, string destination,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.418.1">  DateTime departureTime)</span></strong><span class="koboSpan" id="kobo.419.1"> {
  Id = id;
  Destination = destination;
  DepartureTime = departureTime;
}</span></pre>
<p><span class="koboSpan" id="kobo.420.1">The resulting code correctly sets the required properties based on </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">its parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">If you wanted to, you could go back in and generate a new constructor with a different set of parameters, since classes can have any number of </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">overloaded constructors.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">In fact, we’ll add another constructor in the next section to illustrate this. </span><span class="koboSpan" id="kobo.424.2">However, for now, we have a problem we need to resolve in the form of a </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">build error:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.426.1"><img alt="Figure 4.8 – Build error trying to instantiate a Flight instance" src="image/B21324_04_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.427.1">Figure 4.8 – Build error trying to instantiate a Flight instance</span></p>
<p><span class="koboSpan" id="kobo.428.1">If you tried to build your project after adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Flight</span></strong><span class="koboSpan" id="kobo.430.1"> constructor, you’ll see an error similar to that shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.431.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.432.1">.8</span></em><span class="koboSpan" id="kobo.433.1">. </span><span class="koboSpan" id="kobo.433.2">This “no argument given that corresponds to the required parameter” error exists because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">Flight flight = new()</span></strong><span class="koboSpan" id="kobo.435.1"> code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.437.1"> is trying to invoke the default constructor for </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Flight</span></strong><span class="koboSpan" id="kobo.439.1">, but that constructor no </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">longer exists.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">When we added our</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.442.1"> constructor a moment ago, this didn’t move the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">Flight</span></strong><span class="koboSpan" id="kobo.444.1"> class from having no constructors to one constructor. </span><span class="koboSpan" id="kobo.444.2">Instead, we went from having .NET’s default constructor with no parameters to one constructor with the new parameters we generated, removing the default </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">constructor entirely.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">We can add the default constructor back manually by explicitly </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">defining it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
public Flight() {
}</span></pre>
<p><span class="koboSpan" id="kobo.449.1">This constructor does nothing aside from allowing others to instantiate the class by providing no parameters to the constructor. </span><span class="koboSpan" id="kobo.449.2">As soon as you declare your own constructor, .NET no longer provides the default constructor </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">for you.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">To fix this compiler error, we can either add a new constructor that takes in no parameters or we can adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.453.1"> code to use our new constructor instead of the default one that no </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">longer exists.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Since part of the intent of adding a new constructor is to require certain pieces of information at the time of object creation, it makes more sense to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.457.1"> to use the new constructor, </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">as follows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.459.1">FlightTracker.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart, string gate) {
  Flight flight = </span><strong class="bold"><span class="koboSpan" id="kobo.461.1">new(id, dest, depart)</span></strong><span class="koboSpan" id="kobo.462.1"> {
      Gate = gate,
      Status = FlightStatus.Inbound
  };
  return ScheduleNewFlight(flight);
}</span></pre>
<p><span class="koboSpan" id="kobo.463.1">A nice side effect of doing this is that we no longer need to set those properties in the object initializer since the </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.464.1">constructor does that </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">for us.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.466.1">Chaining constructors</span></h2>
<p><span class="koboSpan" id="kobo.467.1">Earlier, we saw how we </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.468.1">can chain together overloaded methods to work together to reduce code duplication. </span><span class="koboSpan" id="kobo.468.2">I also hinted that constructors are really just special methods. </span><span class="koboSpan" id="kobo.468.3">When you have multiple constructors, they act exactly like </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">overloaded methods.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">We can put all of these concepts</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.471.1"> together by </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">chaining constructors</span></strong><span class="koboSpan" id="kobo.473.1"> together, so one constructor calls to </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">First, let’s look at an example of </span><em class="italic"><span class="koboSpan" id="kobo.476.1">not</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.477.1">doing this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.478.1">Flight.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
public Flight(string id, string destination,
  DateTime departureTime) {
</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">  Id = id;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.481.1">  Destination = destination;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.482.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.483.1">DepartureTime = departureTime;</span></strong><span class="koboSpan" id="kobo.484.1">
}
public Flight(string id, string destination,
  DateTime departureTime, FlightStatus status) {
</span><strong class="bold"><span class="koboSpan" id="kobo.485.1">  Id = id;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.486.1">  Destination = destination;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.487.1">  DepartureTime = departureTime;</span></strong><span class="koboSpan" id="kobo.488.1">
  Status = status;
}</span></pre>
<p><span class="koboSpan" id="kobo.489.1">Here, we have two constructors for </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">Flight</span></strong><span class="koboSpan" id="kobo.491.1"> that are nearly identical, except the second one also accepts a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">status</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.493.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">While this isn’t an excessive</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.495.1"> amount of duplication, it can be avoided by chaining constructors together with </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">: this()</span></strong><span class="koboSpan" id="kobo.497.1"> syntax, </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
public Flight(string id, string destination,
  DateTime departureTime) {
  Id = id;
  Destination = destination;
  DepartureTime = departureTime;
}
public Flight(string id, string destination,
  DateTime departureTime, FlightStatus status)
  </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">: this(id, destination, departureTime)</span></strong><span class="koboSpan" id="kobo.501.1"> {
  Status = status;
}</span></pre>
<p><span class="koboSpan" id="kobo.502.1">In this case, the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">Flight</span></strong><span class="koboSpan" id="kobo.504.1"> constructor starts out by calling the first constructor through its use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">: this</span></strong><span class="koboSpan" id="kobo.506.1">. </span><span class="koboSpan" id="kobo.506.2">Once that call completes, control will move back to the second constructor and it will execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Status = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">status;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1"> line.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">Chaining constructors together adds a little complexity to your code, but it also reduces duplicated code while making it such that you can add new initialization logic in one place and multiple constructors can take advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">the addition.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.512.1">Refactoring parameters</span></h1>
<p><span class="koboSpan" id="kobo.513.1">Now that we’ve</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.514.1"> explored the basics of methods and constructors, let’s talk about managing parameters. </span><span class="koboSpan" id="kobo.514.2">This is important because it is possible that poorly thought-out parameters can quickly reduce the maintainability of </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">Let’s look at a few common refactorings you’ll want to perform over the life of </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">your methods.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.518.1">Reordering parameters</span></h2>
<p><span class="koboSpan" id="kobo.519.1">Sometimes, you’ll realize that the</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.520.1"> order of parameters in a method doesn’t make as much sense as another arrangement might. </span><span class="koboSpan" id="kobo.520.2">At other times, you might notice that a few of your methods take in the same kinds of parameters, but with inconsistent ordering. </span><span class="koboSpan" id="kobo.520.3">In either case, you’ll find yourself wanting to reorder your </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">method parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">Let’s look at a practical example from the various </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">MarkX</span></strong><span class="koboSpan" id="kobo.524.1"> methods we </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">saw earlier:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.526.1">FlightTracker.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.527.1">
public Flight? </span><span class="koboSpan" id="kobo.527.2">MarkFlightDelayed(string id,
  DateTime newDepartureTime) {
  // Details omitted...
</span><span class="koboSpan" id="kobo.527.3">}
public Flight? </span><span class="koboSpan" id="kobo.527.4">MarkFlightArrived(DateTime arrivalTime,
  string id) {
  // Details omitted...
</span><span class="koboSpan" id="kobo.527.5">}
public Flight? </span><span class="koboSpan" id="kobo.527.6">MarkFlightDeparted(string id,
  DateTime departureTime) {
  // Details omitted...
</span><span class="koboSpan" id="kobo.527.7">}</span></pre>
<p><span class="koboSpan" id="kobo.528.1">Here, we have three methods that all take in </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">string</span></strong><span class="koboSpan" id="kobo.530.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">DateTime</span></strong><span class="koboSpan" id="kobo.532.1"> parameters, but their ordering </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">is inconsistent.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">In this case, looking at these three methods, you decide that the most intuitive order is to put the flight ID first and then the time component as the second parameter. </span><span class="koboSpan" id="kobo.534.2">This means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">MarkFlightDelayed</span></strong><span class="koboSpan" id="kobo.536.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">MarkFlightDeparted</span></strong><span class="koboSpan" id="kobo.538.1"> are correct but </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.540.1"> needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">be adjusted.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">You can add, remove, and</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.543.1"> reorder parameters from the same refactoring dialog in Visual Studio by selecting the method you want to refactor and then choosing </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">Change signature…</span></strong><span class="koboSpan" id="kobo.545.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.547.1"> menu, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.548.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.549.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.551.1"><img alt="Figure 4.9 – Triggering the Change signature… refactoring" src="image/B21324_04_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.552.1">Figure 4.9 – Triggering the Change signature… refactoring</span></p>
<p><span class="koboSpan" id="kobo.553.1">This will bring up the </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">Change Signature</span></strong><span class="koboSpan" id="kobo.555.1"> dialog (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.556.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.557.1">.10</span></em><span class="koboSpan" id="kobo.558.1">) and allow you to use the up and down buttons in the upper right to reorder parameters until the order in the preview matches </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">your expectations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.560.1"><img alt="Figure 4.10 – Reordering parameters in the Change Signature dialog" src="image/B21324_04_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.561.1">Figure 4.10 – Reordering parameters in the Change Signature dialog</span></p>
<p><span class="koboSpan" id="kobo.562.1">Once you are done, click </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">OK</span></strong><span class="koboSpan" id="kobo.564.1"> and Visual Studio will update your method as well as everything that was called out to that </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.565.1">method to use the revised </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">parameter order.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.567.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.568.1">There are other ways of making which parameters a method requires more explicit using C#. </span><span class="koboSpan" id="kobo.568.2">One such way would</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.569.1"> be to use the </span><strong class="bold"><span class="koboSpan" id="kobo.570.1">named arguments</span></strong><span class="koboSpan" id="kobo.571.1"> feature of C# that allows you to specify method parameters by name followed by a colon, making the parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">usage explicit.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.573.1">An example of using this to call our </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.575.1"> method would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">MarkFlightArrived(arrivalTime:DateTime.Now, id:"MyId")</span></strong><span class="koboSpan" id="kobo.577.1">. </span><span class="koboSpan" id="kobo.577.2">Note that when using named arguments, you can specify arguments in whatever order you prefer. </span><span class="koboSpan" id="kobo.577.3">See the </span><em class="italic"><span class="koboSpan" id="kobo.578.1">Further reading</span></em><span class="koboSpan" id="kobo.579.1"> section for </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">more details.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.581.1">Adding parameters</span></h2>
<p><span class="koboSpan" id="kobo.582.1">Occasionally, you’ll want to add a new parameter to your method. </span><span class="koboSpan" id="kobo.582.2">The most natural thing to do is generally to</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.583.1"> add the parameter to the end of the list of parameters. </span><span class="koboSpan" id="kobo.583.2">This, however, can have </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">two downsides:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.585.1">The new parameter might not make the most sense when added to the end of the list instead of earlier on in the sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">of parameters</span></span></li>
<li><span class="koboSpan" id="kobo.587.1">Manually adding a parameter means you must now manually adjust anything that was calling your method and provide a new value for </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">the parameter</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.589.1">Let’s look at a practical example and see how the </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">Change Signature</span></strong><span class="koboSpan" id="kobo.591.1"> dialog </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">can help.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.595.1"> method currently finds the flight by its </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">Id</span></strong><span class="koboSpan" id="kobo.597.1"> and then updates its arrival time and status to match </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">the parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
public Flight? </span><span class="koboSpan" id="kobo.599.2">MarkFlightArrived(</span><strong class="bold"><span class="koboSpan" id="kobo.600.1">string id,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.601.1">  DateTime arrivalTime</span></strong><span class="koboSpan" id="kobo.602.1">) {
  Flight? </span><span class="koboSpan" id="kobo.602.2">flight = FindFlightById(id);
  if (flight != null) {
</span><strong class="bold"><span class="koboSpan" id="kobo.603.1">    flight.ArrivalTime = arrivalTime;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.604.1">    flight.Status = FlightStatus.OnTime;</span></strong><span class="koboSpan" id="kobo.605.1">
    Console.WriteLine($"{id} arrived at {Format(arrivalTime)}.");
    } else {
      Console.WriteLine($"{id} could not be found");
    }
    return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.606.1">Let’s say we need to update this method to take in the gate that the plane should taxi to. </span><span class="koboSpan" id="kobo.606.2">While we could manually add it to the end of the parameter list, this would break every method that calls out to </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">this method.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Right now, that’s not a lot of places, since only the tests are calling </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">this method.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.610.1">FlightTrackerTests.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
Flight? </span><span class="koboSpan" id="kobo.611.2">actual =
  _target.</span><strong class="bold"><span class="koboSpan" id="kobo.612.1">MarkFlightArrived(flightId, arrivalTime)</span></strong><span class="koboSpan" id="kobo.613.1">;</span></pre>
<p><span class="koboSpan" id="kobo.614.1">However, the </span><em class="italic"><span class="koboSpan" id="kobo.615.1">Change Signature</span></em><span class="koboSpan" id="kobo.616.1"> refactoring</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.617.1"> tools in Visual Studio provide a safer option when you click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.618.1">Add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1"> button:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.620.1"><img alt="Figure 4.11 – Adding a new gate parameter to MarkFlightArrived" src="image/B21324_04_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.621.1">Figure 4.11 – Adding a new gate parameter to MarkFlightArrived</span></p>
<p><span class="koboSpan" id="kobo.622.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">Add Parameter</span></strong><span class="koboSpan" id="kobo.624.1"> dialog is one of the more complex ones in Visual Studio, but all it really needs is the following </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">few things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.626.1">The parameter name and type that is </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">being added</span></span></li>
<li><span class="koboSpan" id="kobo.628.1">Whether this parameter is required or optional (more on </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">this shortly)</span></span></li>
<li><span class="koboSpan" id="kobo.630.1">The value to use in places that are already calling </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">the method</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.632.1">In this case, our new parameter is going to be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">string</span></strong><span class="koboSpan" id="kobo.634.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">gate</span></strong><span class="koboSpan" id="kobo.636.1">. </span><span class="koboSpan" id="kobo.636.2">Callers must provide a value and any existing callers should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">"A4"</span></strong><span class="koboSpan" id="kobo.638.1"> string </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">for now.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">This use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">"A4"</span></strong><span class="koboSpan" id="kobo.642.1"> may seem like a random string because it is. </span><span class="koboSpan" id="kobo.642.2">The only place using this method right now is a unit test where the gate really doesn’t matter for that test. </span><span class="koboSpan" id="kobo.642.3">If more places were using this method, I’d likely choose </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">Infer from context</span></strong><span class="koboSpan" id="kobo.644.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">Introduce undefined </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.646.1">TODO variables</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">Clicking </span><strong class="bold"><span class="koboSpan" id="kobo.649.1">OK</span></strong><span class="koboSpan" id="kobo.650.1"> will display the </span><em class="italic"><span class="koboSpan" id="kobo.651.1">Change Signature</span></em><span class="koboSpan" id="kobo.652.1"> dialog again with your new parameter listed, allowing you to reorder it as needed. </span><span class="koboSpan" id="kobo.652.2">Clicking </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">OK</span></strong><span class="koboSpan" id="kobo.654.1"> in this dialog will add the parameter to your method and update </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">This updates your </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.657.1">method signature for </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.659.1"> and the test calling </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">your code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
Flight? </span><span class="koboSpan" id="kobo.661.2">actual =
  _target.MarkFlightArrived(flightId, arrivalTime, </span><strong class="bold"><span class="koboSpan" id="kobo.662.1">"A4"</span></strong><span class="koboSpan" id="kobo.663.1">);</span></pre>
<p><span class="koboSpan" id="kobo.664.1">With the new parameter in place, you can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.666.1"> method to use it to set the flight’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Gate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.669.1">
public Flight? </span><span class="koboSpan" id="kobo.669.2">MarkFlightArrived(string id,
  DateTime arrivalTime, </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">string gate</span></strong><span class="koboSpan" id="kobo.671.1">) {
  Flight? </span><span class="koboSpan" id="kobo.671.2">flight = FindFlightById(id);
  if (flight != null) {
    flight.ArrivalTime = arrivalTime;
    </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">flight.Gate = gate;</span></strong><span class="koboSpan" id="kobo.673.1">
    flight.Status = FlightStatus.OnTime;
    Console.WriteLine($"{id} arrived at {Format(arrivalTime)}.");
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.674.1">This workflow is a common one you’ll go through as you find yourself expanding methods to take in </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">new parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Next, let’s see </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.677.1">some ways to simplify method calls using </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">optional parameters.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.679.1">Introducing optional parameters</span></h2>
<p><span class="koboSpan" id="kobo.680.1">If you’re not a fan of the </span><strong class="bold"><span class="koboSpan" id="kobo.681.1">Change Signature</span></strong><span class="koboSpan" id="kobo.682.1"> dialog and would rather write the code yourself, you can always take </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.683.1">advantage of optional parameters to safely add new parameters to the end of your </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">parameter list.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">With an optional parameter, you specify a default value. </span><span class="koboSpan" id="kobo.685.2">Places that call your method can either specify the value for this parameter or not pass any value at all. </span><span class="koboSpan" id="kobo.685.3">In cases where no value is passed, the default value will be </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">used instead.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.687.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.688.1">This only works with parameters at the end of your parameter list due to how optional parameters work in C#. </span><span class="koboSpan" id="kobo.688.2">Additionally, the compiler doesn’t allow certain types of default values such as new objects and </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">certain literals.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">If you wanted to declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">gate</span></strong><span class="koboSpan" id="kobo.692.1"> as optional and default to </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">"TBD"</span></strong><span class="koboSpan" id="kobo.694.1"> (short for “to be determined”), your method would look like </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.696.1">
public Flight? </span><span class="koboSpan" id="kobo.696.2">MarkFlightArrived(string id,
  DateTime arrivalTime, </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">string gate = "TBD"</span></strong><span class="koboSpan" id="kobo.698.1">) {
  // Details omitted...
</span><span class="koboSpan" id="kobo.698.2">}</span></pre>
<p><span class="koboSpan" id="kobo.699.1">The code calling your method could then be left in its </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">prior state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.701.1">
Flight? </span><span class="koboSpan" id="kobo.701.2">actual =
  _target.</span><strong class="bold"><span class="koboSpan" id="kobo.702.1">MarkFlightArrived(flightId, arrivalTime)</span></strong><span class="koboSpan" id="kobo.703.1">;</span></pre>
<p><span class="koboSpan" id="kobo.704.1">Here, the code would compile, but “TBD” would be used for </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">the gate.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">Alternatively, you could specify the value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">gate</span></strong><span class="koboSpan" id="kobo.708.1"> manually by providing a value for </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">that parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
Flight? </span><span class="koboSpan" id="kobo.710.2">actual =
  _target.MarkFlightArrived(flightId, arrivalTime, </span><strong class="bold"><span class="koboSpan" id="kobo.711.1">"A4"</span></strong><span class="koboSpan" id="kobo.712.1">);</span></pre>
<p><span class="koboSpan" id="kobo.713.1">Optional parameters can be particularly nice not just for expanding methods, but also for providing common </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.714.1">defaults that callers can customize if </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">they want.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.716.1">Removing parameters</span></h2>
<p><span class="koboSpan" id="kobo.717.1">Currently, the code requires</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.718.1"> you to specify the gate whenever a new flight </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">is scheduled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.720.1">
public Flight ScheduleNewFlight(string id, string dest, DateTime depart, </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">string gate</span></strong><span class="koboSpan" id="kobo.722.1">) {
    Flight flight = new(id, dest, depart) {
        </span><strong class="bold"><span class="koboSpan" id="kobo.723.1">Gate = gate,</span></strong><span class="koboSpan" id="kobo.724.1">
        Status = FlightStatus.Inbound
    };
    return ScheduleNewFlight(flight);
}</span></pre>
<p><span class="koboSpan" id="kobo.725.1">Let’s say that you decide that since gates are now assigned at arrival, you shouldn’t need to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">gate</span></strong><span class="koboSpan" id="kobo.727.1"> when you schedule a </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">new flight.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">While you could go in and just remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">gate</span></strong><span class="koboSpan" id="kobo.731.1"> parameter from the code, this won’t update any methods that are calling that method and will result in compiler errors you </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">must resolve.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">Instead, you can use the </span><strong class="bold"><span class="koboSpan" id="kobo.734.1">Change Signature</span></strong><span class="koboSpan" id="kobo.735.1"> dialog, select the parameter you want to remove, and click </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">Remove</span></strong><span class="koboSpan" id="kobo.737.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.738.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.739.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.741.1"><img alt="Figure 4.12 – Removing the gate parameter from ScheduleNewFlight" src="image/B21324_04_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.742.1">Figure 4.12 – Removing the gate parameter from ScheduleNewFlight</span></p>
<p><span class="koboSpan" id="kobo.743.1">When you click </span><strong class="bold"><span class="koboSpan" id="kobo.744.1">OK</span></strong><span class="koboSpan" id="kobo.745.1">, Visual Studio</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.746.1"> will update your method and any callers to simply not have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">gate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.748.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">Of course, this isn’t magic, and it will leave behind code that relied on that gate parameter or code that was put in place to get the value ready to pass into </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">ScheduleNewFlight</span></strong><span class="koboSpan" id="kobo.751.1">. </span><span class="koboSpan" id="kobo.751.2">Still, the refactoring does a remarkable job of cleaning up the method definition and the direct calls of </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">that method.</span></span></p>
<p><span class="koboSpan" id="kobo.753.1">Applying the refactoring to remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">gate</span></strong><span class="koboSpan" id="kobo.755.1"> parameter results in a </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">simpler method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.757.1">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart) {
    Flight flight = new(id, dest, depart) {
        Status = FlightStatus.Inbound
    };
    return ScheduleNewFlight(flight);
}</span></pre>
<p><span class="koboSpan" id="kobo.758.1">Now that we’ve covered the basics of methods, constructors, and parameters, let’s get into the more adventuresome aspects of refactoring methods: working </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">with functions.</span></span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.760.1">Refactoring to functions</span></h1>
<p><span class="koboSpan" id="kobo.761.1">In this section, we’ll explore some aspects of refactoring related to </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">functional programming</span></strong><span class="koboSpan" id="kobo.763.1">. </span><span class="koboSpan" id="kobo.763.2">Functional programming is</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.764.1"> an approach to programming that focuses on functions and their interactions instead of purely on objects </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">and classes.</span></span></p>
<p><span class="koboSpan" id="kobo.766.1">Functional programming has become more popular over the last decade and that popularity has influenced the C# language with the addition of new forms </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">of syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">We’ll explore a few of the syntactical improvements related to functional programming and see how they can help make concise and flexible programs. </span><span class="koboSpan" id="kobo.768.2">While this is not a book about functional programming, we’ll still find ourselves exploring a few of these concepts in this section and </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.769.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.770.1">, </span><em class="italic"><span class="koboSpan" id="kobo.771.1">Defensive </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.772.1">Coding Techniques</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.774.1">Using expression-bodied members</span></h2>
<p><span class="koboSpan" id="kobo.775.1">To start dipping </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.776.1">our toes into the waters of the more functional syntax, let’s take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">FindFlightById</span></strong><span class="koboSpan" id="kobo.778.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">FlightTracker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.782.1">
private Flight? </span><span class="koboSpan" id="kobo.782.2">FindFlightById(string id) {
    return _flights.FirstOrDefault(f =&gt; f.Id == id);
}</span></pre>
<p><span class="koboSpan" id="kobo.783.1">Clearly, this is a very brief method with only a single statement. </span><span class="koboSpan" id="kobo.783.2">At the same time, this method takes up three lines of the screen. </span><span class="koboSpan" id="kobo.783.3">Since developers usually leave a blank line above and below each method, the existence of this simple method takes up five lines of the screen. </span><span class="koboSpan" id="kobo.783.4">These five lines can be a significant portion of the visible region of the screen, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.784.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.785.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.787.1"><img alt="Figure 4.13 – The visual footprint of a method with a single statement" src="image/B21324_04_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.788.1">Figure 4.13 – The visual footprint of a method with a single statement</span></p>
<p><span class="koboSpan" id="kobo.789.1">Instead, we can take</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.790.1"> advantage of expression-bodied members and convert our method to a single-line declaration using this new syntax by activating the </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">Use expression body for method</span></strong><span class="koboSpan" id="kobo.792.1"> refactoring on the </span><strong class="bold"><span class="koboSpan" id="kobo.793.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.794.1"> menu with the method selected, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.795.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.796.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.798.1"><img alt="Figure 4.14 – Triggering the Use expression body for method refactoring^" src="image/B21324_04_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.799.1">Figure 4.14 – Triggering the Use expression body for method refactoring^</span></p>
<p><span class="koboSpan" id="kobo.800.1">This converts our code to the following, more </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">concise format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.802.1">
FindFlightById(string id) </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">=&gt;</span></strong><span class="koboSpan" id="kobo.804.1">
  _flights.FirstOrDefault(f =&gt; f.Id == id);</span></pre>
<p><span class="koboSpan" id="kobo.805.1">This style only works for single-line implementations and it isn’t for everyone. </span><span class="koboSpan" id="kobo.805.2">However, if you use it for simple code, it</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.806.1"> helps reduce the “scrolling penalty” you face with many small methods in a </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">larger file.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.808.1">Passing functions as parameters with actions</span></h2>
<p><span class="koboSpan" id="kobo.809.1">While expression-bodied members are</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.810.1"> less functional programming and more functional syntax, let’s shift gears and get a taste of what’s possible by thinking about methods as </span><strong class="bold"><span class="koboSpan" id="kobo.811.1">actions</span></strong><span class="koboSpan" id="kobo.812.1"> that you can store in variables and pass around to </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">other methods.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">Before we talk about </span><em class="italic"><span class="koboSpan" id="kobo.815.1">how</span></em><span class="koboSpan" id="kobo.816.1"> to do this, let’s explore </span><em class="italic"><span class="koboSpan" id="kobo.817.1">why</span></em><span class="koboSpan" id="kobo.818.1"> we’d want to do this by looking at our </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">MarkFlightX</span></strong><span class="koboSpan" id="kobo.820.1"> methods in </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.822.1">. </span><span class="koboSpan" id="kobo.822.2">We’ll start with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">MarkFlightDelayed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
public Flight? </span><span class="koboSpan" id="kobo.825.2">MarkFlightDelayed(string id,
  DateTime newDepartureTime) {
  Flight? </span><span class="koboSpan" id="kobo.825.3">flight = FindFlightById(id);
  if (flight != null) {
</span><strong class="bold"><span class="koboSpan" id="kobo.826.1">    flight.DepartureTime = newDepartureTime;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.827.1">    flight.Status = FlightStatus.Delayed;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.828.1">    Console.WriteLine($"{id} delayed until        {Format(newDepartureTime)}");</span></strong><span class="koboSpan" id="kobo.829.1">
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.830.1">This method does a few </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">discrete things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.832.1">It searches for a flight by </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">its ID</span></span></li>
<li><span class="koboSpan" id="kobo.834.1">If it finds the flight, it updates the properties on the flight and writes out </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">the delay</span></span></li>
<li><span class="koboSpan" id="kobo.836.1">If the flight can’t be </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.837.1">found, a warning is written to </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">the console</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.839.1">On its own, this method is fine. </span><span class="koboSpan" id="kobo.839.2">Let’s look at </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">MarkFlightDeparted</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.841.1"> now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.842.1">
public Flight? </span><span class="koboSpan" id="kobo.842.2">MarkFlightDeparted(string id,
  DateTime departureTime) {
  Flight? </span><span class="koboSpan" id="kobo.842.3">flight = FindFlightById(id);
  if (flight != null) {
</span><strong class="bold"><span class="koboSpan" id="kobo.843.1">    flight.DepartureTime = departureTime;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.844.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.845.1">flight.Status = FlightStatus.Departed;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.846.1">    Console.WriteLine($"{id} departed at {Format(departureTime)}.");</span></strong><span class="koboSpan" id="kobo.847.1">
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.848.1">Compare this method to the last one and you’ll see that there are few differences between them. </span><span class="koboSpan" id="kobo.848.2">The method still must find a flight by its ID, check to see whether the flight was found or not, and update the flight. </span><span class="koboSpan" id="kobo.848.3">The only difference in this method is what updates occur to the flight and what message gets written to </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">Let’s round out our look at these methods with a look </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">MarkFlightArrived</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.854.1">
public Flight? </span><span class="koboSpan" id="kobo.854.2">MarkFlightArrived(string id,
  DateTime arrivalTime, string gate = "TBD") {
  Flight? </span><span class="koboSpan" id="kobo.854.3">flight = FindFlightById(id);
  if (flight != null) {
</span><strong class="bold"><span class="koboSpan" id="kobo.855.1">    flight.ArrivalTime = arrivalTime;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.856.1">    flight.Gate = gate;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.857.1">    flight.Status = FlightStatus.OnTime;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.858.1">    Console.WriteLine($"{id} arrived at {Format(arrivalTime)}.");</span></strong><span class="koboSpan" id="kobo.859.1">
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.860.1">Here, the pattern repeats itself. </span><span class="koboSpan" id="kobo.860.2">The only </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.861.1">major difference between these three methods is what happens if the flight </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">is found.</span></span></p>
<p><span class="koboSpan" id="kobo.863.1">Thinking about it in that way, consider our logic with the </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">following pseudocode:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.865.1">
Flight? </span><span class="koboSpan" id="kobo.865.2">flight = FindFlightById(id);
if (flight != null) {
  </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">ApplyUpdateToFlight(flight);</span></strong><span class="koboSpan" id="kobo.867.1">
} else {
  Console.WriteLine($"{id} could not be found");
}
return flight;</span></pre>
<p><span class="koboSpan" id="kobo.868.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">ApplyUpdateToFlight</span></strong><span class="koboSpan" id="kobo.870.1"> is a placeholder for some method or function we could apply to the flight object. </span><span class="koboSpan" id="kobo.870.2">This is because the </span><em class="italic"><span class="koboSpan" id="kobo.871.1">action</span></em><span class="koboSpan" id="kobo.872.1"> we take turns out to be the only thing that </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">varies here.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">In fact, .NET has a class called an </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">Action</span></strong><span class="koboSpan" id="kobo.876.1"> that can serve this </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">very purpose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
private Flight? </span><span class="koboSpan" id="kobo.878.2">UpdateFlight(string id,
  </span><strong class="bold"><span class="koboSpan" id="kobo.879.1">Action&lt;Flight&gt; updateAction</span></strong><span class="koboSpan" id="kobo.880.1">) {
  Flight? </span><span class="koboSpan" id="kobo.880.2">flight = FindFlightById(id);
  if (flight != null) {
    </span><strong class="bold"><span class="koboSpan" id="kobo.881.1">updateAction(flight);</span></strong><span class="koboSpan" id="kobo.882.1">
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.883.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">updateAction</span></strong><span class="koboSpan" id="kobo.885.1"> parameter represents a specific function that can be called. </span><span class="koboSpan" id="kobo.885.2">What function is it? </span><span class="koboSpan" id="kobo.885.3">We don’t know. </span><span class="koboSpan" id="kobo.885.4">The</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.886.1"> exact function will be provided by whoever called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">UpdateFlight</span></strong><span class="koboSpan" id="kobo.888.1"> method – just like any </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">other parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">However, because </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">updateAction</span></strong><span class="koboSpan" id="kobo.892.1"> is defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">Action&lt;Flight&gt;</span></strong><span class="koboSpan" id="kobo.894.1">, we know that the function takes in a single parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">Flight</span></strong><span class="koboSpan" id="kobo.896.1"> type, which is why we can provide that parameter to the function when we invoke it inside </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">this method.</span></span></p>
<p><span class="koboSpan" id="kobo.898.1">To help the idea of </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">Action</span></strong><span class="koboSpan" id="kobo.900.1"> syntax sink in a little more, let’s see a few </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">other signatures:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">Action&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.903.1"> – A function taking in a single </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">integer parameter</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">Action&lt;string, bool&gt;</span></strong><span class="koboSpan" id="kobo.906.1"> – A function taking in a string and then </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">a boolean</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">Action</span></strong><span class="koboSpan" id="kobo.909.1"> – A function taking in no parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">at all</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.911.1">Now that declaring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">Action</span></strong><span class="koboSpan" id="kobo.913.1"> parameters makes a little more sense syntactically, let’s see how one of our old methods might be updated to use this </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">new method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.915.1">
public Flight? </span><span class="koboSpan" id="kobo.915.2">MarkFlightDelayed(string id,
  DateTime newDepartureTime) {
  return </span><strong class="bold"><span class="koboSpan" id="kobo.916.1">UpdateFlight(id, (flight) =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.917.1">    flight.DepartureTime = newDepartureTime;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.918.1">    flight.Status = FlightStatus.Delayed;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.919.1">    Console.WriteLine($"{id} delayed to {Format(newDepartureTime)}");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.920.1">  });</span></strong><span class="koboSpan" id="kobo.921.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.922.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">MarkFlightDelayed</span></strong><span class="koboSpan" id="kobo.924.1"> method calls directly into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">UpdateFlight</span></strong><span class="koboSpan" id="kobo.926.1"> method and provides an </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">Action&lt;Flight&gt;</span></strong><span class="koboSpan" id="kobo.928.1"> in the form of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">(flight) =&gt; { }</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.930.1">syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">UpdateFlight</span></strong><span class="koboSpan" id="kobo.933.1"> method</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.934.1"> runs, it checks to see whether the flight exists and, if it does, the method calls the arrow function we provided to actually update </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">the flight.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">If the syntax of this is difficult, here’s a different way of representing the same thing, by using a local variable to hold </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">Action&lt;Flight&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.940.1">Action&lt;Flight&gt; updateAction = (flight) =&gt; {</span></strong><span class="koboSpan" id="kobo.941.1">
  flight.DepartureTime = newDepartureTime;
  flight.Status = FlightStatus.Delayed;
  Console.WriteLine($"{id} delayed to {Format(newDepartureTime)}");
</span><strong class="bold"><span class="koboSpan" id="kobo.942.1">};</span></strong><span class="koboSpan" id="kobo.943.1">
return UpdateFlight(id, </span><strong class="bold"><span class="koboSpan" id="kobo.944.1">updateAction</span></strong><span class="koboSpan" id="kobo.945.1">);</span></pre>
<p><span class="koboSpan" id="kobo.946.1">It’s undoubtedly possible to have a happy and productive career as a developer without declaring an </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">Action</span></strong><span class="koboSpan" id="kobo.948.1"> variable. </span><span class="koboSpan" id="kobo.948.2">However, I’ve found that when I’m able to think in terms of discrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">Actions</span></strong><span class="koboSpan" id="kobo.950.1">, it can open some very interesting and flexible solutions </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">to problems.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.952.1">Returning data from Actions with Funcs</span></h2>
<p><span class="koboSpan" id="kobo.953.1">Before we move on to talking</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.954.1"> about static and extension methods, let’s take a brief look </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">Funcs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.958.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.959.1">Func</span></strong><span class="koboSpan" id="kobo.960.1"> is very </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.961.1">similar to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">Action</span></strong><span class="koboSpan" id="kobo.963.1"> in that it represents a </span><em class="italic"><span class="koboSpan" id="kobo.964.1">function</span></em><span class="koboSpan" id="kobo.965.1"> that can be invoked and potentially passed parameters. </span><span class="koboSpan" id="kobo.965.2">However, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">Actions</span></strong><span class="koboSpan" id="kobo.967.1"> do not return any results, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">Funcs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.969.1"> do.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">Let’s examine a simple C# method that </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.971.1">adds two numbers together and displays their result in an </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">equation string:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.974.1">void</span></strong><span class="koboSpan" id="kobo.975.1"> AddAction(</span><strong class="bold"><span class="koboSpan" id="kobo.976.1">int</span></strong><span class="koboSpan" id="kobo.977.1"> x, </span><strong class="bold"><span class="koboSpan" id="kobo.978.1">int</span></strong><span class="koboSpan" id="kobo.979.1"> y) {
    int sum = x + y;
    Console.WriteLine($"{x} + {y} is {sum}");
}</span></pre>
<p><span class="koboSpan" id="kobo.980.1">This method has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">void</span></strong><span class="koboSpan" id="kobo.982.1"> return type, meaning it doesn’t return any value. </span><span class="koboSpan" id="kobo.982.2">As a result, it could be stored in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">Action</span></strong><span class="koboSpan" id="kobo.984.1"> and invoked in </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">that way:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.986.1">Action&lt;int, int&gt;</span></strong><span class="koboSpan" id="kobo.987.1"> myAction = AddAction;
myAction(2, 2);</span></pre>
<p><span class="koboSpan" id="kobo.988.1">Now, let’s look at a slightly different version of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">Add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.990.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.991.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.992.1">string</span></strong><span class="koboSpan" id="kobo.993.1"> AddFunc(</span><strong class="bold"><span class="koboSpan" id="kobo.994.1">int</span></strong><span class="koboSpan" id="kobo.995.1"> x, </span><strong class="bold"><span class="koboSpan" id="kobo.996.1">int</span></strong><span class="koboSpan" id="kobo.997.1"> y) {
    int sum = x + y;
    return $"{x} + {y} is {sum}";
}</span></pre>
<p><span class="koboSpan" id="kobo.998.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">AddFunc</span></strong><span class="koboSpan" id="kobo.1000.1"> has a return type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">string</span></strong><span class="koboSpan" id="kobo.1002.1">. </span><span class="koboSpan" id="kobo.1002.2">Because the method no longer returns a void, it can no longer be considered an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">Action</span></strong><span class="koboSpan" id="kobo.1004.1"> and is now considered a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">Func</span></strong><span class="koboSpan" id="kobo.1006.1"> because it returns </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">some value.</span></span></p>
<p><span class="koboSpan" id="kobo.1008.1">As a result, if we wanted to store a reference to this method, we’d need to do so in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">Func</span></strong><span class="koboSpan" id="kobo.1010.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1012.1">Func&lt;int, int, string&gt;</span></strong><span class="koboSpan" id="kobo.1013.1"> myFunc = AddFunc;
</span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">string</span></strong><span class="koboSpan" id="kobo.1015.1"> equation = myFunc(2, 2);
Console.WriteLine(equation);</span></pre>
<p><span class="koboSpan" id="kobo.1016.1">Note that in addition to using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">Func</span></strong><span class="koboSpan" id="kobo.1018.1"> instead of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">Action</span></strong><span class="koboSpan" id="kobo.1020.1">, we now have a third </span><strong class="bold"><span class="koboSpan" id="kobo.1021.1">generic type parameter</span></strong><span class="koboSpan" id="kobo.1022.1"> that we’re</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.1023.1"> providing. </span><span class="koboSpan" id="kobo.1023.2">The last parameter to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">Func</span></strong><span class="koboSpan" id="kobo.1025.1"> represents the return type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">Func</span></strong><span class="koboSpan" id="kobo.1027.1">. </span><span class="koboSpan" id="kobo.1027.2">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">myFunc</span></strong><span class="koboSpan" id="kobo.1029.1">, the third generic type parameter indicates that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">AddFunc</span></strong><span class="koboSpan" id="kobo.1031.1"> returns </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">Action</span></strong><span class="koboSpan" id="kobo.1036.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">Func</span></strong><span class="koboSpan" id="kobo.1038.1"> are very closely related with the only significant difference being that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">Func</span></strong><span class="koboSpan" id="kobo.1040.1"> returns a value. </span><span class="koboSpan" id="kobo.1040.2">In practice, I tend to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">Action</span></strong><span class="koboSpan" id="kobo.1042.1"> when I want to accomplish something, such as in the </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.1043.1">earlier example of updating flights. </span><span class="koboSpan" id="kobo.1043.2">On the other hand, I tend to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">Func</span></strong><span class="koboSpan" id="kobo.1045.1"> to determine when to do something or how to get a specific value </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">I need.</span></span></p>
<p><span class="koboSpan" id="kobo.1047.1">For example, I might declare a method that takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">Func&lt;Flight, bool&gt;</span></strong><span class="koboSpan" id="kobo.1049.1"> that it uses to determine whether a flight from a list of flights should </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">be displayed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
public void DisplayMatchingFlights(List&lt;Flight&gt; flights,
  </span><strong class="bold"><span class="koboSpan" id="kobo.1052.1">Func&lt;Flight, bool&gt; shouldDisplay</span></strong><span class="koboSpan" id="kobo.1053.1">) {
  foreach (Flight flight in flights) {
    if (</span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">shouldDisplay(flight)</span></strong><span class="koboSpan" id="kobo.1055.1">) {
      Console.WriteLine(flight);
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1056.1">This method calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">shouldDisplay</span></strong><span class="koboSpan" id="kobo.1058.1"> Func for every flight in the list in order to determine whether it should be displayed. </span><span class="koboSpan" id="kobo.1058.2">Flights only display if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">shouldDisplay</span></strong><span class="koboSpan" id="kobo.1060.1"> Func returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">true</span></strong><span class="koboSpan" id="kobo.1062.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">that flight.</span></span></p>
<p><span class="koboSpan" id="kobo.1064.1">This structure allows the same method to be used for different scenarios, including </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1066.1">Listing </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">upcoming flights</span></span></li>
<li><span class="koboSpan" id="kobo.1068.1">Listing </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">delayed flights</span></span></li>
<li><span class="koboSpan" id="kobo.1070.1">Listing flights heading to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">specific airport</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1072.1">The only difference between these is what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">shouldDisplay</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1074.1">parameter holds.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.1075.1">Introducing static methods and extension methods</span></h1>
<p><span class="koboSpan" id="kobo.1076.1">Now that we’ve explored some of the more functional aspects of method refactoring, let’s take a look at some of the features that helped revolutionize .NET: </span><strong class="bold"><span class="koboSpan" id="kobo.1077.1">static methods</span></strong><span class="koboSpan" id="kobo.1078.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1079.1">extension methods</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.1081.1">Making methods static</span></h2>
<p><span class="koboSpan" id="kobo.1082.1">Sometimes, your classes will </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.1083.1">have methods that don’t work directly with instance members (fields, properties, or non-static methods) of that class. </span><span class="koboSpan" id="kobo.1083.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.1085.1"> has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">Format</span></strong><span class="koboSpan" id="kobo.1087.1"> method that converts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">DateTime</span></strong><span class="koboSpan" id="kobo.1089.1"> to a string resembling “Wed Jul 12 </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">23:14 PM”:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1091.1">
private string Format(DateTime time) {
    return time.ToString("ddd MMM dd HH:mm tt");
}</span></pre>
<p><span class="koboSpan" id="kobo.1092.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">Format</span></strong><span class="koboSpan" id="kobo.1094.1"> doesn’t rely on anything other than the parameters it is provided to calculate a result. </span><span class="koboSpan" id="kobo.1094.2">Because of this, we can make </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">Format</span></strong><span class="koboSpan" id="kobo.1096.1"> a </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">static method.</span></span></p>
<p><span class="koboSpan" id="kobo.1098.1">Static methods are methods associated with the class itself and not with an instance of the class. </span><span class="koboSpan" id="kobo.1098.2">As a result, you don’t need to instantiate an instance of the class to call them. </span><span class="koboSpan" id="kobo.1098.3">The C# compiler is also able to make occasional optimizations surrounding static code that can result in </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">faster code.</span></span></p>
<p><span class="koboSpan" id="kobo.1100.1">Typically, static methods can also be </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.1101.1">considered </span><strong class="bold"><span class="koboSpan" id="kobo.1102.1">pure methods</span></strong><span class="koboSpan" id="kobo.1103.1"> – that is to say, methods without direct side effects that always produce the same result when given the </span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">same input.</span></span></p>
<p><span class="koboSpan" id="kobo.1105.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1106.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1107.1">.14</span></em><span class="koboSpan" id="kobo.1108.1">, you can mark a method as static by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">static</span></strong><span class="koboSpan" id="kobo.1110.1"> keyword after the access modifier or by choosing the </span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">Make static</span></strong><span class="koboSpan" id="kobo.1112.1"> option on the </span><strong class="bold"><span class="koboSpan" id="kobo.1113.1">Quick </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1114.1">Actions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1"> menu:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.1116.1"><img alt="Figure 4.15 – Moving a method to a static method" src="image/B21324_04_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1117.1">Figure 4.15 – Moving a method to a static method</span></p>
<p><span class="koboSpan" id="kobo.1118.1">The static version of </span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">Format</span></strong><span class="koboSpan" id="kobo.1120.1"> looks very</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.1121.1"> similar and works </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">almost identically:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1123.1">
private </span><strong class="bold"><span class="koboSpan" id="kobo.1124.1">static </span></strong><span class="koboSpan" id="kobo.1125.1">string Format(DateTime time) {
    return time.ToString("ddd MMM dd HH:mm tt");
}</span></pre>
<p><span class="koboSpan" id="kobo.1126.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">Format</span></strong><span class="koboSpan" id="kobo.1128.1"> method can still be called simply with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">Format(DateTime.Now)</span></strong><span class="koboSpan" id="kobo.1130.1"> as it could before, but adding static also allows you to call it from the class itself, such </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">FlightTracker.Format(DateTime.Now)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1134.1">Marking a method as static has a </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">few advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1136.1">The compiler can make optimizations resulting in faster </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">runtime performance</span></span></li>
<li><span class="koboSpan" id="kobo.1138.1">Code can call the static method without needing to instantiate </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">the class</span></span></li>
<li><span class="koboSpan" id="kobo.1140.1">The static method could be converted to an extension method, as we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">see later</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1142.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">static</span></strong><span class="koboSpan" id="kobo.1144.1"> keyword may seem like a great thing to use everywhere you can due to these added features. </span><span class="koboSpan" id="kobo.1144.2">Unfortunately, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">static</span></strong><span class="koboSpan" id="kobo.1146.1"> has some drawbacks as well. </span><span class="koboSpan" id="kobo.1146.2">Marking a method as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">static</span></strong><span class="koboSpan" id="kobo.1148.1"> also means it can no longer call non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">static</span></strong><span class="koboSpan" id="kobo.1150.1"> methods or access </span><span class="No-Break"><span class="koboSpan" id="kobo.1151.1">instance-level data.</span></span></p>
<p><span class="koboSpan" id="kobo.1152.1">There are certainly many uses for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">static</span></strong><span class="koboSpan" id="kobo.1154.1">, but it’s still something that many developers find distasteful or consider an anti-pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">in excess.</span></span></p>
<p><span class="koboSpan" id="kobo.1156.1">Personally, I find </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">static</span></strong><span class="koboSpan" id="kobo.1158.1"> is appropriate for “helper methods” and, in some cases, to simplify unit testing complex classes that can be complex to instantiate in testing scenarios. </span><span class="koboSpan" id="kobo.1158.2">However, I draw the line at making fields </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">static</span></strong><span class="koboSpan" id="kobo.1160.1"> whenever possible, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">static</span></strong><span class="koboSpan" id="kobo.1162.1"> data can lead to </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.1163.1">many problems in developing and </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">testing applications.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1165.1">Moving static members to another type</span></h2>
<p><span class="koboSpan" id="kobo.1166.1">Sometimes, it doesn’t make sense</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.1167.1"> for a static method to remain in the class it </span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">started in.</span></span></p>
<p><span class="koboSpan" id="kobo.1169.1">For example, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">Format</span></strong><span class="koboSpan" id="kobo.1171.1"> method takes any </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">DateTime</span></strong><span class="koboSpan" id="kobo.1173.1"> and returns a customized string appropriate to Cloudy Skies Airlines’ business needs. </span><span class="koboSpan" id="kobo.1173.2">This logic is currently inside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.1175.1"> class, and yet is completely unrelated to tracking flights and could be useful to have in any number of places throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1">their application.</span></span></p>
<p><span class="koboSpan" id="kobo.1177.1">In this scenario, it makes sense to pull </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">Format</span></strong><span class="koboSpan" id="kobo.1179.1"> into a different class where other developers can more readily discover these </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">formatting capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.1181.1">Visual Studio provides a built-in refactoring for this. </span><span class="koboSpan" id="kobo.1181.2">To use it, select a static method and open the </span><strong class="bold"><span class="koboSpan" id="kobo.1182.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.1183.1"> menu, then click </span><strong class="bold"><span class="koboSpan" id="kobo.1184.1">Move static members to another type...</span></strong><span class="koboSpan" id="kobo.1185.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1186.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1187.1">.16</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.1189.1"><img alt="Figure 4.16 – Moving static members to another type" src="image/B21324_04_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1190.1">Figure 4.16 – Moving static members to another type</span></p>
<p><span class="koboSpan" id="kobo.1191.1">Next, you will be prompted to select the Type your static methods should be moved to. </span><span class="koboSpan" id="kobo.1191.2">This can be the name of a new class if you don’t currently have a class suitable for this. </span><span class="koboSpan" id="kobo.1191.3">For Cloudy Skies, there is no existing Type that should own this, so creating one named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">DateHelpers</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1193.1">makes sense.</span></span></p>
<p><span class="koboSpan" id="kobo.1194.1">Additionally, you will be asked to check or uncheck the static methods you want to move with an option to </span><strong class="bold"><span class="koboSpan" id="kobo.1195.1">Select Dependents</span></strong><span class="koboSpan" id="kobo.1196.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1197.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1198.1">.17</span></em><span class="koboSpan" id="kobo.1199.1">) and select any methods that your selected static </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">methods call:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.1201.1"><img alt="Figure 4.17 – Selecting the destination type and the members to move" src="image/B21324_04_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1202.1">Figure 4.17 – Selecting the destination type and the members to move</span></p>
<p><span class="koboSpan" id="kobo.1203.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.1204.1">OK</span></strong><span class="koboSpan" id="kobo.1205.1"> to move your</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.1206.1"> selected method and create a </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">new class.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1208.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1209.1">The current behavior of Visual Studio is to keep your method’s current access modifier and create the new static class as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">internal</span></strong><span class="koboSpan" id="kobo.1211.1">. </span><span class="koboSpan" id="kobo.1211.2">This may introduce compiler errors if your method was </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">private</span></strong><span class="koboSpan" id="kobo.1213.1">, as code at the old location will no longer be able to access your code. </span><span class="koboSpan" id="kobo.1213.2">I recommend changing your static class and its methods to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">public</span></strong><span class="koboSpan" id="kobo.1215.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">avoid issues.</span></span></p>
<p><span class="koboSpan" id="kobo.1217.1">Here’s the resulting </span><strong class="bold"><span class="koboSpan" id="kobo.1218.1">static class</span></strong><span class="koboSpan" id="kobo.1219.1"> after </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.1220.1">adjusting </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">its modifiers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1222.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.1223.1">static</span></strong><span class="koboSpan" id="kobo.1224.1"> class DateHelpers {
    public </span><strong class="bold"><span class="koboSpan" id="kobo.1225.1">static</span></strong><span class="koboSpan" id="kobo.1226.1"> string Format(DateTime time) {
        return time.ToString("ddd MMM dd HH:mm tt");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1227.1">Now we have a dedicated class just for “helper methods” associated with dates </span><span class="No-Break"><span class="koboSpan" id="kobo.1228.1">and times.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1229.1">Static classes</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1230.1">If you’re not familiar with static classes, a static class can only have static methods in it and cannot be instantiated or inherited from. </span><span class="koboSpan" id="kobo.1230.2">Static classes are required for </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">extension methods.</span></span></p>
<p><span class="koboSpan" id="kobo.1232.1">The refactoring we</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.1233.1"> just performed also updated any code that was using the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">Format</span></strong><span class="koboSpan" id="kobo.1235.1"> method to point to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">DateTimeHelpers.Format</span></strong><span class="koboSpan" id="kobo.1237.1">. </span><span class="koboSpan" id="kobo.1237.2">For example, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.1239.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.1241.1"> method’s flight logging now says </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">Console.WriteLine($"{id} arrived </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">at {DateHelpers.Format(arrivalTime)}.");</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1245.1">By pulling static members into their own dedicated type, we’ve created a home where date-related logic can live and help a wide variety of classes, and we’ve made our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.1247.1"> class more focused on its core job instead of being focused on date formatting as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">flight tracking.</span></span></p>
<p><span class="koboSpan" id="kobo.1249.1">Unfortunately, this change has somewhat hurt the readability of our code because callers must now specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">DateHelpers.Format</span></strong><span class="koboSpan" id="kobo.1251.1"> instead of just </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">Format</span></strong><span class="koboSpan" id="kobo.1253.1">. </span><span class="koboSpan" id="kobo.1253.2">An extension method can help with this, as we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">see next.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1255.1">Creating extension methods</span></h2>
<p><span class="koboSpan" id="kobo.1256.1">Extension methods allow</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.1257.1"> you to “extend” an existing Type by adding your own static methods that appear like they’re part of </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">that Type.</span></span></p>
<p><span class="koboSpan" id="kobo.1259.1">That might sound intimidating, but if you’ve used LINQ, you’ve seen extension methods in action. </span><span class="koboSpan" id="kobo.1259.2">Let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">FindFlightById</span></strong><span class="koboSpan" id="kobo.1261.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.1263.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1265.1">
private Flight? </span><span class="koboSpan" id="kobo.1265.2">FindFlightById(string id) =&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1266.1">_flights.FirstOrDefault(f =&gt; f.Id == id)</span></strong><span class="koboSpan" id="kobo.1267.1">;</span></pre>
<p><span class="koboSpan" id="kobo.1268.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">_flights</span></strong><span class="koboSpan" id="kobo.1270.1"> is defined as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">List&lt;Flight&gt;</span></strong><span class="koboSpan" id="kobo.1272.1">. </span><span class="koboSpan" id="kobo.1272.2">Given that the code to find a flight by its ID, it’s understandable to suspect that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">List</span></strong><span class="koboSpan" id="kobo.1274.1"> must have a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1276.1">; however, it </span><span class="No-Break"><span class="koboSpan" id="kobo.1277.1">does not.</span></span></p>
<p><span class="koboSpan" id="kobo.1278.1">Instead, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1280.1"> method is not defined on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">List&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1282.1"> type in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">System.Collections.Generic</span></strong><span class="koboSpan" id="kobo.1284.1"> namespace, but rather is defined as an extension method in a static class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">Enumerable</span></strong><span class="koboSpan" id="kobo.1286.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">System.Linq</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1"> namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.1289.1">In other words, it is </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.1290.1">perfectly feasible to rewrite our code from earlier to explicitly use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">Enumerable</span></strong><span class="koboSpan" id="kobo.1292.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1294.1">
private Flight? </span><span class="koboSpan" id="kobo.1294.2">FindFlightById(string id) =&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1295.1">Enumerable.FirstOrDefault(_flights, f =&gt; f.Id == id);</span></strong></pre>
<p><span class="koboSpan" id="kobo.1296.1">While this is perfectly valid code, nobody I’ve ever worked with writes code in this way because using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1297.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1298.1"> as an extension method is far more intuitive </span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">and readable.</span></span></p>
<p><span class="koboSpan" id="kobo.1300.1">This highlights the key point of extension methods: </span><em class="italic"><span class="koboSpan" id="kobo.1301.1">extension methods allow you to add new features to existing classes in a way that appears like those methods were present on the object to begin with</span></em><span class="koboSpan" id="kobo.1302.1">, resulting in more </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">intuitive code.</span></span></p>
<p><span class="koboSpan" id="kobo.1304.1">To declare a method as an extension method, the following things must </span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1">be true:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1306.1">The method must </span><span class="No-Break"><span class="koboSpan" id="kobo.1307.1">be static</span></span></li>
<li><span class="koboSpan" id="kobo.1308.1">The method must be inside a </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">static class</span></span></li>
<li><span class="koboSpan" id="kobo.1310.1">The first parameter of the method must start with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1312.1"> keyword</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1313.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">DateHelpers</span></strong><span class="koboSpan" id="kobo.1315.1"> class and its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">Format</span></strong><span class="koboSpan" id="kobo.1317.1"> method are both static, which means we can convert the method to an extension method by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">this</span></strong><span class="koboSpan" id="kobo.1319.1"> keyword to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1320.1">method signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1321.1">
public static class DateHelpers {
    public static string Format(</span><strong class="bold"><span class="koboSpan" id="kobo.1322.1">this</span></strong><span class="koboSpan" id="kobo.1323.1"> DateTime time) {
        return time.ToString("ddd MMM dd HH:mm tt");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1324.1">Moving a static method to an extension method doesn’t mean you have to use it as an extension method and so our previous code will still compile. </span><span class="koboSpan" id="kobo.1324.2">However, in order to get the most value out of our extension method, we should update prior code to take advantage of its </span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">new syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.1326.1">Let’s take another look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">MarkFlightArrived</span></strong><span class="koboSpan" id="kobo.1328.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.1330.1">. </span><span class="koboSpan" id="kobo.1330.2">This time, if you delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">DateFormatHelpers.Format(arrivalTime)</span></strong><span class="koboSpan" id="kobo.1332.1">, instead write </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">arrivalTime.For</span></strong><span class="koboSpan" id="kobo.1334.1">, and </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.1335.1">allow Visual Studio’s </span><strong class="bold"><span class="koboSpan" id="kobo.1336.1">IntelliSense</span></strong><span class="koboSpan" id="kobo.1337.1"> to suggest values, it will list your new </span><span class="No-Break"><span class="koboSpan" id="kobo.1338.1">extension method:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.1339.1"><img alt="Figure 4.18 – IntelliSense suggesting the new extension method" src="image/B21324_04_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1340.1">Figure 4.18 – IntelliSense suggesting the new extension method</span></p>
<p><span class="koboSpan" id="kobo.1341.1">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">arrivalTime</span></strong><span class="koboSpan" id="kobo.1343.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">DateTime</span></strong><span class="koboSpan" id="kobo.1345.1"> and our extension method is built to work on any </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">DateTime</span></strong><span class="koboSpan" id="kobo.1347.1">, the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">Format</span></strong><span class="koboSpan" id="kobo.1349.1"> method we wrote appears here on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">DateTime</span></strong><span class="koboSpan" id="kobo.1351.1"> type provided in .NET through the power of </span><span class="No-Break"><span class="koboSpan" id="kobo.1352.1">extension methods.</span></span></p>
<p><span class="koboSpan" id="kobo.1353.1">Rewriting the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">arrivalTime.Format()</span></strong><span class="koboSpan" id="kobo.1355.1"> has the correct effect of calling out to the extension method, resulting in a far more </span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1">readable experience.</span></span></p>
<p><span class="koboSpan" id="kobo.1357.1">If you’d prefer, you can still call out to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">Format</span></strong><span class="koboSpan" id="kobo.1359.1"> method via </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">DateHelpers.Format(arrivalTime)</span></strong><span class="koboSpan" id="kobo.1361.1">. </span><span class="koboSpan" id="kobo.1361.2">Introducing an extension method just gives you another option for how your syntax </span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">is structured.</span></span></p>
<p><span class="koboSpan" id="kobo.1363.1">The downsides of extension methods are, primarily, </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1365.1">Extension methods require the use of static, which some teams avoid because it tends to spread throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">your code</span></span></li>
<li><span class="koboSpan" id="kobo.1367.1">It can be confusing that you’re using an </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">extension method</span></span></li>
<li><span class="koboSpan" id="kobo.1369.1">It can be confusing where the new extension methods </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">are defined</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1371.1">Thankfully, Visual Studio allows you to go to the definition of any method, member, or type simply by holding </span><em class="italic"><span class="koboSpan" id="kobo.1372.1">Ctrl</span></em><span class="koboSpan" id="kobo.1373.1"> and clicking on the item you want to navigate to. </span><span class="koboSpan" id="kobo.1373.2">Alternatively, you can select the identifier and press </span><em class="italic"><span class="koboSpan" id="kobo.1374.1">F12</span></em><span class="koboSpan" id="kobo.1375.1"> on your keyboard or right-click on it and choose </span><strong class="bold"><span class="koboSpan" id="kobo.1376.1">Go To Definition</span></strong><span class="koboSpan" id="kobo.1377.1"> to navigate to where the extension method </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">is declared.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.1379.1">Reviewing and testing our refactored code</span></h1>
<p><span class="koboSpan" id="kobo.1380.1">Over the course of this chapter, we took a repetitive </span><strong class="source-inline"><span class="koboSpan" id="kobo.1381.1">FlightTracker</span></strong><span class="koboSpan" id="kobo.1382.1"> class and restructured it to ensure that its method </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.1383.1">signatures were more consistent and that common logic was reused </span><span class="No-Break"><span class="koboSpan" id="kobo.1384.1">wherever possible.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1385.1">Refactored code</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1386.1">The final refactored code from this chapter is available in the </span><a href="https://github.com/PacktPublishing/Refactoring-with-CSharp"><span class="koboSpan" id="kobo.1387.1">https://github.com/PacktPublishing/Refactoring-with-CSharp</span></a><span class="koboSpan" id="kobo.1388.1"> repository inside of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">Chapter04/Ch4RefactoredCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1390.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1391.1">Before we move on, we should ensure that all tests still pass by running the unit tests from the </span><strong class="bold"><span class="koboSpan" id="kobo.1392.1">Test</span></strong><span class="koboSpan" id="kobo.1393.1"> menu and then selecting the </span><strong class="bold"><span class="koboSpan" id="kobo.1394.1">Run All Tests</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1395.1">menu item.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.1396.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1397.1">In this chapter, we saw how various methods, constructors, and parameter refactorings can be applied to keep your code orderly. </span><span class="koboSpan" id="kobo.1397.2">We saw how overloading and chaining together methods and constructors gives you more options, while renaming, adding, removing, and reordering parameters helps </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">ensure consistency.</span></span></p>
<p><span class="koboSpan" id="kobo.1399.1">Near the end of this chapter, we covered </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">Actions</span></strong><span class="koboSpan" id="kobo.1401.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">Funcs</span></strong><span class="koboSpan" id="kobo.1403.1">, static methods, and extension methods, and showed how thinking about your code in terms of small, reusable functions can help solve certain types of problems </span><span class="No-Break"><span class="koboSpan" id="kobo.1404.1">more effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.1405.1">In the next chapter, we’ll cover object-oriented refactoring techniques and revisit our parameter refactorings in this chapter by exploring how large sets of parameters can be brought under control by </span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">extracting classes.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.1407.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1408.1">Are there any areas of your code where you seem to be confused more frequently by the parameter ordering </span><span class="No-Break"><span class="koboSpan" id="kobo.1409.1">or naming?</span></span></li>
<li><span class="koboSpan" id="kobo.1410.1">Can you think of any places in your code where slightly different actions are performed based on the same or similar conditions? </span><span class="koboSpan" id="kobo.1410.2">If so, does moving to use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">Action</span></strong><span class="koboSpan" id="kobo.1412.1"> or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">Func</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1414.1">make sense?</span></span></li>
<li><span class="koboSpan" id="kobo.1415.1">Does your code have a set of “helper methods” that might make sense to make static and put into a static class? </span><span class="koboSpan" id="kobo.1415.2">If so, would switching to extension methods improve your </span><span class="No-Break"><span class="koboSpan" id="kobo.1416.1">code elsewhere?</span></span></li>
</ol>
<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1417.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1418.1">You can find more information about the materials discussed in this chapter at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">following URLs:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1420.1">Refactor into pure </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1421.1">functions</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1422.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions"><span class="No-Break"><span class="koboSpan" id="kobo.1423.1">https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1424.1">Action-Oriented </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1425.1">C#</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">: </span></span><a href="https://killalldefects.com/2019/09/15/action-oriented-c/"><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">https://killalldefects.com/2019/09/15/action-oriented-c/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1428.1">Refactor using an extension </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1429.1">method</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1430.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method"><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1432.1">Named and Optional </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1433.1">Arguments</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1434.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments"><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments</span></span></a></li>
</ul>
</div>
</body></html>