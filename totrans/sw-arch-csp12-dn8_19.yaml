- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: 'Client Frameworks: Blazor'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端框架：Blazor
- en: In this chapter, you will learn how to implement presentation layers based on
    client technologies. Applications based on server technologies, like ASP.NET Core
    MVC, run all application layers on the server, thus also creating on the server
    the HTML that encodes the whole UI. Applications based on client technologies,
    instead, run the whole presentation layer on the client machine (mobile device,
    desktop computer, laptop, etc.) thus interacting with a server just to exchange
    data with the web API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何基于客户端技术实现表示层。基于服务器技术的应用程序，如 ASP.NET Core MVC，在服务器上运行所有应用程序层，因此也在服务器上创建
    HTML，以编码整个 UI。相反，基于客户端技术的应用程序在客户端机器（移动设备、桌面计算机、笔记本电脑等）上运行整个表示层，因此仅与服务器交互以交换与 Web
    API 的数据。
- en: In other words, in an application based on client technology, the whole UI is
    created by code that runs on the user device, which also controls the whole user-application
    interaction. Both the business layer and the domain layer, instead, run on server
    machines to prevent users from violating business rules and authorization policies
    by hacking the code that runs on their devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在基于客户端技术的应用程序中，整个 UI 都是由在用户设备上运行的代码创建的，它也控制着整个用户-应用程序交互。相反，业务层和领域层在服务器机器上运行，以防止用户通过破解其设备上运行的代码来违反业务规则和授权策略。
- en: In turn, applications based on client technologies can be classified as single-page
    applications, which benefit from web standards, or as native applications, which
    are tied to specific operating systems and the advantages of specific device peculiarities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于客户端技术的应用程序可以分为单页应用程序，它们受益于 Web 标准，或者作为原生应用程序，它们与特定的操作系统和特定设备特性的优势相关联。
- en: Single-page applications are based on JavaScript or WebAssembly and run in any
    browser. As an example of a single-page application, we will analyze the Blazor
    WebAssembly framework
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序基于 JavaScript 或 WebAssembly，并在任何浏览器中运行。作为一个单页应用程序的例子，我们将分析 Blazor WebAssembly
    框架
- en: Blazor WebAssembly applications are developed in C# and use many technologies
    we already analyzed in *Chapter 17*, *Presenting ASP.NET Core*, such as dependency
    injection and Razor. Therefore, we strongly recommend studying *Chapter 17*, *Presenting
    ASP.NET Core*, and *Chapter 18*, *Implementing Frontend Microservices with ASP.NET
    Core*, before reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 应用程序是用 C# 开发的，并使用我们在第 17 章“展示 ASP.NET Core”中已经分析过的许多技术，例如依赖注入和
    Razor。因此，我们强烈建议在阅读本章之前学习第 17 章“展示 ASP.NET Core”和第 18 章“使用 ASP.NET Core 实现前端微服务”。
- en: As an example of native technologies, we will analyze native .NET MAUI Blazor,
    which is completely analogous to Blazor WebAssembly but instead of using browser
    WebAssembly, it uses .NET, which is compiled just in time into the assembly of
    the target device. Not being limited by browser restrictions, .NET MAUI Blazor
    can access all device features through adequate .NET libraries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为原生技术的例子，我们将分析原生 .NET MAUI Blazor，它与 Blazor WebAssembly 完全类似，但不是使用浏览器 WebAssembly，而是使用
    .NET，它即时编译成目标设备的程序集。不受浏览器限制，.NET MAUI Blazor 可以通过适当的 .NET 库访问所有设备功能。
- en: 'More specifically, in this chapter, you will learn about the following subjects:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，你将学习以下主题：
- en: Comparison of the various types of client technologies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种客户端技术的比较
- en: Blazor WebAssembly architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 架构
- en: Blazor pages and components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 页面和组件
- en: Blazor forms and validation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 表单和验证
- en: Blazor advanced features, such as JavaScript interoperability, globalization,
    authentication, and more
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 的高级功能，例如 JavaScript 互操作性、全球化、身份验证等
- en: Third-party tools for Blazor WebAssembly
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 的第三方工具
- en: .NET MAUI Blazor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI Blazor
- en: While there is also server-side Blazor, which runs on the server like ASP.NET
    Core MVC, this chapter discusses just Blazor WebAssembly and .NET MAUI Blazor,
    since the main focus of the chapter is client-side technology. Moreover, server-side
    Blazor can’t provide a performance that is comparable with other server-side technologies,
    like ASP.NET Core MVC, which we analyzed in *Chapter 17*, *Presenting ASP.NET
    Core*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然也存在服务器端 Blazor，它像 ASP.NET Core MVC 一样在服务器上运行，但本章仅讨论 Blazor WebAssembly 和 .NET
    MAUI Blazor，因为本章的主要重点是客户端技术。此外，服务器端 Blazor 无法提供与其他服务器端技术（如我们在第 17 章“展示 ASP.NET
    Core”中分析过的 ASP.NET Core MVC）相当的性能。
- en: The first section summarizes and compares the various kinds of client technologies,
    while the remainder of the chapter discusses in detail Blazor WebAssembly and
    .NET MAUI Blazor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分总结了并比较了各种类型的客户端技术，而本章的其余部分详细讨论了Blazor WebAssembly和.NET MAUI Blazor。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2022 Community edition or better
    with all the database tools installed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费Visual Studio 2022 Community版或更高版本，并安装所有数据库工具。
- en: All concepts are clarified with simple example applications based on the WWTravelClub
    book use case you can find in the *Using client technologies* section of *Chapter
    21*, *Case Study*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有概念都通过基于WWTravelClub书籍用例的简单示例应用程序进行了阐明，这些用例可以在第21章*案例研究*的*使用客户端技术*部分找到。
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到。
- en: Comparison of the various types of client technologies
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端技术类型比较
- en: 'This section discusses the various types of client technologies:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了各种类型的客户端技术：
- en: Single-page applications, which run in the browser with all browser restrictions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序，在浏览器中运行，但受到所有浏览器限制
- en: Progressive applications, which run in the browser but can be installed like
    usual applications and can overcome some browser restrictions (after user permission
    is granted)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式应用程序，在浏览器中运行但可以像常规应用程序一样安装，并且可以克服一些浏览器限制（在用户授权后）
- en: Native applications, which are tied to a specific device/operating system but
    can take full advantage of all device/operating system features
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生应用程序，与特定设备/操作系统绑定，但可以充分利用所有设备/操作系统功能
- en: Cross-platform technologies, which, like native applications, can take full
    advantage of all device features but are compatible with several devices/operating
    systems
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台技术，类似于原生应用程序，可以充分利用所有设备功能，但与多种设备/操作系统兼容
- en: Single-page applications
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: There are many reasons why web development has increased in recent decades,
    but the most basic one is the ability to deploy any new version of the application
    to many users at the same time. Moreover, the security policies that are automatically
    enforced by all browsers encourage the usage and diffusion of web applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 近几十年来，网络开发之所以增长迅速，有许多原因，但最基本的一个原因是能够同时将任何新版本的应用程序部署给许多用户。此外，所有浏览器自动执行的安全策略鼓励了网络应用程序的使用和传播。
- en: So, a good question here would be, why is web development not used today? The
    best answer would be a lack of connectivity. As a software architect, you need
    to be alert to this, as we discussed in *Chapter 2*, *Non-Functional Requirements*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的一个好问题是，为什么现在不使用网络开发？最好的答案可能是缺乏连接性。作为一名软件架构师，你需要对此保持警惕，正如我们在第2章*非功能性需求*中讨论的那样。
- en: Sometimes, it is not only a matter of having connectivity or not. Sometimes,
    a big problem is instability, and don’t forget the difficulties you will encounter
    from unexpected scenarios that web apps will generate once they’re out in the
    world.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，问题不仅仅是关于是否有连接性。有时候，一个大问题是稳定性，别忘了你将在网络应用一旦进入世界后遇到的不预期的场景中遇到的困难。
- en: 'For instance, in the WWTravelClub case, there is a first user story that says:
    *“As a common user, I want to view promotional packages on the home page, so that
    I can easily find my next vacation.”* At first sight, you may determine that a
    web app is the only option, especially because there is also a system requirement
    that says: *“The system will run on the Windows, Linux, iOS, and Android platforms.”*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在WWTravelClub案例中，有一个用户故事说：“作为一个普通用户，我想在主页上查看促销套餐，这样我可以轻松找到我的下一个假期。”乍一看，你可能会确定网络应用是唯一的选择，尤其是因为还有一个系统要求说：“系统将在Windows、Linux、iOS和Android平台上运行。”
- en: However, imagine that a user browsed a lot of destinations and packages to find
    their perfect vacation, and they are going to reserve it when suddenly, the web
    application crashes because of a lack of web connectivity. In this situation,
    the user would lose all their browsing effort and would be forced to start searching
    for the package from scratch once web connectivity is restored. The issue can
    be overcome just with an application that is able to save its state instead of
    crashing when there are web connectivity issues. This way, the user can complete
    their task as soon as web connectivity is restored, without wasting whatever effort
    they had already put in before the web connectivity issue.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，想象一下，一个用户浏览了很多目的地和套餐以找到他们理想的假期，当他们准备预订时，突然，由于网络连接问题，网络应用程序崩溃了。在这种情况下，用户将失去他们所有的浏览努力，并且一旦网络连接恢复，他们被迫重新从零开始搜索套餐。只需一个能够在网络连接问题时保存其状态而不是崩溃的应用程序，就可以解决这个问题。这样，用户就可以在恢复网络连接后立即完成任务，而不会浪费他们在网络连接问题之前已经投入的努力。
- en: So maybe, for some parts of the solution, a native application with some data
    already downloaded would be a better option. However, the issue can also be solved
    with a particular kind of modern web application, progressive applications, which
    we will analyze in the next subsection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，也许对于解决方案的一些部分，一个已经下载了一些数据的原生应用会是一个更好的选择。然而，这个问题也可以通过一种特定的现代网络应用，即进步式应用来解决，我们将在下一小节中分析。
- en: Progressive applications
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进步式应用
- en: Progressive web applications are single-page applications that run in the browser
    but can be installed like native applications. Moreover, they can run offline.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 进步式网络应用是运行在浏览器中的单页应用，但可以像原生应用一样安装。此外，它们还可以离线运行。
- en: Progressive applications are a new web standard that is supported by all mainstream
    browsers. If you require all the advantages of web applications, but you also
    need the ability to work offline like a native application, progressive web applications
    are the right choice for you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 进步式应用是所有主流浏览器都支持的新网络标准。如果你需要所有网络应用的优势，但同时也需要像原生应用一样离线工作的能力，进步式网络应用是你正确的选择。
- en: However, keep in mind that progressive web applications can’t ensure the same
    performance and flexibility as native applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，进步式网络应用无法保证与原生应用相同的性能和灵活性。
- en: Blazor WebAssembly, as we will describe in the next sections of this chapter,
    supports progressive web applications. Check the **Progressive Web Application**
    checkbox that appears when you create a Blazor WebAssembly project. This is all
    you need to do to create a Blazor progressive web application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly，正如我们将在本章下一节中描述的，支持进步式网络应用。当你创建 Blazor WebAssembly 项目时，请勾选出现的**进步式网络应用**复选框。这就是创建
    Blazor 进步式网络应用所需的所有操作。
- en: If you ship your Blazor application as a progressive application, you overcome
    the problem of the initial download time (4-8 seconds), which is the main disadvantage
    of Blazor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你的 Blazor 应用程序作为进步式应用程序发布，你就可以克服初始下载时间（4-8秒）的问题，这是 Blazor 的主要缺点。
- en: While progressive web applications are installed applications, they automatically
    update to the last available version, because each time they are launched, they
    verify if a more recent version is available, and if there is one, they automatically
    download it before running. That is, they have the advantage of automatically
    running the most recent available version that characterizes all classical web
    applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然进步式网络应用是已安装的应用程序，但它们会自动更新到最新版本，因为每次它们启动时，它们都会检查是否有更新的版本可用，如果有，它们会在运行前自动下载。也就是说，它们具有自动运行最新可用版本的优点，这是所有经典网络应用的特征。
- en: The option to install the Blazor progressive web application is not available
    during development because this would interfere with the usual modification test
    cycle. Therefore, you need to publish your application to test its progressive
    application peculiarities.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，无法选择安装 Blazor 进步式网络应用，因为这会干扰常规的修改测试周期。因此，你需要发布你的应用程序以测试其进步式应用的特性。
- en: It is worth pointing out that progressive applications must be organized to
    take full advantage of their ability to work offline. Therefore, following repeated
    communication errors, the application should save all the data to be sent to the
    server in the browser’s local storage while waiting for a connection to be established
    successfully.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，渐进式应用必须组织起来，以充分利用它们离线工作的能力。因此，在多次通信错误之后，应用应该在建立成功连接之前，将所有要发送到服务器的数据保存到浏览器的本地存储中。
- en: It is also possible to maintain the whole application state in a centralized
    service so that the user can serialize and save it to local storage before quitting
    the application. This way, when the application is offline, data to be sent to
    the server is not lost because it remains in the application state that is saved
    to disk.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能在集中式服务中维护整个应用状态，这样用户在退出应用之前可以将它序列化并保存到本地存储中。这样，当应用离线时，要发送到服务器的数据不会丢失，因为它们保留在已保存到磁盘的应用状态中。
- en: When a progressive web application doesn’t fulfill your requirements because
    it is not able to use the specific device features you need, but you must support
    several different devices, you should consider cross-platform native applications,
    which have full access to all device features but can still support several hardware/software
    platforms. We will discuss them in the next subsection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当渐进式网络应用无法满足你的要求，因为它无法使用你需要的特定设备功能，但你必须支持多个不同的设备时，你应该考虑跨平台原生应用，这些应用可以完全访问所有设备功能，但仍然可以支持多个硬件/软件平台。我们将在下一小节中讨论它们。
- en: Native applications
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地应用
- en: Native development can be considered the beginning of UI development. There
    was no concept of sharing code between machines with diverse hardware when the
    idea of assigning software production to another person/company originally emerged.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 原生开发可以被认为是UI开发的起点。当最初将软件生产任务分配给另一个人/公司时，并没有在具有不同硬件的机器之间共享代码的概念。
- en: This is the first good answer as to why we have good performance on native applications.
    We cannot forget that native apps run better just because they are near the hardware,
    most of the time connected to the OS directly or by using a framework, such as
    .NET. Be careful; we are not only talking about native mobile apps, but we are
    also discussing apps delivered in Windows, Linux, Mac, Android, or any other OS
    that can run apps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于为什么本地应用有良好性能的第一个好答案。我们不能忘记，本地应用之所以运行得更好，仅仅是因为它们靠近硬件，大多数情况下直接连接到操作系统，或者通过使用框架，如.NET。请注意；我们不仅谈论原生移动应用，还在讨论在Windows、Linux、Mac、Android或任何其他可以运行应用的操作系统上交付的应用。
- en: 'Considering this scenario, the big question is – when do I have to use a native
    app? There are some cases where this would be a good idea:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种场景，最大的问题是——我什么时候必须使用本地应用？有些情况下，这样做是个好主意：
- en: There is no need to deploy on different platforms.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要在不同的平台上部署。
- en: There is a huge connection to the hardware.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与硬件有巨大的连接。
- en: The performance provided by a web client is not acceptable.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页客户端提供的性能是不可接受的。
- en: The application needs device resources that can’t be accessed through a browser
    because of a browser’s security policies.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用需要设备资源，而这些资源无法通过浏览器访问，因为浏览器的安全策略。
- en: The place where the application will run has connectivity problems.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用将运行的地方存在连接问题。
- en: 'The worst case is the one where you need two things at the same time: better
    performance than a web client and different platforms. In this scenario, you will
    probably have to deliver two applications, and the way you have designed the backend
    of this solution will be extremely important for reducing maintenance and costs
    as regards development.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏的情况是你需要同时拥有两样东西：比网页客户端更好的性能和不同的平台。在这种情况下，你可能不得不交付两个应用程序，而你设计这个解决方案的后端方式将对于减少开发和维护成本至关重要。
- en: The decision between developing native or not can be difficult to take without
    a **proof of concept** (**POC**). As a software architect, you should be the one
    to recommend this kind of POC.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有**概念验证**（**POC**）的情况下，决定是否开发本地应用可能会很困难。作为一名软件架构师，你应该推荐这种类型的POC。
- en: Examples of native applications that you can develop with C# are the classical
    Windows Forms and Windows Presentation Foundation, which are specific to the Windows
    operating system. Also, there is Xamarin, a platform that allows for the development
    of applications that can be published on both Android and iOS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用C#开发的本地应用示例包括经典的Windows Forms和Windows Presentation Foundation，它们是针对Windows操作系统的。此外，还有Xamarin，这是一个允许开发可在Android和iOS上发布的应用的平台。
- en: Cross-platform applications
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台应用
- en: Although performance can be a difficult requirement to achieve, in many scenarios,
    due to the simplicity of the solution, this is not the Achilles’ heel of the application.
    Considering WWTravelClub, although it would be useful to have the offline experience
    mentioned before, the performance itself is not the most difficult one to achieve.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管性能可能是一个难以实现的要求，但在许多场景中，由于解决方案的简单性，这并不是应用的致命弱点。考虑到WWTravelClub，虽然拥有之前提到的离线体验会有所帮助，但性能本身并不是最难以实现的一个。
- en: In these scenarios, cross-platform technologies make total sense. Among them,
    it is worth mentioning Xamarin.Forms and the new .NET MAUI, which can be published
    on Android, iOS, and Windows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，跨平台技术是完全有意义的。其中，值得提及的是Xamarin.Forms和新的.NET MAUI，它们可以发布到Android、iOS和Windows平台。
- en: The advised choice of cross-platform application is .NET MAUI. However, at the
    moment, MAUI supports Windows and all main mobile platforms but not Linux. Uno
    Platform ([https://platform.uno/](https://platform.uno/)) also supports Linux
    together with all main mobile platforms but is not a Microsoft product maintained
    by Microsoft. Anyway, it can be downloaded as a Visual Studio extension.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的跨平台应用选择是.NET MAUI。然而，目前MAUI支持Windows和所有主要移动平台，但不支持Linux。Uno Platform（[https://platform.uno/](https://platform.uno/)）也支持Linux以及所有主要移动平台，但它不是由微软维护的微软产品。无论如何，它可以作为Visual
    Studio扩展下载。
- en: In this chapter, we will not analyze Uno or all the options offered by .NET
    MAUI but just .NET MAUI Blazor since it is very similar to Blazor WebAssembly.
    So, learning Blazor enables us to develop single-page applications, progressive
    applications, and cross-platform applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会分析Uno或.NET MAUI提供的所有选项，而只是.NET MAUI Blazor，因为它与Blazor WebAssembly非常相似。因此，学习Blazor使我们能够开发单页应用、渐进式应用和跨平台应用。
- en: .NET MAUI Blazor is described in the *.NET MAUI Blazor* section of this chapter,
    while the next section describes the basics of Blazor WebAssembly architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*.NET MAUI Blazor*部分描述了.NET MAUI Blazor，而下一节将介绍Blazor WebAssembly架构的基础。
- en: Blazor WebAssembly architecture
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor WebAssembly架构
- en: Blazor WebAssembly uses the new WebAssembly browser feature to execute the .NET
    runtime in the browser. This way, it enables all developers to use the whole .NET
    code base and ecosystem in the implementation of applications capable of running
    in any WebAssembly-compliant browser. WebAssembly was conceived as a high-performance
    alternative to JavaScript. It is an assembly capable of running in a browser and
    obeying the same limitations as JavaScript code. This means that WebAssembly code,
    like JavaScript code, runs in an isolated execution environment that has very
    limited access to all machine resources.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly利用新的WebAssembly浏览器功能，在浏览器中执行.NET运行时。这样，它使所有开发者能够在任何WebAssembly兼容的浏览器中实现能够运行的应用程序，并使用整个.NET代码库和生态系统。WebAssembly被构想为JavaScript的高性能替代品。它是一个能够在浏览器中运行并遵守与JavaScript代码相同限制的汇编。这意味着WebAssembly代码，就像JavaScript代码一样，在具有非常有限访问所有机器资源的独立执行环境中运行。
- en: WebAssembly differs from similar options from the past, like Flash and Silverlight,
    since it is an official W3C standard. More specifically, it became an official
    standard on December 5, 2019, so it is expected to have a long life. As a matter
    of fact, all mainstream browsers already support it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly与过去的类似选项（如Flash和Silverlight）不同，因为它是一个官方的W3C标准。更具体地说，它于2019年12月5日成为官方标准，因此预计它将有一个漫长的生命周期。事实上，所有主流浏览器都已经支持它。
- en: However, WebAssembly doesn’t bring just performance with it; it also creates
    the opportunity to run whole code bases associated with modern and advanced object-oriented
    languages such as C++ (direct compilation), Java (bytecode), and C# (.NET) in
    browsers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，WebAssembly不仅仅带来了性能；它还创造了在浏览器中运行与现代化和高级面向对象语言（如C++（直接编译）、Java（字节码）和C# (.NET)）相关的整个代码库的机会。
- en: At the moment, Microsoft offers two frameworks that run .NET on top of WebAssembly,
    Blazor WebAssembly and Unity WebAssembly, which is the WebAssembly port of the
    Unity 3D graphic framework. Unity WebAssembly’s main purpose is the implementation
    of online video games that run in the browser, while Blazor WebAssembly is a **single-page
    application** framework that uses .NET instead of JavaScript or TypeScript.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，微软提供了两个在 WebAssembly 上运行 .NET 的框架，即 Blazor WebAssembly 和 Unity WebAssembly，后者是
    Unity 3D 图形框架的 WebAssembly 版本。Unity WebAssembly 的主要目的是实现运行在浏览器中的在线视频游戏，而 Blazor
    WebAssembly 是一个 **单页应用程序** 框架，它使用 .NET 而不是 JavaScript 或 TypeScript。
- en: Before WebAssembly, presentation layers running in a browser could only be implemented
    in JavaScript, with all the problems associated with the maintenance of big code
    bases implemented in a language that is not strictly typed. However, we must consider
    that on one hand, the usage of TypeScript in part solves JavaScript’s lack of
    strict typing, and on the other hand, .NET brings with it the problem of the binary
    compatibility of modules implemented with different .NET versions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebAssembly 之前，运行在浏览器中的表示层只能用 JavaScript 实现，这带来了与在非严格类型语言中实现的大代码库维护相关的问题。然而，我们必须考虑，一方面，TypeScript
    的使用部分解决了 JavaScript 的严格类型缺乏问题，另一方面，.NET 带来了使用不同 .NET 版本实现的模块的二进制兼容性问题。
- en: Anyway, with Blazor C#, developers can now implement complex applications in
    their favorite language, with all the comforts offered to this language by the
    C# compiler and Visual Studio.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，使用 Blazor C#，开发者现在可以用他们最喜欢的语言实现复杂的应用程序，同时享受 C# 编译器和 Visual Studio 为这种语言提供的所有便利。
- en: Moreover, with Blazor, all .NET developers can use the full power of the .NET
    framework, with the only limitations imposed by the browser security policies,
    for the implementation of presentation layers that run in the browser and that
    share libraries and classes with all other layers that run on the server side.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 Blazor，所有 .NET 开发者都可以使用 .NET 框架的全部功能，唯一的限制是由浏览器安全策略强加的，用于实现运行在浏览器中并与服务器端运行的所有其他层共享库和类的表示层。
- en: The subsections that follow describe all the Blazor architectures. The first
    subsection explores the general concept of a single-page application, describing
    Blazor’s peculiarities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子节描述了所有 Blazor 架构。第一个子节探讨了单页应用程序的一般概念，并描述了 Blazor 的特性。
- en: What is a single-page application?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是单页应用程序？
- en: A **single-page application** (**SPA**) is an HTML-based application, where
    the HTML is changed by code that runs in the browser instead of issuing a new
    request to the server and rendering a new HTML page from scratch. SPAs can simulate
    a multi-page experience by replacing complete page areas with new HTML.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPA**）是一个基于 HTML 的应用程序，其中 HTML 通过在浏览器中运行的代码进行更改，而不是向服务器发出新的请求并从头开始渲染新的
    HTML 页面。SPA 可以通过用新的 HTML 替换完整的页面区域来模拟多页体验。'
- en: SPA frameworks are frameworks explicitly designed for implementing SPAs. Before
    WebAssembly, all SPA frameworks were based on JavaScript. The most famous JavaScript-based
    SPA frameworks are Angular, React.js, and Vue.js.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 框架是专门设计用于实现 SPAs 的框架。在 WebAssembly 之前，所有 SPA 框架都基于 JavaScript。最著名的基于 JavaScript
    的 SPA 框架是 Angular、React.js 和 Vue.js。
- en: All SPA frameworks provide ways to transform data into HTML to show to the user
    and rely on a module called *router* to simulate page changes. Typically, data
    fills in the placeholders of HTML templates and selects which parts of a template
    to render (`if-like` constructs) and how many times to render it (`for-like` constructs).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 SPA 框架都提供将数据转换为 HTML 以显示给用户的方法，并依赖于一个名为 *router* 的模块来模拟页面变化。通常，数据填充 HTML
    模板的占位符，并选择渲染模板的哪些部分（`if-like` 结构）以及渲染它的次数（`for-like` 结构）。
- en: The Blazor template language is Razor, which we described in *Chapter 17*, *Presenting
    ASP.NET Core*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 模板语言是 Razor，我们在 *第 17 章*，*展示 ASP.NET Core* 中进行了描述。
- en: In order to increase modularity, code is organized into components, which are
    a kind of virtual HTML tag that, once rendered, generates actual HTML markup.
    Like HTML tags, components have attributes, which are usually called parameters,
    and custom events. It is up to the developer to ensure that each component uses
    its parameters to create proper HTML and to ensure that it generates adequate
    events. Components can be used inside other components in a hierarchical fashion.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高模块化，代码被组织成组件，这些组件是一种虚拟的 HTML 标签，一旦渲染，就会生成实际的 HTML 标记。像 HTML 标签一样，组件有属性，通常称为参数，以及自定义事件。开发者需要确保每个组件使用其参数创建适当的
    HTML，并确保它生成足够的事件。组件可以以分层的方式嵌套在其他组件内部。
- en: Components can be associated with URLs in the application web domain, in which
    case they are called pages. These URLs can be used in the usual HTML links and
    following them leads to the upload of the page into an application area thanks
    to framework services called routers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以与应用程序网络域中的 URL 关联，在这种情况下，它们被称为页面。这些 URL 可以在常规 HTML 链接中使用，并且跟随它们会导致页面通过框架服务（称为路由器）上传到应用程序区域。
- en: Some SPA frameworks also provide a predefined dependency injection engine in
    order to ensure better separation between components on one side and general-purpose
    services plus business code that runs in the browser on the other. Among the frameworks
    listed in this subsection, only Blazor and Angular have an out-of-the-box dependency
    injection engine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 SPA 框架还提供预定义的依赖注入引擎，以确保组件一侧和运行在浏览器中的通用服务以及业务代码之间的更好分离。在本节列出的框架中，只有 Blazor
    和 Angular 提供开箱即用的依赖注入引擎。
- en: In order to reduce the overall application file size, SPA frameworks based on
    JavaScript usually compile all JavaScript code in a few JavaScript files and then
    perform so-called tree-shaking, that is, the removal of all unused code. This
    technique sensibly reduces the application load time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少整体应用程序文件大小，基于 JavaScript 的 SPA 框架通常将所有 JavaScript 代码编译成几个 JavaScript 文件，然后执行所谓的摇树（tree-shaking），即删除所有未使用的代码。这种技术合理地减少了应用程序的加载时间。
- en: At the moment, instead, Blazor keeps all DLLs referenced by the main application
    separate and performs tree-shaking on each of them separately.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Blazor 将主应用程序引用的所有 DLL 分开保存，并对每个 DLL 分别执行摇树（tree-shaking）操作。
- en: The next subsection describes the Blazor architecture. We challenge you to create
    a Blazor WebAssembly project called `BlazorReview`, so you can inspect the code
    and the constructs explained throughout the chapter. To do this, select the **Blazor
    WebAssembly Standalone Application**option when creating a new project. Make sure
    to select **Individual Accounts** as the authentication type and ensure that the
    **Include sample pages** checkbox is checked, as shown in the picture below.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了 Blazor 架构。我们挑战你创建一个名为 `BlazorReview` 的 Blazor WebAssembly 项目，这样你就可以检查本章中解释的代码和结构。为此，在创建新项目时选择
    **Blazor WebAssembly Standalone Application** 选项。确保选择 **Individual Accounts**
    作为身份验证类型，并确保勾选 **Include sample pages** 复选框，如图下所示。
- en: '![](img/B19820_19_01.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_19_01.png)'
- en: 'Figure 19.1: Creating the BlazorReview application'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1：创建 BlazorReview 应用程序
- en: 'If you start the application, the application works properly, but if you try
    to log in, the following error message will appear: “There was an error trying
    to log you in: ‘Network Error’.” This is because you need to configure an identity-provider-authenticated
    user. As the default, the application is configured to use an OAuth-based identity
    provider web application. You need to just add the provider configuration data
    in a configuration file. We will look at this in more detail in the *Authentication
    and authorization* section.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动应用程序，应用程序将正常工作，但如果你尝试登录，将会出现以下错误信息：“尝试登录时发生错误：‘网络错误’。” 这是因为你需要配置一个身份提供者认证用户。默认情况下，应用程序配置为使用基于
    OAuth 的身份提供者网络应用程序。你只需在配置文件中添加提供者配置数据。我们将在 *身份验证和授权* 部分更详细地讨论这个问题。
- en: Loading and starting the application
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和启动应用程序
- en: The folder structure of a Blazor WebAssembly application always includes an
    `index.html` static HTML page. In our `BlazorReview` project, `index.html` is
    in `BlazorReview->wwwroot->index.html`. This page is the container where the Blazor
    application will create its HTML. It contains an HTML header with a `viewport
    meta` declaration, the title, and CSS for the application’s overall styling. The
    Visual Studio default project template adds an application-specific CSS file and
    Bootstrap CSS, with a neutral style. You can replace the default Bootstrap CSS
    either with a customized style or a completely different CSS framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 应用程序的文件夹结构始终包括一个 `index.html` 静态 HTML 页面。在我们的 `BlazorReview`
    项目中，`index.html` 位于 `BlazorReview->wwwroot->index.html`。这个页面是 Blazor 应用程序创建其 HTML
    的容器。它包含一个带有 `viewport meta` 声明的 HTML 头部，标题以及用于应用程序整体样式的 CSS。Visual Studio 默认项目模板添加了一个特定于应用程序的
    CSS 文件和 Bootstrap CSS，具有中性风格。您可以用自定义样式或完全不同的 CSS 框架替换默认的 Bootstrap CSS。
- en: 'The body contains the code that follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 主体包含以下代码：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The initial `div` with the `app` `id` is where the application will place the
    code it generates. Any markup placed inside this `div` will appear just while
    the Blazor application is loading and starting, then it will be replaced by the
    application-generated HTML. As the default, it contains an `svg` image and text
    that shows the loading progress, which are both controlled by the JavaScript code
    that takes care of loading the framework. The loading animation is based on a
    CSS animation contained in the `css/app.css` main application CSS file. However,
    you can replace both the default content and the CSS animation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的 `div` 元素，其 `app` 标识符是应用程序放置其生成的代码的位置。放置在此 `div` 内部的任何标记都将仅在 Blazor 应用程序加载和启动时显示，然后将被应用程序生成的
    HTML 替换。默认情况下，它包含一个 `svg` 图像和显示加载进度的文本，这些都被负责加载框架的 JavaScript 代码控制。加载动画基于位于 `css/app.css`
    主应用程序 CSS 文件中的 CSS 动画。然而，您可以替换默认内容和 CSS 动画。
- en: The second `div` is normally invisible and appears only when Blazor intercepts
    an unhandled exception.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `div` 通常不可见，仅在 Blazor 拦截未处理的异常时才会出现。
- en: '`blazor.webassembly.js` contains the JavaScript part of the Blazor framework.
    Among other things, it takes care of downloading the .NET runtime, together with
    all application DLLs. More specifically, `blazor.webassembly.js` downloads the
    `blazor.boot.json` file, which lists all application files with their hashes.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`blazor.webassembly.js` 包含 Blazor 框架的 JavaScript 部分。除了其他功能外，它负责下载 .NET 运行时以及所有应用程序
    DLL。更具体地说，`blazor.webassembly.js` 下载 `blazor.boot.json` 文件，该文件列出了所有应用程序文件及其哈希值。'
- en: Then, `blazor.webassembly.js` downloads all resources listed in this file and
    verifies their hashes. All resources downloaded by `blazor.webassembly.js` are
    created when the application is built or published. Loading `blazor.webassembly.js`
    periodically updates the `--blazor-load-percentage` and `--blazor-load-percentage-text`
    CSS variables with the loading percentage in numeric format and as text, respectively.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`blazor.webassembly.js` 下载此文件中列出的所有资源并验证它们的哈希值。所有由 `blazor.webassembly.js`
    下载的资源都是在应用程序构建或发布时创建的。定期加载 `blazor.webassembly.js` 会更新 `--blazor-load-percentage`
    和 `--blazor-load-percentage-text` CSS 变量，分别以数值格式和文本格式显示加载百分比。
- en: '`AuthenticationService.js` is added only when the project enables authentication
    and takes care of the `OpenID Connect` protocol used by Blazor to exploit other
    identity providers, to get bearer tokens, which are the preferred authentication
    credentials for clients that interact with a server through web APIs.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目启用身份验证时，会添加 `AuthenticationService.js`，并负责 Blazor 使用的 `OpenID Connect` 协议，以利用其他身份提供者，获取
    bearer 令牌，这些令牌是客户端通过 Web API 与服务器交互时首选的认证凭证。
- en: Authentication is discussed in more detail in the *Authentication and authorization*
    subsection later on in this chapter, while bearer tokens are discussed in the
    *REST service authorization and authentication* section of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后的 *身份验证和授权* 子节中更详细地讨论了身份验证，而 bearer 令牌在 *第 15 章* 的 *REST 服务授权和身份验证* 部分中讨论。
- en: 'The Blazor application entry point is in the `BlazorReview->Program.cs` file.
    This file doesn’t contain a class but just the code that must be executed when
    the application is launched:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 应用程序的入口点位于 `BlazorReview->Program.cs` 文件中。此文件不包含类，只包含在应用程序启动时必须执行的代码：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In fact, the new Blazor WebAssembly project template takes advantage of this
    new way to define the application entry point that was introduced starting from
    .NET 7.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，新的 Blazor WebAssembly 项目模板利用了从 .NET 7 开始引入的这种新方法来定义应用程序的入口点。
- en: '`WebAssemblyHostBuilder` is a builder for creating a `WebAssemblyHost`, which
    is a WebAssembly-specific implementation of the generic host discussed in the
    *Using generic hosts* subsection of *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application* (you are encouraged to review that subsection).
    The first builder configuration instruction declares the Blazor root component
    (`App`), which will contain the whole component tree, and specifies in which HTML
    tag of the `index.html` page to place it (`#app`). More specifically, `RootComponents.Add`
    adds a hosted service that takes care of handling the whole Blazor component tree.
    We can run several Blazor WebAssembly user interfaces on the same HTML page by
    calling `RootComponents.Add` several times, each time with a different HTML tag
    reference.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssemblyHostBuilder` 是创建 `WebAssemblyHost` 的构建器，它是第 11 章 *将微服务架构应用于您的企业应用程序*
    中 *使用通用主机* 子部分讨论的通用主机的 WebAssembly 特定实现（您被鼓励回顾该子部分）。第一个构建器配置指令声明了 Blazor 根组件（`App`），它将包含整个组件树，并指定在
    `index.html` 页面的哪个 HTML 标签中放置它（`#app`）。更具体地说，`RootComponents.Add` 添加了一个托管服务，负责处理整个
    Blazor 组件树。我们可以通过多次调用 `RootComponents.Add` 来在同一个 HTML 页面上运行多个 Blazor WebAssembly
    用户界面，每次调用时使用不同的 HTML 标签引用。'
- en: As the default, just another root component is added, `HeadOutlet`, and is placed
    immediately after the `HTML Head` tag. It is used to dynamically change the `index.html`
    title (the text shown in the browser tab). For more information on the `HeadOutlet`
    component, see the *Modifying HTML <head> content from Blazor component*s subsection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，仅添加了一个名为 `HeadOutlet` 的根组件，并将其放置在 `HTML Head` 标签之后。它用于动态更改 `index.html`
    的标题（浏览器标签中显示的文本）。有关 `HeadOutlet` 组件的更多信息，请参阅 *从 Blazor 组件修改 HTML <head> 内容* 子部分。
- en: '`builder.Services` contains all the usual methods and extension methods to
    add services to the Blazor application dependency engine: `AddScoped`, `AddTransient`,
    `AddSingleton`, and so on. Like in ASP.NET Core MVC applications (*Chapter 17*,
    *Presenting ASP.NET Core*, and *Chapter 18*, *Implementing Frontend Microservices
    with ASP.NET Core*), services are the preferred places to implement business logic
    and store shared state. While in ASP.NET Core MVC services were usually passed
    to controllers, in Blazor WebAssembly, they are injected into components.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder.Services` 包含了向 Blazor 应用程序依赖引擎添加服务的所有常用方法和扩展方法：`AddScoped`、`AddTransient`、`AddSingleton`
    等。就像在 ASP.NET Core MVC 应用程序中（第 17 章 *展示 ASP.NET Core* 和第 18 章 *使用 ASP.NET Core
    实现前端微服务*），服务是实现业务逻辑和存储共享状态的优选位置。虽然在 ASP.NET Core MVC 中服务通常传递给控制器，但在 Blazor WebAssembly
    中，它们被注入到组件中。'
- en: The default project scaffolded by Visual Studio contains just two services,
    one for communicating with the server and the other for handling OAuth-based authentication.
    We will discuss both of them later on in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 默认生成的项目包含两个服务，一个用于与服务器通信，另一个用于处理基于 OAuth 的身份验证。我们将在本章后面讨论这两个服务。
- en: The next subsection explains how the root `App` component simulates page changes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子部分将解释根 `App` 组件如何模拟页面变化。
- en: Routing
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: 'The root `App` class referenced by the host-building code is defined in the
    `BlazorReview ->App.razor` file. `App` is a Blazor component, and like all Blazor
    components, it is defined in a file with a `.razor` extension and uses Razor syntax
    enriched with component notation, that is, with HTML-like tags that represent
    other Blazor components. It contains the whole logic for handling application
    pages:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 主构建代码引用的根 `App` 类定义在 `BlazorReview ->App.razor` 文件中。`App` 是一个 Blazor 组件，就像所有
    Blazor 组件一样，它在一个以 `.razor` 扩展名命名的文件中定义，并使用带有组件符号的 Razor 语法，即具有类似 HTML 标签的其他 Blazor
    组件。它包含处理应用程序页面的全部逻辑：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All tags in the preceding code represent either components or particular component
    parameters, called templates. Components will be discussed in detail throughout
    the chapter. For the moment, imagine them as a kind of custom HTML tags that we
    can somehow define with C# and Razor code. Templates, instead, are parameters
    that accept Razor markup as values. Templates are discussed in the *Templates
    and cascading parameters* subsection later on in this section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码中的所有标签都代表组件或特定的组件参数，称为模板。组件将在本章中详细讨论。目前，可以将它们想象成一种我们可以用 C# 和 Razor 代码定义的自定义
    HTML 标签。模板则是接受 Razor 标记为值的参数。模板将在本节稍后的 *模板和级联参数* 子节中讨论。
- en: The `CascadingAuthenticationState` component only has the function of passing
    authentication and authorization information to all components of the component
    tree that is inside of it. The Blazor project template generates it only if one
    chooses to add authorization during project creation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingAuthenticationState` 组件仅具有将认证和授权信息传递到其内部的所有组件树组件的功能。Blazor 项目模板仅在创建项目时选择添加授权时才生成它。'
- en: The `Router` component is the actual application router. It scans the assembly
    passed in the `AppAssembly` parameter looking for components containing routing
    information, that is, for components that can work as pages. In the Blazor project
    template, the `Router` component is passed the assembly that contains the class
    of the `App` component, that is, the main application. Pages contained in other
    assemblies can be added through the `AdditionalAssemblies` parameter, which accepts
    an `IEnumerable` of assemblies.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router` 组件是实际的应用程序路由器。它扫描通过 `AppAssembly` 参数传入的程序集，寻找包含路由信息的组件，即可以作为页面的组件。在
    Blazor 项目模板中，`Router` 组件接收包含 `App` 组件类的程序集，即主应用程序。其他程序集中的页面可以通过 `AdditionalAssemblies`
    参数添加，该参数接受程序集的 `IEnumerable`。'
- en: After that, the router intercepts all page changes performed either by code
    or through the usual `<a>` HTML tags that point to an address inside of the application
    base address. Navigation can be handled by code by requiring a `NavigationManager`
    instance from dependency injection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，路由器拦截通过代码或通过指向应用程序基础地址内地址的常规 `<a>` HTML 标签执行的任何页面更改。可以通过从依赖注入中获取 `NavigationManager`
    实例来通过代码处理导航。
- en: 'The `Router` component has two templates, one for the case where a page for
    the requested URI is found (`Found`), and the other for the case where it is not
    found (`NotFound`). When the application uses authorization, the `Found` template
    consists of the `AuthorizeRouteView` components, which further distinguish whether
    the user is authorized to access the selected page or not. When the application
    doesn’t use authorization, the `Found` template consists of the `RouteView` component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router` 组件有两个模板，一个用于找到请求的 URI 对应的页面时的情况（`Found`），另一个用于未找到页面时的情况（`NotFound`）。当应用程序使用授权时，`Found`
    模板由 `AuthorizeRouteView` 组件组成，这进一步区分用户是否有权访问所选页面。当应用程序不使用授权时，`Found` 模板由 `RouteView`
    组件组成：'
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`RouteView` takes the selected page and renders it inside the layout page specified
    by the `DefaultLayout` parameter. This specification acts as a default since each
    page can override it by specifying a different layout page. In the Blazor project
    template, the default layout page is in the `BlazorReview->Layout->MainLayout.razor`
    file.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouteView` 接收所选页面，并在由 `DefaultLayout` 参数指定的布局页面内渲染它。这种指定作为默认值，因为每个页面都可以通过指定不同的布局页面来覆盖它。在
    Blazor 项目模板中，默认布局页面位于 `BlazorReview->Layout->MainLayout.razor` 文件中。'
- en: 'Blazor layout pages work similarly to ASP.NET Core MVC layout pages, described
    in the *Reusing view code* subsection of *Chapter 17*, *Presenting ASP.NET Core*,
    the only difference being that the place to add the page markup is specified with
    `@Body`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 布局页面与 *第 17 章* 中描述的 *重用视图代码* 子节中的 ASP.NET Core MVC 布局页面类似，唯一的区别在于添加页面标记的位置是用
    `@Body` 指定的：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the application uses authorization, `AuthorizeRouteView` works like `RouteView`,
    but it also allows the specification of a template for a case where the user is
    not authorized:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用授权，`AuthorizeRouteView` 与 `RouteView` 的工作方式相同，但它还允许指定用户未授权时的模板：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the user is not authenticated, the `RedirectToLogin` component uses a `NavigationManager`
    instance to move to the login logic page; otherwise, it informs the users that
    they haven’t got enough privileges to access the selected page.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未认证，`RedirectToLogin` 组件将使用 `NavigationManager` 实例移动到登录逻辑页面；否则，它通知用户他们没有足够的权限访问所选页面。
- en: Blazor WebAssembly also allows the lazy loading of assemblies to reduce the
    initial application loading time, but we will not discuss it here for lack of
    space. The *Further reading* section contains references to the official Blazor
    documentation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 还允许懒加载程序集以减少初始应用程序加载时间，但在这里我们不会讨论它，因为篇幅有限。*进一步阅读* 部分包含了对官方
    Blazor 文档的引用。
- en: As we will discuss in more detail later on in this chapter, the `PageTitle`
    component enables the developer to set the page title that appears in the browser
    tabs. The `FocusOnNavigate` component, instead, sets the HTML focus on the first
    HTML element that satisfies the CSS selector passed in its `Selector` parameter,
    immediately after a page is navigated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面更详细地讨论的那样，`PageTitle` 组件允许开发者设置浏览器标签中显示的页面标题。而 `FocusOnNavigate` 组件则设置
    HTML 上的焦点在满足其 `Selector` 参数中 CSS 选择器的第一个 HTML 元素上，页面导航后立即进行。
- en: Blazor pages and components
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor 页面和组件
- en: 'In this section, you will learn the fundamentals of Blazor components, including
    how to construct a component, the structure of components, how to attach events
    to HTML tags, how to specify the components’ characteristics, and how to use other
    components within your components. We have divided the content into several subsections:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习 Blazor 组件的基础知识，包括如何构建组件、组件的结构、如何将事件附加到 HTML 标签上、如何指定组件的特性，以及如何在组件内部使用其他组件。我们将内容分为几个子部分：
- en: Component structure
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件结构
- en: Templates and cascading parameters
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板和级联参数
- en: Error handling
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Events
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Bindings
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定
- en: How Blazor updates HTML
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 如何更新 HTML
- en: Component lifecycle
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Component structure
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件结构
- en: Components are the core of all main client frameworks. They are the key ingredient
    to building modular UI, whose parts are easily modifiable and reusable. In a few
    words, they are the graphical counterpart of classes. In fact, just like classes,
    they allow encapsulation and code organization. Moreover, the component architecture
    allows the formal definition of efficacious UI update algorithms, as we will see
    in the *How Blazor updates HTML* section of this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是所有主要客户端框架的核心。它们是构建模块化 UI 的关键成分，其部分易于修改和重用。简而言之，它们是类的图形对应物。实际上，就像类一样，它们允许封装和代码组织。此外，组件架构允许正式定义有效的
    UI 更新算法，正如我们将在本章的 *Blazor 如何更新 HTML* 部分中看到的那样。
- en: Components are defined in files with a `.razor` extension. Once compiled, they
    become classes that inherit from `ComponentBase`. Like all other Visual Studio
    project elements, Blazor components are available through the **Add New Item**
    menu. Usually, components to be used as pages are defined in the `Pages` folder,
    or in its subfolders, while other components are organized in different folders.
    Default Blazor projects add all their non-page components inside the `Shared`
    folder, but you can organize them differently.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 组件定义在扩展名为 `.razor` 的文件中。一旦编译，它们就变成了继承自 `ComponentBase` 的类。和所有其他 Visual Studio
    项目元素一样，Blazor 组件可以通过 **添加新项** 菜单访问。通常，用作页面的组件定义在 `Pages` 文件夹中，或者其子文件夹中，而其他组件则组织在不同的文件夹中。默认的
    Blazor 项目将所有非页面组件添加到 `Shared` 文件夹中，但你可以以不同的方式组织它们。
- en: By default, pages are assigned a namespace that corresponds to the path of the
    folder they are in. Thus, for instance, in our example project, all pages that
    are in the `BlazorReview->Pages` path are assigned to the `BlazorReview.Pages`
    namespace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，页面被分配一个与它们所在文件夹路径相对应的命名空间。因此，例如，在我们的示例项目中，所有位于 `BlazorReview->Pages` 路径中的页面都被分配到
    `BlazorReview.Pages` 命名空间。
- en: 'However, you can change this default namespace with an `@namespace` declaration
    placed in the declaration area that is at the top of the file. This area may also
    contain other important declarations. The following is an example that shows all
    declarations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过在文件顶部的声明区域放置一个 `@namespace` 声明来更改此默认命名空间。此区域还可以包含其他重要声明。以下是一个显示所有声明的示例：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first two directives make sense only for components that must work as pages,
    while all others may appear in any component. Below is a detailed explanation
    of each declaration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个指令仅适用于必须作为页面工作的组件，而所有其他组件都可以出现在任何组件中。以下是每个声明的详细解释：
- en: The `@layout` directive, when specified, overrides the default layout page with
    another component.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定 `@layout` 指令时，它将使用另一个组件覆盖默认布局页面。
- en: 'The `@page` directive defines the path of the page (**route**) within the application
    base URL. Thus, for instance, if our application runs at `https://localhost:5001`,
    then the URL of this page will be `https://localhost:5001/counter`. Page routes
    can also contain parameters, like in this example: `/orderitem/{customer}/{order}`.
    Parameter names must match public properties defined as parameters by the components.
    The match is case-insensitive. Parameters will be explained later on in this subsection.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@page` 指令定义了页面在应用程序基本 URL 中的路径（**路由**）。因此，例如，如果我们的应用程序运行在 `https://localhost:5001`，那么这个页面的
    URL 将是 `https://localhost:5001/counter`。页面路由也可以包含参数，例如在这个例子中：`/orderitem/{customer}/{order}`。参数名称必须与组件公开定义的参数属性匹配。匹配不区分大小写。参数将在本小节稍后进行解释。'
- en: 'The string that instantiates each parameter is converted into the parameter
    type, and if this conversion fails, an exception is thrown. This behavior can
    be prevented by associating a type with each parameter, in which case, if the
    conversion to the specified type fails, the match with the page URL fails. Only
    elementary types are supported: `/orderitem/{customer:int}/{order:int}`. As a
    default, parameters are obligatory; that is, if they are not found, the match
    fails and the router tries other pages. However, you can make parameters optional
    by post-fixing them with a question mark: `/orderitem/{customer?:int}/{order?:int}`.
    If an optional parameter is not specified, the default for its type is used.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化每个参数的字符串被转换为参数类型，如果转换失败，则会抛出异常。可以通过为每个参数关联一个类型来防止这种行为，在这种情况下，如果转换到指定类型失败，则与页面
    URL 的匹配也会失败。仅支持基本类型：`/orderitem/{customer:int}/{order:int}`。默认情况下，参数是必需的；也就是说，如果找不到它们，匹配将失败，并且路由器将尝试其他页面。然而，你可以通过在参数后附加一个问号来使参数可选：`/orderitem/{customer?:int}/{order?:int}`。如果一个可选参数没有被指定，则使用其类型的默认值。
- en: 'From version 6, parameters can also be extracted from the query string: `/orderitem/{customer:int}?order=123`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从版本 6 开始，参数也可以从查询字符串中提取：`/orderitem/{customer:int}?order=123`。
- en: '`@namespace` overrides the default namespace of the component, while `@using`
    is equivalent to the usual C# `using`. The `@using` declared in the special `{project
    folder}->_Imports.razor` folder is automatically applied to all components.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@namespace` 覆盖了组件的默认命名空间，而 `@using` 等同于常用的 C# `using`。在特殊文件夹 `{project folder}->_Imports.razor`
    中声明的 `@using` 会自动应用于所有组件。'
- en: '`@inherits` declares that the component is a subclass of another component,
    while `@implements` declares that it implements an interface.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inherits` 声明该组件是另一个组件的子类，而 `@implements` 声明它实现了接口。'
- en: '`@typeparam` is used if the component is a generic class and declares the name
    of the generic parameter. `@typeparam` also allows the specification of generic
    constraints with the same syntax used in classes: `@typeparam T where T: class`.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果组件是泛型类，则使用 `@typeparam` 并声明泛型参数的名称。`@typeparam` 还允许使用与类中相同的语法指定泛型约束：`@typeparam
    T where T: class`。'
- en: '`@attribute` declares any attribute applied to the component class. Property-level
    attributes are applied directly to properties defined in the code area, so they
    don’t need special notation. The `[Authorize]` attribute, applied to a component
    class used as a page, prevents unauthorized users from accessing the page. It
    works exactly in the same way as when it is applied to a controller or to an action
    method in ASP.NET Core MVC.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@attribute` 声明应用于组件类的任何属性。属性级别的属性直接应用于代码区域中定义的属性，因此不需要特殊标记。应用于用作页面的组件类的 `[Authorize]`
    属性阻止未经授权的用户访问页面。它的工作方式与在 ASP.NET Core MVC 中应用于控制器或操作方法时完全相同。'
- en: Finally, the `@inject` directive requires a type instance to the dependency
    injection engine and inserts it in the field declared after the type name; in
    the previous example, in the `navigation` parameter.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`@inject` 指令需要依赖注入引擎的类型实例，并将其插入在类型名称后面的字段中；在上一个例子中，在 `navigation` 参数中。
- en: The middle part of the component file contains the HTML that will be rendered
    by the component with Razor markup, enriched with the possible invocation of child
    components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 组件文件的中部包含将由组件使用 Razor 标记渲染的 HTML，并可能调用子组件。
- en: 'The bottom part of the file is enclosed by an `@code` construct and contains
    fields, properties, and methods of the class that implements the component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的底部部分被 `@code` 构造包围，包含实现组件的类的字段、属性和方法：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Public properties decorated with the `[Parameter]` attribute work as component
    parameters; that is, when the component is instantiated into another component,
    they are used to pass values to the decorated properties, and those values are
    passed to HTML elements in HTML markup:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰有 `[Parameter]` 特性的公共属性作为组件参数工作；也就是说，当组件被实例化为另一个组件时，它们用于将值传递给装饰的属性，并且这些值在
    HTML 标记中传递给 HTML 元素：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Values can also be passed to component parameters by page route parameters,
    or query string parameters that match the property name in a case-invariant match:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以通过页面路由参数或与属性名匹配的查询字符串参数传递给组件参数，匹配时不区分大小写：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, the match with query string parameters is enabled only if the property
    is also decorated with the `SupplyParameterFromQuery` attribute:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有当属性也装饰有 `SupplyParameterFromQuery` 特性时，才会启用与查询字符串参数的匹配：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Component parameters can also accept complex types and functions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 组件参数还可以接受复杂类型和函数：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If components are generic, they must be passed type values for each generic
    parameter declared with `typeparam`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件是泛型的，它们必须为使用 `typeparam` 声明的每个泛型参数传递类型值：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, often, the compiler is able to infer generic types from the types of
    other parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器通常能够从其他参数的类型推断泛型类型。
- en: 'Finally, the code enclosed in the `@code` directive can also be declared in
    a partial class with the same name and namespace as the component:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `@code` 指令中封装的代码也可以声明在具有相同名称和命名空间的局部类中：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Usually, these partial classes are declared in the same folder as the component
    and with a filename equal to the component’s filename with a `.cs` postfix added.
    Thus, for instance, the partial class associated with the `counter.razor` component
    will be `counter.razor.cs`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些局部类在组件所在的同一文件夹中声明，文件名与组件的文件名相同，但添加了 `.cs` 后缀。例如，与 `counter.razor` 组件关联的局部类将是
    `counter.razor.cs`。
- en: Each component may also have an associated CSS file, whose name must be the
    name of the component file plus the `.css` postfix. Thus, for instance, the CSS
    file associated with the `counter.razor` component will be `counter.razor.css`.
    The CSS contained in this file is applied only to the component and has no effect
    on the remainder of the page. This is called CSS isolation, and at the moment,
    it is implemented by adding a unique attribute to all component HTML roots. Then,
    all selectors of the component CSS file are scoped to this attribute so that they
    can’t affect other HTML.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件也可能有一个相关的 CSS 文件，其名称必须是组件文件名加上 `.css` 后缀。例如，与 `counter.razor` 组件关联的 CSS
    文件将是 `counter.razor.css`。此文件中包含的 CSS 只应用于组件，对页面的其余部分没有影响。这被称为 CSS 隔离，目前它是通过向所有组件
    HTML 根添加一个唯一属性来实现的。然后，组件 CSS 文件的全部选择器都被限制在这个属性上，这样它们就不能影响其他 HTML。
- en: Of course, we can also use global application CSS, and in fact, the Blazor template
    creates the `wwwroot/css/app.css` file for this purpose.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用全局应用 CSS，实际上，Blazor 模板为此创建了 `wwwroot/css/app.css` 文件。
- en: 'When the Blazor application is packaged, either during a build or during its
    publication, all isolated CSS is processed and placed in a unique CSS file called
    `<assembly name>.Client.styles.css`. That’s why the `index.html` page of our `BlazorReview`
    application contains the following CSS reference:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Blazor 应用程序打包时，无论是在构建过程中还是在发布过程中，所有隔离的 CSS 都会被处理并放置在一个名为 `<assembly name>.Client.styles.css`
    的唯一 CSS 文件中。这就是为什么我们的 `BlazorReview` 应用的 `index.html` 页面包含了以下 CSS 引用：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is worth mentioning that isolated CSS can also be obtained with pure CSS
    techniques, or using the **Sass** language, which compiles with CSS.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，隔离的 CSS 也可以通过纯 CSS 技巧或使用 **Sass** 语言获得，Sass 编译成 CSS。
- en: Whenever a component decorates an `IDictionary<string, object>` parameter with
    `[Parameter(CaptureUnmatchedValues = true)]`, then all unmatched parameters inserted
    into the tag, that is, all parameters without a matching component property, are
    added to the `IDictionary` as key-value pairs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件使用 `[Parameter(CaptureUnmatchedValues = true)]` 装饰 `IDictionary<string, object>`
    参数时，所有插入到标签中的不匹配参数（即没有匹配组件属性的参数）都作为键值对添加到 `IDictionary` 中。
- en: 'This feature provides an easy way to forward parameters to HTML elements or
    ­other child components contained in the component markup. For instance, if we
    have a `Detail` component that displays a detail view of the object passed in
    its `Value` parameter, we can use this feature to forward all usual HTML attributes
    to the root HTML tag of the component, as shown in the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能提供了一种简单的方法将参数转发到 HTML 元素或其他包含在组件标记中的子组件。例如，如果我们有一个 `Detail` 组件，它显示传递给其 `Value`
    参数的对象的详细视图，我们可以使用此功能将所有常规 HTML 属性转发到组件的根 HTML 标签，如下例所示：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This way, usual HTML attributes added to the component tag, for instance, `class`,
    are forwarded to the root `div` of the components and used to style the component:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，通常添加到组件标签的 HTML 属性（例如，`class`），都会转发到组件的根 `div` 并用于样式化组件：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next subsection explains how to pass markup-generating functions to components.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节解释了如何将标记生成函数传递给组件。
- en: Templates and cascading parameters
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板和级联参数
- en: Blazor works by building a data structure called a **render tree**, which is
    updated as the UI changes. At each change, Blazor locates the part of the HTML
    that must be rendered and uses the information contained in the **render tree**
    to update it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 通过构建一个称为 **渲染树** 的数据结构来工作，该结构在 UI 发生变化时更新。在每次更改时，Blazor 定位必须渲染的 HTML
    部分，并使用 **渲染树** 中包含的信息来更新它。
- en: The `RenderFragment` delegate defines a function that is able to add further
    markup to a specific position of the **render tree**. There is also `RenderFragment<T>`,
    which accepts a further argument you can use to drive the markup generation. For
    instance, you can pass a `Customer` object to `RenderFragment<T>` so that it can
    render all the data for that specific customer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderFragment` 代理定义了一个函数，该函数能够向 **渲染树** 的特定位置添加更多标记。还有 `RenderFragment<T>`，它接受一个额外的参数，您可以使用它来驱动标记生成。例如，您可以将
    `Customer` 对象传递给 `RenderFragment<T>`，以便它可以渲染特定客户的全部数据。'
- en: 'You can define `RenderFragment` or `RenderFragment<T>` with C# code, but the
    simplest way is to define it in your components with Razor markup. The Razor compiler
    will take care of generating the proper C# code for you:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 C# 代码定义 `RenderFragment` 或 `RenderFragment<T>`，但最简单的方法是在您的组件中使用 Razor
    标记定义它。Razor 编译器将为您生成适当的 C# 代码：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The information on the location to add the markup is passed in the `RenderTreeBuilder`
    argument it receives as an argument. You can use `RenderFragment` in your component
    Razor markup by simply invoking it as shown in the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 添加标记的位置信息通过 `RenderTreeBuilder` 参数传递，该参数作为参数接收。您可以通过如下示例所示的方式在组件 Razor 标记中使用
    `RenderFragment`：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The position where you invoke `RenderFragment` defines the location where it
    will add its markup, since the component compiler is able to generate the right
    `RenderTreeBuilder` argument to pass to it. `RenderFragment<T>` delegates are
    invoked as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `RenderFragment` 的位置定义了它将添加标记的位置，因为组件编译器能够生成正确的 `RenderTreeBuilder` 参数传递给它。`RenderFragment<T>`
    代理调用如下所示：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Being functions, render fragments can be passed to component parameters like
    all other types. However, Blazor has a specific syntax to make it easier to simultaneously
    define and pass render fragments to components: the **template** syntax. First,
    you define the parameters in your component:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数，渲染片段可以像所有其他类型一样传递给组件参数。然而，Blazor 有一种特定的语法，使其更容易同时定义和传递渲染片段到组件：**模板** 语法。首先，在您的组件中定义参数：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, when you call the customer, you can do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当您调用客户时，您可以执行以下操作：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each `RenderFragment` parameter is represented by a tag with the same name as
    the parameter. You can place the markup that defines `RenderFragment` inside of
    it. For the `CustomerTemplate` that has a parameter, the `Context` keyword defines
    the parameter name inside the markup. In our example, the chosen parameter name
    is `customer`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `RenderFragment` 参数都由与参数同名的标签表示。您可以在其中放置定义 `RenderFragment` 的标记。对于具有参数的 `CustomerTemplate`，`Context`
    关键字在标记中定义参数名称。在我们的示例中，选择的参数名称是 `customer`。
- en: 'When a component has just one render fragment parameter, if it is named `ChildContent`,
    the template markup can be enclosed directly between the opening and closing tags
    of the component:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件只有一个渲染片段参数，如果它被命名为`ChildContent`，模板标记可以直接包裹在组件的开头和结尾标签之间：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order to familiarize ourselves with component templates, let’s modify the
    `Pages->Weather.razor` page so that, instead of using `foreach`, it uses a `Repeater`
    component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉组件模板，让我们修改`Pages->Weather.razor`页面，使其不再使用`foreach`，而是使用`Repeater`组件。
- en: 'Let’s right-click on the `Layout` folder, select **Add** and then **Razor Component**,
    and add a new `Repeater.razor` component. Then, replace the existing code with
    this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Layout`文件夹上右键单击，选择**添加**然后**Razor组件**，并添加一个新的`Repeater.razor`组件。然后，用以下代码替换现有的代码：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The component is defined with a generic parameter so that it can be used with
    any `IEnumerable`. Now let’s replace the markup in the `tbody` of the `Weather.razor`
    component with this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用泛型参数定义，以便它可以与任何`IEnumerable`一起使用。现在让我们用以下内容替换`Weather.razor`组件的`tbody`中的标记：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `Repeater` component has just one template, and since we named it
    `ChildContent`, we can place our template markup directly within the component
    open and close tags. Run it and verify that the page works properly. You have
    learned how to use templates and that markup placed inside a component defines
    a template.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Repeater`组件只有一个模板，并且我们将其命名为`ChildContent`，因此我们可以直接在组件的开头和结尾标签内放置模板标记。运行它并验证页面是否正常工作。你已经学会了如何使用模板，以及放置在组件内部标记定义了一个模板。
- en: 'An important predefined templated Blazor component is the `CascadingValue`
    component. It renders the content placed inside of it with no changes, but passes
    a type instance to all its descendant components:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的预定义模板化Blazor组件是`CascadingValue`组件。它以不改变的方式渲染其内部放置的内容，但将类型实例传递给所有其子组件：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All components placed inside of the `CascadingValue` tag and all their descendant
    components can now capture the instance of `MyOptionsInstance` passed in the `CascadingValue`
    parameter. It is enough that the component declares a public or private property
    with a type that is compatible with `MyOptionsInstance` and that decorates it
    with the `CascadingParameter` attribute:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所有放置在`CascadingValue`标签内及其所有子组件现在可以捕获通过`CascadingValue`参数传入的`MyOptionsInstance`实例。只要组件声明一个与`MyOptionsInstance`兼容类型的公共或私有属性，并用`CascadingParameter`属性装饰它就足够了：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Matching is performed by type compatibility. If there’s ambiguity with other
    cascaded parameters with a compatible type, we can specify the `Name` optional
    parameter of the `CascadingValue` component and pass the same name to the `CascadingParameter`
    attribute: `[CascadingParameter("myUnique name")]`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是通过类型兼容性进行的。如果有与兼容类型的其他级联参数的歧义，我们可以指定`CascadingValue`组件的`Name`可选参数，并将相同的名称传递给`CascadingParameter`属性：`[CascadingParameter("myUnique
    name")]`。
- en: The `CascadingValue` tag also has an `IsFixed` parameter that should be set
    to `true` whenever possible for performance reasons. In fact, propagating cascading
    values is very useful for passing options and settings, but it has a very high
    computational cost.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingValue`标签还有一个`IsFixed`参数，出于性能原因，尽可能应该将其设置为`true`。实际上，传播级联值对于传递选项和设置非常有用，但它有很高的计算成本。'
- en: When `IsFixed` is set to `true`, propagation is performed just once, the first
    time that each piece of content involved is rendered, and then no attempt is made
    to update the cascaded value during the content’s lifetime. Thus, `IsFixed` can
    be used whenever the pointer of the cascaded object is not changed during the
    content’s lifetime.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当`IsFixed`设置为`true`时，传播操作仅执行一次，即在涉及的内容首次渲染时执行，之后在内容的生命周期内不再尝试更新级联值。因此，`IsFixed`可以在内容的生命周期内级联对象的指针没有改变的情况下使用。
- en: An example of a cascading value is the `CascadingAuthenticationState` component
    we encountered in the *Routing* subsection, which cascades authentication and
    authorization information to all rendered components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 级联值的例子是我们遇到过的`CascadingAuthenticationState`组件，它在*路由*子节中将身份验证和授权信息级联到所有渲染的组件。
- en: Error handling
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'As the default, when an error in a component occurs, the exception is intercepted
    by the .NET runtime, which automatically makes visible the error code contained
    in `index.html`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当组件发生错误时，异常被.NET运行时拦截，它自动使`index.html`中包含的错误代码可见：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, component errors can be intercepted and handled locally by enclosing
    the component inside an `ErrorBoundary` component. Below, the code of the `Repeater`
    example in the previous subsection has been modified to locally handle errors
    that might occur in each row:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，组件错误可以被拦截并在 `ErrorBoundary` 组件内部本地处理。下面，对前一小节中的 `Repeater` 示例代码进行了修改，以本地处理可能发生在每一行的错误：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The standard code is placed in the `ChildContent` template, while the `ErrorContent`
    template is shown if there’s an error.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 标准代码放置在 `ChildContent` 模板中，而 `ErrorContent` 模板在出现错误时显示。
- en: Events
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'Both HTML tags and Blazor components use attributes/parameters to get input.
    HTML tags provide output to the remainder of the page through events, and Blazor
    allows C# functions to be attached to HTML `on{event name}` attributes. The syntax
    is shown in the `Pages->Counter.razor` component:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 标签和 Blazor 组件都使用属性/参数来获取输入。HTML 标签通过事件将输出提供给页面的其余部分，而 Blazor 允许将 C# 函数附加到
    HTML `on{事件名称}` 属性。语法在 `Pages->Counter.razor` 组件中显示：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The function can also be passed inline as a lambda. Moreover, it accepts the
    C# equivalent of the usual `event` argument. The *Further reading* section contains
    a link to the Blazor official documentation page that lists all supported events
    and their arguments.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以作为 lambda 表达式内联传递。此外，它接受 C# 中通常的 `event` 参数。*进一步阅读* 部分包含一个链接到 Blazor 官方文档页面，该页面列出了所有支持的事件及其参数。
- en: Since Blazor components are designed as enhanced versions of HTML elements—with
    added capabilities—they can also have events. However, unlike standard HTML elements,
    both the features and implementations of these events in Blazor components are
    defined by the developer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Blazor 组件被设计为 HTML 元素的增强版本——增加了功能——它们也可以有事件。然而，与标准 HTML 元素不同，Blazor 组件中这些事件的功能和实现都是由开发者定义的。
- en: 'Blazor events enable components to return output, too. Component events are
    defined as parameters whose type is either `EventCallBack` or `EventCallBack<T>`.
    `EventCallBack` is the type of component event with no arguments while `EventCallBack<T>`
    is the type of component event with an argument of type `T`. In order to trigger
    an event, say `MyEvent`, the component calls:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 事件还使组件能够返回输出。组件事件定义为类型为 `EventCallBack` 或 `EventCallBack<T>` 的参数。`EventCallBack`
    是没有参数的组件事件类型，而 `EventCallBack<T>` 是具有类型为 `T` 的参数的组件事件类型。为了触发一个事件，比如 `MyEvent`，组件调用：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: or
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These calls execute the handlers bound to the events or do nothing if no handler
    has been bound.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用执行绑定到事件的处理程序，如果没有绑定处理程序则不执行任何操作。
- en: 'Once defined, component events can be used exactly in the same way as HTML
    element events, the only difference being that there is no need to prefix the
    event name with an `@`, since `@` in HTML events is needed to distinguish between
    the HTML attribute and the Blazor-added parameter with the same name:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，组件事件可以像 HTML 元素事件一样使用，唯一的区别是无需在事件名称前加上 `@` 前缀，因为在 HTML 事件中 `@` 用于区分具有相同名称的
    HTML 属性和 Blazor 添加的参数：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Actually, HTML element events are also `EventCallBack<T>` events. That is why
    both event types behave in exactly the same way. `EventCallBack` and `EventCallBack<T>`
    are structs, not delegates, since they contain a delegate, together with a pointer
    to the entity that must be notified that the event has been triggered. Formally,
    this entity is represented by a `Microsoft.AspNetCore.Components.IHandleEvent`
    interface. Needless to say, all components implement this interface. The notification
    informs `IHandleEvent` that a state change took place. State changes play a fundamental
    role in the way Blazor updates the page HTML. We will analyze them in detail in
    the next subsection.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，HTML 元素事件也是 `EventCallBack<T>` 事件。这就是为什么这两种事件类型的行为完全相同。`EventCallBack` 和
    `EventCallBack<T>` 都是结构体，而不是委托，因为它们包含一个委托，以及一个指向必须通知事件已触发的实体的指针。正式来说，这个实体由 `Microsoft.AspNetCore.Components.IHandleEvent`
    接口表示。不用说，所有组件都实现了这个接口。通知告知 `IHandleEvent` 发生了状态变化。状态变化在 Blazor 更新页面 HTML 的方式中起着基本的作用。我们将在下一小节中详细分析它们。
- en: 'For HTML elements, Blazor also provides the possibility to stop the event’s
    default action and the event bubbling by adding the `:preventDefault` and `:stopPropagation`
    directives to the attribute that specifies the event, like in these examples:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTML 元素，Blazor 还提供了通过向指定事件的属性添加 `:preventDefault` 和 `:stopPropagation` 指令来停止事件默认操作和事件冒泡的可能性，如下例所示：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Bindings
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: Often, a component parameter value must be kept synchronized with an external
    variable, property, or field. The typical application of this kind of synchronization
    is an object property being edited in an input component or HTML tag. Whenever
    the user changes the input value, the object property must be updated coherently,
    and vice versa. The object property value must be copied into the component as
    soon as the component is rendered so that the user can edit it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，组件参数的值必须与外部变量、属性或字段保持同步。这种同步的典型应用是在输入组件或HTML标签中编辑的对象属性。每当用户更改输入值时，对象属性必须一致地更新，反之亦然。对象属性值必须在组件渲染后立即复制到组件中，以便用户可以编辑它。
- en: Similar scenarios are handled by parameter-event pairs. More specifically, from
    one side, the property is copied in the input component parameter. From the other
    side, each time the input changes value, a component event that updates the property
    is triggered. This way, property and input values are kept synchronized.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 相似的场景由参数-事件对处理。更具体地说，从一方面，属性被复制到输入组件的参数中。从另一方面，每次输入值发生变化时，都会触发一个更新属性的组件事件。这样，属性和输入值保持同步。
- en: This scenario is so common and useful that Blazor has a specific syntax for
    simultaneously defining the event and copying the property value into the parameter.
    This simplified syntax requires that the event has the same name as the parameter
    involved in the interaction but with a `Changed` postfix.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景非常常见且有用，因此Blazor有特定的语法来同时定义事件并将属性值复制到参数中。这种简化的语法要求事件与参与交互的参数具有相同的名称，但后面加上`Changed`后缀。
- en: 'Suppose, for instance, that a component has a `Value` parameter. Then, the
    corresponding event must be `ValueChanged`. Moreover, each time the user changes
    the component value, the component must invoke the `ValueChanged` event by calling
    `await ValueChanged.InvokeAsync(arg)`. With this in place, a property called `MyObject.MyProperty`
    can be synchronized with the `Value` property with the syntax shown here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个组件有一个`Value`参数。那么，相应的事件必须是`ValueChanged`。此外，每次用户更改组件值时，组件必须通过调用`await
    ValueChanged.InvokeAsync(arg)`来调用`ValueChanged`事件。有了这个，就可以使用以下语法将名为`MyObject.MyProperty`的属性与`Value`属性同步：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding syntax is called `binding`. Blazor takes care of automatically
    attaching an event handler that updates the `MyObject.MyProperty` property to
    the `ValueChanged` event.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法称为`绑定`。Blazor会自动处理将更新`MyObject.MyProperty`属性的事件处理器附加到`ValueChanged`事件。
- en: 'Bindings of HTML elements work in a similar way, but since the developer can’t
    decide the names of parameters and events, a slightly different convention must
    be used. First of all, there is no need to specify the parameter name in the binding,
    since it is always the HTML input `value` attribute. Therefore, the binding is
    written simply as `@bind="object.MyProperty"`. By default, the object property
    is updated on the `change` event, but you can specify a different event by adding
    the `@bind-event: @bind-event="oninput"` attribute.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTML元素的绑定以类似的方式工作，但由于开发者不能决定参数和事件的名称，因此必须使用稍微不同的约定。首先，在绑定中不需要指定参数名称，因为它始终是HTML输入的`value`属性。因此，绑定简单地写成`@bind="object.MyProperty"`。默认情况下，对象属性在`change`事件上更新，但您可以通过添加`@bind-event:
    @bind-event="oninput"`属性来指定不同的事件。'
- en: Moreover, bindings of HTML inputs try to automatically convert the input string
    into the target type. If the conversion fails, the input reverts to its initial
    value. This behavior is quite primitive since, in the event of errors, no error
    message is provided to the user, and the culture settings are not taken into account
    properly (HTML5 inputs use invariant culture but text input must use the current
    culture). We advise binding inputs only to string target types. Blazor has specific
    components for handling dates and numbers that should be used whenever the target
    type is not a string. We will describe these components in the *Blazor forms and
    validation* section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HTML输入的绑定尝试自动将输入字符串转换为目标类型。如果转换失败，输入将恢复到其初始值。这种行为相当原始，因为在出现错误的情况下，不会向用户提供错误消息，并且文化设置没有得到适当的考虑（HTML5输入使用不变的文化，但文本输入必须使用当前文化）。我们建议仅将输入绑定到字符串目标类型。Blazor有专门处理日期和数字的组件，当目标类型不是字符串时应该使用这些组件。我们将在*Blazor表单和验证*部分描述这些组件。
- en: 'In order to familiarize ourselves with events, let’s write a component that
    synchronizes the content of an input-type text when the user clicks a confirmation
    button. Let’s right-click on the `Layout` folder and add a new `ConfirmedText.razor`
    component. Then replace its code with this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉事件，让我们编写一个组件，当用户点击确认按钮时同步输入型文本的内容。让我们右键点击`Layout`文件夹，添加一个新的`ConfirmedText.razor`组件。然后替换其代码如下：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ConfirmedText` component exploits the button-click event to trigger the
    `ValueChanged` event. Moreover, the component uses `@bind` to synchronize its
    `Value` parameter with the HTML input. It is worth pointing out that the component
    uses `CaptureUnmatchedValues` to forward all HTML attributes applied to its tag
    to the HTML input. This way, users of the `ConfirmedText` component can style
    the input field by simply adding `class` and/or `style` attributes to the component
    tag.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmedText`组件利用按钮点击事件来触发`ValueChanged`事件。此外，组件使用`@bind`来同步其`Value`参数与HTML输入。值得注意的是，组件使用`CaptureUnmatchedValues`将应用于其标签的所有HTML属性转发到HTML输入。这样，`ConfirmedText`组件的用户可以通过简单地向组件标签添加`class`和/或`style`属性来对输入字段进行样式化。'
- en: 'Now, let’s use this component in the `Pages->Index.razor` page by placing the
    following code at the end of `Home.razor`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`Pages->Index.razor`页面中使用这个组件，将以下代码放置在`Home.razor`的末尾：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you run the project and play with the input and its **Confirm** button, you
    will see that each time the **Confirm** button is clicked, not only are the input
    values copied in the `textValue` page property but also the content of the paragraph
    that is behind the component is coherently updated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行项目并操作输入及其**确认**按钮，你会看到每次点击**确认**按钮时，不仅输入值被复制到`textValue`页面属性中，而且组件后面的段落内容也会连贯地更新。
- en: We explicitly synchronized `textValue` with the component with `@bind-Value`,
    but what takes care of keeping `textValue` synchronized with the content of the
    paragraph? The answer can be found in the next subsection.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`@bind-Value`显式地将`textValue`与组件同步，但谁负责保持`textValue`与段落内容的一致性？答案可以在下一个子节中找到。
- en: How Blazor updates HTML
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor如何更新HTML
- en: When we write the content of a variable, property, or field in Razor markup
    with something like `@model.property`, Blazor not only renders the actual value
    of the variable, property, or field when the component is rendered but tries also
    to update the HTML each time that this value changes, with a process called **change
    detection**. Change detection is a feature of all the main SPA frameworks, but
    the way Blazor implements it is very simple and elegant.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用类似`@model.property`的方式在Razor标记中写入变量、属性或字段的值时，Blazor不仅会在组件渲染时渲染变量、属性或字段的实际值，还会尝试在每次该值发生变化时更新HTML，这个过程称为**变更检测**。变更检测是所有主要SPA框架的一个特性，但Blazor实现它的方式非常简单且优雅。
- en: The basic idea is that once all HTML has been rendered, changes may occur only
    because of code executed inside of events. That is why `EventCallBack` and `EventCallBack<T>`
    contain a reference to an `IHandleEvent`. When a component binds a handler to
    an event, the Razor compiler creates an `EventCallBack` or `EventCallBack<T>`,
    passing its struct constructor the function bound to the event, and the component
    where the function was defined (`IHandleEvent`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，一旦所有HTML都已渲染，变化可能仅由于事件内部执行代码引起。这就是为什么`EventCallBack`和`EventCallBack<T>`包含对`IHandleEvent`的引用。当组件将处理程序绑定到事件时，Razor编译器创建一个`EventCallBack`或`EventCallBack<T>`，将绑定到事件的函数及其定义函数的组件（`IHandleEvent`）传递给结构构造函数。
- en: Once the code of the handler has been executed, the Blazor runtime is notified
    that the `IHandleEvent` might have changed. In fact, the handler code can only
    change the values of variables, properties, or fields of the component where the
    handler was defined. In turn, this triggers a change detection process rooted
    in the component. Blazor verifies which variables, properties, or fields used
    in the component Razor markup changed and updates the associated HTML.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理程序的代码执行完毕，Blazor运行时会通知`IHandleEvent`可能已更改。实际上，处理程序代码只能更改处理程序定义的组件中变量、属性或字段的值。反过来，这会触发以组件为根的变更检测过程。Blazor验证组件Razor标记中哪些变量、属性或字段已更改，并更新相关的HTML。
- en: If a changed variable, property, or field is an input parameter of another component,
    then the HTML generated by that component might also need updates. Accordingly,
    another change detection process rooted in that component is recursively triggered.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改的变量、属性或字段是另一个组件的输入参数，则该组件生成的HTML可能也需要更新。因此，从该组件根生的另一个更改检测过程被递归触发。
- en: 'The algorithm sketched previously discovers all relevant changes only if the
    following conditions are met:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 之前概述的算法只有在满足以下条件时才能发现所有相关更改：
- en: No component references data structures belonging to other components in an
    event handler.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器中不会引用属于其他组件的数据结构。
- en: All inputs to a component arrive through its parameters and not through method
    calls or other public members.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的所有输入都通过其参数传入，而不是通过方法调用或其他公共成员。
- en: When there is a change that is not detected because of the failure of one of
    the preceding conditions, the developer must manually declare the possible change
    of the component. This can be done by calling the `StateHasChanged()` component
    method. Since this call might result in changes to the page’s HTML, its execution
    cannot take place asynchronously but must be queued in the HTML page’s UI thread.
    This is done by passing the function to be executed to the `InvokeAsync` component
    method.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当由于前一个条件之一失败而未检测到更改时，开发者必须手动声明组件的可能更改。这可以通过调用`StateHasChanged()`组件方法来完成。由于此调用可能会导致页面HTML的变化，其执行不能异步进行，而必须在HTML页面的UI线程中排队。这是通过将要执行的功能传递给`InvokeAsync`组件方法来完成的。
- en: Summing up, the instruction to execute is `await InvokeAsync(StateHasChanged)`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，要执行的指令是`await InvokeAsync(StateHasChanged)`。
- en: The next subsection concludes the description of components with an analysis
    of their lifecycle and the associated lifecycle methods.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节通过分析组件的生命周期及其相关生命周期方法来结束对组件的描述。
- en: Component lifecycle
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Each component lifecycle event has an associated method. Some methods have both
    synchronous and asynchronous versions, some have just an asynchronous version,
    and some others have just a synchronous version.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件生命周期事件都有一个相关的方法。一些方法既有同步版本也有异步版本，一些方法只有异步版本，还有一些方法只有同步版本。
- en: 'The component lifecycle starts with parameters passed to the component being
    copied in the associated component properties. You can customize this step by
    overriding the following method:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期从将传递给组件的参数复制到相关组件属性开始。您可以通过重写以下方法来自定义此步骤：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Typically, customization consists of the modification of additional data structures,
    so the base method is called to also perform the default action of copying parameters
    in the associated properties.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，自定义包括修改额外的数据结构，因此会调用基方法以执行在相关属性中复制参数的默认操作。
- en: 'After that, there is the component initialization that is associated with the
    two methods:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，还有与两个方法关联的组件初始化：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: They are called once in the component lifetime, immediately after the component
    has been created and added to the render tree. Please place any initialization
    code there, and not in the component constructor, as this will improve component
    testability. This is because there, you have all parameters set and future Blazor
    versions might pool and reuse component instances.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在组件生命周期中只调用一次，在组件被创建并添加到渲染树之后立即调用。请在此处放置任何初始化代码，而不是在组件构造函数中，因为这将提高组件的可测试性。这是因为在那里，所有参数都已设置，未来的Blazor版本可能会池化和重用组件实例。
- en: If the initialization code subscribes to some events or performs actions that
    need a cleanup when the component is destroyed, implement `IDisposable`, and place
    all the cleanup code in its `Dispose` method. Whenever a component implements
    `IDisposable`, Blazor calls its `Dispose` method before destroying it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始化代码订阅了一些事件或执行在组件销毁时需要清理的操作，则实现`IDisposable`，并将所有清理代码放在其`Dispose`方法中。每当组件实现`IDisposable`时，Blazor都会在销毁它之前调用其`Dispose`方法。
- en: 'After the component has been initialized, and each time a component parameter
    changes, the following two methods are called:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件初始化之后，并且每次组件参数发生变化时，都会调用以下两个方法：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: They are the right place to update data structures that depend on the values
    of the component parameters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是更新依赖于组件参数值的数组的正确位置。
- en: 'After that, the component is rendered or re-rendered. You can prevent component
    re-rendering after an update by overriding the `ShouldRender` method:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，组件将被渲染或重新渲染。您可以通过覆盖`ShouldRender`方法来防止组件在更新后重新渲染：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Letting a component re-render only if you are sure its HTML code will change
    is an advanced optimization technique used in the implementation of component
    libraries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你确定组件的HTML代码将改变时，才重新渲染组件，这是一种在组件库实现中使用的先进优化技术。
- en: 'The component rendering stage also involves the invocation of its children
    components. Therefore, component rendering is considered complete only after all
    its descendant components have completed their rendering too. When rendering is
    complete, the following methods are called:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 组件渲染阶段还涉及到其子组件的调用。因此，只有当所有子组件都完成它们的渲染后，组件渲染才被认为是完整的。当渲染完成后，以下方法会被调用：
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since when the preceding methods are called, all component HTML has been updated
    and all children components have executed all their lifetime methods, the preceding
    methods are the right places for performing the following operations:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在调用上述方法时，所有组件的HTML都已更新，所有子组件都已执行它们的所有生命周期方法，因此上述方法是执行以下操作的正确位置：
- en: Calling JavaScript functions that manipulate the generated HTML. JavaScript
    calls are described in the JavaScript interoperability subsection.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用操作生成的HTML的JavaScript函数。JavaScript调用在JavaScript互操作性子部分中描述。
- en: Processing information attached to parameters or cascaded parameters by descendant
    components. In fact, tab-like components and other components might need to register
    some of their subparts in the root component, so the root component typically
    cascades a data structure where some children components can register. Code written
    in `AfterRender` and `AfterRenderAsync` can rely on the fact that all the parts
    have completed their registration.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理附加到参数或由子组件级联的参数的信息。实际上，类似于标签页的组件和其他组件可能需要在根组件中注册它们的一些子部分，因此根组件通常级联一个数据结构，其中一些子组件可以注册。在`AfterRender`和`AfterRenderAsync`中编写的代码可以依赖于所有部分都已完成注册的事实。
- en: The next section describes Blazor tools for collecting user input.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分描述了Blazor工具用于收集用户输入。
- en: Blazor forms and validation
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor表单和验证
- en: Similar to all major SPA frameworks, Blazor offers specific tools for processing
    user input while providing valid feedback to the user with error messages and
    immediate visual clues.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有主要的SPA框架类似，Blazor提供了特定的工具来处理用户输入，同时通过错误消息和即时视觉提示向用户提供有效的反馈。
- en: In classic HTML websites, HTML forms are used to collect input, validate it,
    and send it to the server. In client frameworks, data is not sent to the server
    by submitting forms, but forms retain their validation purpose. More specifically,
    they act as validation units, that is, as a container for inputs that must be
    validated together because they belong to a unique task. Accordingly, when a submit
    button is clicked, an overall validation is performed, and the system notifies
    of the result via events. This way, the developer can define what to do in case
    of errors and what actions to take when the user has successfully completed their
    input.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的HTML网站上，HTML表单用于收集输入、验证它并将其发送到服务器。在客户端框架中，提交表单时不会将数据发送到服务器，但表单保留了它们的验证目的。更具体地说，它们充当验证单元，即作为必须一起验证的输入的容器，因为它们属于一个独特任务。因此，当点击提交按钮时，会执行整体验证，并通过事件通知结果。这样，开发者可以定义在出现错误时该做什么，以及当用户成功完成输入时应采取哪些行动。
- en: It is worth pointing out that validation performed on the client side doesn’t
    ensure data integrity because a malicious user could easily hack all client validation
    rules because they have full access to the client-side code in their browser.
    The purpose of client-side validation is just to provide immediate feedback to
    the user.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在客户端执行的验证并不保证数据完整性，因为恶意用户可以轻易地破解所有客户端验证规则，因为他们可以完全访问他们浏览器中的客户端代码。客户端验证的目的只是向用户提供即时反馈。
- en: Accordingly, the validation step must be repeated on the server side to enforce
    data integrity.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，验证步骤必须在服务器端重复执行，以确保数据完整性。
- en: Both server-side and client-side validation can be performed with the same code
    shared between the Blazor client and the server. In fact, both the ASP.NET Core
    REST API and Blazor support validation based on validation attributes, so it is
    enough to share the same ViewModels equipped with validation attributes between
    the Blazor and server projects by putting them in a library that is referenced
    by both projects. ASP.NET Core validation is discussed in the *Server-side and
    client-side validation* section of *Chapter 17*, *Presenting ASP.NET Core*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端和客户端验证可以使用在 Blazor 客户端和服务器之间共享的相同代码进行。实际上，ASP.NET Core REST API 和 Blazor
    都支持基于验证属性的验证，因此只需将带有验证属性的 ViewModels 放在一个由两个项目引用的库中，就可以在 Blazor 和服务器项目之间共享相同的
    ViewModels。ASP.NET Core 验证在 *第 17 章*，*展示 ASP.NET Core* 的 *服务器端和客户端验证* 部分中讨论。
- en: The whole toolset is known as **Blazor Forms** and consists of a form component
    called `EditForm`, various input components, a data annotation validator, a validation
    error summary, and validation error labels.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 整个工具集被称为 **Blazor 表单**，它由一个名为 `EditForm` 的表单组件、各种输入组件、数据注释验证器、验证错误摘要和验证错误标签组成。
- en: '`EditForm` takes care of orchestrating the state of all input components through
    an instance of the `EditContext` class that is cascaded inside of the form. The
    orchestration comes from the interaction of both input components and the data
    annotation validator with this `EditContext` instance. A validation summary and
    error message labels don’t take part in the orchestration but register to some
    `EditContext` events to be informed about errors.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm` 通过在表单内部级联的 `EditContext` 类的实例来管理所有输入组件的状态。协调来自输入组件和数据注释验证器与该 `EditContext`
    实例的交互。验证摘要和错误消息标签不参与协调，但会注册到某些 `EditContext` 事件以了解错误。'
- en: '`EditForm` must be passed the object whose properties must be rendered in its
    `Model` parameter. It is worth pointing out that input components bound to nested
    properties are not validated, so `EditForm` must be passed a flattened ViewModel.
    `EditForm` creates a new `EditContext` instance, passes the object received in
    its `Model` parameter in its constructor, and cascades it so it can interact with
    the form content.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm` 必须传递一个对象，其属性必须在 `Model` 参数中渲染。值得注意的是，绑定到嵌套属性的输入组件不会被验证，因此 `EditForm`
    必须传递一个扁平化的 ViewModel。`EditForm` 创建一个新的 `EditContext` 实例，将其在 `Model` 参数中接收到的对象传递给其构造函数，并级联它以便它可以与表单内容交互。'
- en: You can also directly pass an `EditContext` custom instance in the `EditContext`
    parameter of `EditForm` instead of passing the object in its `Model` parameter,
    in which case `EditForm` will use your custom copy instead of creating a new instance.
    Typically, you do this when you need to subscribe to the `EditContext` `OnValidationStateChanged`
    and `OnFieldChanged` events.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以直接在 `EditForm` 的 `EditContext` 参数中传递一个自定义的 `EditContext` 实例，而不是在 `Model`
    参数中传递对象，在这种情况下，`EditForm` 将使用您的自定义副本而不是创建一个新实例。通常，您这样做是为了订阅 `EditContext` 的 `OnValidationStateChanged`
    和 `OnFieldChanged` 事件。
- en: When `EditForm` is submitted with a **Submit** button and there are no errors,
    the form invokes its `OnValidSubmit` callback, where you can place the code that
    uses and processes the user input. If instead there are validation errors, they
    are displayed, and the form invokes its `OnInvalidSubmit` callback.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `EditForm` 与一个 **提交** 按钮一起提交且没有错误时，表单将调用其 `OnValidSubmit` 回调，您可以在其中放置使用和处理用户输入的代码。如果存在验证错误，它们将被显示，并且表单将调用其
    `OnInvalidSubmit` 回调。
- en: The state of each input is reflected in some CSS classes that are automatically
    added to them, namely `valid`, `invalid`, and `modified`. You can use these classes
    to provide adequate visual feedback to the user. The default Blazor template already
    provides some CSS for them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输入的状态都反映在自动添加到它们的某些 CSS 类中，即 `valid`、`invalid` 和 `modified`。您可以使用这些类为用户提供适当的视觉反馈。默认的
    Blazor 模板已经为它们提供了某些 CSS。
- en: 'Here is a typical form:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的表单：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The label is a standard HTML label, while `InputNumber` is a Blazor-specific
    component for number properties. `ValidationMessage` is the error label that appears
    only in the event of a validation error. By default, it is rendered with a `validation-message`
    CSS class. The property associated with the error message is passed in the `for`
    parameter with a parameterless lambda, as shown in the example.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是一个标准的HTML标签，而`InputNumber`是Blazor特定的用于数字属性的组件。`ValidationMessage`是仅在验证错误发生时出现的错误标签。默认情况下，它使用`validation-message`CSS类进行渲染。与错误消息关联的属性通过不带参数的lambda表达式传递到`for`参数中，如示例所示。
- en: The `DataAnnotationsValidator` component adds a validation based on the usual
    .NET validation attributes, such as `RangeAttribute`, `RequiredAttribute`, and
    so on. You can also write your custom validation attributes by inheriting from
    the `ValidationAttribute` class.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataAnnotationsValidator`组件添加了基于通常的.NET验证属性（如`RangeAttribute`、`RequiredAttribute`等）的验证。您还可以通过从`ValidationAttribute`类继承来编写自定义验证属性。'
- en: You can provide custom error messages in the validation attributes. If they
    contain a `{0}` placeholder, this will be filled with the property display name
    declared in a `DisplayAttribute`, if one is found, otherwise with the property
    name.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在验证属性中提供自定义错误消息。如果它们包含一个`{0}`占位符，则该占位符将被在`DisplayAttribute`中声明的属性显示名称填充，如果找到了，否则将使用属性名称。
- en: Together with the `InputNumber` component, Blazor also supports an `InputText`
    component for `string` properties, an `InputTextArea` component for `string` properties
    to be edited in an HTML `textarea`, an `InputCheckbox` component for `bool` properties,
    and an `InputDate` component that renders `DateTime` and `DateTimeOffset` as dates.
    They all work in exactly the same way as the `InputNumber` component. No component
    is available for other HTML5 input types. In particular, no component is available
    for rendering time or date and time, or for rendering numbers with a `range` widget.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与`InputNumber`组件一起，Blazor还支持用于`string`属性的`InputText`组件、用于在HTML`textarea`中编辑的`string`属性的`InputTextArea`组件、用于`bool`属性的`InputCheckbox`组件以及将`DateTime`和`DateTimeOffset`渲染为日期的`InputDate`组件。它们的工作方式与`InputNumber`组件完全相同。没有组件可用于其他HTML5输入类型。特别是，没有组件可用于渲染时间或日期和时间，或用于使用`range`小部件渲染数字。
- en: If you need HTML5 inputs that are not available as Blazor input form components,
    you are left with the option of implementing them yourself or of using a third-party
    library that supports them.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要作为Blazor输入表单组件不可用的HTML5输入，您可以选择自行实现它们或使用支持它们的第三方库。
- en: 'You can implement rendering time or date and time by inheriting from the `InputBase<TValue>`
    class and overriding the `BuildRenderTree`, `FormatValueAsString`, and `TryParseValueFromString`
    methods. The sources of the `InputNumber` component show how to do this: [https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs](https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs).
    You can also use the third-party libraries described in the *Third-party tools
    for Blazor WebAssembly* section.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从`InputBase<TValue>`类继承并重写`BuildRenderTree`、`FormatValueAsString`和`TryParseValueFromString`方法来实现渲染时间或日期和时间。`InputNumber`组件的源代码展示了如何做到这一点：[https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs](https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs)。您还可以使用*Blazor
    WebAssembly第三方工具*部分中描述的第三方库。
- en: 'Blazor also has a specific component for rendering a `select`, which works
    as in the following example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor还有一个用于渲染`select`的特定组件，其工作方式如下面的示例所示：
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Starting from .NET 6, `InputSelect` can also be bound to `IEnnumerable<T>` properties,
    in which case it is rendered as a multi-select.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 6开始，`InputSelect`也可以绑定到`IEnnumerable<T>`属性，在这种情况下，它被渲染为多选。
- en: 'One can also render enumerations with a radio group thanks to the `InputRadioGroup`
    and `InputRadio` components, as shown in the following example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用`InputRadioGroup`和`InputRadio`组件来使用单选组渲染枚举，如下面的示例所示：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, Blazor also offers an `InputFile` component together with all the tools
    for processing and uploading the file. We will not cover this here, but the *Further
    reading* section contains links to the official documentation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Blazor还提供了一个`InputFile`组件以及处理和上传文件的全部工具。这里不会详细介绍，但*进一步阅读*部分包含了指向官方文档的链接。
- en: The next section describes Blazor tools for modifying the host page `<head>`
    tag.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节描述了用于修改宿主页面`<head>`标签的Blazor工具。
- en: Modifying HTML <head> content from Blazor components
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Blazor 组件修改 HTML <head> 内容
- en: 'Since the whole component tree is placed inside the body of the `index.html`
    host page, the components markup has no direct access to the `index.html` host
    page `<head>` tag. Modifying the content of the `<head>` tag is necessary when
    the developer would like to adapt the title shown in the browser tab to the actual
    Blazor page that is being displayed. In fact, this title is contained within the
    `<head>` tag:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个组件树都放置在 `index.html` 主页的 `body` 中，组件标记无法直接访问 `index.html` 主页的 `<head>` 标签。当开发者想要将浏览器标签中显示的标题适配到实际显示的
    Blazor 页面时，修改 `<head>` 标签的内容是必要的。实际上，这个标题包含在 `<head>` 标签中：
- en: '[PRE45]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For this reason, the .NET 6 version of Blazor introduced specific constructs
    for modifying the host page `<head>` tag from inside Blazor components.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，.NET 6 版本的 Blazor 引入了从 Blazor 组件内部修改宿主页面 `<head>` 标签的特定结构。
- en: 'First of all, we must inform the Blazor application about how to reach the
    `<head>` tag content. This is done in `Program.cs` with the same technique used
    to specify the Blazor application root:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须通知 Blazor 应用程序如何访问 `<head>` 标签内容。这通过 `Program.cs` 中与指定 Blazor 应用程序根相同的技巧来完成：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After that, each component can replace the HTML title by specifying the new
    string inside a `PageTitle` component instance:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，每个组件都可以通过在 `PageTitle` 组件实例中指定新的字符串来替换 HTML 标题：
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Moreover, each component can append other HTML content to the `<head>` tag
    by placing it inside a `HeadContent` instance:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个组件还可以通过将其放置在 `HeadContent` 实例中来向 `<head>` 标签追加其他 HTML 内容：
- en: '[PRE48]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this section, you learned all that is needed to write a simple Blazor application
    that doesn’t exchange data with a server. The next section analyzes some advanced
    features and will enable you to interact with a server to handle authentication,
    authorization, and more.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了编写一个不与服务器交换数据的简单 Blazor 应用程序所需的所有内容。下一节将分析一些高级功能，并使你能够与服务器交互以处理身份验证、授权等。
- en: Blazor advanced features
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor 高级功能
- en: 'This section provides short descriptions of various Blazor advanced features
    organized into subsections:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了关于各种 Blazor 高级功能的简短描述，并按子节组织：
- en: References to components and HTML elements
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对组件和 HTML 元素的引用
- en: JavaScript interoperability
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 互操作性
- en: Globalization and localization
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全球化和本地化
- en: Authentication and authorization
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: Communication with the server
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与服务器的通信
- en: AOT compilation
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOT 编译
- en: Because of a lack of space, we can’t give all the details of each feature, but
    the details are covered by links in the *Further reading* section. We start with
    how to reference components and HTML elements defined in Razor markup.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间有限，我们无法提供每个功能的全部细节，但详细内容在 *进一步阅读* 部分的链接中有所涵盖。我们首先介绍如何引用在 Razor 标记中定义的组件和
    HTML 元素。
- en: References to components and HTML elements
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对组件和 HTML 元素的引用
- en: 'Sometimes, we might need a reference to a component in order to call some of
    its methods. This is the case, for instance, for a component that implements a
    modal window:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要一个组件的引用来调用其某些方法。例如，对于实现模态窗口的组件来说就是这样：
- en: '[PRE49]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As the preceding example shows, references are captured with the `@ref` directive.
    The same `@ref` directive can also be used to capture references to HTML elements.
    HTML references have an `ElementReference` type and are typically used to call
    JavaScript functions on HTML elements, as explained in the next subsection.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，引用是通过 `@ref` 指令捕获的。相同的 `@ref` 指令也可以用来捕获 HTML 元素的引用。HTML 引用具有 `ElementReference`
    类型，通常用于在 HTML 元素上调用 JavaScript 函数，如下一小节所述。
- en: JavaScript interoperability
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 互操作性
- en: Since Blazor doesn’t expose all JavaScript features to C# code, and since it
    is convenient to take advantage of the huge JavaScript code base, sometimes it
    is necessary to invoke JavaScript functions. Blazor allows this through the `IJSRuntime`
    interface that can be injected into a component via dependency injection.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Blazor 并没有将所有 JavaScript 功能暴露给 C# 代码，并且利用庞大的 JavaScript 代码库很方便，有时需要调用 JavaScript
    函数。Blazor 通过 `IJSRuntime` 接口允许这样做，该接口可以通过依赖注入将到组件中。
- en: 'Once we have an `IJSRuntime` instance, a JavaScript function that returns a
    value can be called as shown here:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `IJSRuntime` 实例，就可以像下面这样调用返回值的 JavaScript 函数：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Functions that do not return any argument can be invoked as shown here:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回任何参数的函数可以像下面这样调用：
- en: '[PRE51]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Arguments can be either basic types or objects that can be serialized in JSON,
    while the name of the JavaScript function is a string that can contain dots that
    represent access to properties, sub-properties, and method names, such as the
    `"myJavaScriptObject.myProperty.myMethod"` string.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是基本类型或可以序列化为 JSON 的对象，而 JavaScript 函数的名称是一个字符串，可以包含表示访问属性、子属性和方法名的点，例如 `"myJavaScriptObject.myProperty.myMethod"`
    字符串。
- en: 'Thus, for instance, we can save a string in the browser’s local storage with
    the following code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，我们可以使用以下代码在浏览器本地存储中保存一个字符串：
- en: '[PRE52]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Arguments can also be `ElementReference` instances captured with the `@ref`
    directive, in which case they are received as HTML elements on the JavaScript
    side.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也可以是使用 `@ref` 指令捕获的 `ElementReference` 实例，在这种情况下，它们在 JavaScript 端作为 HTML 元素接收。
- en: The JavaScript functions invoked must be defined either in the `Index.html`
    file or in JavaScript files referenced in `Index.html`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的 JavaScript 函数必须在 `Index.html` 文件中定义，或者是在 `Index.html` 中引用的 JavaScript 文件中定义。
- en: 'If you are writing a component library with a Razor library project, JavaScript
    files can be embedded together with CSS files as resources in the DLL library.
    You just need to add a `wwwroot` folder in the project root and place the needed
    CSS and JavaScript files in that folder or some subfolder of it. After that, these
    files can be referenced as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Razor 库项目编写组件库，JavaScript 文件可以与 CSS 文件一起作为资源嵌入到 DLL 库中。你只需在项目根目录中添加一个
    `wwwroot` 文件夹，并将所需的 CSS 和 JavaScript 文件放置在该文件夹或其子文件夹中。之后，这些文件可以按照以下方式引用：
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Accordingly, if the filename is `myJsFile.js`, the DLL name is `MyCompany.MyLibrary`,
    and the file is placed in the `js` folder inside `wwwroot`, then its reference
    will be:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果文件名为 `myJsFile.js`，DLL 名称是 `MyCompany.MyLibrary`，并且文件放置在 `wwwroot` 内的 `js`
    文件夹中，那么它的引用将是：
- en: '[PRE54]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It is worth pointing out that all CSS files added to components (CSS isolation)
    we mentioned earlier in this chapter are compiled into a unique CSS file that
    is added as a DLL resource. This file must be referenced in the `index.html` page
    as:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，我们在这章前面提到的所有添加到组件（CSS 隔离）中的 CSS 文件都被编译成一个唯一的 CSS 文件，该文件作为 DLL 资源添加。此文件必须在
    `index.html` 页面上引用，如下所示：
- en: '[PRE55]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If your JavaScript files are organized as ES6 modules, you can avoid referencing
    them in `Index.html` and can load the modules directly, as shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 JavaScript 文件以 ES6 模块的形式组织，你可以避免在 `Index.html` 中引用它们，并可以直接加载这些模块，如下所示：
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In addition, instance methods of C# objects can be called from JavaScript code,
    by taking the following steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以通过以下步骤从 JavaScript 代码中调用 C# 对象的实例方法：
- en: Say the C# method is called `MyMethod`. Decorate the `MyMethod` method with
    the `[JSInvokable]` attribute.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 C# 方法名为 `MyMethod`。使用 `[JSInvokable]` 属性装饰 `MyMethod` 方法。
- en: 'Enclose the C# object in a `DotNetObjectReference` instance and pass it to
    JavaScript with a JavaScript call:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 C# 对象封装在 `DotNetObjectReference` 实例中，并通过 JavaScript 调用将其传递给 JavaScript：
- en: '[PRE57]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'On the JavaScript side, say the C# object is in a variable called `dotnetObject`.
    Then, we just need to invoke:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JavaScript 端，假设 C# 对象存储在一个名为 `dotnetObject` 的变量中。然后，我们只需调用：
- en: '[PRE58]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The **Awesome Blazor** project ([https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor))
    lists a lot of open-source projects that use JavaScript’s interoperability to
    build .NET wrappers for well-known JavaScript libraries. There, you can find wrappers
    for 3D graphics JavaScript libraries, plot JavaScript libraries, and so on.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**Awesome Blazor** 项目（[https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor)）列出了许多使用
    JavaScript 的互操作性来构建知名 JavaScript 库的 .NET 包装器的开源项目。在那里，你可以找到 3D 图形 JavaScript 库的包装器、绘图
    JavaScript 库等。'
- en: The next section explains how to handle contents and number/date localization.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将解释如何处理内容和数字/日期本地化。
- en: Globalization and localization
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球化和本地化
- en: As soon as the Blazor application starts, both the application culture and the
    application UI culture are set to the browser culture. However, the developer
    can change both of them by assigning the chosen cultures to `CultureInfo.DefaultThreadCurrentCulture`
    and `CultureInfo.DefaultThreadCurrentUICulture`. Typically, the application lets
    the user choose one of its supported cultures, or it accepts the browser culture
    only if it is supported; otherwise, it falls back to a supported culture. In fact,
    it is possible to support just a reasonable number of cultures because all application
    strings must be translated into all supported cultures.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Blazor应用程序启动，应用程序文化和应用程序UI文化都将设置为浏览器文化。然而，开发者可以通过将选定的文化赋值给`CultureInfo.DefaultThreadCurrentCulture`和`CultureInfo.DefaultThreadCurrentUICulture`来更改这两个设置。通常，应用程序允许用户选择其支持的文化之一，或者如果浏览器文化被支持，则接受浏览器文化；否则，将回退到支持的文化。实际上，只支持合理数量的文化是可能的，因为所有应用程序字符串都必须翻译成所有支持的文化。
- en: If the application must support a single culture, this culture can be set once
    and for all in `program.cs` after the host has been built but before the host
    is run.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序必须支持单一文化，可以在构建宿主之后但在运行宿主之前，在`program.cs`中将此文化一次性设置。
- en: 'This can be done by replacing await `builder.Build().RunAsync()` with:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将`await builder.Build().RunAsync()`替换为以下内容来完成：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If the application must support several languages, the code is similar, but
    the culture information must be taken from the browser’s local storage, where
    the user must be given the option to store it in some applications option page.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序必须支持多种语言，代码类似，但必须从浏览器本地存储中获取文化信息，用户必须在某些应用程序选项页中提供存储该信息的选项。
- en: Once the `CurrentCulture` is set, dates and numbers are automatically formatted
    according to the conventions of the chosen culture. For the UI culture, the developer
    must manually provide resource files with the translations of all application
    strings in all supported cultures. Blazor uses the same localization/globalization
    techniques, so please refer to the *ASP.NET Core globalization* section of *Chapter
    17*, *Presenting ASP.NET Core*, for more details.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了`CurrentCulture`，日期和数字将自动根据所选文化的约定进行格式化。对于UI文化，开发者必须手动提供包含所有支持文化中所有应用程序字符串的翻译的资源文件。Blazor使用相同的本地化/全球化技术，因此请参阅第17章“展示ASP.NET
    Core”中的*ASP.NET Core全球化*部分以获取更多详细信息。
- en: 'There are two ways to use resource files. With the first option, you create
    a resource file, say, `myResource.resx`, and then add all language-specific files:
    `myResource.it.resx`, `myResource.pt.resx`, and so on. In this case, Visual Studio
    creates a static class named `myResource` whose static properties are the keys
    of each resource file. These properties will automatically contain the localized
    strings corresponding to the current UI culture. You can use these static properties
    wherever you like, and you can use pairs composed of a resource type and a resource
    name to set the `ErrorMessageResourceType` and `ErrorMessageResourceName` properties
    of validation attributes or similar properties of other attributes. This way,
    the attributes will use an automatically localized string.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资源文件有两种方式。使用第一种选项，您创建一个资源文件，例如`myResource.resx`，然后添加所有特定语言的文件：`myResource.it.resx`、`myResource.pt.resx`等。在这种情况下，Visual
    Studio创建一个名为`myResource`的静态类，其静态属性是每个资源文件的键。这些属性将自动包含与当前UI文化对应的本地化字符串。您可以在任何地方使用这些静态属性，并且可以使用由资源类型和资源名称组成的对来设置验证属性或其他属性的`ErrorMessageResourceType`和`ErrorMessageResourceName`属性。这样，属性将使用自动本地化的字符串。
- en: With the second option, you add only language-specific resource files (`myResource.it.resx`,
    `myResource.pt.resx`, and so on). In this case, Visual Studio doesn’t create any
    class associated with the resource file, and you can use resource files together
    with `IStringLocalizer` and `IStringLocalizer<T>` injected in components as you
    use them in ASP.NET Core MVC views (see the *ASP.NET Core globalization* section
    of *Chapter 17*, *Presenting ASP.NET Core*).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二种选项，您只需添加特定语言的资源文件（例如`myResource.it.resx`、`myResource.pt.resx`等）。在这种情况下，Visual
    Studio不会为资源文件创建任何关联的类，您可以使用资源文件，就像在ASP.NET Core MVC视图中使用它们一样，与注入到组件中的`IStringLocalizer`和`IStringLocalizer<T>`一起使用（参见第17章“展示ASP.NET
    Core”中的*ASP.NET Core全球化*部分）。
- en: Authentication and authorization
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和授权
- en: In the *Routing* subsection, we discussed how the `CascadingAuthenticationState`
    and `AuthorizeRouteView` components prevent unauthorized users from accessing
    pages protected with an `[Authorize]` attribute. Let’s go deeper into the details
    of how page authorization works.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *路由* 子节中，我们讨论了 `CascadingAuthenticationState` 和 `AuthorizeRouteView` 组件如何防止未经授权的用户访问带有
    `[Authorize]` 属性保护的页面。让我们更深入地探讨页面授权的工作原理。
- en: In .NET applications, authentication and authorization information is usually
    contained in a `ClaimsPrincipal` instance. In server applications, this instance
    is built when the user logs in, taking the required information from a database.
    In Blazor WebAssembly, such information must be provided by some remote server
    that takes care of SPA authentication too. Since there are several ways to provide
    authentication and authorization to a Blazor WebAssembly application, Blazor defines
    the `AuthenticationStateProvider` abstraction.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 应用程序中，身份验证和授权信息通常包含在 `ClaimsPrincipal` 实例中。在服务器应用程序中，当用户登录时构建此实例，从数据库中获取所需信息。在
    Blazor WebAssembly 中，此类信息必须由某个远程服务器提供，该服务器还负责处理 SPA 身份验证。由于有几种方法可以为 Blazor WebAssembly
    应用程序提供身份验证和授权，Blazor 定义了 `AuthenticationStateProvider` 抽象。
- en: Authentication and authorization providers inherit from the `AuthenticationStateProvider`
    abstract class and override its `GetAuthenticationStateAsync` method, which returns
    `Task<AuthenticationState>`, where `AuthenticationState` contains the authentication
    and authorization information. Actually, `AuthenticationState` contains just a
    `User` property with a `ClaimsPrincipal`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权提供程序继承自 `AuthenticationStateProvider` 抽象类，并重写其 `GetAuthenticationStateAsync`
    方法，该方法返回 `Task<AuthenticationState>`，其中 `AuthenticationState` 包含身份验证和授权信息。实际上，`AuthenticationState`
    只包含一个具有 `ClaimsPrincipal` 的 `User` 属性。
- en: 'Once we’ve defined a concrete implementation of `AuthenticationStateProvider`,
    we must register it in the dependency engine container in the application’s `Program.cs`
    file:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了 `AuthenticationStateProvider` 的具体实现，我们必须在应用程序的 `Program.cs` 文件中的依赖引擎容器中注册它：
- en: '[PRE60]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We will return to the predefined implementations of `AuthenticationStateProvider`
    offered by Blazor after having described how Blazor uses authentication and authorization
    information provided by a registered `AuthenticationStateProvider`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了 Blazor 如何使用由已注册的 `AuthenticationStateProvider` 提供的身份验证和授权信息之后，我们将回到 Blazor
    提供的预定义 `AuthenticationStateProvider` 实现。
- en: 'The `CascadingAuthenticationState` component calls the `GetAuthenticationStateAsync`
    method of the registered `AuthenticationStateProvider` and cascades the returned
    `Task<AuthenticationState>`. You can intercept this cascading value with a `[CascadingParameter]`
    defined as follows in your components:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingAuthenticationState` 组件调用已注册的 `AuthenticationStateProvider` 的 `GetAuthenticationStateAsync`
    方法，并将返回的 `Task<AuthenticationState>` 进行级联。您可以在组件中定义以下 `[CascadingParameter]` 来拦截此级联值：'
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: However, Blazor applications typically use `AuthorizeRouteView` and `AuthorizeView`
    components to control user access to content.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Blazor 应用程序通常使用 `AuthorizeRouteView` 和 `AuthorizeView` 组件来控制用户对内容的访问。
- en: '`AuthorizeRouteView` prevents access to pages if the user doesn’t satisfy the
    prescriptions of the page’s `[Authorize]` attribute; otherwise, the content in
    the `NotAuthorized` template is rendered. `AuthorizeRouteView` also has an `Authorizing`
    template that is shown while user information is being retrieved.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizeRouteView` 阻止用户在不满足页面 `[Authorize]` 属性规定的情况下访问页面；否则，将渲染 `NotAuthorized`
    模板的内容。`AuthorizeRouteView` 还有一个 `Authorizing` 模板，在检索用户信息时显示。'
- en: '`AuthorizeView` can be used within components to show the markup it encloses
    only to authorized users. It contains the same `Roles` and `Policy` parameters
    of the `[Authorize]` attribute that you can use to specify the constraints the
    user must satisfy to access the content:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizeView` 可以在组件中使用，以仅向授权用户显示其包含的标记。它包含与 `[Authorize]` 属性相同的 `Roles` 和
    `Policy` 参数，您可以使用这些参数来指定用户必须满足的约束条件才能访问内容：'
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`AuthorizeView` can also specify `NotAuthorized` and an `Authorizing` template:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizeView` 还可以指定 `NotAuthorized` 和 `Authorizing` 模板：'
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If one adds authorization while creating a Blazor WebAssembly project, the
    following method call is added to the application dependency engine:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建 Blazor WebAssembly 项目时添加了授权，则将以下方法调用添加到应用程序依赖引擎中：
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This method adds an `AuthenticationStateProvider` that extracts the user information
    from the authentication cookie of an OAuth provider. The OAuth protocol with the
    OAuth provider is performed with the help of the `AuthenticationService.js` JavaScript
    file we saw in the *Loading and starting the application* subsection of this chapter.
    The OAuth provider endpoint returns user information in the form of a bearer token
    that can, then, also be used to authenticate communications with the server’s
    web API. Bearer tokens are described in detail in the *REST service authorization
    and authentication* and *ASP.NET Core service authorization* sections of *Chapter
    15*, *Applying Service-Oriented Architectures with .NET*. Blazor WebAssembly communication
    is described in the next subsection.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法添加了一个 `AuthenticationStateProvider`，它从 OAuth 提供程序的认证 cookie 中提取用户信息。使用 OAuth
    协议与 OAuth 提供程序的交互是通过我们在此章的 *加载和启动应用程序* 子节中看到的 `AuthenticationService.js` JavaScript
    文件来完成的。OAuth 提供程序端点以携带令牌的形式返回用户信息，然后这些令牌也可以用来认证与服务器 Web API 的通信。携带令牌在 *第 15 章*
    的 *REST 服务授权和认证* 和 *ASP.NET Core 服务授权* 部分中进行了详细描述。Blazor WebAssembly 通信将在下一子节中描述。
- en: 'The previous code takes the OAuth parameters from a configuration file you
    must add as `wwwroot/appsettings.json`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从配置文件中获取 OAuth 参数，该配置文件必须添加为 `wwwroot/appsettings.json`：
- en: '[PRE65]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you use Google as the authentication provider, `AUTHORITY` is `https://accounts.google.com/`,
    while `CLIENT ID` is the client ID you receive when you register your Blazor application
    with the Google Developers program.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Google 作为认证提供程序，`AUTHORITY` 是 `https://accounts.google.com/`，而 `CLIENT
    ID` 是您在将 Blazor 应用程序注册到 Google 开发者计划时收到的客户端 ID。
- en: 'Google needs some more parameters, namely the return URL to return once the
    authentication process is completed and the page to return to after a logout:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Google 需要一些额外的参数，即认证过程完成后返回的返回 URL 以及注销后返回的页面：
- en: '[PRE66]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Where `https://localhost:5001` must be replaced with the actual domain of the
    Blazor application.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `https://localhost:5001` 必须替换为 Blazor 应用的实际域名。
- en: 'Before any authentication or if the authentication fails, an unauthenticated
    `ClaimsPrincipal` is created. This way, when the user tries to access a page that
    is protected by an `[Authorize]` attribute, the `AuthorizeRouteView` component
    invokes the `RedirectToLogin` component, which, in turn, navigates to the `Authentication.razor`
    page, passing it a login request in its `action` route parameter:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何认证之前或认证失败时，会创建一个未认证的 `ClaimsPrincipal`。这样，当用户尝试访问由 `[Authorize]` 属性保护的页面时，`AuthorizeRouteView`
    组件会调用 `RedirectToLogin` 组件，后者反过来导航到 `Authentication.razor` 页面，并通过其 `action` 路由参数传递登录请求：
- en: '[PRE67]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `RemoteAuthenticatorView` acts as an interface with the usual ASP.NET Core
    user login/registration system, and whenever it receives an “action” to perform,
    it redirects the user from the Blazor application to the proper ASP.NET Core server
    page (login, registration, logout, and user profile).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoteAuthenticatorView` 充当与常规 ASP.NET Core 用户登录/注册系统的接口，并且每当它收到要执行的操作时，它将用户从
    Blazor 应用程序重定向到适当的 ASP.NET Core 服务器页面（登录、注册、注销和用户资料）。'
- en: Once the user logs in, they are redirected to the Blazor application page that
    caused the login request. The redirect URL is computed by the `BlazorReview.Layout->RedirectToLogin.razor`
    component, which extracts it from the `NavigationManager` and passes it to the
    `RemoteAuthenticatorView` component. This time, the `AuthenticationStateProvider`
    is able to get the user information from the authentication cookie that has been
    created by the login operation.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户登录，他们将被重定向到导致登录请求的 Blazor 应用程序页面。重定向 URL 是由 `BlazorReview.Layout->RedirectToLogin.razor`
    组件计算的，它从中提取它并将其传递给 `RemoteAuthenticatorView` 组件。这次，`AuthenticationStateProvider`
    能够从登录操作创建的认证 cookie 中获取用户信息。
- en: It is possible both to design a custom OAuth provider for your Blazor application
    or to design a completely custom way to get a bearer token with an internal login
    Blazor page without leaving the Blazor application. In this last case, you must
    provide a custom implementation of the `AuthenticationStateProvider`. More details
    on these advanced custom scenarios are available in the official documentation
    reference in the *Further reading* section.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为您的 Blazor 应用程序设计一个自定义的 OAuth 提供程序，或者设计一种完全自定义的方式，通过内部登录 Blazor 页面获取携带令牌，而无需离开
    Blazor 应用程序。在后一种情况下，您必须提供一个 `AuthenticationStateProvider` 的自定义实现。有关这些高级自定义场景的更多详细信息，请参阅
    *进一步阅读* 部分的官方文档参考。
- en: Having learned how to authenticate with an external OAuth provider and how to
    handle authorization within the Blazor application, we are ready to learn how
    to exchange data and how to authenticate with a REST API.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何使用外部 OAuth 提供者进行身份验证以及如何在 Blazor 应用程序中处理授权之后，我们准备好学习如何交换数据和如何使用 REST API
    进行身份验证。
- en: The next subsection describes a Blazor WebAssembly-specific implementation of
    the `HttpClient` class and related types.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了 Blazor WebAssembly 特定的 `HttpClient` 类及其相关类型的实现。
- en: Communication with the server
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与服务器的通信
- en: Blazor WebAssembly supports the same .NET `HttpClient` and `HttpClientFactory`
    classes described in the *.NET HTTP clients* section of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*. However, due to the communication limitations
    of browsers, their implementations are different and rely on the browser’s **fetch
    API**.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 支持与 *第15章* 中 *使用 .NET 应用服务架构* 部分的 *.NET HTTP 客户端* 中描述的相同的
    .NET `HttpClient` 和 `HttpClientFactory` 类。然而，由于浏览器的通信限制，它们的实现不同，并且依赖于浏览器的 **fetch
    API**。
- en: In fact, for security reasons, all browsers, do not allow direct opening of
    generic **TCP/IP** connections but force all server communications to pass either
    through **Ajax** or through the **fetch API**.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，出于安全原因，所有浏览器都不允许直接打开通用的 **TCP/IP** 连接，但强制所有服务器通信通过 **Ajax** 或通过 **fetch
    API**。
- en: This way, when you attempt a communication toward a URL that differs from the
    domain where the browser downloaded the SPA, the browser automatically switches
    to the CORS protocol, thus informing the server that the communication was started
    by a browser application that was downloaded by a different domain and that might
    potentially be a phishing website.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当您尝试与浏览器下载的 SPA 所在域不同的 URL 进行通信时，浏览器会自动切换到 CORS 协议，从而通知服务器通信是由下载自不同域的浏览器应用程序启动的，并且可能是一个钓鱼网站。
- en: In turn, the server accepts CORS communications just from well-known domains
    that are pre-listed in its code. This way, the server is sure that the request
    can’t come from a phishing website.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器反过来只接受来自预先在其代码中列出的知名域的 CORS 通信。这样，服务器可以确信请求不会来自钓鱼网站。
- en: In *Chapter 15*, *Applying Service-Oriented Architectures with .NET*, we analyzed
    how to take advantage of `HttpClientFactory` to define typed clients. You can
    also define typed clients in Blazor with exactly the same syntax.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第15章*，*使用 .NET 应用服务架构* 中，我们分析了如何利用 `HttpClientFactory` 来定义类型化客户端。您也可以使用完全相同的语法在
    Blazor 中定义类型化客户端。
- en: 'However, since an authenticated Blazor application needs to send the bearer
    token created during the authentication process in each request to the application
    server, it is common to define a named client as shown here:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于经过身份验证的 Blazor 应用程序需要在每个请求中将身份验证过程中创建的载体令牌发送到应用程序服务器，因此通常定义一个命名客户端，如下所示：
- en: '[PRE68]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`AddHttpMessageHandler` adds a `DelegatingHandler`, that is, a subclass of
    the `DelegatingHandler` abstract class. Implementations of `DelegatingHandler`
    override its `SendAsync` method in order to process each request and each relative
    response:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddHttpMessageHandler` 添加了一个 `DelegatingHandler`，即 `DelegatingHandler` 抽象类的子类。`DelegatingHandler`
    的实现通过重写其 `SendAsync` 方法来处理每个请求和每个相关响应：'
- en: '[PRE69]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If this bearer token is expired or is not found at all, it tries to get a new
    bearer token by using the authentication cookie received when the user manually
    logged in with the OAuth provider. This way, it can obtain a fresh bearer token
    without requesting a new manual login. If this attempt also fails, an `AccessTokenNotAvailableException`
    is thrown. Typically, this exception is captured and used to trigger a redirection
    to the login page by calling its `Redirect` method, as shown below:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个载体令牌已过期或根本找不到，它将尝试通过使用用户手动使用 OAuth 提供者登录时收到的身份验证cookie来获取一个新的载体令牌。这样，它可以在不请求新的手动登录的情况下获得一个新的载体令牌。如果这次尝试也失败，将抛出
    `AccessTokenNotAvailableException` 异常。通常，这个异常会被捕获并用于通过调用其 `Redirect` 方法来触发对登录页面的重定向，如下所示：
- en: '[PRE70]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If both the Blazor application and the Web API are deployed in different subfolders
    of the same domain, Blazor requests are issued without the CORS protocol, so they
    are automatically accepted by the server. Otherwise, the ASP.NET Core server must
    enable CORS requests, and must list the Blazor application URL among the allowed
    CORS domains with something like:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Blazor 应用程序和 Web API 都部署在同一域的不同子文件夹中，Blazor 请求将不会使用 CORS 协议，因此它们会被服务器自动接受。否则，ASP.NET
    Core 服务器必须启用 CORS 请求，并且必须将 Blazor 应用程序 URL 列在允许的 CORS 域中，例如：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Then, you must also place the `app.UseCors()` middleware in the ASP.NET Core
    pipeline.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须在 ASP.NET Core 管道中放置 `app.UseCors()` 中间件。
- en: 'The example data shown on the `Weather` page of the `ReviewBlazor` application
    are downloaded from a static file located in the `wwwroot/sample-data` folder
    of the same Blazor application, so a normal, not-CORS request is issued and no
    bearer token is needed to request. Accordingly, the `Weather`page uses a default
    `HttpClient` defined in `Program.cs` as:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ReviewBlazor` 应用程序的 `Weather` 页面上显示的示例数据是从同一 Blazor 应用程序的 `wwwroot/sample-data`
    文件夹中的静态文件下载的，因此发出的是正常、非 CORS 请求，不需要携带令牌来请求。因此，`Weather` 页面使用在 `Program.cs` 中定义的默认
    `HttpClient`：
- en: '[PRE72]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The next subsection explains how to improve the performance of computation-intensive
    applications with Blazor AOT compilation.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将解释如何使用 Blazor AOT 编译来提高计算密集型应用程序的性能。
- en: AOT compilation
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AOT 编译
- en: Once uploaded in the browser, .NET assemblies are not compiled **Just in Time**
    (**JIT**) at their first execution as is the case for other platforms. Instead,
    they are interpreted by a very fast interpreter. Just the .NET runtime is pre-compiled
    and uploaded in the browser directly in WebAssembly.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在浏览器中上传，.NET 程序集在其第一次执行时不会像其他平台那样进行 JIT 编译。相反，它们由一个非常快速的解释器进行解释。只有 .NET 运行时是预编译并直接上传到浏览器中的
    WebAssembly。
- en: JIT compilation is avoided since it would considerably increase the application
    start time, which is already quite high because of the high application download
    size (about 10 MB). In turn, the download size is high due to the .NET libraries
    that any Blazor application needs to work properly.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译被避免，因为这会显著增加应用程序的启动时间，而由于应用程序下载大小（约 10 MB）已经相当高，这个启动时间已经很高了。反过来，下载大小之所以高，是因为任何
    Blazor 应用程序都需要 .NET 库才能正常运行。
- en: In order to reduce download size, during the compilation in release mode, Blazor
    .NET assemblies are tree-shaken to remove all unused types and methods. However,
    notwithstanding this tree-shaking, the typical download size remains quite high.
    A good download improvement is achieved with the default caching of the .NET runtime,
    which reduces the download size to 2-4 MB. However, the download size still remains
    high the first time a Blazor application is visited.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少下载大小，在发布模式下的编译过程中，Blazor .NET 程序集会进行树摇操作，以删除所有未使用的类型和方法。然而，尽管有这种树摇操作，典型的下载大小仍然相当高。通过
    .NET 运行时的默认缓存，可以实现良好的下载改进，将下载大小减少到 2-4 MB。然而，当第一次访问 Blazor 应用程序时，下载大小仍然很高。
- en: 'Starting from .NET 6, Blazor offers an alternative to JIT compilation: **Ahead-of-Time**
    (**AOT**) compilation. With AOT, all application assemblies are compiled into
    a unique WebAssembly file during the application publication.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 6 开始，Blazor 提供了 JIT 编译的替代方案：**提前编译**（**AOT**）。使用 AOT，所有应用程序程序集在应用程序发布期间编译成一个唯一的
    WebAssembly 文件。
- en: AOT compilation is very slow and may last something like 10-30 minutes, even
    in the case of small applications. On the other hand, it must be executed only
    once when the application is published, so the compilation time doesn’t impact
    the application start time.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 编译非常慢，可能需要 10-30 分钟，即使是小型应用程序也是如此。另一方面，它只需在应用程序发布时执行一次，因此编译时间不会影响应用程序的启动时间。
- en: Unfortunately, AOT compilation more than doubles the download size, since the
    compiled code is more verbose than the source .NET code. Therefore, AOT should
    be adopted only in performance-critical applications that can trade a higher start
    time for better performance.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，AOT 编译将下载大小增加了一倍多，因为编译后的代码比源 .NET 代码更冗长。因此，AOT 应仅用于性能关键的应用程序，这些应用程序可以以更高的启动时间为代价来换取更好的性能。
- en: '.NET WebAssembly AOT compilation requires an additional build tool that must
    be installed as an optional .NET SDK workload in order to use it. The first time,
    you can install it with the following shell command:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: .NET WebAssembly AOT 编译需要一个额外的构建工具，必须将其作为可选的 .NET SDK 工作负载安装才能使用。第一次安装，可以使用以下
    shell 命令：
- en: '[PRE73]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Instead, when a new .NET version is installed, we just need to launch the following
    command to update all previously installed workloads:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当安装新的.NET版本时，我们只需运行以下命令来更新之前安装的所有工作负载：
- en: '[PRE74]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Once the AOT workload has been installed, AOT compilation can be enabled on
    a per-project basis by adding the `<RunAOTCompilation>true</RunAOTCompilation>`
    declaration to the Blazor project file, as shown here:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了AOT工作负载，就可以通过将 `<RunAOTCompilation>true</RunAOTCompilation>` 声明添加到Blazor项目文件中，按如下所示启用每个项目的AOT编译：
- en: '[PRE75]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The next section briefly discusses some of the most relevant third-party tools
    and libraries that complete Blazor’s official features and help increase productivity
    in Blazor projects.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分简要讨论了一些最相关的第三方工具和库，它们完善了Blazor的官方功能，并有助于提高Blazor项目中的生产力。
- en: Third-party tools for Blazor WebAssembly
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor WebAssembly的第三方工具
- en: Notwithstanding Blazor being a young product, its third-party tool and product
    ecosystem is already quite rich. Among the open source, free products, it is worth
    mentioning the **Blazorise** project ([https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise)),
    which contains various free basic Blazor components (inputs, tabs, modals, and
    so on) that can be styled with various CSS frameworks, such as Bootstrap and Material.
    It also contains a simple editable grid and a simple tree view.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Blazor是一个年轻的产品，但其第三方工具和产品生态系统已经相当丰富。在开源、免费产品中，值得提一下的是 **Blazorise** 项目 ([https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise))，它包含各种免费的基本Blazor组件（输入、标签页、模态框等），可以使用各种CSS框架进行样式化，如Bootstrap和Material。它还包含一个简单的可编辑网格和一个简单的树视图。
- en: Also worth mentioning is **BlazorStrap** ([https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap)),
    which contains pure Blazor implementations of all Bootstrap 4 components and widgets.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的还有 **BlazorStrap** ([https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap))，它包含了所有Bootstrap
    4组件和小部件的纯Blazor实现。
- en: Among all the commercial products, it is worth mentioning **Blazor Controls
    Toolkit** ([https://blazorct.azurewebsites.net/](https://blazorct.azurewebsites.net/)),
    which is a complete toolset for implementing commercial applications. It contains
    all input types with their fallbacks in case they are not supported by the browser;
    all Bootstrap components; other basic components; a complete, advanced drag-and-drop
    framework; and advanced customizable and editable components, like detail views,
    detail lists, grids, and a tree-repeater (a generalization of the tree view).
    All components are based on a sophisticated metadata representation system that
    enables the user to design the markup in a declarative way using data annotations
    and inline Razor declarations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有商业产品中，值得提一下的是 **Blazor Controls Toolkit** ([https://blazorct.azurewebsites.net/](https://blazorct.azurewebsites.net/))，这是一个用于实现商业应用的完整工具集。它包含所有输入类型及其回退，以防浏览器不支持；所有Bootstrap组件；其他基本组件；一个完整、高级的拖放框架；以及高级可定制和可编辑的组件，如详细视图、详细列表、网格和树重复器（树视图的泛化）。所有组件都基于一个复杂的元数据表示系统，使用数据注释和内联Razor声明，使用户能够以声明性方式设计标记。
- en: Moreover, it contains additional sophisticated validation attributes, tools
    for undoing user input, tools for computing changes to send to the server, sophisticated
    client-side and server-side query tools based on the OData protocol, and tools
    to maintain and save the whole application state.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还包含额外的复杂验证属性、撤销用户输入的工具、计算更改并发送到服务器的工具、基于OData协议的复杂客户端和服务器端查询工具，以及维护和保存整个应用程序状态的工具。
- en: It is also worth mentioning the **bUnit** open-source project ([https://github.com/egil/bUnit](https://github.com/egil/bUnit)),
    which provides all the tools for testing Blazor components.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是 **bUnit** 开源项目 ([https://github.com/egil/bUnit](https://github.com/egil/bUnit))，它提供了测试Blazor组件所需的所有工具。
- en: The **Awesome Blazor** project ([https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor))
    lists thousands of open-source and commercial Blazor resources, such as tutorials,
    posts, libraries, and example projects.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**Awesome Blazor** 项目 ([https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor))
    列出了数千个开源和商业Blazor资源，例如教程、文章、库和示例项目。'
- en: A complete example of a Blazor WebAssembly application based on the WWTravelClub
    book use case can be found in the *Using client technologies* section of *Chapter
    21, Case Study.* The next section explains how to use Blazor to implement cross-platform
    applications. The actual code is contained in the folder associated with this
    chapter in the GitHub repository of the book.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 WWTravelClub 书籍用例的 Blazor WebAssembly 应用程序的完整示例可以在 *第21章，案例研究* 的 *使用客户端技术*
    部分找到。下一个部分将解释如何使用 Blazor 实现跨平台应用程序。实际代码包含在书籍 GitHub 仓库中与该章节相关的文件夹中。
- en: .NET MAUI Blazor
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET MAUI Blazor
- en: .NET MAUI is Microsoft’s advised choice to implement cross-platform applications.
    In fact, .NET MAUI applications can be just-in-time compiled for all Windows,
    Android, iOS, and other Linux-based devices. .NET MAUI contains a common abstraction
    of all target devices, and at the same time takes advantage of each device’s peculiarities
    by offering platform-specific libraries each containing platform-specific features
    of a target platform.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 是微软推荐的实现跨平台应用程序的选择。实际上，.NET MAUI 应用程序可以即时编译为所有 Windows、Android、iOS
    和其他基于 Linux 的设备。.NET MAUI 包含所有目标设备的通用抽象，同时通过提供包含特定平台特性的平台特定库来利用每个设备的独特性。
- en: We will not describe .NET MAUI in detail, but after a short introduction to
    .NET MAUI, we will focus just on .NET MAUI Blazor. This way, by learning just
    Blazor, you will be able to develop single-page applications, progressive applications,
    and cross-platform applications.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会详细描述 .NET MAUI，但在对 .NET MAUI 简短介绍之后，我们将专注于 .NET MAUI Blazor。这样，通过学习 Blazor，你将能够开发单页应用程序、渐进式应用程序和跨平台应用程序。
- en: What is .NET MAUI?
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 .NET MAUI？
- en: .NET MAUI extends Xamarin.Forms’ cross-platform capabilities from Android and
    iOS to also include Windows and macOS. Thus, .NET MAUI is a cross-platform framework
    for creating both native mobile and desktop apps with C#.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 扩展了 Xamarin.Forms 从 Android 和 iOS 到 Windows 和 macOS 的跨平台能力。因此，.NET
    MAUI 是一个用于使用 C# 创建原生移动和桌面应用程序的跨平台框架。
- en: 'The basis of .NET MAUI is Xamarin.Forms. In fact, Microsoft has provided a
    guide for migrating original Xamarin.Forms apps to .NET MAUI, as can be seen at
    the following link: [https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate](https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate).
    However, .NET MAUI has been conceived to be the new-generation framework for any
    native/desktop app development in C#:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 的基础是 Xamarin.Forms。实际上，微软提供了一份指南，用于将原始的 Xamarin.Forms 应用程序迁移到 .NET
    MAUI，如下链接所示：[https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate](https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate)。然而，.NET
    MAUI 是为了成为任何原生/桌面应用程序开发的新一代框架而设计的：
- en: '![Interface gráfica do usuário, Site  Descrição gerada automaticamente](img/B19820_19_02.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，网站描述自动生成](img/B19820_19_02.png)'
- en: 'Figure 19.2: .NET MAUI high-level architecture'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2：.NET MAUI 高级架构
- en: There is a specific difference between Xamarin.Forms and .NET MAUI. In Xamarin.Forms,
    there is a specific native project for any kind of device we would like to publish
    to on the app, while in .NET MAUI, this approach is based on as single project
    targeting multiple platforms.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms 和 .NET MAUI 之间存在一个特定的区别。在 Xamarin.Forms 中，为任何我们希望在应用程序中发布的设备都有一个特定的原生项目，而在
    .NET MAUI 中，这种方法基于一个针对多个平台的项目。
- en: The next section explains how to use .NET MAUI to run a Blazor application as
    a native application.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将解释如何使用 .NET MAUI 将 Blazor 应用程序作为原生应用程序运行。
- en: Developing native applications with Blazor
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Blazor 开发原生应用程序
- en: .NET MAUI is not installed by default when you install Visual Studio 2022, but
    you need to select the .NET MAUI workload in the Visual Studio installer. Therefore,
    if you don’t see MAUI projects when you start a new project in your Visual Studio
    installation, you need to run the Visual Studio installer and modify your existing
    installation with the addition of the .NET MAUI workload.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Visual Studio 2022 时，.NET MAUI 并不是默认安装的，但你需要选择 Visual Studio 安装程序中的 .NET
    MAUI 工作负载。因此，如果你在 Visual Studio 安装中启动新项目时看不到 MAUI 项目，你需要运行 Visual Studio 安装程序并修改你的现有安装，添加
    .NET MAUI 工作负载。
- en: 'Once you have the MAUI workload installed, in the project creation wizard,
    you should be able to select **C#/All platforms/MAUI**, and then select **.NET
    MAUI Blazor Hybrid App**, as shown here:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 MAUI 工作负载，在项目创建向导中，你应该能够选择 **C#/所有平台/MAUI**，然后选择 **.NET MAUI Blazor 混合应用程序**，如图所示：
- en: '![](img/B19820_19_03.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_19_03.png)'
- en: 'Figure 19.3: Creating a .NET MAUI Blazor application'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3：创建一个 .NET MAUI Blazor 应用程序
- en: Create a MAUI Blazor project and call it `MAUIBlazorReview`. The MAUI Blazor
    application contains the usual `Layout` and `Pages` folders where you can place
    your Blazor components and pages, but they are placed inside a `Components` folder.
    It also contains a `wwwroot` folder containing the usual `index.html` page and
    all the CSS and JavaScript you might need. Finally, it also contains the usual
    `_Imports.razor` page where you can place all your default `using` statements.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `MAUIBlazorReview` 的 MAUI Blazor 项目。MAUI Blazor 应用程序包含通常的 `Layout` 和
    `Pages` 文件夹，你可以在这里放置你的 Blazor 组件和页面，但它们被放置在 `Components` 文件夹内部。它还包含一个包含通常的 `index.html`
    页面以及你可能需要的所有 CSS 和 JavaScript 的 `wwwroot` 文件夹。最后，它还包含一个通常的 `_Imports.razor` 页面，你可以在这里放置所有默认的
    `using` 语句。
- en: A MAUI Blazor application also uses layout pages that you can place in the `Shared`
    folder and may reference Razor libraries containing CSS components and JavaScript
    files.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: MAUI Blazor 应用程序还使用可以放置在 `Shared` 文件夹中的布局页面，并且可以引用包含 CSS 组件和 JavaScript 文件的
    Razor 库。
- en: '![](img/B19820_19_04.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_19_04.png)'
- en: 'Figure 19.4: .NET MAUI Blazor project'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.4：.NET MAUI Blazor 项目
- en: 'The only difference is that services, instead of being declared in `Program.cs`
    files, are declared in `MauiProgram.cs` together with MAUI-specific code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，服务不是在 `Program.cs` 文件中声明，而是在 `MauiProgram.cs` 文件中与特定于 MAUI 的代码一起声明：
- en: '[PRE76]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Attention must be paid when using an `HttpClient` class to communicate with
    a server. Blazor web applications may use URLs relative to the domain where they
    were downloaded, while MAUI Blazor applications must use absolute URLs since they
    are not associated with any default URL. Therefore, an `HttpClient` definition
    is added to the services with something like this:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `HttpClient` 类与服务器通信时必须注意。Blazor 网络应用程序可能会使用相对于它们下载域的 URL，而 MAUI Blazor
    应用程序必须使用绝对 URL，因为它们与任何默认 URL 无关。因此，添加了一个类似于以下内容的 `HttpClient` 定义到服务中：
- en: '[PRE77]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `Platforms` folder contains a subfolder for each platform supported by the
    application, where each subfolder contains platform-specific code.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`Platforms` 文件夹包含每个应用程序支持的平台的子文件夹，每个子文件夹包含特定于平台的代码。'
- en: '![](img/B19820_19_05.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_19_05.png)'
- en: 'Figure 19.5: Platforms folder'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.5：平台文件夹
- en: 'Supported folders can be changed by editing the `TargetFrameworks` element
    of the `MAUIBlazorReview.csproj` file:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的文件夹可以通过编辑 `MAUIBlazorReview.csproj` 文件的 `TargetFrameworks` 元素进行更改：
- en: '[PRE78]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can select the platform to run the application from using the dropdown next
    to the green Visual Studio run button. On a Windows machine, you can select just
    Windows and Android. If you select Android, an Android device simulator is launched.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用绿色 Visual Studio 运行按钮旁边的下拉菜单选择运行应用程序的平台。在 Windows 机器上，你可以选择仅 Windows 和
    Android。如果你选择 Android，则会启动一个 Android 设备模拟器。
- en: In order to debug for iOS/Mac platforms on a Windows machine, you need to connect
    an iOS/Mac device to your computer.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Windows 机器上调试 iOS/Mac 平台，你需要将 iOS/Mac 设备连接到你的计算机。
- en: When you build the project, the build may ask you to install an Android SDK
    version. If this is the case, please follow the simple instructions in the error
    message.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建项目时，构建过程可能会要求你安装一个 Android SDK 版本。如果是这种情况，请按照错误消息中的简单说明操作。
- en: Summary
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about client-side technologies. In particular,
    you learned what an SPA is and how to build one based on the Blazor WebAssembly
    framework. The chapter first described the Blazor WebAssembly architecture, and
    then explained how to exchange input/output with Blazor components and the concept
    of binding.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了客户端技术。特别是，你学习了什么是单页应用程序（SPA）以及如何基于 Blazor WebAssembly 框架构建一个。本章首先描述了
    Blazor WebAssembly 架构，然后解释了如何与 Blazor 组件交换输入/输出以及绑定的概念。
- en: After having explained Blazor’s general principles, the chapter focused on how
    to get user input while providing the user with adequate feedback and visual clues
    in the event of errors. Then, the chapter provided a short description of advanced
    features, such as JavaScript interoperability, globalization, authentication with
    authorization, and client-server communication.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了 Blazor 的一般原则之后，本章重点介绍了如何在提供用户足够的错误反馈和视觉线索的同时获取用户输入。然后，本章简要介绍了高级功能，例如 JavaScript
    互操作性、全球化、授权认证和客户端/服务器通信。
- en: Finally, the last section explained how to use Blazor to implement cross-platform
    applications based on Microsoft MAUI and how to transform a Blazor WebAssembly
    project into a .NET MAUI Blazor project.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一节解释了如何使用 Blazor 实现基于 Microsoft MAUI 的跨平台应用程序，以及如何将 Blazor WebAssembly
    项目转换为 .NET MAUI Blazor 项目。
- en: Complete examples of Blazor applications based on the WWTravelClub book use
    case can be found in the *Using client technologies* section of *Chapter 21*,
    *Case Study*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 WWTravelClub 书籍用例的 Blazor 应用程序的完整示例可以在第 21 章 *案例研究* 的 *使用客户端技术* 部分找到。
- en: Questions
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is WebAssembly?
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 WebAssembly？
- en: What is an SPA?
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 SPA？
- en: What is the purpose of the Blazor `router` component?
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blazor `router` 组件的用途是什么？
- en: What is a Blazor page?
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Blazor 页面？
- en: What is the purpose of the `@namespace` directive?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@namespace` 指令的用途是什么？'
- en: What is an `EditContext`?
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `EditContext`？
- en: What is the right place to initialize a component?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化组件的正确位置在哪里？
- en: What is the right place to process the user input?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理用户输入的正确位置在哪里？
- en: What is the `IJSRuntime` interface?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IJSRuntime` 接口的用途是什么？'
- en: What is the purpose of `@ref`?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@ref` 的用途是什么？'
- en: Further reading
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Blazor official documentation is available at [https://docs.microsoft.com/en-us/aspnet/core/blazor](https://docs.microsoft.com/en-us/aspnet/core/blazor).
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 官方文档可在 [https://docs.microsoft.com/en-US/aspnet/core/blazor](https://docs.microsoft.com/en-US/aspnet/core/blazor)
    查看。
- en: Lazy loading assemblies is described at [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性加载程序集的描述在 [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies)。
- en: All HTML events supported by Blazor together with their event arguments are
    listed at [https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling#event-arguments-1](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling#event-arguments-1).
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 支持的所有 HTML 事件及其事件参数列表可在 [https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling#event-arguments-1](https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling#event-arguments-1)
    查看。
- en: 'Blazor supports the same validation attributes as ASP.NET MVC, with the exception
    of `RemoteAttribute`: [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes).'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 支持与 ASP.NET MVC 相同的验证属性，除了 `RemoteAttribute`：[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes)。
- en: 'A description of the `InputFile` component, and how to use it, can be found
    here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads](https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads).'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputFile` 组件的描述及其使用方法可在此处找到：[https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads](https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads)。'
- en: 'More details on Blazor localization and globalization are available here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization](https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization).'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Blazor 本地化和全球化的详细信息请在此处查看：[https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization](https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization)。
- en: 'More details on Blazor authentication and all its related URLs are available
    here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/).'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Blazor 身份验证及其所有相关 URL 的详细信息请在此处查看：[https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/)。
- en: 'The Blazorise project: [https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise).'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazorise 项目：[https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise)。
- en: 'BlazorStrap: [https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap).'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BlazorStrap: [https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap)。'
- en: 'Blazor Controls Toolkit: [https://blazorct.azurewebsites.net/](https://blazorct.azurewebsites.net/).'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 控件工具包：[https://blazorct.azurewebsites.net/](https://blazorct.azurewebsites.net/)。
- en: 'bUnit: [https://github.com/egil/bUnit](https://github.com/egil/bUnit).'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'bUnit: [https://github.com/egil/bUnit](https://github.com/egil/bUnit)。'
- en: 'The Awesome Blazor project: [https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor).'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Awesome Blazor 项目：[https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor)。
- en: Learn more on Discord
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入此书的 Discord 社区——您可以在此处分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
