<html><head></head><body>
		<div id="_idContainer197">
			<h1 id="_idParaDest-331" class="chapter-number"><a id="_idTextAnchor330"/>14</h1>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor331"/>gRPC for Binary Communication</h1>
			<p>Service-to-service communication does not need to be via REST passing JSON data. Performance and cost are important factors to consider when it comes to using <strong class="bold">gRPC</strong>, a binary<a id="_idIndexMarker1073"/> and platform-independent communication technology. Reducing the data that’s transferred can increase performance and <span class="No-Break">reduce costs.</span></p>
			<p>In this chapter, we’ll change some services in the Codebreaker solution so that they offer gRPC instead or in addition to REST services. You’ll learn how gRPC differs from REST, as well as how to create services and clients using this binary <span class="No-Break">communication technology.</span></p>
			<p>In this chapter, you’ll learn how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Configure a service project to <span class="No-Break">use gRPC</span></li>
				<li>Create a platform-independent communication contract <span class="No-Break">with Protobuf</span></li>
				<li>Create <span class="No-Break">gRPC services</span></li>
				<li>Create clients that call <span class="No-Break">gRPC services</span></li>
			</ul>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor332"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription and <span class="No-Break">Docker Desktop.</span></p>
			<p>The code for this chapter can be found in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/"><span class="No-Break">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">ch14</strong> folder contains the projects we’ll be looking at in this chapter, as well as their results. To add the functionality from this chapter, you can start with the source code from the <span class="No-Break">previous chapter.</span></p>
			<p>The projects we’ll be considering are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.AppHost</strong>: The .NET Aspire host project. The app model has been updated to use HTTPS with the <strong class="source-inline">game-apis</strong> service and <strong class="source-inline">live-service</strong> so that it <span class="No-Break">supports gRPC.</span></li>
				<li><strong class="source-inline">Codebreaker.Live</strong>: The project we created in the previous chapter has been changed to offer a gRPC service instead of a <span class="No-Break">REST service.</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs</strong>: This project has been updated so that it includes a gRPC client to invoke <strong class="source-inline">live-service</strong>. In addition to the REST service used by many different clients, a gRPC service has been added as an alternative. This is invoked by the <span class="No-Break">bot service.</span></li>
				<li><strong class="source-inline">Codebreaker.Bot</strong>: The bot service has been updated to use a gRPC client instead of REST to invoke the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service.</span></li>
				<li><strong class="source-inline">LiveTestClient</strong>: You will need to use the live test client from the previous chapter to verify the <span class="No-Break">SignalR service.</span></li>
			</ul>
			<p>Before digging into gRPC, let’s compare it with <strong class="bold">Representational State </strong><span class="No-Break"><strong class="bold">Transfer</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">REST</strong></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor333"/>Comparing REST with gRPC</h1>
			<p>The <a id="_idIndexMarker1074"/>most important difference between REST and gRPC is that REST is a <em class="italic">guideline</em> that builds upon HTTP, whereas gRPC is a <em class="italic">protocol</em>. Both are used for communication between clients and services. Let’s take a <span class="No-Break">closer look.</span></p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor334"/>Communication style</h2>
			<p>REST is a guideline that<a id="_idIndexMarker1075"/> defines services to be stateless, makes use of HTTP verbs (GET, POST, PUT, DELETE) to manipulate resources, typically uses a human-readable format such as JSON or XML, and is commonly used with <span class="No-Break">web APIs.</span></p>
			<p>gRPC uses a <em class="italic">strongly defined contract</em> to specify the operations that are available with the services. While other specifications can be used as well, most services make use of <strong class="bold">Protocol Buffers</strong> (<strong class="bold">Protobuf</strong>) to <a id="_idIndexMarker1076"/>specify the contract. With this, gRPC has a compact payload size and <span class="No-Break">efficient serialization.</span></p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor335"/>Performance</h2>
			<p>When it <a id="_idIndexMarker1077"/>comes to textual representation, REST has a higher overhead and a higher latency. With gRPC, because of its efficient serialization, latency is lower, and the binary serialization reduces the payload’s size. With gRPC, multiplexing allows for concurrent requests across a <span class="No-Break">single connection.</span></p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor336"/>Flexibility</h2>
			<p>REST adds <a id="_idIndexMarker1078"/>flexibility by using URIs for resources and is not strictly based on HTTP and HTTPS. Other protocols can be used as well that fulfill <span class="No-Break">REST principles.</span></p>
			<p>With gRPC, contracts strictly specify the communication. gRPC is based on HTTP/2, which offers some advantages compared to HTTP/1, such as multiplexing concurrent calls over a single connection. gRPC-Web is an alternative that allows a subset of gRPC to be used <span class="No-Break">with HTTP/1.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor337"/>Language support</h2>
			<p>REST just <a id="_idIndexMarker1079"/>needs HTTP and works with any language that supports HTTP. With gRPC, based on the protobuf contract, code is created – and this requires supported languages to be used. Check out the list of supported languages at <a href="https://grpc.io/docs/languages/">https://grpc.io/docs/languages/</a>. It includes C#, C++, Dart, Java, Go, Python, PHP, <span class="No-Break">and others.</span></p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor338"/>Security</h2>
			<p>REST relies <a id="_idIndexMarker1080"/>on transport security (HTTPS). Authentication and authorization are done at the application level. With gRPC, transport security (TLS/SSL) is supported, and authentication via OAuth and JWT is built-in. gRPC supports <span class="No-Break">per-message encryption.</span></p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor339"/>Use cases</h2>
			<p>REST <a id="_idIndexMarker1081"/>allows for easy interoperability. Only HTTP calls need to be made. It’s used with web APIs and simple services, as well as for interoperability with <span class="No-Break">existing services.</span></p>
			<p>With cloud services, we pay for compute and memory resources. With a lot of communication going on, the number of instances needed can be reduced by using memory and CPU-efficient technologies. Communication between services can be done <span class="No-Break">using gRPC.</span></p>
			<p>Let’s start by updating the solution so that it makes use of gRPC (with the logging collectors, gRPC is already <span class="No-Break">in use).</span></p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/>Updating a service project so that it uses gRPC</h1>
			<p>When<a id="_idIndexMarker1082"/> using .NET templates to create new projects, a gRPC service can be created by running the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet new grpc</pre>
			<p>When using such a project, you can check the project file to see the NuGet packages and other configurations that <span class="No-Break">are needed.</span></p>
			<p>Because we already have existing projects, we’ll update these to offer a gRPC service. But first, let’s have a look at the communication between the Codebreaker services shown in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B21217_14_01.jpg" alt="Figure 14.1 – Codebreaker communication technologies"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Codebreaker communication technologies</p>
			<p>Let’s start <a id="_idIndexMarker1083"/>with the right-hand side. In <a href="B21217_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, we implemented the Codebreaker live service using a SignalR hub, which notifies SignalR clients. For the SignalR client, we created a console client application. Also in <a href="B21217_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, we used minimal ASP.NET Core APIs which allowed us to call the <strong class="source-inline">game-apis</strong> service to send completed games. This is a form of service-to-service communication that can be replaced by gRPC. The <strong class="source-inline">game-apis</strong> service itself is called by clients and the bot service. With this service, a REST API must be invoked by any client technology. The communication between the bot and the <strong class="source-inline">game-apis</strong> service can be done using gRPC as well. Thus, when it comes to the <strong class="source-inline">game-apis</strong> service, we’ll offer an alternative communication technology so that communication between the <strong class="source-inline">game-apis</strong> service and <strong class="source-inline">live-service</strong> will be replaced. Thus, in this chapter, we’ll do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Replace the minimal API implementation of <strong class="source-inline">live-service</strong> <span class="No-Break">with gRPC</span></li>
				<li>Add an alternative option for the <strong class="source-inline">game-apis</strong> service so that we offer gRPC <span class="No-Break">as well</span></li>
				<li>Implement a gRPC client with the <strong class="source-inline">game-apis</strong> service to <span class="No-Break">invoke </span><span class="No-Break"><strong class="source-inline">live-service</strong></span></li>
				<li>Implement a gRPC client with clients of the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service</span></li>
			</ul>
			<p>Let’s start by creating a gRPC service contract for <strong class="source-inline">live-service</strong> that’s invoked by the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service.</span></p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor341"/>Creating service contracts</h1>
			<p>First, we <a id="_idIndexMarker1084"/>need to add the <strong class="source-inline">Grpc.AspNetCore</strong> NuGet package to the <strong class="source-inline">Codebreaker.Live</strong> project. Then, we must add a Protobuf file as a contract to the service. The contract file is language and platform-independent, so a .NET service can communicate with a Dart application using the same <span class="No-Break">Protobuf file.</span></p>
			<p>Using Visual Studio, add a <strong class="source-inline">Protos</strong> folder, and use the Visual Studio template to create a <strong class="bold">Protobuf file</strong>. When<a id="_idIndexMarker1085"/> using the command line, with the current directory set to the project folder of <strong class="source-inline">Codebreaker.Live</strong>, you can run the following command to create the <strong class="source-inline">LiveGame.proto</strong> file inside the <span class="No-Break"><strong class="source-inline">Protos</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="console">
dotnet new proto -o Protos -n LiveGame</pre>
			<p>Now, let’s create contracts for both <strong class="source-inline">live-service</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor342"/>Creating a gRPC service contract for live-service</h2>
			<p>The <a id="_idIndexMarker1086"/>simpler contract is <a id="_idIndexMarker1087"/>the one <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">live-service</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Protos/LiveGame.proto</p>
			<pre class="source-code">
syntax = "proto3";
option csharp_namespace = "Codebreaker.Live.Grpc";
package ReportGame;
import "google/protobuf/empty.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
<strong class="bold">service ReportGameService {</strong>
<strong class="bold">  rpc ReportGameCompleted (ReportGameCompletedRequest)</strong>
<strong class="bold">    </strong><strong class="bold">returns (google.protobuf.Empty);</strong>
<strong class="bold">}</strong>
<strong class="bold">message ReportGameCompletedRequest {</strong>
<strong class="bold">  string id = 1;</strong>
<strong class="bold">  string gameType = 2;</strong>
<strong class="bold">  string playerName = 3;</strong>
<strong class="bold">  bool isCompleted = 4;</strong>
<strong class="bold">  bool isVictory = 5;</strong>
<strong class="bold">  int32 numberMoves = 6;</strong>
<strong class="bold">  google.protobuf.Timestamp startTime = 7;</strong>
<strong class="bold">  google.protobuf.Duration duration = 8;</strong>
<strong class="bold">}</strong></pre>
			<p>The <strong class="source-inline">syntax</strong> keyword<a id="_idIndexMarker1088"/> specifies the Protobus version that should be used. Version 3 added <a id="_idIndexMarker1089"/>features such as <strong class="source-inline">maps</strong> and <strong class="source-inline">oneof</strong> fields. The <strong class="source-inline">option</strong> keyword allows us to add language-specific features. <strong class="source-inline">option csharp_namespace</strong> sets the C# namespace that should be used by the generated classes, postfixed with the name set by the <strong class="source-inline">package</strong> keyword. The <strong class="source-inline">service</strong> keyword describes the list of operations offered by the gRPC service. Every operation within the service uses the <strong class="source-inline">rpc</strong> keyword (remote procedure call). In our code, the operation is called <strong class="source-inline">ReportGameCompleted</strong>, uses <strong class="source-inline">ReportGameCompletedRequest</strong> as a parameter, and returns <strong class="source-inline">google.protobuf.Empty</strong>. <strong class="source-inline">google.protobuf.Empty</strong> is one of the well-known Protobuf types that’s available. When used, this type must be imported using the <strong class="source-inline">import</strong> keyword. The <strong class="source-inline">google.protobuf.Duration</strong> and <strong class="source-inline">google.protobuf.Timestamp</strong> types are imported as well. <strong class="source-inline">ReportGameCompletedRequest</strong> is a message that’s specified using the <strong class="source-inline">message</strong> keyword. Every field within a message needs a unique identifier. The serializer and deserializers use this number to get a match. Thus, if you specify a contract once, don’t change the number in future versions, as this breaks existing clients or services. The types used need to be platform-independent as the same Protobuf file can be used by all platforms <a id="_idIndexMarker1090"/>that support gRPC. <strong class="source-inline">string</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">int32</strong> are types that are defined by the Protobuf specification. With .NET, these types map to <strong class="source-inline">string</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">int</strong>, respectively. <strong class="source-inline">Id</strong> is a GUID, but there’s no representation for GUIDs with Protobuf. <strong class="source-inline">string</strong> can be <a id="_idIndexMarker1091"/>used for the identifier. With the .NET <strong class="source-inline">GameSummary</strong> class, the <strong class="source-inline">StartTime</strong> property is of the <strong class="source-inline">DateTime</strong> type and the <strong class="source-inline">Duration</strong> property is of the <strong class="source-inline">TimeSpan</strong> type. To map these types with Protobuf, you can use <strong class="source-inline">Timestamp</strong> and <strong class="source-inline">Duration</strong>. These types are defined in the <strong class="source-inline">Google.Protobuf.WellKnownTypes</strong> .NET namespace. <strong class="source-inline">Timestamp</strong> and <strong class="source-inline">Duration</strong> offer conversion methods to convert to and from <strong class="source-inline">DateTime</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">TimeSpan</strong></span><span class="No-Break">.</span></p>
			<p>To create .NET classes from the Protobuf file, a <strong class="source-inline">Protobuf</strong> entry needs to be added to the project file, <span class="No-Break">like so:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Codebreaker.Live.csproj</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
<strong class="source-inline">  &lt;Protobuf Include="Protos\LiveGame.proto"</strong>
<strong class="source-inline">    GrpcServices="Server" /&gt;</strong>
&lt;/ItemGroup&gt;</pre>
			<p>This <strong class="source-inline">Protobuf</strong> entry references the Protobuf file with the <strong class="source-inline">Include</strong> attribute and specifies the code to be generated for the server by setting <strong class="source-inline">GrpcServices</strong> to <strong class="source-inline">Server</strong>. With the server, classes for all the defined messages and base classes for every service specified are generated. Later in this chapter, we’ll use the <strong class="source-inline">Protobuf</strong> element to generate classes for <span class="No-Break">the client.</span></p>
			<p>In the previous chapter, we created the <strong class="source-inline">GameSummary</strong> class to report game completions. To convert this class into the gRPC-generated <strong class="source-inline">ReportGameCompletedRequest</strong> class, we must define a <span class="No-Break">conversion method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Extensions/ReportGameCompletedRequestExtensions.cs</p>
			<pre class="source-code">
public static class ReportGameCompletedRequestExtensions
{
<strong class="bold">  public static GameSummary ToGameSummary(</strong>
<strong class="bold">    this ReportGameCompletedRequest request)</strong>
  {
<strong class="bold">    Guid id = Guid.Parse(request.Id);</strong>
<strong class="bold">    DateTime startTime = request.StartTime.ToDateTime();</strong>
<strong class="bold">    TimeSpan duration = request.Duration.ToTimeSpan();</strong>
    return new GameSummary(
      id,
      request.GameType,
      request.PlayerName,
      request.IsComleted,
      request.IsVictory,
      request.NumberMoves,
      startTime,
      duration);
  }
}</pre>
			<p>In this<a id="_idIndexMarker1092"/> implementation, we <a id="_idIndexMarker1093"/>create a new <strong class="source-inline">GameSummary</strong> instance and use conversion methods – for example, we parse a string to a <strong class="source-inline">Guid</strong> value and invoke the <strong class="source-inline">ToDateTime</strong> and <strong class="source-inline">ToTimeSpan</strong> methods to convert the <strong class="source-inline">Timestamp</strong> and <span class="No-Break"><strong class="source-inline">Duration</strong></span><span class="No-Break"> values.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To see the generated code with Visual Studio, click on the <strong class="source-inline">ReportGameCompletedRequest</strong> class, use the context menu, and select <strong class="bold">Go To Implementation</strong>. This directly opens the <span class="No-Break">generated code.</span></p>
			<p>With <strong class="source-inline">ReportGameService</strong>, we just have a very simple contract. To allow <strong class="source-inline">game-apis</strong> to <a id="_idIndexMarker1094"/>be called <a id="_idIndexMarker1095"/>and moves to be made by the bot service, we need a more <span class="No-Break">complex contract.</span></p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor343"/>Creating a gRPC service contract for the game-apis service</h2>
			<p>The gRPC <a id="_idIndexMarker1096"/>contracts <a id="_idIndexMarker1097"/>of the <strong class="source-inline">game-apis</strong> service are lengthier than for <strong class="source-inline">live-service</strong>. Here, we’ll focus on some specific parts of the contract. Check out this book’s GitHub repository for the <span class="No-Break">complete definition.</span></p>
			<p>The service contract specifies operations to play <span class="No-Break">the game:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
syntax = "proto3";
option csharp_namespace = "Codebreaker.Grpc";
package GamesAPI;
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
service GrpcGame {
<strong class="bold">  rpc CreateGame(CreateGameRequest)</strong>
<strong class="bold">    returns (CreateGameResponse);</strong>
<strong class="bold">  rpc SetMove(SetMoveRequest) returns (SetMoveResponse);</strong>
<strong class="bold">  rpc GetGame(GetGameRequest) returns (GetGameResponse);</strong>
}
// code removed for brevity</pre>
			<p>The <a id="_idIndexMarker1098"/>alternative option to the REST interface, <strong class="source-inline">GrpcGameService</strong>, defines operations to create a game (<strong class="source-inline">CreateGame</strong>), set a move (<strong class="source-inline">SetMove</strong>), and get information about a <span class="No-Break">game (</span><span class="No-Break"><strong class="source-inline">GetGame</strong></span><span class="No-Break">).</span></p>
			<p>Most <a id="_idIndexMarker1099"/>messages that are used to send a request to the service just contain scalar values. The <strong class="source-inline">SetMoveRequest</strong> message is different. This message contains a list of <span class="No-Break">guess pegs:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
message <strong class="bold">SetMoveRequest</strong> {
  string id = 1;
  string gameType = 2;
  int32 moveNumber = 3;
  bool end = 4;
<strong class="bold">  repeated string guessPegs = 5;</strong>
}</pre>
			<p>Lists are specified using the <span class="No-Break"><strong class="source-inline">repeated</strong></span><span class="No-Break"> keyword.</span></p>
			<p>Not only pre-defined types can be repeated – it’s also possible to repeat an inner <span class="No-Break">message type:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
message <strong class="bold">GetGameResponse</strong> {
  string id = 1;
  string gameType = 2;
  string playerName = 3;
  // code removed for brevity
<strong class="bold">  repeated Move moves = 14;</strong>
}
<strong class="bold">message Move {</strong>
<strong class="bold">  string id = 1;</strong>
<strong class="bold">  int32 moveNumber = 2;</strong>
<strong class="bold">  repeated string guessPegs = 3;</strong>
<strong class="bold">  repeated string keyPegs = 4;</strong>
<strong class="bold">}</strong></pre>
			<p>The <strong class="source-inline">GetGameResponse</strong> message type contains a repeated list of <strong class="source-inline">Move</strong> messages. The <strong class="source-inline">Move</strong> message<a id="_idIndexMarker1100"/> type<a id="_idIndexMarker1101"/> contains a list of strings for the guess pegs and the <span class="No-Break">key pegs.</span></p>
			<p>Protobuf also defines a list of keys and values via the <span class="No-Break"><strong class="source-inline">map</strong></span><span class="No-Break"> type:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
<strong class="bold">message FieldNames {</strong>
<strong class="bold">  repeated string values = 1;</strong>
<strong class="bold">}</strong>
<strong class="bold">message CreateGameResponse </strong>{
  string id = 1;
  string gameType = 2;
  string playerName = 3;
  int32 numberCodes = 4;
  int32 maxMoves = 5;
<strong class="bold">  map&lt;string, FieldNames&gt; fieldValues = 6;</strong>
}</pre>
			<p>With a map, the<a id="_idIndexMarker1102"/> key and value types are specified. With the <strong class="source-inline">fieldValues</strong> field, the key is a string. The corresponding REST API specifies a string array for the value. Using <strong class="source-inline">repeated</strong> with the value type is not possible with Protobuf. Instead, <strong class="source-inline">FieldMessage</strong> is defined to contain a <strong class="source-inline">repeated string</strong>, and this is used with the <span class="No-Break"><strong class="source-inline">map</strong></span><span class="No-Break"> value.</span></p>
			<p>The <a id="_idIndexMarker1103"/>message contracts create .NET classes that are specific to gRPC. When it comes to the local service classes, it’s better if they’re independent of communication technologies. So, we need to create <span class="No-Break">conversion methods.</span></p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor344"/>Creating conversion methods</h2>
			<p>The<a id="_idIndexMarker1104"/> gRPC service of <strong class="source-inline">live-service</strong> receives <strong class="source-inline">ReportGameCompletedRequest</strong>. This is forwarded to the SignalR service we created in the previous chapter as a <strong class="source-inline">GameSummary</strong> method. So, we need to convert <strong class="source-inline">ReportGameCompletedRequest</strong> into a <span class="No-Break"><strong class="source-inline">GameSummary</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Extensions/GrpcExtensions.cs</p>
			<pre class="source-code">
internal static class GrpcExtensions
{
<strong class="bold">  public static GameSummary ToGameSummary(</strong>
<strong class="bold">    this ReportGameCompletedRequest request)</strong>
  {
<strong class="bold">    Guid id = Guid.Parse(request.Id);</strong>
<strong class="bold">    DateTime startTime = request.StartTime.ToDateTime();</strong>
<strong class="bold">    TimeSpan duration = request.Duration.ToTimeSpan();</strong>
    return new GameSummary(
      id,
      request.GameType,
      request.PlayerName,
      request.IsCompleted,
      request.IsVictory,
      request.NumberMoves,
      startTime,
      duration);
  }
}</pre>
			<p>This is done<a id="_idIndexMarker1105"/> in the form of an extension method where we extend the <strong class="source-inline">ReportGameCompletedRequest</strong> type. With the implementation of the <strong class="source-inline">ToGameSummary</strong> method, simple scalar types can be passed on, creating a <strong class="source-inline">GameSummary</strong> object. Google’s <strong class="source-inline">Timestamp</strong> and <strong class="source-inline">Duration</strong> types offer the <strong class="source-inline">ToDateTime</strong> and <strong class="source-inline">ToTimeSpan</strong> methods to convert <strong class="source-inline">DateTime</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">TimeSpan</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Libraries such as <strong class="source-inline">AutoMapper</strong>, <strong class="source-inline">Mapster</strong>, and others can be used to automatically implement such conversions. While this works out of the box with simple properties without the need to add custom code, some customization is needed when converting different types. What you need to be aware of is that mapper libraries that use .NET reflection instead of source generators increase memory and CPU usage and cannot be used with native AOT. Depending on the types you need to map, you might prefer a custom <span class="No-Break">extension method.</span></p>
			<p>Check out this book’s GitHub repository for additional conversion methods that can be used with the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service.</span></p>
			<p>With the conversion methods in place, let’s create the gRPC <span class="No-Break">service implementations.</span></p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor345"/>Creating gRPC services</h1>
			<p>To implement a <a id="_idIndexMarker1106"/>gRPC service for the <strong class="source-inline">Codebreaker.Live</strong> project, create the <span class="No-Break"><strong class="source-inline">GRPCLiveGameService</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/GRPCLiveGameService.cs</p>
			<pre class="source-code">
using Codebreaker.Grpc;
using Google.Protobuf.WellKnownTypes;
using Grpc.Core;
namespace Codebreaker.Live.Endpoints;
public class <strong class="bold">GRPCLiveGameService</strong>(
  <strong class="bold">IHubContext&lt;LiveHub&gt; hubContext</strong>,
  ILogger&lt;LiveGameService&gt; logger) :
    <strong class="bold">ReportGame.ReportGameBase</strong>
{
<strong class="bold">  async public override Task&lt;Empty&gt; ReportGameCompleted(</strong>
<strong class="bold">    ReportGameCompletedRequest request,</strong>
<strong class="bold">    ServerCallContext context)</strong>
  {
    logger.LogInformation("Received game ended {type} " +
      "{gameid}", request.GameType, request.Id);
<strong class="bold">    await hubContext.Clients.Group(request.GameType)</strong>
<strong class="bold">      .SendAsync("GameCompleted", request.ToGameSummary());</strong>
<strong class="bold">    return new Empty();</strong>
  }
}</pre>
			<p>With the <strong class="source-inline">GRPCLiveGameService</strong> class, using constructor injection, the hub context we created in<a id="_idIndexMarker1107"/> the previous chapter is injected to send a <strong class="source-inline">GameSummary</strong> method to all connected clients participating with the group that is named with <strong class="source-inline">game-type</strong>. The <strong class="source-inline">GRPCLiveGameService</strong> class needs to derive from the base class – that is, <strong class="source-inline">ReportGame.ReportGameBase</strong>. <strong class="source-inline">ReportGameBase</strong> is implemented as an inner class of <strong class="source-inline">ReportGame</strong> based on the <span class="No-Break">Protobuf contract.</span></p>
			<p>Next, use the <strong class="source-inline">GRPCLiveGameService</strong> class to map it as a <span class="No-Break">gRPC endpoint:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static WebApplication MapApplicationEndpoints(this WebApplication app)
{
<strong class="bold">  app.MapGrpcService&lt;GRPCLiveGameService&gt;();</strong>
  app.MapHub&lt;LiveHub&gt;("/livesubscribe");
  return app;
 }</pre>
			<p>You can remove the mapping of the minimal API endpoint and just configure the gRPC endpoint with the <strong class="source-inline">WebApplication</strong> class known as <strong class="source-inline">MapGrpcService</strong>, passing the service class as a <span class="No-Break">generic parameter.</span></p>
			<p>gRPC requires HTTP/2. So, we need to configure the <span class="No-Break"><strong class="source-inline">Kestrel</strong></span><span class="No-Break"> server:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/appsettings.json</p>
			<pre class="source-code">
{
<strong class="bold">  "Kestrel": {</strong>
<strong class="bold">    "EndpointDefaults": {</strong>
<strong class="bold">      "Protocols": "Http1And2"</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>Configuring <strong class="source-inline">Protocols</strong> to <strong class="source-inline">Http1And2</strong> starts the <strong class="source-inline">Kestrel</strong> server and ensures it supports both HTTP/1 and HTTP/2. The gRPC service needs HTTP/2. When it comes to <strong class="source-inline">live-service</strong>, SignalR is offered from the same server. To allow the SignalR service to connect <a id="_idIndexMarker1108"/>via HTTP/1 or HTTP/2, the server must be configured to offer <span class="No-Break">both versions.</span></p>
			<p>The <strong class="source-inline">game-apis</strong> service’s implementation has similarities. In the project file, we need to add the <strong class="source-inline">Grpc.AspNetCore</strong> package, add a <strong class="source-inline">Protobuf</strong> element to the project file, and specify that we wish to create classes for <span class="No-Break">the server:</span></p>
			<p>Implementing this aspect of the gRPC service is simple: we can inject the <strong class="source-inline">IGameService</strong> interface. This uses the same classes we already used to implement the minimal <span class="No-Break">API service:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/GrpcGameEndpoints.cs</p>
			<pre class="source-code">
public class GrpcGameEndpoints(
  IGamesService gamesService,
  ILogger&lt;GrpcGameEndpoints&gt; logger) :
  <strong class="bold">Grpc.GrpcGame.GrpcGameBase</strong>
{
<strong class="bold">  public override async</strong>
<strong class="bold">    Task&lt;Grpc.CreateGameResponse&gt; CreateGame</strong>(
    Grpc.CreateGameRequest request,
    ServerCallContext context)
  {
    logger.GameStart(request.GameType);
<strong class="bold">    Game game = await gamesService.StartGameAsync(</strong>
<strong class="bold">      request.GameType, request.PlayerName);</strong>
<strong class="bold">    return game.ToGrpcCreateGameResponse();</strong>
  }
<strong class="bold">  public override async Task&lt;SetMoveResponse&gt; SetMove(</strong>
<strong class="bold">    SetMoveRequest request, ServerCallContext context)</strong>
  {
    Guid id = Guid.Parse(request.Id);
    string[] guesses = request.GuessPegs.ToArray();
    (Game game, Models.Move move) =
      await gamesService.SetMoveAsync(
        id, request.GameType, guesses, request.MoveNumber);
    return game.ToGrpcSetMoveResponse(move);
  }
<strong class="bold">  public override async Task&lt;GetGameResponse&gt; GetGame(</strong>
<strong class="bold">    GetGameRequest request, ServerCallContext context)</strong>
  {
    Guid id = Guid.Parse(request.Id);
    Game? game = await gamesService.GetGameAsync(id);
    if (game is null)
      return new GetGameResponse()
      {
        Id = Guid.Empty.ToString()
      };
    return game.ToGrpcGetGameResponse();
  }
}</pre>
			<p>In gRPC, we can derive from the generated base class, <strong class="source-inline">GrpcGame.GrpcGameBase</strong>, override the base<a id="_idIndexMarker1109"/> class methods that have been specified with the service contracts, and use the conversion methods to convert the input and output types into their corresponding <span class="No-Break">gRPC representations.</span></p>
			<p>Similar to <strong class="source-inline">live-service</strong>, the <strong class="source-inline">game-apis</strong> service needs gRPC to be added to the DI container and mapped to the endpoint, and <strong class="source-inline">Kestrel</strong> needs to be configured so that it supports both HTTP/1 <span class="No-Break">and HTTP/2.</span></p>
			<p>With the services implemented, let’s consider the <span class="No-Break">gRPC clients.</span></p>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor346"/>Creating gRPC clients</h1>
			<p>If you’re <a id="_idIndexMarker1110"/>using Visual Studio 2022, you can take advantage of its built-in support to add a gRPC client. From Solution Explorer, select the project, open the context menu, and select <strong class="bold">Add</strong> | <strong class="bold">Connected Service</strong>. This opens the dialogue shown in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B21217_14_02.jpg" alt="Figure 14.2 – Add service reference"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Add service reference</p>
			<p>Select <strong class="bold">gRPC</strong> and <a id="_idIndexMarker1111"/>click <strong class="bold">Next</strong>. This opens the dialogue shown in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B21217_14_03.jpg" alt="Figure 14.3 – Add new gRPC service reference"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Add new gRPC service reference</p>
			<p>Select the Protobuf file, then select <strong class="bold">Client</strong> from the <strong class="bold">Select the type of class to be generated</strong> dropdown to create the classes for messages and the code for <span class="No-Break">the client.</span></p>
			<p>If you’re not<a id="_idIndexMarker1112"/> using Visual Studio, you can use a .NET command-line tool called <strong class="source-inline">dotnet</strong>. To install this tool, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet tool install -g dotnet-grpc</pre>
			<p>With this tool globally installed, you can use the <strong class="source-inline">dotnet-grpc</strong> command to create the proxy classes for the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> client:</span></p>
			<pre class="console">
cd Codebreaker.GameAPIs
dotnet-grpc add-file ..\Codebreaker.Live\Protos\LiveGame.proto</pre>
			<p>You can run the following for the bot <span class="No-Break">service client:</span></p>
			<pre class="console">
cd ..
cd Codebreaker.Bot
dotnet-grpc add-file ..\Codebreaker.GameAPIs\Protos\GameService.proto</pre>
			<p>What happened with these commands or with the Visual <span class="No-Break">Studio integration?</span></p>
			<ul>
				<li>The <strong class="source-inline">Grpc.AspNetCore</strong> NuGet package was added to <span class="No-Break">the project</span></li>
				<li>A <strong class="source-inline">Protobuf</strong> element was added to the <span class="No-Break">project file</span></li>
			</ul>
			<p>Using the <a id="_idIndexMarker1113"/>command-line tool, code for both the client and the server is created when the <strong class="source-inline">Protobuf</strong> entry is created. To only create code for the client, the <strong class="source-inline">GrpcServices="Client"</strong> attribute needs to <span class="No-Break">be added:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPis/Codebreaker.GameAPIs.csproj</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
  <strong class="bold">&lt;Protobuf</strong>
<strong class="bold">    Include="..\Codebreaker.Live\Protos\LiveGame.proto"</strong>
<strong class="bold">    GrpcServices="Client" /&gt;</strong>
<strong class="bold">  &lt;Protobuf Include=".\Protos\GameService.proto" GrpcServices="Server" /&gt;</strong>
&lt;/ItemGroup&gt;</pre>
			<p>Regarding the <strong class="source-inline">game-apis</strong> service, the project file now includes two <strong class="source-inline">Protobuf</strong> entries. One is used to create the service part (which we did in the previous section), while the new entry is for the <span class="No-Break">client code.</span></p>
			<p>The bot invokes the <strong class="source-inline">game-apis</strong> service. So, the proto file of the <strong class="source-inline">game-apis</strong> service needs to be referenced in the bot <span class="No-Break">project file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/Codebreaker.Bot.csproj</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
  <strong class="bold">&lt;Protobuf Include=</strong>
<strong class="bold">    "..\Codebreaker.GameApis\Protos\GameService.proto"</strong>
<strong class="bold">    GrpcServices="Client" /&gt;</strong>
&lt;/ItemGroup&gt;</pre>
			<p>Again, for the client, <strong class="source-inline">GrpcServices</strong> is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Client</strong></span><span class="No-Break">.</span></p>
			<p>Upon using<a id="_idIndexMarker1114"/> the proto files, client proxy classes are created, offering methods to invoke the service with the names of the operations. These proxy classes can be injected. In the following code snippet, the generated <strong class="source-inline">ReportGameClient</strong> class is being injected into the <span class="No-Break"><strong class="source-inline">GrpcLiveReportClient</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameApis/GrpcLiveReportClient.cs</p>
			<pre class="source-code">
public class <strong class="bold">GrpcLiveReportClient</strong>(
<strong class="bold">  ReportGame.ReportGameClient client,</strong>
  ILogger&lt;LiveReportClient&gt; logger) : <strong class="bold">ILiveReportClient</strong>
{
  public async Task ReportGameEndedAsync(GameSummary gameSummary, 
    CancellationToken cancellationToken = default)
  {
    try
    {
<strong class="bold">      ReportGameCompletedRequest request = gameSummary.</strong>
<strong class="bold">        ToReportGameCompletedRequest();</strong>
<strong class="bold">      await client.ReportGameCompletedAsync(request);</strong>
    }
    catch (Exception ex) when (ex is RpcException or
      SocketException)
    {
      logger.ErrorWritingGameCompletedEvent(
        gameSummary.Id, ex);
    }
  }
}</pre>
			<p><strong class="source-inline">ReportGameClient</strong> implements the <strong class="source-inline">ILiveReportClient</strong> interface – the same interface we defined and implemented in the previous chapter to invoke the SignalR service on <a id="_idIndexMarker1115"/>completion of a game. When implementing the same interface, we just need to change the configuration of the DI container so that it invokes the service via gRPC instead of using the REST interface. With the implementation of the <strong class="source-inline">ReportGameEndedAsync</strong> method, we can invoke the generated method from the proxy and need to convert the parameter with the help of an <span class="No-Break">extension method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameApis/ApplicationServices.cs</p>
			<pre class="source-code">
builder.Services.<strong class="bold">AddSingleton&lt;ILiveReportClient,</strong>
<strong class="bold">  GrpcLiveReportClient&gt;()</strong>
<strong class="bold">  .AddGrpcClient&lt;ReportGame.ReportGameClient&gt;(</strong>
<strong class="bold">    grpcClient =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">      grpcClient.Address = new Uri("https://live");</strong>
<strong class="bold">    });</strong>
// code removed for brevity</pre>
			<p>Similarly, for the bot service, <strong class="source-inline">GrpcGamesClient</strong> implements the <strong class="source-inline">IGamesClient</strong> interface and <span class="No-Break">injects </span><span class="No-Break"><strong class="source-inline">GrpcGame.GrpcGameClient</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/GrpcGamesClient.cs</p>
			<pre class="source-code">
<strong class="bold">public class GrpcGamesClient(</strong>
<strong class="bold">  GrpcGame.GrpcGameClient client,</strong>
<strong class="bold">  ILogger&lt;GrpcGamesClient&gt; logger) : IGamesClient</strong>
{
  // code removed for brevity
<strong class="bold">  public async Task&lt;(string[] Results, bool Ended,</strong>
<strong class="bold">    bool IsVictory)&gt; SetMoveAsync(</strong>
    Guid id, string playerName, GameType gameType,
    int moveNumber, string[] guessPegs,
    CancellationToken cancellationToken = default)
  {
    <strong class="bold">SetMoveRequest</strong> request = new()
    {
      Id = id.ToString(),
      GameType = gameType.ToString(),
      MoveNumber = moveNumber,
      End = false
    };
    request.GuessPegs.AddRange(guessPegs);
<strong class="bold">    var response = await client.SetMoveAsync(request,</strong>
<strong class="bold">      cancellationToken: cancellationToken);</strong>
    return (response.Results.ToArray(), response.Ended,
      response.IsVictory);
  }</pre>
			<p>The <strong class="source-inline">IGamesClient</strong> interface<a id="_idIndexMarker1116"/> was the same one that’s implemented by <strong class="source-inline">GameClient</strong>, which calls the REST API. This interface is injected into <strong class="source-inline">CodebreakerGameRunner</strong>, so no changes are required when switching <span class="No-Break">to gRPC.</span></p>
			<p>The <strong class="source-inline">SetMoveAsync</strong> method makes a request to the gRPC service by invoking the <strong class="source-inline">SetMoveAsync</strong> method of <strong class="source-inline">GrpcGame.GrpcGameClient</strong>. Similar to before, it aims to convert the parameters into the ones needed <span class="No-Break">by gRPC.</span></p>
			<p>For help <a id="_idIndexMarker1117"/>with implementing the other methods of the interface, check out this book’s GitHub repository. Note that it’s similar to what we <span class="No-Break">did previously.</span></p>
			<p>To glue <strong class="source-inline">IGamesClient</strong> to the new implementation, and to configure the gRPC client, we need to update the DI <span class="No-Break">container’s configuration:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/ApplicationServices.cs</p>
			<pre class="source-code">
<strong class="bold">builder.Services.AddSingleton&lt;IGamesClient,</strong>
<strong class="bold">  </strong><strong class="bold">GrpcGamesClient&gt;()</strong>
<strong class="bold">  .AddGrpcClient&lt;GrpcGame.GrpcGameClient&gt;(client) =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    client.Address = new Uri("https://gameapis");</strong>
<strong class="bold">  });</strong></pre>
			<p>The <strong class="source-inline">AddGrpcClient</strong> method configures the generated class with the address of the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service.</span></p>
			<p>Now, run the application and start one or multiple instances of the live test client to see if completed games show up. Start the bot service and send requests to the bot service to play several games. At the same time, use another client to play a game. How many games does the bot run until you complete one? Of course, this depends on the think time you configure with the bot. Do the results show up in the console of the live test client? Check the logs and the environment variables of the different services in the .NET <span class="No-Break">Aspire dashboard.</span></p>
			<h1 id="_idParaDest-348"><a id="_idTextAnchor347"/>Summary</h1>
			<p>In this chapter, you learned the differences between REST APIs and gRPC, as well as the advantages when using gRPC with <span class="No-Break">service-to-service communication.</span></p>
			<p>You created a service contract using Protobuf syntax to define services and messages. Contrary to REST, gRPC is strict when it comes to messages and service operations. You created servers and clients using the classes that were generated with the <span class="No-Break">proto files.</span></p>
			<p>To reduce cost in the cloud, it can be cost-effective to use protocols with lower overhead for service-to-service communication. However, other options are available as well. Upon completion of the game, it’s not required to inform the listener immediately. There’s also a price aspect to this: with the current implementation, the live service is running when accessed from the game APIs service. If nobody is listening, this is not required. By using asynchronous communication, the <strong class="source-inline">live-service</strong> can register to receive information when it’s started – this is when a listener is active. Asynchronous communication will be covered in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor348"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">Protobuf Language </em><span class="No-Break"><em class="italic">Guide</em></span><span class="No-Break">: </span><a href="https://protobuf.dev/programming-guides/proto3/"><span class="No-Break">https://protobuf.dev/programming-guides/proto3/</span></a></li>
				<li><em class="italic">gRPC on .NET-supported </em><span class="No-Break"><em class="italic">platforms</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms</span></a></li>
				<li><em class="italic">grpc-dotnet GitHub </em><span class="No-Break"><em class="italic">repository</em></span><span class="No-Break">: </span><a href="https://github.com/grpc/grpc-dotnet"><span class="No-Break">https://github.com/grpc/grpc-dotnet</span></a></li>
				<li><em class="italic">Call gRPC services with the .NET </em><span class="No-Break"><em class="italic">client</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/client"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/grpc/client</span></a></li>
			</ul>
		</div>
	</body></html>