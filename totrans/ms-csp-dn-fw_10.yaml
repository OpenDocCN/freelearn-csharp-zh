- en: Chapter 10. Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're not focusing on the architecture and tools required to
    manage a solution's life cycle (sometimes called the development ecosystem) but
    on the quality of the code and its structures in terms of efficacy, precision,
    and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the SOLID principles, proposed by Robert Martin, which are
    gaining more and more recognition and that we can see implemented in different
    frameworks and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: A basic application will be used to illustrate the distinct principles, and
    as the requirements evolve, we'll apply different principles and patterns to solve
    the problems.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll go through the eight most used patterns of the Gang of Four (according
    to statistics), revising its definitions and purpose to finish with the current
    list of available patterns created and published after the GoF group published
    their book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/Closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov Substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other software patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The origins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With time, programming techniques have evolved, at the same pace as languages
    and hardware; so, from the initial confusion in the early 60s, when no foundations
    were established and few models were considered, the 70s marked the start of the
    adoption of other paradigms, such as procedural programming, and later on, **object
    oriented programming** (**OOP**).
  prefs: []
  type: TYPE_NORMAL
- en: Ole-Johan Dahl and Kristen Nygaard originally proposed OOP with the Simula language,
    when they both worked at the Norwegian Computing Center. They were given the Turing
    Award for these achievements, among other recognitions.
  prefs: []
  type: TYPE_NORMAL
- en: A few years later (around 1979), Bjarne Stroustrup created C with Classes, the
    prototype of what C++ today is because he found valuable aspects in Simula, but
    he thought that it was too slow for practical purposes. C++ originally had imperative
    features and object-oriented and generic ones, while also providing the ability
    to program for low-level memory manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: It was the first OOP language that became universal in adoption (though limited
    in number), due to its many virtues, but for many people, it was not adequate
    for business applications.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, the appearance of Java and the .NET platforms proposed a much easier
    and affordable solution for many programmers while still moving within the ordered
    space that object oriented programming languages promote.
  prefs: []
  type: TYPE_NORMAL
- en: So, OOP was adopted, and up until this date, no other important programming
    paradigm has substituted these ideas. Surely, there are other approaches, such
    as functional programming, but even the most significant representative of this
    tendency, JavaScript, is becoming more object-oriented in the latest versions
    (ECMAScript 2015).
  prefs: []
  type: TYPE_NORMAL
- en: With the accelerated expansion of software solutions, many lessons were learned
    about how to correctly afford common software problems, and that will be our starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some programming guidelines have a wide, general-purpose intention, while some
    are designed to fix certain specific problems. Thus, before talking about the
    specific problems, we should review those features that can be applied in many
    different scenarios and solutions. I mean those principles that should be taken
    into consideration beyond the type of solution or specific platform to program
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, this is where the SOLID principles (and other related problems) come
    into play. In 2001, Robert Martin published a foundational article on the subject
    ([http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)),
    in which he picked up a set of principles and guidelines that, in his own words,
    *focus very tightly on dependency management*, its inconveniences, and how to
    solve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain this further in his words, *poor dependency management leads to
    code that is hard to change, fragile, and non-reusable*. Reusability is one the
    main principles of OOP, along with maintainability (the capacity to change as
    the project grows: one of the purposes of inheritance).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, there are 11 principles to consider, but they can be divided into
    three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID principles, which deal with class design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the principles, which are about packages: three of them are about
    package cohesion and the other three study couplings between packages and how
    to evaluate the package structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're going to start with the SOLID principles, which by extension not only
    affect the class design, but other architectures as well.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the application of some of these ideas paved the way for some
    of the most important modifications in the building of HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: The application of the **SRP** (**Single Responsibility principle**), from which
    the more general design principle of Separation of Concerns is derived, only highlighted
    the need to totally separate presentation (CSS) from content (HTML) and the subsequent
    deprecation of some tags (`<cite>`, `<small>`, `<font>`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the aforementioned tags are deprecated and not recommended as presentation
    features, but they are kept in the standard because of their semantic value instead,
    such as `<b>`, `<i>`, <`small>`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This applies to some popular frameworks, such as AngularJS, which was designed
    not only with the Single Responsibility principle in mind, but also based on the
    Dependency Inversion principle (the **D** in SOLID).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next graphic resumes the five principles'' initials and its correspondences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SOLID principles](img/image00629.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The explanation of every letter in the acronym as expressed in Wikipedia is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S - Single Responsibility Principle**: A class should have only a single
    responsibility (that is, only one potential change in the software''s specification
    should be able to affect the specification of the class). Martin states that this
    principle is based on the principle of cohesion, previously defined by Tom de
    Marco in a book named *Structured Analysis and Systems Specification* and by Meilir
    Page-Jones in his work *The Practical Guide to Structured Systems Design*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O - Open/Closed Principle**: Software entities should be open for extension,
    but closed for modification. Bertrand Meyer was the first to propose this principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L - Liskov Substitution principle**: *Objects in a program should be replaceable
    with instances of their subtypes without altering the correctness of that program*.
    Barbara Liskov first stated this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I - Interface Segregation principle**: *Many client-specific interfaces are
    better than one general-purpose interface*. Robert C. Martin was the first to
    use and formulate this principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D - Dependency inversion principle**: *We should ''Depend on Abstractions''.
    Do not depend upon concretions*. This too is an idea developed by Robert C. Martin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For **Single Responsibility principle** (**SRP**), the basic statement, in this
    case, is *there should never be more than one reason for a class to change*. In
    this context, responsibility is defined as *a reason for change*. If, under any
    circumstance, more than one reason comes up to change the class, the class' responsibilities
    are multiple and should be redefined.
  prefs: []
  type: TYPE_NORMAL
- en: This is, indeed, one of the most difficult principles to apply properly because
    as Martin says, *conjoining responsibilities is something that we do naturally*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his book *Agile Principles, Patterns, and Practices in C#* , Martin proposes
    a canonical example to show the differences, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the previous interface, any class implementing this interface has two
    responsibilities: the connection management and the communication itself. Such
    responsibilities can be used from the different parts of an application, which,
    in turn, might change as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of this code structure, Martin proposes a different diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single Responsibility principle](img/image00630.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, one wonders, should these two responsibilities be separated? It only
    depends on application changes. To be precise, the key here is to know whether
    changes in the application affect the signature of connection functions. If they
    do, we should separate both; otherwise, there's no need for separation because
    we would then create needless complexity.
  prefs: []
  type: TYPE_NORMAL
- en: So, overall, reason to change is the key, but keep in mind that a reason to
    change is applicable only if changes occur.
  prefs: []
  type: TYPE_NORMAL
- en: In other situations, there might be reasons to keep distinct responsibilities
    together as long as they are closely related to the business definitions or have
    to do with hardware requirements of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's imagine we need to create a simple Windows Forms application (we pick
    this model for simplicity in order to avoid unnecessary XAML), which has the ability
    to offer the user a few cars (actually, just three different brands), and the
    application should show maximum speed and a photo for the selected car.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we can derive from the class hierarchy to create different versions
    that are able to cover distinct characteristics, specific of business models,
    or legal conditions, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first step is to represent the user interface that will cover the requirements,
    mentioned previously, according to the indications. I came up with a very simple
    Windows form, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/image00631.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We're dealing with three (or more) brands, and optionally, we have a place to
    display the maximum speed value. We also included a button for acceleration so
    that we can verify that the car never goes faster than its maximum speed limit.
    Finally, the photo will remind us about the car we're dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: So, we plan to define a class named `SportCar`, in which we will abstract the
    required elements to be managed from the UI, and to make things clearer, we start
    by creating an interface, `ISportCar`, which states the requisites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Class Diagram tool to create an interface that defines four
    properties and one method: `Brand`, `MaxSpeed`, `Photo`, `Speed`, and `Accelerate`
    (which will change the Speed property from the user interface). So, the final
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the Class Diagram tool, we can create a `SportCar` class and link it to
    the interface so it declares the dependency. Later on, with the basic class declaration
    created by the IDE, we can move on to the source code and indicate the `Implement
    Interface` option to have the class with the interface implemented for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few touches for the sake of simplicity can have us end up with the following
    initial code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that all properties are read-only, since all except one should be established
    at creation time, and the only method that changes (`Speed`) must only vary using
    the `Accelerate` method (declared as virtual in order to allow further inheritance).
    This method returns a Boolean value to indicate the limit conditions: `MaxSpeed`
    exceeded. This is why it''s declared a private set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the graphic side, our (now modified) diagram should reveal dependencies
    and members of both code fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/image00632.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, at first, the class has the sole responsibility of managing the state of
    a `SportCar` instance of the class. This implies business logic: a Ferrari looks
    like a Ferrari, not like a BMW, and each one has its own properties (`MaxSpeed`
    and `Speed` in this case). Nothing related to the user interface or storing state,
    among other things, should be considered here.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a constructor that enforces some of the principles mentioned earlier.
    It should resolve all the immutable properties; so, when the class is created,
    they are assigned the proper value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we face another problem: how does our class know about the possible brands
    available? There are several approaches here, but a simple one would be to declare
    an internal array defining the allowed brands and have the constructor check whether
    the brand suggested in the construction is one of the brands our class can manage.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that I have included three simple pictures corresponding to the three brands
    inside the application's resource file. This is a dependency. If a fourth brand
    needs to be considered, we should change the constructor to supply this additional
    functionality, but for the sake of simplicity, let's assume that no changes in
    the business logic of the number of cars will happen for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in mind, we will add the following code to our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have an operational (although incomplete) version of our class.
    Now, in the user interface, we should declare a variable of the `SportCar` class
    and instantiate it every time the user changes the brand using the `cboPickUpCar`
    ComboBox.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, we also need to update the UI once the car is instantiated so that
    it reflects the properties of the car (its state). And it should be consistent
    with the properties of every brand available.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple code does the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a first version that works properly, but our class needs to have
    the ability to change the `Speed` property. So we add some code to the `Accelerate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it. We should now reflect these changes in the UI, which is pretty
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The final result should work as expected (refer to the screenshot). You can
    pick from the different brands available, and every new selection provokes a new
    instantiation of the `SportCar` class.
  prefs: []
  type: TYPE_NORMAL
- en: We can see all the properties at runtime, and the only mutable property (`Speed`)
    is changed exclusively from the `Accelerate` method, which now has a unique responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since this responsibility implies business logic, it also checks whether
    an attempt to exceed the allowed speed has taken place and avoids a case inspecting
    the possible value of an increase in the speed (we have assumed a constant value
    for that speed in the initial declarations of the class). You should see an output
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/image00633.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's consider some possible situations that arise when changes are proposed.
    This is when the next principle comes into action, and it deals with how to manage
    requisites when new conditions arise.
  prefs: []
  type: TYPE_NORMAL
- en: Open/Closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can detect the need to use this principle when a change in the module outcomes
    in a waterfall of changes that affect dependent modules. The design is said to
    be too inflexible.
  prefs: []
  type: TYPE_NORMAL
- en: The **Open/Closed principle** (**OCP**) advises us that we should refactor the
    application in a manner that future changes don't provoke further modifications.
  prefs: []
  type: TYPE_NORMAL
- en: The form to apply this principle correctly would be by extending the functionality
    with new code (for instance, using polymorphism) and never changing the old code,
    which is working already. We can find several strategies to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Observe that *closed for modification* is especially meaningful when you have
    distinct, separate modules (DLLs, EXEs, and so on) that depend on the module to
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, using extension methods or polymorphic techniques allows
    us to perform changes in code without affecting the rest. Think, for example,
    about the extension methods available in the C# language since version 3.0\. You
    can consider extension methods a special type of static method, with the difference
    that they are called as if they were instance methods of the extended type. You
    find a typical example in the LINQ standard query operators because they add a
    query functionality to the existing types, such as `System.Collections.IEnumerable`
    or `System.Collections.Generic.IEnumerable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: The classical and simplest example of this pattern is the client/server cohesion
    that is largely seen in development for many years. It is preferable that clients
    depend on servers' abstractions, not on their concretions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved with interfaces. Servers can implement a client interface
    that clients will use to connect to them. In this manner, servers can change without
    affecting the way clients use them (refer to the next diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open/Closed principle](img/image00634.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Any subtype of client interface will be free to implement the interface in the
    way it deems more appropriate and as long as it doesn't break other clients' access.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's imagine that the Mercedes corporation announces a change in their
    models, which allows you to receive a notification when the user is in danger
    due to the car approaching its speed limit.
  prefs: []
  type: TYPE_NORMAL
- en: On first view, some would think about modifying the `Accelerate` method to include
    an event that can communicate this circumstance to whatever user interface is
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: However, that would violate the OCP, since the current version is already working
    properly. This is one case where polymorphism is useful.
  prefs: []
  type: TYPE_NORMAL
- en: We can create another overload of the `Accelerate` method to allow this. It
    could receive an argument (the brand) that identifies whether the call is being
    made from a Mercedes and launch an event call, so any client could act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll duplicate the project in a new one with another name so that you always
    have distinct versions depending on the case (`Demo2-OCP`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we declare a new event member (`SpeedLimit`) and invoke the
    event if the Boolean value is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Since events are notifications and not direct function calls to the user interface,
    the UI is free to subscribe to the events required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the user interface, we should subscribe to the `SpeedLimit` event and modify
    our `btnAccelerate_Click` event handler in this manner to handle this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the instantiation process, the subscription is quite simple, and we can
    also have the IDE to create the `SpeedLimit` event handler for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Observe that I'm simplifying the code as much as possible because the interest
    here is showing coding practices that align with the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute this code, we can observe that—just for the Mercedes—if we
    try to pass the speed limit, a MessageBox popup indicating the circumstance appears
    (refer to the screenshot). The other brands are not affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back to our sample](img/image00635.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, as we mentioned, the .NET framework also uses these patterns and others
    in different namespaces, and that also includes the important LSP principle, as
    we'll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s remember this definition: subtypes must be substitutable for their base
    types. This means that this should happen without breaking the execution or losing
    any other kind of functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that this idea lies behind the basic principles of inheritance
    in the OOP programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a method that requires an argument of the `Person` type (let's put
    it that way), you can pass an instance of another class (`Employee`, `Provider`,
    and so on) as long as these instances inherit from `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the main advantages of well-designed OOP languages, and the most
    popular and accepted languages support this characteristic.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the code again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at the support inside our sample, where a new requisite arises.
    Actually, our demo simply calls the subscribers of Mercedes cars and notifies
    them that a `SpeedLimit` event took place.
  prefs: []
  type: TYPE_NORMAL
- en: However, what if we need to know the moment in time in which that circumstance
    happened and the resulting speed that we tried to obtain? That is, what if we
    need more information about the event?
  prefs: []
  type: TYPE_NORMAL
- en: In the current state, the `SpeedLimit` event does not pass any information to
    the caller beyond the sender (which refers to the origin of such call). But we
    can use the implementation of the Liskov Substitution principle inherent to the
    C# language in order to pass a derived class of `EventArgs` containing the required
    information, and the context should manage it just as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first step is to inherit from `EventArgs` and create a new class capable
    of holding the solicited information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to change the event invocation so that it recovers the necessary
    information before calling the event. In this way, the new version of `Accelerate`—which
    is still totally compatible with the previous one—will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, when we invoke `SpeedLimit`, we are sending business logic information to
    any subscriber, either from the UI or any other. So, we can pass a derived instance
    of the `EventArgs` class to the event without provoking any complain in the UI's
    editor (or the compiler).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to change the user interface to recover the data passed to
    it and present it in a modified version of the previous `MessageBox` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, when we select a Mercedes car and try to surpass the limit, we get
    a much more informative report in `MessageBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back to the code again](img/image00636.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Thanks to the Liskov Substitution principle support, we were able to add behavior
    and information with minimum effort, knowing that the UI receiving the information
    would perform a simple casting to convert the basic `EventArgs` declaration into
    the extended `SpeedLimitData` event that we really passed to the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Other implementations of LSP in .NET (Generics)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not the only implementation of the LSP principle that we find inside
    .NET, since different areas of the framework have grown using this conception.
    For instance, generics are one of the benefits of LSP.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample, we can create a generic version of the event in order to manage
    extra information very easily. Imagine that besides the private measures taken
    in the case of Mercedes, all the brands now want to support messaging when the
    legal speed limit is reached.
  prefs: []
  type: TYPE_NORMAL
- en: This affects any instance of `SpeedCar`. It's not mandatory (it doesn't force
    you to stop increasing the speed, but it shows you another warning about this
    condition).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it has an impact on all brands, we can add a new event to the `SpeedCar`
    class, only this time, we define it as generic in order to support the extra information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that the value for Speed Legal Limit is the maximum allowed in
    some states of the US (80 mi/h). We''ll define a new constant, `MaxLegal`, with
    this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to reflect this new condition, we should modify our `Accelerate` methods
    to include a previous call in case the car exceeds the legal value, indicating
    the amount exceeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's all the work you need to do with the `SpeedCar` class. The rest will
    be an update to the user interface; so, for any car, when the condition launches,
    another `MessageBox` call warns the user about the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, we now register every car for the `LegalLimitCondition` event
    and let the IDE generate the associated event handler for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we pass the argument to a revised version of the `UpdateUI` method,
    which now admits an optional argument, indicating the speed excess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. Now, different event mechanisms inform the user interface about
    the business logic conditions via notifications with a custom event system.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the sequence in calling events is important and the final assignment
    of the `Speed` value is performed at the end of the `Accelerate` method when all
    previous conditions have been processed.
  prefs: []
  type: TYPE_NORMAL
- en: Events are flexible enough as to be defined in a way that allows us to pass
    our own information via classic definitions, or—with the participation of generics—we
    can simply define a generic event handler that holds information of any kind.
    All these techniques foster the implementation of good practices, not just the
    SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the UI should not affect the `SportClass` definition; although its
    usage of the business logic differs, we keep the changes in the class to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, we will now be warned about any excess in velocity over the `MaxLegal`
    constant previously established (refer to the screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other implementations of LSP in .NET (Generics)](img/image00637.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the other two principles remaining in the SOLID package now:
    **Interface Segregation principle** (**ISP**) and **Dependency Inversion principle**
    (**DIP**).'
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Martin states, this principle *deals with the inconveniences of "fat" interfaces*.
    And the problem arises when the interfaces of the class can be logically fragmented
    into distinct groups or methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, if there is more than a client of our application, chances are
    that some clients are connected to a functionality they never use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our demo again: the mere review of the definition reveals that our
    system has some defects from the point of view of this principle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re implementing a method that is only used by a type of a `SportCar`
    client: the Mercedes. The other brands don''t use it. In case a new condition
    arises for a different brand, new options should be created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this marks a difference in the way in which we can categorize our cars:
    those who notify the user interface about `SpeedLimit` and those who don''t. We
    should start by redefining our `ISportCar` interface to cover only those aspects
    that are commonly used by any client. This includes the `LegalLimitCondition`
    event but not the `SpeedLimit` event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will have this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version of `SportCar` would implement only an `Accelerate` overload
    of the method, launching the `LegalLimitCondition` event but not the `SpeedLimit`
    event, which is only suitable for the Mercedes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that we still control `MaxSpeed`, only that we don't take any action but
    avoid the speed beyond the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: This separation suggested by this principle also applies to the first principle,
    since now, the responsibilities of this class are focused on the group of clients
    that use this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we will create a new class `SportsCarWithN` (a sports car
    with notifications) that inherits from `SportsCar` but adds the functionality
    required by the Mercedes (or any other brand that would decide to do this in the
    future):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, each part of the hierarchy takes care of its own duties. Any
    car that inherits from `SportCarWithN` will have the extra functionality, while
    the rest of the cars will behave in the standard manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the user interface, things also get simplified. Now, we declare `theCar`
    to be of type `ISportCar` and decide which constructor to call at execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `btnAccelerate_Click` event handler is also simplified, since every instance
    of `ISportCar` will know how to call the appropriate method in the underlying
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, at runtime, only the Mercedes brand receives both notifications, while
    the rest of the brands get only the `LegalLimitCondition` event.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the results in Demo-ISP and check out both types of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last of the SOLID principles is based on two statements, that Wikipedia
    states in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '*High-level modules should not depend on low-level modules. Both should depend
    on abstractions.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Abstractions should not depend upon details. Details should depend upon abstractions.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As for the first statement, we should clarify what we understand by high-level
    and low-level modules. The terminology is related to the importance of the actions
    performed by the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put it simply: if a module holds the business logic of a `Customers`
    class, and another includes the format that a list of the `Customers` class uses
    in a report, the first one would be high-class and the second would be low-class.'
  prefs: []
  type: TYPE_NORMAL
- en: The second statement speaks by itself. If an abstraction depends on details,
    the usage as a definition contract is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of our sample, we still have some code that will not grow appropriately:
    the `SportsCar` creation method depends much on what the user writes in the ComboBox.
    There are several situations that could show this inconvenience: writing the wrong
    name in the brand selection procedure, adding future new brands, and so on. There
    is some boilerplate code in the UI that we can improve.'
  prefs: []
  type: TYPE_NORMAL
- en: A final version of the sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without pretending that the sample is perfect (at all), the creation procedure
    can be extracted from the UI and delegated to another class (`CarFactory`) that
    would be responsible for calling the appropriate constructor depending on the
    brand. (We'll see that this technique is actually implemented using one of the
    design patterns we'll study later on.)
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the responsibility of calling the proper constructor would be on
    `CarFactory`, and additional brands can be added more easily.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, our `SportsCar` class will now exclusively take care of its state
    and business logic related to the state and not the details of `Photo` associations
    or `MaxSpeed` values, which seem adequate for a factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will now have a new class (located in the same file as the `SportsCar`
    file), containing these details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new version, the `SportsCar` class is reduced to a minimum: it declares
    constants, its event, its state (properties), and the only action required (`Accelerate`).
    The rest is in the hands of the `CarFactory` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface is also simplified in the creation method, since it doesn''t
    need to know which brand the user selected in order to call either constructor;
    it simply calls the constructor inside `CarFactory` and checks the result of the
    process in order to assign the event handlers required to show the car''s notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The runtime behavior is just the same as earlier. The difference is that with
    this decoupling of components, maintenance and growing are much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that a change happens and the application now has to deal with
    a new type of brand: Ford, which also incorporates `SpeedLimit` notifications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only work to do is to add a picture of a Ford (a Ford GT, not to detract
    from the other cases…) and retouch `CarFactory` to add the new case structure
    and its values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the UI, only one thing is required: adding the new `Ford` string to the
    selection ComboBox, and it''s ready. Now, we''ll be offered the new brand, and
    when we select it, the behavior will be as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A final version of the sample](img/image00638.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Generally speaking, there are many ways in which the DIP principle can lead
    to a solution. One of them is through a dependency container, which is a component,
    which serves or provides you with some code, injecting it when required.
  prefs: []
  type: TYPE_NORMAL
- en: Some popular dependency containers for C# are Unity and Ninject, to name just
    a couple. In the code, you instruct this component to register certain classes
    of your application; so, later on, when you need an instance of one of them, it
    is served to your code automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Other frameworks implement this principle as well, even if they're not purely
    object oriented. This is the case with AngularJS, in which, when you create a
    controller that requires access to a service, you ask for the service in the controller's
    function declaration, and the internal DI system of Angular serves a singleton
    instance of the service without the intervention of the client's code.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said, SOLID principles are beyond any specific consideration on how to
    resolve a certain coding problem and even beyond languages or paradigms. However,
    before Robert Martin defined these principles, other patterns were already in
    use related to very distinct aspects of coding and structuring applications.
  prefs: []
  type: TYPE_NORMAL
- en: In real life, a class can use one or more patterns, making it diffuse the boundary
    between the two. Additionally, you can begin to use a simple pattern and evolve
    into other more complex patterns depending on the needs of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1995, Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides (since
    then, the **Gang of Four** or **GoF** for short) published a book that has remained
    a reference point: *Design Patterns: Elements of Reusable Object-Oriented Software*.'
  prefs: []
  type: TYPE_NORMAL
- en: The authors analyze a total of 23 design patterns applicable in different coding
    scenarios in order to solve different coding problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'They divide the 23 patterns into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational**: It includes these patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural**: It is composed of these patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral**: It is made up of the following patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of Responsibility
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, all these patterns are a lot to be covered in this chapter, even
    in a superficial way, but we''re going to focus on the most frequently used ones
    and explain their advantages and programming in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design patterns](img/image00639.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The .NET framework itself contains, among others, these patterns: Singleton,
    Strategy, Factory, Builder, Decorator, and several other patterns in different
    namespaces.'
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous statistic reports on the Internet about the GoF pattern's
    usage. Obviously, it's not a question of using this or that pattern because of
    general acceptance. On the contrary, the reasons to use them are based on the
    benefits these patterns offer in order to improve the quality of an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, I''ll just review some of them to give you an idea about their possibilities
    of solving specific problems. However, an agreement seems to exist when placing
    the following eight patterns among the most used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**: Singleton and Factory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural**: Adapter, Decorator, and Façade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral**: Command, Observer, and Strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that some patterns, such as Iterator, are not included here just because
    they're already present in the vast majority of the collection's libraries (such
    as in the `System.Collections` and `System.Collections.Generic` namespaces in
    .NET). Another typical case is Abstract Factory, which is widely used in ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the most common (and reviled) of them all: Singleton.'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Singleton pattern prevents the creation of more than one instance of a class.
    It's the most popular pattern because its implementation is required in a great
    variety of situations and many different languages (also in non-compiled languages,
    such as JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, it's one of the most reviled because of general abuse of the
    pattern in many situations in which other patterns would be preferred or even
    no pattern is required at all (not to mention the difficulties that sometimes
    arise when including it in unit tests).
  prefs: []
  type: TYPE_NORMAL
- en: 'The way it should be coded requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The class should be responsible for creating the unique instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unique instance has to be accessible through a method in the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor should be private in order to avoid direct instantiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply this pattern in our sample, we can imagine a new requisite: for instance,
    imagine that the user interface requires that either from the current main window
    or from other future windows, some user information showing the name of the user
    and the date/time at which the car is selected is available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape of the new class should reflect the pattern and the values required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Observe that this class is only for reading purposes, with no meaningful functionality.
    However, having it instantiated in this manner, no possible duplication is possible.
    There will always be a unique set of user information.
  prefs: []
  type: TYPE_NORMAL
- en: The class' instance is stored in the private static `instance` variable, and
    the constructor is private in order to avoid external instantiation. Actually,
    all members except the `Instance` property are private.
  prefs: []
  type: TYPE_NORMAL
- en: The other aspect of the class that you might wonder about is the `Lazy<UserInfoSingleton>`
    type of the `instance` member, which guarantees that the instance is thread-safe
    since it won't really be instantiated until it is used by a client of the class.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wikipedia's definition of the Factory pattern states that, *a Factory is actually
    a creator of objects which have a common interface, without exposing the instantiation
    logic*.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, this is what we did in the last modification in our sample, when we
    detached the instantiation into a `CarFactory` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes, we divided the structure of the resulting objects into
    two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CarFactory` class decides the state structure of the resulting object depending
    on the brand field (remember that the state of a class is defined by the set of
    values that its properties hold in a given instant of its execution).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SportsCar` and `SportsCarWithN` are implementations of a behavior. Each one
    implements distinct behaviors with respect to the instant `Speed` value, and both
    share the same state structure (same field names and types).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our sample, there is a dependency between the fields, since `MaxSpeed` and
    `Photo` directly depend on `Brand`, so they should be resolved at construction
    time. Generally speaking, when there aren't any dependencies of this type, the
    structure can be more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Adapter pattern is one of the most versatile, and it's intended to allow
    two components that were not originally designed to work together in order to
    integrate them in the cleanest way possible.
  prefs: []
  type: TYPE_NORMAL
- en: It is, therefore, especially suitable when we have to deal with legacy code,
    in which it is quite difficult, if not impossible, to modify fragments of the
    code, but we have the requirement to include new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema shows the most common way to visually prototype the indirect
    path that the Adapter pattern implements in order to achieve this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Adapter pattern](img/image00640.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the schema, there is a client that uses a certain interface.
    When the original class needs to change or extend some behavior with minimal or
    no changes, Adapter is one of the most accepted solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have a class that lists all car brands and that we cannot modify,
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, a new class has to be used in order to get the list of the
    cars still calling to the same `adapter.GetCars()` function. This class, named
    `ListOfCarsProvider`, holds a method called `GetListOfCars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define a simple interface (`ITarget`), which defines the same method
    signature that the final class requires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to make `VendorAdapter` implement `ITarget`. The trick is
    that we make the implementation of `GetCars()` call the new list of cars in `ListOfCarsProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we preserve the functionality of the base class but allow a
    new way to obtain the list of available cars. We provide a level of indirection
    with minimal changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the list is obtained at runtime, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Adapter pattern](img/image00641.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Façade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful (and quite used) pattern in many circumstances is the Façade
    pattern. It's quite simple, and its main purpose is to unify processes dispersed
    in distinct functions of a library, giving access to them through a more simple,
    concrete set of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia collects some typical usages of this pattern, for example, when you
    want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make an external library easier to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give access to a library in a more readable way or with a more organized structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the dependencies found in the management of an outside library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The graphic schema that represents this structure is usually represented in
    this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Façade pattern](img/image00642.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means that the façade its just another layer between a set of classes that
    can either be saved inside a larger library or disaggregated along distinct files.
    In any case, the pattern allows the unification of that functionality included
    in the assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: No interface implementation is required since it's only a matter of calling
    the required methods, thus providing the business logic. You'll find the source
    code corresponding to the preceding schema in the demo called `PatternFacade`.
    The runtime doesn't have much interest in this since you can easily deduct how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator pattern is frequently used when you need to add a functionality
    to a procedure (often obtaining extra data to accompany the standard implementation)
    but you have to keep the current behavior as it is and only add the new functionality
    for certain scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, this pattern enforces the application of the Open/Closed
    principle. The main code remains intact, but the pattern allows the functionality
    to grow in a controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation is similar to the first implementation of our `SportsClassWithN`
    type of cars in our sample. The current functionality of the main class (`SportsCar`)
    is not to be changed. But some extra requirements would be needed in case the
    brand were a Mercedes (and later on, for the Ford brand as well). In this case,
    the new class inherited from the base class and added some behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Decorator pattern](img/image00643.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the user interface decides which class is to be implemented at runtime,
    and in the case of the exception, it instructs the event handler to manage that
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern admits (like most of them) slight variations in the way you implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Command pattern is one of the most used patterns in the behavioral category.
    GoF authors define the pattern in this way: *encapsulate a request as an object,
    thereby letting you parameterize clients with different requests, queue or log
    requests, and support undoable operations*.'
  prefs: []
  type: TYPE_NORMAL
- en: As always, a level of indirection is provided. Instead of immediately executing
    a call, we are allowed to queue it, which has many advantages in a bunch of scenarios,
    especially now, when more and more implementations require asynchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: The key part of this pattern is that it decouples the object that invokes an
    operation from the one that has the knowledge to perform it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example that GoF authors state as canonical is about the menu''s
    implementation in a classic user interface: in this case, you can implement several
    user interface artifacts to perform the same action (such as `MenuItem` and a
    toolbar''s button) by having both of them perform the same action, that is, making
    both implement the same concrete `Command` subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: An example already implemented in .NET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again, we can find the Command pattern implemented in a variety of places within
    .NET Framework. Perhaps one of the most evident patterns is something as simple
    as the procedure to close a window: you can do it in four different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on the icon window to close it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the window menu (not the user menu) and selecting **Close**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By pressing *Ctrl* + *F4*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By calling `this.close()` in some of the window's code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding ways provoke a command invocation, sending a `WM_CLOSE`
    message to the window.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can check the whole list of window messages that a window can handle at
    the dedicated site, Platform Invoke ([http://www.pinvoke.net/](http://www.pinvoke.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: Invoking `this.close()` in a window is a command invocation itself. The .NET
    Framework also sends one of these messages to be managed by the message's dispatcher
    window function.
  prefs: []
  type: TYPE_NORMAL
- en: You can intervene in this call thanks to the implementation of the `Window.FormClosing`
    event, which carries information about the command to be executed and allows it
    to cancel it by assigning the value of the `e.Cancel` property (`EventArgs`)to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, you can find out the reason for this event to be launched, examining
    the `e.CloseReason` property that the `e` argument holds.
  prefs: []
  type: TYPE_NORMAL
- en: These two possibilities are available thanks to the implementation of the command
    pattern in the internal mechanism used to send `WM_CLOSE` messages to a window
    inside .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll talk about the advanced aspects of .NET framework in the last chapter
    of this book, along with other techniques related to platform invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following capture resumes this window-closing scenario in the user interface
    of our initial demos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example already implemented in .NET](img/image00644.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, we find another popular pattern that's widely implemented inside the
    .NET framework for distinct scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The MSDN documentation states that this pattern *enables a subscriber to register
    with and receive notifications from a provider. It is suitable for any scenario
    that requires push-based notification*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical case of this pattern is implemented in order to link data in a model
    with the user interface, which shows it in distinct controls: DataGridViews, TextBoxes,
    and so on. When the user performs an action that implies a modification in the
    data shown in the UI—such as an update, a deletion, or a modification—the desired
    behavior is that these controls are automatically informed of the changes and
    they can update them in the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This source suggests the steps to implement this pattern in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: A provider needs to be in charge of sending notifications to the observer. It
    should be a class or a structure that implements the `IObservable<T>` interface,
    although its only requisite is implementing the `IObservable<T>.Subscribe` method.
    This is the one called by client observers that wish to receive notifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An observer that is the object that receives notifications from the provider.
    In this case, the class should implement the `IObserver<T>` interface, but it''s
    required that it implement three methods that will be called by the provider:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IObserver<T>.OnNext`, which provides new or current information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IObserver<T>.OnError`, which is in charge of informing the observer about
    any error that has occurred'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IObserver<T>.OnCompleted`, which always marks the ending of notifications'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you think about the scenario, we have the typical communication scheme between
    a sender and a receiver. So, we also need a channel to transmit the information.
    In this case, we need a mechanism that allows providers to keep track of observers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such mechanism in .NET is usually assigned to an instance of `System.Collections.Generics.List<T>`,
    which is in charge of holding references to the implementations of `IObserver<T>`.
    This is a convenient way to handle references to an unlimited number of observers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, there is another object that stores data that the provider sends to
    its subscribed observers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a real-case scenario, it might depend on the solution you''re building:
    Windows Presentation Foundation interfaces implement observable collections precisely
    with this purpose. Even other mechanisms that implement the MVC paradigm are capable
    of showing this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: A well-known case outside the OOP world is the AngularJS Framework, which makes
    every data in the model observable and linkable to the user interface, implementing
    a double binding architecture that makes any change in the model automatically
    reflect in the user interface, using a special markup (the *moustache* syntax).
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strategy pattern is officially defined as *a practice of defining a family
    of algorithms, encapsulate each one, and make them interchangeable. Strategy lets
    the algorithm vary independently from clients that use it*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mainly, there are three participants:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Strategy` (or compositor) component responsible for defining a common interface
    for all algorithms to be managed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteStrategy`, which implements the algorithm using the strategy interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AContext`, which has three roles: it gets configured with the `ConcreteStrategy`
    object, maintains a reference to the `Strategy` object, and—optionally—it can
    define an interface to allow Strategy to access its data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In code, a typical example might be when you have to use different sorting strategies
    (in any collection), but depending on other circumstances, you might like to choose
    which sorting algorithm you'd like to use, for instance, QuickSort, Shell, or
    Bubble.
  prefs: []
  type: TYPE_NORMAL
- en: You can define an object (`SortingClass`) with a method responsible for sorting,
    but depending on a value, the instance is created from another instance of the
    actual sorting method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code gives you an idea about how to use this pattern. The key
    is that `SortingClass` is called with distinct instances of the desired algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, the user interface will always call the same method for
    sorting, whatever its name, but the actual sorting mechanism will be decided at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Other software patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned, there is a total of 23 patterns linked to the original publication
    of the GoF group, but later on, other patterns belonging to the three main categories
    have appeared. Even a new category was defined: Concurrency patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the three base categories, the additions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational**: The following are the sub types of this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiton**: Focalizes the creation of classes through a single, global point
    and ensures that instances are only named instances.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Pool**: Provides a cached system to avoid the expensive acquisition
    (or release) of resources. It does this by recycling any object that is not being
    used. Many specialists consider it a generalization of the connection pool and
    thread pool patterns.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Acquisition is Initialization**: Wikipedia states that this *ensures
    that resources are properly released by tying them to the lifespan of suitable
    objects*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural**: The following are the sub types of this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extension object**: Allows the addition of a functionality to a given hierarchy
    without changing it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Front controller**: This one has to do with web application design. It''s
    a way to unify entry points to handle requests in a single node.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marker**: This is an empty interface to provide a way to link metadata to
    a class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module**: Wikipedia says that it''s *intended to group several related elements,
    such as classes, singletons, methods, globally used, into a single conceptual
    entity*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twin**: A dangerous one; according to some specialists, this provides the
    modeling of multiple inheritance for languages that don''t support this feature.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral**: The following are the sub types of this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blackboard**: This is a pattern for artificial intelligence systems that
    allow the merging of different data sources (refer to [https://en.wikipedia.org/wiki/Blackboard_system](https://en.wikipedia.org/wiki/Blackboard_system)).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Null object**: This is intended to avoid null references by providing a default
    object. In C#, we''ve seen how it is implemented using different operators (such
    as Null Coalescence and Null-Conditional Operators, which we saw in the initial
    chapters).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Servant**: This defines common operations for a set of classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specification**: Recombines business logic in a Boolean fashion. There is
    abundant documentation of the implementation of this pattern in C# and how it
    has improved along with new versions of the language ([https://en.wikipedia.org/wiki/Specification_pattern](https://en.wikipedia.org/wiki/Specification_pattern)).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency patterns**: These are specifically designed to deal with multithreading
    scenarios. The following table is inspired by the actual documentation of this
    subject available on Wikipedia:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Active object | Decouples method execution from the method invocation that
    resides in its own thread of control. The goal is to introduce concurrency using
    asynchronous method invocation and a scheduler to handle requests. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Balking | Only executes an action on an object when the object is in a particular
    state. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Binding properties | Combines multiple observers to force properties in different
    objects to be synchronized or coordinated in some way. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Block chain | A decentralized way to store data and agree on the ways to
    process it in a Merkle tree, optionally using a digital signature for any individual
    contributions. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Double-checked locking | Reduces the overhead of acquiring a lock by first
    testing the locking criterion (the lock hint) in an unsafe manner; only if that
    succeeds does the actual locking logic proceed.Can be unsafe when implemented
    in some language/hardware combinations. It can, therefore, be considered an anti-pattern
    sometimes. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Event-based asynchronous | Addresses problems with the asynchronous pattern
    that occurs in multithreaded programs. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Guarded suspension | Manages operations that require both a lock to be acquired
    and a precondition to be satisfied before the operation can be executed. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Join | Provides a way to write concurrent, parallel, and distributed programs
    by passing messages. Compared to the use of threads and locks, this is a high-level
    programming model. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Lock | A thread puts a "lock" on a resource, preventing other threads from
    accessing or modifying it. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Messaging Design Pattern (MDP) | Allows the interchange of information (that
    is, messages) between components and applications. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Monitor object | An object whose methods are subject to mutual exclusion,
    thus preventing multiple objects from erroneously trying to use it at the same
    time. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Reactor | Provides an asynchronous interface to resources that must be handled
    synchronously. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Read-write lock | Allows concurrent read access to an object, but requires
    exclusive access for write operations. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Scheduler | Explicitly controls when threads may execute single-threaded
    code. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Thread pool | A number of threads are created to perform a number of tasks,
    which are usually organized in a queue. Typically, there are many more tasks than
    threads. Can be considered a special case of the object pool pattern. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Thread-specific storage | Static or "global" memory that is local to a thread.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Also, remember that often, there's no need to explicitly implement a pattern
    when the framework you use already supports it (such as how it happens in the
    .NET Framework), and chances are that at the time of implementing a real solution,
    not one but several of these patterns might be required in order to code things
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Other patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we said that there are many different patterns,
    guides, and sets of good practices published by different specialists, either
    from academic environments or from corporations.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be also applied to distinct programming contexts, and for different
    programming paradigms: the integration of applications, data management, user
    interfaces, application testing (unit or behavioral), and so on. They are usually
    called Domain Specific patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, as technology evolves, so do the patterns. New patterns appear,
    and some others become less used, just because the technology or architecture
    they apply to also falls into disuse.
  prefs: []
  type: TYPE_NORMAL
- en: Some others, in turn, get revitalized as the technology grows, such as in the
    case of *Design and Implementation Guidelines for Web Clients*, which you can
    find at [https://msdn.microsoft.com/en-us/library/ff650462.aspx](https://msdn.microsoft.com/en-us/library/ff650462.aspx).
    However, if we consider other patterns very useful at the moment, such as Data
    patterns ([https://msdn.microsoft.com/en-us/library/ff648420.aspx](https://msdn.microsoft.com/en-us/library/ff648420.aspx)),
    chances are that you'll find them a little outdated just because it was published
    in 2003, and things have changed a lot since then, not to mention the appearance
    of other models and technologies, such as the Big Data revolution.
  prefs: []
  type: TYPE_NORMAL
- en: So, keep in mind the big principles first, and when you have to apply any of
    them for the sake of your application, take a look at the available patterns (classic
    or new) because they might offer you a trusted, proved solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through software guides and patterns. We started with
    the SOLID principles proposed by Robert Martin a few years ago, which are now
    gaining momentum among the programmers community, and we can see them implemented
    in the vast majority of frameworks in use today.
  prefs: []
  type: TYPE_NORMAL
- en: We used a simple application, and as the requirements evolved, we applied different
    principles or patterns to solve the problems.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we studied the eight most used GoF patterns (according to the statistics),
    revising their definitions and purposes in order to finish with the current list
    of available patterns created and published after the GoF group published their
    book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll deal with security issues, including the new proposals
    widely adopted in the industry, such as the **OAuth** (**Open Authorization**)
    protocol.
  prefs: []
  type: TYPE_NORMAL
