- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are a fundamental part of nearly every application, allowing us
    to manage and organize groups of related objects. In this chapter, we’ll explore
    the power of collections in the context of the MVVM design pattern, offering you
    the tools and knowledge to efficiently work with data in your .NET MAUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, our focus has primarily been on binding single values, such as
    titles, ratings, and commands. However, with the introduction of collections,
    we can take our applications to the next level. Collections empower us to represent
    groups of items, whether it be a collection of recipes, lists of ingredients,
    or arrays of user ratings. By harnessing the capabilities of collections, we can
    create dynamic, data-driven UIs that provide enhanced user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is structured into three key sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `BindableLayout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ICollectionChanged` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `CollectionView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a strong understanding of working
    with collections in .NET MAUI, significantly expanding your capabilities in building
    rich, data-centric applications such as our *Recipes!* app. Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be enhancing the functionality of the *Recipes!*
    app. The code base for this chapter and all the assets, including the additional
    classes and code required to cover the topics in this chapter effectively, can
    be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06).
    The starting point for this chapter is provided in the `Start` folder, which includes
    the necessary classes and code that have been added specifically for this chapter.
    The code in the `Start` folder serves as the starting point to follow along with
    this chapter’s content, building upon the foundation we established in the previous
    chapters. The completed code, which includes all the code we have written throughout
    this chapter, can be found in the `Finish` folder for reference and comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Using BindableLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BindableLayout` class is a static class that provides *attached properties*
    for binding collections to layout containers. An attached property is a concept
    that allows you to attach additional properties to existing elements or controls.
    These properties are not defined within the element itself but are provided by
    an external class. They enable you to extend the behavior and functionality of
    elements without modifying their underlying code. `Grid.Row` is probably one of
    the most commonly used attached properties in .NET MAUI. It can be applied to
    any UI element, allowing you to define the row position within a `Grid` layout.
    It is not a property of the UI element itself; instead, it is an attached property
    that enhances the flexibility and power of the `Grid` layout. As such, `BindableLayout`
    provides a set of attached properties that can be used to bind collections of
    data to layout containers, such as `VerticalStackLayout` or `Grid`. You can leverage
    its attached properties to effortlessly bind and display dynamic collections of
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `BindableLayout` class’s attached properties can be added to any
    layout that derives from the `Layout` class, it is commonly used with layouts
    such as `VerticalStackLayout` and `HorizontalStackLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`BindableLayout` is a lightweight and straightforward solution for displaying
    collections of data. It works great for scenarios with a limited number of items,
    offering simplicity and ease of use.'
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to consider that `BindableLayout` generates UI elements
    for each item in the collection without built-in features such as virtualization
    or view recycling. This means that for large collections with many items, there
    may be performance implications and increased memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how we can use `BindableLayout` to show a collection of
    data inside a `VerticalStackLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: What to show and how to show it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two essential attached properties of `BindableLayout` are `ItemsSource` and
    `ItemTemplate`. These two properties play a crucial role in defining what collection
    of data needs to be shown and how each data item should be visualized. The `ItemsSource`
    property is used to bind a collection of data, while the `ItemTemplate` property
    is used to define the `DataTemplate` for each item in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Since a recipe is nothing without its list of ingredients, in the first example,
    we are going to display the list of ingredients on `RecipeDetailPage`. However,
    before we dive into how to effectively use `BindableLayout`, let’s first discuss
    `RecipeIngredientViewModel`, which is used to hold the information of ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: Defining ingredients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `RecipeIngredientViewModel` class represents an ingredient within a recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'It contains the name of the ingredient and information about the required quantity
    of the ingredient for a specific number of servings. The purpose of the `DisplayAmount`
    property is to dynamically adjust and display the appropriate quantity of ingredients
    for the desired number of servings. It allows the user to see the adjusted amount
    that aligns with their selected serving size, providing accurate ingredient measurements
    for their recipe preparation. Let’s have a look at its `UpdateServings` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method updates the `DisplayAmount` property based on the desired number
    of servings, allowing the user to see the appropriate quantity of the ingredient
    for their selected serving size. As the setter of the `DisplayAmount` property
    calls the `PropertyChanged` event when its value changes, we can bind this property
    to a UI element in our view to dynamically display the adjusted ingredient amount
    based on the selected number of servings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend `IngredientsListViewModel` with an additional property: `Ingredients`.
    This property is a list of `RecipeIngredientViewModel` objects that, for demo
    purposes, is assigned a hard-coded list of ingredients needed for making a Caesar
    salad.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `NumberOfServings` property is updated. The following code block
    shows how the `UpdateServings` method on each of the ingredients is called when
    the value of the `NumberOfServings` property is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When updating `NumberOfServings`, the `DisplayAmount` property of each ingredient
    is updated as well, by calling the `UpdateServings` method.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this in place, we can finally move over to XAML and see how we can
    bind this collection of `RecipeIngredientViewModels` to a `VerticalStackLayout`
    while using the attached properties of `BindableLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Showing ingredients on the screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following steps, we’ll go through the process of setting up the XAML
    code to display the ingredients in a visually appealing manner. Note that everything
    we are about to do in XAML can also be done in code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `RecipeDetailPage`, right below the `HorizontalStackLayout`, which holds
    the `Stepper` property that controls the number of servings, we can add a new
    `VerticalStackLayout`. As shown in the following code block, we can use the `ItemsSource`
    property of the `BindableLayout` class to bind to the list of ingredients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to define the UI elements that need to be rendered for each of
    the items in the bound collection. We can define this using the `ItemTemplate`
    property. This property needs a value of the `DataTemplate` class. It can be defined
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that on a `DataTemplate`, we can define `x:DataType` if we want to leverage
    compiled bindings, as we saw in [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069),
    *Data Binding in .**NET MAUI*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s very important to realize that the `BindingContext` of a `DataTemplate`
    is set to an individual item of the bound collection. Because the template is
    repeated for each item in the collection, UI elements named with `x:Name` in `DataTemplate`
    are inaccessible in the code behind. Their name is confined to that template’s
    scope. However, the name can still be used for element binding within the same
    `DataTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can define a `DataTemplate` for the
    ingredients. This is how we define how each of the ingredients needs to be visualized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each ingredient, we want to render a `HorizontalStackLayout` containing
    a label showing the ingredient’s name, a label showing the `DisplayAmount`, and
    finally, a label showing the `Measurement`. *Figure 6**.1* shows what it looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: The Ingredients list](img/B20941_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The Ingredients list'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `DisplayAmount` is bound `OneWay`, meaning that when the `PropertyChanged`
    event for this property is triggered, the label’s `Text` property is updated accordingly.
    All the other properties can be bound `OneTime` as their values won’t change once
    they’re displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In terms of performance, it’s worth noting that `OneTime` binding mode is generally
    more efficient than `OneWay` data binding. This is especially important when binding
    collections of data! `OneTime` binding establishes the binding once and does not
    track subsequent changes to the source property. Therefore, it’s advisable to
    use `OneTime` binding wherever possible to optimize performance and reduce unnecessary
    UI updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `DataTemplate` can also be defined in a resource dictionary. This allows
    `DataTemplate`s to be reused, which can be especially convenient when showing
    the same kind of data in different parts of your app. By defining the template
    once in `Application.Resources` (in `App.xaml`), for example, it can be reused
    throughout the app. Then, we can use the `StaticResource` markup extension to
    bind a particular `DataTemplate` to the `BindableLayout` `ItemTemplate` property
    using the key that was defined in the resource dictionary. The following code
    block shows how to add a `DataTemplate` to the page’s resources and use it later
    on as the `ItemTemplate` of the `VerticalStackLayout` showing the ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, a `DataTemplate` is defined within the `ContentPage.Resources`
    section and is assigned the `"recipeIngredientTemplate"` key. Later, this template
    is used in the `VerticalStackLayout` by us referencing it through the `StaticResource`
    markup extension, using the `"``recipeIngredientTemplate"` key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI, if you bind a collection without assigning a specific `DataTemplate`,
    the framework automatically invokes the `ToString` method of each object in the
    collection. The returned string value is what will be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this in place, our app now shows a list of ingredients on the recipe’s
    detail page, where each ingredient is rendered using the defined `ItemTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: But what if not all items in a particular collection should be rendered the
    same way? Let’s see how we can choose a `DataTemplate` dynamically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically choosing a DataTemplate at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While ingredients are essential to a recipe app, not much can be done with the
    ingredients without a comprehensive set of cooking instructions. So, let’s bring
    these instructions to life within our app! In addition to the essential steps,
    a list of instructions may also include valuable cooking tips and additional information
    to enhance the cooking experience. Let’s explore how we can incorporate these
    cooking instructions, along with any accompanying notes, into our *Recipes!* app.
  prefs: []
  type: TYPE_NORMAL
- en: Defining cooking instructions and notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our app, we use `InstructionViewModel` and `NoteViewModel` for cooking instructions
    and notes, respectively. `InstructionViewModel` has `Index` and `Description`
    properties, while `NoteViewModel` has just a `Note` property. Both are grouped
    under a common parent, `InstructionBaseViewModel`, and stored in a list called
    `Instructions` in `RecipeDetailViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, this list is initialized with some cooking instructions and a tip for
    creating a Caesar salad.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to show this list, which contains both instructions and notes, on
    the screen, we would need a mechanism that would allow us to use a different `ItemTemplate`,
    depending on the type. Let’s see how a `DataTemplateSelector` can achieve this!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DataTemplateSelector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With a `DataTemplateSelector`, we can write code that determines what `DataTemplate`
    to use at runtime. Writing a `DataTemplateSelector` is pretty straightforward.
    Let’s have a look at how we can build one:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `TemplateSelectors` by right-clicking the **Recipes.Mobile** project
    and selecting **Add** | **New Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click this newly added folder, select `InstructionsDataTemplateSelector`
    as the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our class to function as a `DataTemplateSelector`, it needs to inherit
    from `Microsoft.Maui.Controls.DataTemplateSelector`, as shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inheriting from the `DataTemplateSelector` class requires overriding the abstract
    `OnSelectTemplate` method. This method is invoked at runtime to select the appropriate
    `DataTemplate` and takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`item` (of type `object`) is the object we want to display, such as a `NoteViewModel`
    or `InstructionViewModel` item in our app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container` (of type `BindableObject`) refers to the layout element that holds
    the collection, such as `VerticalStackLayout` in our example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these parameters, the `OnSelectTemplate` method in a `DataTemplateSelector`
    assists you in selecting the appropriate `DataTemplate` for a given item. In our
    specific scenario, the method will determine the template based solely on the
    type of the passed-in item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce two properties to `InstructionsDataTemplateSelector`. These
    two properties, `NoteTemplate` and `InstructionTemplate`, dictate which `DataTemplate`
    the `DataTemplateSelector` should return based on the type of the passed-in item
    parameter. Specifically, if it is a `NoteViewModel`, the `OnSelectTemplate` method
    should return `NoteTemplate`. Conversely, if it’s an `InstructionViewModel`, `InstructionTemplate`
    will be returned. Let’s explore how to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following properties to `InstructionsDataTemplateSelector`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code block shows how we can implement the `OnSelectTemplate`
    method so that it checks the type of the given item and returns the appropriate
    `DataTemplate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the given item isn’t an `InstructionViewModel` or `NoteViewModel` item, `null`
    is returned. As a result, the value returned by the object’s `ToString` method
    will be rendered, which is the same behavior when not providing a `DataTemplateSelector`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That’s it for `InstructionsDataTemplateSelector`. Let’s see how we can use this
    `DataTemplateSelector` to show both instructions and notes in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Showing instructions and notes on the screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the data is in place as well as the `DataTemplateSelector` that we
    want to use, we need to do a few things in XAML to display the recipe’s instructions
    and notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by thinking about how we want to represent a `InstructionViewModel`
    in the app. Here’s a template that we could add to the `RecipeDetailPage’s` resources
    for that data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `DataTemplate` for an `InstructionViewModel` defines how we want to visualize
    this type of item: showing the `Index` property with the `Description` below it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we’ve given the `DataTemplate` a key (`instructionTemplate`) that
    we can use later on to reference this specific template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add a `DataTemplate` for the `NoteViewModel` items as well. The following
    code block shows a `DataTemplate` for visualizing such items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By using this `DataTemplate`, we can visualize notes by showing an icon – for
    which we use the `MaterialIconsRegular` font – followed by the note itself. Both
    are in a specific color so that there is a clear distinction between notes and
    instructions. As before, we’ve given the `DataTemplate` a specific key (`noteTemplate`)
    so that we can reference it later on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s add an `InstructionsDataTemplateSelector` to `RecipeDetailPage`.
    Start by adding said `DataTemplateSelector`’s namespace as an XML namespace to
    the page, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is in place, we can add an instance of the `InstructionsDataTemplateSelector`
    class to the page’s `Resources`, as shown in the following snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `StaticResource` markup extension is used to reference the two `DataTemplate`s
    that we created earlier to assign them to the respective properties of this `InstructionsDataTemplateSelector`.
    Just like we did with the individual `DataTemplate`, we’ve given this instance
    of the `InstructionsDataTemplateSelector` a key (`instructionDataTemplateSelector`)
    that we can use later on to reference it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To display the list of instructions, we can add a `VerticalStackLayout` near
    the bottom of `RecipeDetailPage`. The following code snippet demonstrates this
    setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.2: Showing instructions and notes](img/B20941_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Showing instructions and notes'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve explored how to leverage `DataTemplate`s and a `DataTemplateSelector`
    to visualize instructions and notes within our *Recipes!* app. By defining separate
    `DataTemplate`s and using a `DataTemplateSelector`, we can dynamically choose
    the appropriate template for each item in the collection, providing a customized
    and intuitive display of cooking instructions and additional notes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully implemented the visualization of instructions
    and notes, let’s move on to handling empty collections.
  prefs: []
  type: TYPE_NORMAL
- en: Handling empty collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the `ItemsSource` and `ItemTemplate` properties, `BindableLayout` also
    has `EmptyView` and `EmptyViewTemplate` properties. These properties allow us
    to define what to show if the provided `ItemsSource` is empty or null.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EmptyView` property can be a string value or a `View`. So, in its simplest
    form, we could add the following to a `VerticalStackLayout` to show the shopping
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`"Nothing to see here"` is shown on the screen when the bound `ItemSource`
    contains no items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, if we want to have more control over the appearance of what is shown when
    the collection is empty, we could also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: public ObservableCollection<RecipeIngredientViewModel>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ShoppingList { get; } = new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public IRelayCommand AddToShoppingListCommand { get; }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public IRelayCommand RemoveFromShoppingListCommand
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{ get; }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private void AddToShoppingList(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RecipeIngredientViewModel viewModel)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (ShoppingList.Contains(viewModel))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ShoppingList.Add(viewModel);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private void RemoveFromShoppingList
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (RecipeIngredientViewModel viewModel)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (ShoppingList.Contains(viewModel))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ShoppingList.Remove(viewModel);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public RecipeDetailViewModel()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AddToShoppingListCommand = new RelayCommand
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <RecipeIngredientViewModel>(AddToShoppingList);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RemoveFromShoppingListCommand = new RelayCommand
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <RecipeIngredientViewModel>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (RemoveFromShoppingList);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <VerticalStackLayout Padding="10">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Label ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Text="Ingredients list" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <VerticalStackLayout Margin="10,0" Padding="10">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Label
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FontAttributes="Italic,Bold"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FontSize="16" Text="Shopping list" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <VerticalStackLayout
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Margin="0,10" Spacing="10"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BindableLayout.ItemsSource="{Binding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ShoppingList, Mode=OneTime}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BindableLayout.EmptyView="Nothing added">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </VerticalStackLayout>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </VerticalStackLayout>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </VerticalStackLayout>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <HorizontalStackLayout Spacing="5">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Command="{Binding AddToShoppingListCommand,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Source={RelativeSource AncestorType={x:Type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: vms:RecipeDetailViewModel}}}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CommandParameter="{Binding}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FontFamily="MaterialIconsRegular"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Text="&#xe854;" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Label
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FontAttributes="Bold"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FontSize="16" VerticalOptions="Center"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Text="{Binding IngredientName,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: StringFormat='{0}:'}" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </HorizontalStackLayout>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <Button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Command="{Binding RemoveFromShoppingListCommand,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Source={RelativeSource AncestorType={x:Type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: vms:RecipeDetailViewModel}}}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CommandParameter="{Binding}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FontFamily="MaterialIconsRegular"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Button has a different icon and has its Command bound to RemoveFromShoppingListCommand,
    allowing the user to remove an ingredient again from the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <ShellContent AppShell.xaml file, as shown earlier, and don’t worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the recipes in `RecipesOverviewPage`, we can use `CollectionView`.
    The `ItemsSource` property of `CollectionView` is bound to the `Recipes` property
    of the `RecipesOverviewViewModel` class, which serves as the page’s `BindingContext`.
    Similar to `BindableLayout`, we define the `ItemTemplate` property to specify
    how each item in the collection should be rendered. The following code snippet
    demonstrates this setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The usage of `CollectionView` should feel familiar if you have worked with `BindableLayout`
    before. You can copy the `DataTemplate` class from `BindableLayout` and it will
    show up the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s leverage one of the more powerful features of `CollectionView`:
    data grouping. Let’s explore how to effectively display grouped data.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying grouped data
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping data in a collection is a powerful way to organize and present information
    in a meaningful and structured manner. By grouping related items, you can provide
    intuitive navigation and enhance the user experience. `CollectionView` allows
    us to easily display grouped data and provides both `GroupHeaderTemplate` and
    `GroupFooterTemplate` properties. These templates allow us to define what’s being
    displayed above and below a group of items. *Figure 6**.4* illustrates how a list
    of grouped items is rendered with group headers and footers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Group headers and footers](img/B20941_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Group headers and footers'
  prefs: []
  type: TYPE_NORMAL
- en: '`RecipeRatingDetailPage`, which can be accessed by tapping on the rating information
    on `RecipeDetailPage`, should show all the ratings of a recipe grouped by the
    number of stars. Let’s walk through the steps needed to set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: While `RecipeRatingsDetailViewModel` already contains a list of all the reviews
    of a recipe, it doesn’t group the data yet. First, let’s create a class for holding
    a group of ratings. In the `RatingGroup` as its name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `RatingGroup` class inherits from `List<UserReviewModel>` and has an additional
    property called `Key`. Here’s what it looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class serves as a specialized list for holding `UserReviewViewModel` objects.
    It inherits from `List<UserReviewViewModel>`, meaning it can do anything a regular
    list can do, such as holding multiple `UserReviewViewModel` items. In addition
    to that, the class includes an extra property called `Key`. This property is used
    to group the user reviews by some criteria, such as a rating or a category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.  Next, add a `GroupedReviews` property to `RecipeRatingsDetailViewModel`.
    This property is of type `List<RatingGroup>`. It holds groups of reviews that
    are organized based on the number of stars. Each `RatingGroup` in the list will
    contain reviews that share the same number of stars, which is represented by the
    `Key` property. The following snippet shows this newly added property and how
    it gets initialized in the constructor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the constructor, we have grouped all the reviews by their rating, rounded
    to 0.5\. We use this grouping to create a list of `RatingGroups` items that we
    assign to the `GroupedReviews` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  Now, we can bind the `GroupedReviews` property to the `CollectionView`
    on `RecipeRatingDetailPage`. When binding a grouped collection, we also need to
    make sure the `IsGrouped` property of `CollectionView` is set to true, as the
    following snippet shows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 5.  As we did previously, we should be defining an `ItemTemplate` to declare
    how each item should be rendered. Once that is in place, `CollectionView` renders
    all the items but there isn’t a clear distinction between the different groups
    yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, let''s add `GroupHeaderTemplate` and `GroupFooterTemplate` to clearly distinguish
    the different groups. The following code block demonstrates how this can be done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BindingContext` of these templates is an instance of `RatingGroup`, allowing
    us to bind to its properties, such as `Key` and `Count`. With this, we can make
    the groupings visually clear to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Grouping data in `CollectionView` allows for a more organized and structured
    presentation of information, as shown in *Figure 6**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Grouping data](img/B20941_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Grouping data'
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging the `GroupHeaderTemplate` and `GroupFooterTemplate` properties,
    you can enhance the user experience and provide intuitive navigation within your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can `CollectionView` render your data, it also offers various interactive
    features to engage users with your app. From selecting items to incrementally
    loading data and other common functionalities, let’s discover how to get the most
    out of this powerful control, by keeping MVVM principles in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting items
  prefs: []
  type: TYPE_NORMAL
- en: When working with `CollectionView`, you have various options for selecting items
    and managing the selection state. By binding the `SelectedItem` property, you
    can easily track the currently selected item in your ViewModel. Additionally,
    you can bind the `SelectedItems` property to a collection in your ViewModel to
    track multiple selected items. The `SelectionMode` property allows you to define
    whether single or multiple items can be selected or whether or not selecting items
    is disabled. You can use the `SelectionChangedCommand` property to bind a command
    in your ViewModel that will be executed when the selection changes or handle the
    `SelectionChanged` event, allowing you to implement flexible and interactive item
    selection behavior in your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can allow the user to select one or more reviews, allowing
    the user to report inappropriate reviews, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property to `RecipeRatingsDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This property will hold the items that the user has selected on the `CollectionView`.
    Note that this `ObservableCollection` uses `object` as its type parameter, rather
    than a more specific type. Though it’s not explicitly documented, using `object`
    appears to be the only way to successfully bind multiple selections in `CollectionView`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Now, let’s add a command called `ReportReviewsCommand` that can only be
    executed when one or more reviews are selected, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  As the `SelectedReviews` property is an `ObservableCollection`, we can
    listen to the `CollectionChangedEvent` and call the `ReportReviewsCommand`’s `NotifyCanExecuteChanged`
    method. That way the `ReportReviewsCommand`’s `CanExecute` method gets re-evaluated.
    The following snippet shows how to implement this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '4.  Update the `CollectionView` on `RecipeRatingDetailPage` so that its `SelectedItems`
    property is bound to the `SelectedReviews` property. We also need to set the appropriate
    `SelectionMode`, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By adding this code, the items the user selects on the UI will be added to the
    `SelectedReviews` list, while selected items that the user de-selects will be
    removed from it. The `ReportReviews` method, we can easily access the `SelectedReviews`
    property to see what items have been selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final example, let’s look at how we can bind the `SelectedItem` and `SelectionChangedCommand`
    properties to trigger something such as navigation. Let’s take a look at how to
    implement this on `RecipesOverviewPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `RecipesOverviewPage`, update the `CollectionView` and bind its `SelectedItem`
    and `SelectionChangedCommand` properties, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SelectedItem` property is bound `TwoWay` to the `SelectedRecipe` property
    and `SelectionChangedCommand` is bound to `NavigateToSelectedDetailCommand`. Both
    properties will be added shortly. Also, the `SelectionMode` property is set to
    `"Single"`, allowing the user to select one item in the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Now, let’s add the two properties mentioned earlier to `RecipeOverviewViewModel`.
    Here’s what they look like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  The following snippet shows how the command is instantiated in the constructor
    of the ViewModel:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because this command is bound to the `SelectionChangedCommand` of the `CollectionView`,
    it will get triggered when an item is selected or de-selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  The following code block shows the `NavigateToSelectedDetail` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the user selects an item in `CollectionView`, the `SelectedRecipe` property
    on the ViewModel will be updated. Next, `NavigateToSelectedDetailCommand` will
    be executed, which will call the `NavigateToSelectedDetail` method. In this method,
    we can access the `SelectedRecipe` property and act upon it, such as navigating
    to its detail page, for example. Finally, we set the `SelectedRecipe` property
    to null. As this property is bound `TwoWay`, the item will get de-selected in
    `CollectionView`. As a result, if we navigate back from `RecipeDetailPage`, no
    item will be selected on the overview and then we can immediately select another
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s have a look at how we can load data incrementally while the user
    scrolls through a large dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Incrementally loading data
  prefs: []
  type: TYPE_NORMAL
- en: 'As the user scrolls through large datasets in `CollectionView`, providing a
    seamless and interactive user experience is crucial. The `RemainingItemsThreshold`
    and `RemainingItemsThresholdReachedCommand` properties allow you to effortlessly
    load additional items. By specifying a threshold value for the remaining items,
    new data is dynamically fetched and seamlessly loaded, ensuring a smooth and continuous
    experience. Let’s explore how to implement this interactive functionality in just
    a few simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to `RecipesOverviewViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method adds items to the `Recipes` `ObservableCollection` class as it has
    fewer items than what’s defined in the `TotalNumberOfRecipes` property. It’s a
    pretty dumb implementation, but it should get the point across. In a real-life
    scenario, we would fetch this data from an API or something. We’ll look at this
    in [*Chapter 10*](B20941_10.xhtml#_idTextAnchor165), *Working with* *Remote Data*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Next, let’s add a command called `TryLoadMoreItemsCommand`. This is the
    command that should be invoked when we want to load more items. We want to instantiate
    it in the constructor of `RecipesOverviewViewModel`, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Now, we can update the `CollectionView` and add both `RemainingItemsThreshold`
    and `RemainingItemsThresholdReachedCommand`, as shown in the following code block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code in place, `TryLoadMoreItemsCommand` will be invoked as soon as
    the user scrolls and the number of remaining items reaches the specified threshold
    of five or less. The `TryLoadMoreItems` method will then add items to the `Recipes`
    `ObservableCollection`. Because this method implements the `ICollectionChanged`
    interface, the added items will be automatically added to `CollectionView`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Incrementally loading data is a good idea when dealing with very large datasets
    and `CollectionView` makes it extremely convenient to implement using the `RemainingItemsThreshold`
    and `RemainingItemsThresholdReachedCommand` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Other common interactions
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the features we’ve discussed, it’s worth mentioning that common
    interactions such as pull-to-refresh and item context menus are also available
    in .NET MAUI. These interactions allow users to refresh the data that’s displayed
    in the collection and access additional actions or information specific to each
    item. While they are used on collections very often, it’s important to note that
    these features are not exclusive to `CollectionView` and can be implemented anywhere
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: '`SwipeView` is a versatile control that allows you to add swipe gestures to
    individual items in a collection. It enables users to perform actions by swiping
    horizontally or vertically on an item, such as deleting an item or revealing additional
    options.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RefreshView`, on the other hand, is a control that provides a standard pull-to-refresh
    functionality. It allows users to refresh the data that’s displayed in a collection
    by pulling down on the screen. When triggered, `RefreshView` executes a command
    to update the collection with fresh data.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the powerful features and capabilities of collections
    in .NET MAUI. We learned how to effectively bind collections to UI elements using
    `BindableLayout` and `CollectionView`, enabling dynamic and efficient rendering
    of data. We covered topics such as data templating, item selection, grouping,
    and incremental loading. `CollectionView` proved to be a versatile control, offering
    advanced functionality such as item virtualization and seamless data loading.
  prefs: []
  type: TYPE_NORMAL
- en: As we continue our journey in building robust and scalable apps, in the next
    chapter, we will delve into the important concepts of dependency injection, services,
    and messaging. These fundamental aspects of app development will empower us to
    create modular and maintainable code, enhance code reusability, and enable effective
    communication between different parts of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BindableLayout`: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollectionView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CarouselView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SwipeView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RefreshView`: [https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview](https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Part 2: Building a .NET MAUI App Using MVVM'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we focus on equipping you with the essential tools and techniques
    needed to craft a genuine .NET MAUI application that leverages the MVVM pattern.
    We will dive into the core mechanisms such as dependency injection, services,
    and messaging, which form the backbone of any robust app. We will help you master
    MVVM-based navigation in .NET MAUI with or without Shell, refine user interactions
    with precise input and validation, and connect seamlessly with remote data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20941_07.xhtml#_idTextAnchor119), *Dependency Injection, Services,
    and Messaging*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B20941_08.xhtml#_idTextAnchor132), *.NET MAUI Shell and Navigation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B20941_09.xhtml#_idTextAnchor148), *Handling User Input and Validation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B20941_10.xhtml#_idTextAnchor165), *Working with Remote Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
