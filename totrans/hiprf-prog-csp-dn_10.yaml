- en: '*Chapter 8*: File and Stream I/O'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to improve directory, file, and streaming
    performance. You will also learn how to efficiently enumerate directories, process
    small and large files, perform asynchronous operations, use local storage, handle
    exceptions, and work with memory efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the various Windows file path formats**: This section provides
    information on the different file path formats that you will encounter on the
    Windows operating system. Also covered is the 256-character file path limit on
    Windows, and techniques that cover how to remove this limitation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Considering improved I/O performance**: In this section, we will be benchmarking
    some code to see which method of coding performs fastest when it comes to calculating
    directory sizes and moving files. Plus, we will look at how to read and write
    files asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling I/O operation exceptions**: We will cover how to handle I/O exceptions
    in this section. You will learn how to handle exceptions so that performance is
    not negatively impacted. You will also learn when to recover from exceptions,
    as well as when to exit them to preserve data integrity when exceptions cannot
    be graciously recovered from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performing memory tasks efficiently**: In this section, you will learn how
    to efficiently use memory when processing strings and dealing with objects. We
    will also discuss how to defragment the Large Object Heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding local storage tasks**: In this section, we will discuss the
    various options for local file storage, some problems that can arise in networked
    environments, and when users install software just for themselves when multiple
    people use the same software on the same computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the different Windows file path formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overcome the 256-character file path limit on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how hardware affects the performance of your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the best option for calculating directory sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the best option for moving files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write files asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle I/O and other exceptions effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the performance of memory-based tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what local file storage options are available to you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the problems that can occur in networked environments, such as when
    applications that should be installed for all users on a single machine are installed
    only for the current user, and how to effectively resolve them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for this book: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the various Windows file path formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably already know that .NET provides managed code that hides interaction
    with the Windows APIs from the end user. So, it will come as no surprise that
    the System.IO namespace passes file path information to the Windows APIs to handle.
    The Windows APIs perform the required task, and then control is handed back to
    .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'File paths in .NET can be absolute, relative, UNC paths, or DOS device paths.
    Non-Windows files and directories are case-sensitive. But on Windows, files and
    directories are case-insensitive. The following table provides examples of the
    different Windows file path formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.1 – Windows path format examples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Table_8.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.1 – Windows path format examples
  prefs: []
  type: TYPE_NORMAL
- en: By default, Windows can only accept paths with a length of 256\. As a programmer,
    you have probably encountered the `Destination Path Too Long` warning when backing
    up your files or moving them. A situation that can often lead to this warning
    is developing web projects using node modules via NPM. NPM packages can have particularly
    long file paths that exceed 256 characters in length, which will lead to this
    exception being raised.
  prefs: []
  type: TYPE_NORMAL
- en: You can remove the maximum path length limitation by either editing the registry
    or by editing the group policy. First, you will learn how to remove this limitation
    using the registry. Then, you will learn how to remove this limitation using the
    group policy.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the maximum path length limitation using the registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Always exercise caution when making changes to the registry.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to remove the file path limit of 260 characters
    by modifying the registry.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of performance, the `MAX_PATH` issue on Windows can waste your time.
    Copying many gigabytes of data can be very time-consuming. This can be made worse
    if a file copy fails after 28 minutes of you moving files between locations on
    different disks.
  prefs: []
  type: TYPE_NORMAL
- en: So, with file management applications, for example, if a user is going to copy
    files between two locations that will raise a file length exception, it is best
    to warn the user and provide them with the option to restructure their files before
    they perform the copy, or offer to update the registry for them. This way, you
    can save the end user a lot of wasted time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually remove the `MAX_PATH` file path limit, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `regedit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have opened the registry editor, navigate to the following key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Identify the `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the key does not exist, then add it as a `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may not be necessary, but it is a good idea to restart your computer for
    the changes to be picked up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be able to process files with paths with over 260 characters.
    If you experience permission issues after performing the preceding steps, then
    open the registry editor as an administrator. If you still have problems, then
    see your system administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to do this using the local group policy editor.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the maximum path length limitation using the group policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also remove the file path limit of 260 characters by modifying the
    computer’s policy. You can do this with the `gpedit.msc` tool. This may be unavailable
    on some versions of Windows, or may not be available because of enterprise group
    policies that have been put in place. If you find that to be the case, then see
    your system administrator. Otherwise, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `gpedit.msc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Computer Configuration**, navigate to **Administrative Templates** |
    **System** | **Filesystem**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will be a setting called `Not configured` by default. Edit this setting
    by setting it to `Enabled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may not be necessary, but it is a good idea to restart your computer for
    the changes to be picked up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’ve learned how to overcome the limiting path situation on Windows
    by editing the registry and local group policy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is really important to remove the file path limitation. There have been instances
    where critical backups on client and server computers have failed due to this
    limitation being in place. It can also break your development project when you’re
    working with third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at some considerations that will help boost I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Considering improved I/O performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several common I/O tasks that we do often, such as traversing directories
    searching for files, adding, renaming, moving and deleting directories, adding,
    renaming, moving, and deleting files, password protecting files and directories,
    encrypting and decrypting files and directories, and compressing files and directories.
    We also transmit and load files synchronously, asynchronously, and via streams
    such as file streams and memory streams. Then, there are all the NoSQL and SQL
    data operations, all of which will be happening frequently on corporate networks,
    and streaming data and audio/visual content at work and home.
  prefs: []
  type: TYPE_NORMAL
- en: When working with I/O, it is quite easy to completely slow a system down to
    the point that it becomes unusable while file reading and file writing is taking
    place. So, if you are going to be performing heavy I/O, you must keep the system
    where the work is being carried out fully operational and responsive for the end
    user and other processes.
  prefs: []
  type: TYPE_NORMAL
- en: If your hardware is poor, then no matter how good your software is, it will
    more than likely be slow!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before you consider optimizing your software to improve the speed and performance
    of I/O operations, you need to make sure that the hardware in place is suited
    to the type of I/O you will be performing. Otherwise, you could be wasting your
    time trying to improve your software!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re dealing with hardware to speed up input and output operations, things
    to consider include the speed of your network card, whether or not you are using
    SSD disks, the number of CPUs, and the amount of RAM in use.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to consider what other software processes will be running on the
    target computers. Security software that’s performing real-time scanning can often
    be overlooked when it comes to application slowdowns. When this is the case, you
    can have your application added as an exception to the antivirus software so that
    real-time scanning no longer slows down your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another issue that’s encountered in the wild is running one or more backups
    over the network during critical times of operation. No matter how efficient your
    program is, if it is running on a backup server, its performance can be severely
    impacted by the running backup software and process. This can also be the case
    if your software is not on the backup server, but requires the network to run
    and then send and receive files and data. The following are things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Change backup schedules to run at non-critical times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install your software on a different server with a better overall performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check your network for bottlenecks and alleviate those bottlenecks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your network cards are fast enough and configured appropriately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your Ethernet cables are up to date. Cat-5 cables are fine for typical
    internet traffic, but if you are doing a lot of file and data operations over
    your network, then you will want to upgrade to Cat-6a/Cat-7 cables for increased
    performance. However, with Cat-7 cables, you need to be careful not to damage
    the foil shielding when you bend the cable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With web projects, it is important to reduce file size to speed up how files
    are transmitted and received over the internet. This helps reduce the overall
    page load time and results in happier customers. To improve the load performance
    of your web applications, enable the Windows Dynamic Content Compression feature.
    This will reduce the data’s size, thus increasing the response time from the user’s
    perspective. The need for data compression also applies to client/server applications,
    especially if the file and data sizes that are being transmitted are huge.
  prefs: []
  type: TYPE_NORMAL
- en: Employ caching to improve network performance. Caching will store resources
    locally or keep them in memory for a certain period. Should such resources be
    requested again, then the locally stored resources will be checked and used instead
    of the network resources. This increases the access and load times of resources,
    and it also reduces network traffic. Cached resources will be updated if the resources
    have been updated, if the cache period has expired, or if the user has cleared
    their cache.
  prefs: []
  type: TYPE_NORMAL
- en: The two most common data transfer mechanisms are XML and JSON. These are text
    files that store structured information. Parsers are required to extract information
    from such files so that the extracted data can be utilized in the applications.
    But not all XML and JSON parsers perform the same. It would be prudent to benchmark
    the performance of various XML and JSON parsers to help you choose the most efficient
    and performant one for your data processing needs.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re serializing and deserializing data, your objects and their hierarchies
    should match your JSON and XML formats so that processing is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft recommends that developers shouldn''t use BinaryFormatter for transferring
    binary data as it is unsafe and can lead to **denial-of-service** (**DOS**) attacks.
    .NET offers several in-box serializers that can handle untrusted data safely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XmlSerializer` and `DataContractSerializer` can serialize object graphs into
    and from XML. Do not confuse `DataContractSerializer` with `NetDataContractSerializer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BinaryReader` and `BinaryWriter` for XML and JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `System.Text.Json` APIs can serialize object graphs into JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types can vary in size as they can hold different data values, and data
    values can vary in length. Both number values and string values are variable in
    length. The bigger the number or string, the more bytes are saved to the file.
    The smaller the number or string, the fewer bytes are saved to the file. Likewise,
    with data type names, the longer the name, the more bytes are used, and the shorter
    the name, the fewer bytes are used.
  prefs: []
  type: TYPE_NORMAL
- en: While writing one or two files occasionally, the size of bytes may not be an
    issue to the end user or your application’s performance. But when you move into
    the realms of batch file processing, the more bytes that have to be written per
    file, the longer batch processing will take to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your OS version, drivers, disk, and networking hardware, it is
    possible that copying or moving small files is more performance-heavy than moving
    around large files. You can optimize file transfer at the OS level under the hood
    by leveraging burst copy or similar techniques.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you can have a lot of performance issues when moving around media
    files (photo/audio/video) or AI/ML datasets (usually text-based). If files are
    small (ranging from a few KBs to a few MBs), you can group them in ZIP files (without
    compression, if they’re media files) so that it results in bigger files that can
    be transferred faster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be benchmarking three different methods for moving
    files. We will be using `File.Copy`, `FileInfo.MoveTo`, and obtaining `FileInfo`
    from the memory cache and using `FileInfo.MoveTo`. This will help us identify
    the quickest method to use in our applications, especially when large numbers
    of files need to be moved.
  prefs: []
  type: TYPE_NORMAL
- en: Moving files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common function in various enterprise applications is the need to move around
    large numbers of files. For example, a reporting function may require the amalgamation
    of last month’s sales figures from various teams to be entered into a data warehouse
    for report processing purposes. Those sales figures could reside in spreadsheets
    in various locations. Each spreadsheet would need to be moved to a central file
    storage location for further processing. The more files that you have in any file
    move operation, the more processing time will be required. So, it pays to know
    which method of moving a large number of files is the most performant in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, we will write a simple application to benchmark three different
    ways of moving files. Each method that we write will vary in performance. Our
    method of choice will be the method that performs the fastest, and this will be
    identified in our benchmark summary report once we have run our compiled executable.
    Let’s start writing our benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new C# .NET 5 console application and name it `CH08_FileAndStreamIO`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `BenchmarkDotNet` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class called `MovingFiles` to the root of the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our class is now set up to benchmark our methods and report on memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the class, add the following code (you can replace the `Moonshine-3.0.0.exe`
    file with a file of your own choosing):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have declared a dictionary of `FileInfo` objects, which will act as
    our in-memory cache, and three constants for our source directory, destination
    directory, and filename. We will need these constants in the other methods we
    will be writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to have a procedure in place to prepare our code so that it can be
    benchmarked without exceptions being raised. If we don’t, our benchmarks will
    fail to execute more than once because the file will have been moved. Each time
    a benchmark runs, the moved file needs to be moved back to its original location.
    So, we are going to need a `[GlobalSetup]` method and a `[GlobalCleanup]` method.
    First, add the `[GlobalSetup]` method to the `MovingFiles` class. We will call
    the `PreloadFilesAndCacheThem()` method here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is getting `FileSystemInfo` for each file in the source directory
    identified by the `SOURCE_DIRECTORY` string. Then, it instantiates `_cache` as
    a dictionary of `FileInfo` objects. After that, the list of files is iterated
    through, and the `FileInfo` object for the current file is added to `_cache`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `PreMoveCheck() [GlobalCleanup]` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The cleanup code checks whether the file already exists in `SOURCE_DIRECTORY`.
    If it does, then `DESTINATION_DIRECTORY` is checked for the file. If it exists,
    it is deleted. If the file does not exist in `SOURCE_DIRECTORY` but exists in
    `DESTINATION_DIRECTORY`, then the file is moved from `DESTINATION_DIRECTORY` back
    into `SOURCE_DIRECTORY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need the `[GlobalSetup]` and `[GlobalCleanup]` methods because if they are
    not in place doing what they are doing, the benchmarks will fail because the file
    cannot be found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `FileCopy()` method to the `MovingFiles` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `FileCopy()` method performs a `PreMoveCheck()` so that the file is in place,
    ready for the benchmark to run without failing. It then proceeds to copy the file
    from `SOURCE_DIRECTORY` to `DESTINATION_DIRECTORY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the `FileInfoMoveTo()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `FileInfoMoveTo()` method also performs a `PreMoveCheck()`, ensuring that
    the file is in place, ready for the move. Then, it creates a `FileInfo` object
    for the specified file and uses the `MoveTo(string destinatation)` method to move
    the file from `SOURCE_DIRECTORY` to `DESTINATION_DIRECTORY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `FileInfoReadCacheAndMoveTo()` method to the `MovingFiles` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `FileInfoReadCacheAndMoveTo()` method performs a `PreMoveCheck()`. Then,
    it creates a `FileInfo` object from the `FileInfo` object stored in `_cache`.
    If the `FileInfo` object exists, it is then moved to `DESTINATION_DIRECTORY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line of code to the `Main` method in the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the project in `Release` mode, and then run the executable from the command
    line. You should see the following benchmark summary report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The BenchmarkDotNet summary report for various file move operations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_8.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – The BenchmarkDotNet summary report for various file move operations
  prefs: []
  type: TYPE_NORMAL
- en: From the timings, we can see that the `File.Copy(string source, string destination)`
    method is the slowest method of moving files, followed by the `FileInfo.MoveTo(string
    destination)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The fastest file move operation is to extract `FileInfo` from the in-memory
    cache and then use the `FileInfo.MoveTo(string destination)` method to perform
    the move operation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at two different methods for calculating the
    size of all the files in a directory. We can then use the fastest method for when
    we need to calculate the size of directories, such as before doing a batch file
    move in an enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating directory sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re batch processing files and directories, it can pay to know how large
    the sum of files is before moving them to a new location. This can help you determine
    the amount of time that it will take to copy the files, as well as whether the
    destination has space to store all the files.
  prefs: []
  type: TYPE_NORMAL
- en: An example of some dialog that pops up when you’re copying or moving files is
    the Windows Explorer dialog. It traverses the files and directories to be moved
    or copied. As it does, it logs the total amount of bytes that are being used by
    the files and directories. Then, it provides a time estimate regarding how long
    it will take to move or copy those bytes. There are times when this process can
    take a very long time and be frustrating for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason to know about directory sizes is when you have critical business
    needs that are time-sensitive. Prolonged file move operations can be detrimental
    to the business’ time plan. In this section, we will calculate directory size
    by benchmarking two different methods. The method that performs the fastest is
    the one we would choose when calculating a directory’s size. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class to the project called `GettingFileSizes` and configure it for
    benchmarking, as you did withthe `MovingFiles` class. Then, add the `DIRECTORY`
    constant to the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `GetDirectorySizeUsingGetFileSystemInfos()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GetDirectorySizeUsingGetFileSystemInfos()` method creates a new `DirectoryInfo`
    object based on the directory defined in the `DIRECTORY` constant. Then, it gets
    an array of `FileSystemInfo` from the `DirectoryInfo` variable. The `FileSystemInfo`
    array is then iterated through and the `directorySize` variable is incremented.
    Once `directorySize` has been calculated, the value is returned to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `GetDirectorySizeUsingArrayAndFileInfo()` method to the `MovingFiles`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GetDirectorySizeUsingArrayAndFileInfo()` method gets a string array of
    filenames for the given directory. The array is then iterated and `directorySize`
    is incremented by the current file size. Once the iteration is complete, `directorySize`
    is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `benchmark` runner method to the `Main` method in the `Program` class,
    perform a `Release` build, and then run the executable from the command line.
    You will see the following report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The benchmark summary report for obtaining directory sizes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_8.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The benchmark summary report for obtaining directory sizes
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we used two different methods to calculate the size of the `System32`
    directory. The slowest method of calculating a directory size was our second method.
    So, for performance reasons, the best method for calculating the size of a directory
    is to get `DirectoryInfo` for the directory in question. Then, you can call `GetFileSystemInfos()`
    and iterate through the result, summing the length of the `FileInfo` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at asynchronous file operations.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing files asynchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Why should you access files asynchronously? Well, here are a few reasons that
    you might consider when using asynchronous file access:'
  prefs: []
  type: TYPE_NORMAL
- en: Your user interface thread will be more responsive as the file operation won’t
    block the user interaction if it takes a few seconds or longer to complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An asynchronous process reduces the need for manually managed threads, making
    applications more scalable. ASP.NET and server-side applications are specific
    examples of applications that will benefit from asynchronous file processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File access latency is also something you must consider. Computer resources
    such as the type of hard disk, network upload and download speeds, and real-time
    scanning by the security software, as well as file size, are all factors that
    can affect file access times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is only a small overhead for using asynchronous tasks over threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run asynchronous tasks in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `FileStream` class gives you the most control over file access operations.
    You can configure the class to execute I/O operations at the operating system
    level. By doing this, you avoid blocking thread pool threads. To execute I/O operations
    at the operating system level, you must specify one of the following in the constructor
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useAsync=true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options=FileOptions.Asynchronous`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This option can only be used with the `StreamReader` and `StreamWriter` classes
    when the stream that’s provided to them is one that was opened by the `FileStream`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s look at a very simple example of performing asynchronous file writing
    and reading. Let’s start by writing some text to a text file asynchronously. Then,
    we will read the text from the same file asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Writing text to a file asynchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will write some text to a text file asynchronously. There
    is a simpler way to perform this task but the method we will be using provides
    the most control and operates at the operating system level:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file to the `CH08_FileAndStreamIO` project called `AsyncFileAccess`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new method called `WriteTextToFileAsync(string text, string path)` to
    the `AsyncFileAccess` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we pass a string of text in and the name of the file to write the text
    to. Then, we read all the text into a byte array. Next, we declare an asynchronous
    `FileStream` variable with a buffer size of 4,096 bytes, write the text asynchronously
    to the specified file, and wait for the operation to complete. The reason for
    using 4,096 bytes is that it is a power of two number and a memory page size.
    A page, memory page, or virtual page is a fixed-length contiguous block of virtual
    memory that’s described by a single entry in the page table. So, when the system
    chooses to swap out a page to disk, it can do so in one go without any overhead
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadTextFromFileAsync(string path)` method to the `AsynFileAccess`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we declare a `StringBuilder` for efficient string concatenation.
    Then, we declare and initialize a new byte array that will be our buffer and declare
    a `numberOfBytesToDecode` variable. A new `FileStream` object is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: The `numberOfBytesToDecode` variable is set by awaiting the call to the `ReadAsync`
    method. This variable is set for each iteration of the `For` loop. For each iteration
    of the loop, we obtain the number of bytes to be decoded. Then, we append a line
    to the output, with the items taken from the buffer. Finally, we return the resulting
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DemonstrateAsyncFileOps()` method to the `AsyncFileAccess` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DemonstrateAsynFileOps()` method writes some text to a file asynchronously
    by calling the asynchronous write operation. Then, it reads the text back asynchronously
    by calling the asynchronous read operation. The result is then printed to the
    console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `Program` class’s `Main` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code creates a new instance of our `AsyncFileAccess` class, and then calls
    the `DemonstrateAsyncFileOps()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run your code. In your console window, you should see the following
    line printed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As can be seen from our simple example, asynchronous file access is fairly straightforward.
    In the next section, we will look at how to handle I/O exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling I/O operation exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with I/O operations, you can encounter several different exceptions.
    The base I/O exception is `IOException`. It pays to differentiate between the
    different I/O exceptions and to log them as this can help expedite problem resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table provides a breakdown of the various I/O exceptions that
    can be raised by your I/O operations. By trapping these specific exceptions, you
    can provide a more detailed exception log entry that helps with identifying the
    root source of the problem more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.2 – Microsoft .NET I/O exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Table_8.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.2 – Microsoft .NET I/O exceptions
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the kind of I/O exceptions that can be raised, you also
    need to know about the correct way to handle, log, and display such exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we need to write code that can detect malfunctioning code. Code
    that malfunctions leaves a computer program in an undefined state. This can lead
    to side effects that are unexpected and unpredictable. A computer program that
    is in an unpredictable state can lead to all manner of issues such as performance
    slowing down, application hangs, and invalid data, leading to incorrect information.
    This can lead to serious business and consumer issues, and that is not good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, your code needs to be fault-tolerant and should be able to handle
    faults appropriately. Exceptions should be handled so that data integrity remains
    intact. You should also bear in mind that there are two categories of exceptions
    that your computer program should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expected exceptions** are exceptions that your computer program can recover
    from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unexpected exceptions** are exceptions that your computer program is unable
    to recover from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected exceptions need to be handled silently. You know what has the potential
    to fail and why, so you can put defensive code in place to act against such code-raising
    exceptions in the first place. This is important, as you don’t want bubbling exceptions
    since this reduces application performance. In turn, a reduction in application
    performance impacts the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing exceptions to propagate through your computer program is expensive
    in terms of performance. With this in mind, best practice stipulates that it is
    better to handle exceptions at the point where they occur within your code for
    improved application performance.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re trapping for errors using a `try/catch` block, it is also a good
    practice to have multiple `catch` blocks. The only exceptions that would form
    the `catch` blocks are those that can be thrown by the current method. You would
    put the exception `catch` blocks in an order where the most specific exception
    is at the top, and then reduce to the least specific, which would be your bottom
    `catch` block. This helps make your code more readable to fellow programmers,
    and it also makes debugging your code for specific exceptions much easier.
  prefs: []
  type: TYPE_NORMAL
- en: You can use exception filters to handle an exception when a specific condition
    is present. If the exception filter returns true, then the exception is handled.
    But if it returns false, the search for an exception handler continues. It is
    preferable to use exception filters instead of catching and rethrowing because
    filters leave the stack unharmed. If a later handler dumps the stack, you can
    see where the exception originally came from, rather than just the last place
    it was rethrown.
  prefs: []
  type: TYPE_NORMAL
- en: When an unexpected exception occurs, it must be thrown because it can have a
    seriously detrimental effect on the predictability of your computer program. When
    unexpected exceptions occur, you should log the exception and exit to protect
    the integrity of your data.
  prefs: []
  type: TYPE_NORMAL
- en: This is why using `System.Exception` is a bad idea in that it swallows all exceptions.
    Your methods should only trap for the exceptions that they expect to be raised.
    All unexpected exceptions should be handled by the application in such a way that
    the exception is logged and the program is exited. It is in the main application’s
    `try/catch` block that you would have your `System.Exception` catch block to catch
    unexpected exceptions. This block would handle all unexpected exceptions that
    are allowed to bubble up back to the main application code.
  prefs: []
  type: TYPE_NORMAL
- en: When unexpected exceptions propagate back to the main application code’s exception
    `catch` block, you can extract the underlying base exception by calling `Exception.GetBaseException()`.
    This will get the original exception that was raised, causing any subsequent exceptions
    to also be raised.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, I have found that IT professionals will often neglect to review
    the event log and application logs when troubleshooting. However, when they have
    drawn blanks and have asked for my help, this has usually been my first port of
    call. It may be that nothing gets logged in **Event Viewer**, and nothing gets
    logged by the application. But there are times when valuable information does
    get logged, and it can be a time-saver in terms of problem-solving and getting
    the application working again in a more stable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are essentially three different locations where an exception can be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application log files**: When an exception is encountered, it will be logged
    by the application to a text file, JSON file, or XML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Viewer**: When an expected exception is encountered, this will be logged
    by the application to a named event log. When an unexpected exception is encountered
    such as an application hang, the system will log this exception in either the
    Windows Application Log or the Windows System Log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The database**: When an application is encountered, the application will
    log the exception to a database table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever mechanism or mechanisms you choose is down to you and your application
    needs. However, you must make sure that the logs are well-formatted and that the
    data that’s provided is meaningful. Logs are no good if they are hard to read
    and contain lots of noise!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Use a best practice that dictates managed and unmanaged resources should be
    correctly disposed of, especially if an application does crash. When providing
    tech support, I have often come across situations where applications have crashed
    and locked resources, and where resources have been kept alive in memory. This
    leads to bad user experiences and can lead to files, directories, and other resources
    not being accessible, and the application itself not being able to start up. Often,
    in these cases, the only options are to kill the application using Task Manager
    or restart the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Performing memory tasks efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When benchmarking C# programs, you will see that sometimes, the objects that
    allocate the most memory will be faster than the methods that allocate fewer objects.
    A case in point is strings. Using formatted strings can allocate fewer memory
    interpolated strings. However, formatted strings can be slower than using interpolated
    strings. We are going to demonstrate this with a really simple piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a class to the `Memory` and configure it for using *BenchmarkDotNet*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ReturnFormattedString()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a formatted string. It is essentially one line and contains
    no named variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReturnInterpolatedString()` method to the `Memory` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method declares several strings and assigns values to them. It then returns
    the interpolated string. This method covers multiple lines and looks like it will
    be slower and use the most memory. However, the only way to know for sure is to
    run the benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BenchmarkRunner.Run<Memory>();` call to your `Main` method, do a `Release`
    build, and then run the executable from the command line. The following screenshot
    shows the memory that was allocated and the time it took to perform each method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The Benchmark summary report comparing String.Format against
    interoperable strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_8.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – The Benchmark summary report comparing String.Format against interoperable
    strings
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even though we can declare multiple variables and allocate the
    most memory using our string interoperability method, it is much faster than doing
    the same thing with `String.Format`. If you have a lot of string processing to
    do, such as in batch report generation or document processing, then you can almost
    halve the time it takes to perform your string manipulations using string interoperability.
    The memory also never reaches generation 1, so it is dealt with efficiently by
    the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you need to reduce the amount of boxing and unboxing that you do. Every
    time you convert a value type into a reference type, it will be stored on the
    heap. And every time you convert a reference type into a value type, you place
    it on the stack. So, what are the performance implications for doing this? Boxing
    and unboxing are computationally expensive processes. The more computations that
    are required to perform a function, the slower the process will be. So, by eliminating
    unnecessary computations caused by boxing and unboxing, you speed up your application
    and can end up using less memory. So, when you can, try and use value types on
    the stack instead of reference types on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid code duplication in your objects. If you have multiple constructor overrides,
    then place the common code in the common constructor and do the same with your
    methods. A class with duplicate code will use more memory than the same class
    correctly coded to have no duplication. You should always look for ways to refactor
    your objects to reduce code bloat, and removing code duplication and reusing code
    is an easy way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Memory fragmentation can be a major cause of performance issues for C# programs.
    Memory fragmentation occurs when objects are added to the heap, garbage is collected,
    and then other objects fill the available space. If you end up with free space
    between the objects in memory, then your memory has become fragmented. The GC
    will perform a compacting collection when it is most efficient to do so. Doing
    this manually should only be done after carefully investigating the scenario in
    question.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, you can defragment the **Large Object Heap** (**LOH**) using the garbage
    collection settings that are available, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code ensures that the objects on the LOH occupy a contiguous area of memory.
    All the free space that is located between objects in memory is removed and placed
    at the end of the allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: You should also consider not using finalizers. An object will remain in memory
    longer if it uses finalizers. This will cause a build-up of memory usage. And
    a build-up of memory usage will lead to reduced performance by your applications.
  prefs: []
  type: TYPE_NORMAL
- en: It is a best practice to dispose of objects and resources when you have finished
    with them. This helps prevent objects remaining in memory that are not being used,
    and also releases locks on resources such as files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: When utilizing disposable objects, you should always try and use the `using`
    statement. This is because when the block of code finishes, the object will automatically
    be disposed of. When you write a class that uses various disposable resources,
    even if it does not own those disposable resources, you should implement the disposable
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at file and memory operations and how performance can
    be impacted. Now, let’s turn our attention to local storage tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding local storage tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Windows 10, there are several locations that you can use to store data locally.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppData` folder, this folder can contain settings, files, and folders. This
    folder is used for data that is not that easy to recreate or download. If you
    have backup applications that can back up a user’s `AppData` folder, then anything
    stored in the `Local` folder will be backed up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationData.LocalCacheFolder` property can be stored in the local cache.
    Items stored using the local cache will be persisted across sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roaming**: Roaming profiles can be used by network users to store their local
    data on the server. This has the advantage that prudent network managers will
    ensure profiles are backed up regularly, so users will always have a restore point
    if they happen to lose data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppData\Temp` folder for temporary data. It is a good idea to clean data in
    the `Temp` folder when you have finished with it. Application initialization and
    shutdown are good points to perform system housekeeping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C:\ProgramData**: This location is a best practice location for storing application
    data. However, this location does not always get backed up. So, it is always a
    good idea to provide an in-application way to ensure data is regularly backed
    up and stored in a safe location in case your computer dies, which does happen!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s down to you regarding how and where you store your data. From my extensive
    experience providing IT support to schools, they can have some extremely complicated
    and very hardened systems security-wise. You cannot assume your application will
    be installed on the `C:\` drive, and you cannot assume you will have access to
    the `C:\ProgramData` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Many business and assessment hours have been lost by schools trying to install
    and run educational vendor software on such complicated systems. Often, this leads
    to remote technical support sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that can often arise is the use of the Microsoft VirtualStore.
    When a user installs software and they are presented with the question, `Install
    for anyone who uses this computer` or `Install for Just Me`, they tend to select
    the latter. On Windows 10 computers, `Install for Just Me` puts the stored data
    for the installed application into the user’s virtual store. But selecting `Install
    for anyone who uses this computer` will normally store application data in the
    `C:\ProgramData\YOUR_APPLICATION` folder.
  prefs: []
  type: TYPE_NORMAL
- en: A telltale sign that a user has installed the software for only themselves to
    use is when multiple people log onto an office computer, and each person has a
    copy of the data. When this happens, multiple copies of the data exist. These
    copies can be found in each person’s virtual store.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what happened to me and my colleagues. We develop educational
    software that comes in standalone, network, and online formats. For our standalone
    customers, we offer a single-user license. The data for the application is stored
    in a Microsoft Access database. Originally a problem on Windows 7, which remains
    a potential problem on Windows 10, is users being given the prompt to install
    for just them or all users. When they install for all users, the Microsoft Access
    database can be found under `C:\ProgramData\CompanyName\ProductName`. All users
    who log onto the computer to use our software will see the same datasets. But
    should a user select to install only for themselves, then our software’s data
    will be stored under the user profile's VirtualStore
  prefs: []
  type: TYPE_NORMAL
- en: The location of the Virtual Store is `C:\Users\%USERNAME%\AppData\Local\VirtualStore`.
    This is useful to know because it reduces your time locating the data for the
    various users under their profiles. The difficulty arises when the customer demands
    that the data be merged and stored in a central location. When this situation
    arises, uninstall the software and reinstall it, making sure that you select the
    option to `Install for all users`. Then, request the users stop using the software
    until you have provided them with the merged data. Information such as this may
    not increase the performance of your C# and .NET programs, but it certainly improves
    your performance when you’re providing technical support. And that can be a feather
    in your cap, as I have found to my benefit! And as programmers/technical support
    staff/software developers, we all go through personal performance reviews to see
    how well we are doing in our roles.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have concluded the material for this chapter, let’s summarize what
    we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by looking at various file paths. There are four
    different types of file paths – absolute paths, relative paths, UNC paths, and
    DOS device paths.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing the various types of paths, we learned that, by default, Windows
    and Windows Server are limited to a complete file path length of 256 characters.
    In today’s world of open source and web-based software working across platforms,
    this maximum standard length on Windows computers can be very limiting. This can
    cause backup issues when you’re performing disk-to-disk backups, and deeply nested
    projects can blow the maximum file path length. To overcome this limitation, we
    learned how to remove the limit by accessing and modifying the registry.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we looked at was the various considerations for improving disk
    I/O. We started looking at I/O performance considerations by considering the different
    hardware devices that can affect performance. Then, we benchmarked some code to
    find the most efficient ways of calculating directory sizes, moving files, and
    performing asynchronous file manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we looked at was exception handling. We came to understand that
    bubbling up exceptions unnecessarily affects performance and that they should
    be caught and dealt with at the source. We also came to understand that we should
    not swallow exceptions by catching generic exceptions. Generic exceptions should
    only be a last resource for logging purposes before you close the application
    down due to encountering a non-recoverable exception.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at memory tasks. After benchmarking `string.Format` and interpolated
    strings, where we learned how using interpolated strings almost doubled our `performane.Next`,
    we considered memory fragmentation, which can occur when we’re adding and removing
    objects of various sizes. We also learned how to compact fragmented memory to
    make it run more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at local storage tasks. We discussed the various types of
    local storage available and their uses. Plus, we discussed the end user installation
    of our products, which can result in different logged-on users having their own
    sets of data. This problem arises when users choose to install for themselves
    instead of all users. Thus, each user has their copy of the application data stored
    against the profile in `C:\Users\%USERNAME%\AppData\Local\VirtualStore`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at networking. But before we do, see if you
    can answer the following questions. Then, improve your knowledge on the topic
    of I/O performance by looking at the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the various Windows file path formats that you need to be aware of?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you remove the 256-character limit for Windows file paths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method is the most efficient for calculating directory sizes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method is the most efficient for moving files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you catch exceptions using the `Exception` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base I/O `Exception` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What file location options do you have for local storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one of the potential pitfalls that may be encountered when users install
    your software?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Microsoft Virtual Store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the Microsoft Virtual Store located?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*File and Stream I/O*: [https://docs.microsoft.com/dotnet/standard/io/](https://docs.microsoft.com/dotnet/standard/io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pipes*: [https://docs.microsoft.com/dotnet/standard/io/pipe-operations](https://docs.microsoft.com/dotnet/standard/io/pipe-operations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Faster file move method other than File.Move*: [https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move](https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C# GetFileSystemInfos can get file sizes quickly*: [https://thedeveloperblog.com/getfilesysteminfos](https://thedeveloperblog.com/getfilesysteminfos).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance of writing to a file in C#*: [https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp](https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Asynchronous File Processing*: https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/using-async-for-file-access#:~:text=%20Asynchronous%20file%20access%20(C#)%20%201%20Use,writing%2010%20text%20files.%20For%20each...%20More.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to iterate file directories with PLINQ*: [https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3](https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling I/O exceptions in .NET*: [https://docs.microsoft.com/dotnet/standard/io/handling-io-errors](https://docs.microsoft.com/dotnet/standard/io/handling-io-errors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Calling Windows 10 APIs from a desktop application*: https://blogs.windows.com/windowsdeveloper/2017/01/25/calling-windows-10-apis-desktop-application/#vZiZ96PlZUqTduts.97.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance Improvements in .NET 6*: [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Page (Computer Memory)*: [https://en.wikipedia.org/wiki/Page_(computer_memory)](https://en.wikipedia.org/wiki/Page_(computer_memory)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
