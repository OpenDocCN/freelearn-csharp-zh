["```cs\n    {  \"IsEncrypted\": false,  \"Values\": {    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",    \"FUNCTIONS_WORKER_RUNTIME\": \"dotnet\",    \"AzureSignalRConnectionString\": \"SticksAndStones.Functions project, and add the code listed previously with your connection string.\n    ```", "```cs\n    namespace SticksAndStones.Models;public class Player {    public Guid Id { get; set; } = Guid.Empty;    public string GamerTag { get; set; } = string.Empty;    public string EmailAddress { get; set; } = string.Empty;    public Guid MatchId { get; set; } = Guid.Empty;}\n    ```", "```cs\n    using System;using System.Collections.Generic;namespace SticksAndStones.Models;public class Match {    public Guid Id { get; set; } = Guid.Empty;    public Guid PlayerOneId { get; set; }    public int PlayerOneScore { get; set; }    public Guid PlayerTwoId { get; set; }    public int PlayerTwoScore { get; set; }    public Guid NextPlayerId { get; set; }    public List<int> Sticks {get; set; } = new(new int[24]);    public List<int> Stones {get; set;} = new(new int[9]);    public List<int> Score = new(new int[2]);    public bool Completed { get; set; } = false;    public Guid WinnerId { get; set; } = Guid.Empty;    public static Game New(Guid challengerId, Guid opponentId)    {        return new()        {            Id = Guid.NewGuid(),            PlayerOne = opponent,            PlayerTwo = challenger,            NextPlayer = opponent         };    }}\n    ```", "```cs\n    public GameDbContext(DbContextOptions<GameDbContext> options) : base(options) { }\n    ```", "```cs\n    public DbSet<Player> Players { get; set; }\n    ```", "```cs\n    public DbSet<Match Matches { get; set; }\n    ```", "```cs\n    protected override void OnModelCreating(ModelBuilder modelBuilder){}\n    ```", "```cs\n    modelBuilder.Entity<Player>()    .HasKey<Player>(p => p.Id);modelBuilder.Entity<Match>()    .HasKey<Match>(g => g.Id);base.OnModelCreating(modelBuilder);\n    ```", "```cs\n    modelBuilder.Entity<Game>()    .HasKey(g => g.Id);modelBuilder.Entity<Match>()    .Property(p => p.Sticks)    .HasConversion(        toDb => string.Join(\",\", toDb),        fromDb => fromDb.Split(',', StringSplitOptions.None).Select(int.Parse).ToList() ?? new(new int[24]));\n    modelBuilder.Entity<Match>()    .Property(p => p.Stones)    .HasConversion(        toDb => string.Join(\",\", toDb),        fromDb => fromDb.Split(',', StringSplitOptions.None).Select(int.Parse).ToList() ?? new(new int[9]));\n    base.OnModelCreating(modelBuilder);\n    ```", "```cs\n    using Microsoft.Azure.Functions.Extensions.DependencyInjection;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.DependencyInjection;using SticksAndStones.Repository;[assembly: FunctionsStartup(typeof(SticksAndStones.Startup))]\n    namespace SticksAndStones;public class Startup : FunctionsStartup {    public override void Configure(IFunctionsHostBuilder builder)    {        string SqlConnection = Environment.GetEnvironmentVariable(\"SqlConnectionString\");        builder.Services.AddDbContextFactory<GameDbContext>(            options =>            {                options.UseInMemoryDatabase(\"SticksAndStones\");            });    }}\n    ```", "```cs\n    namespace SticksAndStones.Models;public class ConnectionInfo {    public string Url { get; set; }    public string AccessToken { get; set; }}\n    ```", "```cs\n    using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct ConnectRequest(Player Player);public record struct ConnectResponse(Player Player, List<Player> Players, ConnectionInfo ConnectionInfo);\n    ```", "```cs\n    using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct PlayerUpdatedEventArgs(Player Player);\n    ```", "```cs\n    public class GameHub : ServerlessHub\n    {    [FunctionName(\"Function1\")]    public static async Task<IActionResult> Run(    [HttpTrigger(AuthorizationLevel.Function, \"get\", \"post\", Route = null)] HttpRequest req,    ILogger log)    {        log.LogInformation(\"C# HTTP trigger function processed a request.\");        string name = req.Query[\"name\"];        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();        dynamic data = JsonConvert.DeserializeObject(requestBody);        name = name ?? data?.name;        string responseMessage = string.IsNullOrEmpty(name)        ? \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\"                : $\"Hello, {name}. This HTTP triggered function executed successfully.\";        return new OkObjectResult(responseMessage);    }}\n    ```", "```cs\n    [FunctionName(\"HttpTrigger attribute indicates that this function is called by using the HTTP protocol and not by some other means, such as a SignalR message or a timer. The function is only called using the HTTP POST method, not GET.\n    ```", "```cs\n    [HttpTrigger(AuthorizationLevel.Anonymous, \"post\", Route = null)] HttpRequest req,[SignalRConnectionInfo(HubName = \"GameHub\")] SignalRConnectionInfo connectionInfo,[SignalR(HubName = \"GameHub\")] IAsyncCollector<SignalRMessage> signalRMessages,ILogger log)\n    ```", "```cs\n    log.LogInformation(\"A new client is requesting connection\");\n    ```", "```cs\n    var result = await JsonSerializer.DeserializeAsync<ConnectRequest>(req.Body, jsonOptions);var newPlayer = result.Player;\n    ```", "```cs\n    internal class GameHub : ServerlessHub {    private readonly JsonSerializerOptions jsonOptions = new(JsonSerializerDefaults.Web);\n        [FunctionName(\"Connect\")]    public async Task<IActionResult> Connect(\n    ```", "```cs\n    if (newPlayer is null){    var error = new ArgumentException(\"No player data.\", \"Player\");    log.LogError(error, \"Failure to deserialize arguments\");    return new BadRequestObjectResult(error);}if (string.IsNullOrEmpty(newPlayer.GamerTag)){    var error = new ArgumentException(\"A GamerTag is required for all players.\", \"GamerTag\");    log.LogError(error, \"Invalid value for GamerTag\");    return new BadRequestObjectResult(error);}if (string.IsNullOrEmpty(newPlayer.EmailAddress)){    var error = new ArgumentException(\"An Email Address is required for all players.\", \"EmailAddress\");    log.LogError(error, \"Invalid value for EmailAddress\");    return new BadRequestObjectResult(error);}\n    ```", "```cs\n    using Microsoft.Azure.WebJobs.Extensions.SignalRService;private field to store the context factory and a constructor with an argument that will be fulfilled by dependency injection, as follows:\n\n    ```", "```cs\n\n    ```", "```cs\n    using System;GamerTag in the database to ensure it isn’t in use already by another player, as follows:\n\n    ```", "```cs\n\n    The first step is to get a new database context from the factory. The `Players` list from the database context to compare `GamerTag` value to other GamerTagsvalues. However, we want to exclude a result if it matches `EmailAddress` since that would indicate the records are identical, and this user is just signing back in again.\n    ```", "```cs\n        log.LogInformation(\"Locating Player record.\");    var thisPlayer = (from p in context.Players where string.Equals(p.EmailAddress, newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase) select p).FirstOrDefault();\n    ```", "```cs\n    if (thisPlayer is null){    log.LogInformation(\"Player not found, creating.\");    thisPlayer = newPlayer;    thisPlayer.Id = Guid.NewGuid();    context.Add(thisPlayer);    await context.SaveChangesAsync();}\n    ```", "```cs\n    namespace SticksAndStones;public static class Constants {    public static class Events     {        public static readonly string PlayerUpdated = nameof(PlayerUpdated);    }}\n    ```", "```cs\n        log.LogInformation(\"Notifying connected players of new player.\");    await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(thisPlayer));\n    ```", "```cs\n    // Get the set of available players log.LogInformation(\"Getting the set of available players.\");    var players = (from player in context.Players         where player.Id != thisPlayer.Id         select player).ToList();\n    ```", "```cs\n    var connectionInfo = await NegotiateAsync(new NegotiationOptions() { UserId = thisPlayer.Id.ToString() });\n    ```", "```cs\n    log.LogInformation(\"Creating response.\");var connectResponse = new ConnectResponse(){    Player = thisPlayer,    Players = players,    ConnectionInfo = new Models.ConnectionInfo { Url = connectionInfo.Url, AccessToken = connectionInfo.AccessToken }};\n    ```", "```cs\n    log.LogInformation(\"Sending response.\");return new OkObjectResult(connectResponse);\n    ```", "```cs\nInvoke-WebRequest -Headers @{ ContentType = \"application/json\" } -Uri http://localhost:7024/api/Connect -Method Post -Body ''\n```", "```cs\n{  \"profiles\": {    \"SticksAndStones.Functions\": {      \"commandName\": \"Project\",      \"commandLineArgs\": \"--port Uri parameter after localhost:.\nIn the `Body` parameter, you can add the JSON that the command is expecting. For the `Connect` function, this would be `ConnectRequest` and would look like this:\n\n```", "```cs\n\n The full command will look like this:\n\n```", "```cs\n\n Go ahead and try out various versions of the command to see how the function reacts.\nNow that we can connect players to the game server, let’s look at what is needed for the lobby.\nRefreshing the lobby\nIn the Sticks and Stones App, which you will create in Chapter 10, once a player has connected, they will move to the lobby page. Initially, the lobby will be populated from the list of players sent in the response from the `Connect` function. Additionally, as each player connects, the lobby will be updated through a SignalR event.\nBut we all get impatient and want a way to refresh the list immediately. So, the lobby page has a way to refresh the list; to do so, it will call the `GetAllPlayers` function.\nLet’s start by creating the messages needed for `GetAllPlayers`.\nCreating the messages\n`GetAllPlayers` takes no parameters, so we only need to create the `GetAllPlayersResponse` type. Follow these steps to add `GetAllPlayersResponse`:\n\n1.  In the `SticksAndStones.Shared` project, create a new file named `GetAllPlayers` **Messages.cs** in the `Messages` folder.\n2.  Modify the contents of the file so that it looks as follows:\n\n    ```", "```cs\n\nWith the messages created, we can move on to the `GetAllPlayers` function.\nGetting all the players\n`GetAllPlayers` is called using the `Http` `GET` method and has an optional parameter that is passed through `QueryString` using the `id` key. The optional parameter is used to exclude a specific `id` from the returned list. This makes it so that the app can send the current player’s `id` and not have it returned in the list. To create the `GetAllPlayers` function, follow these steps:\n\n1.  In the `GameHub` class, after the `Connect` method, add the following method declaration:\n\n    ```", "```cs\n\n    Not much is new here other than using `\"get\"` instead of `\"post\"` for the `Http` method, and `Route` is set to `\"Players/GetAll\"`, which would make the URL for the function `http://localhost:7024/api/Players/GetAll`.\n\n     2.  In the method, we will process the `id` option parameter. To do so, add the following code:\n\n    ```", "```cs\n\n    In this code, we check for the existence of a key named `id`. If it exists, then its value is retrieved and converted into a `Guid` value and assigned to the `playerId` variable.\n\n     3.  Next, we can query the database for all players, and exclude `player.Id` using the following code:\n\n    ```", "```cs\n\n     4.  Finally, return `OkObjectResult` with a new `GetAllPlayersResponse` object initialized with the list of `players`:\n\n    ```", "```cs\n\nNow that we can refresh the lobby with a list of all the players, it’s time to match them up for a game.\nChallenging another player to a game\nTo test your skills at this game, you’ll need an opponent – someone who would also like to test their skills against yours. This section will build the functionality needed in the `SticksAndStones.Function` project to have one player – the challenger – challenge another player – the opponent – to a game. The opponent has the option to accept the challenge or deny it. We will also handle the case where the opponent does not respond since they might have put their phone down; this is an edge case.\nThe interactions in this use case can get tricky, so let’s review the following diagram to get a better understanding of what we are building:\n![Figure 9.10 – Challenge diagram](img/B19214_09_11.jpg)\n\nFigure 9.10 – Challenge diagram\nThe process starts with a user interaction that results in the client making an HTTP request to the `GameHub` instance via the `IssueChallenge` function. The client will pass the challenger and opponent details when making the HTTP call. `IssueChallenge` will create an `Id` value to track this process. `IssueChallenge` will then send a direct message to the opponent via the SignalR hub using the `SendAsync` method. The message will include the `Id` value that was created earlier, the challenger, and the opponent details as an instance of `ChallengeEventArgs`. The opponent’s client will receive the message via an `On<ChallengeEventArgs>` event handler. The opponent will then have the choice of accepting or declining the challenge. The response is sent back to the `GameHub` instance using the `AcknowledgeChallenge` function. The `Id` value of the challenge is sent along with `ChallengeResponse`, either `Accept` or `Decline`. A third possibility is `Timeout`. If the opponent never responds, then after a certain amount of time has passed, `Challenge` will `Timeout`. In either event, the result is then returned to the challenger using the response of the `IssueChallenge` call.\nLet’s get started by defining the messages.\nCreating the messages and models\nWe will start with `IssueChallengeRequest` since that is the first message that is being sent. Follow these steps to create the class:\n\n1.  In the `SticksAndStones.Shared` project, create a new file named `ChallengeMessages.cs` under the `Message` folder.\n2.  Modify the file so that it looks as follows:\n\n    ```", "```cs\n\nAs we have in the `Connect` function, we use a `record` struct to eliminate a lot of the boilerplate code needed to define a `struct` value. Our message only needs two `Player` objects – `Challenger` and `Opponent`. The client will have both available when it makes the call to this function. `Challenger` will be the client making the call to `IssueChallenge` and `Opponent` will be the opposing side.\nThe `IssueChallenge` function will return `IssueChallengeResponse`. This `Issue` **ChallengeResponse** will have just one field, `Response`, which will be an `enum` value called `ChallengeResponse`. Follow these steps to create `ChallengeResponse`:\n\n1.  In the `SticksAndStones.Shared` project, in the `Models` folder, create a new `enum` named `ChallengeResponse`.\n2.  Add the following values to the `enum` value:\n    *   `None`\n    *   `Accepted`\n    *   `Declined`\n    *   `Timeout`\n\n    Your code should look like this:\n\n    ```", "```cs\n\nTo create the remaining messages for the `IssueChallenge` and `AcknowledgeChallenge` functions, follow these steps:\n\n1.  Open the `ChallengeMessages.cs` file and add the following declaration at the end of the file:\n\n    ```", "```cs\n\n     2.  When the opponent responds to a challenge, they will call the `AcknowledgeChallenge` function and pass an `AcknowledgeChallengeRequest` object as an argument. In the `ChallengeMessages.cs` file, add the following declaration to create `AcknowledgeChallengeRequest`:\n\n    ```", "```cs\n\nThat completes the messages that are sent or received from the `GameHub` functions for a challenge. That just leaves `ChallengeEventArgs`, which is sent from `GameHub` to the opponent. To create the `ChallengeEventArgs` class, follow these steps:\n\n1.  In the `Messages` folder of the `SticksAndStones.Shared` project, create a new file named `ChallengeEventArgs.cs`.\n2.  Replace the contents of the `ChallengeEventArgs.cs` file with the following:\n\n    ```", "```cs\n\n     3.  To add the method name constant for the `SendAsync` method, open the `Constants.cs` file in the `SticksAndStones.Shared` project and add the following highlighted field to the `Events` class:\n\n    ```", "```cs\n\nAs with the previous message definitions, `ChallengeEventArgs` is also defined as `public record struct`. The parameters are an `Id` value of the `Guid` type and two `Player` objects – one for `Challenger` or the initiator, and one for `Opponent` or the receiver. `Id` will be created in the `IssueChallenge` function and is used to correlate the challenge with the response. This is needed because we are tracking the challenge and if a certain amount of time has passed, we expire the challenge. `Id` is used to track that state and check whether the challenge is still valid if the client responds.\nWhat was not included in the diagram in *Figure 9**.10* is a structure that is used to track the challenge in the `GameHub` class. It is only needed while a challenge is active and hasn’t timed out. To create the `Challenge` class, follow these steps:\n\n1.  Create a file named `Challenge.cs` in the `Models` folder of the `SticksAndStones.Shared` project.\n2.  Replace the contents of the `Challenge.cs` file with the following code:\n\n    ```", "```cs\n\nAs with previous models, we use a `record` struct. The `Challenge` class has various properties – `Id`, `Challenger` as a `Player` type, `Opponent` as a `Player` type, and `ChallengeResponse`, which is called `Response`.\nIf a player accepts the challenge, then the two players will start a match with each other. Each player will be notified that the match has begun by receiving a `MatchStarted` SignalR event. To create the event and its arguments, follow these steps:\n\n1.  Open the `Constants.cs` file in the `SticksAndStones.Shared` project and add the following highlighted field to the `Events` class:\n\n    ```", "```cs\n\n     2.  In the `Messages` folder of the `SticksAndStones.Shared` project, create a new file named `MatchStartedEventArgs.cs`.\n3.  Replace the contents of the `MatchStartedEventArgs.cs` file with the following:\n\n    ```", "```cs\n\nThat concludes the new messages and models that are needed to allow one player to challenge another to a game of `SticksAndStones`. Next, we will create the first of two functions that will handle the process in the `GameHub` class.\nCreating the IssueChallenge function\nWe’ll start with the `IssueChallenge` function. This function is called from the `Challenger` client to start the challenge process. The client will pass their `Player` object, `Challenger`, and the player they are challenging – that is, `Opponent`. These two models are contained in an `IssueChallengeRequest` object. The `IssueChallenge` function will need to perform the following actions:\n\n*   Validate input\n*   Create a challenge object\n*   Send a challenge to the opponent\n*   Wait for a response from the opponent\n*   Send the response to the challenger\n\nTo create the function and implement these actions, follow these steps:\n\n1.  Open the `GameHub.cs` file in the `SticksAndStones.Functions` project.\n2.  Add the `IssueChallenge` function declaration, as follows:\n\n    ```", "```cs\n\n    The `FunctionName` attribute tells Azure Functions that this is an available function. The `req` parameter is an `HttpRequest` object, and the Azure Functions runtime will provide its instance when the function is called. It is attributed by the `HttpTrigger` attribute, which makes the function available via an `Http` API call. `HttpRequest` must use the `POST` method and not `GET` when making the call and the function’s `Route` or `Url` will end with `Challenge/Issue`. The function returns `IssueChallengeResponse` to the caller.\n\n     3.  The first action the function performs is to validate the inputs. The `IssueChallengeRequest` object is sent as part of the body of the `Http` POST request. To retrieve the instance, use the following code in the `IssueChallenge` function:\n\n    ```", "```cs\n\n    This is the same way we retrieved the arguments that were passed in the `Connect` function. The main difference is that the type of object being returned by the `DeserializeAsync` method is `IssueChallengeRequest`, not `ConnectRequest`. The `jsonOptions` field is already defined in the `GameHub` class.\n\n     4.  Now, we need to check whether the challenger and opponent are valid. Valid means that they exist in our database, and neither are currently in a match. We will use `IssueChallenge` function to verify that the players exist:\n\n    ```", "```cs\n\n    First, we capture the `Id` value of the player. We use this `Id` to query the `Players` `DbSet` in the database context for a matching `Id` and return the `Player` object if it exists; otherwise, we return `null`. If the object is `null`, then we exit the function by throwing `ArgumentException` and passing the name of the object as the `paramName` argument and a message detailing the issue. This can be used on the client to display an error message.\n\n     5.  The following code will check whether the players are currently engaged in a match with another player. Add the following code to the end of the `IssueChallenge` function:\n\n    ```", "```cs\n\n    Again, we use `Matches` `DbSet`. We are not looking for the `Match` instance, just the fact that one does exist, where either `PlayerOneId` or `PlayerTwoId` is the player’s `Id` value. We use the `Any` function to return `true` if there are any results and `false` if there are no results. Again, we throw `ArgumentException` if either player is in a match with an appropriate message.\n\n     6.  At this point, we have validated that both players exist and can join a new game. We will need to capture the game `Id` value if the challenge is accepted, so let’s create the variable and log some details before moving on:\n\n    ```", "```cs\n\nThe next step in the `IssueChallenge` function is to create a `Challenge` object. But because we want to track how long `Challenge` is waiting so that we can time it out, we need a helper class to abstract that detail away from the function.\nDon’t reinvent the wheel\nThe implementation of `ChallengeHandler` is heavily based on `AckHandler` from the **Azure SignalR AckableChatRoom** sample. The source for the sample is available at [https://github.com/aspnet/AzureSignalR-samples/tree/main/samples/AckableChatRoom](https://github.com/aspnet/AzureSignalR-samples/tree/main/samples/AckableChatRoom).\nLet’s create the `ChallengeHandler` class by following these steps:\n\n1.  Create a new folder in the `SticksAndStones.Functions` folder named `Handlers`.\n2.  Create a new class named `ChallengeHandler` in the `Handlers` folder, and change the access modifier from `internal` to `public`.\n3.  Add a constructor for the class that has three parameters – `completeAcksOnTimeout` as `bool`, `ackThreshold` as `TimeSpan`, and `ackInterval` as `TimeSpan`. The constructor will create a timer to periodically clear out old challenges and store the `ackThreshold` value in a class field. The class’s contents should look like this:\n\n    ```", "```cs\n\n    You will need to add a `using` declaration for the `System.Threading` namespace to use the `Timer` type. The `CheckAcks` method will be created later in this section.\n\n     4.  To provide some reasonable defaults for the constructor, we will create a parameterless constructor and provide the defaults, as shown in the following snippet:\n\n    ```", "```cs\n\n    This will provide the default values to the main constructor.\n\n     5.  Now, to create a new `Challenge`, the `IssueChallenge` function will call a method named `CreateChallenge`, as shown here:\n\n    ```", "```cs\n\n    Add this declaration to the top of the `ChallengeHandler` class. This `record` has an `Id` value – for uniqueness, `TaskCompletionSource` – a `DateTime` value to track the creation time, and the `Challenge` object itself. We keep a list of `ChallengeRecord` instances in another field called `handlers`. The `handlers` field, which is declared right after the `ChallengeRecord` class, is as follows:\n\n    ```", "```cs\n\n    We use `ConcurrentDictionary` since we may be accessing the field from several different threads at the same time. `ConncurrentDictionary` is designed to prevent data corruption in multithreaded situations, like this one.\n\n    Once `TaskCompletionSource`, `Challenge`, and `ChallengeRecord` have been created, the `Challenge` `Id` value and the `Task` value associated with `TaskCompletionSource` are returned as a `Tuple` value to the `IssueChallenge` function. We will see what happens to that data later in this section when we complete the `IssueChallege` function.\n\n    Finally, to resolve the missing namespaces, add the following highlighted namespace declarations to your `ChallengeHandler` class file:\n\n    ```", "```cs\n    public Challenge Respond(Guid id, ChallengeResponse response){    if (handlers.TryRemove(id, out var res))    {        var challenge = res.Challenge;        challenge.Response = response;        res.ResponseTask.TrySetResult(challenge);        return challenge;    }    return new Challenge();}\n    ```", "```cs\n\n     6.  The `CheckAcks` method, which is called periodically to check for `Challenge` objects that have expired and have not been responded to, looks like this:\n\n    ```", "```cs\n\n    This method will iterate over all the pairs in the `handlers` dictionary. For each one, it will determine whether the elapsed time is greater than the threshold provided in the constructor. If it is, then the task fails with a `TimeOutException` error.\n\n     7.  To wrap up this class, we need to make sure that we clean up any remaining tasks when the service shuts down. We will handle canceling tasks in a `Dispose` method, which is implemented via the `IDisposable` interface. Add the `IDisposable` interface to the `ChallengeHandler` class and add the following `Dispose` method to the end of the class:\n\n    ```", "```cs\n\n    The `Dispose` method will dispose of the timer since we don’t want that firing any longer. Then, it iterates over the handlers and cancels each of the tasks.\n\nThat should complete the `ChallengeHandler` class. We can now resume the implementation of the `IssueChallenge` function:\n\n1.  Open the `GameHub.cs` file and locate the constructor, modifying it as highlighted in the following code:\n\n    ```", "```cs\n\n    Since we will need the `ChallengeHandler` class, and it needs to maintain state, we will use dependency injection and have the Azure Functions runtime supply us with the instance.\n\n     2.  Open the `Startup.cs` file in the `SticksAndStones.Function` project and add the following line of code at the end of the `Configure` method:\n\n    ```", "```cs\n\n    This will register `ChallengeHandler` with dependency injection to allow the Azure Functions runtime to manage the instance creation and lifetime.\n\n     3.  Open the `GameHub.cs` file and navigate to the bottom of the `IssueChallenge` function.\n4.  Add the following lines of code:\n\n    ```", "```cs\n\n    This code will first call `CreateChallenge` using the `ChallengeHandler` instance that we are getting in the constructor. `challengeInfo` is a `Tuple` value of the `Challenge` `Id` type and `task`.\n\n    Next, the opponent is sent a SignalR `Challenge` message with `ChallengeEventArgs`. This message is sent slightly differently since this message will only be sent to the client that matches the opponent’s `Id`.\n\n     5.  Now, we need to wait for the opponent’s response, or a timeout from `ChallengeHandler`, by using the following code:\n\n    ```", "```cs\n\n    The real trick in this code is the `challengeInfo.responseTask` await. `responseTask` is the task that is created as part of `TaskCompletionSource` in `ChallengeHandler`. By awaiting it, we do not continue until either the `Respond` method is called and the task is completed, or the task is failed by setting a `TimeoutException` error in the `CheckAcks` method of `ChallengeHandler`.\n\n    Once one of those conditions is `true`, the method completes and we can get the response from the returned `Challenge`, or in the case of a timeout, handle the exception and return the response to the client in a new instance of `IssueChallengeResponse`.\n\nThe `IssueChallenge` function is now complete. The client can call the function and it will send a message to the opponent’s client and wait for the response. If the opponent client does not respond in a defined amount of time, which is 30 seconds by default, then the challenge will time out. Now, let’s work on accepting or declining a challenge. As with the `Connect` function, you can try it out using the command line. You just need to connect two players, and then have one challenge the other!\nCreating the AcknowledgeChallenge function\nThe `AcknowledgeChallenge` function is used by the client to respond to an open challenge from another player. Let’s create the function by following these steps:\n\n1.  Add a new function to the `GameHub` class, as follows:\n\n    ```", "```cs\n\n     2.  In the body of the function, deserialize the arguments using the following line of code:\n\n    ```", "```cs\n\n     3.  Use `challengeHandler` to `Respond` to the challenge:\n\n    ```", "```cs\n\n     4.  If the response is `Declined`, then just log a message:\n\n    ```", "```cs\n\n     5.  If the response is `Accepted`, then create a match and notify the players:\n\n    ```", "```cs\n\n    So, ignoring all the logging, since that is non-functional, the preceding code starts by creating a new `Match` instance and assigning `PlayerOneId`, `PlayerTwoId`, and `NextPlayerId`. The `Match` object’s `Id` property is then assigned to both of the players, and all the changes are saved to the database.\n\n    Next, is the SignalR messages. First, we create a SignalR group with just the two players in it and use the `Match` object’s `Id` property in the name. This way we can send messages to the group and both players will receive them.\n\n    The first message we will send will indicate the start of a new game and it will send the `match` instance wrapped in `MatchStartedEventArgs`.\n\n    Finally, we send a message for each player to all players, indicating a change in their status.\n\nThat completes the functionality for one player to challenge another player to a match of Sticks and Stones! It’s time to move on to playing a match. But first, we will need a function to return the game to the player.\nGetting the match\nYou may be wondering why we need this functionality since, in the previous function, we sent the `Match` object to both players through a SignalR message. The answer is rather simple – if the user accidentally closes the Sticks and Stones app while in the middle of a game, then when they return to the Sticks and Stones app and log back in, the app will detect that they are still in a match and navigate to the `Match` page. It will use this function to retrieve the `Match` object in this case since it wasn’t sent during `Connect`, just `Id`.\nSo, let’s create a function to return a game by its `Id`, starting with the messages.\nCreating the messages\nThis function will only need a response message object. Unlike the previous functions, the `GetMatch` function will use the `Http` GET method, and we will pass the match `Id` value as part of the URL. The response from the `GetGame` function will be the `Match` instance. To create the `GetGameResponse` message, follow these steps:\n\n1.  In the `SticksAndStones.Shared` project, create a new file named `GetGameMessages.cs` in the `Messages` folder.\n2.  Modify the contents of the file so that it’s as follows:\n\n    ```", "```cs\n\nWith the response message class in place, we can create the `GetMatch` function.\nGetting a match by its ID\nThe `GetMatch` function will accept a single integer named `id` as a parameter. The parameter is bound to a part of the URL that’s used to call the function. Let’s look at an example. If we wanted to get `Match` identified by a `Guid` type of `c39c7490-f4bc-425a-84ab-0a4ad916ea48`, then the URL would be `http://localhost:7024/api/Game/c39c7490-f4bc-425a-84ab-0a4ad916ea48`.\nFollow these steps to implement the `GetMatch` function:\n\n1.  Open the `GameHub.cs` file in the `Hubs` folder of the `SticksAndStones.Functions` project.\n2.  Add the following method declaration after the `AcknowledgeChallenge` method:\n\n    ```", "```cs\n\n    There are a few differences from the other functions. First, the `Http` method that’s used is `\"get\"`, not `\"post\"`. Second, `Route` is set to `\"Game/{id}\"`; `{id}` in `Route` tells the Azure Functions runtime that this function has a parameter named `id` and that the value in that position of the URL should be passed in as an argument. You can see that the third change is that there is an `id` parameter of the `Guid` type. This means that whatever is on the URL in the `{id}` position must be able to be converted into the `Guid` type; otherwise, the Azure Functions runtime will return an HTTP `500 Internal` `Server` error.\n\n     3.  To query our database for the `Match` object that matches the `id` value, use the following lines of code:\n\n    ```", "```cs\n\n     4.  If the method gets this far, then it has been completed successfully, so we can return `OkObjectResult`. The object that’s returned will be a `GetMatchResponse` instance with the `Match` instance that was found, or `null`:\n\n    ```", "```cs\n\nSince this function uses the HTTP GET method, you can test it out in your favorite browser:\n\n1.  Press *F5* to start the project in debug mode.\n2.  Wait for txhe service to start, then copy the URL for the `GetMatch` function from the output window – for example, http://localhost:####/api/Game/{id}, where `###` is your port number.\n3.  Open your browser and paste the URL in the address bar.\n4.  Change `{id}` to anything.\n5.  Press *Enter*.\n\n    You should get an error page in your browser. Try a valid `Guid` value such as `c39c7490-f4bc-425a-84ab-0a4ad916ea48`. You should get a response similar to the following:\n\n    ```", "```cs\n\n    Since there are no active games, you won’t be able to retrieve an actual `Match` instance.\n\nNow that we can retrieve the `Match` object, we will tackle how players make and receive moves and how to determine the score and winner of the game.\nPlaying the game\nSticks and Stones is an interactive, fast-paced, turn-based game. \nLet's review the following diagram to get a better understanding of what we are building:\n![Figure 9.11 – Processing turns](img/B19214_09_12.jpg)\n\nFigure 9.11 – Processing turns\nOnce a match has started, players will take turns choosing a location to place one of their sticks. The client application will then send a message to the GameHub’s `ProcessTurn` function. The `ProcessTurn` function will then validate the move, recalculate the score, check for a winner, and finally, send an update to the players.\nCreating the ProcessTurn messages and models\nThe `ProcessTurn` function has three parameters – the `Match Id`, the player making the move, and the position of the move. The function will return an updated `Match` instance. Follow these steps to add the `ProcessTurn` messages:\n\n1.  Add a new file named `ProcessTurnMessages.cs` to the `Messages` folder in the `SticksAndStones.Shared` project.\n2.  Modify the contents of the file so that it looks as follows:\n\n    ```", "```cs\n\nAs part of the turn, `ProcessTurn` will send the updated `Match` instance to the players. This will require a new SignalR event. Perform the following steps to add it:\n\n1.  `SaveMatchAndSendUpdates` sends a new event via SignalR to the clients, so we need to add that to our constants. Add the highlighted code in the following snippet to the `Constants.cs` file in the `SticksAndStones.Shared` project:\n\n    ```", "```cs\n\n     2.  Add the `MatchUpdatedEventArgs` class that we used to send the updated `Match` to the players when the `MatchUpdated` event is set by adding a new file named `MatchUpdatedEventArgs.cs` to the `Messages` folder in the `SticksAndStones.Shared` project.\n3.  Modify the contents of the file so that it’s as follows:\n\n    ```", "```cs\n\nThat concludes the additional models, events, and messages that are used by the `ProcessTurn` function. Next, we can start working on the ProcessTurn (P-Code) function.\nProcessing turns\nThe `ProcessTurn` function has a few responsibilities. It will need to do the following:\n\n*   Validate the turn\n*   Make the necessary changes to the `Match` object\n*   Recalculate the score\n*   Determine whether there is a winner\n*   Notify the players\n\nTo start the implementation of the `ProcessTurn` function, we will create stubs for each of the methods that we will call when processing a turn. Follow these steps to create the method stubs:\n\n1.  Add a new method declaration to the `GameHub` class for the `ProcessTurn` function:\n\n    ```", "```cs\n\n     2.  Add a new method declaration for `ValidateProcessTurnRequest`:\n\n    ```", "```cs\n\n    The method accepts `ProcessTurnRequest` as the only argument. If there are no errors in the arguments, then it will default to returning `null`. If there is an error, then it will return an `Exception` error.\n\n     3.  We will use another method to verify the match state before processing the move. Create a new method in the `GameHub` class named `VerifyMatchState`, as follows:\n\n    ```", "```cs\n\n    Just like with `ValidateProcessTurnRequest`, we will return `null` for the error if everything is okay; otherwise, we will return an error.\n\nNow that we have the helper method signatures in place, let’s implement them, starting with `ValidateProcessTurnRequest`. Follow these steps to add the implementation to `ValidateProcessTurnRequest`:\n\n1.  In `ValidateProcessTurnRequest`, add the following at the top of the method to check for a valid position:\n\n    ```", "```cs\n\n     2.  In `ValidateProcessTurnRequest`, add the following at the top of the method to check for a valid player:\n\n    ```", "```cs\n\n     3.  In `ValidateProcessTurnRequest`, add the following at the top of the method to check for a valid game `Id` value:\n\n    ```", "```cs\n\nThat completes the `ValidateProcessTurnRequest` method. Now, we can add the code to `VerifyMatchState`, as follows:\n\n1.  In `VerifyMatchState`, add the following at the top of the method to check that the position hasn’t already been played:\n\n    ```", "```cs\n\n     2.  In `VerifyMatchState`, add the following at the top of the method to check that the correct player is taking their turn:\n\n    ```", "```cs\n\n     3.  In `VerifyMatchState`, add the following at the top of the method to check that the game isn’t over already:\n\n    ```", "```cs\n\n     4.  In `VerifyMatchState`, add the following at the top of the method to check that the game object exists:\n\n    ```", "```cs\n\nNow that we have created these helper methods, we can implement the `ProcessTurn` method by following these steps:\n\n1.  Deserialize the arguments that are passed to the `ProcessTurn` function using `JsonSerializer`, as follows:\n\n    ```", "```cs\n\n     2.  In the `ProcessTurn` method, we can call `ValidateProcessTurnRequest`. If there is an error, we can handle it, as follows:\n\n    ```", "```cs\n\n     3.  With the arguments verified, we can query the database for the game, and fail if it doesn’t exist:\n\n    ```", "```cs\n\n     4.  Now, we can call `VerifyGameState`. If there is an error, we can handle it, as follows:\n\n    ```", "```cs\n\n     5.  We must do one final check before making the move and updating the scores – we need to check to see whether the player made their selection before their turn expired using the following code:\n\n    ```", "```cs\n\nWith the validation of the input and game out of the way, we can now focus on applying the player’s move to the current state of the game, updating the score, and determining a winner. To make the code for updating the score simpler, we will need a complex data structure. Let’s explore this further.\nWhen a player chooses a location to place one of their sticks, it may complete a square. If it does, then the player who placed the stick gets the square and an additional five points. The trick is how to determine that a stick has completed a square. We are storing the state of all sticks and stones as an array of integers. What we need is a map from a stone index (0–8) to the sticks that make up its sides. But we can simplify the logic a bit more once we know what sticks make up a square since we are only interested in a single stick, and a single stick can complete, at most, two squares. So, we can now have a structure that maps each stick position (0–23) to an array of tuples. Each tuple has an integer that is the index for the stone and another integer array that is the other three stick indexes that make up the square.\nLet’s use an example to illustrate this. Pretend that we have a game that’s in the following state:\n![Figure 9.12 – Sample view of the board game](img/B19214_09_13.jpg)\n\nFigure 9.12 – Sample view of the board game\nNow, pretend that a player has chosen to place their stick at location 9, highlighted in aqua:\n![Figure 9.13 – Board game with stick placement highlighted](img/B19214_09_14.jpg)\n\nFigure 9.13 – Board game with stick placement highlighted\nWe will only need to check the two squares highlighted in brown. This means that we need to check whether there are sticks in positions 2, 5, and 6 for the stone in the upper brown box, and 12, 13, and 16 for the stone in the lower brown box.\nThis means we need two tuples – one for stone 2 and a second for stone 5 – each with an array of integers of the sides – f example, { (2, {2, 5, 6} ), (5, {12, 13, 16) }. Using that data, we can check the two possible squares that could be completed by placing a stick at position 9.\nUsing old-fashioned sticky notes with a pencil and eraser, we can determine that the complete mapping will look like this:\n\n```", "```cs\n\n Add the preceding code to the `GameHub` class after the `turnHandler` field declaration. Now that we have declared the data structure for finding completed boxes, let’s continue processing the turn:\n\n1.  Return the `ProcessTurn` method, and add the following code at the end:\n\n    ```", "```cs\n\n    This will assign the position `-1` or `1`, depending on who the active player is. We will use a value of `-1` and `1` later in determining a winner, in the case of three stones in a row.\n\n     2.  Now that we have placed the stick, we need to adjust the player’s score, as follows:\n\n    ```", "```cs\n\n     3.  The following code will use the data structure from earlier to determine whether placing the stick completed any squares:\n\n    ```", "```cs\n\n    This code will iterate over the tuples declared at the array position of the newly placed stick, adjusting for C# arrays being 0-based. It will then use the array of stick positions from the tuple to index into the array of sticks in the match The value at that location will be either `1` for player one, `-1` for player two, or `0` for unclaimed. We can add the absolute value of all three locations and if it is 3, then the newly placed stick completes a box. If so, then assign the stone location from the tuple, adjusting for 0-based arrays again, to the player, and give them five points.\n\n     4.  To help determine whether the match is over, we are going to use a couple of helper functions to make the code cleaner and easier to read. The first of those returns a `boolean` value if all the sticks have been played in the match. Add the following code to the end of the `GameHub` class:\n\n    ```", "```cs\n\n    This function uses a straightforward LINQ query to search the `Sticks` array for any element that has a value of `0`, meaning unclaimed. If there are, the function returns.\n\n     5.  The next function is a little more complex as it is used to determine whether a player has three stones in a row, either horizontally, vertically, or diagonally, and returns the `Id` value of the player that does. Add the following code to the end of the `GameHub` class:\n\n    ```", "```cs\n\n    This method starts by checking all the rows and columns for 3 stones in a row, for the same player. Since there are nine stones arranged in a 3x3 grid, we only need to check three columns and three rows. Using a single iterator, each row or column is checked by adding the values stored at each position in the row or column and if the absolute value of the sum is 3, then a single player has a winning row. If the sum is positive, player one has won; otherwise, player two has won. Since there are only two possible diagonals, those checks use the same logic but are done individually, rather than looping.\n\n     6.  Now, we can use those two functions to determine whether there is a winner. To do so, we can use the following code at the end of the `ProcessTurn` function:\n\n    ```", "```cs\n\n    Here, we use the two methods we just created to do the main checks and assign the winner. We capture the winner as the `Guid` type from the `Id` property of the `Player` class, so some translation is needed.\n\n     7.  Next, we can set the next player’s turn, or if there is a winner, complete the match, as follows:\n\n    ```", "```cs\n\n     8.  The final steps are to save any changes we have made and send updates to the players. We will use a helper method called `SaveGameAndSendUpdates` to handle that as we will need the same code when a turn expires. Add the following code to the end of the `GameHub` class:\n\n    ```", "```cs\n\nThis function will save the current match state to the database, then sends a message to the SignalR group for the match indicating that there have been updates to the match. If the match is over, then we remove the players from the group.\n\n1.  The following final three lines of code complete the `ProcessTurn` method:\n\n    ```", "```cs\n\n    After saving the match changes and notifying the players of the match updates, if the match is not over yet, we notify the next player that it is their turn to play. To wrap things up we return the updated match object back to the player that just made their move.\n\n     2.  We also need to call `SaveGameAndSendUpdates` when there is an error after calling `VerifyGameState`. Modify that section of code in `ProcessTurn` using the following snippet:\n\n    ```", "```cs\n\nWe have now completed all the required functions to connect a player to the service, challenge another player to a match, and then process each player’s turn and determine the winner.\nLet’s take a short look back at what we have accomplished so far in this chapter. We started by creating the Azure services that our game server backend would need, a SignalR service for real-time communication, and finally, the Functions service to host our backend functions. We then implemented the Azure functions that would provide the functionality for our game:\n\n*   `Connect`: To register players to the game service\n*   `IssueChallenge`: To allow one player to request a game with another player\n*   `AcknowledgeChallenge`: To accept or decline a request\n*   `ProcessTurn`: To manage the gameplay between two players and determine the winner\n\nOur backend is now complete, and we are ready to publish it to Azure so that we can consume the services from the game app in *Chapter 10*.\nDeploying the functions to Azure\nThe final step in this chapter is to deploy the functions to Azure. You can do that as a part of a **continuous integration/continuous deployment** (**CI/CD**) pipeline – for example, with Azure DevOps. But the easiest way to deploy the functions, in this case, is to do it directly from Visual Studio. Perform the following steps to deploy the functions:\n\n1.  Right-click on the `SticksAndStones.Functions` project and select **Publish**.\n2.  Select **Azure** as the destination for publishing and click **Next**:\n\n![Figure 9.14 – Target selection when publishing](img/B19214_09_15.jpg)\n\nFigure 9.14 – Target selection when publishing\n\n1.  Choose **Azure Function App (Windows)** in the **Specific target** tab, then click **Next**:\n\n![Figure 9.15 – Container selection when publishing](img/B19214_09_16.jpg)\n\nFigure 9.15 – Container selection when publishing\n\n1.  Sign in to the same Microsoft account that we used in the Azure portal when we were creating the **Function** **App** resource.\n2.  Select the subscription that contains the function app. All function apps we have in the subscription will now be loaded.\n3.  Select the function app and click **Finish**. If your app isn’t showing up, click **Back** and choose the **Azure Function App (Linux)** option as you may not have changed the default when creating the service in the *Creating the Azure service for* *functions* section.\n4.  When the profile is created, click the **Publish** button.\n\nThe following screenshot shows the last step. After that, the publishing profile will be created:\n![Figure 9.16 – Publishing Azure functions](img/B19214_09_17.jpg)\n\nFigure 9.16 – Publishing Azure functions\nSummary\nIn this chapter, we started by learning about a few Azure services, including SignalR, and Functions. Then, we created the services in Azure that our game server backend would need – a SignalR service for real-time communication, and finally, the Functions service to host our backend functions. After this, we implemented the Azure functions that would provide the functionality for our game.\nWe wrapped up this chapter by publishing our function code to the Azure Functions instance in Azure.\nIn the next chapter, we will build a game app that will use the backend we have built in this project.\n\n```"]