<html><head></head><body>
        

                            
                    Working with Data Bindings
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Working with CLR properties and UI notifications</li>
<li>Working with dependency properties</li>
<li>Working with attached properties</li>
<li>Data binding to an object</li>
<li>Data binding to a collection</li>
<li>Element-to-element data binding</li>
<li>Sorting data in a <kbd>DataGrid</kbd> control</li>
<li>Grouping data in a <kbd>DataGrid</kbd> control</li>
<li>Filtering data in a <kbd>DataGrid</kbd> control</li>
<li>Using static bindings</li>
<li>Using value converters</li>
<li>Using multi-value converters</li>
</ul>
<h1 id="uuid-ceb5307a-3ca8-4526-a705-31fcd41ac0e6" class="chapter-content">Introduction</h1>
<p><strong>Data binding</strong> is a technique to establish a connection between the UI of the application and the business logic in order to have proper data synchronization between them. Though you can directly access UI controls from code behind to update their content, data binding has become the preferred way to update the UI layer for its automatic notification system.</p>
<p>To make data binding work in WPF applications, both sides of the binding must provide a change notification to the other side. The source property of a data binding can be a .NET CLR property or a dependency property, but the target property must be a dependency property, as shown here:</p>
<div><img src="img/14330605-76a3-417e-b2ec-fca74e9203e9.png" style=""/></div>
<p>Data binding is typically done in XAML using the <kbd>{Binding}</kbd> markup extension. In this chapter, we are going to learn more about the WPF data binding mechanism by exploring a few recipes.</p>
<h1 id="uuid-a46c045b-cdf0-4959-ad43-1564ac2358b0" class="chapter-content">Working with CLR properties and UI notifications</h1>
<p>The CLR properties are just a wrapper around the private variables to expose getters and setters to retrieve and assign the value of a variable. You can use these normal CLR properties in data binding, but the automatic UI notifications are not possible by default, unless you create the notification mechanism.</p>
<p>In this recipe, we will learn how to perform data binding with CLR properties and then learn how to trigger notifications from the code to automatically update the UI when the value changes.</p>
<h2 id="uuid-ccc2a4c2-e224-45d0-bf11-89b3aa0fe8bf" class="chapter-content">Getting ready</h2>
<p>To get started with data binding with normal CLR properties, open your Visual Studio IDE and create a new WPF application project called <kbd>CH04.NotificationPropertiesDemo</kbd>.</p>
<h2 id="uuid-926e548b-c9c2-443a-b6c4-421e9fbedf71">How to do it...</h2>
<p>Perform the following steps to create CLR properties that send notifications to the UI:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file and give the window a name. For example, name the current window  <kbd>window</kbd> by adding the following syntax to the <kbd>Window</kbd> tag: <kbd>x:Name="window"</kbd>.</li>
<li>Now divide the default <kbd>Grid</kbd> into a few rows and columns. Copy the following XAML markup inside your <kbd>Grid</kbd> panel:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition Width="Auto"/&gt; 
    &lt;ColumnDefinition Width="15"/&gt; 
    &lt;ColumnDefinition Width="*"/&gt; 
&lt;/Grid.ColumnDefinitions&gt; 
&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="10"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
&lt;/Grid.RowDefinitions&gt; </pre>
<ol start="3">
<li>Once the grid has been divided into rows and columns, let's add a few text and button controls inside it. Place these at proper cells, as shared in the following code:</li>
</ol>
<pre style="padding-left: 90px">&lt;!-- Row 0 --&gt; 
&lt;TextBlock Text="Your department" 
           Grid.Row="0" Grid.Column="0"/&gt; 
&lt;TextBlock Text=":" 
           Grid.Row="0" Grid.Column="1" 
           HorizontalAlignment="Center"/&gt; 
&lt;TextBlock Text="{Binding Department, ElementName=window}" 
           Margin="0 2" 
           Grid.Row="0" Grid.Column="2"/&gt; 
 
&lt;!-- Row 1 --&gt; 
&lt;TextBlock Text="Your name" 
           Grid.Row="1" Grid.Column="0"/&gt; 
&lt;TextBlock Text=":" 
           Grid.Row="1" Grid.Column="1" 
           HorizontalAlignment="Center"/&gt; 
&lt;TextBox Text="{Binding PersonName, ElementName=window, Mode=TwoWay}" 
         Margin="0 2" 
         Grid.Row="1" Grid.Column="2"/&gt; 
 
&lt;!-- Row 3 --&gt; 
&lt;StackPanel Orientation="Horizontal" 
            HorizontalAlignment="Center" 
            Grid.Row="3" Grid.Column="0" 
            Grid.ColumnSpan="3"&gt; 
    &lt;Button Content="Submit" 
            Margin="4" Width="80" 
            Click="OnSubmit"/&gt; 
    &lt;Button Content="Reset" 
            Margin="4" Width="80" 
            Click="OnReset"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="4">
<li>Now open the code behind the file <kbd>MainWindow.xaml.cs</kbd> and add two CLR properties named <kbd>Department</kbd> and <kbd>PersonName</kbd> inside it. The first property (<kbd>Department</kbd>) always returns a constant string, whereas the second property (<kbd>PersonName</kbd>) can accept values from the user. Here's the complete code:</li>
</ol>
<pre style="padding-left: 90px">public string Department { get { return "Software Engineering"; } } 
 
private string personName; 
public string PersonName 
{ 
    get { return personName; } 
    set { personName = value; } 
} </pre>
<ol start="5">
<li>In the code-behind class, add the following event implementations:</li>
</ol>
<pre style="padding-left: 90px">private void OnSubmit(object sender, RoutedEventArgs e) 
{ 
    MessageBox.Show("Hello " + PersonName); 
} 
 
private void OnReset(object sender, RoutedEventArgs e) 
{ 
    PersonName = string.Empty; 
}</pre>
<ol start="6">
<li>Now build and run the application. As shown in the following screenshot, enter your name in the <kbd>TextBox</kbd> and click the Submit button. A message will be shown to the user with the entered name:</li>
</ol>
<div><img src="img/221e6c32-5d83-4f94-9ef1-2062272bf311.png" style=""/></div>
<ol start="7">
<li>Now click on the Reset button and watch the behavior. Even though the code has been written to set the property with an empty string, the UI was not modified:</li>
</ol>
<div><img src="img/8bee4bd9-c134-48b7-9348-7e56371f9fab.png" style=""/></div>
<ol start="8">
<li>To send a notification to the UI when there is a change in the associated property, you need to implement the <kbd>INotifyPropertyChanged</kbd> interface, present in the <kbd>System.ComponentModel</kbd> namespace. Open the <kbd>MainWindow.xaml.cs</kbd> file and add the<kbd>INotifyPropertyChanged</kbd> interface as defined here:</li>
</ol>
<pre style="padding-left: 90px">public partial class MainWindow : Window, INotifyPropertyChanged</pre>
<ol start="9">
<li>You need to add the following <kbd>using</kbd> namespace declaration to resolve the build issue:</li>
</ol>
<pre style="padding-left: 90px">using System.ComponentModel; </pre>
<ol start="10">
<li>Add the following <kbd>PropertyChanged</kbd> event implementation inside the class:</li>
</ol>
<pre style="padding-left: 90px">public event PropertyChangedEventHandler PropertyChanged; 
public void OnPropertyChanged(string propertyName) 
{ 
    //in C# 7.0 and above 
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); 
 
    //prior to C# 7.0 
    //var handler = PropertyChanged; 
    //if (handler != null) 
    //{ 
    //    handler(this, new PropertyChangedEventArgs(propertyName)); 
    //} 
} </pre>
<ol start="11">
<li>Now notify the framework to update the UI when there is a change in the property value. Modify the existing implementation of the <kbd>PersonName</kbd> property to give a call to the <kbd>OnPropertyChanged</kbd> event, passing the name of the property as follows:</li>
</ol>
<pre style="padding-left: 90px">private string personName; 
public string PersonName 
{ 
    get { return personName; } 
    set  
    {  
          personName = value;  
          OnPropertyChanged("PersonName");  
    } 
} </pre>
<p>If you are using C# 6 and above, you can remove the hardcoded strings by using the <kbd>nameof</kbd> operator.</p>
<ol start="12">
<li>Build and run the application once again. Enter your name in the input box and hit the Submit button. You will see the message box mentioning the entered name.</li>
<li>Close the message box and hit the Reset button. You will see that the text in the <kbd>TextBox</kbd> initialized to an empty string:</li>
</ol>
<div><img src="img/18267dcb-d8c5-4cc0-86a8-4eed1d270284.png" style=""/></div>
<h2 id="uuid-032d39f2-81e9-40ca-b6c3-7a9c012ddfc7">How it works...</h2>
<p>In the preceding example, the <kbd>Department</kbd> property has a data binding with the <kbd>TextBlock</kbd> control and thus the associated <kbd>TextBlock</kbd> displays the text returned by the property. Similarly, the <kbd>PersonName</kbd> property has a data binding with a <kbd>TextBox</kbd> control. As the data binding has been made to the <kbd>Text</kbd> property of the <kbd>TextBlock</kbd> (with <kbd>TwoWay</kbd> mode), it automatically updates the associated property when the user changes it in the UI.</p>
<p>So, when you hit the Submit button, the <kbd>OnSubmit</kbd> event triggers, and it directly reads the <kbd>PersonName</kbd> property instead of fetching the text from the UI by accessing the <kbd>Text</kbd> property of the <kbd>TextBox</kbd> control.</p>
<p>When you hit the Reset button, the <kbd>OnReset</kbd> event triggers and it sets the <kbd>PersonName</kbd> property to an empty string. But the UI does not change. This is because the CLR property does not have a notification mechanism to automatically update the UI when a value change happens to it.</p>
<p>To overcome this, WPF uses the <kbd>INotifyPropertyChanged</kbd> interface, which defines a <kbd>PropertyChanged</kbd> event to automatically push the UI notification to update the elements in the UI thread. In the example, when you set the <kbd>PersonName</kbd> property, the <kbd>OnPropertyChanged</kbd> event fires from the property <kbd>setter</kbd> and notifies the UI that the <kbd>PersonName</kbd> has been modified. The UI then sets the value based on the property value.</p>
<h2 id="uuid-bbabc39e-47e2-4c39-843b-eb32a8af1fed">There's more...</h2>
<p>Data binding can be unidirectional (source &gt; target or target &gt; source) or bidirectional (source &lt; &gt; target), known as <strong>mode</strong>, and is defined in four categories:</p>
<ul>
<li><strong>OneTime</strong>: This type of data binding mode causes the source property to initialize the target property. After the binding gets generated, no notifications will be triggered. You should use this type of data binding where the source data does not change.</li>
<li><strong>OneWay</strong>: This type of binding causes the source property to automatically update the target property. The reverse is not possible here. For example, if you want to display a label/text in the UI based on some condition in the code behind or business logic, you need to use <kbd>OneWay</kbd> data binding as you don't need to update back the property from the UI.</li>
<li><strong>TwoWay</strong>: This type of binding is a bidirectional data binding, where both the source property and the target property can send update notifications. This is applicable for editable forms where the user can change the value displayed in the UI. For example, the <kbd>Text</kbd> property of a <kbd>TextBox</kbd> control supports this type of data binding.</li>
<li><strong>OneWayToSource</strong>: This is another unidirectional data binding, which causes the target property to update the source property (the reverse of <kbd>OneWay</kbd> binding). Here, the UI sends notification to the context and no notification is generated if the context changes.</li>
</ul>
<p>Here's a simple diagram, describing how the various data binding modes work:</p>
<div><img src="img/0d2f78d4-084b-4607-a235-b0bdd9776aed.png" style=""/></div>
<h1 id="uuid-e72ad175-f2b5-48a7-95be-17d2c46d4ed5">Working with dependency properties</h1>
<p>WPF provides a set of services which can be used to extend the CLR properties to provide additional benefits such as automatic UI notifications in the ecosystem. To implement the dependency property, the class must be inherited from the <kbd>DependencyObject</kbd> class.</p>
<p>A CLR property reads directly from the private member of the class, whereas a dependency property is stored in a dictionary of keys and values provided by the base class. As the dependency property stores the property only when it is changed, it uses a great deal less memory and is accessed faster.</p>
<p>To easily create a dependency property in a <kbd>.cs</kbd> file, use the <kbd>propdp</kbd> code snippet. In any class file which is inherited from <kbd>DependencyObject</kbd>, write <kbd>propdp</kbd> followed by <em>TAB</em> to generate the structure of it. Navigate using the <em>TAB</em> key and change the type, name, owner, and metadata details.</p>
<p>In this recipe, we will learn how to use a dependency property to automatically notify the UI that a change has been made in the property value, which will reduce the burden of defining the <kbd>PropertyChanged</kbd> event from the <kbd>INotifyPropertyChanged</kbd> interface.</p>
<h2 id="uuid-cde4bc49-8579-4899-9709-4b39cc10fe08">Getting ready</h2>
<p>Let's open the Visual Studio IDE and create a project named <kbd>CH04.DependencyPropertyDemo</kbd>. Make sure that you have selected the WPF application type as a project template. We will use the same example that we have created in the previous recipe.</p>
<h2 id="uuid-33fa5580-079a-4427-a250-aed4306266d7">How to do it...</h2>
<p>Perform the following steps to create a dependency property, bind it to the UI, and send notifications from the code:</p>
<ol>
<li>From Solution Explorer, open the <kbd>MainWindow.xaml</kbd> page and use the same UI design that we have used in the previous example. Copy the following XAML markup and replace the content of the <kbd>MainWindow.xaml</kbd> file:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH04.DependencyPropertyDemo.MainWindow" 
  
        x:Name="window" 
        Title="Dependency Properties Demo" Height="150"  <br/>        Width="300"&gt; 
    &lt;Grid Margin="10"&gt; 
        &lt;Grid.ColumnDefinitions&gt; 
            &lt;ColumnDefinition Width="Auto"/&gt; 
            &lt;ColumnDefinition Width="15"/&gt; 
            &lt;ColumnDefinition Width="*"/&gt; 
        &lt;/Grid.ColumnDefinitions&gt; 
        &lt;Grid.RowDefinitions&gt; 
            &lt;RowDefinition Height="Auto"/&gt; 
            &lt;RowDefinition Height="Auto"/&gt; 
            &lt;RowDefinition Height="10"/&gt; 
            &lt;RowDefinition Height="Auto"/&gt; 
        &lt;/Grid.RowDefinitions&gt; 
 
        &lt;!-- Row 0 --&gt; 
        &lt;TextBlock Text="Your department" 
                   Grid.Row="0" Grid.Column="0"/&gt; 
        &lt;TextBlock Text=":" 
                   Grid.Row="0" Grid.Column="1" 
                   HorizontalAlignment="Center"/&gt; 
        &lt;TextBlock Text="{Binding Department,  
                          ElementName=window}" 
                   Margin="0 2" 
                   Grid.Row="0" Grid.Column="2"/&gt; 
 
        &lt;!-- Row 1 --&gt; 
        &lt;TextBlock Text="Your name" 
                   Grid.Row="1" Grid.Column="0"/&gt; 
        &lt;TextBlock Text=":" 
                   Grid.Row="1" Grid.Column="1" 
                   HorizontalAlignment="Center"/&gt; 
        &lt;TextBox Text="{Binding PersonName,  
                        ElementName=window, Mode=TwoWay}" 
                 Margin="0 2" 
                 Grid.Row="1" Grid.Column="2"/&gt; 
 
        &lt;!-- Row 3 --&gt; 
        &lt;StackPanel Orientation="Horizontal" 
                    HorizontalAlignment="Center" 
                    Grid.Row="3" Grid.Column="0" 
                    Grid.ColumnSpan="3"&gt; 
            &lt;Button Content="Submit" 
                    Margin="4" Width="80" 
                    Click="OnSubmit"/&gt; 
            &lt;Button Content="Reset" 
                    Margin="4" Width="80" 
                    Click="OnReset"/&gt; 
        &lt;/StackPanel&gt; 
    &lt;/Grid&gt; 
&lt;/Window&gt; </pre>
<ol start="2">
<li>Now open the code-behind file and add the following CLR property inside the class. We don't need to make it a dependency property, as the value is always constant here:</li>
</ol>
<pre style="padding-left: 90px">public string Department  
{  
    get { return "Software Engineering"; }  
} </pre>
<ol start="3">
<li>Now, inside the class, write <kbd>propdp</kbd> and press the <em>TAB</em> key twice. It will create the structure of the property system. By default, <kbd>int</kbd> will be highlighted. Replace it with <kbd>string</kbd>.</li>
<li>Press the <em>TAB</em> key once again and rename the property name from <kbd>MyProperty</kbd> to <kbd>PersonName</kbd>.</li>
<li>Press the <em>TAB</em> key once again to change the focus to the <kbd>ownerclass</kbd> name parameter of the <kbd>Register</kbd> method. Rename it to the class name of the owner. In our case, it is <kbd>MainWindow</kbd>.</li>
<li>Press the <em>TAB</em> key once again to move the focus to the property metadata. Here you can set the default value of the property. By default, <kbd>0</kbd> (zero) is selected. Change it to <kbd>string.Empty</kbd>. Here's the complete implementation of our dependency property, named <kbd>PersonName</kbd>:</li>
</ol>
<pre style="padding-left: 90px">public string PersonName 
{ 
    get { return (string)GetValue(PersonNameProperty); } 
    set { SetValue(PersonNameProperty, value); } 
} 
 
public static readonly DependencyProperty PersonNameProperty = 
    DependencyProperty.Register("PersonName",  
          typeof(string), typeof(MainWindow),  
          new PropertyMetadata(string.Empty)); </pre>
<ol start="7">
<li>Let's add the following event implementations for the Submit and Reset buttons inside the <kbd>MainWindow</kbd> class:</li>
</ol>
<pre style="padding-left: 90px">private void OnSubmit(object sender, RoutedEventArgs e) 
{ 
    MessageBox.Show("Hello " + PersonName); 
} 
 
private void OnReset(object sender, RoutedEventArgs e) 
{ 
    PersonName = string.Empty; 
} </pre>
<ol start="8">
<li>As the code change has been done, let's build and run the application. You will see the application window pop up on the screen. Enter a name in the provided input box and click Submit. The message box will be shown, including the entered text:</li>
</ol>
<div><img src="img/276819c8-4fb5-411c-84bd-71031c93bbf8.png" style=""/></div>
<ol start="9">
<li>Click on the Reset button. This will clear the text inside the input box (<kbd>TextBox</kbd> control):</li>
</ol>
<div><img src="img/d295ae5e-01fa-481f-a798-a1a2f4db2ee2.png" style=""/></div>
<h2 id="uuid-5b750e8f-b6e1-4d55-adef-75a8ac7040bb">How it works...</h2>
<p>The getters and setters work differently in dependency properties. Rather than returning or setting a value from/to its private field (<kbd>CLR</kbd> property), the dependency property calls <kbd>GetValue(DependencyProperty)</kbd> or <kbd>SetValue(DependencyProperty, value)</kbd> from its base class <kbd>DependencyObject</kbd>. In our example, the name of the dependency property is <kbd>PersonNameProperty</kbd>.</p>
<p>The static <kbd>Register</kbd> method of the <kbd>DependencyProperty</kbd> class takes a few parameters to create the <kbd>dependency</kbd> property. The first parameter that it takes is the actual <kbd>name</kbd> of the property. The second parameter is the <kbd>type</kbd> of the property, the third is the <kbd>owner type</kbd> which is basically the class name where the <kbd>dependency</kbd> property is going to create. The next parameter it takes is the metadata information, where you can assign the default value of the property. Here is the complete code:</p>
<pre style="padding-left: 60px">public static readonly DependencyProperty PersonNameProperty = 
    DependencyProperty.Register("PersonName",  
                       typeof(string),  
                       typeof(MainWindow),  
                       new PropertyMetadata(string.Empty)); </pre>
<p>When you set a value from the XAML, by providing a data binding with the property, it sets the value which you can pick from an accessible place. Similarly, when you set the value from code, it automatically notifies the UI that a change has been made and performs the same change in the UI. Thus, it reduces the burden of implementation of the <kbd>INotifyPropertyChanged</kbd> interface and its associated <kbd>PropertyChanged</kbd> event.</p>
<h2 id="uuid-ed5495bf-3bcc-4928-af24-568a312d83fd">There's more...</h2>
<p>The property metadata of the <kbd>Register</kbd> method can take one to three arguments to it. The first one is the default value that we have seen earlier. The second one is the <kbd>PropertyChangedCallback</kbd>, which is to be called by the property system whenever the effective value of the property changes. The third one is the <kbd>CoerceValueCallback</kbd>, which is to be called whenever the property system calls <kbd>System.Windows.DependencyObject.CoerceValue</kbd> method against the property.</p>
<p>Most of the time, the property metadata is created using one to two parameters defining the default value and the property changed callback. Let's learn with an example demonstrating how this can be written:</p>
<pre style="padding-left: 60px">public string PersonName 
{ 
    get { return (string)GetValue(PersonNameProperty); } 
    set { SetValue(PersonNameProperty, value); } 
} 
 
public static readonly DependencyProperty PersonNameProperty = 
    DependencyProperty.Register("PersonName", typeof(string),   <br/>    typeof(MainWindow), new PropertyMetadata(string.Empty,   <br/>    OnPropertyChangedCallback)); 
 
private static void OnPropertyChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e) 
{ 
             
} </pre>
<p>Here, the <kbd>OnPropertyChangedCallback</kbd> event will be raised whenever you change the value of the property. You can take further action based on the event trigger. You can also call other non-static members from the callback event by accessing the <kbd>DependencyObject</kbd> "<kbd>d</kbd>".</p>
<p>You can also validate a dependency property before submitting it to the property system. The fifth parameter of the <kbd>Register</kbd> method accepts a delegate, called <kbd>ValidateValueCallback</kbd>. You can implement it to validate the effective value of the <kbd>dependency</kbd> property. If the value has been validated properly, it will return <kbd>true</kbd>; if not it will be treated as invalid and will return <kbd>false</kbd>.</p>
<h1 id="uuid-7e96bbf9-5229-4c8f-8d7d-da63c230c9f7">Working with attached properties</h1>
<p>An attached property is a kind of <kbd>dependency</kbd> property which is intended to be used as a global property type and is settable on any object. It does not have conventional property wrapper and can still be used to receive notification of a value change. Unlike dependency properties, attached properties are not defined in the same class where they are used.</p>
<p>The main purpose of using attached properties is to allow different child elements to specify unique values of a property, which is actually defined in a parent element. For example, you can use <kbd>Grid.Row</kbd>, <kbd>Grid.Column</kbd> in any child elements of the <kbd>Grid</kbd> panel. Similarly, the <kbd>Canvas.Left</kbd>, <kbd>Canvas.Top</kbd> attached properties are used in any child elements of a <kbd>Canvas</kbd> panel.</p>
<p>In this recipe, we will learn how to create an <kbd>Attached</kbd> property and perform the operation from a different class.</p>
<h2 id="uuid-2fe8293d-b800-4034-bbbb-345fec1375b5">Getting ready</h2>
<p>First, create a new project called <kbd>CH04.AttachedPropertyDemo</kbd>, based on the WPF application project type.</p>
<h2 id="uuid-1aef12a9-db9a-4175-b7f9-a1f8bfa0dced">How to do it...</h2>
<p>Now, perform the following steps to create the <kbd>Attached</kbd> property named <kbd>SelectOnFocus</kbd>, to a <kbd>TextBox</kbd> control, which when enabled will select the text on focus change by using the <em>TAB</em> key:</p>
<ol>
<li>Open Solution Explorer, right-click on the project, and add a new class by following the Add | Class... context menu path. Give the class the name <kbd>TextBoxExtensions</kbd>.</li>
<li>Open the <kbd>TextBoxExtensions.cs</kbd> file and add the following <kbd>using</kbd> namespace inside the class file:</li>
</ol>
<pre style="padding-left: 90px">using System.Windows; 
using System.Windows.Controls; </pre>
<ol start="3">
<li>Inside the class body, type <kbd>propa</kbd> and press <em>TAB</em> twice. This will create the structure of the attached dependency property and the keyboard focus will move to the <kbd>property</kbd> type, which is <kbd>int</kbd> by default. Change it to <kbd>bool</kbd>.</li>
<li>Press <em>TAB</em> again to select <kbd>MyProperty</kbd>. Rename it to <kbd>SelectOnFocus</kbd>.</li>
<li><em>TAB</em> it once again to select the <kbd>ownerclass</kbd> and change it to <kbd>TextBoxExtensions</kbd>.</li>
</ol>
<p> </p>
<ol start="6">
<li>Press <em>TAB</em> to set the property metadata. Set the default value to <kbd>false</kbd>. Set the <kbd>PropertyChangedCallback</kbd> parameter to <kbd>OnSelectOnFocusChanged</kbd>. Here's the complete code, including the callback event:</li>
</ol>
<pre style="padding-left: 90px">public static bool GetSelectOnFocus(DependencyObject obj) 
{ 
    return (bool)obj.GetValue(SelectOnFocusProperty); 
} 
 
public static void SetSelectOnFocus(DependencyObject obj,  
 bool value) 
{ 
    obj.SetValue(SelectOnFocusProperty, value); 
} 
 
public static readonly DependencyProperty SelectOnFocusProperty<br/>     = DependencyProperty.RegisterAttached("SelectOnFocus",  
       typeof(bool),  
       typeof(TextBoxExtensions),  
       new PropertyMetadata(false, OnSelectOnFocusChanged)); 
 
private static void OnSelectOnFocusChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) 
{ 
    if (d is TextBox textBox) 
    { 
        textBox.GotFocus += (s, arg) =&gt; 
        { 
            textBox.SelectAll(); 
        }; 
    } 
} </pre>
<ol start="7">
<li>Now open the <kbd>MainWindow.xaml</kbd> file and replace the existing XAML content with the following one:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH04.AttachedPropertyDemo.MainWindow" 
         
         
         
        Title="Attached Property Demo"  
        Height="150" Width="340"&gt; 
    &lt;StackPanel Margin="15"&gt; 
        &lt;TextBox Text="Normal TextBox Control" 
                 Width="200" Height="30" 
                 Margin="4"/&gt; 
        &lt;TextBox Text="Select On Focus: Enabled" 
                 extensions:TextBoxExtensions.SelectOnFocus="True" 
                 Width="200" Height="30" 
                 Margin="4"/&gt; 
    &lt;/StackPanel&gt; 
&lt;/Window&gt; </pre>
<ol start="8">
<li>Now, build and run the application.</li>
<li>Focus on the first textbox. It won't have any selection by default. Press <em>TAB</em> to move the focus to the second textbox. The entire text of the textbox will be highlighted. Press <em>TAB</em> again to focus on the first textbox. There won't be any selection, as the said attached property was added to the second textbox only.</li>
</ol>
<h2 id="uuid-fe319b70-48c0-4112-af84-09dc33c0c060">How it works...</h2>
<p>Dependency properties are registered by calling the <kbd>DependencyProperty.Register</kbd> method, whereas attached properties are registered by calling the <kbd>DependencyProperty.RegisterAttached</kbd> method. It takes four parameters—the actual name of the property, type of the property, type of the owner, and property metadata.</p>
<p>When you set the property to the control, as an attached property (<kbd>extensions:TextBoxExtensions.SelectOnFocus="True"</kbd>, in our example), in the XAML, it registers it to the WPF property system during the instance load and fires the <kbd>PropertyChangedCallback</kbd> defined in the <kbd>RegisterAttached</kbd> method. In the preceding example, the <kbd>OnSelectOnFocusChanged</kbd> event will be called, which will register the <kbd>GotFocus</kbd> event on the associated <kbd>TextBox</kbd> control to perform the selection of the text.</p>
<p>Instead of a specific control such as <kbd>TextBox</kbd>, you can use <kbd>UIElement</kbd> to generalize the association. In this way, you can apply it to any control, by registering the attached property in the XAML.</p>
<h1 id="uuid-6c12e4ac-438c-45ba-9c26-86e97fb38680">Data binding to an object</h1>
<p>Up to this point, we have learned how to create CLR properties with the <kbd>INotifyPropertyChanged</kbd> interface; we have also learned about the dependency property with a simple data type. There are many instances when you need to bind an object of some class/model to an UI and display its associated properties necessary.</p>
<p>In this recipe, we will learn how to do object data binding to show and retrieve information to and from the user.</p>
<h2 id="uuid-8f5109e6-e616-45bb-9206-a1151a3d745d">Getting ready</h2>
<p>Let's open the Visual Studio instance and create a new project named <kbd>CH04.ObjectBindingDemo</kbd>. Make sure you select the proper WPF application project type.</p>
<h2 id="uuid-f4d96db9-c97f-467d-a781-2d94820ff999">How to do it...</h2>
<p>Perform the following steps to create the model and dependency property, and bind the data to the UI controls, so that, when a change happens in underlying data, it automatically reflects in the UI:</p>
<ol>
<li>First, we need to create a data model. From Solution Explorer, right-click on the project and navigate to the context menu entry Add | Class... and create a class file called <kbd>Person.cs</kbd>.</li>
<li>Replace the content of the <kbd>Person</kbd> class with the following three properties:</li>
</ol>
<pre style="padding-left: 90px">public class Person 
{ 
    public string Name { get; set; } 
    public string Blog { get; set; } 
    public int Experience { get; set; } 
} </pre>
<ol start="3">
<li>Go to Solution Explorer once again and double-click to open the <kbd>MainWindow.xaml.cs</kbd> file. Create a dependency property named <kbd>PersonDetails</kbd> and set its data type as <kbd>Person</kbd>. Also, set its default value to <kbd>null</kbd> as shared here:</li>
</ol>
<pre style="padding-left: 90px">public Person PersonDetails 
{ 
    get { return (Person)GetValue(PersonDetailsProperty); } 
    set { SetValue(PersonDetailsProperty, value); } 
} 
 
public static readonly DependencyProperty PersonDetailsProperty =</pre>
<pre style="padding-left: 90px">    DependencyProperty.Register("PersonDetails",  
                       typeof(Person),  
                       typeof(MainWindow),  
                       new PropertyMetadata(null)); </pre>
<ol start="4">
<li>Just after the <kbd>InitializeComponent()</kbd> method call, inside the constructor of the <kbd>MainWindow</kbd> class, initialize the <kbd>PersonDetails</kbd> property and set it as the <kbd>DataContext</kbd> of the selected class as follows:</li>
</ol>
<pre style="padding-left: 90px">PersonDetails = new Person 
{ 
    Name = "Kunal Chowdhury", 
    Blog = "http://www.kunal-chowdhury.com", 
    Experience = 10 
}; 
 
DataContext = PersonDetails; </pre>
<ol start="5">
<li>Now, as the backend code is ready, let's open the <kbd>MainWindow.xaml</kbd> file to design the UI and do the data binding with our model.</li>
<li>Replace the existing <kbd>Grid</kbd> panel with the following XAML markup:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Margin="10"&gt; 
    &lt;TextBlock Margin="0 0 0 20" 
               TextWrapping="Wrap"&gt; 
        &lt;Run Text="{Binding Name}"/&gt; blogs at &lt;Hyperlink NavigateUri="{Binding Blog}"&gt;&lt;Run Text="{Binding Blog}"/&gt;&lt;/Hyperlink&gt;, and has &lt;Run Text="{Binding Experience}"/&gt; years of experience. 
    &lt;/TextBlock&gt; 
    &lt;StackPanel Orientation="Horizontal"&gt; 
        &lt;TextBlock Text="Enter years of experience:"/&gt; 
        &lt;TextBox Text="{Binding Experience, Mode=TwoWay}" 
                 Margin="10 0" Width="50"/&gt; 
    &lt;/StackPanel&gt; 
&lt;/StackPanel&gt;</pre>
<ol start="7">
<li>Now compile the project and run the application. You will see the following UI:</li>
</ol>
<div><img src="img/15628741-7329-45f9-8b2a-66eb5057bab7.png" style=""/></div>
<h2 id="uuid-dcc21d58-9789-4310-827f-2d52b2ac38b4">How it works...</h2>
<p>The UI of the application has two <kbd>TextBlock</kbd> controls to represent the data and one <kbd>TextBox</kbd> to get input from the user. In the first <kbd>TextBlock</kbd> control, we have multiple <kbd>&lt;Run/&gt;</kbd> commands to bind the data value from the <kbd>Person</kbd> class, along with other static texts and a <kbd>Hyperlink</kbd> to create a link. The data of the UI class is bound to the <kbd>DataContext</kbd>, which is <kbd>PersonDetails</kbd> in our case. The properties binded to the UI come from the <kbd>Person</kbd> class, which is the data type of the <kbd>PersonDetails</kbd> dependency property.</p>
<p>The <kbd>TextBox</kbd> control is bound to the <kbd>Experience</kbd> property, which is again bound to the third <kbd>Run</kbd> command of the first <kbd>TextBlock</kbd>. Hence, it is showing <kbd>10</kbd> in both places. Now change the value of the <kbd>TextBox</kbd> control to <kbd>15</kbd> and press the <em>TAB</em> key to change the focus. This will trigger the <kbd>TextChanged</kbd> event of the <kbd>TextBox</kbd> and modify the underlying property named <kbd>Experience</kbd>. Due to its nature, the notification will be automatically sent to the UI and the <kbd>TextBlock</kbd> control will get updated as follows:</p>
<div><img src="img/7ec33b64-7349-44e1-979b-1f937baa2a16.png" style=""/></div>
<h1 id="uuid-102003a8-d74d-41c9-9cec-5aa4babf7853">Data binding to a collection</h1>
<p>As we learned about object data binding to show a single object on the UI, let's begin with binding a collection of data objects in a UI to display all the records to the user. We will discuss it in this recipe.</p>
<h2 id="uuid-afbdb330-384a-4252-90c4-bfcc34fb4c6c">Getting ready</h2>
<p>Open a Visual Studio instance and create a new project called <kbd>CH04.CollectionBindingDemo</kbd>. Make sure you use the WPF application project template.</p>
<h2 id="uuid-1ec05238-7488-4b93-9116-3ade7da58b04">How to do it...</h2>
<p>Perform the following steps to create a collection data model and bind it to the UI, using a <kbd>DataGrid</kbd> control:</p>
<ol>
<li>Inside the Solution Explorer, right-click on the project. From the context menu, navigate to Add | Class... to create a class file named <kbd>Employee.cs</kbd>.</li>
<li>Open the <kbd>Employee.cs</kbd> file and replace the class implementation with the following code:</li>
</ol>
<pre style="padding-left: 90px">public class Employee 
{ 
    public string FirstName { get; set; } 
    public string LastName { get; set; } 
    public string Department { get; set; } 
} </pre>
<ol start="3">
<li>Navigate to the <kbd>MainWindow.xaml.cs</kbd> file and add the following <kbd>using</kbd> statement to define <kbd>ObservableCollection</kbd> inside the class:</li>
</ol>
<pre style="padding-left: 90px">using System.Collections.ObjectModel; </pre>
<ol start="4">
<li>Inside the <kbd>MainWindow</kbd> class implementation, create a dependency property named <kbd>Employees</kbd>, of type <kbd>ObservableCollection&lt;Employee&gt;</kbd>, as shared here:</li>
</ol>
<pre style="padding-left: 90px">public ObservableCollection&lt;Employee&gt; Employees 
{ 
    get { return (ObservableCollection&lt;Employee&gt;)GetValue(EmployeesProperty); } 
    set { SetValue(EmployeesProperty, value); } 
} 
 
public static readonly DependencyProperty EmployeesProperty = 
    DependencyProperty.Register("Employees",  
             typeof(ObservableCollection&lt;Employee&gt;),  
             typeof(MainWindow),  
             new PropertyMetadata(null)); </pre>
<ol start="5">
<li>Now, just after the <kbd>InitializeComponent()</kbd> method call inside the constructor, write the following code block:</li>
</ol>
<pre style="padding-left: 90px">Employees = new ObservableCollection&lt;Employee&gt; 
{ 
    new Employee 
    { 
        FirstName = "Kunal", LastName ="Chowdhury", 
        Department="Software Division" 
    }, 
 
    new Employee 
    { 
        FirstName = "Michael", LastName ="Washington", 
        Department="Software Division" 
    }, 
 
    new Employee 
    { 
        FirstName = "John", LastName ="Strokes", 
        Department="Finance Department" 
    }, 
}; 
 
dataGrid.ItemsSource = Employees; </pre>
<ol start="6">
<li>Now open the <kbd>MainWindow.xaml</kbd> file and a <kbd>DataGrid</kbd> control inside the default <kbd>Grid</kbd> panel. Create three columns and bind their values to the <kbd>FirstName</kbd>, <kbd>LastName</kbd>, and <kbd>Department</kbd> properties of the <kbd>Employee</kbd> object. Make sure you set the <kbd>AutoGenerateColumns</kbd> property of the <kbd>DataGrid</kbd> to <kbd>False</kbd>. Here's the complete XAML markup:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;DataGrid x:Name="dataGrid" 
              AutoGenerateColumns="False"&gt; 
        &lt;DataGrid.Columns&gt; 
            &lt;DataGridTextColumn Header="First Name"  
                     Binding="{Binding FirstName}"/&gt; 
            &lt;DataGridTextColumn Header="Last Name"  
                     Binding="{Binding LastName}"/&gt; 
            &lt;DataGridTextColumn Header="Department"  
                     Binding="{Binding Department}"/&gt; 
        &lt;/DataGrid.Columns&gt; 
    &lt;/DataGrid&gt; 
&lt;/Grid&gt;</pre>
<ol start="7">
<li>Now build the project and run the application. You will see the following screen, along with the data inside a <kbd>DataGrid</kbd>:</li>
</ol>
<div><img src="img/5fe8ba1a-dccd-4197-bd40-07dbd1818a5f.png" style=""/></div>
<h2 id="uuid-36be9277-b41f-457a-8579-89d15a2d7f26">How it works...</h2>
<p>When you bind a collection of objects to a <kbd>DataGrid</kbd>, it creates data grid rows for each object present in the collection. The column defines the properties exposed by the object.</p>
<p>When the <kbd>AutoGenerateColumns</kbd> property of the <kbd>DataGrid</kbd> is set to <kbd>True</kbd> (default), it automatically creates the columns based on the property list. In this example, we have set the <kbd>AutoGenerateColumns</kbd> property to <kbd>False</kbd> and defined the individual columns explicitly. Using this method, you can define which column to show or hide. Once you set the collection to the <kbd>ItemsSource</kbd> property of the <kbd>DataGrid</kbd>, it populates the rows and columns accordingly.</p>
<h2 id="uuid-6e6edc42-9b35-4818-91ba-d5a898a1c880">There's more...</h2>
<p>You can also define the binding in the XAML. To do this, first open the <kbd>MainWindow.xaml.cs</kbd> and remove the line <kbd>dataGrid.ItemsSource = Employees;</kbd>. Now, go to the <kbd>MainWindow.xaml</kbd> file and give the window a name (<kbd>x:Name="window"</kbd>). Now, set the <kbd>ItemsSource</kbd> property of the <kbd>DataGrid</kbd> control, as mentioned here:</p>
<pre style="padding-left: 90px">&lt;DataGrid ItemsSource="{Binding Employees, ElementName=window}" </pre>
<p>Let's run the application once again, by building the project. You will see the same output on the screen.</p>
<h1 id="uuid-9bc4161e-964a-4ec2-9065-923d632b23be">Element-to-element data binding</h1>
<p>In the last few recipes, we learned how to do object-to-element data binding. Though this is commonly used, you will need element-to-element data binding within the same XAML page to reduce the extra lines of codes in the code-behind file. In this recipe, we will learn how to do this.</p>
<h2 id="uuid-50ac9308-aee3-4740-b85a-de8d0208f655">Getting ready</h2>
<p>First, launch your Visual Studio IDE and create a new WPF application project. Give it the name <kbd>CH04.ElementToElementBindingDemo</kbd>.</p>
<h2 id="uuid-07ee8028-3af2-463d-8649-65f575f84944">How to do it...</h2>
<p>Now perform the following steps to design the UI with a <kbd>TextBlock</kbd> and a <kbd>Slider</kbd> control. Then we will bind the value of the slider control with the <kbd>FontSize</kbd> property of the <kbd>TextBlock</kbd>:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> page and replace the default <kbd>Grid</kbd> panel with the following XAML markup:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;TextBlock FontSize="{Binding Value,  
     ElementName=fontSizeSlider}" 
               Margin="4" 
               HorizontalAlignment="Center" 
               VerticalAlignment="Center"&gt; 
        &lt;Run Text="Font Size:"/&gt; 
        &lt;Run Text="{Binding Value,  
               ElementName=fontSizeSlider}"/&gt; 
    &lt;/TextBlock&gt; 
    &lt;Slider x:Name="fontSizeSlider"  
            Minimum="10" Maximum="40" Value="20" 
            LargeChange="5" 
            VerticalAlignment="Bottom" 
            Margin="10"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="2">
<li>Now build the project and run it. You will see the application UI on the screen, with a <kbd>TextBlock</kbd> and a <kbd>Slider</kbd> control.</li>
<li>Now increase or decrease the slider value to see the change in the UI, as shown in the following screenshot:</li>
</ol>
<div><img src="img/739b0f1e-58be-4931-8db5-03a725eaa071.png" style=""/></div>
<h2 id="uuid-e03dcd44-0ebc-4d13-b87d-369349411810">How it works...</h2>
<p>When you drag the thumb of the slider, it increases or decreases the value of the slider control (<kbd>fontSizeSlider</kbd>, in our example). The <kbd>FontSize</kbd> property of the <kbd>TextBlock</kbd> control is directly bound to the value of the slider. So, when you drag the slider, based on the value, it increases or decreases the font size.</p>
<p>Similarly, the <kbd>TextBlock</kbd> has a few <kbd>Run</kbd> commands. The <kbd>Text</kbd> property of one of the <kbd>Run</kbd> commands is also binded with the slider value, and thus, you can see the number (current value of slider) on the screen as the font size.</p>
<h1 id="uuid-060a50e4-e57a-4168-bf85-f7aa6abf5c6e">Sorting data in a DataGrid control</h1>
<p>The <kbd>DataGrid</kbd> control is used to show a number of records in a tabular format. Rows and columns are used to display the data. Along with other common functionalities, the WPF <kbd>DataGrid</kbd> control offers a default sorting feature. You can also customize this to handle it programmatically. In this recipe, we will learn how to add the sorting feature to <kbd>DataGrid</kbd> and trigger it on demand.</p>
<h2 id="uuid-b3858483-4b2b-44d3-9e51-00c562d12e37">Getting ready</h2>
<p>To get started with this recipe, open your Visual Studio editor and create a new WPF application project, called <kbd>CH04.DataGridSortDemo</kbd>.</p>
<h2 id="uuid-b45f58bf-d904-4078-81b1-5c3dbf811da5">How to do it...</h2>
<p>Perform the following to create a data model, populate it, and bind it to a <kbd>DataGrid</kbd> in the UI. Later, add a <kbd>CheckBox</kbd> control to customize the sorting functionality:</p>
<ol>
<li>To begin, right-click on the Solution Explorer, create a new class file named <kbd>Employee.cs</kbd>, by following the right-click context menu entry Add | Class..., and add a few properties in it:</li>
</ol>
<pre style="padding-left: 90px">public class Employee 
{ 
    public string ID { get; set; } 
    public string FirstName { get; set; } 
    public string LastName { get; set; } 
    public string Department { get; set; } 
}</pre>
<ol start="2">
<li>Open the <kbd>MainWindow.xaml.cs</kbd> file and add a dependency property, <kbd>Employees</kbd>, of type <kbd>ObservableCollection&lt;Employee&gt;</kbd>. Make sure you add the following namespaces, <kbd>System.Collections.ObjectModel</kbd> and <kbd>System.ComponentModel</kbd>, in order to resolve the required classes:</li>
</ol>
<pre style="padding-left: 90px">public ObservableCollection&lt;Employee&gt; Employees 
{ 
    get { return (ObservableCollection&lt;Employee&gt;) GetValue(EmployeesProperty); } 
    set { SetValue(EmployeesProperty, value); } 
} 
 
public static readonly DependencyProperty 
    EmployeesProperty =  
    DependencyProperty.Register("Employees",  
            typeof(ObservableCollection&lt;Employee&gt;),  
            typeof(MainWindow),  
            new PropertyMetadata(null)); </pre>
<ol start="3">
<li>Inside the constructor of the <kbd>MainWindow</kbd> class, initialize the <kbd>Employees</kbd> collection as follows:</li>
</ol>
<pre style="padding-left: 90px">Employees = new ObservableCollection&lt;Employee&gt; 
{ 
    new Employee 
    { 
        ID = "EMP0001", 
        FirstName = "Kunal", LastName = "Chowdhury", 
        Department = "Software Division" 
    }, 
 
    new Employee 
    { 
        ID = "EMP0002", 
        FirstName = "Michael", LastName = "Washington", 
        Department = "Software Division" 
    }, 
 
    new Employee 
    { 
        ID = "EMP0003", 
        FirstName = "John", LastName = "Strokes", 
        Department = "Finance Department" 
    }, 
 
    new Employee 
    { 
        ID = "EMP0004", 
        FirstName = "Ramesh", LastName = "Shukla", 
        Department = "Finance Department" 
    } 
}; </pre>
<ol start="4">
<li>Now open the <kbd>MainWindow.xaml</kbd> page and replace the default <kbd>Grid</kbd> panel with a <kbd>StackPanel</kbd>. Add a <kbd>DataGrid</kbd> control inside it and give it a name (let's say, <kbd>dataGrid</kbd>). Set its <kbd>AutoGenerateColumns</kbd> property to <kbd>False</kbd>.</li>
<li>Create four data grid columns of type <kbd>DataGridTextColumn</kbd> and create the data binding with the properties exposed from the <kbd>Employee</kbd> model. Here's the XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel&gt; 
    &lt;DataGrid x:Name="dataGrid" 
      AutoGenerateColumns="False"&gt; 
        &lt;DataGrid.Columns&gt; 
            &lt;DataGridTextColumn Header="EMP ID"  
                     Binding="{Binding ID}"/&gt; 
            &lt;DataGridTextColumn Header="First Name"  
                     Binding="{Binding FirstName}"/&gt; 
            &lt;DataGridTextColumn Header="Last Name"  
                     Binding="{Binding LastName}"/&gt; 
            &lt;DataGridTextColumn Header="Department"  
                     Binding="{Binding Department}"/&gt; 
        &lt;/DataGrid.Columns&gt; 
    &lt;/DataGrid&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="6">
<li>Now, as the data grid is already in place, assign the <kbd>Employees</kbd> collection as the <kbd>ItemsSource</kbd> property of the data grid. You can do this inside the <kbd>MainWindow.xaml.cs</kbd> file, just after initialization of the <kbd>Employees</kbd> collection:</li>
</ol>
<pre style="padding-left: 90px">dataGrid.ItemsSource = Employees;</pre>
<ol start="7">
<li>If you run the application now, you will see a <kbd>DataGrid</kbd> control with the records that we have added into the collection. You will be able to sort the records by clicking on the column headers, which is the default functionality of the control:</li>
</ol>
<div><img src="img/24cea8ab-2139-4446-9c93-ecf876d2a1e7.png" style=""/></div>
<ol start="8">
<li>Now we need to add a <kbd>CheckBox</kbd> control in the UI to toggle the sort on demand. Let's do this for the <kbd>Department</kbd> column. Add the following <kbd>CheckBox</kbd> inside the <kbd>StackPanel</kbd>, just after the <kbd>DataGrid</kbd> control:</li>
</ol>
<pre style="padding-left: 90px">&lt;CheckBox x:Name="sortByDepartment" 
          Content="Sort by Department"  
          HorizontalAlignment="Right" 
          Margin="10" 
          Click="OnSortByDepartment"/&gt; </pre>
<ol start="9">
<li>Navigate to the <kbd>MainWindow.xaml.cs</kbd> file once again, and add the following event inside the class:</li>
</ol>
<pre style="padding-left: 90px">private void OnSortByDepartment(object sender,  
 RoutedEventArgs e) 
{ 
    var cvs =   <br/>    CollectionViewSource.GetDefaultView(dataGrid.ItemsSource); 
    if (cvs != null &amp;&amp; cvs.CanSort) 
    { 
        cvs.SortDescriptions.Clear(); 
 
        if (sortByDepartment.IsChecked == true) 
        { 
            cvs.SortDescriptions.Add( 
                new SortDescription("Department",  
                ListSortDirection.Ascending)); 
        } 
    } 
}</pre>
<ol start="10">
<li>Now run the application again. You will see a new checkbox, under the data grid. Toggle the selection (check status) and observe the behavior on the UI:</li>
</ol>
<div><img src="img/b3b2a54f-fb4e-4427-9054-bad6cc0464aa.png" style=""/></div>
<h2 id="uuid-4aed5d6a-6500-4ea0-a35c-718837e2fc2d">How it works...</h2>
<p>Once the <kbd>OnSortByDepartment</kbd> event triggers, it gets the default view of the data grid and adds <kbd>SortDescription</kbd> to the <kbd>SortDescriptions</kbd> property of the default view instance. <kbd>SortDescription</kbd> takes the property name as the first argument. It defines the column for which you want to add the sort functionality. The second parameter is the <kbd>ListSortDirection</kbd>, which can be either <kbd>Ascending</kbd> or <kbd>Descending</kbd>.</p>
<p>It's not limited to a single <kbd>SortDescriptor</kbd>. You can add more based on your requirement. At any point of time, when you want to reset the view from the applied sort description, you can call the <kbd>SortDescriptions.Clear()</kbd> method on the view (in our case, it is <kbd>cvs</kbd>).</p>
<h1 id="uuid-793cbe53-c189-488a-bc38-d9e99dd2d8ad">Grouping data in a DataGrid control</h1>
<p>The <kbd>DataGrid</kbd> control also allows you to group the records by field name. In this recipe, we are going to learn how to implement this feature using the <kbd>PropertyGroupDescription</kbd>.</p>
<h2 id="uuid-f9cfc094-ac5e-4ca2-ab3c-413d3098e9d3">Getting ready</h2>
<p>Let's begin with creating a new project called <kbd>CH04.DataGridGroupDemo</kbd>. Make sure you select the WPF application template while creating the project.</p>
<h2 id="uuid-cc2eca87-42d8-4e31-bef0-126d868ee9b2">How to do it...</h2>
<p>Perform the following steps to create groups while displaying records in <kbd>DataGrid</kbd>:</p>
<ol>
<li>Inside the project, create the <kbd>Employee</kbd> model class and expose some properties, like we shared earlier in the <em>Sorting data in a DataGrid control</em> recipe.</li>
<li>Create the same dependency property (<kbd>Employees</kbd>, of type <kbd>ObservableCollection&lt;Employee&gt;</kbd>) in the <kbd>MainWindow.xaml.cs</kbd> file and populate the collection with some data records.</li>
<li>Now open the <kbd>MainWindow.xaml</kbd> file and add the attribute <kbd>x:Name="window"</kbd> to give the <kbd>Window</kbd> a name, so that we can perform element-to-element data binding.</li>
<li>Replace the default <kbd>Grid</kbd> panel with <kbd>StackPanel</kbd> and add a <kbd>DataGrid</kbd> control inside it.</li>
<li>Set the <kbd>ItemsSource</kbd> property of the <kbd>DataGrid</kbd> to bind the <kbd>Employees</kbd> collection, exposed from the code behind as a dependency property:</li>
</ol>
<pre style="padding-left: 90px">ItemsSource="{Binding Employees, ElementName=window}" </pre>
<ol start="6">
<li>Set the <kbd>AutoGenerateColumns</kbd> of the data grid to <kbd>False</kbd>, as we are going to add the columns manually.</li>
<li>As shown in the following XAML snippet, add the four columns to the data grid.</li>
<li>Also, add a <kbd>CheckBox</kbd> control, just after the <kbd>DataGrid</kbd>, to enable it to apply grouping to the records by department name. Here's the complete XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel&gt; 
    &lt;DataGrid x:Name="dataGrid" 
              ItemsSource="{Binding Employees,  
                ElementName=window}" 
              AutoGenerateColumns="False"  
              CanUserAddRows="False"&gt; 
        &lt;DataGrid.Columns&gt; 
            &lt;DataGridTextColumn Header="EMP ID"  
                 Binding="{Binding ID}"/&gt; 
            &lt;DataGridTextColumn Header="First Name"  
                 Binding="{Binding FirstName}"/&gt; 
            &lt;DataGridTextColumn Header="Last Name"  
                 Binding="{Binding LastName}"/&gt; 
            &lt;DataGridTextColumn Header="Department"  
                 Binding="{Binding Department}"/&gt; 
        &lt;/DataGrid.Columns&gt; 
    &lt;/DataGrid&gt; 
    &lt;CheckBox x:Name="groupByDepartment" 
              Content="Group by Department"  
              HorizontalAlignment="Right" 
              Margin="10" 
              Click="OnGroupByDepartment"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="9">
<li>As we are going to add grouping on the <kbd>DataGrid</kbd> records, we need to design the group style. Add the following snippet inside the <kbd>DataGrid</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;DataGrid.GroupStyle&gt; 
    &lt;GroupStyle&gt; 
        &lt;GroupStyle.ContainerStyle&gt; 
            &lt;Style TargetType="{x:Type GroupItem}"&gt; 
                &lt;Setter Property="Margin" Value="0,0,0,5"/&gt; 
                &lt;Setter Property="Template"&gt; 
                    &lt;Setter.Value&gt; 
                        &lt;ControlTemplate TargetType="{x:Type <br/>                         GroupItem}"&gt; 
                            &lt;Expander IsExpanded="True"&gt; 
                                &lt;Expander.Header&gt; 
                                    &lt;TextBlock Text="{Binding   <br/>                                     Path=Name}" <br/>                                     Margin="5,0,0,0"/&gt; 
                                &lt;/Expander.Header&gt; 
                                &lt;Expander.Content&gt; 
                                    &lt;ItemsPresenter /&gt; 
                                &lt;/Expander.Content&gt; 
                            &lt;/Expander&gt; 
                        &lt;/ControlTemplate&gt; 
                    &lt;/Setter.Value&gt; 
                &lt;/Setter&gt; 
            &lt;/Style&gt; 
        &lt;/GroupStyle.ContainerStyle&gt; 
    &lt;/GroupStyle&gt; 
&lt;/DataGrid.GroupStyle&gt;</pre>
<ol start="10">
<li>Now we will need to add the <kbd>OnGroupByDepartment</kbd> event implementation. Open the <kbd>MainWindow.xaml.cs</kbd> and add the following code:</li>
</ol>
<pre style="padding-left: 90px">private void OnGroupByDepartment(object sender,  
 RoutedEventArgs e) 
{ 
    var cvs =  <br/>    CollectionViewSource.GetDefaultView(dataGrid.ItemsSource); 
    if (cvs != null &amp;&amp; cvs.CanGroup) 
    { 
        cvs.GroupDescriptions.Clear(); 
 
        if (groupByDepartment.IsChecked == true) 
        { 
            cvs.GroupDescriptions.Add( 
              new PropertyGroupDescription("Department")); 
        } 
    } 
} </pre>
<ol start="11">
<li>Run the application now. You will see that the UI contains a <kbd>DataGrid</kbd> with some records.</li>
<li>Click on the checkbox that says Group by Department and observe the behavior:</li>
</ol>
<div><img src="img/c3067186-1900-4915-88bb-bdcc02180bd0.png" style=""/></div>
<ol start="13">
<li>Uncheck the checkbox to revert the view to its original state.</li>
</ol>
<h2 id="uuid-7fec4e7d-e3b2-4d70-9bf8-10b218644845">How it works...</h2>
<p>When you trigger the <kbd>OnGroupByDepartment</kbd> event, it retrieves the instance of the default view of <kbd>DataGrid</kbd> and applies the group description to it. The grouping applies based on the property name, passed to the <kbd>PropertyGroupDescription</kbd>, as shared here:</p>
<pre style="padding-left: 60px">cvs.GroupDescriptions.Add( 
         new PropertyGroupDescription("Department")); </pre>
<p>Based on that, the group style applies to the data grid. The template contains an <kbd>Expander</kbd> control with the name of the column to be grouped as the <kbd>Header</kbd>:</p>
<pre style="padding-left: 60px">&lt;Expander IsExpanded="True"&gt; 
    &lt;Expander.Header&gt; 
        &lt;TextBlock Text="{Binding Path=Name}" Margin="5,0,0,0"/&gt; 
    &lt;/Expander.Header&gt; 
    &lt;Expander.Content&gt; 
        &lt;ItemsPresenter /&gt; 
    &lt;/Expander.Content&gt; 
&lt;/Expander&gt; </pre>
<p>You can now expand or collapse the groups and apply sorting or filtering to drill down the data. It helps to find the correct record easily.</p>
<h2 id="uuid-17201077-f65c-4231-8761-c7699661e4fb">There's more...</h2>
<p>You can also modify the <kbd>Expander Header</kbd> to display the number of records inside a group. The <kbd>ItemCount</kbd> property can be used to display the record count. Modify the <kbd>Expander.Header</kbd>, as shared here, to customize it:</p>
<pre style="padding-left: 30px">&lt;Expander.Header&gt; 
    &lt;StackPanel Orientation="Horizontal"&gt; 
        &lt;TextBlock Text="{Binding Path=Name}" Margin="5,0,0,0"/&gt; 
        &lt;StackPanel Orientation="Horizontal"&gt; 
            &lt;TextBlock Margin="5,0,0,0" 
                       Text="{Binding Path=ItemCount}"/&gt; 
            &lt;TextBlock Text=" Item(s)"/&gt; 
        &lt;/StackPanel&gt; 
    &lt;/StackPanel&gt; 
&lt;/Expander.Header&gt; </pre>
<p>Now build and run the application again. Once the window loads, click on the checkbox to group the records by department name. Observe the item count in the expander, as shown here:</p>
<div><img src="img/e2719de3-0fa4-4955-8d25-9b04043577ff.png" style=""/></div>
<h1 id="uuid-ab213a77-e7d6-4d67-962a-194ebabdc4f4">Filtering data in a DataGrid control</h1>
<p>When we display a set of huge records in a <kbd>DataGrid</kbd>, it often becomes difficult for the user to search for and find a particular record from the grid. In such cases, you may want to provide an additional feature to filter the records to a specific search term.</p>
<p>In this recipe, we will learn how to add a search box to filter records in a <kbd>DataGrid</kbd> control.</p>
<h2 id="uuid-eca76671-8626-475c-b343-39d26b2ad979">Getting ready</h2>
<p>Let's start by creating a WPF application project named <kbd>CH04.DataGridFilterDemo</kbd> in your Visual Studio IDE.</p>
<h2 id="uuid-b4dd3822-74c8-4283-a7af-e1f086583d2d">How to do it...</h2>
<p>Now perform the following steps to add the search functionality attached to the grid records:</p>
<ol>
<li>Once the project has been created, add a new <kbd>Employee</kbd> model class inside the project and expose some properties, like we shared earlier in the <em>Sorting data in a DataGrid control</em> recipe.</li>
<li>Create the same dependency property (<kbd>Employees</kbd>, of type <kbd>ObservableCollection&lt;Employee&gt;</kbd>) in the <kbd>MainWindow.xaml.cs</kbd> file and populate the collection with some data records.</li>
<li>Now open the <kbd>MainWindow.xaml</kbd> file and add the attribute <kbd>x:Name="window"</kbd> to give the <kbd>Window</kbd> a name, so that we can perform element-to-element data binding.</li>
<li>Replace the default <kbd>Grid</kbd> panel with a <kbd>StackPanel</kbd>.</li>
<li>Now insert the following horizontal <kbd>StackPanel</kbd>, containing one <kbd>TextBlock</kbd> and one <kbd>TextBox</kbd>, inside the root <kbd>StackPanel</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal" 
            HorizontalAlignment="Right" 
            Margin="4 8"&gt; 
    &lt;TextBlock Text="Filter records: "/&gt; 
    &lt;TextBox x:Name="searchBox" Width="100" 
             TextChanged="OnFilterChanged"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="6">
<li>Add a <kbd>DataGrid</kbd> control, having four columns inside it. Set the <kbd>AutoGenerateColumns</kbd> to <kbd>False</kbd> and add the data binding of the <kbd>ItemsSource</kbd> property with the <kbd>Employees</kbd> collection (<kbd>ItemsSource="{Binding Employees, ElementName=window}"</kbd>). Here's the complete code for reference:</li>
</ol>
<pre style="padding-left: 90px">&lt;DataGrid x:Name="dataGrid" 
          AutoGenerateColumns="False" 
          CanUserAddRows="False" 
          ItemsSource="{Binding Employees,  
           ElementName=window}"&gt; 
    &lt;DataGrid.Columns&gt; 
        &lt;DataGridTextColumn Header="EMP ID"  
             Binding="{Binding ID}"/&gt; 
        &lt;DataGridTextColumn Header="First Name"  
             Binding="{Binding FirstName}"/&gt; 
        &lt;DataGridTextColumn Header="Last Name"  
             Binding="{Binding LastName}"/&gt; 
        &lt;DataGridTextColumn Header="Department"  
             Binding="{Binding Department}"/&gt; 
    &lt;/DataGrid.Columns&gt; 
&lt;/DataGrid&gt; </pre>
<ol start="7">
<li>Now navigate to the <kbd>MainWindow.xaml.cs</kbd> file, and add the following code blocks to implement the <kbd>OnFilterChanged</kbd> event that gets triggered whenever any text changes in the <kbd>searchBox</kbd>:</li>
</ol>
<pre style="padding-left: 90px">private void OnFilterChanged(object sender,  
 TextChangedEventArgs e) 
{ 
    var cvs = <br/>    CollectionViewSource.GetDefaultView(dataGrid.ItemsSource); 
    if (cvs != null &amp;&amp; cvs.CanFilter) 
    { 
        cvs.Filter = OnFilterApplied; 
    } 
} 
 
private bool OnFilterApplied(object obj) 
{ 
    if(obj is Employee emp) 
    { 
        var searchText = searchBox.Text.ToLower(); 
        return  
           emp.Department.ToLower().Contains(searchText) || 
           emp.FirstName.ToLower().Contains(searchText) || 
           emp.LastName.ToLower().Contains(searchText); 
    } 
 
    return false; 
}</pre>
<ol start="8">
<li>Let's build the project and run the application. You will see the following UI on the screen:</li>
</ol>
<div><img src="img/8bb6ba8f-4aba-4b77-a93e-d2f72014d403.png" style=""/></div>
<ol start="9">
<li>Now filter the records by entering some search term in the textbox. Let's enter <kbd>Finance</kbd> as the keyword and see the behavior:</li>
</ol>
<div><img src="img/c3e64cdd-119f-4849-95de-7c313a82c997.png" style=""/></div>
<ol start="10">
<li>
<p>If you change the search term to perform the following from the records, it will filter out only those records.</p>
</li>
</ol>
<h2 id="uuid-a0291220-7062-4ff2-92b8-7f65704efc2d">How it works...</h2>
<p>When you enter a search term, it fires the event <kbd>OnFilterChanged</kbd> and retrieves the default view of the <kbd>DataGrid</kbd>. It exposes a property named <kbd>Filter</kbd>, which is a predicate. In our example, we assigned the predicate <kbd>OnFilterApplied</kbd> on the <kbd>Filter</kbd> property, which, when called, compares the term with <kbd>Department</kbd>, <kbd>FirstName</kbd>, <kbd>LastName</kbd>, and returns <kbd>true</kbd> if a match is found. Based on the <kbd>boolean</kbd> value, it shows the said record.</p>
<h1 id="uuid-4c6e9d86-5e56-42c0-8ed8-60e50ac2c66a">Using static bindings</h1>
<p>Often, we use static properties in our applications. Along with WPF 4.5, Microsoft provided us with the option to use static properties in XAML markup, while performing data binding. In this recipe, we will learn how to create such bindings. These can be useful in the next recipes while using Converters, Styles, and Templates.</p>
<h2 id="uuid-bf0b2e8a-4c2d-4b1d-a885-6e147801460c">Getting ready</h2>
<p>Let's start by creating a new project, called <kbd>CH04.StaticBindingDemo</kbd>. Open your Visual Studio IDE and select the WPF application project as the project template.</p>
<h2 id="uuid-5fd781e4-4053-4410-985a-bcf0e3b43252">How to do it...</h2>
<p>Once the project has been created, perform the following steps to learn static binding:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> page and add a <kbd>Label</kbd> inside the <kbd>Grid</kbd> panel. Give it a background color (let's say, <kbd>OrangeRed</kbd>) and run the application. This is what we use most often to write hardcoded values inline:</li>
</ol>
<pre style="padding-left: 90px">&lt;Label Background="OrangeRed" 
       Content="Kunal Chowdhury" 
       FontSize="25" 
       Width="300" Height="60" 
       Padding="10" Margin="10"/&gt; </pre>
<ol start="2">
<li>Now, let's change it to set a background color from the system defined colors. To do this, we need to use <kbd>{x:Static}</kbd> markup extension to access the static properties. Here's how the code will be changed:</li>
</ol>
<pre style="padding-left: 90px">&lt;Label Background="{x:Static  
  SystemColors.ControlDarkBrush}" 
       Content="Kunal Chowdhury" 
       FontSize="25" 
       Width="300" Height="60" 
       Padding="10" Margin="10"/&gt;</pre>
<ol start="3">
<li>You can also access locally defined resources, within the XAML page or defined in a centralized <kbd>ResourceDictionary</kbd>. Let's define a color within the same page, under <kbd>Window</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;SolidColorBrush Color="GreenYellow"  
      x:Key="myBrush"/&gt; 
&lt;/Window.Resources&gt; </pre>
<ol start="4">
<li>Add a <kbd>Foreground</kbd> property to the label, to assign its foreground color. Let's bind it with the static resource (<kbd>myBrush</kbd>), that we defined earlier. Here's the code for reference:</li>
</ol>
<pre style="padding-left: 90px">&lt;Label Background="{x:Static  
  SystemColors.ControlDarkBrush}" 
       Foreground="{StaticResource myBrush}" 
       Content="Kunal Chowdhury" 
       FontSize="25" 
       Width="300" Height="60" 
       Padding="10" Margin="10"/&gt; </pre>
<ol start="5">
<li>Now let's build and run the application. You will see the colors similar to the following screenshot, where the background will have a light gray color (based on the color set to your system's <kbd>ControlDarkBrush</kbd>) and the foreground will have a greenish yellow color:</li>
</ol>
<div><img src="img/b2f60b3b-453e-4b65-9016-e899914a0ee9.png" style=""/></div>
<h2 id="uuid-2a78611d-6d0f-45b5-8b3f-3f90aa2eb89c">How it works...</h2>
<p>A markup extension is a class that derives from <kbd>System.Windows.Markup.MarkupExtension</kbd> and implements a single method named <kbd>ProvideValue</kbd>. In this example, we have used the <kbd>{x:Static}</kbd> markup extension, implemented by the <kbd>System.Windows.Markup.StaticExtension</kbd> class, which allowed you to access the static property.</p>
<p>Similarly, the <kbd>{StaticResource}</kbd> is used to access the resource (<kbd>Color</kbd>, <kbd>Brush</kbd>, <kbd>Converter</kbd>, and more), defined in a XAML.</p>
<h1 id="uuid-305d1389-9d2b-4af9-a97c-8767dc7200e8">Using value converters</h1>
<p>Converters are often useful when you want to perform data binding between two properties that have incompatible types. In such cases, you will need a piece of code which creates a bridge between source and target. This piece of code is defined as a <strong>value converter</strong>.</p>
<p>The <kbd>IValueConverter</kbd> interface is used to create value converters and contains two methods named <kbd>Convert</kbd> and <kbd>ConvertBack:</kbd></p>
<ul>
<li><strong>Convert(...)</strong>: It gets called when the source updates the target object</li>
<li><strong>ConvertBack(...)</strong>: It gets called when the target object updates the source object</li>
</ul>
<p>In this recipe, we will learn how to create value converters and use them while data binding.</p>
<h2 id="uuid-eb65a36c-4e05-46e1-85f0-7e64f7678735">Getting ready</h2>
<p>Let's begin by creating a new WPF project. Call it <kbd>CH04.ConverterDemo</kbd>.</p>
<h2 id="uuid-4e611b0d-f5f1-4a42-b0e3-579060c97f50">How to do it...</h2>
<p>To begin with the value converter, perform the following steps:</p>
<ol>
<li>From the Solution Explorer, open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Replace the existing <kbd>Grid</kbd> with the following XAML markup, which contains a <kbd>CheckBox</kbd> and a <kbd>Rectangle</kbd> inside a <kbd>StackPanel</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal" 
            VerticalAlignment="Top" 
            Margin="20"&gt; 
    &lt;CheckBox x:Name="chkBox" 
              Content="Show/Hide Box"/&gt; 
    &lt;Rectangle Fill="Red" Margin="80 0 0 0" 
               Width="150" Height="50" 
               Visibility="{Binding IsChecked,  
                 ElementName=chkBox}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="3">
<li>There is a data binding between the <kbd>Visibility</kbd> property of the <kbd>Rectangle</kbd> and the <kbd>IsChecked</kbd> property of the <kbd>CheckBox</kbd> control. If you build and run the application, you will see that there exists no visible change in the UI when you change the checked state of the checkbox:</li>
</ol>
<div><img src="img/16d39b4b-fbae-4449-985a-f15f497a4a25.png" style=""/></div>
<ol start="4">
<li>As the <kbd>Visibility</kbd> property does not accept <kbd>boolean</kbd> values, the <kbd>Rectangle</kbd> stays always visible by default. Now we will add the converter to it, which will automatically convert the value from <kbd>bool</kbd> to <kbd>Visibility</kbd>.</li>
<li>Let's create a new class file in the project. Name it <kbd>BoolToVisibilityConverter</kbd>.</li>
<li>Open the <kbd>BoolToVisibilityConverter.cs</kbd> file and add the following namespaces—<kbd>System</kbd>, <kbd>System.Globalization</kbd>, <kbd>System.Windows</kbd>, and <kbd>System.Windows.Data</kbd> as <kbd>using</kbd> statement.</li>
<li>Now, mark the class as <kbd>public</kbd> and implement the <kbd>IValueConverter</kbd> interface.</li>
<li>Add the following two code blocks inside the class:</li>
</ol>
<pre style="padding-left: 90px">public object Convert(object value,  
                      Type targetType,  
                      object parameter,  
                      CultureInfo culture) 
{ 
    return value is bool val &amp;&amp; val ? Visibility.Visible : <br/>    Visibility.Collapsed; 
} 
 
public object ConvertBack(object value,  
                          Type targetType,  
                          object parameter,  
                          CultureInfo culture) 
{ 
    throw new NotImplementedException(); 
} </pre>
<ol start="9">
<li>Now, go to the <kbd>MainWindow.xaml</kbd> file and add the following XMLNS namespace, so that we can declare the converter as a window resource:</li>
</ol>
<pre style="padding-left: 90px"> </pre>
<ol start="10">
<li>Inside the <kbd>Window</kbd> tag, add the following markup to declare the converter that we have created:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;converters:BoolToVisibilityConverter  
       x:Key="BoolToVisibilityConverter"/&gt; 
&lt;/Window.Resources&gt;</pre>
<ol start="11">
<li>Now, in the binding syntax of the <kbd>Visibility</kbd> property of <kbd>Rectangle</kbd>, associate the converter as <kbd>StaticResource</kbd>, as shown in the following code snippet:</li>
</ol>
<pre style="padding-left: 90px">Visibility="{Binding IsChecked, ElementName=chkBox, Converter={StaticResource BoolToVisibilityConverter}}" </pre>
<ol start="12">
<li>Once this is done, build the project and run the application.</li>
<li>By default, the checkbox will be unchecked and the rectangle will not be visible on the screen. Change the state of the checkbox to checked and observe that the rectangle will become visible on the screen. Unchecking the box will again hide the rectangle:</li>
</ol>
<div><img src="img/79724832-3b9e-4b6f-b302-a0aa63222852.png" style=""/></div>
<h2 id="uuid-08fc9aff-896c-45a4-8b53-38cbefbeabe3">How it works...</h2>
<p>A value converter is used to convert one value to another, by implementing the <kbd>IValueConverter</kbd> interface. The values may be of the same type or different types, but require some transformation that is not possible declaratively. These are often powerful because they are written in code, and hence have more logic to control the functionality.</p>
<p>An instance of the converter is generally created in the XAML page and declared as a resource. Then it sets to the controls by using binding expressions with the <kbd>Converter</kbd> property.</p>
<p>Whenever the source property changes, the converter returns a different result through the <kbd>Convert</kbd> method. The <kbd>ConvertBack</kbd> method is called in a two-way binding mode, where the source and target are reversed. In a one-way binding, there's no need to implement <kbd>ConvertBack</kbd> and generally we set its body to return an exception, like this—<kbd>throw new NotImplementedException()</kbd>.</p>
<h2 id="uuid-04216c20-0938-4441-beab-110e25f038bd">There's more...</h2>
<p>You can extend the functionality of the converter by using the converter parameter. Let's modify the <kbd>Convert</kbd> method to utilize the parameter named <kbd>parameter</kbd> and reverse the visibility based on its value.</p>
<p>To do so, open the <kbd>BoolToVisibilityConverter.cs</kbd> and modify the class implementation as shared in the following code snippet:</p>
<pre>public class BoolToVisibilityConverter : IValueConverter 
{ 
   public object Convert(object value,  
                         Type targetType,  
                         object parameter,  
                         CultureInfo culture) 
   { 
         var val = (bool) value; 
         if (parameter is string param &amp;&amp;  
             param.ToString().Equals("inverse")) { val = !val; } 
 
         return val ? Visibility.Visible: Visibility.Collapsed; 
   } 
 
   public object ConvertBack(object value,  
                             Type targetType,  
                             object parameter,  
                             CultureInfo culture) 
   { 
         throw new NotImplementedException(); 
   } 
} </pre>
<p>Now, open the <kbd>MainWindow.xaml</kbd> file and modify the data binding of the <kbd>Visibility</kbd> property of the <kbd>Rectangle</kbd> to have a <kbd>ConverterParameter=inverse</kbd>, as shared here:</p>
<pre>&lt;Rectangle Fill="Red" Margin="80 0 0 0" 
           Width="150" Height="50" 
           Visibility="{Binding IsChecked, ElementName=chkBox,  
           Converter={StaticResource BoolToVisibilityConverter},  
           ConverterParameter=inverse}"/&gt; </pre>
<p>Let's build and run the application. You will see that, this time, the rectangle will be visible by default when the checkbox is unchecked. Now change the status of the checkbox to check, and you will see that the rectangle becomes visible on the screen:</p>
<div><img src="img/cc010dd1-837e-4796-aac1-22924c24bad4.png" style=""/></div>
<p>You can, of course, change the implementation and the value of the <kbd>ConverterParameter</kbd>, based on your business requirement, and use the same converter class to return different values on various conditions.</p>
<p>You can also use <kbd>BooleanToVisibilityConverter</kbd>, provided by .NET Framework. You can read more about this converter here: <a href="https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx</a>.</p>
<h1 id="uuid-4e16f84b-a598-47a9-b571-a55e46d95a1e">Using multi-value converters</h1>
<p>When you want to change the target value based on multiple values of the same or different types, you will need to use multi-binding. This is done by using a multi-value converter (<kbd>IMultiValueConverter</kbd> interface).</p>
<p>In this recipe, we will build a sample demo to learn how to work with multi-binding and multi-value converters.</p>
<h2 id="uuid-2b1a0456-1a1d-4ac3-a6b7-1c90de4dc6c2">Getting ready</h2>
<p>Open your Visual Studio IDE and create a new project called <kbd>CH04.MultiValueConverterDemo</kbd>, based on the WPF application project template.</p>
<h2 id="uuid-f058ed8d-183b-44f6-a255-44e6c19a2435">How to do it...</h2>
<p>Once the project is created, follow these steps to design the UI and do a multi-binding between multiple elements:</p>
<ol>
<li>From the Solution Explorer, open the <kbd>MainWindow.xaml</kbd> page.</li>
<li>Inside the default <kbd>Grid</kbd> panel, create a few rows and columns, so that we can position elements at specific cells. Let's divide the <kbd>Grid</kbd> into five rows and three columns:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="*"/&gt; 
&lt;/Grid.RowDefinitions&gt; 
&lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition/&gt; 
    &lt;ColumnDefinition Width="90"/&gt; 
    &lt;ColumnDefinition/&gt; 
&lt;/Grid.ColumnDefinitions&gt;</pre>
<ol start="3">
<li>Inside the <kbd>Grid</kbd> panel, insert the following XAML code snippet to add few labels and input boxes inside the window:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBlock Text="Firstname:"  
           Grid.Column="0" Margin="2 0"/&gt; 
&lt;TextBlock Text="Middle:"  
           Grid.Column="1" Margin="2 0"/&gt; 
&lt;TextBlock Text="Lastname:"  
           Grid.Column="2" Margin="2 0"/&gt; 
&lt;TextBlock Text="Fullname:"  
           Grid.Row="2" Grid.ColumnSpan="3" 
           Margin="2 0"/&gt; 
 
&lt;TextBox x:Name="firstName" 
         Grid.Row="1" Grid.Column="0" 
         Margin="2 0"/&gt; 
&lt;TextBox x:Name="middleName" 
         Grid.Row="1" Grid.Column="1" 
         Margin="2 0"/&gt; 
&lt;TextBox x:Name="lastName" 
         Grid.Row="1" Grid.Column="2" 
         Margin="2 0"/&gt; 
&lt;TextBox x:Name="fullName" 
         Grid.Row="3" Grid.ColumnSpan="3" 
         Margin="2 0"&gt; 
 
&lt;/TextBox&gt; </pre>
<ol start="4">
<li>Build the project and run the application. You will see four input boxes on the screen, along with their associated labels as follows:</li>
</ol>
<div><img src="img/1656b782-5683-48f8-bee6-d3705f04be3a.png" style=""/></div>
<ol start="5">
<li>Let's close the application and return to the Solution Explorer. Create a new class named <kbd>FullNameConverter</kbd> inside the project.</li>
<li>Open the <kbd>FullNameConverter.cs</kbd> file and implement <kbd>IMultiValueConverter</kbd> on it.</li>
</ol>
<p> </p>
<ol start="7">
<li>Define the following <kbd>using</kbd> namespaces in the class file—<kbd>System</kbd>, <kbd>System.Globalization</kbd>, and <kbd>System.Windows.Data</kbd>.</li>
<li>Now add the following two methods inside the class, which implements the methods defined in <kbd>IMultiValueConverter</kbd> interface:</li>
</ol>
<pre style="padding-left: 90px">public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) 
{ 
    return string.Format("{0} {1} {2}", values[0], values[1], <br/>    values[2]); 
} 
 
public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) 
{ 
    return value.ToString().Split(' '); 
} </pre>
<ol start="9">
<li>Now navigate to the <kbd>MainWindow.xaml</kbd> page and add the following XMLNS namespace, so that the converter can be accessible from the XAML markup:</li>
</ol>
<pre style="padding-left: 90px"> </pre>
<ol start="10">
<li>Now add the converter to the window resource. To do this, inside the <kbd>Window</kbd> tag, add the following markup to define the instance by key name:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;converters:FullNameConverter  
              x:Key="FullNameConverter"/&gt; 
&lt;/Window.Resources&gt; </pre>
<ol start="11">
<li>Now, inside the <kbd>Text</kbd> property of the <kbd>fullName</kbd> textbox, define the multi-binding to bind the property with the <kbd>Text</kbd> property of three <kbd>TextBox</kbd> controls. Here's the code:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBox x:Name="fullName" 
         Grid.Row="3" 
         Grid.ColumnSpan="3" 
         Margin="2 0"&gt; 
    &lt;TextBox.Text&gt; 
        &lt;MultiBinding Converter="{StaticResource  
            FullNameConverter}"&gt; 
            &lt;Binding ElementName="firstName"  
                     Path="Text" Mode="TwoWay"/&gt; 
            &lt;Binding ElementName="middleName"  
                     Path="Text" Mode="TwoWay"/&gt; 
            &lt;Binding ElementName="lastName"  
                     Path="Text" Mode="TwoWay"/&gt; 
        &lt;/MultiBinding&gt; 
    &lt;/TextBox.Text&gt; 
&lt;/TextBox&gt; </pre>
<ol start="12">
<li>Once the binding is done, build the project and run the application. You will see the same UI on the screen. Enter some strings in the <kbd>Firstname</kbd>, <kbd>Middle</kbd>, and <kbd>Lastname</kbd> fields. Observe the value in the <kbd>Fullname</kbd> field:</li>
</ol>
<div><img src="img/a1186b7b-855f-431f-aac6-2e0849b5d863.png" style=""/></div>
<ol start="13">
<li>Similarly, change the <kbd>Fullname</kbd> field to hold three strings. Press the <em>TAB</em> key once you are done, and observe the value of the other three fields—<kbd>Firstname</kbd>, <kbd>Middle</kbd> and <kbd>Lastname</kbd>.</li>
</ol>
<h2 id="uuid-376987e8-2e5d-43d2-9f25-a86ca89ff25b">How it works...</h2>
<p>When you use a converter of type <kbd>IMultiValueConverter</kbd> in a <kbd>MultiBinding</kbd>, it passes the values defined by the <kbd>Binding</kbd> tag to the <kbd>Convert</kbd> method as an object array. In our preceding example, we passed three string values (<kbd>firstName</kbd>, <kbd>middleName</kbd>, and <kbd>lastName</kbd>) to the <kbd>Convert</kbd> method. The method then concatenated the strings to form a single string, which was the output string of the <kbd>Fullname</kbd> field as the binding was made with its <kbd>Text</kbd> property.</p>
<p>Similarly, when we changed the value of the <kbd>Fullname</kbd> field, the <kbd>ConvertBack</kbd> method triggered by the binding converter and returned the splitted strings. As per the binding order, those automatically got assigned to the respective fields—<kbd>Firstname</kbd>, <kbd>Middle</kbd>, and <kbd>Lastname</kbd>.</p>


            

            
        
    </body></html>