- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: CI/CD – Publishing with GitHub Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD - 使用GitHub Actions进行发布
- en: One of the features of microservices is their ability to continuously build
    and deploy services. In the previous chapters, we automatically created the infrastructure
    that’s used by our service solution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一个特点是它们能够持续构建和部署服务。在之前的章节中，我们自动创建了服务解决方案使用的基础设施。
- en: In this chapter, we’ll continue to automatically build and update services and
    use protection rules before deploying applications to staging and production environments.
    While doing this, you’ll learn how to use feature flags with Azure App Configuration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续自动构建和更新服务，并在将应用程序部署到预发布和生产环境之前使用保护规则。在这个过程中，你将学习如何使用Azure App Configuration与功能标志一起使用。
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Use GitHub Actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub Actions
- en: Build and test the application automatically after a pull request
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拉取请求后自动构建和测试应用程序
- en: Deploy the application to test environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到测试环境
- en: Use deployment protection rules before deploying the application to production
    environments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将应用程序部署到生产环境之前，使用部署保护规则
- en: Publish NuGet packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布NuGet包
- en: Use feature flags with modern deployment patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现代部署模式中的功能标志
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, similar to the previous chapter, you’ll need an Azure subscription,
    the Azure CLI, the Azure Developer CLI, and .NET Aspire. You’ll also need your
    own GitHub repository so that you can store secrets, create environments, and
    run GitHub actions. These features are available in public repositories. If you
    create a private repository, the GitHub Team feature is required for creating
    environments (see [https://github.com/pricing](https://github.com/pricing)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，与上一章类似，你需要Azure订阅、Azure CLI、Azure Developer CLI和.NET Aspire。你还需要自己的GitHub仓库，以便你可以存储机密信息、创建环境并运行GitHub
    Actions。这些功能在公共仓库中可用。如果你创建一个私有仓库，则需要GitHub团队功能来创建环境（见[https://github.com/pricing](https://github.com/pricing)）。
- en: 'The source code for this chapter can be found in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure)。
- en: 'The `ch08` folder contains the following projects, along with the output for
    this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch08`文件夹包含以下项目，以及本章的输出：'
- en: '`Codebreaker.GameAPIs`: The `game-apis` project we used in the previous chapter
    has been enhanced using feature flags.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs`：我们在上一章中使用过的`game-apis`项目已经通过功能标志进行了增强。'
- en: '`Codebreaker.Bot`: This is the implementation of `bot-service`, which plays
    games.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Bot`：这是`bot-service`的实现，用于玩游戏。'
- en: '`Codebreaker.GameAPIs.KiotaClient`: This is the client library we created in
    [*Chapter 4*](B21217_04.xhtml#_idTextAnchor092) to be used by clients.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.KiotaClient`：这是我们[*第4章*](B21217_04.xhtml#_idTextAnchor092)中创建的客户端库，用于客户端。'
- en: '`Workflows`: This folder is new. Here, you will find all the GitHub Actions
    workflows. However, these don’t become active until you copy them to the `.github/workflows`
    folder in your repository.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Workflows`：这个文件夹是新的。在这里，你可以找到所有GitHub Actions工作流程。然而，这些工作流程在你将它们复制到仓库中的`.github/workflows`文件夹之前不会激活。'
- en: To work through the code with this chapter, you can use the `service` and `bot`
    projects from the previous chapter, as well as the `Kiota` library from [*Chapter
    4*](B21217_04.xhtml#_idTextAnchor092).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要与本章中的代码一起工作，你可以使用上一章中的`service`和`bot`项目，以及[*第4章*](B21217_04.xhtml#_idTextAnchor092)中的`Kiota`库。
- en: For this chapter, you’ll need GitHub rights to run GitHub workflows, as well
    as to create and use GitHub environments with protection rules. The easiest way
    to do this is to create a public repository and copy just the code from this chapter
    into it. Create the `src` folder in this new repository and copy the source code
    to this folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要GitHub权限来运行GitHub工作流程，以及创建和使用具有保护规则的GitHub环境。最简单的方法是创建一个公共仓库，并将本章中的代码仅复制到其中。在这个新仓库中创建`src`文件夹，并将源代码复制到这个文件夹中。
- en: Check out the README file in the `ch08` folder of this book’s GitHub repository
    for the latest updates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本书GitHub仓库中`ch08`文件夹中的README文件以获取最新更新。
- en: Preparing the solution using the Azure Developer CLI
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure Developer CLI准备解决方案
- en: 'First, let’s prepare the solution using the Azure Developer CLI. When initializing
    the solution, set the current folder to the root folder of the repository (not
    the folder of the solution file, as we did previously):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用Azure Developer CLI准备解决方案。在初始化解决方案时，将当前文件夹设置为存储库的根文件夹（而不是解决方案文件的文件夹，如我们之前所做的那样）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Select `bot` and `game-apis` as projects to be exposed to the internet, and
    enter a new environment name – for example, `codebreaker-08-dev`. The generated
    `azure.yaml` file, which contains a link to the AppHost project file, needs to
    be committed to the source code repository. The generated `.azure` folder can
    contain secrets and has been – because of the generated `.gitignore` file – excluded
    from the source code repository.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `bot` 和 `game-apis` 作为要公开到互联网的项目，并输入一个新的环境名称 - 例如，`codebreaker-08-dev`。包含指向AppHost项目文件的链接的生成
    `azure.yaml` 文件需要提交到源代码仓库。生成的 `.azure` 文件夹可以包含密钥，并且由于生成的 `.gitignore` 文件，已被排除在源代码仓库之外。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason to use the root directory of the `azd pipeline` command used later;
    At the time of writing, this command requires the `.github/workflows` directory
    to be in the same folder. Some changes are planned for a later release, so please
    check the README file for this chapter for updates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用稍后使用的 `azd pipeline` 命令的根目录的原因；在编写本文时，此命令需要 `.github/workflows` 目录位于同一文件夹中。计划在以后的版本中进行一些更改，因此请检查本章的README文件以获取更新。
- en: 'Now, let’s deploy the resources to Azure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将资源部署到Azure：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With `azd up`, the resources are deployed to your configured environment. Select
    the Azure subscription you wish to use and the Azure region where you want to
    deploy the resources.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `azd up`，资源将被部署到您配置的环境。选择您希望使用的Azure订阅以及您希望部署资源的Azure区域。
- en: The generated file, `azure.yaml`, references the AppHost project. The generated
    folder, `.azure` (which has been excluded from the source code repository because
    of possible secrets being stored), contains the current environment and a folder
    that has the same name as the environment. This folder contains the `config.json`
    file, which lists the publicly accessible service configuration, and the `.env`
    file, which contains variables referencing the created Azure resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件 `azure.yaml` 引用了AppHost项目。生成的文件夹 `.azure`（由于可能存储密钥而被排除在源代码仓库之外），包含当前环境和与环境同名的一个文件夹。此文件夹包含
    `config.json` 文件，其中列出公开可访问的服务配置，以及包含引用创建的Azure资源的 `.env` 文件。
- en: 'Now, we are ready to use GitHub Actions. You can remove the Azure resources
    with `azd down` again since the complete infrastructure should have been deployed
    via GitHub Actions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用GitHub Actions。您可以使用 `azd down` 再次删除Azure资源，因为完整的基础设施应该已经通过GitHub
    Actions部署：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Answer `y` to delete the resources, and then `y` again to permanently delete
    the resources that have soft delete enabled.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回答 `y` 以删除资源，然后再次回答 `y` 以永久删除已启用软删除的资源。
- en: If you want to permanently delete resources, open the Azure portal ([https://portal.azure.com](https://portal.azure.com)),
    go to **Key Vault**, and click on **Manage deleted vaults**. Key vaults that are
    deleted need to be purged so that you can create a resource with the same name
    again. Purge the key vaults. Similarly, check for Azure App Configuration services
    that need to be purged.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想永久删除资源，请打开Azure门户（[https://portal.azure.com](https://portal.azure.com)），转到
    **密钥保管库**，然后单击 **管理已删除的保管库**。已删除的密钥保管库需要被清除，以便您可以再次创建具有相同名称的资源。清除密钥保管库。同样，检查需要清除的Azure
    App Configuration服务。
- en: Exploring GitHub Actions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索GitHub Actions
- en: '**GitHub Actions** is a feature of GitHub that you can use to automatically
    build, test, and deploy source code. GitHub Actions is a product that consists
    of *workflows*, *events*, *jobs*, *actions*, and *runners*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub Actions** 是GitHub的一个功能，您可以使用它来自动构建、测试和部署源代码。GitHub Actions 是一个由 *工作流程*、*事件*、*作业*、*操作*
    和 *运行器* 组成的产品：'
- en: A `.github/workflows` folder of a repository. A workflow contains events and
    jobs.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库的 `.github/workflows` 文件夹。一个工作流程包含事件和作业。
- en: An **event** specifies what triggers a workflow. When should the workflow be
    started?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**指定触发工作流程的内容。工作流程应该在何时启动？'
- en: A **job** consists of steps that are executed on a **runner** machine.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**由在 **运行器**机器上执行的步骤组成。'
- en: A **step** can run a script or an action.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**可以运行脚本或操作。'
- en: An **action** is a reusable GitHub extension that reduces the need to write
    scripts. Many of these reusable extensions can be used to build and deploy applications.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作** 是一个可重用的 GitHub 扩展，它可以减少编写脚本的必要性。许多这些可重用扩展可以用于构建和部署应用程序。'
- en: Now that we’ve set the foundation with these terms, let’s get into the details
    by creating a workflow using the Azure portal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用这些术语奠定了基础，让我们通过使用 Azure 门户创建一个工作流程来深入了解细节。
- en: Creating a GitHub Actions workflow
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GitHub Actions 工作流程
- en: 'There are several options to automatically create GitHub Actions workflows
    to deploy services to Microsoft Azure. Using the Azure portal, upon opening **Container
    App**, you can select **Continuous deployment** under **Settings**, as shown in
    *Figure 8**.1*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选项可以自动创建 GitHub Actions 工作流程以部署服务到 Microsoft Azure。使用 Azure 门户，在打开 **容器应用**
    时，您可以在 **设置** 下选择 **持续部署**，如图 *图 8.1* 所示：
- en: '![Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal](img/B21217_08_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 从 Azure 门户创建 GitHub Actions 工作流程](img/B21217_08_01.jpg)'
- en: Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 从 Azure 门户创建 GitHub Actions 工作流程
- en: Using the Azure portal, you can select the GitHub repository, configure the
    Azure Container Registry you wish to use, and specify a **Service Principal**
    or a **User-assigned Identity** value to be used to publish the project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure 门户，您可以选择 GitHub 仓库，配置您希望使用的 Azure 容器注册表，并指定一个 **服务主体** 或 **用户分配的身份**
    值来发布项目。
- en: 'Another option is to use Visual Studio. With Visual Studio, you can select
    a project (for example, `game-apis`) and select **Publish…** from the context
    menu. Upon adding a new publish profile, which you can do by selecting **Azure**
    | **Azure Container Apps (Linux)**, then selecting **Container App**, then Container
    Registry, the following dialogue appears:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 Visual Studio。使用 Visual Studio，您可以选择一个项目（例如，`game-apis`），然后从上下文菜单中选择
    **发布…**。在添加新的发布配置文件时，您可以通过选择 **Azure** | **Azure 容器应用 (Linux)**，然后选择 **容器应用**，然后容器注册表，出现以下对话框：
- en: '![Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio](img/B21217_08_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 通过 Visual Studio 创建 GitHub Actions 工作流程](img/B21217_08_02.jpg)'
- en: Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 通过 Visual Studio 创建 GitHub Actions 工作流程
- en: From this dialogue, you can directly publish to the Azure Container App or create
    a GitHub Actions workflow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对话框中，您可以直接发布到 Azure 容器应用或创建一个 GitHub Actions 工作流程。
- en: What’s common with these options is that you can publish service by service.
    Here, you used `azd up` to deploy the complete solution. Let’s have a look at
    what the Azure Developer CLI has to offer to create GitHub Actions workflows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项的共同点是您可以按服务发布。在这里，您使用了 `azd up` 来部署完整解决方案。让我们看看 Azure 开发者 CLI 提供了哪些功能来创建
    GitHub Actions 工作流程。
- en: First, you need to create a `.github` folder in the root directory of the repository.
    Files that are used by specific GitHub functionality are stored in this folder.
    To this folder, add a `workflows` folder (`.github/workflows`). All the GitHub
    Actions workflows need to be stored within this folder.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在仓库的根目录下创建一个 `.github` 文件夹。用于特定 GitHub 功能的文件存储在这个文件夹中。向这个文件夹添加一个 `workflows`
    文件夹（`.github/workflows`）。所有 GitHub Actions 工作流程都需要存储在这个文件夹中。
- en: 'Next, create the `codebreaker-deploy.yml` file. Now, copy the content of the
    `azure-deploy.yaml` file to this file. This file is from the *Azure-Samples* repository:
    [https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml](https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 `codebreaker-deploy.yml` 文件。现在，将 `azure-deploy.yaml` 文件的内容复制到这个文件中。此文件来自
    *Azure-Samples* 仓库：[https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml](https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml)。
- en: Now that we’ve created this workflow file, we can take a closer look at it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了此工作流程文件，我们可以更仔细地查看它。
- en: Workflow file with YAML syntax
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 YAML 语法的工怍流程文件
- en: The syntax of workflow files makes use of **YAML Ain’t Markup Language** (**YAML**,
    a recursive acronym) syntax. YAML is a data-oriented human-readable serialization
    language that uses indentation to specify what belongs together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程文件的语法使用了 **YAML Ain’t Markup Language**（**YAML**，一个递归缩写）语法。YAML 是一种面向数据的人可读序列化语言，它使用缩进来指定什么属于一起。
- en: 'See [https://yaml.org/](https://yaml.org/) for the YAML spec and links to libraries.
    You can check out the following cheat sheet for the syntax: [https://yaml.org/refcard.html](https://yaml.org/refcard.html).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 YAML 规范和库的链接，请参阅 [https://yaml.org/](https://yaml.org/)。您可以通过以下速查表了解语法：[https://yaml.org/refcard.html](https://yaml.org/refcard.html)。
- en: Let’s take a closer look at the workflow file while making some small changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些小修改的同时，让我们更仔细地看看工作流程文件。
- en: Triggers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发器
- en: 'A workflow file starts with a name followed by a trigger:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程文件以名称开头，后跟触发器：
- en: workflows/codebreaker-deploy.yml
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-deploy.yml
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The name of a workflow is shown in the list of workflows. The `on` keyword specifies
    the events that trigger the workflow. GitHub offers many events that can be used
    with workflows. In this YAML file, the workflow is triggered with a `workflow_dispatch`
    event. This allows you to manually trigger the workflow. The second event, `push`,
    is triggered when changes are pushed to the repository. Because of the filtering
    that follows as part of `push`, the trigger is only done with a push to the `main`
    branch with changes specified by the files specified with `path`. If we don’t
    specify branches and path filters, the workflow will be triggered with every change
    in this repository.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程的名称显示在工作流程列表中。`on` 关键字指定触发工作流程的事件。GitHub 提供了许多可以与工作流程一起使用的事件。在此 YAML 文件中，工作流程由
    `workflow_dispatch` 事件触发。这允许您手动触发工作流程。第二个事件 `push` 在将更改推送到存储库时触发。由于 `push` 部分中的过滤，触发仅针对使用
    `path` 指定的文件更改推送到 `main` 分支进行。如果我们不指定分支和路径过滤器，则工作流程将在存储库的每个更改时触发。
- en: Permissions for secretless Azure federated credentials
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无密 Azure 联邦凭据权限
- en: 'The `permissions` section is a new construct that’s used with secretless Azure
    federated credentials to deploy to Azure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`permissions` 部分是一个新结构，用于与无密 Azure 联邦凭据一起使用以部署到 Azure：'
- en: workflows/codebreaker-deploy.yml
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-deploy.yml
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Permissions are used to access the identity token and the content. With `contents
    read`, the workflow has read access to the content of the repository. `id-token
    write` grants write access to the identity token. This token is used to authenticate
    GitHub with Azure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 权限用于访问身份令牌和内容。使用 `contents read`，工作流程可以读取存储库的内容。`id-token write` 授予对身份令牌的写入访问权限。此令牌用于使用
    Azure 认证 GitHub。
- en: Jobs and runners
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jobs 和 运行者
- en: 'In the workflow file, after the trigger is defined, the `jobs` keyword can
    be used to list one or more jobs that should run:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作流程文件中，在定义触发器之后，可以使用 `jobs` 关键字列出一个或多个应运行的作业：
- en: workflows/codebreaker-deploy.yml
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-deploy.yml
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`build-and-deploy` is the name of the job. A job needs a runner. GitHub offers
    hosted runners to run jobs on Linux, Windows, and Mac. You can find out what runners
    are available, as well as their versions, at: [https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources).
    If other hardware or operating system versions are needed, a custom runner can
    be used.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`build-and-deploy` 是作业的名称。一个作业需要一个运行者。GitHub 提供托管运行者，可以在 Linux、Windows 和 Mac
    上运行作业。您可以在以下位置找到可用的运行者及其版本：[https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources)。如果需要其他硬件或操作系统版本，可以使用自定义运行者。'
- en: Using the `env` keyword, environment variables are defined that can be used
    with the steps in this runner. The values for these variables come from the GitHub
    project variables using the `vars` object. The `${{ }}` expressions are evaluated
    during the execution of the workflow, and the values that are retrieved are added
    to the workflow at runtime. We will specify these values later using `azd` `pipeline
    config`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `env` 关键字定义环境变量，这些变量可以在本运行者的步骤中使用。这些变量的值来自 GitHub 项目变量，使用 `vars` 对象。`${{
    }}` 表达式在工作流程执行期间进行评估，检索到的值将在运行时添加到工作流程中。我们将稍后使用 `azd` `pipeline config` 指定这些值。
- en: Steps and actions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤和操作
- en: 'A job consists of steps and actions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个作业由步骤和操作组成：
- en: workflows/codebreaker-deploy.yml
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-deploy.yml
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first step consists of an action, `actions/checkout@v4`. This action checks
    out the source code to ensure it’s available alongside the runner. `@v4` defines
    the version number to be used for this GitHub action. Actions are available via
    GitHub Marketplace: [https://github.com/marketplace?category=&query=&type=actions](https://github.com/marketplace?category=&query=&type=actions).
    Every action has documentation that you can read to learn which parameters are
    available. `actions/checkout`, for example, allows you to include submodules at
    checkout and also allows you to check out source code from other repositories.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步包括一个操作，`actions/checkout@v4`。此操作检出源代码以确保它与运行器一起可用。`@v4` 定义了用于此 GitHub 操作的版本号。操作通过
    GitHub Marketplace 提供：[https://github.com/marketplace?category=&query=&type=actions](https://github.com/marketplace?category=&query=&type=actions)。每个操作都有文档，您可以阅读以了解哪些参数可用。例如，`actions/checkout`
    允许在检出时包含子模块，并允许从其他存储库检出源代码。
- en: The next action installs the Azure Developer CLI using `Azure/setup-azd`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个操作使用 `Azure/setup-azd` 安装 Azure 开发者 CLI。
- en: .NET is installed with the hosted runner, but we need to make sure we install
    the .NET Aspire workload. This can be done using a one-line script specified with
    the `run` field – that is, `dotnet workload` `install aspire`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用托管运行器安装 .NET，但我们需要确保安装 .NET Aspire 工作负载。这可以通过使用 `run` 字段指定的单行脚本来完成 - 即，`dotnet
    workload install aspire`。
- en: 'Next, the `azd auth` command is used:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `azd auth` 命令：
- en: workflows/codebreaker-deploy.yml
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-deploy.yml
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have the step where the permissions we defined earlier are needed:
    authentication with Federated Identity. `if` specifies that this step is conditional
    – only if `AZURE_CLIENT_ID` is not empty. We’ll have another option for authentication
    if `AZURE_CLIENT_ID` is empty with the following step. This step is not using
    a GitHub action; instead, the `run` field defines that it will invoke a multi-line
    script. Using multiple lines is specified by `|` at the end of the line. PowerShell
    (which is specified with the `shell` field) uses the backtick (`` ` ``) as a line
    continuation character.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们需要使用之前定义的权限：使用联合身份进行身份验证。`if` 指定此步骤是条件性的 - 只有当 `AZURE_CLIENT_ID` 不为空时。如果
    `AZURE_CLIENT_ID` 为空，我们将有另一个身份验证选项，如下一步所示。此步骤不使用 GitHub 操作；相反，`run` 字段定义了它将调用一个多行脚本。使用多行是通过行尾的
    `|` 来指定的。PowerShell（通过 `shell` 字段指定）使用反引号（`` ` ``）作为行续字符。
- en: The command that’s running with PowerShell is `azd auth login`, passing a few
    parameters. `--client-id` uses the identifier of the service principal, which
    has the necessary Azure permissions. `--federated-credential-provider` uses GitHub
    for federated authentication. Federated authentication allows you to use GitHub
    identities to access resources on Azure. `--tenant-id` specifies the Azure directory
    identifier that is used with Azure authentication.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell 运行的命令是 `azd auth login`，并传递了一些参数。`--client-id` 使用具有必要 Azure 权限的服务主体的标识符。`--federated-credential-provider`
    使用 GitHub 进行联合身份验证。联合身份验证允许您使用 GitHub 身份访问 Azure 上的资源。`--tenant-id` 指定用于 Azure
    身份验证的 Azure 目录标识符。
- en: 'The next step uses another conditional script if the `AZURE_CREDENTIALS` variable
    is set:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步使用另一个条件脚本，如果设置了 `AZURE_CREDENTIALS` 变量：
- en: workflows/codebreaker-deploy.yml
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-deploy.yml
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `AZURE_CREDENTIALS` environment variable is stored as a JSON script. This
    is converted into a PowerShell hash table variable named `info` and allows us
    to access each part of the JSON content, such as the client ID, the client secret,
    and the tenant ID. These parts are then passed to the `azd auth login` command.
    `AZURE_CREDENTIALS` itself is retrieved using `secrets.AZURE_CREDENTIALS`. Secrets
    are stored encrypted alongside the GitHub project and are not part of the source
    code of the repository. We’ll configure these secrets in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`AZURE_CREDENTIALS` 环境变量存储为 JSON 脚本。这被转换为一个名为 `info` 的 PowerShell 哈希表变量，使我们能够访问
    JSON 内容的各个部分，例如客户端 ID、客户端密钥和租户 ID。然后，这些部分被传递给 `azd auth login` 命令。`AZURE_CREDENTIALS`
    本身是通过 `secrets.AZURE_CREDENTIALS` 获取的。密钥存储在与 GitHub 项目一起加密的旁边，不是存储库源代码的一部分。我们将在下一节中配置这些密钥。'
- en: 'Finally, two one-line commands are invoked:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用两个单行命令：
- en: workflows/codebreaker-deploy.yml
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-deploy.yml
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first command, `azd provision`, creates the Azure infrastructure, as specified
    by the ap`p-model` definition of the AppHost project. If the infrastructure already
    exists, it is checked if a change is needed, and only updates are applied. `azd
    deploy` then deploys the services to Azure, thus building the Docker images, publishing
    them to Azure Container Registry, and creating various Azure Container Apps with
    the created images. The `--no-prompt` option doesn’t wait for the user to interact
    with this command and just uses defaults.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令 `azd provision` 根据 AppHost 项目的 `app-model` 定义创建 Azure 基础设施。如果基础设施已经存在，则会检查是否需要更改，并且仅应用更新。然后
    `azd deploy` 将服务部署到 Azure，从而构建 Docker 镜像，将它们发布到 Azure 容器注册库，并使用创建的镜像创建各种 Azure
    容器应用。`--no-prompt` 选项不会等待用户与此命令交互，而只是使用默认值。
- en: The `azd up` command we used previously used `azd provision` and `azd deploy`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的 `azd up` 命令使用了 `azd provision` 和 `azd deploy`。
- en: Create the `.github/workflows` folder in your repository and copy the `codebreaker-deploy.yml`
    workflow file to this folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的仓库中创建 `.github/workflows` 文件夹，并将 `codebreaker-deploy.yml` 工作流程文件复制到该文件夹。
- en: GitHub variables and secrets
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 变量和密钥
- en: Secrets shouldn’t be part of the source code, and the workflow file is stored
    with the source code. GitHub has a vault where you can store secrets outside of
    the source code repository. Using `azd`, secrets and variables can automatically
    be configured with GitHub.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥不应包含在源代码中，工作流程文件与源代码一起存储。GitHub 有一个保险库，您可以在其中存储源代码仓库之外的密钥。使用 `azd`，可以自动配置
    GitHub 中的密钥和变量。
- en: The `azd pipeline` command supports this. Start by having the current directory
    set to the root folder of the repository. `azd pipeline` needs the .`github/workflows`
    folder to be in the same directory where you run `azd pipeline`; you must also
    have the .NET Aspire application initialized in this directory. This requirement
    might change – check the README file in this chapter’s GitHub repository for more
    information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`azd pipeline` 命令支持此功能。首先，将当前目录设置为仓库的根文件夹。`azd pipeline` 需要的 `.github/workflows`
    文件夹必须与您运行 `azd pipeline` 的目录相同；您还必须在目录中初始化 .NET Aspire 应用程序。此要求可能会更改 - 请检查本章 GitHub
    仓库中的 README 文件以获取更多信息。'
- en: 'Run the following command to configure the pipeline:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以配置管道：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`azd pipeline config` uses the Azure subscription you configured earlier to
    create GitHub variables and secrets, as well as create an Azure app registration,
    which allows GitHub to deploy to Azure. By default, the principal name created
    starts with `az-dev-` and contains the date and time it was created. Here, we
    specify the principal name as `github-codebreaker-dev`. Repository variables for
    `AZURE_ENV_NAME`, `AZURE_LOCATION`, `AZURE_SUBSCRIPTION_ID`, `AZURE_TENANT_ID`,
    and `AZURE_CLIENT_ID` are created.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`azd pipeline config` 使用您之前配置的 Azure 订阅来创建 GitHub 变量和密钥，以及创建 Azure 应用注册，这允许
    GitHub 将应用程序部署到 Azure。默认情况下，创建的主名称以 `az-dev-` 开头，并包含创建的日期和时间。在此处，我们指定主名称为 `github-codebreaker-dev`。创建了
    `AZURE_ENV_NAME`、`AZURE_LOCATION`、`AZURE_SUBSCRIPTION_ID`、`AZURE_TENANT_ID` 和
    `AZURE_CLIENT_ID` 的仓库变量。'
- en: 'Open the GitHub repository in your browser. In the portal, click **Settings**.
    With the **Security** category open in the left pane, you’ll see **Secrets and
    variables**. In this sub-category, when you open **Actions**, you’ll see the **Actions
    secrets and variables** page, which contains **Repository secrets**. This is shown
    in *Figure 8**.3*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 GitHub 仓库。在门户中，点击 **设置**。在左侧面板中打开 **安全** 类别，您将看到 **密钥和变量**。在此子类别中，当您打开
    **操作** 时，您将看到 **操作密钥和变量** 页面，其中包含 **仓库密钥**。这如图 *图 8**.3* 所示：
- en: '![Figure 8.3 – Repository secrets](img/B21217_08_03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 仓库密钥](img/B21217_08_03.jpg)'
- en: Figure 8.3 – Repository secrets
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 仓库密钥
- en: The `AZD_INITIAL_ENVIRONMENT_CONFIG` secret contains the content of the `.azure/[environment]/config.json`
    file. This file contains a list of publicly accessible services and is read by
    `azd deploy` to configure the Ingress controller. The needed environment name,
    location, subscription ID, and other details are stored within repository variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`AZD_INITIAL_ENVIRONMENT_CONFIG` 密钥包含 `.azure/[环境]/config.json` 文件的内容。此文件包含一个公开可访问的服务列表，并由
    `azd deploy` 读取以配置 Ingress 控制器。所需的环境名称、位置、订阅 ID 和其他详细信息存储在仓库变量中。'
- en: Because `azd pipeline config` creates Federated Identity credentials for GitHub,
    secrets to access Azure are not required with the default (federated) configuration.
    Instead of using a value of `federated`, you can pass `client-credentials`, which
    configures credentials to be stored within a repository secret.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `azd pipeline config` 为 GitHub 创建了联邦身份凭证，所以在默认（联邦）配置下不需要 Azure 的密钥。您可以选择传递
    `client-credentials`，这样配置的凭证将被存储在存储库的密钥中，而不是使用 `federated` 的值。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137), you understood how to separate
    secrets and variables with Azure Container Apps, and then with Azure App Configuration
    and Key Vault in [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162). The reason for
    this separation is similar here using GitHub Actions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B21217_06.xhtml#_idTextAnchor137) 中，您了解了如何使用 Azure Container Apps
    将密钥和变量分开，然后在 [*第 7 章*](B21217_07.xhtml#_idTextAnchor162) 中使用 Azure App Configuration
    和 Key Vault 进行操作。这里使用 GitHub Actions 的分离原因与此类似。
- en: GitHub allows you to specify different levels where you can store secrets and
    variables. The organization level can be used when secrets should be shared across
    different repositories within the organization. Repository secrets are stored
    within the scope of the repository and are not available from other repositories.
    Environment secrets are scoped within deployment environments. These will be covered
    later in the *Using deployment* *environments* section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 允许您指定不同的存储密钥和变量的级别。当需要在组织内的不同存储库之间共享密钥时，可以使用组织级别。存储库密钥存储在存储库的作用域内，并且不可从其他存储库访问。环境密钥存储在部署环境中。这些将在
    *使用部署* *环境* 部分中稍后介绍。
- en: 'Run the GitHub Actions workflow now – either by pushing a source code update
    to the GitHub repository or by running the workflow explicitly from the GitHub
    portal. You’ll see that the workflow is in progress before it completes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 GitHub Actions 工作流 – 要么通过将源代码更新推送到 GitHub 存储库，要么通过从 GitHub 门户显式运行工作流。您将看到在工作流完成之前它正在运行：
- en: '![Figure 8.4 – Workflow in progress](img/B21217_08_04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 工作流进行中](img/B21217_08_04.jpg)'
- en: Figure 8.4 – Workflow in progress
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 工作流进行中
- en: 'At this stage, you might need to wait until an agent is available. When it’s
    in progress, you can click on it to see progress information about what’s going
    on. *Figure 8**.5* shows the steps that appear when the workflow is completed
    successfully:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您可能需要等待代理可用。当它正在运行时，您可以点击它以查看有关正在进行的操作的信息。*图 8**.5* 展示了工作流成功完成后出现的步骤：
- en: '![Figure 8.5 – Workflow steps](img/B21217_08_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 工作流步骤](img/B21217_08_05.jpg)'
- en: Figure 8.5 – Workflow steps
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 工作流步骤
- en: Upon checking the logs, you’ll see all the steps that have been completed. In
    the preceding figure, you can see that federated credentials have been used, and
    not the client credentials. You can click on each of these steps to find more
    details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 检查日志后，您将看到所有已完成的步骤。在前面的图中，您可以看到使用了联邦凭证，而不是客户端凭证。您可以点击这些步骤中的每一个以获取更多详细信息。
- en: When creating a GitHub Actions workflow with `azd`, just a few statements are
    required to deploy the complete solution. With every source code change that is
    not pushed to the main branch, the deployment is updated.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `azd` 创建 GitHub Actions 工作流时，只需要几个语句即可部署完整解决方案。对于每次未推送到主分支的源代码更改，都会更新部署。
- en: Getting more with GitHub Actions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 GitHub Actions 获取更多功能
- en: It’s great to have an easy way to create a GitHub action using integration from
    Visual Studio, the Azure portal, or via the `azd pipeline` command. `azd pipeline`
    is great for deploying a complete solution, but because of its early development
    stages, some features are missing. With our solution, some more features are required;
    we’ll customize these manually.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自 Visual Studio、Azure 门户或通过 `azd pipeline` 命令的集成来创建 GitHub 动作非常方便。`azd pipeline`
    非常适合部署完整解决方案，但由于其处于早期开发阶段，一些功能尚未实现。我们的解决方案需要更多功能；我们将手动进行定制。
- en: 'Let’s have a look at some of the goals we have:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的一些目标：
- en: All the services should be built, tested, and deployed
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有服务都应该构建、测试和部署
- en: NuGet packages should be published to GitHub Packages and made available there
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet 包应该发布到 GitHub Packages 并在那里提供
- en: We don’t want to repeat code, so we’ll create reusable workflows
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不想重复代码，所以我们将创建可重用的工作流
- en: Deploying should be done to multiple environments, such as development, staging,
    and production
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将部署到多个环境，例如开发、测试和生成环境
- en: Let’s get into the details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解细节。
- en: Enhancing GitHub Actions workflows
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强 GitHub Actions 工作流
- en: To build our services, we must create reusable workflows. First, let’s configure
    the variables and secrets that are needed by these workflows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的服务，我们必须创建可重用的工作流。首先，让我们配置这些工作流所需的变量和密钥。
- en: Configuring variables and secrets
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置变量和密钥
- en: 'We’ve configured variables and secrets using `az pipeline config` previously.
    if you need more customization, you might need to set these values yourself. You’ve
    already seen how to access the repository secrets and variables with the GitHub
    portal. Now, let’s add these to secrets:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用`az pipeline config`配置了变量和密钥。如果您需要更多自定义，您可能需要自己设置这些值。您已经看到了如何使用GitHub门户访问仓库密钥和变量。现在，让我们将这些添加到密钥中：
- en: '`AZURE_TENANT_ID`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_TENANT_ID`'
- en: '`AZURE_SUBSCRIPTION_ID`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_SUBSCRIPTION_ID`'
- en: '`AZURE_CLIENT_ID`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_CLIENT_ID`'
- en: 'To get the tenant ID, use the Azure CLI:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取租户ID，请使用Azure CLI：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`az account show` returns JSON information about the logged-in Azure account.
    With the JSONPath `--query tenantId` query, the Microsoft Entra tenant ID is returned.
    `-o tsv` returns the result in tab-separated values. Set the returned value with
    the `AZURE_TENANT_ID` repository secret.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`az account show`返回有关已登录Azure账户的JSON信息。使用JSONPath `--query tenantId`查询，返回Microsoft
    Entra租户ID。`-o tsv`以制表符分隔的值返回结果。使用`AZURE_TENANT_ID`仓库密钥设置返回的值。'
- en: 'The subscription ID can also be listed with `az` `account show`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅ID也可以使用`az` `account show`列出：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `id` contains the subscription ID. Set this value with the `AZURE_SUBSCRIPTION_ID`
    repository secret.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`id`包含订阅ID。使用`AZURE_SUBSCRIPTION_ID`仓库密钥设置此值。
- en: 'Earlier in this chapter, we used the `azd pipeline` command to create an account
    for federated authentication. Let’s check out this account within the Microsoft
    Entra portal: [https://entra.microsoft.com](https://entra.microsoft.com). After
    logging in, from the left bar, within the `github-codebreaker-dev`. If you didn’t
    supply a name, `azd` creates an account starting with `az-dev`. Open this account
    and, within the **Manage** category, click **Certificates & secrets**. Open **Federated
    credentials**. You will see credentials named based on the GitHub organization
    and the repository, with entity types of **Pull request** and **Branch**. A predefined
    federated credential scenario for GitHub actions deploying Azure resources will
    be available.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们使用了`azd pipeline`命令来创建联合身份验证的账户。让我们在Microsoft Entra门户中查看此账户：[https://entra.microsoft.com](https://entra.microsoft.com)。登录后，从左侧栏中，在`github-codebreaker-dev`内。如果您没有提供名称，`azd`将创建以`az-dev`开头的账户。打开此账户，在**管理**类别中，点击**证书和密钥**。打开**联合凭据**。您将看到基于GitHub组织和仓库命名的凭据，实体类型为**拉取请求**和**分支**。将为GitHub
    Actions部署Azure资源提供一个预定义的联合凭据场景。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To create a new app registration with federated credentials using the Azure
    portal, the Azure CLI, or Azure PowerShell, check out the following documentation:
    [https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials](https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Azure门户、Azure CLI或Azure PowerShell使用联合凭据创建新的应用程序注册，请参阅以下文档：[https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials](https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials)。
- en: Copy the value for `AZURE_CLIENT_ID` repository secret.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 复制`AZURE_CLIENT_ID`仓库密钥的值。
- en: Now that we’ve specified the necessary secrets and variables, let’s get back
    to creating workflows.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了必要的密钥和变量，让我们回到创建工作流的步骤。
- en: Running unit tests
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: 'When triggering the workflow by updating the source code of a service, the
    first step should be to run unit tests. Let’s create a reusable workflow:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过更新服务的源代码来触发工作流时，第一步应该是运行单元测试。让我们创建一个可重用的工作流：
- en: workflows/shared-test.yml
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`workflows/shared-test.yml`'
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A reusable workflow is triggered by calling this workflow. The trigger specified
    by `on` uses the `workflow_call` keyword. At this point, the input values that
    are needed are also defined. With this workflow, `project-name` and `solution-path`
    are required input values. The `dotnet-version` input value has a default value
    assigned and is not required.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用此工作流可以触发一个可重用的工作流。由`on`指定的触发器使用`workflow_call`关键字。在此阶段，所需的输入值也已定义。使用此工作流，`project-name`和`solution-path`是必需的输入值。`dotnet-version`输入值已分配默认值，因此不是必需的。
- en: 'After the trigger and the input values, a job with a runner is defined, followed
    by the steps to be invoked:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在触发器和输入值之后，定义了一个带有运行器的作业，随后是调用的步骤：
- en: work flows/shared-test.yml
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: work flows/shared-test.yml
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After checking out the source code with the `actions/checkout` action, the
    .NET SDK is installed using `actions/setup-dotnet`. Here, the .NET version is
    retrieved from the input values. As the .NET SDK is now installed with this runner,
    the .NET CLI can be used. In the next step, instead of invoking an action, the
    `run` keyword is used to execute the `dotnet restore` command. `dotnet restore`
    retrieves the NuGet packages of the referenced solution. If this fails, there’s
    no need to continue with the next step. The next step runs the unit tests using
    `dotnet test`. The `--logger` option specifies to write log output with the TRX
    logger format – a Visual Studio `actions/upload-artifact` action. Artifacts can
    be used to share data between runners and also downloaded with workflow runs.
    By default, a step only runs if the previous step succeeds. In this case, we want
    to download the test result from the artifacts if the test fails – that’s why
    `if: always()` was added on uploading the artifact.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`actions/checkout`操作检出源代码后，使用`actions/setup-dotnet`安装.NET SDK。在这里，.NET版本是从输入值中检索的。由于现在使用此运行器安装了.NET
    SDK，因此可以使用.NET CLI。在下一步中，不是调用操作，而是使用`run`关键字执行`dotnet restore`命令。`dotnet restore`检索引用解决方案的NuGet包。如果失败，则无需继续下一步。下一步使用`dotnet
    test`运行单元测试。`--logger`选项指定使用TRX日志格式写入日志输出 – 一个Visual Studio `actions/upload-artifact`操作。工件可以用于在运行器之间共享数据，也可以与工作流程运行一起下载。默认情况下，只有前一个步骤成功时，步骤才会运行。在这种情况下，如果测试失败，则希望从工件中下载测试结果
    – 这就是为什么在上传工件时添加了`if: always()`。'
- en: 'This shared workflow is started from the `codebreaker-test.yml` workflow:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此共享工作流程从`codebreaker-test.yml`工作流程启动：
- en: workflows/codebreaker-test.yml
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-test.yml
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The job that’s been defined uses the name `build-and-test`, references the shared
    workflow file with the `uses` keyword, and sets the input values using the `with`
    keyword.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的工作流程使用名称`build-and-test`，通过`uses`关键字引用共享工作流程文件，并使用`with`关键字设置输入值。
- en: 'This workflow is triggered when a change is made in the specified files and
    folders in the main branch, explicitly. *Figure 8**.6* shows the result of running
    the workflow:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当主分支中指定的文件和文件夹发生更改时，此工作流程会被触发，这是明确的。**图8.6**.6显示了运行工作流程的结果：
- en: '![Figure 8.6 – Running the workflow](img/B21217_08_06.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 运行工作流程](img/B21217_08_06.jpg)'
- en: Figure 8.6 – Running the workflow
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 运行工作流程
- en: With this result, you can see the downloadable artifacts for viewing the test
    results.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个结果，你可以看到用于查看测试结果的可下载工件。
- en: Now that we’ve run the unit tests, let’s combine this with the previously created
    build and deploy job.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了单元测试，让我们将之前创建的构建和部署任务结合起来。
- en: Running multiple jobs
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行多个任务
- en: 'To run multiple jobs from one workflow, we’ll need to create a shared workflow
    from the deployment project:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个工作流程中运行多个作业，我们需要从部署项目中创建一个共享工作流程：
- en: workflows/shared-deploy.yml
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/shared-deploy.yml
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Because this is a shared workflow that’s triggered from other workflows, `on`
    specifies `workflow_call`. This workflow is very similar to the previously created
    deployment workflow, so the code for this hasn’t been repeated here. Check out
    the source code repository for the complete workflow. What’s important here is
    that not only inputs are passed from the calling workflow, but also secret information.
    These secrets are referenced using the `$ {{ secrets.<secret> }}` expression.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个从其他工作流程触发的共享工作流程，所以`on`指定了`workflow_call`。此工作流程与之前创建的部署工作流程非常相似，所以这里没有重复代码。查看源代码存储库以获取完整工作流程。这里重要的是，不仅从调用工作流程传递了输入，还传递了秘密信息。这些秘密信息使用`$
    {{ secrets.<secret> }}`表达式引用。
- en: 'The `codebreaker-testanddeploy.yml` workflow invokes both shared workflows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`codebreaker-testanddeploy.yml`工作流程调用这两个共享工作流程：'
- en: workflows/codebreaker-testanddeploy.yml
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker-testanddeploy.yml
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `needs` keyword, the `build-and-deploy` job is defined to require
    the `build-and-test` job to run beforehand. If the `build-and-test` job does not
    succeed, `build-and-deploy` will not run. Secrets need to be forwarded to the
    shared workflow. With secrets, you can specify every secret to pass with the calling
    workflow, or to share all the secrets available from the calling workflow with
    the called workflow. Inheriting these secrets is required when using environments
    (as shown in a later section).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `needs` 关键字，`build-and-deploy` 作业被定义为在运行之前需要 `build-and-test` 作业。如果 `build-and-test`
    作业没有成功，则 `build-and-deploy` 不会运行。需要将密钥转发到共享工作流程。有了密钥，你可以指定要传递给调用工作流程的每个密钥，或者将调用工作流程中可用的所有密钥与被调用工作流程共享。在使用环境时（如后续部分所示），需要继承这些密钥。
- en: 'When you run the workflow at this stage, you’ll see a graphical view of how
    the two jobs are connected, as shown in *Figure 8**.7*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在这一阶段运行工作流程时，你会看到一个图形视图，显示了两个作业是如何连接的，如图 *图 8.7* 所示。7*：
- en: '![Figure 8.7 – Running multiple jobs](img/B21217_08_07.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 运行多个作业](img/B21217_08_07.jpg)'
- en: Figure 8.7 – Running multiple jobs
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 运行多个作业
- en: Both jobs were completed successfully.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个任务都成功完成了。
- en: Next, we’ll dive into environments that can be used from multiple jobs to, for
    example, deploy the solution to staging and production environments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解可以从多个作业中使用的环境，例如，将解决方案部署到预生产和生产环境。
- en: Using deployment environments
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用部署环境
- en: When running the solution locally on the developer system, projects can be built
    and debugged locally. Just a few services, such as App Insights and Key Vault,
    need to be run in the Azure cloud environment. This is done automatically by .NET
    Aspire, which provisions `app-model` in the AppHost project. You just need to
    make sure you configure `Azure:SubscriptionId` with the user secrets. To run and
    test the application while it’s running within Azure, and to try out different
    Azure offerings, every developer of the team can use `azd init` and `azd up` to
    have all the services running in the personal Azure subscription that’s part of
    the Visual Studio Professional and Enterprise offerings.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当在开发者的本地系统上运行解决方案时，项目可以在本地构建和调试。只需要运行少数服务，例如 App Insights 和 Key Vault，这些服务需要在
    Azure 云环境中运行。这由 .NET Aspire 自动完成，它在 AppHost 项目中配置了 `app-model`。你只需确保你已经配置了 `Azure:SubscriptionId`
    使用用户密钥。为了在 Azure 中运行和测试应用程序，并尝试不同的 Azure 产品，团队中的每个开发者都可以使用 `azd init` 和 `azd up`
    来在个人 Azure 订阅中运行所有服务，该订阅是 Visual Studio Professional 和 Enterprise 提供的一部分。
- en: It’s also useful to use a shared environment where the services of the solution
    running in Microsoft Azure are used together by the developer team. One example
    is for client application developers to use a new daily build to test the client
    applications accessing the services in the cloud. This is the *development environment*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用共享环境也很有用，其中解决方案在 Microsoft Azure 中运行的服务由开发团队共同使用。一个例子是客户端应用程序开发者使用新的每日构建来测试访问云中服务的客户端应用程序。这是
    *开发环境*。
- en: To run load tests, it’s useful to have *test environments*. Such environments
    can be created on demand before running the load test. They can be deleted again
    after the load tests are finished and the results have been documented. See [*Chapter
    10*](B21217_10.xhtml#_idTextAnchor239) for more details on running tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行负载测试，拥有 *测试环境* 是有用的。这些环境可以在运行负载测试之前按需创建。在负载测试完成后，并记录了结果后，它们可以被删除。有关运行测试的更多详细信息，请参阅
    [*第 10 章*](B21217_10.xhtml#_idTextAnchor239)。
- en: Before moving into production, *staging environments*, which mirror the *production
    environments*, are used to make final tests if the application is behaving as
    expected.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序移入生产之前，使用与 *生产环境* 相似的 *预生产环境* 来进行最终测试，如果应用程序表现如预期。
- en: We can deploy the solution to all these environments by using GitHub Actions.
    However, some of these environments are more restrictive, which means that deployments
    can only be done when it’s been verified that the solution runs successfully with
    the defined constraints.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 GitHub Actions 将解决方案部署到所有这些环境中。然而，其中一些环境更为限制性，这意味着只有在验证了解决方案在定义的约束下成功运行后，才能进行部署。
- en: Let’s take a closer look.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看。
- en: Create environments with the Azure Developer CLI
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure 开发者 CLI 创建环境
- en: 'To create environments with the Azure Developer CLI, you can use the `azd env`
    `new` command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Azure 开发者 CLI 创建环境，你可以使用 `azd env` `new` 命令：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This not only creates a new environment named `codebreaker-08-prod` but also
    sets the current environment to this new one. To show all environments that have
    been configured, run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅创建了一个名为 `codebreaker-08-prod` 的新环境，还将当前环境设置为这个新环境。要显示所有已配置的环境，请运行以下命令：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This shows all the environments that have been configured, as well as the currently
    selected environment. To change the current one, run the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了所有已配置的环境以及当前选定的环境。要更改当前环境，请运行以下命令：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating an environment with `azd` creates the `.azure` subdirectory. Upon opening
    this folder, you will see the `config.json` file. This shows the currently selected
    environment.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `azd` 创建环境会创建 `.azure` 子目录。打开此文件夹后，您将看到 `config.json` 文件。这显示了当前选定的环境。
- en: With every environment that’s created, a subdirectory containing the name of
    the environment is created that contains values for the resource group, the Azure
    region, and the Azure subscription ID. When you’re creating a new environment,
    you can change the subscription with the `--subscription` option. To change the
    location of the resources, use `--location`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每创建一个环境，都会创建一个包含环境名称的子目录，其中包含资源组、Azure 区域和 Azure 订阅 ID 的值。在创建新环境时，您可以使用 `--subscription`
    选项更改订阅。要更改资源的位置，请使用 `--location`。
- en: 'To see the configuration values for an environment, run the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看环境的配置值，请运行以下命令：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To change the Azure region afterward, you can use `azd` `env set`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在之后更改 Azure 区域，您可以使用 `azd` `env set`：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While the Azure Developer CLI supports using multiple environments, using this
    in combination with GitHub environments is (not yet) directly available but can
    be easily customized. At the time of writing, the `azd pipeline config` command
    only supports one environment per repository. However, this is expected to change,
    and integration with GitHub environments is already being discussed. Check the
    README file in this chapter’s repository for updates.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Azure 开发者 CLI 支持使用多个环境，但与 GitHub 环境结合使用（目前）尚不可直接访问，但可以轻松定制。在撰写本文时，`azd pipeline
    config` 命令仅支持每个仓库一个环境。然而，这预计将会改变，并且与 GitHub 环境的集成已经在讨论中。请检查本章仓库中的 README 文件以获取更新。
- en: 'You can still use `azd pipeline` to create federated accounts for every environment:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用 `azd pipeline` 为每个环境创建联邦账户：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This creates the account that we’ll use with the `codebreaker-08-prod` environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们将与 `codebreaker-08-prod` 环境一起使用的账户。
- en: At this point, we need to learn how to use GitHub environments. So, we’ll start
    by creating GitHub environments.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要学习如何使用 GitHub 环境。因此，我们将从创建 GitHub 环境开始。
- en: Creating GitHub environments
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GitHub 环境
- en: Before using GitHub environments, you need to be aware that this GitHub feature
    is only available for free with public repositories. With private repositories,
    a Team license is required (see [https://github.com/pricing](https://github.com/pricing)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 GitHub 环境之前，您需要知道此 GitHub 功能仅适用于免费公共仓库。对于私有仓库，需要团队许可证（见 [https://github.com/pricing](https://github.com/pricing)）。
- en: 'Open your GitHub repository in your browser and click **Settings**. In the
    left pane, under the **Code and automation** category, click **Environments**.
    *Figure 8**.8* shows the environments for development, testing, staging, and production:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开您的 GitHub 仓库并点击 **设置**。在左侧面板中，在 **代码和自动化** 类别下，点击 **环境**。*图 8**.8* 显示了开发、测试、预发布和生产环境：
- en: '![Figure 8.8 – GitHub environments](img/B21217_08_08.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – GitHub 环境](img/B21217_08_08.jpg)'
- en: Figure 8.8 – GitHub environments
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – GitHub 环境
- en: You can create these environments using your browser by accessing your repository.
    As the environments are being created, protection rules can be applied.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问您的仓库使用浏览器创建这些环境。在创建环境的同时，可以应用保护规则。
- en: Defining deployment protection rules
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义部署保护规则
- en: Before publishing to another environment, you can enforce **deployment protection
    rules**. Publishing to the production environment might only be allowed from **protected
    branches**, specific branches that fulfill a naming convention, and only with
    commits from specific tag names. Up to six reviewers can be specified to approve
    the deployment. There’s also the option to implement custom protection rules,
    which, for example, might check the results of different test runs (tests will
    be covered in [*Chapter 10*](B21217_10.xhtml#_idTextAnchor239)) or check for issues
    within the GitHub repository. Third-party protection rules are also available.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布到另一个环境之前，你可以强制执行**部署保护规则**。发布到生产环境可能仅允许从**受保护的分支**、满足命名约定的特定分支以及仅使用特定标签名的提交中进行。最多可以指定六个审查员来批准部署。还有实施自定义保护规则的选择，例如，可能检查不同测试运行的结果（测试将在[*第10章*](B21217_10.xhtml#_idTextAnchor239)中介绍）或检查GitHub仓库中的问题。第三方保护规则也可用。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With the first few versions of the application, where you’ll start with deployments
    across different environments, it’s good practice to add reviewers that do some
    manual checks. Before the solution is deployed to the **production** environment,
    it needs to be deployed to the **staging** environment. In the staging environment,
    manual checks are used. On the road to improving the CI/CD process, you might
    add more and more automatic checks. Automated tests, code analysis, checking for
    issues, and more can be done before moving on to the next stage. You just need
    to be able to trust how you set up the environment and have your tests running.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的前几个版本中，你将在不同的环境中开始部署，这时添加一些进行手动检查的审查者是良好的实践。在解决方案部署到**生产环境**之前，它需要先部署到**预发布环境**。在预发布环境中，使用手动检查。在改进CI/CD流程的道路上，你可能需要添加越来越多的自动检查。在进入下一阶段之前，可以进行自动化测试、代码分析、检查问题等。
- en: 'Within the production environment, add yourself as a required reviewer with
    deployment protection, as shown in *Figure 8**.9*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，添加自己作为必需审查员，并启用部署保护，如图*图8.9*所示：
- en: '![Figure 8.9 – Required reviewers with GitHub environments](img/B21217_08_09.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – GitHub环境下的必需审查员](img/B21217_08_09.jpg)'
- en: Figure 8.9 – Required reviewers with GitHub environments
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – GitHub环境下的必需审查员
- en: Other than requiring reviewers, you can use rules defined by existing apps from
    GitHub partner applications to require some source code or issue checks, and also
    implement custom protection rules
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了要求审查员外，你还可以使用GitHub合作伙伴应用程序中现有应用程序定义的规则来要求某些源代码或问题检查，并实施自定义保护规则。
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using deployment protection rules for branches and tags, you should specify
    that not everyone is allowed to create branches and tags that are used with the
    rules. See *Configuring tag protection rules* at [https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules)
    for more details.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用分支和标签的部署保护规则时，你应该指定并非每个人都可以创建与规则一起使用的分支和标签。有关更多详细信息，请参阅[配置标签保护规则](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules)。
- en: Next, we’ll configure secrets and variables with environments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用环境配置密钥和变量。
- en: Setting environment secrets and variables
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境密钥和变量
- en: With environments, you can also specify variables and secrets that are only
    available within these environments. We need the tenant ID, the subscription ID
    , and the account ID of the federated account we created earlier. This information
    was configured in the *Enhancing GitHub Actions* *workflows* section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境，你还可以指定仅在这些环境中可用的变量和密钥。我们需要之前创建的联合账户的租户ID、订阅ID和账户ID。这些信息已在*增强GitHub Actions工作流程*部分配置。
- en: As a reminder, to get the tenant ID, use `az account show –query tenantId -o
    tsv`). To get the subscription ID, use `az account show --query id -o tsv`. With
    the account, to use an environment, an additional credential is required.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，要获取租户ID，请使用`az account show –query tenantId -o tsv`。要获取订阅ID，请使用`az account
    show --query id -o tsv`。对于账户，要使用环境，还需要额外的凭证。
- en: 'Open the Entra portal ([https://entra.microsoft.com](https://entra.microsoft.com))
    and select `az-dev<date>`. Select `repo:<github org/repo>:pull_request` and `repo:<github
    org/repo:refs/heads/main` subject identifiers were added. Add a new credential
    and select **GitHub Actions deploying Azure resources**, as shown in *Figure 8**.10*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Entra门户([https://entra.microsoft.com](https://entra.microsoft.com))并选择`az-dev<date>`。选择`repo:<github
    org/repo>:pull_request`和`repo:<github org/repo:refs/heads/main>`主题标识符已添加。添加新的凭据并选择**GitHub
    Actions部署Azure资源**，如图*图8**.10*所示：
- en: '![Figure 8.10 – Environment credentials](img/B21217_08_10.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 环境凭据](img/B21217_08_10.jpg)'
- en: Figure 8.10 – Environment credentials
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 环境凭据
- en: Within this dialogue, add your GitHub **Organization** and **Repository**, select
    **Environment** for **Entity type**, enter the **GitHub environment name** value
    that matches your GitHub environment, and provide **Credential details**.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对话框中，添加您的GitHub**组织**和**仓库**，选择**实体类型**为**环境**，输入与您的GitHub环境匹配的**GitHub环境名称**值，并提供**凭据详情**。
- en: To configure the secret, copy the **Application (client) ID** value of this
    app registration.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置密钥，复制此应用程序注册的**应用程序（客户端）ID**值。
- en: 'Once you have these values, open the environment in the GitHub portal and add
    **Environment secrets** and **Environment variables**, as shown in *Figure 8**.11*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了这些值，在GitHub门户中打开环境并添加**环境密钥**和**环境变量**，如图*图8**.11*所示：
- en: '![Figure 8.11 – Configuring Environment secrets and Environment variables](img/B21217_08_11.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 配置环境密钥和环境变量](img/B21217_08_11.jpg)'
- en: Figure 8.11 – Configuring Environment secrets and Environment variables
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 配置环境密钥和环境变量
- en: 'The following variables are required:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 需要以下变量：
- en: '`AZURE_ENV_NAME`: The resource group name that should be used without the `rg-`
    prefix – for example, `codebreaker-08-prod`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_ENV_NAME`: 应使用不带`rg-`前缀的资源组名称 – 例如，`codebreaker-08-prod`'
- en: '`AZURE_LOCATION`: Your preferred Azure region'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_LOCATION`: 您首选的Azure区域'
- en: 'You will need the following secrets:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下密钥：
- en: '`AZURE_SUBSCRIPTION_ID`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_SUBSCRIPTION_ID`'
- en: '`AZURE_TENANT_ID`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_TENANT_ID`'
- en: '`AZURE_CLIENT_ID`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AZURE_CLIENT_ID`'
- en: With this configuration in place, let’s update the workflows.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置就绪后，让我们更新工作流。
- en: Using environments with workflows
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工作流的环境
- en: 'To use an environment from a workflow, all you need to do is reference the
    environment name. Copy the shared workflow, `shared-deploy.yml`, to `shared-deploy-withenvironment.yml`
    and enhance it with an environment configuration:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用工作流中的环境，您只需引用环境名称。将共享工作流`shared-deploy.yml`复制到`shared-deploy-withenvironment.yml`，并增强其环境配置：
- en: workflows/shared-deploy-withenvironment.yml
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/shared-deploy-withenvironment.yml
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When configuring the job, the `environment` keyword is used to reference an
    environment name. With this implementation, a required input parameter is used
    to pass the name of the environment. No changes need to be made regarding the
    secrets and variables. When running in the environment, these values are retrieved
    from the environment configuration.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置作业时，使用`environment`关键字来引用环境名称。在此实现中，使用必需的输入参数来传递环境名称。无需对密钥和变量进行更改。在环境中运行时，这些值是从环境配置中检索的。
- en: 'The `codebreaker-production.yml` workflow, which uses the various workflows
    to create and push the Docker image and publish the Container App, is different
    from the development environment, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用各种工作流创建和推送Docker镜像以及发布容器应用的`codebreaker-production.yml`工作流与开发环境不同，如下所示：
- en: workflows/codebreaker- produnction.yml
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: workflows/codebreaker- produnction.yml
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The environment parameter is now set to `codebreaker-08-prod`. This time, the
    secrets are not explicitly declared, but all secrets this workflow has access
    to are given to the called workflow. Because of the environment specified by the
    called workflow, secrets and variables are referenced from the GitHub environment.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 环境参数现在设置为`codebreaker-08-prod`。这次，密钥没有明确声明，但所有此工作流可以访问的密钥都传递给了被调用的工作流。由于被调用工作流指定的环境，密钥和变量是从GitHub环境引用的。
- en: 'Now, you can try triggering the workflow. The first stage runs, but the second
    stage must be reviewed, as shown in *Figure 8**.12*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以尝试触发工作流。第一阶段运行，但第二阶段必须进行审查，如图*图8**.12*所示：
- en: '![Figure 8.12 – Workflow review requested](img/B21217_08_12.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 工作流请求审查](img/B21217_08_12.jpg)'
- en: Figure 8.12 – Workflow review requested
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 工作流请求审查
- en: 'Review the results of the workflow and approve it, as shown in *Figure 8**.13*:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 查看工作流程的结果并批准它，如图 *8.13* 所示：
- en: '![Figure 8.13 – Approve and deploy](img/B21217_08_13.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 批准和部署](img/B21217_08_13.jpg)'
- en: Figure 8.13 – Approve and deploy
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 批准和部署
- en: At this point, you need to wait a few minutes until all the resources are deployed
    to the production environment. Verify that the deployment succeeded. After a successful
    deployment, you can use a client, update the link to the new environment, and
    play a game.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你需要等待几分钟，直到所有资源都部署到生产环境中。验证部署是否成功。在成功部署后，你可以使用客户端，更新到新环境的链接，并玩游戏。
- en: For the client programmers, we’ll create a NuGet package.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端程序员，我们将创建一个 NuGet 包。
- en: Publishing NuGet packages
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布 NuGet 包
- en: With our solution, we also have libraries that are used by client applications.
    Having NuGet packages helps with using these libraries. By creating a GitHub action,
    we can automatically build and publish the NuGet package. If you want to make
    a package publicly available, you can publish it to the NuGet server (you’ve already
    used packages that are available for this book). To make packages private with
    authentication, GitHub offers **GitHub Packages**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的解决方案中，我们还有客户端应用程序使用的库。拥有 NuGet 包有助于使用这些库。通过创建 GitHub 动作，我们可以自动构建和发布 NuGet
    包。如果你想使包公开可用，你可以将其发布到 NuGet 服务器（你已经使用过可用于本书的包）。要使包私有并需要身份验证，GitHub 提供 **GitHub
    Packages**。
- en: Preparing the library project
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备库项目
- en: Adding some metadata, such as a README Markdown file to the project describing
    the package, and a custom icon to replace the default icon, enhances usability.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目中添加一些元数据，例如描述包的 README Markdown 文件，以及替换默认图标的自定义图标，可以增强可用性。
- en: 'The `Codebreaker.GameAPIs.KiotaClient` project contains a `readme.md` file
    and a JPG file for an icon. These additions need to be uploaded within the project
    file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.KiotaClient` 项目包含一个 `readme.md` 文件和一个图标 JPG 文件。这些添加需要在项目文件中上传：'
- en: Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The README file and the icon don’t need to be built into the library, which
    is why `None` is used within `ItemGroup` to exclude them from the build result
    of the library. Adding these items to the NuGet package is specified by the `Pack`
    attribute. `PackagePath` specifies the folder within the package where these items
    can be found.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: README 文件和图标不需要构建到库中，这就是为什么在 `ItemGroup` 中使用 `None` 来排除它们从库的构建结果中。将这些项目添加到 NuGet
    包中是通过 `Pack` 属性指定的。`PackagePath` 指定这些项目可以在包中的哪个文件夹找到。
- en: 'The following `PropertyGroup` definitions specify the use of the README file
    and the package icon and add some metadata:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `PropertyGroup` 定义指定了 README 文件和包图标的使用，并添加了一些元数据：
- en: Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj
- en: '[PRE27]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Adding metadata to the package is specified with the `PackageId`, `PackageTags`,
    and `Description` elements.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PackageId`、`PackageTags` 和 `Description` 元素指定向包添加元数据。
- en: It’s also a good idea to define the version of the package. With the source
    code repository, the `VersionPrefix` element, which is defined within the `Directory.Build.props`
    file, specifies the first part of the version for all the projects found in subdirectories.
    Using a GitHub action, a `VersionSuffix` element is added dynamically that increments
    with every build. This versioning scheme is used with `alpha`, `beta`, and `prerelease`
    versions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 定义包的版本也是一个好主意。与源代码仓库一起，`Directory.Build.props` 文件中定义的 `VersionPrefix` 元素指定了子目录中找到的所有项目的版本的第一部分。使用
    GitHub 动作，动态添加一个 `VersionSuffix` 元素，该元素在每次构建时递增。这种版本控制方案用于 `alpha`、`beta` 和 `prerelease`
    版本。
- en: As soon as the library is released, the `Version` element is added to specify
    the complete version of the package. Adding the `Version` element to the project
    overrides `VersionPrefix` and `VersionSuffix`, and just this version is used.
    After the release, when the next beta versions are available, the `Version` element
    is removed again, and the `VersionPrefix` element is incremented to the next iteration.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库发布，就会添加 `Version` 元素来指定包的完整版本。将 `Version` 元素添加到项目会覆盖 `VersionPrefix` 和 `VersionSuffix`，并且只使用这个版本。发布后，当下一个
    beta 版本可用时，`Version` 元素再次被移除，`VersionPrefix` 元素递增到下一个迭代。
- en: Creating access tokens
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建访问令牌
- en: To publish a package to GitHub Packages, a **personal access token (classic)**
    is required. At the time of writing, the new fine-grained personal access tokens
    cannot be used with GitHub Packages.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要将包发布到 GitHub Packages，需要一个**个人访问令牌（经典版）**。在撰写本文时，新的细粒度个人访问令牌不能与 GitHub Packages
    一起使用。
- en: You can create a personal access token by clicking on the user icon in the top-right
    corner, selecting **Settings**, and then clicking on **Developer Settings** in
    the left pane. Select **Personal access tokens** and click **Tokens (classic)**.
    To create a new token, select **Generate new token (classic)**. Select an expiration
    date. The scope that is required to publish packages is **write:packages**. Selecting
    this scope also adds other scopes, such as reading packages and access to the
    repository. Click **Generate token**. You need to copy this generated token –
    it will not be visible again after you close the screen. Just make sure you store
    it in a safe place. You can create a new token in case you don’t have one anymore,
    or when the token has expired.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击右上角的用户图标，选择**设置**，然后在左侧面板中点击**开发者设置**来创建一个个人访问令牌。选择**个人访问令牌**并点击**令牌（经典版）**。要创建新令牌，选择**生成新令牌（经典版）**。选择一个过期日期。发布包所需的范围是**write:packages**。选择此范围还会添加其他范围，例如读取包和访问仓库。点击**生成令牌**。你需要复制这个生成的令牌——关闭屏幕后它将不再可见。只需确保将其存储在安全的地方。如果你没有令牌，或者令牌已过期，你可以创建一个新的令牌。
- en: For the GitHub action you wish to use, store this token alongside the secrets
    of the `PAT_PUBLISHPACKAGE` repository.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你希望使用的 GitHub 动作，将此令牌存储在 `PAT_PUBLISHPACKAGE` 仓库的秘密中。
- en: Now that we’ve stored this secret, let’s use it with a GitHub action.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经存储了这个秘密，让我们使用 GitHub 动作来使用它。
- en: Creating a GitHub action to publish a GitHub package
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用于发布 GitHub 包的 GitHub 动作
- en: The GitHub actions that are used to create a NuGet package have similarities
    with the GitHub actions we created previously. Check out the source code repository
    for details.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建 NuGet 包的 GitHub 动作与我们之前创建的 GitHub 动作有相似之处。查看源代码仓库以获取详细信息。
- en: 'The `shared-create-nuget.yml` shared workflow builds the NuGet package and
    uploads it with GitHub artifacts. The following steps are completed in this workflow:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared-create-nuget.yml` 共享工作流程构建 NuGet 包并将其与 GitHub 艺术品一起上传。以下步骤在此工作流程中完成：'
- en: Check out the source code.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看源代码。
- en: Set up .NET.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 .NET。
- en: Calculate the build number (using a configured offset to the GitHub build number).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算构建号（使用配置的偏移量到 GitHub 构建号）。
- en: Build the library using `dotnet build`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet build` 构建库。
- en: Test the library using `dotnet test`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet test` 测试库。
- en: Create a NuGet package using `dotnet pack`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet pack` 创建 NuGet 包。
- en: Upload the package with GitHub artifacts.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GitHub 艺术品上传包。
- en: 'The next shared workflow (`shared-githubpackages.yml`) uploads the package
    to GitHub Packages by following these steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个共享工作流程（`shared-githubpackages.yml`）通过以下步骤将包上传到 GitHub Packages：
- en: Download the GitHub artifact.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 GitHub 艺术品。
- en: Set up .NET.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 .NET。
- en: Set the NuGet source with `dotnet nuget` `add source`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet nuget add source` 设置 NuGet 源。
- en: Push the package to GitHub Packages with `dotnet` `nuget push`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet nuget push` 将包推送到 GitHub Packages。
- en: Pushing the package makes use of the configured access token.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 推送包时使用配置的访问令牌。
- en: 'The `kiota-lib.yml` workflow connects the two shared workflows and passes parameters.
    Upon running this workflow successfully, you can verify the packages with the
    organization of your GitHub repository, as shown in *Figure 8**.14*:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`kiota-lib.yml` 工作流程连接两个共享工作流程并传递参数。在成功运行此工作流程后，你可以使用 GitHub 仓库的组织验证包，如图 8.14
    所示。14*：'
- en: '![Figure 8.14 – GitHub Packages](img/B21217_08_14.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – GitHub Packages](img/B21217_08_14.jpg)'
- en: Figure 8.14 – GitHub Packages
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – GitHub Packages
- en: Using GitHub environments, you can enhance the creation of NuGet packages and
    define environments, such as those to publish to the publicly available NuGet
    server only after successfully using a private feed with GitHub Packages.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitHub 环境，你可以增强 NuGet 包的创建并定义环境，例如，在成功使用 GitHub Packages 的私有源之后，仅将包发布到公开可用的
    NuGet 服务器。
- en: With modern deployments, there’s more than just using development, staging,
    and production environments. We’ll discuss this next.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代部署中，不仅仅是使用开发、测试和生产环境。我们将在下一节讨论这个问题。
- en: Using modern deployment patterns
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现代部署模式
- en: 'Using development, staging, and production environments is one of the “traditional”
    deployment patterns. Nowadays, other deployment patterns are used as well:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开发、预发布和生产环境是“传统”部署模式之一。如今，也使用了其他部署模式：
- en: When using **canary releases**, different versions of an application are available
    for the user to choose from. This is evident from the Edge browser, which offers
    a Beta channel that’s updated monthly, a Dev channel that’s updated weekly, and
    a Canary channel that’s updated daily. The user can decide what version to test.
    See [https://www.microsoft.com/en-us/edge/download/insider](https://www.microsoft.com/en-us/edge/download/insider)
    for more details.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用**金丝雀发布**时，用户可以选择不同的应用程序版本。这从Edge浏览器中很明显，它提供每月更新的Beta频道、每周更新的Dev频道和每日更新的金丝雀频道。用户可以决定要测试哪个版本。有关更多详细信息，请参阅[https://www.microsoft.com/en-us/edge/download/insider](https://www.microsoft.com/en-us/edge/download/insider)。
- en: With **A/B testing**, users randomly receive one of two different user interfaces.
    When using this pattern, you can monitor which UI allows the user to be more productive.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**A/B测试**中，用户随机收到两种不同的用户界面之一。当使用此模式时，您可以监控哪种UI可以让用户更高效。
- en: '**Blue-green deployments** allow you to quickly roll back an installation by
    installing to a staging server, swapping staging with production. If something
    fails, an easy rollback can be done.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**允许您通过安装到预发布服务器，交换预发布与生产环境，快速回滚安装。如果出现问题，可以轻松回滚。'
- en: '**Dark launching** is a pattern that you can use to publish a new version of
    the application while ensuring that the new features are hidden until they are
    activated by turning on a switch. One example of this is when a feature should
    be available at a specific time. This switch can be turned on by a time event
    – there’s no need to redeploy the application.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暗启动**是一种模式，您可以在确保新功能在激活开关打开之前隐藏的情况下发布应用程序的新版本。一个例子是当功能应在特定时间可用时。此开关可以通过时间事件打开
    – 无需重新部署应用程序。'
- en: '**Feature toggles** allow you to turn each feature on/off. One option is to
    enable some of the features for a specific group of users, such as early adopters.
    Users themselves can also decide which of the new features they want to test.
    Such toggles are available with Microsoft Azure and Visual Studio.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能开关**允许您打开/关闭每个功能。一个选项是为特定用户组启用一些功能，例如早期采用者。用户自己也可以决定他们想要测试的新功能。此类开关在Microsoft
    Azure和Visual Studio中可用。'
- en: In [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162), you saw Azure App Configuration
    in action. This Azure service not only supports a central application configuration
    but also offers feature flags. This functionality of Azure App Configuration can
    be used with several of the modern deployment patterns by using different feature
    flag filters.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B21217_07.xhtml#_idTextAnchor162)中，您看到了Azure App Configuration的实际应用。这项Azure服务不仅支持集中式应用程序配置，还提供了功能标志。Azure
    App Configuration的这项功能可以通过使用不同的功能标志过滤器与几种现代部署模式一起使用。
- en: Configuring feature flags
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置功能标志
- en: Let’s open the Azure App Configuration service that was created with Bicep scripts.
    In the left pane, within the **Operations** category, open **Feature manager**.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开使用Bicep脚本创建的Azure App Configuration服务。在左侧面板中，在**操作**类别下，打开**功能管理器**。
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might not have access to this resource to add configuration data since the
    resource was created from Bicep scripts. Using **Access control (IAM)**, add your
    user to the **App Configuration Data Owner** or **Contributor** role. You might
    need to wait about 15 minutes before the role changes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于资源是从Bicep脚本创建的，您可能无法访问此资源以添加配置数据。使用**访问控制（IAM）**，将您的用户添加到**应用程序配置数据所有者**或**贡献者**角色。您可能需要等待大约15分钟，角色才会更改。
- en: 'Create a new feature flag, as shown in *Figure 8**.15*:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的功能标志，如图*8.15*所示：
- en: '![Figure 8.15 – Creating feature flags](img/B21217_08_15.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 创建功能标志](img/B21217_08_15.jpg)'
- en: Figure 8.15 – Creating feature flags
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 创建功能标志
- en: Set the feature flag’s name to `Feature8x5Game`, add a description, and check
    the `FeatureGame6x4Mini`, `FeatureGame6x4`, and `FeatureGame5x5x4`. Don’t add
    filters for the first two; just enable one of these. For the last one, add a time
    filter so that it can be enabled in the future, but don’t set an expiration date.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能标志的名称设置为`Feature8x5Game`，添加描述，并勾选`FeatureGame6x4Mini`、`FeatureGame6x4`和`FeatureGame5x5x4`。对于前两个，不要添加过滤器；只需启用这些中的一个。对于最后一个，添加时间过滤器，以便将来可以启用，但不要设置过期日期。
- en: The **targeting filter** allows you to open a feature for a specific user group
    (early adopters). It can also act as a percentage filter, so you can turn this
    feature on for a random percentage of users. The other built-in filter is the
    **time window filter**. Using this filter, you can specify start and end times
    when this feature should be enabled. You can also create a custom implementation
    for a filter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标过滤器**允许您为特定用户组（早期采用者）打开功能。它也可以作为百分比过滤器，因此您可以为此随机百分比的用户打开此功能。另一个内置过滤器是**时间窗口过滤器**。使用此过滤器，您可以指定此功能应启用的开始和结束时间。您还可以为过滤器创建自定义实现。'
- en: Now that we’ve configured this feature flag, let’s use this from the `game-apis`
    service.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了这个功能标志，让我们从`game-apis`服务中使用它。
- en: DI and middleware configuration for feature flags
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能标志的DI和中间件配置
- en: 'To use Feature Management, add the `Microsoft.FeatureManagement.AspNetCore`
    NuGet package to the `Codebreaker.GameAPIs` project. The DI container needs to
    be configured for feature flags, as shown here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用功能管理，将`Microsoft.FeatureManagement.AspNetCore` NuGet包添加到`Codebreaker.GameAPIs`项目中。DI容器需要配置功能标志，如下所示：
- en: Codebreaker.GameAPIs/Program.cs
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Program.cs
- en: '[PRE28]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `AddFeatureManagement` extension method registers types that are needed
    for feature flags. Every filter that is used is added using the `AddFeatureFilter`
    extension method.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddFeatureManagement`扩展方法注册了功能标志所需的类型。每个使用的过滤器都通过`AddFeatureFilter`扩展方法添加。'
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The Feature Management API can also be used without Azure App Configuration.
    Upon viewing the source code in this book’s GitHub repository, you’ll see that
    the Feature Management API can be configured without using Azure as well. In this
    case, an overload of the `AddFeatureManagement` API is invoked to pass an `IConfiguration`
    object. With this, feature flags can be configured with the .NET configuration
    options. Revisit [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162) for more information
    on configuration.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 功能管理API也可以在不使用Azure的情况下使用。在查看本书GitHub仓库中的源代码时，您会看到功能管理API也可以不使用Azure进行配置。在这种情况下，调用`AddFeatureManagement`
    API的重载以传递`IConfiguration`对象。有了这个，功能标志可以使用.NET配置选项进行配置。请参阅[*第7章*](B21217_07.xhtml#_idTextAnchor162)以获取有关配置的更多信息。
- en: 'To connect Feature Management with Azure App Configuration, you must update
    the `AddAzureAppConfiguration` method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要将功能管理连接到Azure App Configuration，您必须更新`AddAzureAppConfiguration`方法：
- en: Codebreaker.GameAPIs/Program.cs
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Program.cs
- en: '[PRE29]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`UseFeatureFlags` is a method of the `AzureAppConfigurationOptions` class for
    connecting feature flags.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseFeatureFlags`是`AzureAppConfigurationOptions`类的一个方法，用于连接功能标志。'
- en: 'When using feature flags, the Azure App Configuration middleware also needs
    to be configured:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用功能标志时，Azure App Configuration中间件也需要进行配置：
- en: Codebreaker.GameAPIs/Program.cs
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Program.cs
- en: '[PRE30]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the setup in place, we can check if feature flags have been set.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们可以检查功能标志是否已设置。
- en: Using feature flags
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用功能标志
- en: 'Now, we can use the feature manager to check if features are available. We’ll
    start by creating an extension method for the `IFeatureManager` interface:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用功能管理器来检查功能是否可用。我们将首先为`IFeatureManager`接口创建一个扩展方法：
- en: Codebreaker.GameAPIs/Extensions/FeatureManagerExtensions.cs
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Extensions/FeatureManagerExtensions.cs
- en: '[PRE31]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method uses the `GetFeatureNamesAsync` and `IsEnabledAsync` methods defined
    by the `IFeatureManager` interface. On the first invocation of this method, the
    list of features registered with the feature manager is retrieved and added to
    the `_featureNames` collection. Not every game type is registered as a feature.
    For the game types that are not registered as features, the method returns `true`
    to inform us that this type is available. With all the game types registered as
    a feature, the `IsEnabledAsync` method is used to check if the feature is enabled.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用由`IFeatureManager`接口定义的`GetFeatureNamesAsync`和`IsEnabledAsync`方法。在第一次调用此方法时，检索与功能管理器注册的功能列表，并将其添加到`_featureNames`集合中。并非每种游戏类型都注册为功能。对于未注册为功能的游戏类型，该方法返回`true`以通知我们此类型可用。对于所有已注册为功能的游戏类型，使用`IsEnabledAsync`方法来检查功能是否启用。
- en: 'Next, let’s inject `IFeatureManager` with the minimal API:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用最少的API注入`IFeatureManager`：
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
- en: '[PRE32]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: On starting a game using the API, the `IFeatureManagement` interface is injected
    to check the requested game type for the feature to be enabled using the previously
    created extension method, `IsGameTypeAvailable`. Depending on the result, an error
    is returned, or a new game is created.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用API启动游戏时，`IFeatureManagement`接口被注入以检查请求的游戏类型，并使用之前创建的扩展方法`IsGameTypeAvailable`启用功能。根据结果，会返回错误或创建一个新的游戏。
- en: With this implementation, you can run the application and test these feature
    flags. The `game-apis` project contains an HTTP file that you can use to create
    all the different game types and see the results that were returned when using
    feature flags. You can test this locally on your developer system. Upon pushing
    an update to your GitHub repository, a workflow is ready to be triggered. Then,
    you just need to configure the link of your API service within the HTTP file to
    test the service that’s running with Azure Container Apps.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实现，您可以运行应用程序并测试这些功能标志。`game-apis`项目包含一个HTTP文件，您可以使用它创建所有不同的游戏类型，并查看使用功能标志时返回的结果。您可以在您的开发系统上本地测试。在将更新推送到您的GitHub仓库后，一个工作流程已准备好被触发。然后，您只需在HTTP文件中配置您的API服务的链接，以测试使用Azure
    Container Apps运行的服务。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After creating Azure services with Bicep scripts in [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137),
    in this chapter, you learned how to use **continuous integration** (**CI**) and
    **continuous delivery** (**CD**) with GitHub Actions. Here, you changed the source
    code, created and merged a pull request, tested code, and deployed Azure Container
    Apps. Using GitHub Actions, you learned how to build NuGet packages and push them
    to GitHub Packages.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21217_06.xhtml#_idTextAnchor137)中使用Bicep脚本创建Azure服务之后，在本章中，您学习了如何使用GitHub
    Actions进行**持续集成**（**CI**）和**持续交付**（**CD**）。在这里，您更改了源代码，创建并合并了一个拉取请求，测试了代码，并部署了Azure
    Container Apps。使用GitHub Actions，您学习了如何构建NuGet包并将它们推送到GitHub Packages。
- en: Using GitHub environments, you created multiple deployment environments where
    additional checks are required before deployment is extended to another stage.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitHub环境，您创建了多个部署环境，在部署扩展到另一个阶段之前需要执行额外的检查。
- en: After, you learned how to configure Azure App Configuration, as well as how
    to use feature flags, which are needed for modern deployment patterns such as
    A/B testing, blue-green deployments, and dark launching.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您学习了如何配置Azure App Configuration，以及如何使用功能标志，这些标志对于现代部署模式（如A/B测试、蓝绿部署和暗启动）是必需的。
- en: 'The next chapter covers another important topic: authentication and authorization.
    In [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162), you learned how to run Azure
    services with managed identities. In [*Chapter 9*](B21217_09.xhtml#_idTextAnchor216),
    we’ll restrict the applications that are allowed to invoke APIs, authenticate
    users to restrict functionality for anonymous users, and add APIs that are only
    allowed to be used by specific user groups.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖另一个重要主题：身份验证和授权。在[*第7章*](B21217_07.xhtml#_idTextAnchor162)中，您学习了如何使用托管标识运行Azure服务。在[*第9章*](B21217_09.xhtml#_idTextAnchor216)中，我们将限制允许调用API的应用程序，对匿名用户的功能进行限制，并添加仅允许特定用户组使用的API。
- en: Further reading
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解更多关于本章讨论的主题，请参考以下链接：
- en: '*GitHub Actions* *documentation*: [https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitHub Actions* 文档：[https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
- en: '*azd: configure a* *pipeline*: [https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline](https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*azd: 配置* *管道*：[https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline](https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline)'
- en: '*Using environments for* *deployments*: [https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用环境进行* *部署*：[https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment)'
- en: '*Creating custom protection* *rules*: [https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules](https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义保护* 规则：[https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules](https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules)'
- en: '*Microsoft Feature Management* *documentation*: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Microsoft 功能管理* 文档：[https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet)'
