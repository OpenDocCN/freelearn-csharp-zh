<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Parallel Programming Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Parallel Programming Patterns</h1></div></div></div><p>In this chapter, we will review the common problems that a programmer often faces while trying to implement a parallel workflow. You will learn the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing Lazy-evaluated shared states</li><li class="listitem" style="list-style-type: disc">Implementing Parallel Pipeline with <code class="literal">BlockingCollection</code></li><li class="listitem" style="list-style-type: disc">Implementing Parallel Pipeline with TPL DataFlow</li><li class="listitem" style="list-style-type: disc">Implementing Map/Reduce with PLINQ</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec83"/>Introduction</h1></div></div></div><p>Patterns in programming means a concrete and standard solution to a given problem. Usually, programming patterns are the result of people gathering experience, analyzing the common problems, and providing solutions to these problems.</p><p>Since parallel programming has existed for quite a long time, there are many different patterns that are used to program parallel applications. There are even special programming languages to make programming of specific parallel algorithms easier. However, this is where things start to become increasingly complicated. In this chapter, I will provide you with a starting point from where you will be able to study parallel programming further. We will review very basic, yet very useful, patterns that are quite helpful for many common situations in parallel programming.</p><p>First, we will be using a<a id="id389" class="indexterm"/> <span class="strong"><strong>shared-state object</strong></span> from multiple threads. I would like to emphasize that you should avoid it as much as possible. As we discussed in previous chapters, a shared state is really bad when you write parallel algorithms, but on many occasions, it is inevitable. We will find out how to delay the actual computation of an object until it is needed and how to implement different scenarios to achieve thread safety.</p><p>Then, we will show you how<a id="id390" class="indexterm"/> to create a structured parallel data flow. We will review a concrete case of a producer/consumer pattern, which is called <span class="strong"><strong>Parallel Pipeline</strong></span>. We are going to implement it by just blocking the collection first, and then we will see how <a id="id391" class="indexterm"/>helpful another library from Microsoft is for parallel programming—<span class="strong"><strong>TPL DataFlow</strong></span>.</p><p>The last pattern that we will study is <a id="id392" class="indexterm"/>the <span class="strong"><strong>Map/Reduce</strong></span> pattern. In the modern world, this name could mean very different things. Some people consider Map/Reduce not as a common approach to any problem, but as a concrete implementation for large, distributed cluster computations. We will find out the meaning behind the name of this pattern and review some examples of how it might work in cases of small parallel applications.</p></div></div>
<div class="section" title="Implementing Lazy-evaluated shared states"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec84"/>Implementing Lazy-evaluated shared states</h1></div></div></div><p>This recipe shows how to <a id="id393" class="indexterm"/>program a Lazy-evaluated, thread-safe shared state object.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec209"/>Getting ready</h2></div></div></div><p>To start this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe1</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec210"/>How to do it...</h2></div></div></div><p>To implement Lazy-evaluated shared states, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static async Task ProcessAsynchronously()
{
  var unsafeState = new UnsafeState();
  Task[] tasks = new Task[4];

  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(unsafeState));
  }
  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var firstState = new DoubleCheckedLocking();
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(firstState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var secondState = new BCLDoubleChecked();
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(secondState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var lazy = new Lazy&lt;ValueToAccess&gt;(Compute);
      var thirdState = new LazyWrapper(lazy);
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(thirdState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var fourthState = new BCLThreadSafeFactory();
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(fourthState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

}

static void Worker(IHasValue state)
{
  WriteLine($"Worker runs on thread id {CurrentThread.ManagedThreadId}");
  WriteLine($"State value: {state.Value.Text}");
}

static ValueToAccess Compute()
{
  WriteLine("The value is being constructed on a thread " +
        $"id {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(1));
  return new ValueToAccess(
            $"Constructed on thread id {CurrentThread.ManagedThreadId}");
}

class ValueToAccess
{
  private readonly string _text; 
  public ValueToAccess(string text)
  {
    _text = text;
  }

  public string Text =&gt; _text;
}

class UnsafeState : IHasValue
{
  private ValueToAccess _value;

  public ValueToAccess Value =&gt;_value ?? (_value = Compute());
}

class DoubleCheckedLocking : IHasValue
{
  private readonly object _syncRoot = new object();
  private volatile ValueToAccess _value;

  public ValueToAccess Value
  {
    get
    {
      if (_value == null)
      {
        lock (_syncRoot)
        {
          if (_value == null) _value = Compute();
        }
      }
      return _value;
    }
  }
}

class BCLDoubleChecked : IHasValue
{
  private object _syncRoot = new object();
  private ValueToAccess _value;
  private bool _initialized;

  public ValueToAccess Value =&gt; LazyInitializer.EnsureInitialized(
    ref _value, ref _initialized, ref _syncRoot, Compute);
}

class BCLThreadSafeFactory : IHasValue
{
  private ValueToAccess _value;

  public ValueToAccess Value =&gt; LazyInitializer.EnsureInitialized(ref _value, Compute);
}

class LazyWrapper : IHasValue
{
  private readonly Lazy&lt;ValueToAccess&gt; _value;

  public LazyWrapper(Lazy&lt;ValueToAccess&gt; value )
  {
    _value = value;
  }

  public ValueToAccess Value =&gt; _value.Value;
}

interface IHasValue
{
  ValueToAccess Value { get; }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var t = ProcessAsynchronously();
t.GetAwaiter().GetResult();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec211"/>How it works...</h2></div></div></div><p>The first example shows why it is not safe to use the <code class="literal">UnsafeState</code> object with multiple accessing threads. We<a id="id394" class="indexterm"/> see that the <code class="literal">Construct</code> method was called several times, and different threads use different values, which is obviously not right. To fix this, we can use a lock when reading the value, and if it is not initialized, create it first. This will work, but using a lock with every read operation is not efficient. To avoid using locks every time, we can use a traditional approach called the <a id="id395" class="indexterm"/>
<span class="strong"><strong>double-checked locking</strong></span> pattern. We check the value for the first time, and if is not null, we avoid unnecessary locking and just use the shared object. However, if it was not constructed, we use the lock and then check the value for the second time because it could be initialized between our first check and the lock operation. If it is still not initialized, only then do we compute the value. We can clearly see that this approach works with the second example—there is only one call to the <code class="literal">Construct</code> method, and the first-called thread defines the shared object state.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Note that if the Lazy-evaluated object implementation is thread-safe, it does not automatically mean that all its properties are thread-safe as well.</p><p>If you add, for example, an <code class="literal">int</code> public property to the <code class="literal">ValueToAccess</code> object, it will not be thread-safe; you still have to use interlocked constructs or locking to ensure thread safety.</p></div></div><p>This pattern is very common, and that is why there are several classes in the Base Class Library to help us. First, we <a id="id396" class="indexterm"/>can use the <code class="literal">LazyInitializer.EnsureInitialized</code> method, which implements the double-checked locking pattern inside. However, the most comfortable option is to use the <code class="literal">Lazy&lt;T&gt;</code> class, which allows us to have thread-safe, Lazy-evaluated, shared state, out of the box. The next two examples show us that they are equivalent to the second one, and the program behaves in the same way. The only difference is that since <code class="literal">LazyInitializer</code> is a static class, we do not have to create a new instance of a class, as we do in the case of <code class="literal">Lazy&lt;T&gt;</code>, and therefore, the performance in the first case can be better in some rare scenarios.</p><p>The last option is to avoid locking at all if we do not care about the <code class="literal">Construct</code> method. If it is thread-safe and has no side effects/serious performance impacts, we can just run it several times but use only the first constructed value. The last example shows the described behavior, and we can achieve this result using another <code class="literal">LazyInitializer.EnsureInitialized</code> method overload.</p></div></div>
<div class="section" title="Implementing Parallel Pipeline with BlockingCollection"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec85"/>Implementing Parallel Pipeline with BlockingCollection</h1></div></div></div><p>This recipe<a id="id397" class="indexterm"/> will describe how to implement a <a id="id398" class="indexterm"/>specific scenario of a producer/consumer pattern, which is called Parallel Pipeline, using the standard <code class="literal">BlockingCollection</code> data structure.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec212"/>Getting ready</h2></div></div></div><p>To begin this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe2</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec213"/>How to do it...</h2></div></div></div><p>To understand how to implement Parallel Pipeline using <code class="literal">BlockingCollection</code>, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">private const int CollectionsNumber = 4;
private const int Count = 5;

static void CreateInitialValues(BlockingCollection&lt;int&gt;[] sourceArrays, CancellationTokenSource cts)
{
  Parallel.For(0, sourceArrays.Length*Count, (j, state) =&gt;
  {
      if (cts.Token.IsCancellationRequested)
      {
          state.Stop();
      }

      int number = GetRandomNumber(j);
      int k = BlockingCollection&lt;int&gt;.TryAddToAny(sourceArrays, j);
      if (k &gt;= 0)
      {
          WriteLine(
              $"added {j} to source data on thread " +
              $"id {CurrentThread.ManagedThreadId}");
          Sleep(TimeSpan.FromMilliseconds(number));
      }
  });
  foreach (var arr in sourceArrays)
  {
      arr.CompleteAdding();
  }
}

static int GetRandomNumber(int seed)
{
  return new Random(seed).Next(500);
}

class PipelineWorker&lt;TInput, TOutput&gt;
{
  Func&lt;TInput, TOutput&gt; _processor;
  Action&lt;TInput&gt; _outputProcessor;
  BlockingCollection&lt;TInput&gt;[] _input;
  CancellationToken _token;
  Random _rnd;

  public PipelineWorker(
      BlockingCollection&lt;TInput&gt;[] input,
      Func&lt;TInput, TOutput&gt; processor,
      CancellationToken token,
      string name)
  {
    _input = input;
    Output = new BlockingCollection&lt;TOutput&gt;[_input.Length];
    for (int i = 0; i &lt; Output.Length; i++)
      Output[i] = null == input[i] ? null
        : new BlockingCollection&lt;TOutput&gt;(Count);

    _processor = processor;
    _token = token;
    Name = name;
    _rnd = new Random(DateTime.Now.Millisecond);
  }

  public PipelineWorker(
      BlockingCollection&lt;TInput&gt;[] input,
      Action&lt;TInput&gt; renderer,
      CancellationToken token,
      string name)
  {
    _input = input;
    _outputProcessor = renderer;
    _token = token;
    Name = name;
    Output = null;
    _rnd = new Random(DateTime.Now.Millisecond);
    }

  public BlockingCollection&lt;TOutput&gt;[] Output { get; private set; }

  public string Name { get; private set; }

  public void Run()
  {
    WriteLine($"{Name} is running");
    while (!_input.All(bc =&gt; bc.IsCompleted) &amp;&amp; 
      !_token.IsCancellationRequested)
    {
      TInput receivedItem;
      int i = BlockingCollection&lt;TInput&gt;.TryTakeFromAny(
          _input, out receivedItem, 50, _token);
      if (i &gt;= 0)
      {
        if (Output != null)
        {
          TOutput outputItem = _processor(receivedItem);
        BlockingCollection&lt;TOutput&gt;.AddToAny(
            Output, outputItem);
        WriteLine($"{Name} sent {outputItem} to next, on " +
        $"thread id {CurrentThread.ManagedThreadId}");
        Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));
        }
        else
        {
          _outputProcessor(receivedItem);
        }
      }
      else
      {
        Sleep(TimeSpan.FromMilliseconds(50));
      }
    }
    if (Output != null)
    {
      foreach (var bc in Output) bc.CompleteAdding();
    }
  }
}</pre></div></li><li class="listitem">Add the<a id="id399" class="indexterm"/> following<a id="id400" class="indexterm"/> code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var cts = new CancellationTokenSource();

Task.Run(() =&gt;
{
  if (ReadKey().KeyChar == 'c') cts.Cancel();
}, 
cts.Token);

var sourceArrays = new BlockingCollection&lt;int&gt;[CollectionsNumber];

for (int i = 0; i &lt; sourceArrays.Length; i++)
{
  sourceArrays[i] = new BlockingCollection&lt;int&gt;(Count);
}

var convertToDecimal = new PipelineWorker&lt;int, decimal&gt;
(
  sourceArrays,
  n =&gt; Convert.ToDecimal(n*100),
  cts.Token,
  "Decimal Converter"
);

var stringifyNumber = new PipelineWorker&lt;decimal, string&gt;
(
  convertToDecimal.Output,
  s =&gt; $"--{s.ToString("C", CultureInfo.GetCultureInfo("en-us"))}--",
  cts.Token,
  "String Formatter"
  );

var outputResultToConsole = new PipelineWorker&lt;string, string&gt;
(
  stringifyNumber.Output,
  s =&gt; WriteLine($"The final result is {s} on thread " +
            $"id {CurrentThread.ManagedThreadId}"),
  cts.Token,
  "Console Output"
  );

try
{
  Parallel.Invoke(
    () =&gt;
    CreateInitialValues(sourceArrays, cts),
    () =&gt; convertToDecimal.Run(),
    () =&gt; stringifyNumber.Run(),
    () =&gt; outputResultToConsole.Run()
  );
}
catch (AggregateException ae)
{
  foreach (var ex in ae.InnerExceptions)
    WriteLine(ex.Message + ex.StackTrace);
}

if (cts.Token.IsCancellationRequested)
{
  WriteLine("Operation has been canceled! Press ENTER to exit.");
}
else
{
  WriteLine("Press ENTER to exit.");
}
ReadLine();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec214"/>How it works...</h2></div></div></div><p>In the preceding <a id="id401" class="indexterm"/>example, we implement one of the most common parallel programming scenarios. Imagine that we have some data that has to pass through several computation stages, which takes a significant amount of time. The latter computation requires the results of the former, so we cannot run them in parallel.</p><p>If we had only one<a id="id402" class="indexterm"/> item to process, there would not be many possibilities to enhance the performance. However, if we run many items through the same set of computation stages, we can use a Parallel Pipeline technique. This means that we do not have to wait until all items pass through the first computation stage to go to the next one. It is enough to have just one item that finishes the stage; we move it to the next stage, and meanwhile, the next item is being by the previous stage, and so on. As a result, we almost have parallel processing shifted by the time required for the first item to pass through the first computation stage.</p><p>Here, we use four collections for each processing stage, illustrating that we can process every stage in parallel as well. The first step that we do is to provide the possibility to cancel the whole process by pressing the <span class="emphasis"><em>C</em></span> key. We create a cancelation token and run a separate task to monitor the <span class="emphasis"><em>C</em></span> key. Then, we define our pipeline. It consists of three main stages. The first stage is where we put the initial numbers on the first four collections that serve as the item source to the latter pipeline. This code is inside the <code class="literal">Parallel.For</code> loop of the <code class="literal">CreateInitialValues</code> method, which in turn is inside the <code class="literal">Parallel.Invoke</code> statement, as we run all the stages in parallel; the initial stage runs in parallel as well.</p><p>The next stage is defining our pipeline elements. The logic is defined inside the <code class="literal">PipelineWorker</code> class. We initialize the worker with the input collection, provide a transformation function, and then run the worker in parallel with the other workers. This way, we define two workers, or filters, because they filter the initial sequence. One of them turns an integer into a decimal value, and the second one turns a decimal to a string. Finally, the last worker just prints every incoming string to the console. In all the places, we provide a running thread ID to see how everything works. Besides this, we added artificial delays, so the item's processing will be more natural, as we really use heavy computations.</p><p>As a result, we see the exact expected behavior. First, some items are created on the initial collections. Then, we see that the first filter starts to process them, and as they are being processed, the second filter starts to work. Finally, the item goes to the last worker that prints it to the console.</p></div></div>
<div class="section" title="Implementing Parallel Pipeline with TPL DataFlow"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Implementing Parallel Pipeline with TPL DataFlow</h1></div></div></div><p>This recipe shows how<a id="id403" class="indexterm"/> to implement a Parallel<a id="id404" class="indexterm"/> Pipeline pattern with the help of the TPL DataFlow library.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec215"/>Getting ready</h2></div></div></div><p>To start this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe3</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec216"/>How to do it...</h2></div></div></div><p>To understand how to implement Parallel Pipeline with TPL DataFlow, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add references to the <span class="strong"><strong>Microsoft TPL DataFlow</strong></span> NuGet package. Follow these steps to do so:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the <span class="strong"><strong>References</strong></span> folder in the project and select the <span class="strong"><strong>Manage NuGet Packages...</strong></span> menu option.</li><li class="listitem">Now, add your preferred references to the <span class="strong"><strong>Microsoft TPL DataFlow</strong></span> NuGet package. You can use the search option in the <span class="strong"><strong>Manage NuGet Packages</strong></span> dialog as follows:</li></ol></div><div class="mediaobject"><img src="graphics/B05292_10_01.jpg" alt="How to do it..."/></div></li><li class="listitem">In the<a id="id405" class="indexterm"/> <code class="literal">Program.cs</code> file, add the <a id="id406" class="indexterm"/>following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">async static Task ProcessAsynchronously()
{
  var cts = new CancellationTokenSource();
  Random _rnd = new Random(DateTime.Now.Millisecond);

  Task.Run(() =&gt;
  {
    if (ReadKey().KeyChar == 'c')
      cts.Cancel();
  }, cts.Token);

  var inputBlock = new BufferBlock&lt;int&gt;(
    new DataflowBlockOptions { BoundedCapacity = 5, CancellationToken = cts.Token });

  var convertToDecimalBlock = new TransformBlock&lt;int, decimal&gt;(
    n =&gt;
    {
      decimal result = Convert.ToDecimal(n * 100);
      WriteLine($"Decimal Converter sent {result} to the next stage on " +
              $"thread id {CurrentThread.ManagedThreadId}");
      Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));
      return result;
    }
    , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });

  var stringifyBlock = new TransformBlock&lt;decimal, string&gt;(
    n =&gt;
    {
      string result = $"--{n.ToString("C", CultureInfo.GetCultureInfo("en-us"))}--";
      WriteLine($"String Formatter sent {result} to the next stage on thread id {CurrentThread.ManagedThreadId}");
      Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));
      return result;
    }
    , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });

  var outputBlock = new ActionBlock&lt;string&gt;(
    s =&gt;
    {
      WriteLine($"The final result is {s} on thread id {CurrentThread.ManagedThreadId}");
    }
    , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });

  inputBlock.LinkTo(convertToDecimalBlock, new DataflowLinkOptions { PropagateCompletion = true });
  convertToDecimalBlock.LinkTo(stringifyBlock, new DataflowLinkOptions { PropagateCompletion = true });
  stringifyBlock.LinkTo(outputBlock, new DataflowLinkOptions { PropagateCompletion = true });

  try
  {
    Parallel.For(0, 20, new ParallelOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token }
    , i =&gt;
    {
      WriteLine($"added {i} to source data on thread id {CurrentThread.ManagedThreadId}");
      inputBlock.SendAsync(i).GetAwaiter().GetResult();
    });
    inputBlock.Complete();
    await outputBlock.Completion;
    WriteLine("Press ENTER to exit.");
  }
  catch (OperationCanceledException)
  {
    WriteLine("Operation has been canceled! Press ENTER to exit.");
  }

  ReadLine();
}</pre></div></li><li class="listitem">Add the<a id="id407" class="indexterm"/> following <a id="id408" class="indexterm"/>code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var t = ProcessAsynchronously();
t.GetAwaiter().GetResult();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec217"/>How it works...</h2></div></div></div><p>In the previous recipe, we implemented a Parallel Pipeline pattern to process items through sequential stages. It is quite a common problem, and one of the proposed ways to program such algorithms is using a TPL DataFlow library from Microsoft. It is distributed via NuGet and is easy to install and use in your application.</p><p>The TPL DataFlow<a id="id409" class="indexterm"/> library contains different types of blocks that can be connected with each other in different ways and form complicated processes that can be partially parallel and sequential where needed. To see some of the available infrastructure, let's implement the previous scenario with the help of the TPL DataFlow library.</p><p>First, we define the different blocks that will be processing our data. Note that these blocks have different options that can be specified during their construction; they can be very important. For<a id="id410" class="indexterm"/> example, we pass the cancelation token into every block we define, and when we signal the cancelation, all of them stop working.</p><p>We start our process with <code class="literal">BufferBlock</code>, we bound its capacity to 5 items maximum. This block holds items to pass them to the next blocks in the flow. We restrict it to the five-item capacity, specifying the <code class="literal">BoundedCapacity</code> option value. This means that when there will be five items in this block, it will stop accepting new items until one of the existing items passes to the next blocks.</p><p>The next block type is <code class="literal">TransformBlock</code>. This block is intended for a data transformation step. Here, we define two transformation blocks; one of them creates decimals from integers, and the second one creates a string from a decimal value. We can use the <code class="literal">MaxDegreeOfParallelism</code> option for this block, specifying the maximum simultaneous worker threads.</p><p>The last block is of the <code class="literal">ActionBlock</code> type. This block will run a specified action on every incoming item. We use this block to print our items to the console.</p><p>Now, we link these blocks together with the help of the <code class="literal">LinkTo</code> methods. Here, we have an easy sequential data flow, but it is possible to create schemes that are more complicated. Here, we also provide <code class="literal">DataflowLinkOptions</code> with the <code class="literal">PropagateCompletion</code> property set to <code class="literal">true</code>. This means that when the step is complete, it will automatically propagate its results and exceptions to the next stage. Then, we start adding items to the buffer block in parallel, calling the block's <code class="literal">Complete</code> method, when we finish adding new items. Then, we wait for the last block to get completed. In the case of a cancelation, we handle <code class="literal">OperationCancelledException</code> and cancel the whole process.</p></div></div>
<div class="section" title="Implementing Map/Reduce with PLINQ"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Implementing Map/Reduce with PLINQ</h1></div></div></div><p>This recipe will<a id="id411" class="indexterm"/> describe how to implement the Map/Reduce pattern while using PLINQ.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec218"/>Getting ready</h2></div></div></div><p>To begin<a id="id412" class="indexterm"/> this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe4</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec219"/>How to do it...</h2></div></div></div><p>To understand how to implement Map/Reduce with PLINQ, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

using Newtonsoft.Json;

using static System.Console;</pre></div></li><li class="listitem">Add references to the <code class="literal">Newtonsoft.Json</code> NuGet package and the <code class="literal">System.Net.Http</code> assembly.</li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static char[] delimiters = { ' ', ',', ';', ':', '\"', '.' };

async static Task&lt;string&gt; ProcessBookAsync(
    string bookContent, string title, HashSet&lt;string&gt; stopwords)
{
    using (var reader = new StringReader(bookContent))
    {
        var query = reader.EnumLines()
            .AsParallel()
            .SelectMany(line =&gt; line.Split(delimiters))
            .MapReduce(
                word =&gt; new[] { word.ToLower() },
                key =&gt; key,
                g =&gt; new[] { new { Word = g.Key, Count = g.Count() } }
            )
            .ToList();

        var words = query
            .Where(element =&gt;
                !string.IsNullOrWhiteSpace(element.Word)
                &amp;&amp; !stopwords.Contains(element.Word))
            .OrderByDescending(element =&gt; element.Count);
               
        var sb = new StringBuilder();

        sb.AppendLine($"'{title}' book stats");
        sb.AppendLine("Top ten words used in this book: ");
        foreach (var w in words.Take(10))
        {
            sb.AppendLine($"Word: '{w.Word}', times used: '{w.Count}'");
        }

        sb.AppendLine($"Unique Words used: {query.Count()}");

        return sb.ToString();
    }
}

async static Task&lt;string&gt; DownloadBookAsync(string bookUrl)
{
  using (var client = new HttpClient())
  {
      return  await client.GetStringAsync(bookUrl);
  }             
}

async static Task&lt;HashSet&lt;string&gt;&gt; DownloadStopWordsAsync()
{
  string url = 
        "https://raw.githubusercontent.com/6/stopwords/master/stopwords-all.json";

  using (var client = new HttpClient())
  {
      try
      {
          var content = await client.GetStringAsync(url);
          var words =
              JsonConvert.DeserializeObject
                  &lt;Dictionary&lt;string, string[]&gt;&gt;(content);
          return new HashSet&lt;string&gt;(words["en"]);
      }
      catch
      {
          return new HashSet&lt;string&gt;();
      }
              
  }
}</pre></div></li><li class="listitem">Add the<a id="id413" class="indexterm"/> following code snippet inside<a id="id414" class="indexterm"/> the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var booksList = new Dictionary&lt;string, string&gt;()
{
    ["Moby Dick; Or, The Whale by Herman Melville"] 
    = "http://www.gutenberg.org/cache/epub/2701/pg2701.txt",

    ["The Adventures of Tom Sawyer by Mark Twain"]
    = "http://www.gutenberg.org/cache/epub/74/pg74.txt",

    ["Treasure Island by Robert Louis Stevenson"]
    = "http://www.gutenberg.org/cache/epub/120/pg120.txt",

    ["The Picture of Dorian Gray by Oscar Wilde"]
    = "http://www.gutenberg.org/cache/epub/174/pg174.txt"
};

HashSet&lt;string&gt; stopwords = DownloadStopWordsAsync().GetAwaiter().GetResult();

var output = new StringBuilder();

Parallel.ForEach(booksList.Keys, key =&gt;
{
    var bookContent = DownloadBookAsync(booksList[key])
        .GetAwaiter().GetResult();

    string result = ProcessBookAsync(bookContent, key, stopwords)
        .GetAwaiter().GetResult();

  output.Append(result);
  output.AppendLine();
});

Write(output.ToString());
ReadLine();</pre></div></li><li class="listitem">Add the<a id="id415" class="indexterm"/> following code snippet<a id="id416" class="indexterm"/> after the <code class="literal">Program</code> class definition:<div class="informalexample"><pre class="programlisting">static class Extensions
{
  public static ParallelQuery&lt;TResult&gt; MapReduce&lt;TSource, TMapped, TKey, TResult&gt;(
    this ParallelQuery&lt;TSource&gt; source,
    Func&lt;TSource, IEnumerable&lt;TMapped&gt;&gt; map,
    Func&lt;TMapped, TKey&gt; keySelector,
    Func&lt;IGrouping&lt;TKey, TMapped&gt;, IEnumerable&lt;TResult&gt;&gt; reduce)
  {
    return source.SelectMany(map)
    .GroupBy(keySelector)
    .SelectMany(reduce);
  }

    public static IEnumerable&lt;string&gt; EnumLines(this StringReader reader)
    {
        while (true)
        {
            string line = reader.ReadLine();
            if (null == line) yield break;

            yield return line;
        }
    }
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec220"/>How it works...</h2></div></div></div><p>The <code class="literal">Map</code>/<code class="literal">Reduce</code> functions are another important parallel programming pattern. They are suitable for a small program and large multiserver computations. The meaning of this pattern is that you have two special functions to apply to your data. The first of them is the <code class="literal">Map</code> function. It takes a set of initial data in a key/value list form and produces another key/value sequence, transforming the data to a comfortable format for further processing. Then, we<a id="id417" class="indexterm"/> use another function, called <code class="literal">Reduce</code>. The <code class="literal">Reduce</code> function takes the result of the <code class="literal">Map</code> function and transforms it to the smallest possible set of data that we actually need. To understand how this algorithm works, let's look through the preceding recipe.</p><p>Here, we are going to analyze four classic books' text. We are going to download the books from the project <a id="id418" class="indexterm"/>Gutenberg's site (<a class="ulink" href="http://www.gutenberg.org">www.gutenberg.org</a>), which can ask for a captcha if you issue many network requests and thus break the program logic of this sample. If you see<a id="id419" class="indexterm"/> HTML elements in the program's output, open one of the book URLs in the browser and complete the captcha. The next thing to do is to load a list of English words that we are going to skip when analyzing the text. In this sample, we try to load a JSON-encoded word list from GitHub, and in case of failure, we just get an empty list.</p><p>Now, let's pay attention to our <code class="literal">Map</code>/<code class="literal">Reduce</code> implementation as a PLINQ extension method in the <code class="literal">PLINQExtensions</code> class. We use <code class="literal">SelectMany</code> to transform the initial sequence to the sequence we need by applying the <code class="literal">Map</code> function. This function produces several new elements from one sequence element. Then, we choose how we group the new sequence with the <code class="literal">keySelector</code> function, and we use <code class="literal">GroupBy</code> with this key to produce an intermediate key/value sequence. The last thing we do is apply <code class="literal">Reduce</code> to the resulting grouped sequence to get the result.</p><p>Then, we run all our books processing in parallel. Each processing worker thread outputs the resulting information into a string, and after all workers are complete, we print this information to the console. We do this to avoid concurrent console output, when each worker text overlaps and makes the resulting information unreadable. In each worker process, we split the book text into a text lines sequence, chop each line into word sequences, and apply our <code class="literal">MapReduce</code> function to it. We use the <code class="literal">Map</code> function to transform each word into lowercase and use it as the grouping key. Then, we define the <code class="literal">Reduce</code> function as a transformation of the grouping element into a key value pair, which has the <code class="literal">Word</code> element that contains one unique word found in the text and the <code class="literal">Count</code> element, which has information about how many times this word has been used. The final step is our query materialization with the <code class="literal">ToList</code> method call, since we need to process this query twice. Then, we use our list of stop words to remove common words from our statistics and create a string result with the book's title, top 10 words used in the book, and a unique word's frequency in the book.</p></div></div></body></html>