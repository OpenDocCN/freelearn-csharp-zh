- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Building a Calculator Using .NET MAUI Blazor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET MAUI Blazor 构建 Calculator
- en: In this chapter, we will explore a .NET `BlazorWebView`. We will also communicate
    between Blazor and .NET MAUI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 .NET `BlazorWebView`。我们还将实现 Blazor 和 .NET MAUI 之间的通信。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is Blazor?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Blazor？
- en: Exploring the differences between .NET MAUI projects and .NET MAUI Blazor projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 .NET MAUI 项目和 .NET MAUI Blazor 项目的区别
- en: Using HTML and CSS to define a UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML 和 CSS 定义 UI
- en: Using XAML controls with HTML in a WebView
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WebView 中使用 XAML 控件与 HTML
- en: Writing C# code that will integrate with XAML controls and HTML controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写将与 XAML 控件和 HTML 控件集成的 C# 代码
- en: Working with the main .NET MAUI window to resize it to its contents
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主 .NET MAUI 窗口来调整其大小以适应内容
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need to have Visual Studio for Mac or PC installed, as well as the
    .NET MAUI components. See *Chapter 1*, *Introduction to .NET MAUI*, for more details
    on how to set up your environment. The source code for this chapter is available
    in this book’s GitHub repository: [https://github.com/](https://github.com/)PacktPublishing/MAUI-Projects-3rd-Edition.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 Visual Studio for Mac 或 PC，以及 .NET MAUI 组件。有关如何设置环境的更多详细信息，请参阅 *第 1 章*，*.NET
    MAUI 简介*。本章的源代码可在本书的 GitHub 仓库中找到：[https://github.com/](https://github.com/)PacktPublishing/MAUI-Projects-3rd-Edition。
- en: Project overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, you will discover .NET Blazor and how to use it with .NET MAUI
    to develop a UI for an app. We will explore the different options available for
    hosting a Blazor app within a .NET MAUI app. Communication between the two apps
    is a crucial part of the interoperability and this chapter’s project will show
    you how to send data from .NET MAUI to Blazor and vice versa.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 .NET Blazor 以及如何使用它与 .NET MAUI 开发应用程序的 UI。我们将探讨在 .NET MAUI 应用程序内托管
    Blazor 应用程序的不同选项。两个应用程序之间的通信是互操作性的关键部分，本章的项目将向你展示如何从 .NET MAUI 向 Blazor 发送数据，反之亦然。
- en: What is Blazor?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Blazor？
- en: '.NET Blazor is a web framework built on top of .NET. Blazor applications run
    in the browser by using **WebAssembly** (**WASM**), or on a server using SignalR.
    Blazor is one part of the whole ASP.NET ecosystem, and it leverages Razor pages
    for developing the UI. Blazor uses HTML and CSS to render a rich UI. Blazor uses
    a component-based UI, where each component is a Razor markup page. Within a Razor
    page, you can mix and match HTML, CSS, and C# code. There are three deployment
    models for a Blazor app:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Blazor 是一个基于 .NET 的 Web 框架。Blazor 应用程序通过使用 **WebAssembly**（**WASM**）在浏览器中运行，或者通过
    SignalR 在服务器上运行。Blazor 是整个 ASP.NET 生态系统的一部分，并且它利用 Razor 页面来开发 UI。Blazor 使用 HTML
    和 CSS 来渲染丰富的 UI。Blazor 使用基于组件的 UI，其中每个组件都是一个 Razor 标记页。在一个 Razor 页面中，你可以混合使用 HTML、CSS
    和 C# 代码。Blazor 应用程序有三种部署模型：
- en: '**Blazor Server**: In a Blazor Server deployment, the application code runs
    on the server in an ASP.NET Core app, and it communicates with the UI running
    in a browser via SignalR.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor Server**：在 Blazor Server 部署中，应用程序代码在 ASP.NET Core 应用程序的服务器上运行，并通过
    SignalR 与在浏览器中运行的 UI 进行通信。'
- en: '**Blazor WebAssembly**: For Blazor WebAssembly, the entire app runs in the
    browser via WASM. It is an open web standard that makes it possible to run .NET
    code safely in the browser. WASM provides interoperability with JavaScript.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor WebAssembly**：对于 Blazor WebAssembly，整个应用程序通过 WASM 在浏览器中运行。它是一个开放的网络标准，使得在浏览器中安全运行
    .NET 代码成为可能。WASM 提供了与 JavaScript 的互操作性。'
- en: '**Blazor Hybrid**: Blazor Hybrid is a blend of native .NET and web technologies.
    Blazor Hybrid apps can be hosted in .NET MAUI, **WPF**, and **Windows Forms**
    applications. Since the hosts are all .NET, the Blazor runtime runs natively within
    the same .NET process and renders the Razor page web UI into a WebView control.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor Hybrid**：Blazor Hybrid 是原生 .NET 和 Web 技术的混合体。Blazor Hybrid 应用程序可以托管在
    .NET MAUI、**WPF** 和 **Windows Forms** 应用程序中。由于所有宿主都是 .NET，Blazor 运行时在同一个 .NET
    进程中本地运行，并将 Razor 页面 Web UI 渲染到 WebView 控件中。'
- en: Now that we have some general knowledge of Blazor, let’s look at the app we
    will build in this chapter!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Blazor 有了一些基本的了解，让我们看看本章我们将要构建的应用程序吧！
- en: Creating the calculator app
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建计算器应用程序
- en: In this chapter, we are going to build a calculator app. The UI for the calculator
    is built using Razor pages in Blazor, but the actual mechanics of the calculator
    reside in the .NET MAUI app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个计算器应用程序。计算器的 UI 使用 Blazor 中的 Razor 页面构建，但计算器的实际机制位于 .NET MAUI 应用程序中。
- en: Setting up the project
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: This project, like all the rest, is a **File** | **New** | **Project...**-style
    project. This means that we will not be importing any code at all. So, this first
    section is all about creating the project and setting up the basic project structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目，就像所有其他项目一样，是一个 **文件** | **新建** | **项目...** 风格的项目。这意味着我们根本不会导入任何代码。因此，这个第一部分完全是关于创建项目和设置基本项目结构。
- en: Creating the new project
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'The first step is to create a new .NET MAUI project. Follow these steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的 .NET MAUI 项目。按照以下步骤操作：
- en: 'Open Visual Studio 2022 and select **Create a** **new project**:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2022 并选择 **创建一个** **新项目**：
- en: "![Figure 11.1 – Visual \uFEFFStudio 2022](img/B19214_11_1.jpg)"
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Visual Studio 2022](img/B19214_11_1.jpg)'
- en: Figure 11.1 – Visual Studio 2022
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Visual Studio 2022
- en: This will open the **Create a new** **project** wizard.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 **创建一个新** **项目** 向导。
- en: 'In the search field, type in `blazor` and select the **.NET MAUI Blazor App**
    item from the list:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 `blazor` 并从列表中选择 **.NET MAUI Blazor App** 项：
- en: "![Figure 11.2 – Create a n\uFEFFew project](img/B19214_11_2.jpg)"
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 创建一个新项目](img/B19214_11_2.jpg)'
- en: Figure 11.2 – Create a new project
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 创建一个新项目
- en: Click **Next**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'Enter `Calculator` as the name of the app, as shown in the following screenshot:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，将应用名称输入为 `Calculator`：
- en: '![Figure 11.3 – Configure your new project](img/B19214_11_3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 配置您的全新项目](img/B19214_11_3.jpg)'
- en: Figure 11.3 – Configure your new project
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 配置您的全新项目
- en: Click **Next**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'The last step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For this book, we will assume that
    you will be using .NET 7:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步将提示您选择要支持的 .NET Core 版本。在撰写本文时，.NET 6 可用为 **长期支持**（**LTS**），而 .NET 7 可用为
    **标准期限支持**。对于本书，我们假设您将使用 .NET 7：
- en: '![Figure 11.4 – Additional information](img/B19214_11_4.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 其他信息](img/B19214_11_4.jpg)'
- en: Figure 11.4 – Additional information
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 其他信息
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **创建** 并等待 Visual Studio 创建项目来最终完成设置。
- en: That’s it for project creation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建到此结束。
- en: Let’s continue by reviewing the structure of the app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回顾应用的结构来继续。
- en: Exploring a .NET MAUI Blazor Hybrid project
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索 .NET MAUI Blazor 混合项目
- en: 'If you run the project, you will see an app, as shown in *Figure 11**.5*. It
    does not resemble the .NET MAUI app template and has a distinctive web feel to
    it. Poke around the app a little bit to see how all the visual elements work together.
    Then, close the application, return to Visual Studio, and continue exploring the
    project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行项目，您将看到一个应用，如图 11.5 所示。它并不像 .NET MAUI 应用模板，而是具有独特的网络感觉。稍微探索一下应用，看看所有视觉元素是如何协同工作的。然后，关闭应用程序，返回
    Visual Studio，并继续探索项目：
- en: '![Figure 11.5 – Running the .NET MAUI Blazor template project](img/B19214_11_5.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 运行 .NET MAUI Blazor 模板项目](img/B19214_11_5.jpg)'
- en: Figure 11.5 – Running the .NET MAUI Blazor template project
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 运行 .NET MAUI Blazor 模板项目
- en: 'The structure of the .NET MAUI Blazor app is a mashup of a .NET MAUI app and
    a Blazor app. If you look at the `Platforms` and `Resources` folders and the `App.xaml`,
    `MainPage.xaml`, and `MauiProgram.cs` files that are normally present in the .NET
    MAUI template. The `wwwroot`, `Data`, `Pages`, and `Shared` folders all support
    the Blazor app. Additionally, you’ll find `_Imports.razor` and `Main.razor` at
    the root of the project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI Blazor 应用的结构是 .NET MAUI 应用和 Blazor 应用的混合体。如果您查看通常存在于 .NET MAUI 模板中的
    `Platforms` 和 `Resources` 文件夹以及 `App.xaml`、`MainPage.xaml` 和 `MauiProgram.cs`
    文件。`wwwroot`、`Data`、`Pages` 和 `Shared` 文件夹都支持 Blazor 应用。此外，您将在项目的根目录下找到 `_Imports.razor`
    和 `Main.razor`：
- en: '![Figure 11.6 – Solution Explorer view of a .NET MAUI Blazor project](img/B19214_11_6.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – .NET MAUI Blazor 项目的解决方案资源管理器视图](img/B19214_11_6.jpg)'
- en: Figure 11.6 – Solution Explorer view of a .NET MAUI Blazor project
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – .NET MAUI Blazor 项目的解决方案资源管理器视图
- en: If you need a refresher on how a .NET MAUI app is structured and works, refer
    to *Chapter 1*. Ignoring how a Blazor app works for the moment, let’s take a look
    at how a Blazor app is hosted by .NET MAUI.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要复习 .NET MAUI 应用的结构和功能，请参阅 *第 1 章*。暂时忽略 Blazor 应用的功能，让我们看看 Blazor 应用是如何由
    .NET MAUI 托管的。
- en: 'Since all .NET MAUI programs start with the `MauiProgram.cs` file, that seems
    like a good place to start. Open the `MauiProgram.cs` file and inspect its contents.
    The following snippet highlights the differences for a .NET MAUI Blazor app:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有 .NET MAUI 程序都从 `MauiProgram.cs` 文件开始，这似乎是一个好的起点。打开 `MauiProgram.cs` 文件并检查其内容。以下代码片段突出了
    .NET MAUI Blazor 应用的差异：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first highlighted line enables the hosting services for the Blazor app,
    specifically the WebView controller. The second highlighted line enables the developer
    tools (*F12*) within the WebView control, but only in a debug configuration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行高亮显示的行启用了 Blazor 应用的托管服务，特别是 WebView 控制器。第二行高亮显示的行启用了 WebView 控制器内的开发者工具（*F12*），但仅限于调试配置。
- en: '`App.xaml` and `App.xaml.cs` are essentially the same as in a .NET MAUI template
    project, but `MainPage.xaml` is not. Open the `MainPage.xaml` file to inspect
    its contents, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.xaml` 和 `App.xaml.cs` 与 .NET MAUI 模板项目中的基本相同，但 `MainPage.xaml` 则不同。打开
    `MainPage.xaml` 文件来检查其内容，如下所示：'
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`MainPage` has a single control, `BlazorWebView`. This is a wrapper around
    the native controls to host web pages in apps. The `HostPage` attribute points
    to the starting page – in this case, `wwwroot/index.html`. The `BlazorWebView.RootComponents`
    element identifies the starting points for the Blazor application and the location
    where they are hosted on the page. In this case, `RootComponent` `Main` is rooted
    in the element with an ID of `app`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage` 有一个单独的控制项，`BlazorWebView`。这是一个包装原生控件以在应用程序中托管网页的包装器。`HostPage` 属性指向起始页面
    - 在这种情况下，`wwwroot/index.html`。`BlazorWebView.RootComponents` 元素标识了 Blazor 应用程序的起始点以及它们在页面上的托管位置。在这种情况下，`RootComponent`
    `Main` 在具有 ID `app` 的元素中根。'
- en: 'To see where the `app` element is located, open the `index.html` file in the
    `wwwroot` folder and inspect its contents, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `app` 元素的位置，打开 `wwwroot` 文件夹中的 `index.html` 文件并检查其内容，如下所示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The key parts of the file are highlighted in the preceding code. First, the
    `div` element with `id` set to `app` is where the `Main` component is rooted,
    or loaded. In the header of the page, the stylesheets are identified. The first
    stylesheet, `app.css`, is located in the `wwwroot/css` folder of the project.
    The second stylesheet, `Calculator.Styles.css`, is created during the build process
    from isolated CSS files. `_framework/blazor.webview.js` file is imported and is
    responsible for doing all the heavy lifting of getting your Blazor components
    rendered at the right location on the page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中突出显示的文件的关键部分。首先，`id` 设置为 `app` 的 `div` 元素是 `Main` 组件的根或加载位置。在页面的页眉中，识别了样式表。第一个样式表
    `app.css` 位于项目的 `wwwroot/css` 文件夹中。第二个样式表 `Calculator.Styles.css` 在构建过程中从隔离的 CSS
    文件创建。导入 `_framework/blazor.webview.js` 文件，该文件负责在页面上正确位置渲染你的 Blazor 组件的所有繁重工作。
- en: 'The final piece for us to review before we move on to creating the rest of
    the application is the Blazor components. `Main.razor` is a routing file that
    directs the Blazor runtime to the starting component, `MainLayout.razor`, as shown
    in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建应用程序的其他部分之前，我们需要审查的最后部分是 Blazor 组件。`Main.razor` 是一个路由文件，它将 Blazor 运行时指向起始组件
    `MainLayout.razor`，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `MainLayout.razor` file defines the basic layout of the page, with a navigation
    bar on the left, and the main body consuming the remainder of the page, as shown
    in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainLayout.razor` 文件定义了页面的基本布局，左侧有一个导航栏，主体内容占据了页面的剩余部分，如下面的代码所示：'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `@Body` content is provided by the page that satisfies the route. For the
    first page, that would be `/`. If you look at the files in the `Pages` folder,
    the `Index.razor` file has a `@page` directive with an argument of `/`. So, by
    default, that is the page that would be displayed. The `@page` directive is a
    Razor construct that allows the route to be satisfied without using a controller.
    The `NavLink` entries in the `Shared/NavMenu.razor` file reference the route using
    the `href` attribute. That value is looked up in the list of `@page` directives
    to find a match. If no match is found, then the content in the `<NotFound>` element
    in the `Main.razor` file is rendered.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Body` 内容由满足路由的页面提供。对于第一个页面，那将是 `/`。如果你查看 `Pages` 文件夹中的文件，`Index.razor` 文件有一个
    `@page` 指令，其参数为 `/`。因此，默认情况下，那将是显示的页面。`@page` 指令是一个 Razor 构造，允许满足路由而无需使用控制器。`Shared/NavMenu.razor`
    文件中的 `NavLink` 条目使用 `href` 属性引用路由。该值在 `@page` 指令列表中查找匹配项。如果没有找到匹配项，则在 `Main.razor`
    文件中的 `<NotFound>` 元素中渲染内容。'
- en: 'Open the `Pages/Counter.razor` page to see how a Razor page works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Pages/Counter.razor` 页面，看看 Razor 页面是如何工作的：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the `@page` directive, the page is made up of HTML mixed with some Razor
    directives. Then, there’s the `@code` directive, which contains the C# code for
    the page. The HTML `button` element has its click event mapped to the C# `IncrementCount`
    method using the `@``onclick` directive.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@page` 指令之后，页面由 HTML 和一些 Razor 指令混合组成。然后是 `@code` 指令，其中包含页面的 C# 代码。HTML 的
    `button` 元素的点击事件通过 `@onclick` 指令映射到 C# 的 `IncrementCount` 方法。
- en: Learn more
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多
- en: To learn more about Razor pages, take a look at the official documentation at
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-7.0).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Razor 页面的信息，请查看官方文档：[https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-7.0)。
- en: Now, let’s start creating the project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始创建项目。
- en: Preparing the project
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备项目
- en: .NET MAUI and Blazor integrate seamlessly – so seamlessly that it is sometimes
    hard to differentiate what is executing where. That makes it very easy to render
    data in both XAML and HTML.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 和 Blazor 无缝集成 – 集成得如此之好，以至于有时很难区分在哪里执行。这使得在 XAML 和 HTML 中渲染数据变得非常容易。
- en: 'Let’s get started by preparing the project for the calculator. We will start
    by removing much of the template code we won’t be using. Follow these steps to
    prepare the template:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为计算器准备项目开始。我们将首先删除大部分我们不会使用的模板代码。按照以下步骤准备模板：
- en: In Visual Studio, using `Data` folder.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，使用 `Data` 文件夹。
- en: In the `Pages` folder, delete `Index.razor`, `Counter.Razor`, and `FetchData.razor`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Pages` 文件夹中，删除 `Index.razor`、`Counter.Razor` 和 `FetchData.razor`。
- en: In the `Shared` folder, delete `NavMenu.razor`, `NavMenu.razor.css`, and `SurveyPrompt.razor`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Shared` 文件夹中，删除 `NavMenu.razor`、`NavMenu.razor.css` 和 `SurveyPrompt.razor`。
- en: 'Right-click on the `Pages` folder, then select **Add** | **Razor Component…**,
    as shown in the following screenshot:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Pages` 文件夹，然后选择 **添加** | **Razor 组件…**，如图所示：
- en: '![Figure 11.7 – Adding a new Razor component](img/B19214_11_7.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 添加新的 Razor 组件](img/B19214_11_7.jpg)'
- en: Figure 11.7 – Adding a new Razor component
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 添加新的 Razor 组件
- en: 'In the `Keypad.razor` and click **Add**:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Keypad.razor` 中点击 **添加**：
- en: "![Figure 11.8 – Razor \uFEFFcomponent](img/B19214_11_8.jpg)"
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – Razor 组件](img/B19214_11_8.jpg)'
- en: Figure 11.8 – Razor component
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – Razor 组件
- en: 'In the new `Keypad.razor` file, add the following highlighted lines:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `Keypad.razor` 文件中，添加以下突出显示的行：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open the `MainLayout.razor` file in the `Shared` folder and remove the following
    highlighted sections:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Shared` 文件夹中的 `MainLayout.razor` 文件，并删除以下突出显示的部分：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open `MauiProgram.cs` and remove the highlighted lines of code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 并删除突出显示的代码行：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, run the project to see the effects of the changes, as shown in *Figure
    11**.9*:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目以查看更改的效果，如图 *图 11.9* 所示：
- en: '![Figure 11.9 – Running the blank calculator app on Windows](img/B19214_11_9.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 在 Windows 上运行空白计算器应用](img/B19214_11_9.jpg)'
- en: Figure 11.9 – Running the blank calculator app on Windows
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 在 Windows 上运行空白计算器应用
- en: Now that the project is ready to be an app, let’s start with the Keypad view.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，项目已经准备好成为一个应用，让我们从 Keypad 视图开始。
- en: Creating the Keypad view
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Keypad 视图
- en: The Keypad view is the basic functionality of the calculator. It has buttons
    for each digit, 0 through 9, the decimal separator, *.*, clear, *C*, clear everything,
    *CE*, and, finally, addition, *+*, subtraction, *-*, multiplication, *x*, division,
    */*, *=* to get the result, and *<* to erase the last character. The view has
    three basic components to it – HTML and CSS for styling and the C# code. Each
    of the following sections will guide you through adding each of these components
    for the view, starting with the HTML.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Keypad 视图是计算器的基本功能。它有 0 到 9 的每个数字按钮，小数分隔符 `.*`，清除按钮 `C`，清除所有内容 `CE`，以及最终，加号
    `+`，减号 `-`，乘号 `x`，除号 `/`，等于 `*=` 来获取结果，和左箭头 `<` 来删除最后一个字符。视图有三个基本组件 – HTML 和 CSS
    用于样式，以及 C# 代码。以下每个部分将指导您为视图添加每个这些组件，从 HTML 开始。
- en: Adding the HTML
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 HTML
- en: 'Razor files and .NET MAUI XAML files do not have a designer for you to visualize
    your changes. You have to run your app to see the changes you have made, which
    usually involves building, deploying, and then navigating to the view in your
    app. .NET has a time-saving feature called Hot Reload. It works by applying the
    changes you make to your Razor, XAML, CSS, and C# files to the running application
    without you having to stop and restart the app. Try using **Hot Reload** while
    you go through the next set of steps. To apply the changes, use the **Hot Reload**
    button in the **Debug** toolbar. It’s easy to find – it’s the flames icon:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 文件和 .NET MAUI XAML 文件没有为你提供可视化的设计器。你必须运行你的应用来查看你所做的更改，这通常涉及到构建、部署，然后导航到应用中的视图。.NET
    有一个节省时间的功能叫做热重载。它通过将你对 Razor、XAML、CSS 和 C# 文件所做的更改应用到正在运行的应用程序中，而无需你停止并重新启动应用来实现。在完成下一步操作时尝试使用**热重载**。要应用更改，请使用**调试**工具栏中的**热重载**按钮。它很容易找到——它是一个火焰图标：
- en: '![Figure 11.10 – The Hot Reload toolbar button](img/B19214_11_10.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 热重载工具栏按钮](img/B19214_11_10.jpg)'
- en: Figure 11.10 – The Hot Reload toolbar button
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 热重载工具栏按钮
- en: 'If at any point you receive a “Rude Edit” dialog like the following, it just
    means that the change cannot be applied by Hot Reload, so you need to stop, rebuild,
    and restart debugging:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候你收到类似于以下“粗鲁编辑”对话框，这仅仅意味着更改不能通过热重载应用，因此你需要停止、重新构建并重新启动调试：
- en: "![Figure 11.11 – Hot Reload \uFEFFdialog](img/B19214_11_11.jpg)"
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – 热重载对话框](img/B19214_11_11.jpg)'
- en: Figure 11.11 – Hot Reload dialog
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – 热重载对话框
- en: Hot Reload is constantly getting better, so there will be fewer and fewer of
    these cases in the future.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 热重载一直在不断改进，所以将来这些情况会越来越少。
- en: 'To add the HTML that will provide you with the UI to interact with the keypad,
    follow these steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加将为你提供与密钥盘交互的 UI 的 HTML，请按照以下步骤操作：
- en: Start the app by using the debugger or pressing *F5*.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用调试器或按*F5*键启动应用。
- en: If you want to see your app in Visual Studio, you can open the **XAML Live Preview**
    pane. To open the **XAML Live Preview** pane, use the Visual Studio menu and select
    **Debug** | **Windows** | **XAML Live Preview**. I usually pin it open so that
    it is always available.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在 Visual Studio 中查看你的应用，你可以打开**XAML 实时预览**窗格。要打开**XAML 实时预览**窗格，请使用 Visual
    Studio 菜单并选择**调试**|**窗口**|**XAML 实时预览**。我通常将其固定打开，以便始终可用。
- en: Open the `Keypad.razor` file in the `Pages` folder.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Pages”文件夹中打开`Keypad.razor`文件。
- en: 'Remove the highlighted content shown in the following code block:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下代码块中显示的突出内容：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following HTML after `@page` but before the `@``code` directive:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@page`之后但在`@`代码指令之前添加以下 HTML：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don’t forget to press the `div` and not `table` since it is easier to style
    `div` elements than `table` elements. The keypad is arranged in rows of four buttons,
    except for the top two rows. The top row is the display where the expression or
    result is shown. The second row only has three buttons. The class names have already
    been added to the HTML elements, but since they don’t exist yet, they don’t alter
    the appearance.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记按`div`而不是`table`，因为比`table`元素更容易为`div`元素添加样式。密钥盘按四按钮一行排列，除了前两行。第一行是显示表达式或结果的显示屏。第二行只有三个按钮。类名已经添加到
    HTML 元素中，但由于它们还不存在，它们不会改变外观。
- en: The keypad doesn’t quite look like a keypad yet, but it will once we add some
    style to it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥盘看起来还不完全像密钥盘，但一旦我们给它添加一些样式，它就会变得如此。
- en: Adding style to the HTML
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 HTML 添加样式
- en: 'CSS has been around for a very long time and is the best way to make your HTML
    look its best. Follow these steps to add the styles we used in the previous section:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 已经存在很长时间了，是使你的 HTML 看起来最好的最佳方式。按照以下步骤添加我们在上一节中使用的样式：
- en: 'Make sure your app is still running and use `Keypad.razor.css` in the `Pages`
    folder. Click the **Show All Templates** button if Visual Studio doesn’t display
    them by default:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的应用仍在运行，并在“Pages”文件夹中使用`Keypad.razor.css`。如果 Visual Studio 默认不显示它们，请点击**显示所有模板**按钮：
- en: '![Figure 11.12 – Adding a new CSS file](img/B19214_11_12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 添加新的 CSS 文件](img/B19214_11_12.jpg)'
- en: Figure 11.12 – Adding a new CSS file
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 添加新的 CSS 文件
- en: 'If you look in `Pages` folder, you will notice that your new file is now under
    the `Keypad.razor` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看“Pages”文件夹，你会注意到你的新文件现在位于`Keypad.razor`文件下：
- en: '![ Figure 11.13 – A Razor page with an isolated CSS file](img/B19214_11_13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 带有独立 CSS 文件的 Razor 页面](img/B19214_11_13.jpg)'
- en: Figure 11.13 – A Razor page with an isolated CSS file
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 带有独立 CSS 文件的 Razor 页面
- en: Visual Studio automatically recognized that you wanted to add an `Keypad.razor`
    file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio自动识别您想要添加一个`Keypad.razor`文件。
- en: 'Add the `keypad` style to the `Keypad.razor.css` file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`keypad`样式添加到`Keypad.razor.css`文件中：
- en: '[PRE11]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This style will set the width of the element to `300px`, with automatic margins,
    except for the top, which is at `-1.1em`. `-1.1em` moves the top edge of the keypad
    right up against the top of the web view control.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个样式将元素的宽度设置为`300px`，除了顶部，其值为`-1.1em`。`-1.1em`将键盘的顶部边缘直接移动到网页视图控制的顶部。
- en: 'Now, add the `keypad-body` style using the following code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码添加`keypad-body`样式：
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This style just gives the entire element a border one pixel wide in a dark gray
    color.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个样式只是给整个元素添加了一个一像素宽的深灰色边框。
- en: 'We will save the `keypad-screen` and `keypad-typed` styles for last, so add
    the `keypad-row` style shown in the following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将最后保存`keypad-screen`和`keypad-typed`样式，所以添加以下代码中显示的`keypad-row`样式：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This style sets the element width to 100% of its parent, which would be `keypad-body`,
    and sets the background to a pleasing dark gray color.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个样式将元素宽度设置为父元素的100%，即`keypad-body`，并将背景设置为令人愉悦的深灰色。
- en: 'The next style to add is `keypad-button`. Use the following code to add the
    style:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要添加的样式是`keypad-button`。使用以下代码添加样式：
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This style is the base for all the buttons on the keypad, hence it has the most
    attributes. Elements that have this style applied have a border on the right and
    bottom that is 2 pixels wide and uses the same color as the background of the
    row. The `background` attribute of the button is a bit darker than the border
    color, which provides a bit of depth. The text is aligned in the center both vertically
    and horizontally and uses a 25-pixel font size. The width is set to 25% since
    there are four buttons in a row, mostly. The `transition` attribute imposes a
    200-millisecond transition using `ease-in-out`, which accelerates from the start
    to the middle and then decelerates from the middle to the end. `transition` is
    applied to all attributes, so any time an attribute of this style changes, it
    will slowly change from the starting value to the end value.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个样式是所有按键按钮的基础，因此它具有最多的属性。应用了这个样式的元素在其右侧和底部有2像素宽的边框，并且使用与行背景相同的颜色。按钮的`background`属性比边框颜色略暗，这提供了一点深度。文本在垂直和水平方向上居中对齐，并使用25像素的字体大小。宽度设置为25%，因为每行通常有四个按钮。`transition`属性使用`ease-in-out`进行200毫秒的过渡，这从开始加速到中间，然后从中间减速到结束。`transition`应用于所有属性，所以每当这个样式的属性发生变化时，它都会从起始值缓慢变化到结束值。
- en: 'If the button is an action button, such as an operator, then an additional
    style is applied, called `operator`. The definition of this style is slightly
    different from the rest of the styles that have been created so far. Instead of
    just being named `operator`, this style is named `keypad-button.operator`. In
    CSS, `.` is a selector; it is used to locate which attributes to apply. In this
    case, we want all elements that have both the `keypad-button` class and the `operator`
    class applied. To add the `keypad-button.operator` class, use the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按钮是动作按钮，例如运算符，则应用一个额外的样式，称为`operator`。这个样式的定义与迄今为止创建的其他样式略有不同。这个样式不仅被命名为`operator`，而是命名为`keypad-button.operator`。在CSS中，`.`是一个选择器；它用于定位要应用哪些属性。在这种情况下，我们想要所有同时应用了`keypad-button`类和`operator`类的元素。要添加`keypad-button.operator`类，请使用以下代码：
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These buttons will appear with a slightly darker background with slightly less
    white text.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些按钮将以略暗的背景和略少的白色文字显示。
- en: 'The clear (*C*) and clear everything (*CE*) buttons also have their own class,
    as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除(*C*)和清除所有(*CE*)按钮也有它们自己的类，如下所示：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These buttons will appear with slightly darker backgrounds with red text.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些按钮将以略暗的背景和红色文字显示。
- en: 'Now, for the desktop, we can add hover highlighting by using the `:hover` pseudo
    selector. Add the hover styles using the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于桌面，我们可以通过使用`:hover`伪选择器来添加悬停高亮。使用以下代码添加悬停样式：
- en: '[PRE17]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The background is altered to an orange color. The change isn’t immediate due
    to the `transition` attribute on the `keypad-button` style, so it will transition
    from dark gray to orange in two-tenths of a second.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 背景被改为橙色。由于`keypad-button`样式中存在`transition`属性，所以变化不会立即发生，它将在两十分之一秒内从深灰色过渡到橙色。
- en: 'The last button-related style is wide, or `keypad-button.wide`. This style
    makes the button twice as wide as a normal button. To add this style, use the
    following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个与按钮相关的样式是宽的，或者 `keypad-button.wide`。这种样式使按钮的宽度是普通按钮的两倍。要添加此样式，请使用以下代码：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The final two styles, `keypad-screen` and `keypad-typed`, are for displaying
    the expression and the result. Use the following code to add the remaining two
    styles:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个样式，`keypad-screen` 和 `keypad-typed`，用于显示表达式和结果。使用以下代码添加剩余的两个样式：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the keypad looks like a real calculator keypad; refer to *Figure 11**.14*
    for an example. Were you able to keep adding styles and seeing the changes in
    your app without having to restart? Remember to click the **Hot Reload** button
    or set the **Hot Reload on File Save** option under the **Hot Reload** button
    menu; Visual Studio will attempt to apply the changes as soon as you save the
    file. Next, we will add the code to enable the buttons to work:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，键盘看起来像真正的计算器键盘；请参阅 *图 11**.14* 以获取示例。你是否能够在不重新启动应用程序的情况下继续添加样式并看到更改？请记住点击
    **热重载** 按钮，或在 **热重载** 按钮菜单下设置 **在文件保存时热重载** 选项；Visual Studio 将在您保存文件时尝试应用更改。接下来，我们将添加使按钮能够工作的代码：
- en: '![Figure 11.14 – HTML keypad with style](img/B19214_11_14.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 带样式的 HTML 键盘](img/B19214_11_14.jpg)'
- en: Figure 11.14 – HTML keypad with style
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 带样式的 HTML 键盘
- en: Wiring up the controls
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接控件
- en: 'In most web pages, you would use `Keypad.razor` file, follow these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数网页中，您会使用 `Keypad.razor` 文件，按照以下步骤操作：
- en: 'Within the `@code` directive block, add the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `@code` 指令块内，添加以下内容：
- en: '[PRE20]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This declares a field named `inputDisplay` as a `string` element and initializes
    it to the empty string. It also declares a `bool` element and initializes it to
    `false`. `clearInputBeforeAppend` is a flag to keep `inputDisplay` clean. After
    a result is displayed, when the user taps a button, `inputDisplay` should be cleared
    before the character is added to the screen.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这声明了一个名为 `inputDisplay` 的 `string` 字段，并将其初始化为空字符串。它还声明了一个 `bool` 字段，并将其初始化为
    `false`。`clearInputBeforeAppend` 是一个标志，用于保持 `inputDisplay` 的清洁。在显示结果后，当用户轻触按钮时，应在将字符添加到屏幕之前清除
    `inputDisplay`。
- en: 'Update the element with the `keypad-typed` class, as in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新具有 `keypad-typed` 类的元素，如下所示：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will render the contents of the `inputDisplay` variable into the `div`
    element. Note the use of `@` to reference the C# field.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将渲染 `inputDisplay` 变量的内容到 `div` 元素中。注意使用 `@` 来引用 C# 字段。
- en: 'To help with validating the input, add the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助验证输入，请添加以下内容：
- en: '[PRE22]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When any of the numbers (0 through 9) or the operator buttons are tapped, `inputDisplay`
    will be updated by appending a character to the display. Add the `AppendInput`
    method using the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下任何数字（0 到 9）或操作按钮时，`inputDisplay` 将通过向显示中添加一个字符来更新。使用以下代码添加 `AppendInput`
    方法：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let’s review the code. The first check is to see whether `inputDisplay` needs
    to be cleared; if so, it’s cleared. Then, a check for operators is made. The next
    check is more complex as it doesn’t allow multiple operators in a row. This check
    uses the `Range` syntax of `^1` to indicate the last character. String interpolation
    is used to convert the last character back into a string, so `IndexOfAny` can
    be used to find that character in the array of symbols. Multiple leading 0s are
    checked and rejected if found. If all the checks pass, the input is appended to
    `inputDisplay`, and the `clearInputBeforeAppend` flag is reset to `false`.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下代码。首先检查 `inputDisplay` 是否需要清除；如果是，则清除。然后进行操作符的检查。下一个检查更复杂，因为它不允许一行中有多个操作符。此检查使用
    `^1` 的 `Range` 语法来指示最后一个字符。使用字符串插值将最后一个字符转换回字符串，以便 `IndexOfAny` 可以在符号数组中找到该字符。检查并拒绝多个前导
    0。如果所有检查都通过，则将输入追加到 `inputDisplay`，并将 `clearInputBeforeAppend` 标志重置为 `false`。
- en: 'When the user presses the `Undo` method using the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户使用以下代码按下 `Undo` 方法时：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method uses the `Range` syntax again, and the capability of strings being
    able to be indexed as arrays. It uses the array syntax to get the elements from
    index 0 to the next to last index and returns it.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法再次使用 `Range` 语法，以及字符串能够像数组一样索引的能力。它使用数组语法从索引 0 到下一个最后一个索引获取元素，并返回它。
- en: 'When the user presses the `ClearInput` method using the following code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户使用以下代码按下 `ClearInput` 方法时：
- en: '[PRE25]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the user presses the `ClearAll` method:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户按下 `ClearAll` 方法时：
- en: '[PRE26]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, the `EvaluateExpression` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`EvaluateExpression` 方法：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method doesn’t evaluate the expression that’s entered yet; that will happen
    in the *Creating the Compute* *service* section.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法尚未评估输入的表达式；这将在 *创建计算* *服务* 部分中发生。
- en: The next step in the `Keypad.razor` file is to hook the methods that were just
    defined so that they are called when the user taps or clicks on that element.
    Like in standard HTML, events are hooked up via attributes on the element that
    reference code, either inline or methods. The attributes in Razor pages use a
    page directive with the event name. For example, the DOM event for handling taps
    or clicks is `click`, so the Razor event name would be `@onclick`. That attribute
    is then assigned to a delegate, which could be any method. The full attribute
    might look like `@onclick="DoSomething"`, where `DoSomething` is a C# method defined
    in the page’s `@``code` directive.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Keypad.razor` 文件中的下一步是连接刚刚定义的方法，以便在用户点击或触摸该元素时调用它们。就像在标准 HTML 中一样，事件通过引用代码的元素属性连接起来，无论是内联还是方法。Razor
    页面中的属性使用页面指令与事件名称相关联。例如，处理触摸或点击的 DOM 事件是 `click`，因此 Razor 事件名称将是 `@onclick`。该属性随后被分配给一个代表，它可以是任何方法。完整的属性可能看起来像
    `@onclick="DoSomething"`，其中 `DoSomething` 是在页面的 `@code` 指令中定义的 C# 方法。
- en: The `AppendInput` method accepts a single string argument, so the delegate cannot
    be just `AppendInput` – it has to be wrapped in an expression so that the parameter
    can be passed along. Expressions in Razor pages are contained in the `@(…)` directive.
    All calls to `AppendInput` from an event directive would look like `@onclick="@(AppendInput("0"))"`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppendInput` 方法接受一个字符串参数，因此代表不能只是 `AppendInput` – 它必须被包裹在一个表达式中，以便可以将参数传递下去。Razor
    页面中的表达式包含在 `@(…)` 指令中。所有从事件指令对 `AppendInput` 的调用都将类似于 `@onclick="@(AppendInput("0"))"`。'
- en: 'Use the highlighted lines in the following code to update the HTML in the `Keypad.razor`
    file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码中高亮显示的行来更新 `Keypad.razor` 文件中的 HTML：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: More about Razor event handling
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Razor 事件处理的信息
- en: To learn more about Razor event handling, visit https://learn.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-7.0.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Razor 事件处理的信息，请访问 https://learn.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-7.0。
- en: The keypad is nearly complete. At this point, you should be able to enter a
    full expression to evaluate and then clear the display. In the next section, you
    will create a service to evaluate the expression.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘几乎完成了。在此阶段，你应该能够输入一个完整的表达式进行评估，然后清除显示屏。在下一节中，你将创建一个用于评估表达式的服务。
- en: Creating the Compute service
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建计算服务
- en: 'The `Compute` service evaluates the expression and returns the result. To illustrate
    how .NET MAUI and the Blazor application can interact with one another, this service
    will be injected from the .NET MAUI dependency injection container into the Blazor
    page. To implement the `Compute` service, follow these steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Compute` 服务评估表达式并返回结果。为了说明 .NET MAUI 和 Blazor 应用程序如何相互交互，此服务将从 .NET MAUI 依赖注入容器注入到
    Blazor 页面中。要实现 `Compute` 服务，请按照以下步骤操作：'
- en: Create a new folder in the root of the project named `Services`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个名为 `Services` 的新文件夹。
- en: In the `Services` folder, add a new C# class file named `Compute`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Services` 文件夹中，添加一个名为 `Compute` 的新 C# 类文件。
- en: 'Modify the `Compute.cs` file so that it matches the following code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Compute.cs` 文件，使其与以下代码匹配：
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code might be shorter than you expected. Instead of writing a lot of code
    to parse the expression and build an expression tree to evaluate, there is already
    a built-in way of evaluating simple expressions: `DataTable`. The `DataTable.Compute`
    method can evaluate all the expressions that can be built from the calculator.'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码可能比你预期的要短。而不是编写大量代码来解析表达式并构建一个用于评估的表达式树，已经存在一种内置的方式来评估简单的表达式：`DataTable`。`DataTable.Compute`
    方法可以评估从计算器构建的所有表达式。
- en: 'Open the `MauiProgram.cs` file and add the following highlighted line of code
    to register the class with dependency injection:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 文件，并添加以下高亮显示的代码行以使用依赖注入注册类：
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To allow the `Keypad.razor` page to use the `Compute` type, it needs to be
    declared with Razor. Open the `_Imports.razor` file and add the following highlighted
    line of code to the end of the file:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许 `Keypad.razor` 页面使用 `Compute` 类型，它需要使用 Razor 声明。打开 `_Imports.razor` 文件，并在文件末尾添加以下高亮显示的代码行：
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Without this line, you could still use the type, but you would have to fully
    qualify it as `Calculator.Services.Compute`. This is the Razor equivalent of `global`
    `using` directives in C# files.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有此行，你仍然可以使用该类型，但必须完全限定它为`Calculator.Services.Compute`。这是Razor中C#文件中`global`
    `using`指令的等效项。
- en: 'Now, open the `Keypad.razor` file and add the following line of code after
    the `@``page` directive:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`Keypad.razor`文件，在`@page`指令之后添加以下代码行：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `@inject` directive will use the .NET MAUI dependency injection container
    to resolve the type provided as the first parameter and assign it to the variable
    defined in the second parameter.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@inject`指令将使用.NET MAUI依赖注入容器解析第一个参数提供的类型，并将其分配给第二个参数定义的变量。'
- en: 'In the `EvaluateExpression` method, the `compute` variable can be used to evaluate
    the expression contained in `inputDisplay`, as shown in the following highlighted
    code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EvaluateExpression`方法中，可以使用`compute`变量来评估`inputDisplay`中包含的表达式，如下所示突出显示的代码：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the `Evaluate` method is called with `inputDisplay` as the parameter.
    `inputDisplay` is first modified to replace all the `X` values in the string with
    `*` as that is what the `DataTable` expects for multiplication. The result is
    then assigned to `inputDisplay`.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，使用`inputDisplay`作为参数调用了`Evaluate`方法。首先将`inputDisplay`修改为将字符串中的所有`X`值替换为`*`，因为这是`DataTable`期望用于乘法的。然后将结果分配给`inputDisplay`。
- en: At this point, the calculator app can accept input of a combination of numbers
    and operators and evaluate the result, displaying it to the user. The user can
    also clear out the display. In the next section, we will explore more interoperability
    by giving the calculator memory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，计算器应用程序可以接受数字和运算符的组合输入，并评估结果，将其显示给用户。用户还可以清除显示。在下一节中，我们将通过给计算器添加内存来探索更多的互操作性。
- en: Adding memory functions
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加内存功能
- en: Most calculators can store previous calculations. In this section, you will
    add a list of previous calculations to the calculator app and recall previous
    calculations to the `inputDisplay` parameter of the keypad.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算器可以存储以前的计算。在本节中，你将向计算器应用程序添加一个以前计算列表，并将以前的计算召回到键盘的`inputDisplay`参数。
- en: The code will use .NET MAUI controls to render right next to `WebViewControl`.
    A new class, `Calculations`, will be used to manage the listing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将使用.NET MAUI控件在`WebViewControl`旁边渲染。将使用一个名为`Calculations`的新类来管理列表。
- en: 'To add the memory functions to the calculator app, follow these steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要将内存功能添加到计算器应用程序中，请按照以下步骤操作：
- en: Create a new folder named `ViewModels`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ViewModels`的新文件夹。
- en: 'Add a new class named `Calculations` in the `ViewModels` folder and modify
    the file so that it matches the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModels`文件夹中添加一个名为`Calculations`的新类，并修改文件以匹配以下代码：
- en: '[PRE34]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code adds two classes – `Calculations`, which is just shorthand for `Observable
    Collection<Calculation>`, and `Calculation`, which is `Tuple<string, string>`
    and defines two properties to reference `Item1` as `Expression` and `Item2` as
    `Result`.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码添加了两个类 - `Calculations`，它是`Observable Collection<Calculation>`的简称，以及`Calculation`，它是`Tuple<string,
    string>`，并定义了两个属性来引用`Item1`作为`Expression`和`Item2`作为`Result`。
- en: Add a reference to the `CommunityToolkit.Mvvm` NuGet package.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对`CommunityToolkit.Mvvm` NuGet包的引用。
- en: 'Add a new class named `MainPageViewModel` to the `ViewModels` folder and modify
    the file, as shown in the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModels`文件夹中添加一个名为`MainPageViewModel`的新类，并修改文件，如下所示代码：
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `MainViewModel` class uses two features of `CommunityToolkit`: `RelayCommand`
    and `IMessenger`. As in the other chapters, `RelayCommand` is used to bind methods
    to XAML actions. `IMessenger` is an interface for sending messages between parts
    of your application. It is helpful when you don’t want to take a hard dependency
    between two classes, especially if it creates a circular reference. `CommunityToolkit`
    provides a default implementation of `IMessenger` called `WeakReferenceMessenger`.'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MainViewModel`类使用`CommunityToolkit`的两个功能：`RelayCommand`和`IMessenger`。与其他章节一样，`RelayCommand`用于将方法绑定到XAML操作。`IMessenger`是一个用于在应用程序的不同部分之间发送消息的接口。当你不希望两个类之间有硬依赖时，它非常有用，尤其是如果它创建了一个循环引用。`CommunityToolkit`提供了一个名为`WeakReferenceMessenger`的`IMessenger`的默认实现。'
- en: 'Open `MauiProgram.cs` and add the following `using` declarations to the top
    of the file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MauiProgram.cs`文件，在文件顶部添加以下`using`声明：
- en: '[PRE36]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `CreateMauiApp` method make the following highlighted changes:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreateMauiApp`方法中，进行以下突出显示的更改：
- en: '[PRE37]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This adds `MainPage`, `MainPageViewModel`, and the default instance of `WeakReferenceMessenger`
    to the dependency injection container. The next few steps will enable `MainPage`
    to be initialized via dependency injection.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会将 `MainPage`、`MainPageViewModel` 和 `WeakReferenceMessenger` 的默认实例添加到依赖注入容器中。接下来的几个步骤将使
    `MainPage` 能够通过依赖注入进行初始化。
- en: 'Open `MainView.xaml.cs` and make the following highlighted changes:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainView.xaml.cs` 文件，并进行以下高亮显示的更改：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As in other chapters, the constructor for the view is updated to accept the
    view model as a parameter, and it is assigned as `BindingContext`.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同其他章节，视图的构造函数被更新以接受视图模型作为参数，并将其分配为 `BindingContext`。
- en: 'Open `App.xaml.cs`, modify the constructor, and add the `OnHandlerChanging`
    event handler, as shown in the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.xaml.cs` 文件，修改构造函数，并添加 `OnHandlerChanging` 事件处理程序，如下所示：
- en: '[PRE39]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since a .NET MAUI Blazor app does not use `Shell` by default, the views cannot
    be initialized via dependency injection the same way as is done with `Shell`.
    Instead, the instance of `MainPage` is obtained after `Handler` has been set.
    The `OnHandlerChanging` event is used to get the reference to the new `Handler`,
    which then provides `MauiContext` to the dependency injection container.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 .NET MAUI Blazor 应用程序默认不使用 `Shell`，因此视图不能像使用 `Shell` 那样通过依赖注入进行初始化。相反，在设置
    `Handler` 之后，将获取 `MainPage` 的实例。使用 `OnHandlerChanging` 事件来获取新 `Handler` 的引用，然后它为依赖注入容器提供
    `MauiContext`。
- en: 'Open `_Imports.razor` and add the following lines to the end of the file:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `_Imports.razor` 文件，并将以下行添加到文件末尾：
- en: '[PRE40]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Open `Keypad.razor` and add the following highlighted lines:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Keypad.razor` 文件，并添加以下高亮显示的行：
- en: '[PRE41]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will inject the `Calculations` instance as `calculations` and `WeakReference`
    **Messenger** as `messenger` from the .NET MAUI dependency injection container.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将从 .NET MAUI 依赖注入容器中注入 `Calculations` 实例作为 `calculations` 和 `WeakReference`
    **信使** 作为 `messenger`。
- en: 'Modify the `ClearAll` and `EvaluateExpression` methods and add an `OnAfter`
    **RenderAsync** method, as shown in the following code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `ClearAll` 和 `EvaluateExpression` 方法，并添加一个 `OnAfter` **RenderAsync** 方法，如下所示：
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open the `Shared/MainLayout.razor.css` file and add the following line to the
    `page` class:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Shared/MainLayout.razor.css` 文件，并将以下行添加到 `page` 类中：
- en: '[PRE43]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is simply for aesthetics and makes the areas surrounding the calculator
    black.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是为了美观，使得计算器周围区域变为黑色。
- en: 'Open the `MainPage.xaml` file and modify it so that it matches the following
    code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainPage.xaml` 文件，并修改它以匹配以下代码：
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A `Grid` element with two rows defined is used to contain the new display for
    previous calculations and the original `BlazorWebView` control. The calculations
    are rendered using `ScrollView`, which contains `CollectionView`. The `CollectionView.ItemTemplate`
    property contains `DataTemplate` for each `Calculation`. The `SwipeView` control
    allows the user to swipe in either the up, down, left, or right direction to expose
    additional commands. Each direction has an element to define those actions. For
    `Calculation` items, when the user swipes right, it exposes a `Recall` item, which
    is bound to the `Recall` command of `MainPageViewModel`. The display for `Calculation`
    uses a combination of horizontal and vertical `StackLayout` controls to stack
    `Expression` on top of `Result` with `=`, all aligned to the left.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用定义了两行的 `Grid` 元素来包含新的显示区域，用于之前的计算和原始的 `BlazorWebView` 控件。计算使用 `ScrollView`
    渲染，其中包含 `CollectionView`。`CollectionView.ItemTemplate` 属性包含每个 `Calculation` 的
    `DataTemplate`。`SwipeView` 控件允许用户向上、向下、向左或向右滑动以显示额外的命令。每个方向都有一个元素来定义这些操作。对于 `Calculation`
    项目，当用户向右滑动时，它会显示一个 `Recall` 项目，该项目绑定到 `MainPageViewModel` 的 `Recall` 命令。`Calculation`
    的显示使用水平和垂直 `StackLayout` 控件的组合来堆叠 `Expression` 在 `Result` 之上，并用 `=` 对齐，所有内容都向左对齐。
- en: That completes the main functionality of our calculator app. The next section
    deals with some aesthetics of the main window when running on a desktop such as
    Windows or macOS.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们计算器应用的主要功能。下一节将处理在桌面操作系统（如 Windows 或 macOS）上运行时的主窗口的一些美学问题。
- en: Resizing the main window
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整主窗口大小
- en: 'The calculator app is defined to be a fixed size. Most of the projects in this
    book have allowed the controls to grow or shrink with changes to the window size.
    For our calculator app, the main window should be fixed so that it appears in
    the best way possible. To fix the window size when the app launches, open the
    `App.xaml.cs` file and add the following method to the `App` class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器应用被定义为固定大小。本书中的大多数项目都允许控件随着窗口大小的变化而增长或缩小。对于我们的计算器应用，主窗口应该是固定的，以便以最佳方式显示。要在应用启动时固定窗口大小，打开
    `App.xaml.cs` 文件，并将以下方法添加到 `App` 类中：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `CreateWindow` method is overridden so that the `Window.Created` event can
    have a custom handler attached to it if the app is running on Windows or macOS.
    The work of resizing the window is done in the `Window_Created` method. It uses
    the `defaultHeight` and `defaultWidth` constants to set the new windows’ height,
    width, and location on the screen. The method then waits for all threads to have
    finished before altering the `X` and `Y` properties of the window again, but this
    time accounting for the screen pixel density. Finally, it detaches the event handler
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateWindow` 方法被重写，以便当应用在 Windows 或 macOS 上运行时，可以给 `Window.Created` 事件附加一个自定义处理程序。调整窗口大小的操作在
    `Window_Created` 方法中完成。它使用 `defaultHeight` 和 `defaultWidth` 常量来设置新窗口的高度、宽度和屏幕上的位置。然后，该方法等待所有线程完成后再再次更改窗口的
    `X` 和 `Y` 属性，但这次要考虑到屏幕像素密度。最后，它断开事件处理程序'
- en: "![Figure 11.1\uFEFF5 – The completed calculator project](img/B19214_11_15.jpg)"
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 完成的计算器项目](img/B19214_11_15.jpg)'
- en: Figure 11.15 – The completed calculator project
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 完成的计算器项目
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Excellent work! In this chapter, you completed a project that used the .NET
    MAUI Blazor template. You created a UI using HTML, updated it with C# code, and
    then implemented a service that was managed by .NET MAUI and injected it into
    a Razor page. Then, you used `CollectionView` to display a list of the previous
    calculations. Within `CollectionView` `ItemTemplate`, the `SwipeView` control
    was used to recall a previous calculation to the keypad for additional editing
    and reevaluation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作！在本章中，你完成了一个使用 .NET MAUI Blazor 模板的项目。你使用 HTML 创建了一个 UI，并用 C# 代码更新它，然后实现了一个由
    .NET MAUI 管理并注入到 Razor 页面中的服务。然后，你使用 `CollectionView` 显示之前计算列表。在 `CollectionView`
    的 `ItemTemplate` 中，使用了 `SwipeView` 控件来将之前的计算召回键盘进行额外的编辑和重新评估。
- en: 'To extend this project even further, consider the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步扩展此项目，请考虑以下：
- en: Add an additional swipe action to delete a calculation from the collection
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为集合添加一个额外的滑动操作以删除一个计算
- en: Add an additional keypad layout for scientific calculations
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为科学计算添加一个额外的键盘布局
- en: In the next – and final – chapter, you will discover the world of AI as you
    build an object recognition app.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章——也是最后一章中，你将随着构建一个物体识别应用而发现人工智能的世界。
