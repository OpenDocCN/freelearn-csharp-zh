- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: MVVM and Controls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM 和控件
- en: In [*Chapter 3*](B19723_03.xhtml#_idTextAnchor036), we examined the fundamentals
    of .NET MAUI, but our code was in the code-behind files associated with XAML files.
    It is time, though, to turn our attention to the consensus architecture for .NET
    MAUI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B19723_03.xhtml#_idTextAnchor036) 中，我们探讨了 .NET MAUI 的基础知识，但我们的代码位于与
    XAML 文件关联的后台代码文件中。然而，现在是时候将我们的注意力转向 .NET MAUI 的共识架构了。
- en: '**Model-View-ViewModel** (**MVVM**) is not a tool or a platform but an architecture.
    Simply put, it is a way of organizing your code and thinking to optimize the creation
    of .NET MAUI applications and to facilitate unit testing (see [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160)).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型** (**MVVM**) 不是一个工具或平台，而是一种架构。简单来说，它是一种组织代码和思考的方式，以优化 .NET MAUI
    应用程序的创建并便于单元测试（参见 [*第 9 章*](B19723_09.xhtml#_idTextAnchor160)）。'
- en: At its simplest, MVVM consists of three sets of files, that is three namespaces,
    which essentially means three folders (with subfolders as needed). Taken in turn,
    `Model` is the set of classes that define the *shape* of your data. This just
    means that the classes that represent data are held in the model.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，MVVM 由三组文件组成，即三个命名空间，这本质上意味着三个文件夹（根据需要包含子文件夹）。依次来看，`Model` 是定义数据 *形状*
    的类集合。这仅仅意味着表示数据的类被保存在模型中。
- en: '`View` is, in simple words, the page that the user sees.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`View` 是用户看到的页面。
- en: '`ViewModel` is where all the action happens. It is the set of classes that
    manage the logic of your program and that contain the *properties* that are presented
    in `View`. We’ll get into **ViewModel** (**VM**) properties as we go.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 是所有动作发生的地方。它是管理程序逻辑并包含在 `View` 中展示的 *属性* 的类集合。随着我们的深入，我们将探讨 **ViewModel**
    (**VM**) 属性。'
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Setting up MVMM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 MVVM
- en: Data binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: XAML versus C#
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML 与 C#
- en: Behaviors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为
- en: Popups and dialogs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹出窗口和对话框
- en: Brushes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画笔
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need the latest version of Visual Studio (any edition).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要 Visual Studio 的最新版本（任何版本）。
- en: Each chapter in this book is saved as a branch. The code shown in this chapter
    and the next is in the branch at [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls).
    If you check out the branch you’ll see where we ended up, but if you want some
    of the intermediate steps, just examine the commits that contributed to the branch.
    To follow along, however, check out the branch at [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Navigation/tree/XAMLAndCSharp](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Navigation/tree/XAMLAndCSharp)
    as the starting point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每一章都保存为一个分支。本章和下一章中显示的代码位于 [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls)
    分支中。如果您检查该分支，您将看到我们最终到达的位置，但如果您想查看一些中间步骤，只需检查对分支做出贡献的提交即可。然而，为了跟上进度，请从 [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Navigation/tree/XAMLAndCSharp](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Navigation/tree/XAMLAndCSharp)
    分支作为起点。
- en: Setting up for MVVM
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 MVVM 准备
- en: 'MVVM is as much a way to organize your files and folders as it is an architectural
    approach. To get started using MVVM we’ll do two things:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 既是组织文件和文件夹的方式，也是一种架构方法。要开始使用 MVVM，我们将做两件事：
- en: Create the folders.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件夹。
- en: Download the associated Community Toolkits.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载相关的社区工具包。
- en: Creating folders
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文件夹
- en: 'We will be creating three folders. Before I tell you the names of these folders,
    I should say there is some disagreement about what exactly to name them. *Table
    4.1* shows the folder names and their alternatives:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个文件夹。在我告诉你这些文件夹的名称之前，我应该说明，关于确切命名它们的意见存在一些分歧。*表 4.1* 显示了文件夹名称及其替代方案：
- en: '| **Name** **we’ll use** | **Alternative 1** | **Alternative 2** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **我们将使用** **名称** | **替代方案 1** | **替代方案 2** |'
- en: '| `Model` | `Models` |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Model` | `Models` |  |'
- en: '| `View` | `Views` | `Pages` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `View` | `Views` | `Pages` |'
- en: '| `ViewModel` | `ViewModels` |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `ViewModel` | `ViewModels` |  |'
- en: Table 4.1 – Naming the folders
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 文件夹命名
- en: As you can see, the key difference is whether or not the name of the folder
    should use the plural, reflecting the fact that there will be more than one file
    in each folder, or the singular (as we will do), reflecting the name Model-View-ViewModel.
    I can’t think of a less important controversy, and it clearly doesn’t matter what
    you choose as long as you are consistent. Arbitrarily, we’ll use the first.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，关键的区别在于文件夹的名称是否应该使用复数，反映每个文件夹中将有多于一个文件的事实，或者使用单数（正如我们将做的），反映 Model-View-ViewModel
    的名称。我想不出一个更不重要的争议，而且显然你选择什么只要保持一致就无关紧要。任意地，我们将使用前者。
- en: 'Thus, create three folders in your project: `Model`, `View`, and `ViewModel`,
    as shown in *Figure 4**.1*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你的项目中创建三个文件夹：`Model`、`View` 和 `ViewModel`，如图 *图 4**.1* 所示：
- en: '![Figure 4.1 – MVVM Folders'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – MVVM 文件夹'
- en: '](img/Figure_4.1_B19723.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B19723.jpg)'
- en: Figure 4.1 – MVVM Folders
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – MVVM 文件夹
- en: '`MainPage` is now in the wrong place. Drag `MainPage.xaml` to the `View` folder
    (it will bring its code-behind with it). You need to fix the namespace in the
    XAML file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage` 现在位置不正确。将 `MainPage.xaml` 拖到 `View` 文件夹（它将带其代码后置文件一起移动）。你需要修复 XAML
    文件中的命名空间：'
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And in the code behind:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码背后：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Microsoft provides libraries that are not part of .NET MAUI as they were created
    by the .NET community, but which, nonetheless, Microsoft endorses and supports.
    Much of the functionality of these community toolkits will probably migrate into
    .NET MAUI itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了由 .NET 社区创建但微软认可和支持的库，这些库不是 .NET MAUI 的一部分。这些社区工具包的大部分功能可能会迁移到 .NET MAUI
    本身。
- en: The MVVM Community Toolkit
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM 社区工具包
- en: 'Open `CommunityToolkit-MVVM` and click on **CommunityToolkit.MVVM**. This wonderful
    toolkit will make programming with MVVM infinitely easier than it otherwise would
    be. See *Figure 4**.2*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `CommunityToolkit-MVVM` 并点击 **CommunityToolkit.MVVM**。这个出色的工具包将使使用 MVVM 的编程比其他方式更容易。见图
    *图 4**.2*：
- en: '![Figure 4.2 – Getting the NuGet package'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 获取 NuGet 包'
- en: '](img/Figure_4.2_B19723.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B19723.jpg)'
- en: Figure 4.2 – Getting the NuGet package
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 获取 NuGet 包
- en: We’ll come back to how to use this toolkit when we talk about *source code generators*.
    Next, let’s take a look at some of the views.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到 *源代码生成器* 时，我们将回到如何使用此工具包。接下来，让我们看看一些视图。
- en: Exploring views
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索视图
- en: .NET MAUI Controls is a generic term for pages, layouts, and views. In this
    chapter, we will look at views, while pages and layouts will be reviewed in the
    next chapter. In [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129), we’ll look at
    navigating between pages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 控件是一个泛称，用于页面、布局和视图。在本章中，我们将查看视图，而页面和布局将在下一章中回顾。在 [*第 7 章*](B19723_07.xhtml#_idTextAnchor129)
    中，我们将查看页面之间的导航。
- en: Views versus pages
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 视图与页面
- en: From the perspective of MVVM, a view is a page. From the perspective of .NET
    MAUI, `View` is a control. So, just to keep you totally confused, a View consists
    of Views and layouts. To avoid this absurdity, we’ll refer to the latter as controls.
    Some frameworks call these widgets. From time to time I’ll forget and refer to
    these controls as Views, but the context will make clear what I mean.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MVVM 的角度来看，一个视图是一个页面。从 .NET MAUI 的角度来看，`View` 是一个控件。所以，为了让你完全困惑，一个视图由视图和布局组成。为了避免这种荒谬，我们将后者称为控件。一些框架将这些称为小部件。不时我会忘记，将这些控件称为视图，但上下文将清楚地表明我的意思。
- en: A .NET MAUI Control is an object that maps to native controls on each target
    platform. Thus, a .NET MAUI Button maps to an iOS, Android, Macintosh, and Windows
    native Button.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 控件是一个映射到每个目标平台上的本地控件的对象。因此，.NET MAUI 按钮映射到 iOS、Android、Macintosh 和
    Windows 的本地按钮。
- en: 'The principal way to display text is with `Label`. The inheritance tree for
    `Label` is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文本的主要方式是使用 `Label`。`Label` 的继承树如下：
- en: '`Object` > `BindableObject` > `Element` > `NavigableElement` >'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` > `BindableObject` > `Element` > `NavigableElement` >'
- en: '`VisualElement` > `View` > `Label`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualElement` > `View` > `Label`'
- en: An object is, of course, the base for every class in C#. We’ll skip over `BindableObject`
    for now, and we’ll group `Element`, `NavigableElement`, and `VisualElement` together
    as things you can see on your page. This brings us to `View` as described previously,
    and then `Label` itself.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对象当然是 C# 中每个类的基类。我们现在暂时跳过 `BindableObject`，并将 `Element`、`NavigableElement` 和
    `VisualElement` 一起分组为你在页面上可以看到的东西。这使我们回到了之前描述的 `View`，然后是 `Label` 本身。
- en: 'The most common property to use on `Label` is `Text`. `Text` is what `Label`
    displays, thus you can write the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Label` 上最常用的属性是 `Text`。`Text` 是 `Label` 显示的内容，因此你可以编写以下内容：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a Label that displays the iconic greeting. But there is more you
    can do with `Label`, as we saw in the previous chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个显示标志性问候语的标签。但你可以用 `Label` 做更多的事情，就像我们在上一章中看到的那样。
- en: Forget Me Not labels
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Forget Me Not 标签
- en: Let’s look at Labels in the context of Forget Me Not. We already have the application,
    but it is just what we get out of the box. Let’s revise this first page to create
    the initial page for Forget Me Not.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Forget Me Not 的上下文中看看标签。我们已经有应用程序了，但它只是开箱即得。让我们修改这个第一页，为 Forget Me Not
    创建初始页面。
- en: 'Please click on the `VerticalStackLayout` on `MainPage.xaml` That will collapse
    `VerticalStackLayout` and allow you to delete it all at once, as shown in *Figure
    4**.3*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请点击 `MainPage.xaml` 中的 `VerticalStackLayout`，这将折叠 `VerticalStackLayout` 并允许你一次性删除它，如图
    *图 4.3* 所示：
- en: '![Figure 4.3 – Collapsed VerticalStackLayout'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 折叠的 VerticalStackLayout'
- en: '](img/Figure_4.3_B19723.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B19723.jpg)'
- en: Figure 4.3 – Collapsed VerticalStackLayout
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 折叠的 VerticalStackLayout
- en: Next, go to the code-behind file (`MainPage.xaml.cs`) and remove the counter
    and the `OnCounterClicked` event handler.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到代码后文件（`MainPage.xaml.cs`）并删除计数器和 `OnCounterClicked` 事件处理器。
- en: Having cleaned all that out, we are ready to put in new code. We need a layout
    we can put labels into, so let’s create an empty `VerticalStackLayout`, and add
    a Label Control to it that says `Welcome to Forget` `Me Not`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 清理完所有这些后，我们就可以开始添加新的代码了。我们需要一个可以放入标签的布局，所以让我们创建一个空的 `VerticalStackLayout`，并向其中添加一个显示
    `Welcome to Forget Me Not` 的标签控制。
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’re ready to build on that. Let’s add some of the more common properties
    for making `Label` look good:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好在此基础上构建了。让我们添加一些使 `Label` 看起来更好的更常见属性：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ll examine each of these properties in turn, but first, *Figure 4**.4* shows
    what the page looks like right now:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次检查这些属性，但首先，*图 4.4* 显示了页面现在的样子：
- en: '![Figure 4.4 – Label'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – Label'
- en: '](img/Figure_4.4_B19723.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B19723.jpg)'
- en: Figure 4.4 – Label
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Label
- en: Note that the title (**Home**) is an artifact of the page. What we care about
    is the Label shown below it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标题（**主页**）是页面的一部分。我们关心的是下面的标签。
- en: 'Let’s see if we can’t make that look a bit nicer before we examine the properties
    of `Label` by adding just a bit of padding:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查 `Label` 的属性之前，让我们先看看是否可以使其看起来更美观一些，只需添加一点内边距：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That gives us the page, as shown in *Figure 4**.5*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就给出了如图 *图 4.5* 所示的页面。
- en: XAML Styler
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: XAML Styler
- en: Notice that the properties are laid out nicely and in alphabetical order. This
    is due to a (free) tool named XAML Styler which you can get from the Visual Studio
    Marketplace ([https://bit.ly/XAMLstyler](https://bit.ly/XAMLstyler)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性排列得很好，并且按字母顺序排列。这是由于一个名为 XAML Styler 的（免费）工具造成的，您可以从 Visual Studio Marketplace
    获取它（[https://bit.ly/XAMLstyler](https://bit.ly/XAMLstyler)）。
- en: '![Figure  4.5 – Label with Padding'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 带有内边距的 Label'
- en: '](img/Figure_4.5_B19723.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B19723.jpg)'
- en: Figure 4.5 – Label with Padding
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 带有内边距的 Label
- en: Much better. Let’s examine the preceding code with the padding line by line.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。让我们逐行检查前面的代码。
- en: Most of these properties are self-explanatory. The `BackgroundColor` property
    controls the entire label. In our case, we’ve set the `Padding` property (as described
    in [*Chapter 3*](B19723_03.xhtml#_idTextAnchor036)) to `10`; thus, the red shows
    with a padding of `10` all around the text.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些属性都是不言自明的。`BackgroundColor` 属性控制整个标签。在我们的例子中，我们将 `Padding` 属性（如 [*第 3 章*](B19723_03.xhtml#_idTextAnchor036)
    中所述）设置为 `10`；因此，红色在文本周围有 `10` 的内边距。
- en: As you can see, we set the text to `Bold` using the `FontAttributes` property.
    The possible attributes are `Bold`, `Italic`, and `None`, with `None` being the
    default.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 `FontAttributes` 属性将文本设置为 `Bold`。可能的属性是 `Bold`、`Italic` 和 `None`，其中
    `None` 是默认值。
- en: '`FontSize` can be entered in device-independent units (for example, `FontSize
    = "20")` or in one of the enumerated constants such as `Micro`, `Small`, `Large`,
    and so on.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`FontSize` 可以输入设备无关的单位（例如，`FontSize = "20"`）或者输入以下枚举常量之一，如 `Micro`、`Small`、`Large`
    等。'
- en: '`HorizontalOptions` and `VerticalOptions` place the label on the page relative
    to the edges of the page. We touched on this in the previous chapter. In the case
    of `HorizontalOptions`, the choices are `Start` (far left), `Center` (middle),
    or `End` (far right).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalOptions` 和 `VerticalOptions` 将标签放置在页面上的相对位置。我们在上一章中提到了这一点。在 `HorizontalOptions`
    的情况下，选择是 `Start`（最左边）、`Center`（中间）或 `End`（最右边）。'
- en: The next property is `LineBreakMode`, which goes with the `MaxLines` property.
    Together they determine how many lines of text the label can support and where
    the lines will be wrapped. To see this, modify the text to say “*Welcome to Forget
    Me Not, so glad you are here, we couldn’t do this without you and we appreciate
    your patience.*” As you can see in *Figure 4**.6*, the text is now centered on
    multiple lines, and each line breaks at a word boundary.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性是`LineBreakMode`，它与`MaxLines`属性一起使用。它们共同决定了标签可以支持多少行文本以及文本将在哪里换行。为了看到这一点，修改文本，使其说“*欢迎来到忘不了，非常高兴你在这里，没有你我们无法做到这一点，我们感激你的耐心。*”正如你在*图4.6*中看到的那样，文本现在在多行中居中，并且每行都在单词边界处换行。
- en: '![Figure 4.6 – Multi-line Label'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 多行标签'
- en: '](img/Figure_4.6_B19723.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.6_B19723.jpg]'
- en: Figure 4.6 – Multi-line Label
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 多行标签
- en: As noted earlier, `Label` has dozens of properties, and while we’ve covered
    the most important ones, you can always look up the others on Microsoft Learn.
    In this case, the page you’ll need is [https://bit.ly/MicrosoftLabel](https://bit.ly/MicrosoftLabel).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Label`有数十个属性，虽然我们已经涵盖了最重要的属性，但你总是可以在Microsoft Learn上查找其他属性。在这种情况下，你需要查看的页面是[https://bit.ly/MicrosoftLabel](https://bit.ly/MicrosoftLabel)。
- en: The key to displaying data in the MVVM model is data binding, which allows us
    to associate a view and a property and then allows .NET MAUI to keep the view
    up to date as the value of the property changes. Let’s explore this next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM模型中显示数据的关键是数据绑定，这使我们能够将视图和属性关联起来，然后允许.NET MAUI在属性值变化时保持视图的更新。让我们继续探讨这一点。
- en: Data binding
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: One of the most powerful aspects of .NET MAUI is **data binding** and data binding
    works extremely well with MVVM. The idea is to *bind* data (values) to controls.
    For example, we might have a class with the text we want to display on this label
    held on a public property (you can only bind to public properties). Rather than
    having to copy that text from the class to the label, we just tell the label the
    name of the property.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI最强大的功能之一是**数据绑定**，并且数据绑定与MVVM配合得非常好。想法是将数据（值）绑定到控件上。例如，我们可能有一个类，其中包含我们想要在标签上显示的文本，它被保存在一个公共属性中（你只能绑定到公共属性）。我们不需要从类中复制该文本到标签，我们只需告诉标签属性的名称。
- en: The public property will be kept in a class in `ViewModel`. But we have to answer
    the question how does `View` know where to look for the property? That is handled
    by setting `BindingContext`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 公共属性将保存在`ViewModel`的类中。但我们必须回答这样一个问题：`View`如何知道在哪里查找属性？这通过设置`BindingContext`来处理。
- en: Let’s look at a simple example. In `ViewModel`, create a new file named `MainViewModel.cs`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子。在`ViewModel`中创建一个名为`MainViewModel.cs`的新文件。
- en: Naming ViewModel
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 命名ViewModel
- en: The most common naming convention is to name the page with the word page, such
    as `MainPage` or `LoginPage` but to drop the word page in the `ViewModel` name,
    such as `MainViewModel` and `LoginViewModel`. So, that is what we’ll do in this
    book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的命名约定是用单词*page*来命名页面，例如`MainPage`或`LoginPage`，但在`ViewModel`的名称中省略单词*page*，例如`MainViewModel`和`LoginViewModel`。所以，这就是我们在本书中要做的。
- en: Note that other programmers will use the `MainPageViewModel` name. On the other
    hand, some do not use the word *page* but rather *view*, as in `MainView` and
    `LoginView`. What is most important is for you (and your team) to be consistent
    so that it is easy to guess and find the associated pages and view models.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其他程序员将使用`MainPageViewModel`这个名字。另一方面，有些人不使用单词*page*，而是使用*view*，例如`MainView`和`LoginView`。最重要的是你（和你的团队）要保持一致性，这样就可以轻松猜测和找到相关的页面和视图模型。
- en: Before going ahead, notice that Visual Studio has put your class into the `ForgetMeNotDemo.ViewModel`
    namespace (if you named your project `ForgetMeNot`, the namespace will be `ForgetMeNot.ViewModel`).
    This is based on the folder the `.cs` file is in.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意Visual Studio已经将你的类放入了`ForgetMeNotDemo.ViewModel`命名空间（如果你将项目命名为`ForgetMeNot`，则命名空间将是`ForgetMeNot.ViewModel`）。这是基于`.cs`文件所在的文件夹。
- en: Make sure the class is public and that it is marked `partial`. All binding in
    .NET MAUI is done with partial classes, allowing the rest of the class to be handled
    internally and by generated partial classes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保类是公共的，并且被标记为`partial`。在.NET MAUI中，所有绑定都是使用部分类完成的，这使得类的其余部分可以由内部处理和生成的部分类处理。
- en: Creating a public property
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建公共属性
- en: We now want to create a property named `FullName`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想创建一个名为`FullName`的属性。
- en: 'The original way to do this looked something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的做法看起来像这样：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, the absolute best approach is to take advantage of the code generators
    in the `NuGet` package we just added. These work by using attributes. Add an attribute
    above the `[ObservableObject]` class declaration like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好的方法是我们利用我们刚刚添加的 `NuGet` 包中的代码生成器。这些生成器通过使用属性来实现。在 `[ObservableObject]`
    类声明上方添加一个属性，如下所示：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That attribute will allow you to generate properties. Above each property,
    use the `ObservableProperty` attribute:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性将允许你生成属性。在每个属性上方，使用 `ObservableProperty` 属性：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will cause the `NuGet` package to (invisibly) generate the uppercase public
    property and its `OnPropertyChanged()` method call as if you had entered them
    yourself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 `NuGet` 包（无形中）生成大写公共属性及其 `OnPropertyChanged()` 方法调用，就像你亲自输入它们一样。
- en: Before we look at how to set the `FullName` value, we need to set up `BindingContext`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何设置 `FullName` 值之前，我们需要设置 `BindingContext`。
- en: Setting up BindingContext
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 `BindingContext`
- en: '`BindingContext` tells your `View` where to get its bound data. You can set
    this in a number of ways; the most common is to set it in the code-behind file
    for the `View` class (in this case, `MainPage.xaml.cs`). First, we declare an
    instance of `ViewModel`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingContext` 告诉你的 `View` 从哪里获取其绑定数据。你可以通过多种方式设置它；最常见的是在 `View` 类的代码后文件中设置（在这种情况下，`MainPage.xaml.cs`）。首先，我们声明一个
    `ViewModel` 的实例：'
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the code behind the class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类的代码后：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we’ll see how to assign values to the `ViewModel` class properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何将值分配给 `ViewModel` 类的属性。
- en: Names
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: I don’t usually like abbreviations for names. There are rare exceptions, and
    using `vm` for `ViewModel` is such a strong convention that I yield to peer-group
    pressure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不喜欢名字的缩写。有一些罕见的例外，使用 `vm` 作为 `ViewModel` 的约定非常强烈，以至于我屈服于同伴压力。
- en: Assigning values to the View Model class properties
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将值分配给视图模型类的属性
- en: 'You can assign your string in `ViewModel`, in the `ViewModel` constructor,
    or in the override for the `OnAppearing` method. `OnAppearing` is called before
    `View` is displayed and looks like this (you put this in the code-behind file):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `ViewModel` 中、在 `ViewModel` 构造函数中或在 `OnAppearing` 方法的重写中分配你的字符串。`OnAppearing`
    在 `View` 显示之前被调用，其外观如下（你将此放入代码后文件中）：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will return to `OnAppearing` and its sibling `OnDisappearing` method, in
    [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 7 章*](B19723_07.xhtml#_idTextAnchor129) 中返回 `OnAppearing` 和其兄弟 `OnDisappearing`
    方法。
- en: InitializeComponent
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: InitializeComponent
- en: '`InitializeComponent` must be in the constructor of every code-behind file.
    It is the responsibility of `InitializeComponent` to initialize all the controls
    on the page.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitializeComponent` 必须在所有代码后文件的构造函数中。`InitializeComponent` 负责初始化页面上的所有控件。'
- en: Implementing Binding
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现绑定
- en: 'You are now ready to bind the `FullName` property to `Label`. In the XAML,
    change the `Label` text property to this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以绑定 `FullName` 属性到 `Label`。在 XAML 中，将 `Label` 文本属性更改为以下内容：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Naming properties and fields
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命名属性和字段
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the binding keyword tells `Label` to get its value from the `FullName`
    property found in the `ViewModel` set by `BindingContext`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定关键字告诉 `Label` 从 `ViewModel` 中通过 `BindingContext` 设置的 `FullName` 属性获取其值。
- en: 'You will want to pay attention to the syntax. It is always as shown here: open
    quotes, open braces, the `Binding` keyword, property name, closing brace, and
    closing quotes. Okay, I lied. It is sometimes more complex, but these elements
    are always there.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意语法。它总是如下所示：开引号，开大括号，`Binding` 关键字，属性名，闭大括号，闭引号。好吧，我骗了你们。有时它可能更复杂，但这些元素总是存在的。
- en: 'The result of this construct is that the value of `FullName` is placed inside
    the `Text` property of the label, as shown in *Figure 4**.7*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造的结果是 `FullName` 的值被放置在标签的 `Text` 属性中，如图 *图 4**.7* 所示：
- en: '![Figure 4.7 – A label with data-bound text'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 带有数据绑定文本的标签'
- en: '](img/Figure_4.7_B19723.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.7_B19723.jpg)'
- en: Figure 4.7 – A label with data-bound text
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 带有数据绑定文本的标签
- en: One of the distinguishing characteristics of an MVVM program is that the logic
    is in `ViewModel` rather than in the code-behind file, which we will explore next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 程序的一个显著特点是逻辑在 `ViewModel` 中，而不是在代码后文件中，我们将在下一节中探讨这一点。
- en: ViewModel versus code-behind
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图模型与代码后
- en: The more you can put into `ViewModel` (rather than the code-behind file) the
    easier it will be to test your program (see [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160)
    on unit testing). Some MVVM fans think *nothing* should be in the code-behind
    file besides the required call to `InitializeComponent`. They argue that even
    setting `ViewModel` should be done in the XAML to keep the code-behind file as
    empty as possible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将更多内容放入 `ViewModel`（而不是代码后文件），这样测试您的程序就会更容易（请参阅 [*第 9 章*](B19723_09.xhtml#_idTextAnchor160)
    中的单元测试）。一些 MVVM 粉丝认为除了对 `InitializeComponent` 的必需调用外，代码后文件中不应有任何内容。他们认为甚至设置 `ViewModel`
    也应该在 XAML 中完成，以使代码后文件尽可能空。
- en: 'I take a more moderate view of this. I often set `BindingContext` in the code-behind
    file. I do move all my *event handling* out of the code-behind file as you’ll
    see when we talk about commands:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个持有更为中庸的观点。我经常在代码后文件中设置 `BindingContext`。我也会像您在讨论命令时看到的，将所有的事件处理都移出代码后文件。
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that `BindingContext` here is set before calling `InitializeComponent`.
    While either can come first in most cases, setting up all your bindings before
    initializing the page is generally good practice. Thus, we’ll stick with the approach
    shown here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的 `BindingContext` 在调用 `InitializeComponent` 之前已经设置。虽然在大多数情况下两者可以互换，但在初始化页面之前设置所有绑定通常是良好的实践。因此，我们将坚持这里所示的方法。
- en: Renegade code-behind
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 非常规代码后
- en: There are times when it is just much easier to put a method in the code-behind
    file. Be careful with this, however. 99% of the time, when it seems really important
    to put something in the code-behind file, you actually can make it work in `ViewModel`,
    and that is much better (again, for testing). But if you do have to put something
    in the code-behind file, do not feel bad, and do not let other .NET MAUI programmers
    push you around.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在代码后文件中放置一个方法会容易得多。但是要小心。99% 的情况下，当您觉得在代码后文件中放置某物非常重要时，您实际上可以在 `ViewModel`
    中实现它，这要好得多（再次，为了测试）。但如果您确实需要在代码后文件中放置某些内容，请不要感到难过，也不要让其他 .NET MAUI 程序员欺负您。
- en: The center of developing most apps, the part that people respond to, is the
    **user interface** (**UI**). In .NET MAUI, the UI consists of views in layouts.
    Let’s turn our attention to the most important views.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序的开发中心，人们所响应的部分，是 **用户界面**（**UI**）。在 .NET MAUI 中，UI 由布局中的视图组成。让我们将注意力转向最重要的视图。
- en: Views
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'There are many controls for displaying and obtaining data from the user. The
    following sections will cover the most common and useful ones, including those
    shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多控件用于显示和从用户获取数据。以下几节将介绍最常见和有用的控件，包括这里展示的：
- en: Images
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Labels
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Buttons
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: ImageButtons
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像按钮
- en: Entering text
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入文本
- en: Images
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片
- en: You *can* write a .NET MAUI program without images, but it is likely to look
    pretty boring. Managing images is much easier in .NET MAUI than it was in `Xamarin.Forms`.
    Now, instead of having to have one image for each resolution in iOS and Android,
    you place one image in the resources folder, and .NET MAUI takes care of the rest
    for all the platforms!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您*可以*编写一个没有图片的 .NET MAUI 程序，但它可能看起来相当无聊。在 .NET MAUI 中管理图片比在 `Xamarin.Forms`
    中要容易得多。现在，您不需要为 iOS 和 Android 的每个分辨率都准备一个图片，只需将一个图片放在资源文件夹中，.NET MAUI 就会为所有平台处理其余部分！
- en: In this example, we’ll use an image named `flower.png`, which you can download
    from our GitHub repository. If you prefer, though, you can use any image you like.
    We’ll place the image in the `Resources` > `Images` folder.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个名为 `flower.png` 的图片，您可以从我们的 GitHub 仓库下载。如果您愿意的话，也可以使用您喜欢的任何图片。我们将把图片放在
    `Resources` > `Images` 文件夹中。
- en: 'When we are ready to display it, we’ll use an **Image View**. Here is a simple
    example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好显示它时，我们将使用 **图像视图**。以下是一个简单的示例：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I’ve only set three properties, but they accomplish quite a bit. `HeightRequest`
    sets, as you might guess, the height of the image on the page in device-independent
    units (in this case, `200`). I’ve set it to be centered. Most importantly, I’ve
    identified the source—that is the name of the image. But rather than lock in the
    name of the image in `View`, I’ve bound it to a property in `MainPageViewModel`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我只设置了三个属性，但它们完成了相当多的工作。`HeightRequest` 设置，正如您可能猜到的，页面中图片的高度（以设备无关的单位计，在这种情况下为
    `200`）。我将其设置为居中。最重要的是，我已标识了源——即图片的名称。但不是将图片的名称锁定在 `View` 中，而是将其绑定到 `MainPageViewModel`
    中的一个属性。
- en: 'The result is that `MainPage` now looks like *Figure 4**.8*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `MainPage` 现在看起来像 *图 4**.8*：
- en: '![Figure 4.8 – Binding the source to a property in ViewModel'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 将源绑定到 ViewModel 中的属性](img/Figure_4.8_B19723.jpg)'
- en: '](img/Figure_4.8_B19723.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B19723.jpg)'
- en: Figure 4.8 – Binding the source to a property in ViewModel
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 将源绑定到 ViewModel 中的属性
- en: 'Of course, there are a number of additional properties you can set. A set of
    favorites for me are the `Rotation` properties, which can rotate on the *x*, *y*,
    and *z* axes. If I add the `RotationX` property like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他属性可以设置。对我来说，一组最喜欢的属性是 `Rotation` 属性，它们可以在 *x*、*y* 和 *z* 轴上旋转。如果我将 `RotationX`
    属性添加如下：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The image rotates, as shown in *Figure 4**.9*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图片旋转，如图 *图 4.9* 所示：
- en: '![Figure 4.9 – RotationX=”45”'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – RotationX=”45”'
- en: '](img/Figure_4.9_B19723.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B19723.jpg)'
- en: Figure 4.9 – RotationX=”45”
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – RotationX=”45”
- en: 'Another useful trick is to make the image semi-transparent by setting `Opacity`
    to a value between `0` and `1`. *Figure 4**.10* shows the same image with an opacity
    of `.25`. I removed `StackLayout` and substituted a `Grid`. More about grids in
    the next chapter, but if you just declare one and put `Label` and `Image` into
    it with no other `Grid` properties, they lay one on top of the other:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的技巧是通过将 `Opacity` 设置为介于 `0` 和 `1` 之间的值来使图片半透明。*图 4.10* 展示了具有 `.25` 透明度的相同图片。我移除了
    `StackLayout` 并用 `Grid` 取代了它。关于网格的更多内容将在下一章中介绍，但如果你只声明一个网格并将 `Label` 和 `Image`
    放入其中，没有其他 `Grid` 属性，它们将一个叠在另一个上面：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Figure 4**.10* shows the result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.10* 展示了结果：'
- en: '![Figure 4.10 – Overlay and semi-transparent effect'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 叠加和半透明效果'
- en: '](img/Figure_4.10_B19723.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B19723.jpg)'
- en: Figure 4.10 – Overlay and semi-transparent effect
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 叠加和半透明效果
- en: There is endless room for creativity.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创造力的空间是无限的。
- en: Clicking on an image
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点击图片
- en: One of the key things that many people want to do with an image is click on
    it. There are two solutions to this problem. The easiest is to use a button.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人想要对图片做的关键事情之一就是点击它。这个问题的有两个解决方案。最简单的是使用一个按钮。
- en: Buttons can have text and a number of other properties, but the most important
    is the command. The command tells `ViewModel` what to do when the button is clicked.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮可以有文本和许多其他属性，但最重要的是命令。命令告诉 `ViewModel` 当按钮被点击时应该做什么。
- en: To show how this works, I’m going to put a new property on our image, `IsVisible`,
    and set it to `true`. As long as that is `true`, the image is visible. But, as
    you can imagine, setting it false makes the big flower invisible. Not only is
    it invisible, but it also takes up no space on the page, so the button will be
    directly under the label.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这是如何工作的，我将在我们的图片上添加一个新的属性 `IsVisible` 并将其设置为 `true`。只要它是 `true`，图片就是可见的。但，正如你可以想象的那样，将其设置为
    `false` 使得大花朵不可见。不仅不可见，它还在页面上不占用任何空间，因此按钮将直接位于标签下方。
- en: 'Here is the code for `Button`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Button` 的代码：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the simplest button I can make (we’ll look at making it nicer in just
    a bit). The key here is the `Command` parameter. You can tell by the `Binding`
    keyword that `ToggleFlowerVisibility` will be in `ViewModel`. Sure enough, it
    is, but rather than declaring a command and pointing it at a method, we can use
    the code generator to do the heavy lifting for us.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我能制作的 simplest 按钮了（我们将在稍后看看如何让它更好看）。这里的关键是 `Command` 参数。你可以通过 `Binding` 关键字知道
    `ToggleFlowerVisibility` 将在 `ViewModel` 中。确实如此，但我们不是声明一个命令并将其指向一个方法，而是可以使用代码生成器来为我们做繁重的工作。
- en: 'Here is the modified `MainViewModel`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是修改后的 `MainViewModel`：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is an example of *convention over configuration* – the `Command` property
    in `Button` is `ToggleFlowerVisibilityCommand`, but when you implement it in `RelayCommand`
    [2], you name it `ToggleFlowerVisibility` [3] leaving off `Command`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 *约定优于配置* 的例子 – `Button` 中的 `Command` 属性是 `ToggleFlowerVisibilityCommand`，但当你使用
    `RelayCommand` [2] 实现它时，你将其命名为 `ToggleFlowerVisibility` [3]，省略了 `Command`。
- en: Note that we created `FlowerIsVisible` [1] as an `ObservableProperty`, we simply
    toggle it from `true` to `false` and back on each click.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个 `FlowerIsVisible` [1] 作为 `ObservableProperty`，我们只需在每次点击时将其从 `true`
    切换到 `false` 再切回即可。
- en: Button properties
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮属性
- en: As it is now, the button will be displayed as it would appear natively on each
    platform. But these buttons can be pretty ugly. We can make them much nicer by
    taking over more of their appearance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，按钮将显示为在每个平台上原生显示的样子。但这些按钮可能相当难看。我们可以通过接管它们的外观的大部分来使它们看起来更漂亮。
- en: 'Here is my XAML for `Button`, which while not beautiful, will illustrate some
    of the properties you can use to take control of the button’s appearance:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的 `Button` 的 XAML，虽然不美观，但将展示你可以用来控制按钮外观的一些属性：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are three new properties that we’ve not seen before. The first is `BorderColor`,
    which goes along with `BorderWidth`. This provides a border around the button.
    Since we’ve set `BackgroundColor` to `Red`, the border will stand out. The final
    new property is `CornerRadius`, which gives us a nice rounding of the corners
    of the otherwise square button. Put that all together, and you get a button that
    looks like *Figure 4**.11*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个之前没有见过的新的属性。第一个是 `BorderColor`，它与 `BorderWidth` 一起使用。这为按钮提供了一个边框。由于我们已将
    `BackgroundColor` 设置为 `Red`，边框会突出显示。最后一个新属性是 `CornerRadius`，它为我们提供了对其他方形按钮角落的圆润处理。把这些都放在一起，你就得到了一个看起来像
    *图 4.11* 的按钮：
- en: '![Figure 4.11 – A nicer-looking button'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 一个看起来更好的按钮'
- en: '](img/Figure_4.11_B19723.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.11_B19723.jpg)'
- en: Figure 4.11 – A nicer-looking button
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 一个看起来更好的按钮
- en: Why is this button still ugly?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个按钮仍然很丑？
- en: I am certainly not a UI person, and so my pages tend to be fairly ugly until
    fixed by someone who knows what they are doing. The screen images in this book
    will reflect that inability.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我当然不是一个 UI 人员，所以我编写的页面通常相当丑陋，直到有人知道如何处理它们。这本书中的屏幕图像将反映出这种无能。
- en: ImageButton
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageButton
- en: 'At times, rather than having text, we’d rather have an image on the button.
    There is an `ImageButton` control that combines many of the properties of the
    `Image` control and the `Button` control:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们宁愿在按钮上放一个图片，而不是文字。有一个 `ImageButton` 控件，它结合了许多 `Image` 控件和 `Button` 控件的属性：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see how similar it is to the `Button` control. In fact, I’ve preserved
    the command binding and the source binding, so we end up with a small image of
    the flower under the big image, but clicking on the small one (`ImageButton`)
    causes the big one (`Image`) to become invisible and then visible, and so on.
    I’ll show both visible in *Figure 4**.12* because it is hard to toggle an image
    on paper:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它如何与 `Button` 控件相似。事实上，我保留了命令绑定和源绑定，所以我们最终在大的图片下面得到了一个小花的图片，但点击小的一个（`ImageButton`）会使大的一个（`Image`）变得不可见，然后又变得可见，以此类推。我会在
    *图 4.12* 中展示它们都可见的样子，因为很难在纸上切换图片：
- en: '![Figure 4.12 – ImageButton'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – ImageButton'
- en: '](img/Figure_4.12_B19723.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.12_B19723.jpg)'
- en: Figure 4.12 – ImageButton
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – ImageButton
- en: TapGestureRecognizer
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TapGestureRecognizer
- en: The second way to handle tapping on an image is to assign a gesture recognizer.
    The type of `GestureRecognizer` we’re going to assign is `TapGestureRecognizer`,
    which will recognize when the image itself has been tapped. To be safe, we’ll
    set it so that the image has to be double-tapped. When that happens, the image
    will “poof!” disappear.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 处理在图片上点击的第二种方式是分配一个手势识别器。我们将分配的 `GestureRecognizer` 类型是 `TapGestureRecognizer`，它将识别图片本身被点击的情况。为了安全起见，我们将它设置为图片必须被双击。当发生这种情况时，图片会“噗！”地消失。
- en: 'We’ll remove `ImageButton`, and just have `Image` (and `Label`). Here is our
    new XAML file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将移除 `ImageButton`，只保留 `Image`（和 `Label`）。这是我们的新 XAML 文件：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We see at [1] that the image starts as visible. Between the opening and closing
    brackets for `Image` we add `GestureRecognizer` [2]. Within `GestureRecognizer`
    we add `TapGestureRecognizer` [3], and we define `ImageTappedCommand` [4] just
    as we did with other commands. Finally, we declare that for the command to fire,
    the user must tap twice [5].
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [1] 处看到，图片最初是可见的。在 `Image` 的开头和结尾括号之间，我们添加了 `GestureRecognizer` [2]。在 `GestureRecognizer`
    中，我们添加了 `TapGestureRecognizer` [3]，并且我们定义了 `ImageTappedCommand` [4]，就像我们处理其他命令一样。最后，我们声明，为了触发命令，用户必须双击
    [5]。
- en: 'Here is an example of `RelayCommand` from `ViewModel`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从 `ViewModel` 中 `RelayCommand` 的示例：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, this handler is nearly identical to the previous one. However,
    this one won’t work as intended. Before reading further, try to figure out what
    will happen when we double-click on the image (to make it invisible) and then
    try to do so again (to make it visible). Take your time. I’ll wait here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个处理程序几乎与上一个相同。然而，这个处理程序不会按预期工作。在继续阅读之前，试着想想当我们双击图片（使其不可见）然后再次尝试这样做（使其可见）会发生什么。请慢慢来。我会在这里等待。
- en: You can solve this by going back to `Button`, or perhaps putting a `GestureRcognizer`
    on the Label.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过回到 `Button` 或者在标签上放置一个 `GestureRecognizer` 来解决这个问题。
- en: 'When you double-tap on the image, it does, in fact, disappear because `IsVisible`
    is set to false. However, once it disappears, it is gone, and there is nothing
    there to tap on to bring it back:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你双击图片时，它确实会消失，因为 `IsVisible` 被设置为 `false`。然而，一旦它消失，它就消失了，并且没有东西可以点击来让它回来：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What’s interesting here is that the `TapGestureRecognizer` command points to
    the same `RelayCommand`; it will be invoked either by double-tapping on the image
    or single-tapping on the label.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，`TapGestureRecognizer`命令指向相同的`RelayCommand`；它可以通过在图像上双击或单击标签来调用。
- en: 'The following are two takeaway points from this section:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本节有两个要点：
- en: '`TapGestureRecognizer` allows you to make any control tappable, which can be
    pretty powerful.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TapGestureRecognizer`允许您使任何控件可触摸，这可以非常强大。'
- en: Once `View` is invisible, it is no longer on the page. You can make it visible
    again from the code behind, but only if you do so by way of a different control
    (as we did with `ButtonImage`).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦`View`不可见，它就不再在页面上。您可以通过代码背后的方式再次使其可见，但仅限于通过不同的控件（就像我们使用`ButtonImage`那样）。
- en: After displaying text, the most important aspect of an app is the ability to
    obtain text from the user. For that, the principal views are `Entry` and `Editor`.
    Let’s have a look at them next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示文本后，应用程序最重要的方面是能够从用户那里获取文本。为此，主要视图是`Entry`和`Editor`。让我们接下来看看它们。
- en: Entering text
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入文本
- en: 'We’ve looked at displaying text, let’s turn our attention to entering text.
    There are two controls that are principally responsible for this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看了显示文本，现在让我们把注意力转向输入文本。有两个控件主要负责这一点：
- en: '`Entry`: Used for entering a line of text'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Entry`: 用于输入一行文本'
- en: '`Editor`: Used for entering multiple lines of text'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Editor`: 用于输入多行文本'
- en: These two controls are obviously related, but they have different properties.
    `Entry` is designed to take a single line of text and `Editor` handles multi-line
    entry.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个控件显然相关，但它们有不同的属性。`Entry`设计用于接受单行文本，而`Editor`处理多行输入。
- en: To see these views at work, let’s create a login page for Forget Me Not.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些视图的工作情况，让我们为“忘记我”创建一个登录页面。
- en: Forget Me Not login page
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忘记我登录页面
- en: 'We’ve been playing with the `MainPage`, but in truth, the actual application
    has a very simple `MainPage`: just the image. Things get more interesting with
    the login page. We will make a first approximation of the login page as it will
    allow us to use the `Entry` and `Editor` controls, though we will evolve this
    page as we go.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在玩`MainPage`，但事实上，实际应用程序的`MainPage`非常简单：只是一个图像。登录页面更有趣。我们将对登录页面做一个初步的近似，这将使我们能够使用`Entry`和`Editor`控件，尽管我们将随着进程的发展而改进这个页面。
- en: Creating the login page
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建登录页面
- en: 'The first task is to create the login page. To do so, right-click on the `LoginPage.xaml`,
    as shown in *Figure 4**.13*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建登录页面。要做到这一点，请右键单击`LoginPage.xaml`，如图*图4**.13*所示：
- en: '![Figure 4.13 – Add Item dialog box'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.13 – Add Item dialog box]'
- en: '](img/Figure_4.13_B19723.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_4.13_B19723.jpg]'
- en: Figure 4.13 – Add Item dialog box
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – Add Item对话框
- en: XAML versus C#
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XAML与C#
- en: If you wish to create the UI for the login page using C# rather than XAML, choose
    **ContentPage (C#)** instead. We’ll look at both in this section, but let’s start
    with the XAML version.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用C#而不是XAML来创建登录页面的UI，请选择**ContentPage (C#)**。我们将在本节中查看这两个，但让我们先从XAML版本开始。
- en: Examine the XAML page out of the box. The class is set to `ForgetMeNotDemo.View.LoginPage`,
    reflecting the namespace (when we created the file under `View` that became the
    namespace automatically). The XAML also has `VerticalStackLayout` and inside that,
    `Label`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 检查XAML页面，其类设置为`ForgetMeNotDemo.View.LoginPage`，反映了命名空间（当我们创建位于`View`下的文件时，命名空间会自动生成）。XAML还包括`VerticalStackLayout`，在其中，有`Label`。
- en: Take a very quick look at the code-behind file. Note that `namespace` has been
    created for you and that the page derives from `ContentPage` .
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下代码背后的文件。注意，已经为您创建了`namespace`，并且页面继承自`ContentPage`。
- en: 'Go back to the XAML page and delete `Label` in `VerticalScrollView`. When the
    application is complete, it should look like *Figure 4**.14*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 返回XAML页面，并在`VerticalScrollView`中删除`Label`。当应用程序完成时，它应该看起来像*图4**.14*：
- en: '![Figure 4.14 – Login.XAML (top portion)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.14 – Login.XAML (top portion)]'
- en: '](img/Figure_4.14_B19723.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_4.14_B19723.jpg]'
- en: Figure 4.14 – Login.XAML (top portion)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – Login.XAML（顶部部分）
- en: As you can see, we have two labels. To the right of each label is an entry,
    and the entry has placeholder text. As soon as you start typing in the entry,
    the placeholder text will disappear.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个标签。每个标签的右侧都有一个输入框，输入框有占位文本。一旦您开始在输入框中键入，占位文本就会消失。
- en: There are also three buttons. To lay this out properly, we’d like to use `Grid`,
    but we’re not covering grids until [*Chapter 6*](B19723_06.xhtml#_idTextAnchor115),
    *Layouts*. That’s not a problem, though, because it gives us the opportunity to
    look at nesting `StackLayouts` and using `HorizontalStackLayout`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有三个按钮。为了正确布局，我们希望使用 `Grid`，但我们不会在[*第 6 章*](B19723_06.xhtml#_idTextAnchor115)中介绍网格，*布局*。但这不是问题，因为它给了我们查看嵌套
    `StackLayouts` 和使用 `HorizontalStackLayout` 的机会。
- en: To get started, we’ll just create the top line. We’d like flexibility for the
    text in the label, and we’d like to capture the *User name* entry in a property
    of `ViewModel` that we haven’t created yet. Let’s do that now. Right-click on
    the `LoginViewModel` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们只需创建顶层。我们希望标签中的文本具有灵活性，并且我们希望捕获 `ViewModel` 中尚未创建的属性中的 *用户名* 输入。让我们现在就做。在
    `LoginViewModel` 类上右键单击。
- en: 'In `LoginViewModel` add `ObservableProperty` for the user name:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LoginViewModel` 中添加用于用户名的 `ObservableProperty`：
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the user types a name into the Entry control it will be saved in this property.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 `Entry` 控件中输入一个名字时，它将保存在这个属性中。
- en: OneWay and TwoWay binding
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: OneWay 和 TwoWay 绑定
- en: Controls can be `OneWay`, in which case the control gets its value from the
    data source (in this case, the property) but can’t send it back, or `TwoWay`,
    in which case the control gets its data from the data source but can also write
    a value back. `Entry` defaults to `TwoWay`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 控件可以是 `OneWay`，在这种情况下，控件从数据源（在这种情况下，属性）获取其值，但不能将其发送回去，或者 `TwoWay`，在这种情况下，控件从数据源获取数据，但也可以写回一个值。`Entry`
    默认为 `TwoWay`。
- en: 'We’re ready to create the top line in `LoginPage` in XAML:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好在 XAML 中的 `LoginPage` 创建顶层：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We’re using three properties on `Entry`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Entry` 上使用了三个属性：
- en: '`HorizontalOptions`: Here we are setting it to `End` so that `Entry` will be
    to the far right of the line'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HorizontalOptions`：这里我们将它设置为 `End`，这样 `Entry` 就会在行的最右边'
- en: '`PlaceHolder`: This is the text that will be displayed until the user starts
    to enter text'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlaceHolder`：这是用户开始输入文本之前将显示的文本'
- en: '`Text`: We have bound this to the `Name` property in `ViewModel`'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Text`：我们将其绑定到 `ViewModel` 中的 `Name` 属性'
- en: 'There is one problem looking at this page: there is no way to get there (yet).
    For now, rather than having the program open at `MainPage`, we’ll have it open
    to our new `LoginPage`. To do so, go to `AppShell.xaml` and change `ShellContent`
    to look like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个页面有一个问题：没有方法可以到达那里（目前还没有）。现在，而不是让程序在 `MainPage` 中打开，我们将让它打开到我们新的 `LoginPage`。为此，转到
    `AppShell.xaml` 并将 `ShellContent` 改成这样：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll be discussing the Shell and routing in [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129),
    but this will work for now.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 7 章*](B19723_07.xhtml#_idTextAnchor129)中讨论 Shell 和路由，但现在这将是可行的。
- en: 'Run the program. If you run it on an Android device or emulator, it should
    look more or less like *Figure 4**.15*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序。如果你在 Android 设备或模拟器上运行它，它应该看起来大致像*图 4.15*：
- en: '![Figure 4.15 – LoginPage, the first iteration'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – LoginPage，第一次迭代'
- en: '](img/Figure_4.15_B19723.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B19723.jpg)'
- en: Figure 4.15 – LoginPage, the first iteration
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – LoginPage，第一次迭代
- en: Even for me, it’s not very attractive, but it does demonstrate the controls
    and the layout. Try typing in the **User Name** entry. Notice that the placeholder
    text disappears instantly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对我来说，这也不是很吸引人，但它确实展示了控件和布局。尝试在 **用户名** 输入框中输入。注意，占位符文本会立即消失。
- en: 'We need a way to tell whether the value you entered is really binding to the
    `Name` property. To do this, let’s add a label and bind it to the `Name` property.
    That way, when we enter text into the entry it will be reflected in `Label`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法来判断你输入的值是否真正绑定到 `Name` 属性。为此，让我们添加一个标签并将其绑定到 `Name` 属性。这样，当我们输入文本到输入框时，它将在
    `Label` 中反映出来：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, before we can make that work, we have to set up `BindingContext`,
    as we did on `MainPage`. Open the code-behind file for the XAML page and set up
    `LoginViewModel` as the binding context:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够使其工作之前，我们必须设置 `BindingContext`，就像我们在 `MainPage` 上做的那样。打开 XAML 页面的代码隐藏文件，并将
    `LoginViewModel` 设置为绑定上下文：
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we run this and type into the entry the text is saved in the `Name` property
    in `ViewModel`. Since the label is bound to the same property, the text is immediately
    shown there as well, as seen in *Figure 4**.16*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序并在输入框中输入文本时，文本将保存在 `ViewModel` 中的 `Name` 属性中。由于标签绑定到相同的属性，文本也会立即在那里显示，如*图
    4.16*所示。16*：
- en: '![Figure 4.16 – Proving that the entry is binding to the Name property'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – 证明输入框绑定到 Name 属性'
- en: '](img/Figure_4.16_B19723.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B19723.jpg)'
- en: Figure 4.16 – Proving that the entry is binding to the Name property
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 证明输入绑定到 Name 属性
- en: 'Now that we know it is working, delete the label. Let’s do the same thing for
    the password that we did for the name, except that we don’t want anyone to see
    the password we’re entering. No problem, `Entry` has a `boolean` property, `IsPassword`,
    which we’ll set to `True`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道它正在工作，删除标签。让我们为密码做同样的事情，就像我们对名字所做的那样，只是我们不想让任何人看到我们输入的密码。没问题，`Entry` 有一个
    `boolean` 属性，`IsPassword`，我们将将其设置为 `True`：
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Before continuing, notice that we have `VerticalStackLayout` that contains two
    `HorizontalStackLayouts`. This is a not uncommon layout, but again we’ll get more
    control over the appearance when we move on to `Grid`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意我们有一个 `VerticalStackLayout`，其中包含两个 `HorizontalStackLayouts`。这是一个不常见的布局，但当我们转向
    `Grid` 时，我们将在外观上获得更多的控制。
- en: 'The result of this XAML is shown in *Figure 4**.17*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此 XAML 的结果显示在 *图 4**.17* 中：
- en: '![Figure 4.17 – Using the password Boolean on Entry'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – 在 Entry 上使用密码布尔值'
- en: '](img/Figure_4.17_B19723.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B19723.jpg)'
- en: Figure 4.17 – Using the password Boolean on Entry
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 在 Entry 上使用密码布尔值
- en: 'Let’s complete this first iteration of the page by adding the three buttons.
    We’ll only give one (**Submit**) a command for now:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加三个按钮来完成这个页面的第一次迭代。现在我们只为一个（**提交**）分配一个命令：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result is shown in *Figure 4**.18*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在 *图 4**.18* 中：
- en: '![Figure 4.18 – Adding the buttons'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – 添加按钮'
- en: '](img/Figure_4.18_B19723.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B19723.jpg)'
- en: Figure 4.18 – Adding the buttons
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 添加按钮
- en: When you run this, you may notice that it works fine, except that clicking on
    **Submit** doesn’t do anything. That is because we named the command but never
    implemented it. We’re going to save doing so for a while. Actually, for a long
    while. We’ll tackle the real implementation when we get to [*Chapter 11*](B19723_11.xhtml#_idTextAnchor216),
    *Working with* *the API*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你可能注意到它运行得很好，除了点击 **提交** 没有做任何事情。这是因为我们命名了命令但从未实现它。我们将稍后进行操作。实际上，我们会长时间地推迟。我们将在到达
    [*第 11 章*](B19723_11.xhtml#_idTextAnchor216)，*与 API 一起工作* 时处理真正的实现。
- en: The Title
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题
- en: You may have noticed that the page has a **LoginPage** title. The good news
    is that we got that for free (.NET MAUI created it when we created the page).
    However, it would be nice to have a space between **Login** and **Page**.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到页面有一个 **LoginPage** 标题。好消息是这是免费的（.NET MAUI 在我们创建页面时创建了它）。然而，在 **登录**
    和 **页面** 之间有一个空格会更好。
- en: At the top of the XAML page is the declaration of `ContentPage`, and the first
    property set there is `Title`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XAML 页面的顶部是 `ContentPage` 的声明，并设置了第一个属性 `Title`。
- en: '[PRE32]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Just insert the missing space, and all will be right with the world.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 只需插入缺失的空格，一切都会变得完美。
- en: Editor
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑器
- en: The second primary way of entering text into your application is with the `Editor`
    control. The principal difference from the `Entry` class is that `Editor` is designed
    for multi-line data entry. You have a lot of control over the text, as you’ll
    see in the next example.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本输入到应用程序中的第二种主要方式是使用 `Editor` 控件。与 `Entry` 类的主要区别在于 `Editor` 是为多行数据输入设计的。你可以对文本有相当大的控制，你将在下一个示例中看到。
- en: Let’s add an editor to the login page. We’ll set it so that it is only visible
    if the user clicks on **Forgot Password**. The user will be encouraged to explain
    exactly where the password was the last time they saw it and why they were so
    careless when we told them to keep the password secure.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在登录页面添加一个编辑器。我们将设置它，使其仅在用户点击 **忘记密码** 时可见。我们将鼓励用户解释他们上次看到密码的确切位置以及为什么我们在告诉他们要确保密码安全时他们如此粗心。
- en: 'Reopen `LoginPage.xaml` and add an `Editor` inside `VerticalStackLayout`, at
    the very bottom:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开 `LoginPage.xaml` 并在 `VerticalStackLayout` 中添加一个 `Editor`，位于最底部：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I’ve used a number of properties on the editor, and a few of them are new.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我在编辑器上使用了许多属性，其中一些是新的。
- en: '[1] `IsTextPredictionEnabled` allows your editor to offer the user text to
    complete their sentence. You’ve seen this, no doubt, when working with Gmail and
    other applications. This is actually `True` by default; you might want to set
    it to `False` when asking for a user’s name or other conditions in which the prediction
    might be annoying.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] `IsTextPredictionEnabled` 允许你的编辑器为用户提供文本以完成他们的句子。你无疑在处理 Gmail 和其他应用程序时已经看到了这一点。这实际上是默认的
    `True`；你可能想在请求用户姓名或其他可能令人烦恼的预测条件下将其设置为 `False`。'
- en: '[2] `MaxLength` manages how many characters the user may enter into the editor.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] `MaxLength` 管理用户可以输入到编辑器中的字符数。'
- en: '[3] `PlaceHolderColor` allows you to set the color of the placeholder text.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] `PlaceHolderColor` 允许你设置占位文本的颜色。'
- en: '[4] Similarly, `TextColor` sets the color of the text the user enters.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 类似地，`TextColor` 设置用户输入文本的颜色。'
- en: '[5] `VerticalTextAlignment` sets where, within the editor, the text will lie.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] `VerticalTextAlignment` 设置文本在编辑器中的位置。'
- en: '*Figure 4**.19* shows what **Login Page** looks like before the user enters
    anything into the editor, and *Figure 4**.20* shows what it looks like after the
    user has entered a few lines of text:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.19* 显示了用户在编辑器中输入任何内容之前 **登录页面** 的样子，而 *图 4.20* 显示了用户输入了几行文本后的样子：'
- en: '![Figure 4.19 – Before the user enters text into the editor'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – 用户在编辑器中输入文本之前'
- en: '](img/Figure_4.19_B19723.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.19_B19723.jpg)'
- en: Figure 4.19 – Before the user enters text into the editor
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 用户在编辑器中输入文本之前
- en: You can enter as much text as you want into the editor, up to whatever maximum
    you’ve set in the declaration of the control.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你想要的文本输入到编辑器中，最多不超过你在控件声明中设置的任何最大值。
- en: '![Figure 4.20 – After the user enters text into the editor'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20 – 用户在编辑器中输入文本之后'
- en: '](img/Figure_4.20_B19723.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.20_B19723.jpg)'
- en: Figure 4.20 – After the user enters text into the editor
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 用户在编辑器中输入文本之后
- en: 'Although the margin is only set to `10`, there is a huge space between the
    buttons and the text. That is because we set `VerticalTextAlignment` to `Center`.
    If we change it to `Start`, the text will move to the top of the editor, as shown
    in *Figure 4**.21*:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然边距只设置为 `10`，但按钮和文本之间有很大的空间。这是因为我们将 `VerticalTextAlignment` 设置为 `Center`。如果我们将其更改为
    `Start`，文本将移动到编辑器的顶部，如图 *图 4.21* 所示：
- en: '![Figure 4.21 – Moving the text in the editor to the top (start) position'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.21 – 将编辑器中的文本移动到顶部（开始）位置'
- en: '](img/Figure_4.21_B19723.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.21_B19723.jpg)'
- en: Figure 4.21 – Moving the text in the editor to the top (start) position
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 将编辑器中的文本移动到顶部（开始）位置
- en: Buttons inherently rely on events, but events are handled in the code-behind
    file, and we’d like to keep all our logic in `ViewModel`. The answer to that is
    the `EventToCommand` behavior, which we will consider next.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮本质上是依赖于事件的，但事件是在代码后文件中处理的，我们希望将所有逻辑都保留在 `ViewModel` 中。这个问题的答案是 `EventToCommand`
    行为，我们将在下一节中考虑。
- en: Behaviors
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为
- en: The `Editor` control has a number of events. These can be handled by event handlers
    in the code-behind file, but for the reasons already explained (and explained)
    we’d rather not do that. So, here enters behaviors.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor` 控件有许多事件。这些事件可以通过代码后文件中的事件处理程序来处理，但正如之前解释的那样（以及解释），我们宁愿不这样做。因此，行为就出现了。'
- en: Behaviors let you add functionality to your controls without having to create
    subclasses. They *tack on* the behavior. What we want to do now is tack on the
    ability to manage commands in a control (`Editor`) that doesn’t have commands.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 行为允许你在不创建子类的情况下向控件添加功能。它们 *附加* 行为。我们现在想要附加管理控制（`Editor`）中命令的能力，该控制没有命令。
- en: The .NET MAUI Community Toolkit comes with a plethora of behaviors, including
    `EventToCommandBehavior`. This wonderful behavior allows you to transform an event
    (which would be handled in the code-behind file) into a command, which can be
    handled in `ViewModel`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 社区工具包附带了许多行为，包括 `EventToCommandBehavior`。这个美妙的行为允许你将事件（本应在代码后文件中处理）转换为命令，该命令可以在
    `ViewModel` 中处理。
- en: 'The event we want to change in `Editor` is `OnEditorCompleted`, which is raised
    when the user hits the *Enter* key (or, on Windows, the *Tab* key):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要更改 `Editor` 中的事件是 `OnEditorCompleted`，该事件在用户按下 *Enter* 键（或在 Windows 上，按下
    *Tab* 键）时触发：
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The syntax is reminiscent of `GestureRecognizers`, and that is not a coincidence.
    The idea is to enable a control to have various collections and to be able to
    declare those collections in the XAML.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 语法让人联想到 `GestureRecognizers`，这并非巧合。想法是使控件能够拥有各种集合，并能够在 XAML 中声明这些集合。
- en: 'You can, of course, declare the same thing in C#:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在 C# 中声明相同的内容：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As noted earlier, anything you can do in XAML, you can also do in C#.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以在 XAML 中做任何事情，也可以在 C# 中做。
- en: You manage the command (however you create it) in `ViewModel`, just as you would
    any other command. For fun, let’s add a label below the editor and bind it to
    `LostPasswordExcuse`, but only show it until the user presses *Enter*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `ViewModel` 中管理命令（无论你如何创建它），就像你管理任何其他命令一样。为了好玩，让我们在编辑器下方添加一个标签并将其绑定到 `LostPasswordExcuse`，但只有在用户按下
    *Enter* 键时才显示。
- en: '`Login.xaml` now looks like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login.xaml` 现在看起来是这样的：'
- en: '[PRE36]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The Community Toolkit provides us with a much easier way to handle commands
    in `ViewModel`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 社区工具包为我们提供了一个在`ViewModel`中处理命令的更简单的方法。
- en: Popups and dialogs
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出窗口和对话框
- en: 'It is not uncommon to want to alert the user to a condition or change or to
    get back a bit of data from the user with an alert, as shown in *Figure 4**.22*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 想要提醒用户某个条件或变化，或者从用户那里获取一些数据，使用警报，如图 4.22 所示并不罕见：
- en: '![Figure 4.22 – The Alert dialog'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.22 – 警告对话框'
- en: '](img/Figure_4.22_B19723.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B19723.jpg)'
- en: Figure 4.22 – The Alert dialog
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 警告对话框
- en: To keep things clean, remove the Editor and its associated Label from `LoginPage.xaml`
    and remove the constructor and `ICommand` from `ViewModel`. We won’t need them
    in the final version.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持整洁，从`LoginPage.xaml`中删除编辑器和其关联的标签，并从`ViewModel`中删除构造函数和`ICommand`。在最终版本中我们不需要它们。
- en: 'The `DisplayAlert` object can only be called from a page. Later, you’ll see
    how to handle `SubmitCommand` on the Button in `ViewModel` and send a message
    to the page to show the alert. For now, let’s keep things simple, and change the
    Button’s `SubmitCommand` to an event:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayAlert`对象只能从页面调用。稍后，你将看到如何在`ViewModel`中的按钮上处理`SubmitCommand`并发送消息到页面以显示警报。现在，让我们保持简单，将按钮的`SubmitCommand`更改为事件：'
- en: '[PRE37]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The event handler is placed in the code-behind file. Notice the signature of
    the event handler:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器放在代码后文件中。注意事件处理器的签名：
- en: '[PRE38]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The dialog in *Figure 4**.22* displayed data but did not interact with the user
    (except to say to press **OK** to close the dialog). However, we can allow the
    user to make a choice and then record which button they press.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 中的对话框显示了数据，但没有与用户交互（除了告诉用户按**确定**关闭对话框）。然而，我们可以允许用户做出选择，并记录他们按下了哪个按钮。
- en: Event handler signature
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器签名
- en: '`OnSubmit` wants to be `async` because you want to call `DisplayAlert` with
    `await`. With events (and only events) `async` is not an async Task but rather
    an async void. The parameters are always an `Object` type and `EventArgs` or a
    type derived from `EventArgs`. The first is typically named `sender` as this is
    the `View` that raised the event. `EventArgs` is empty and serves as the base
    class for specific types of arguments that some events pass into the event handler.
    Since we won’t be using event handlers in the final code, you don’t have to worry
    too much about this.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSubmit`想要是`async`，因为你想用`await`调用`DisplayAlert`。对于事件（仅限事件）`async`不是异步`Task`而是异步`void`。参数始终是`Object`类型和`EventArgs`或从`EventArgs`派生的类型。第一个通常命名为`sender`，因为这通常是引发事件的`View`。`EventArgs`是空的，作为传递到事件处理器的特定类型参数的基类。由于我们不会在最终代码中使用事件处理器，所以你不必太担心这一点。'
- en: Here we’ve considered only one of the three types of alerts. Let’s look at the
    other two next.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只考虑了三种警报类型中的一种。让我们看看其他两种。
- en: Presenting the user with a choice
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向用户展示选择
- en: While we’re at it, let’s look at the other two types of alerts. One asks the
    user to select one of two choices. We’ll add that to the `CreateAccount` button
    just for now.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理这些时，让我们看看其他两种类型的警报。一种要求用户从两个选择中选择一个。我们暂时将其添加到`CreateAccount`按钮上。
- en: 'Let’s add a `clicked` event to the `OnCreate` button:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`OnCreate`按钮上添加一个`clicked`事件：
- en: '[PRE39]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And, to have a place to show the result, let’s add a label after the closing
    `HorizontalStackLayout` tag:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个地方显示结果，让我们在关闭`HorizontalStackLayout`标签后添加一个标签：
- en: '[PRE40]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The code-behind file has the event handler, which will update our label:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 代码后文件包含事件处理器，它将更新我们的标签：
- en: '[PRE41]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'DisplayA`lert` returns a Boolean, so we call `ToString()` to place it in the
    text field of the `CreateAccount` label. The dialog is shown in *Figure 4**.23*:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayAlert`返回一个布尔值，所以我们调用`ToString()`将其放置在`CreateAccount`标签的文本字段中。对话框显示在图
    4.23 中：'
- en: '![Figure 4.23 – Using dialog to prompt a choice'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.23 – 使用对话框提示选择'
- en: '](img/Figure_4.23_B19723.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B19723.jpg)'
- en: Figure 4.23 – Using dialog to prompt a choice
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 使用对话框提示选择
- en: We can go further and offer the user a series of choices. This is often referred
    to as a *wizard*, as it can be used to walk the user through a series of actions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，向用户提供一系列选择。这通常被称为*向导*，因为它可以用来引导用户完成一系列操作。
- en: ActionSheet
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ActionSheet
- en: 'The third variant of dialog is `ActionSheet`. Here we can put forward a number
    of choices and allow the user to select one. We’ll attach this to an event handler
    for the **Forgot** **Password** button:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框的第三种变体是`ActionSheet`。在这里我们可以提出多个选择，并允许用户选择一个。我们将将其附加到**忘记密码**按钮的事件处理器：
- en: '[PRE42]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s the event handler:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是事件处理器：
- en: '[PRE43]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[1] The first parameter is the title.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 第一个参数是标题。'
- en: '[2] The second parameter is the text for the **Cancel** button.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 第二个参数是 **取消** 按钮的文本。'
- en: '[3] The third parameter is the text for the `null`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 第三个参数是 `null` 的文本。'
- en: 'This is followed by a list of choices. *Figure 4**.24* shows what this looks
    like when it runs:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这后面跟着一个选择列表。*图 4**.24* 展示了运行时的样子：
- en: '![Figure 4.24 – ActionSheet'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.24 – 操作表'
- en: '](img/Figure_4.24_B19723.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B19723.jpg)'
- en: Figure 4.24 – ActionSheet
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – 操作表
- en: Finally, there are times when we want to allow the user to enter free-form data.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时我们希望允许用户输入自由格式数据。
- en: Displaying a prompt
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示提示
- en: 'The final variant of dialog provides a prompt to the user who can fill in a
    value. We’ll need to modify the event handler for `OnCreate` to illustrate this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框的最后一个变体提供了一个提示，用户可以填写值。我们需要修改 `OnCreate` 的事件处理程序来展示这一点：
- en: '[PRE44]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this variant, it is common to use named parameters, as there are many options.
    *Figure 4**.25* shows what this looks like:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变体中，通常使用命名参数，因为有很多选项。*图 4**.25* 展示了它看起来是什么样子：
- en: '![Figure 4.25 – Display prompt'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.25 – 显示提示'
- en: '](img/Figure_4.25_B19723.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B19723.jpg)'
- en: Figure 4.25 – Display prompt
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 显示提示
- en: Toast
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Toast
- en: A very popular alternative to dialog boxes is the *Toast* view. This is a popup
    that comes up from the bottom of the page (much like toast coming up out of a
    toaster), which displays its message and then disappears.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框的一个非常流行的替代方案是 *Toast* 视图。这是一个从页面底部弹出的弹出窗口（就像吐司从烤面包机中弹出一样），它显示其消息然后消失。
- en: 'Let’s modify the handler for `OnCreate` again, this time to display a toast:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次修改 `OnCreate` 的处理程序，这次是为了显示一个吐司：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When creating a Toast, you’ll need `cancellationToken`. Fortunately, you can
    instantiate one from the static `Token` object from the `CancellationTokenSource`
    object [1] and [3].
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建吐司时，您需要 `cancellationToken`。幸运的是，您可以从 `CancellationTokenSource` 对象的静态 `Token`
    对象中实例化一个 [1] 和 [3]。
- en: You set the duration of how long the toast will be shown with the `ToastDuration`
    enumeration [2]. The choices are `Long` and `Short`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ToastDuration` 枚举设置吐司显示的持续时间 [2]。选项有 `Long` 和 `Short`。
- en: '*Figure 4**.26* shows the Toast:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.26* 展示了吐司：'
- en: '![Figure 4.26 – Toast popup'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.26 – Toast 弹出'
- en: '](img/Figure_4.26_B19723.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.26_B19723.jpg)'
- en: Figure 4.26 – Toast popup
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – Toast 弹出
- en: Snackbar
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snackbar
- en: If you need more control over the appearance of your Toast, you can use the
    closely related `Snackbar`. `Snackbar` not only has a plethora of options, it
    but it also has two steps. First is the display of the toast, and second is an
    (optional) action – that is, what do you want to do when the toast is dismissed?
    In this example, we’ll display a dialog.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多控制吐司的外观，可以使用与之密切相关的 `Snackbar`。`Snackbar` 不仅有许多选项，而且它还有两个步骤。首先是显示吐司，其次是（可选的）动作——也就是说，当吐司被取消时，您想做什么？在这个例子中，我们将显示一个对话框。
- en: 'The cornucopia of options means that the event handler is a bit more extensive
    than usual:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 选项的丰富性意味着事件处理程序比通常更广泛：
- en: '[PRE46]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[1] We start by creating `CancellationTokenSource` as we did previously.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 我们首先创建 `CancellationTokenSource`，就像之前做的那样。'
- en: '[2] Create a message to be displayed in the toast.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 创建要显示在吐司中的消息。'
- en: '[3] Add a message that can be clicked on to dismiss the toast.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 添加一个可以点击以取消吐司的消息。'
- en: '[4] Define how long you want the toast to be displayed. You can use any unit
    of time that `TimeSpan` supports (you could have the toast display for days!).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 定义您希望吐司显示多长时间。您可以使用 `TimeSpan` 支持的任何时间单位（吐司可以显示几天！）。'
- en: '[5] The action is what will happen when the toast is dismissed.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] 当吐司被取消时，动作将发生。'
- en: '[6] Here is where we set the characteristics of the toast.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] 这里是我们设置吐司特性的地方。'
- en: '[7] You can set the text color for the toast and for the dismissal text independently
    of each other.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] 您可以独立设置吐司和取消文本的文字颜色。'
- en: '*Figure 4**.27* shows what `Snackbar` looks like before we click on it:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.27* 展示了在点击之前 `Snackbar` 的样子：'
- en: '![Figure 4.27 – Snackbar'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.27 – Snackbar'
- en: '](img/Figure_4.27_B19723.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.27_B19723.jpg)'
- en: Figure 4.27 – Snackbar
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27 – Snackbar
- en: 'After the user clicks on the `SnackBar` disappears, and the action is fired;
    in this case, the dialog box appears, as shown in *Figure 4**.28*:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 用户点击 `SnackBar` 后消失，并触发动作；在这种情况下，对话框出现，如图 *图 4**.28* 所示：
- en: '![Figure 4.28 – The action after the snackbar is dismissed'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.28 –Snackbar 取消后的动作'
- en: '](img/Figure_4.28_B19723.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.28_B19723.jpg)'
- en: Figure 4.28 – The action after the snackbar is dismissed
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 –Snackbar 取消后的动作
- en: .NET MAUI does not have a horizontal line control, but we can put the `BoxView`
    control to work as an excellent substitute.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 没有水平线控件，但我们可以将 `BoxView` 控件用作一个很好的替代品。
- en: BoxView
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BoxView
- en: 'One of the simplest controls is `BoxView`, which simply draws a box on the
    page:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的控件之一是 `BoxView`，它只是在页面上绘制一个框：
- en: '[PRE47]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Figure 4**.29* shows the `BoxView` control:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.29* 显示了 `BoxView` 控件：'
- en: '![Figure 4.29 – A simple BoxView control'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.29 – 简单的 BoxView 控件'
- en: '](img/Figure_4.29_B19723.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.29_B19723.jpg)'
- en: Figure 4.29 – A simple BoxView control
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – 简单的 BoxView 控件
- en: 'What good is this you ask? If you make the box height very small and the width
    very large, you get a nice line to divide your page. If we put the following after
    the **Password** entry, but before the buttons, we can neatly divide the page:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问这有什么好处？如果您将框的高度设置得非常小，宽度设置得非常大，您将得到一条很好的线条来分割您的页面。如果我们把以下内容放在 **Password**
    输入之后，但在按钮之前，我们可以整洁地分割页面：
- en: '[PRE48]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Figure 4**.30* shows what this looks like:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.30* 显示了这看起来是什么样子：'
- en: '![Figure 4.30 – Using the BoxView control to draw a line'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.30 – 使用 BoxView 控件绘制线条'
- en: '](img/Figure_4.30_B19723.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.30_B19723.jpg)'
- en: Figure 4.30 – Using the BoxView control to draw a line
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – 使用 BoxView 控件绘制线条
- en: Many UI experts like to frame controls with a border, potentially with a *drop
    shadow*. To do this you’ll want to use a `Frame` control.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 UI 专家喜欢用边框来框定控件，可能还会使用 *阴影*。为此，您需要使用 `Frame` 控件。
- en: Frame
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Frame
- en: 'If you wish to create a border around another control, you’ll want to use a
    `Frame` control. `Frame` lets you define the color of the border, `CornerRadius`,
    and whether or not the frame has a shadow. Let’s create a frame around the `Password`
    entry field:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在另一个控件周围创建边框，您将需要使用 `Frame` 控件。`Frame` 允许您定义边框的颜色、`CornerRadius` 以及边框是否有阴影。让我们为
    `Password` 输入字段创建一个边框：
- en: '[PRE49]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Figure 4**.31* shows the result:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.31* 显示了结果：'
- en: '![Figure 4.31 – Putting a frame around the Password entry'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.31 – 在密码输入周围添加边框'
- en: '](img/Figure_4.31_B19723.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.31_B19723.jpg)'
- en: Figure 4.31 – Putting a frame around the Password entry
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – 在密码输入周围添加边框
- en: You control the color of the `BoxView` control and a number of other controls
    by painting the color using Brushes.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用画笔来控制 `BoxView` 控件和其他许多控件的颜色。
- en: Brushes
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Brushes
- en: You can fill in the color of any number of controls using a brush. The easiest
    place to see this in action is with a `BoxView` control, or with `Frame`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用画笔为任意数量的控件填充颜色。最容易看到这一功能的地方是使用 `BoxView` 控件，或者使用 `Frame`。
- en: There are three types of brushes, **Solid**, **Linear Gradient**, and **Radial
    Gradient**. Let’s explore them in a bit more detail.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的画笔，**实心**、**线性渐变**和**径向渐变**。让我们更详细地探讨它们。
- en: The Solid brush
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实心画笔
- en: The Solid Brush is used when you want to fill a control with a single color.
    Typically, the solid brush is implicit in the `BackgroundColor` property of the
    control, as we saw above when drawing the `BoxView` control.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 实心画笔用于您想用一个单一的颜色填充控件时。通常，实心画笔是隐含在控件的 `BackgroundColor` 属性中的，就像我们在绘制 `BoxView`
    控件时上面看到的。
- en: LinearGradientBrush
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinearGradientBrush
- en: '`LinearGradientBrush` paints an area with a blend of two or more colors along
    a line called the gradient axis. You specify a start point and an endpoint, and
    then you specify stop points (where the colors switch) along the way.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearGradientBrush` 在称为渐变轴的线上绘制一个区域，其中包含两种或多种颜色的混合。您指定一个起点和一个终点，然后指定沿途的停止点（颜色切换的地方）。'
- en: The start and endpoints are relative to the borders of the painted area, with
    `0,0` being the upper left corner (and the default start) and `1,1` being the
    lower right (and the default stop).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 起点和终点相对于绘制区域的边界，其中 `0,0` 是左上角（也是默认起点）和 `1,1` 是右下角（也是默认终点）。
- en: 'To illustrate this, I’ll move the frame from around the password to a space
    of its own:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我将把框架从密码周围移动到一个单独的空间：
- en: '[PRE50]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[1] Here we create a `Background` property on `Frame`.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 在这里，我们在 `Frame` 上创建了一个 `Background` 属性。'
- en: '[2] Within that, create `LinearGradientBrush`.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 在其中创建 `LinearGradientBrush`。'
- en: Note that we specify `EndPoint` but not `StartPoint`, as we’re using the default
    `StartPoint` of `0,0`. By going from `0,0` to `1,0`, we create a horizontal gradient.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们指定了 `EndPoint` 但没有指定 `StartPoint`，因为我们使用了默认的 `StartPoint` `0,0`。通过从 `0,0`
    到 `1,0`，我们创建了一个水平渐变。
- en: '[3] We have set the first `GradientStop` at `0.2`.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 我们将第一个 `GradientStop` 设置为 `0.2`。'
- en: '[4] We set the second `GradientStop` at `0.1`, giving us about twice as much
    yellow as red.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 我们将第二个 `GradientStop` 设置为 `0.1`，这使得黄色的数量大约是红色的两倍。'
- en: '*Figure 4**.32* shows the result:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.32* 显示了结果：'
- en: '![Figure 4.32 – LinearGradientBrush'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.32 – LinearGradientBrush'
- en: '](img/Figure_4.32_B19723.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.32_B19723.jpg)'
- en: Figure 4.32 – LinearGradientBrush
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – LinearGradientBrush
- en: Gradient stops
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 渐变停止点
- en: Gradient stops indicate the position along the gradient vector, ranging from
    `0` to `1`. In short, the first gradient shown here is two-tenths of the way,
    and the second is one-tenth of the way along the gradient vector.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 渐变停止点表示沿渐变向量的位置，范围从`0`到`1`。简而言之，这里显示的第一个渐变是渐变向量的二十分之一，第二个是十分之一。
- en: 'Gradients come in two flavors: linear, as shown in the previous example, and
    radial, as explained next.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 渐变有两种类型：线性，如前一个示例所示，和径向，如以下所述。
- en: RadialGradientBrush
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RadialGradientBrush
- en: 'If we do the same thing with `RadialGradientBrush`, our coordinates start at
    the center, which defaults to `0.5,0.5`, and we supply the radius as a double.
    The default value is `0.5`. Let’s reproduce `LinearGradient` shown previously
    using `RadialGradientBrush`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`RadialGradientBrush`做同样的事情，我们的坐标从中心开始，默认为`0.5,0.5`，我们提供一个半径作为双精度值。默认值是`0.5`。让我们使用`RadialGradientBrush`重现之前显示的`LinearGradient`：
- en: '[PRE51]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that we did not specify the center or the radius, so we are using the
    default values. *Figure 4**.33* illustrates the result:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有指定中心或半径，因此我们使用默认值。*图 4**.33* 展示了结果：
- en: '![Figure 4.33 – RadialGradientBrush'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.33 – RadialGradientBrush'
- en: '](img/Figure_4.33_B19723.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.33_B19723.jpg)'
- en: Figure 4.33 – RadialGradientBrush
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33 – RadialGradientBrush
- en: With this, we’ve come to the end of a very important chapter.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经到达了非常重要的一章的结尾。
- en: Summary
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This has been a long chapter, and we’ve covered many things, but if you break
    it down, the real topics were as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章很长的内容，我们涵盖了众多内容，但如果您将其分解，真正的主题如下：
- en: MVVM
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM
- en: '`DataBinding`'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据绑定`'
- en: Controls
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件
- en: Of course, controls are a pretty big topic, and we’re not done. In the next
    chapter, we’ll talk about layouts, but we’ll also discuss how you style controls,
    animate controls, and more.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，控件是一个相当大的主题，我们还没有完成。在下一章中，我们将讨论布局，但我们也会讨论如何设置控件样式、动画控件等。
- en: The 90% you use 90% of the time
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 您90%的时间都在使用90%的功能
- en: I did not try to cover every control, nor did I cover all the properties of
    the controls we did see. That would have turned this book into an encyclopedia,
    and my goal is to show you the 90% of .NET MAUI that you use day in and day out.
    If you find you need a different property or a different control, well, that’s
    what the (excellent) documentation is for. Just go to [https://bit.ly/Liberty-Maui](https://bit.ly/Liberty-Maui),
    or ask Google or your local AI agent, and you’ll be able to find every nook and
    cranny.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我并没有试图涵盖每个控件，也没有涵盖我们看到的控件的所有属性。那样会把这本书变成一本百科全书，我的目标是向您展示您日常使用的90%的.NET MAUI。如果您发现您需要不同的属性或不同的控件，那么，这正是（出色的）文档的作用。只需访问[https://bit.ly/Liberty-Maui](https://bit.ly/Liberty-Maui)，或者询问谷歌或您当地的AI代理，您就能找到每一个角落和缝隙。
- en: 'The main takeaways from this chapter are:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要收获是：
- en: MVVM is the essential architecture for .NET MAUI. In MVVM, `Model` is the data
    (we’ve not seen this at work yet), `View` is the UI, and `ViewModel` is where
    all the logic is (or should be). We broke MVVM for much of this chapter and put
    the logic in the code-behind file, but that was only as a convenience and because
    we haven’t, yet, talked about getting data into and out of pages.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM是.NET MAUI的基本架构。在MVVM中，`Model`是数据（我们尚未看到它的工作情况），`View`是UI，`ViewModel`是所有逻辑的地方（或应该是）。我们在本章的大部分内容中打破了MVVM，并将逻辑放在了代码-behind文件中，但这只是为了方便，因为我们还没有讨论如何将数据放入和取出页面。
- en: '`DataBinding` is how you connect `ViewModel` to `View`. Rather than copying
    data from a property in `ViewModel` to a field in `View`, you bind that control
    to the property, and when the property’s value changes, the control is automagically
    updated.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据绑定`是您将`ViewModel`连接到`View`的方式。而不是将`ViewModel`中的属性数据复制到`View`的字段中，您将这个控件绑定到属性上，当属性的值发生变化时，控件会自动更新。'
- en: 'There is a boatload of controls available to you and each is displayed as a
    native control on all of the supported platforms: iOS, Android, Windows, and macOS.
    The fact that they are emitted as native controls is tremendously important. Not
    only will they look right, but they will also be wicked fast.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有大量的控件可供您使用，并且每个控件都在所有支持的平台上以原生控件的形式显示：iOS、Android、Windows 和 macOS。它们被作为原生控件发出这一点非常重要。这不仅会使它们看起来正确，而且它们也会非常快。
- en: Anything you can declare in XAML you can declare in C#.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在XAML中声明的任何内容都可以在C#中声明。
- en: You can take control over the appearance of each control so that they look the
    same on every platform – anything from having the same color all the way to looking
    identical. That is entirely up to you. It only depends on how many properties
    you set on each control.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以控制每个控件的外观，使它们在每一个平台上看起来都一样——从颜色相同到看起来完全相同。这完全取决于你。这取决于你在每个控件上设置了多少属性。
- en: Quiz
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: What are the advantages of MVVM?
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVVM 的优点是什么？
- en: How do you create the connection between the `View` class and `ViewModel` so
    that data binding will work?
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建 `View` 类和 `ViewModel` 之间的连接，以便数据绑定能够工作？
- en: What are two controls for entering data into a form?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些控件可以用于在表单中输入数据？
- en: What is the most common control for displaying data?
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最常见的用于显示数据的控件是什么？
- en: What is a `SnackBar`?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `SnackBar`？
- en: You try it
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你试试看
- en: Build a page that acts like a form
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个像表单一样的页面
- en: Give it some prompts, entry fields, and buttons to accept the entry
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些提示、输入字段和按钮以接受输入
- en: When the user fills in the field and clicks on the button, display a confirmation
    toast and show their entry in a label
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户填写字段并点击按钮时，显示一个确认吐司并在标签中显示他们的输入
- en: Add in an image, and for extra credit, enable that image to be clicked on and,
    when clicked on, display a congratulatory dialog box and/or toast (or if you are
    ambitious, use `SnackBar`!)
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一张图片，并且作为额外加分项，使图片可点击，点击时显示一个祝贺对话框和/或吐司（或者如果你有雄心，可以使用 `SnackBar`！）
- en: Feel free to mix in additional controls
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随意混合使用额外的控件
