- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Background Functions in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start working with cloud computing, especially while working with **Platform
    as a Service** (**PaaS**), one of the challenges you may encounter is how to enable
    background work if your solution is based on instances that require a request
    before processing. One of the answers to this problem is the use of serverless
    to process this background job. In Azure, you will find Azure Functions triggers
    that can help you with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss three of them: the timer trigger, Blob storage
    trigger, and queue storage trigger. It is important to mention that we covered
    their basics in [*Chapter 1*](Chapter_1.xhtml#_idTextAnchor022)*, Demystifying
    Serverless Applications*, but we will start to implement them now.'
  prefs: []
  type: TYPE_NORMAL
- en: Together with their implementation, we will present an alternative to the publication
    of Azure Functions inside Visual Studio. We will also check how to monitor these
    functions. Understanding the advantages and disadvantages and when these functions
    are a good approach to be used will be discussed in the chapter. We will also
    see them working using the car-sharing example as a basis for understanding the
    purpose of each trigger better. Let’s go!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the Visual Studio 2022 free *Community edition* or Visual
    Studio Code. You will also need an Azure account to create the sample environment.
    You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  prefs: []
  type: TYPE_NORMAL
- en: Timer trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is not uncommon to need to process a task from time to time, at a specific
    moment of the day. A timer trigger will certainly help you with this. This function
    is based on the `NCRONTAB` expression, which is like a `CRON` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{second} {minute} {hour} {day} {month} {day-of-week}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you consider this expression, you will be able to schedule different moments
    to trigger the function. Let’s check the following table to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Second** | **Minute** | **Hour** | **Day** | **Month** | **Day of the Week**
    | **Result** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| * | * | * | * | * | * | * * * * * * | Every second |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | * | * | * | * | * | 0 * * * * * | Every minute |'
  prefs: []
  type: TYPE_TB
- en: '| */5 | * | * | * | * | * | */5 * * * * * | Every five seconds |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | * | * | 1-5 | 0 0 1 * * 1-5 | At 1:00 AM, from Monday to Friday
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5,10,20 | * | * | * | * | * | 5,10,20 * * * * * | At 5, 10, and 20 seconds
    past the minute |'
  prefs: []
  type: TYPE_TB
- en: There are some important tips related to the `NCRONTAB` expression. First, you
    may consider days of the week from Sunday (`0`) to Saturday (`6`). The `*` operator
    represents all values at the moment defined, while `-` is the range operator.
    If you want to express an interval, you may use the `/` operator, and if you want
    to define a set of values, the `,` operator must be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a timer trigger and the way you define
    its schedule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are some websites where you can interpret the `NCRONTAB` expression you
    have designed. You can check this out at https://crontab.cronhub.io/.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the result of the preceding timer trigger code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Timer trigger function in execution](img/B31916_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Timer trigger function in execution'
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility enables you to define a solid structure of jobs to run your
    microservices. On the other hand, if you want to debug a specific function, you
    may use the `RunOnStartup` parameter set to `true`. It is important to mention,
    though, that this parameter must not be used in production
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a possibility to manually trigger non-HTTP functions. Please check
    this link to do so: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http](https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http).'
  prefs: []
  type: TYPE_NORMAL
- en: Now you understand how timer trigger functions work, let’s check a way you can
    publish them using Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are developing your Azure functions in Visual Studio, it is useful to
    know that the IDE enables you to publish your code to Azure in small steps. Let’s
    check how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to right-click the project you want to publish. As soon as
    you do this, you will find the **Publish…** action to start the process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Publishing an Azure function project](img/B31916_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Publishing an Azure function project'
  prefs: []
  type: TYPE_NORMAL
- en: Once you decide to publish, you will be prompted to decide where to publish
    the function. Besides Azure, you might want to publish the function in a Docker
    container registry or a folder. You may also want to use a pre-made profile, so
    there is also an option to import the profile. For this demo, the **Azure** option
    will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Publishing on Azure](img/B31916_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Publishing on Azure'
  prefs: []
  type: TYPE_NORMAL
- en: After the selection of **Azure**, you need to decide where in Azure you will
    have your function running. As we saw in [*Chapter 1*](Chapter_1.xhtml#_idTextAnchor022)*,
    Demystifying Serverless Applications*, Azure functions can run in different operating
    systems and different container solutions. For this demo, we will select the Windows
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Selecting Azure Function App for Windows](img/B31916_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Selecting Azure Function App for Windows'
  prefs: []
  type: TYPE_NORMAL
- en: After connecting Visual Studio to your Azure account, all the function instances
    available for deployment will be presented to you. However, if you don’t have
    any instances, you will also be given the opportunity to create a new instance,
    by selecting the **Create new** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Creating the Azure Function App on the Visual Studio interface](img/B31916_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Creating the Azure Function App on the Visual Studio interface'
  prefs: []
  type: TYPE_NORMAL
- en: The creation will take a few minutes, but then your Azure function can be published
    on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Azure Function App ready](img/B31916_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Azure Function App ready'
  prefs: []
  type: TYPE_NORMAL
- en: The current wizard available in Visual Studio is very useful. It not only helps
    you publish in a single step but also creates a YML file for you, to be used together
    with GitHub Actions. For this demo, we will use the basic option that generates
    a `.pubxml` file, but you may consider GitHub Actions as the best opportunity
    for real-life scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Methods available for publishing](img/B31916_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Methods available for publishing'
  prefs: []
  type: TYPE_NORMAL
- en: Once you finish the wizard, you will have the publishing profile ready to start
    publishing the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Publishing profiler](img/B31916_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Publishing profiler'
  prefs: []
  type: TYPE_NORMAL
- en: By clicking the **Publish** button, the process will start running and, after
    a few moments, your Azure Function App will be published.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Function App published](img/B31916_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Function App published'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that you will need to do this complete process only
    once. After that, the new deployments needed will be a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring your functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process for deploying functions presented in the last section is not exclusive
    to timer trigger functions. The same happens when it comes to monitoring your
    functions. In Azure, there are some alternative ways to check whether your Azure
    function is running properly. Let’s explore them.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to monitor whether a function is running properly is by checking
    the number of invocations made by it. The **Invocations** tab is available in
    the Function App, and it will give you basic details about the execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Function invocations](img/B31916_05_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Function invocations'
  prefs: []
  type: TYPE_NORMAL
- en: However, you may want to obtain detailed information about each execution. In
    this case, the best option to get this kind of information is by accessing the
    logs retained by Azure Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Azure Monitor logs](img/B31916_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Azure Monitor logs'
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Monitor logs will result in a cost increase. Please check the best
    alternative for storing logs at [https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs](https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs).
  prefs: []
  type: TYPE_NORMAL
- en: The logs stored by Azure Monitor will also give you two other views. The Application
    Insights **Performance** view helps you analyze performance and errors that may
    happen in the Azure functions you develop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Application Insights Performance view](img/B31916_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Application Insights Performance view'
  prefs: []
  type: TYPE_NORMAL
- en: There is also a **Live metrics** view of the function running, which may be
    useful for debugging or understanding behaviors in production.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Application Insights Live metrics view](img/B31916_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Application Insights Live metrics view'
  prefs: []
  type: TYPE_NORMAL
- en: These options make Azure Functions an excellent alternative for processing your
    background work, as the observability provided is very good.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages, disadvantages, and when to use Azure timer triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw before, Azure timer triggers provide a great way to execute functions
    at regular intervals without the need for manual intervention. Their simplicity
    in setup and configuration helps you create functions that will run regularly,
    such as data synchronization, cleanup operations, and scheduled reports.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the function will run exactly when you schedule it, if there
    is no job to be done at that moment, this execution will result in resource wastage,
    which basically means spending money unnecessarily. So, you must properly define
    the execution of the timer trigger function.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding information, scheduled actions that cannot depend on
    human manual intervention, such as backups, routine maintenance tasks, and periodic
    data processing, are great use cases for this kind of function. Even though it
    is important to define a way to monitor and report these executions, you can still
    make the most of this option.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing timer trigger example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The car-sharing solution is an event-driven application. This means that there
    is no need for a timer trigger for this application when it comes to its basic
    flow of work. However, let’s imagine a routine for processing billing. Considering
    the business rules of this company, there is no way to process bills on Sundays,
    and considering the cash flow on the other days, the billing can be processed
    once an hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this scenario, a timer trigger function can be a great choice to solve
    this problem, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that no matter whether you have billing to process or not, the execution
    of the function will happen every single hour, between 8:00 AM and 5:59 PM, from
    Monday through Saturday. It is important to mention that Azure Functions will
    respect UTC time, so you should consider your location when defining the correct
    `CRON` expression to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Blob trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Blob Storage is a service provided by Microsoft Azure for storing large
    amounts of unstructured data, such as images, videos, logs, and backups. It is
    optimized for storing binary data in a highly scalable and cost-effective way.
    **Blob** stands for **Binary Large Object**, highlighting its ability to handle
    massive volumes of data efficiently, making it an ideal solution for applications
    that require durable, scalable storage.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about this service is that it is highly scalable, secure, and
    accessible from anywhere in the world via HTTP or HTTPS. Also, it enables integration
    with other Azure services, such as Azure Functions. This connector enables a variety
    of possible solutions for automating processes since it is possible to execute
    a function for each change made in a specific blob storage.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this book is not to go further into Blob Storage options, but it
    is useful to know that the service provides different access tiers, such as hot,
    cool, and archive, which vary according to access needs, each with its own pricing.
  prefs: []
  type: TYPE_NORMAL
- en: When you start creating a Blob storage trigger function, one of the things that
    you will be asked to define is where the storage will run. For debugging, you
    will have the possibility to use **Storage Azurite emulator**, which is a local
    emulator for Azure Storage. Azurite is available with Visual Studio. Based on
    your edition of Vision Studio, it will be placed in a specific folder. After you
    find the executable, you may run it using Admin access.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Azurite execution](img/B31916_05_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Azurite execution'
  prefs: []
  type: TYPE_NORMAL
- en: Another important tool to be used while creating Blob storage trigger functions
    is Microsoft Azure Storage Explorer. With these two tools, the process of creating
    Blob storage trigger functions will be very easy. The following figure shows how
    Visual Studio enables you to select Azurite as the default emulator for your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Connecting a Blob storage trigger to Azure](img/B31916_05_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Connecting a Blob storage trigger to Azure'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages, disadvantages, and when to use Blob storage triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to advantages regarding the usage of Blob storage triggers, the
    possibility of handling large volumes of data efficiently can surely be mentioned.
    Besides that, the possibility to scale the processing no matter the number of
    incoming triggers is also a good reason why you should consider this kind of trigger
    to process data.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, pricing can be a problem since, in some cases, the pricing
    model is based on the number of executions and the amount of data processed, so
    do not forget to analyze the best way to allocate this kind of Azure function.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to mention that, depending on the app plan you have defined
    for the Azure function, you may experience some delay between the uploading or
    updating of the file and the function processing. To avoid it, you may consider
    an App Service plan with Always On enabled, although this will obviously increase
    the cost of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, it is important to mention that the initial Blob storage trigger
    function implementation was based on pooling. Pooling refers to a periodic scan
    of the entire container, typically processing up to 10,000 blobs per batch. In
    this approach, each file has up to five retry attempts by default. If all retries
    fail, the function creates a poison message and moves it to the `webjobs-blobtrigger-poison`
    queue. To avoid such scenarios and improve reliability, you can implement a Blob
    storage trigger using Event Grid instead. We will cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this information, you can use a Blob storage trigger in applications
    where you have software requirements such as image processing, data analysis,
    and real-time or batch processing. In this kind of application, you generally
    need to react quickly and automatically to new or updated blobs. In these cases,
    the scalability and adaptability of Azure Functions will help you meet your demands.
  prefs: []
  type: TYPE_NORMAL
- en: Blob trigger implementation using Event Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind using Event Grid to implement Blob trigger events is to reduce
    latency. Besides, if you decide to define your functions using the Flex Consumption
    plan, this is the only option you will have.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, while creating the function, select the **Blob Trigger (using Event
    Grid)** option. With this option, Visual Studio will create a different code for
    the Azure function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Creating a Blob trigger function using Event Grid](img/B31916_05_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Creating a Blob trigger function using Event Grid'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that this function will run better on Azure than
    locally. For this, you need to create a **general-purpose v2** storage account,
    which is mandatory for the event subscription.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: Review of the creation of the storage account](img/B31916_05_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Review of the creation of the storage account'
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that we have the prerequisite for Azure Storage, the function
    app for running this kind of trigger should consider using the Flex Consumption
    plan, as we can see in the following figure. The advantage of this Consumption
    plan, according to Microsoft, is that it reduces cold starts with always-ready
    instances, supports VNets, and scales automatically, even in high load periods.
    On the other hand, at the time of writing this book, this option was not available
    in all regions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Flex Consumption plan](img/B31916_05_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Flex Consumption plan'
  prefs: []
  type: TYPE_NORMAL
- en: After the creation of the Azure function app, you may use the steps presented
    previously to publish the function. The name used for the function app in this
    example was `flexfunction`. It is worth noting that Flex Consumption plans are
    for Linux-based operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the published function. Notice that the `Connection`
    parameter is `"ConnectionStringName"` in this example. Also, notice that the name
    of the function is `SampleFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will need this information to set the Azure function. `"ConnectionStringName"`
    needs to be defined in the settings of the function app as an environment variable,
    as you can see in the following figure. The content of this configuration is the
    connection string of the created storage account.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Defining the connection between the function app and the storage
    account](img/B31916_05_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Defining the connection between the function app and the storage
    account'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you will have all the information needed to define the event that
    will be triggered in the function app. Notice that the event happens in the storage
    account and Event Grid triggers the function. To do this, a webhook is created.
    The definition of the URL of the webhook can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Template** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Base function app URL | https://<FUNCTION_APP_NAME>.azurewebsites.net |'
  prefs: []
  type: TYPE_TB
- en: '| Blob-specific path | /runtime/webhooks/blobs |'
  prefs: []
  type: TYPE_TB
- en: '| Function query string | ?functionName=Host.Functions.<FUNCTION_NAME> |'
  prefs: []
  type: TYPE_TB
- en: '| Blob extension access key | &code=<BLOB_EXTENSION_KEY> |'
  prefs: []
  type: TYPE_TB
- en: The blob extension access key can be found in the **App Keys** section of the
    function app. There is a specific system key for `blobs_extension`. Once you have
    the key, you can use it to create a new event in Azure Storage, as you can see
    in the next figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Subscribing to an event in Blob Storage](img/B31916_05_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Subscribing to an event in Blob Storage'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that your Azure subscription may not have enabled
    the resource provider for Event Grid and an error may occur with this disabled
    while creating the subscription. To enable the resource provider, you need to
    go to your subscription account and register it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Registering the Microsoft.EventGrid resource provider](img/B31916_05_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: Registering the Microsoft.EventGrid resource provider'
  prefs: []
  type: TYPE_NORMAL
- en: After this configuration, by simply uploading files to the defined container,
    the function will be triggered for each file uploaded, in a low-latency model.
    You can monitor each trigger using the function’s **Invocations** panel. Notice,
    in the figure, that the function was triggered four times in the same second in
    the last calls, showing the capacity of the trigger function to handle a greater
    number of files at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: Monitoring triggers](img/B31916_05_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Monitoring triggers'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that this example requires different components that may
    create additional costs. So, you must pay attention not to let this demo run in
    your Azure account if you are just trying this option. On the other hand, this
    will decrease the latency between the arrival of a file and its processing, so
    you may consider it a good approach for real-life applications.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing Blob storage trigger example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering the car-sharing use case that we are presenting in this book, it
    is worth mentioning that one of the services that may be included in this solution
    is to analyze the driver’s license. To do so, in the frontend application, there
    will be a user interface to upload this important document to the business logic
    of the application. However, as this file is important, storing information like
    this needs to be well designed. A good option is to only extract the information
    needed with the uploaded image and then create a hash of this information, so
    you can delete the file uploaded by the user.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, you may create a function dedicated to processing driver’s license
    photos. Using a Blob storage trigger to do so may be a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to mention that this example needs to update the `Program.cs`
    file. Instead of directly using the `FunctionsApplication` class, we will use
    `HostBuilder` here, configuring the Azure Functions application with the `ConfigureFunctionsWebApplication`
    method. It is worth mentioning that in Azure Functions with .NET 8, `ConfigureFunctionsWebApplication()`
    enables ASP.NET Core integration, while the default `ConfigureFunctionsWorkerDefaults()`
    is used for the isolated worker model, offering greater flexibility and control
    over .NET versions and dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddUserSecrets` method adds user secrets to the configuration, which is
    useful for storing sensitive information such as API keys or connection strings.
    In this case, we are storing the connection with Blob Storage. The `ProcessDriversLicensePhoto`
    type is used to identify the assembly containing the user secrets. The `optional:
    true` parameter means that the application will not fail if the user secrets file
    is not found, and `reloadOnChange: false` indicates that the configuration will
    not automatically reload if the user secrets file changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have defined `Program.cs`, you may create the Azure function to process
    Blob Storage. The function itself is quite simple to define, as you can see in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `BlobTrigger` attribute defines where in Blob Storage the files will be
    uploaded, in this case, in the `drivers-license` folder, where `{name}` is a placeholder
    for the blob’s name, which will be passed as a string in the `name` parameter.
    The stream of the file will be obtained by the `myBlob` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Queue storage trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principle of a queue is fairly well known since this is a data structure
    where you want to control the data so that first in will be first out. When we
    talk about the queue storage trigger in Azure Functions, we have the possibility
    to manage queues asynchronously and totally decoupled, making its usage extremely
    powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The great power that we have in this scenario is the ability to handle large
    amounts of messages efficiently. Azure Functions has the capability to scale automatically,
    and it guarantees that each task will be processed properly with reliability and
    fault tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: Considering this approach, it is worth noting that serverless applications will
    always focus the development on what is essentially needed – the business logic
    to make that service work. That is why serverless applications are a great way
    to implement microservices since the necessity of handling infrastructure will
    be less needed.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages, disadvantages, and when to use queue storage triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a use case where you must control a queue of data, a queue storage
    trigger function will be one of the good options to select. The fact that this
    approach can handle large volumes of messages efficiently is truly an advantage.
    In this case, you only need to focus on the business logic for the service that
    will be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: However, the pricing model is based on the number of executions and the amount
    of data processed, so you must be aware of it and not be surprised by the costs
    related to the solution. It is also worth noting that high load or transient errors
    may occur and, as a developer, you must implement retries and error-handling mechanisms
    to ensure your solution is well implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Queue storage triggers may be a good solution when you must deliver a reliable
    and efficient solution for processing queued tasks, considering all we have discussed.
    For instance, if you need order processing, background job scheduling, or event
    event-driven notifications, this kind of solution can be a good approach. Now,
    let’s check a scenario in the car-sharing example where a queue storage trigger
    could be a good solution.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing queue storage trigger example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering the car-sharing use case, one of the services that may be created
    using a queue storage trigger is the `My_Best_Matches` microservice. According
    to the car-sharing example specification described in [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038),
    *Demystifying Microservices Applications*, all routes’ changes are sent to both
    the `My_Best_Matches` and `Route-Choosing` microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering this scenario, let’s suppose that the routes’ changes are queued
    as JSON components in an Azure Storage queue. This JSON will indicate that there
    is a new match to be processed by `My_Best_Matches` microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once you have this code running, using the local storage emulator, you can place
    a message in the `new-match` queue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Placing a message in the queue](img/B31916_05_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Placing a message in the queue'
  prefs: []
  type: TYPE_NORMAL
- en: The message placed in the queue will be automatically processed by the function
    and then deleted from the storage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Azure function output](img/B31916_05_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Azure function output'
  prefs: []
  type: TYPE_NORMAL
- en: Considering this scenario, this message could be used to send an email to both
    the car holder and car seeker, indicating that there is a new match for them and
    that they can interact with the system to define whether or not they will accept
    the proposed route.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed the implementation of three important Azure trigger functions
    to implement background services – timer triggers, Blob storage triggers, and
    queue storage triggers. Tasks such as processing routines, images, data, and orders
    can be easily implemented using this serverless technology.
  prefs: []
  type: TYPE_NORMAL
- en: While presenting these kinds of functions, the chapter explained how to publish
    and monitor functions. It also presented a more efficient way to implement blob
    trigger functions, using Event Grid as a basis, and reducing the latency between
    the file upload and the start of the processing.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also explained how Azure Functions can be a great approach to implementing
    microservices. To do so, it presented three examples related to the car-sharing
    use case where the usage of this kind of solution will let developers focus on
    what really matters when it comes to software development – coding the business
    logic of the solution that is being developed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the next chapter, which will discuss how to enable IoT
    solutions using Azure Functions as a basis.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the timer trigger function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The timer trigger function is designed to execute code on a schedule, defined
    using `NCRONTAB` expressions. It allows developers to run background jobs at regular
    intervals without requiring manual initiation or HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for scenarios such as data synchronization, cleanup operations,
    report generation, and periodic billing. It helps automate repetitive tasks, especially
    those that shouldn’t depend on human interaction to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the blob trigger function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The blob trigger function responds automatically whenever a file is added or
    modified in a specific Azure Blob Storage container. It enables event-driven processing
    for unstructured data such as images, logs, or documents.
  prefs: []
  type: TYPE_NORMAL
- en: This trigger is ideal for automating workflows involving data ingestion, file
    processing, image analysis, or document transformation. It supports scalability
    and integration with Event Grid to reduce latency in high-performance scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the queue trigger function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The queue trigger function executes when a new message is added to Azure Queue
    Storage. It enables the asynchronous processing of tasks, decoupling producers
    from consumers in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: This approach ensures reliable and scalable handling of queued tasks such as
    background processing, order handling, or notifications, allowing developers to
    focus on business logic while Azure Functions handles infrastructure concerns.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the blob and queue trigger functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The blob trigger function reacts to file changes in Azure Blob Storage, typically
    processing binary or unstructured data. It is event-driven and suited for scenarios
    such as file uploads, media processing, or document handling.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the queue trigger function is designed to process text-based messages
    from Azure Queue Storage. It is better suited for managing workflows, job scheduling,
    and message-driven integrations, where you need explicit control over task order
    and execution.
  prefs: []
  type: TYPE_NORMAL
- en: How can we reduce the latency between the file upload and the start of processing
    in a blob trigger function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To reduce latency in a blob trigger function, it’s recommended to use Event
    Grid-based blob triggers instead of polling-based triggers. Event Grid enables
    near-real-time processing by pushing events as they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, using the Flex Consumption plan or an App Service plan with Always
    On enabled helps minimize cold start times. However, these approaches may increase
    cost, so they should be evaluated based on application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: List different ways to monitor an Azure function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure functions can be monitored using several built-in tools. The **Invocation**
    tab in the Azure portal provides basic metrics, such as the number of executions
    and execution status.
  prefs: []
  type: TYPE_NORMAL
- en: For deeper insights, Azure Monitor logs and Application Insights (**Performance**
    and **Live Metrics** views) offer advanced telemetry, performance tracking, and
    real-time diagnostics. These tools help identify errors, analyze trends, and debug
    runtime behavior effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions timer trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azurite: [https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Azure Storage Explorer: [https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer](https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions blob trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions blob trigger with Event-Grid: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Queue storage trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure storage considerations: [https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations](https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
