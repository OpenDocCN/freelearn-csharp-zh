- en: Virtual Reality and Extra Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving screenshots from the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading player data – using static properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading player data – using PlayerPrefs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading game data from a text file map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI Slider to change game quality settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing slow motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gizmo to show the currently selected object in the scene panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editor snap-to grid drawn by Gizmo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a VR project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding 360-degree videos to a VR project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing VR content inside a VR environment – the XR Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are too many features in Unity 2018 to all be covered in a single book.
    In this chapter, we will present a set of recipes illustrating VR game development
    in Unity, plus a range of additional Unity features that we wanted to include.
  prefs: []
  type: TYPE_NORMAL
- en: The Big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from plain text, there are three sections below will give you an idea
    of what this chapter is about.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual reality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VR is about presenting to the player an immersive audio-visual experience, engaging
    enough for them to lose themselves in exploring and interacting with the game
    world that has been created.
  prefs: []
  type: TYPE_NORMAL
- en: From one point of view, VR simply requires two cameras in order to generate
    the images for each eye to give that 3D effect. But effective VR needs content,
    UI controls, and tools to help create them. In this chapter, we will explore recipes
    that work with 360-degree videos, and Unity's XR Editor toolset.
  prefs: []
  type: TYPE_NORMAL
- en: Gizmos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gizmos are another kind of Unity editor customization. Gizmos are visual aids
    for game designers that are provided in the scene panel. They can be useful as
    setup aids (to help us know what we are doing), or for debugging (understanding
    why objects aren't behaving as expected).
  prefs: []
  type: TYPE_NORMAL
- en: 'Gizmos are not drawn through Editor scripts, but as part of Monobehaviours,
    so they only work for GameObjects in the current scene. Gizmo drawing is usually
    performed in two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnDrawGizmos()`: This is executed every frame, for every GameObject in the
    hierarchy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDrawGizmosSelect()`: This is executed every frame, for just the/those GameObject(s)
    that are currently selected in the hierarchy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gizmo graphical drawing makes it simple to draw lines, cubes, and spheres. More
    complex shapes can also be drawn with meshes, and you can also display 2D image
    icons (located in the Project folder: `Assets` | `Gizmos`).
  prefs: []
  type: TYPE_NORMAL
- en: Several recipes in this chapter illustrate how Gizmos can be useful. Often,
    new GameObjects created from Editor Extensions will have helpful Gizmos associated
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: Saving/Loading data at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When loading/saving data either locally, it is important to keep in mind the
    data types that can be used. When writing C# code, our variables can be of any
    type permitted by the language, but when communicated by the web interface, or
    to a local storage using Unity's **PlayerPrefs** class, we are restricted in the
    types of data that we can work with. When using the **PlayerPrefs** class, we
    are limited to saving and loading integers, floats, and strings. We provide several
    recipes illustrating ways to save and load data at Run-Time, including the use
    of static variables, PlayerPrefs, and a public TextAsset containing text-format
    data for a 2D game level.
  prefs: []
  type: TYPE_NORMAL
- en: Saving screenshots from the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to take in-game snapshots, and save them in
    an external file. Better yet, we will make it possible to choose between three
    different methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique only works in the Unity Editor, or when you build to a **standalone** Windows
    or Mac executable (it will not work for Web Player builds, for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7a5b736-647a-4670-b147-d9761244cf2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow this recipe, please import the screenshots package, which is available
    in the `16_01` folder, to your project. The package includes a main camera, cube,
    and sphere—something to be able to recognize when the screenshot is taken!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save the screenshots from your game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the screenshots package by choosing the following menu: `**Assets | Import
    Package | Custom Package**...`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the scene provided in the screenshots package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# `CaptureScreenshot` script class and add an instance object as
    a component to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the Main Camera selected in the Hierarchy, in the Inspector access the CaptureScreenshot
    (Scripted) component. Set Capture Method as `SCREENSHOT_PNG`. Change Screenshot
    Scale to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want your image file''s name to start with something other than the
    word Screenshot, then change it in the Prefix field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6583298-da92-4e8c-8f3c-f324ec43468d.png)'
  prefs: []
  type: TYPE_IMG
- en: Play the scene. A new screenshot with twice the original size will be saved
    in your project folder every time you press *P*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each frame the `Update()` methods tests whether the *P* key has been pressed.
    If pressed, the `TakeShot()` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Method `TakeShot()` captures an image of the screen is and stores the image
    as a file in the main Unity project directory (that is, alongside the Assets and Library directories,
    and so on). The public settings of the CaptureScreenshot (Scripted) of MainCamera determine
    the properties of the image file created by the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three types of screenshot image are defined as an enumerated type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCREENSHOT_PNG`: built-in Unity function `CaptureScreenshot()`. This is capable
    of scaling the original screen size, which can be set by our Capture Scale public
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ_PIXELS_PNG`: `ReadPixels()` function used, encoded to PNG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ_PIXELS_JPG`: `ReadPixels()` function used, encoded to JPG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image data captured by the ReadPixels function is written to file by the
    built-in Unity function `WriteAllBytes()` in our `WriteBytesToFile(...)` method.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the file created will have the appropriate *.png* or *.jpg* file
    extension, to match its image file format.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have included the options using the `ReadPixel` function as a demonstration
    of how to save your images to a disk without using Unity's `CaptureScreenshot()` function.
    One advantage of this method is that it can be adapted to capture and save only
    a portion of the screen—if a different-sized rectangle is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading player data – using static properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping track of the player's progress and user settings during a game is vital
    to give your game a greater feeling of depth and content. In this recipe, we will
    learn how to make our game remember the player's score between the different levels
    (scenes).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have included a complete project in a Unity package named game_HigherOrLower in
    the `16_02` folder. To follow this recipe, we will import this package as the
    starting point.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save and load player data, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project and import the game_HigherOrLower package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add each of the scenes to the build in the sequence (scene0_mainMenu, then scene1_gamePlaying,
    and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make yourself familiar with the game by playing it a few times and examining
    the content of the scenes. The game starts on the scene0_mainMenu scene, inside
    the `Scenes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a class to store the number of correct and incorrect guesses
    made by the user. Create a new C# script called `Player` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the lower-left corner of the scene0_mainMenu scene, create a UI Text GameObject named Text -
    score, containing the placeholder text Score: 99 / 99:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d166200b-9a58-4460-9fd0-4050c3345e43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, attach the following C# script to the UI GameObject Text—score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `scene2_gameWon` scene, attach the following C# script to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `scene3_gameLost` scene, attach the following C# script to the Main
    Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Save your scripts, and play the game. As you progress from level (scene) to
    level, you will find that the score and the player's name are remembered, until
    you quit the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Player class uses static (class) properties `scoreCorrect` and `scoreIncorrect` to
    store the current total number of correct and incorrect guesses. Since these are
    public static properties, any object from any scene can access (set or get) these
    values, since the static properties are remembered from scene to scene. This class
    also provides the public static method called `ZeroTotals()` that resets both
    the values to zero.
  prefs: []
  type: TYPE_NORMAL
- en: When the scene0_mainMenu scene is loaded, all the `GameObjects` with scripts
    will have their `Start()` methods executed. The UI Text GameObject called Text-score has
    an instance of the `UpdateScoreText` class as s script component, so that the
    scripts `Start()` method will be executed, which retrieves the correct and incorrect
    totals from the Player class, creates the `scoreMessage` string about the current
    score, and updates the text property so that the user sees the current score.
  prefs: []
  type: TYPE_NORMAL
- en: When the game is running and the user guesses correctly (higher), then the scene2_gameWon scene
    is loaded. So, the `Start()` method, of the `IncrementCorrectScore` script component,
    of the Main Camera in this scene is executed, which adds 1 to the `scoreCorrect` variable
    of the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: When the game is running and the user guesses wrongly (lower), then the scene scene3_gameLost is
    loaded. So, the `Start()` method, of the `IncrementIncorrectScore` script component,
    of the Main Camera in this scene is executed, which adds 1 to the `scoreIncorrect` variable
    of the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: The next time the user visits the main menu scene, the new values of the correct
    and incorrect totals will be read from the `Player` class, and the UI Text on
    the screen will inform the user of their updated total score for the game.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the score before the first attempt is completed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Showing a score of zero out of zero isn''t very professional. Let''s add some
    logic so that the score is only displayed (a non-empty string) if the total number
    of attempts is greater than zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading player data - using PlayerPrefs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading player data – using PlayerPrefs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the previous recipe illustrates how the static properties allow a game
    to remember values between different scenes, these values are forgotten once the
    game application has quit. Unity provides the `PlayerPrefs` feature to allow a
    game to store and retrieve data, between the different game-playing sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44b8a09b-8c00-466a-9589-7b93c8fe6902.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the previous recipe, so make a copy of that project
    and work on the copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save and load the player data using `PlayerPrefs`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the C# script called `Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the C# script called `UpdateScoreText` by replacing the `Start()` method      with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now edit the C# script called `IncrementCorrectScore` by replacing the `Start()` method
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now edit the C# script called `IncrementIncorrectScore` by replacing the `Start()` method
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save your scripts and play the game. Quit from Unity and then restart the application.
    You will find that the player's name, level, and score are now kept between the
    game sessions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had no need for the Player class, since this recipe uses the built-in runtime
    class called `PlayerPrefs`, provided by Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Unity's `PlayerPrefs` runtime class is capable of storing and accessing information
    (the string, int, and float variables) in the user's machine. Values are stored
    in a plist file (Mac) or the registry (Windows), in a similar way to web browser
    cookies, and, therefore, remembered between game application sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Values for the total correct and incorrect scores are stored by the `Start()` methods
    in the `IncrementCorrectScore` and `IncrementIncorrectScore` classes. These methods
    use the `PlayerPrefs.GetInt("")` method to retrieve the old total, add 1 to it,
    and then store the incremented total using the `PlayerPrefs.SetInt("")` method.
  prefs: []
  type: TYPE_NORMAL
- en: These correct and incorrect totals are then read each time the scene0_mainMenu scene
    is loaded, and the score totals are displayed via the UI Text object on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `PlayerPrefs`, see Unity's online documentation at [http://docs.unity3d.com/ScriptReference/PlayerPrefs.html](http://docs.unity3d.com/ScriptReference/PlayerPrefs.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading player data - using static properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading game data from a text file map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than, for every level of a game, having to create and place every GameObject on
    the screen by hand, a better approach can be to create the text files of rows,
    and columns of characters, where each character corresponds to the type of GameObject that
    is to be created in the corresponding location.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use a text file and set of prefab sprites to display
    a graphical version of a text data file for a screen from the classic game, *NetHack*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ff4de70-894c-4bcf-a779-42270d17972e.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `16_04` folder, we have provided the following two files for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`level1.txt` (a text file, representing a level)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`absurd128.png` (a 128 x 128 sprite sheet for NetHack).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The level data came from the NetHack Wikipedia page, and the sprite sheet came
    from SourceForge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/NetHack](http://en.wikipedia.org/wiki/NetHack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://sourceforge.net/projects/noegnud/files/tilesets_nethack-3.4.1/absurd%20128x128/](http://sourceforge.net/projects/noegnud/files/tilesets_nethack-3.4.1/absurd%20128x128/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we also included a Unity package with all the prefabs set up, since
    this can be a laborious task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To load game data from a text file map, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import text file `level1.txt`, and image file `absurd128.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `absurd128.png` in the Inspector, and set Texture Type to Sprite (2D/uGUI), and Sprite
    Mode to Multiple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit this sprite in the Sprite Editor, choosing Type as Grid and Pixel Size as 128
    x 128, and apply these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/66dfa1d5-50ee-4d6d-b1d3-1c1929b60936.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project panel, click on the right-facing white triangle to explode the
    icon, to show all the sprites in this sprite sheet individually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ded1048-60a8-4cf8-8995-c97902e90837.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag the Sprite called absurd128_175 on to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Prefab named `corpse_175` in the Project panel, and drag onto this
    blank prefab Sprite `absurd128_175` from the scene. Now delete the sprite instance
    from the scene. You have now created a prefab containing the `Sprite 175`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat this process for the following sprites (that is, create prefabs for
    each one):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`– floor_848`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– corridor_849`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– horiz_1034`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– vert_1025`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– door_844`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– potion_675`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– chest_586`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– alter_583`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– stairs_up_994`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– stairs_down_993`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`– wizard_287`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the Main Camera in the Inspector, and ensure that it is set to an Orthographic camera,
    sized 20, with Clear Flags as Solid Color and Background as Black.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the following C# code to the Main Camera as the script class called `LoadMapFromTextfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the Main Camera selected, drag the appropriate prefabs on to the prefabs
    slots in the Inspector, for the `LoadMapFromTextfile` Script component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the scene, you will see that a sprite-based Nethack map will appear,
    using your prefabs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sprite sheet was automatically sliced up into hundreds of 128 x 128 pixel Sprite squares.
    We created the prefab objects from some of these sprites so that the copies can
    be created at runtime when needed.
  prefs: []
  type: TYPE_NORMAL
- en: The text file called `level1.txt` contains the lines of text characters. Each
    non-space character represents where a sprite prefab should be instantiated (column
    = *x*; row = y). A C# dictionary variable named *dictionary* is declared and initialized
    in the `Start()` method to associate the specific prefab GameObjects with some
    particular characters in the text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Awake()` method splits the string into an array using the newline character
    as a separator. So, now, we have `stringArray` with an entry for each row of the
    text data.      The `BuildMaze(...)` method is called with the `stringArray`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `BuildMaze(...)` method interrogates the array to find its length (the number
    of rows of data for this level), and sets `yOffSet` to half this value. This is
    done to allow the placing of the prefabs half above *y* = 0, and half below, so
    (0,0,0) is the center of the level map. A for-loop is used to read each row's
    string from the array. It passes it to the `CreateRow(...)` method along with
    the *y*-value corresponding to the current row.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateRow(...)` method extracts the length of the string, and sets `xOffSet` to
    half this value. This is done to allow the placing of the prefabs half to the
    left of *x* = 0 and half to the right, so (0,0,0) is the center of the level map.
    A for-loop is used to read each character from the current row's string, and (if
    there is an entry in our dictionary for that character) then the `CreatePrefabInstance
    (...)` method is called, passing the prefab reference in the dictionary for that
    character, and the *x* and *y* value.
  prefs: []
  type: TYPE_NORMAL
- en: The CreatePrefabInstance(...) method instantiates the given prefab at a position
    of *x, y, z,* where *z* is always zero, and there is no rotation (`Quarternion.identity`).
  prefs: []
  type: TYPE_NORMAL
- en: UI Slider to change game quality settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will show you how the player can control the quality settings
    by providing a UI Slider for the player. From this, they can choose from an array
    of possible quality settings for the current project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7317d68b-1e05-4c46-bc2d-ad9db6ded1df.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a package named `BallGame` containing two
    scenes. The package is in the `16_05` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a player UI to change the game''s quality settings, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project and import the `BallGame` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the scene named `scene0_ballCourt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the scene, create a new UI Panel named `Panel-quality` by choosing menu:
    Create | UI | Panel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the GameObject Panel-quality selected in the Hierarchy, create a new UI
    Slider named Slider-quality by choosing menu: Create | UI | Slider. This GameObject
    should be childed to Panel-quality.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With Panel-quality selected in the Hierarchy, create a new UI Text GameObject
    named Text-quality by choosing menu: Create | UI | Text. This GameObject should
    be childed to GameObject Panel-quality. In the **Inspector**, set its Transform
    Position Y value to -25.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class named `QualityChooser`, and attach an instance
    object as a component to the First Person Controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **Hierarchy,** select the First Person Controller. Then, from the **Inspector**,
    access the Quality Chooser component, and populate the panelGo, Slide, and Text
    Label public fields with the UI GameObjects Panel-quality, Slider, and Text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/877bda8e-a671-4a58-be55-82c660062529.png)'
  prefs: []
  type: TYPE_IMG
- en: From the **Hierarchy** panel, select Slider. Then, from the **Inspector,** for
    the Slider component, find the list named On Value Changed (Single), and click
    on the + sign to add a command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the First Person Controller from the **Hierarchy** into the **Game Object**
    field of the new command. Then, use the function selector to find the UpdateQuality
    function in the Dynamic float section (No Function | QualityChooser | Dynamic
    float | UpdateQuality):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37dddf3e-3e1c-497d-afea-7eb3bf15d05c.png)'
  prefs: []
  type: TYPE_IMG
- en: When you play the scene, you should be able to drag the quality slider to change
    the quality settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a panel containing a UI Slider and a UI Text object.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetQualitySliderActive(...)` method receives a true/false value, and uses
    this to show/hide the mouse cursor and the UI Panel.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateQuality(...)` method receives a float value from the Slider `OnChange`
    event. This value is converted to an integer, which is to be the index of the
    selected quality setting. This index is used both to select the project quality
    setting, and also to update the UI Text label with the name of the currently selected
    quality setting.
  prefs: []
  type: TYPE_NORMAL
- en: When the Scene begins, in the `Awake()` method, the UI Slider has its maximum
    value set to 1 less then the number of project quality items (for example, if
    there are five items, the slider will be from 0 to 4). Also, the UI Slider is
    moved to the position corresponding to the current quality level, and the `SetQualitySliderActive(...)` method
    is invoked with the true value in order to display both the mouse pointer and
    the UI Panel showing the slide and text label.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to go further with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing/editing the list of quality settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can view and modify the quality settings available for a project by choosing
    menu: Edit | Project Settings | Quality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/211f0b70-908b-4097-a20d-db4b63cd639c.png)'
  prefs: []
  type: TYPE_IMG
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As compelling as your next game will be, you should always let players pause
    it for a short break. Sometimes, a game pause is used to let the player rest,
    but another reason might be to change some game setting such as volume or graphics
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game usually involves a combination of freezing a game action, and
    also hiding or revealing UI items, to display a message to the player and provide
    UI controls to change settings.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement a simple and effective pause screen that hides
    the previous recipe's quality settings slide when the game is being played, and
    reveals it when the game has been paused.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds on the previous one, so make a copy of that and use that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To pause your game upon pressing the *Esc* key, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the First Person Controller, and in the Inspector, enable the following
    components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Character Controller
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse Look (Script)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Character Motor (Script)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: FPS Input Controller (Script)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shooter (Script)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following C# script called `PauseGame` to First Person Controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `QualityController` script class, and, in the `Awake()` method, change
    the last line to pass false (not true) to the `SetQualitySliderActive(...)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you play the Scene, you should be able to pause/resume the game by pressing
    the *Esc* key, which will also display/hide the slider that controls the game's
    quality settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To pause a Unity game with a script, we need to set the game''s Time Scale
    to 0 (and set it back to 1 to resume). The `SetPause()` method does these actions
    according to the value of the `isPaused` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isPause`= `true`: Time Scale 0 (pause the game), disable `MouseLook` component,
    and activate the quality slider and mouse cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPause` = `false`: Time Scale 1 (resume the game), enable `MouseLook` component,
    and deactivate the quality slider and mouse cursor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9cf70e8d-e179-416b-812e-8f205e312650.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `Update()` method, a test is made for each frame, whether or not the
    *Esc* key has been pressed. If pressed, the value of `isPaused` is toggled, and
    the `SetPause()` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to go further with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about quality settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our code for changing quality settings is a modification of an example given
    by Unity's documentation. If you want to learn more about this subject, check
    out the following link: [http://docs.unity3d.com/ScriptReference/QualitySettings.html](http://docs.unity3d.com/ScriptReference/QualitySettings.html).
  prefs: []
  type: TYPE_NORMAL
- en: Offering the user further game settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could add more UI panels to be activated when the game is paused, for example,
    for sound volume controls, save/load buttons, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing slow motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Remedy Entertainment's *Max Payne* video game, slow motion, or bullet
    time, has become a popular feature in games. For example, Criterion's *Burnout*
    series has successfully explored the slow motion effect in the racing genre. In
    this recipe, we will implement a slow motion effect that is triggered by pressing
    the mouse's right button.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use the same package as the previous recipes, `BallGame`,
    which is in the `16_07` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement slow motion, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BallGame` package into your project and, from the Project panel,
    open the level named `scene1_ballGame.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class called `BulletTime,` and add an instance object as
    a component to the First Person Controller GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a UI Slider to the scene named Slider-energy by choosing menu: Create |
    UI | Slider. Please note that it will be created as a child of the existing Canvas
    object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Slider-energy and, from the Rect Transform component in the Inspector,
    set its Anchors as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Min X: 0, Y: 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Max X: 0.5, Y: 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pivot X: 0, Y: 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select Slider-energy and, from the Rect Transform component in the Inspector,
    set its Position as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Left: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pos Y: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pos Z: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Height: 50:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1b621a49-cd9e-4080-9a33-cfc487c413be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Inspector, set the slider''s child **GameObject** Handle Slide Area
    as inactive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b52387fa-64fc-4b45-84f7-942d5b95f989.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, select the First Person Controller from the Hierarchy. Then, find the
    Bullet Time component, and drag the GameObject Slider-energy from the Hierarchy
    into its Energy Bar slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your game. You should be able to activate slow motion by holding down the
    right mouse button (or whatever alternative you have set for the Input axis Fire2).
    The slider will act as a progress bar that slowly shrinks, indicating the remaining
    bullet time you have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, all we need to do to have the slow motion effect is decrease the
    `Time.timeScale` variable. In our script, we do that by using the `slowSpeed`
    variable. Please note that we also need to adjust the `Time.fixedDeltaTime` variable,
    updating the physics simulation of our game.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the experience more challenging, we have also implemented a
    sort of energy bar to indicate how much bullet time the player has left (the initial
    value is given, in seconds, by the `totalTime` variable). Whenever the player
    is not using bullet time, he/she has his/her quota filled according to the `recoveryRate`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the UI Slider, we have used the Rect Transform settings to place it
    on the top-left corner and set its dimensions to half of the screen's width and
    50 pixels tall. Also, we have hidden the handle slide area to make it similar
    to a traditional energy bar. Finally, instead of allowing direct interaction from
    the player with the slider, we have used the `BulletTime` script to change the
    slider's value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some suggestions on how you can improve your slow motion effect even further
    are described in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't forget that you can personalize the slider's appearance by creating your
    own sprites, or even by changing the slider's fill color based on the slider's
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try adding the following lines of code to the end of the `Update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Adding Motion Blur
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Motion Blur is an image effect that''s frequently identified with slow motion.
    Once attached to the camera, it can be enabled or disabled depending on the speed
    float value. For more information on the Motion Blur post-processing image effect,
    refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Unity-Technologies/PostProcessing/wiki/Motion-Blur](https://github.com/Unity-Technologies/PostProcessing/wiki/Motion-Blur)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.postprocessing@2.0/manual/Motion-Blur.html](https://docs.unity3d.com/Packages/com.unity.postprocessing@2.0/manual/Motion-Blur.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.postprocessing@2.0/manual/Manipulating-the-Stack.html](https://docs.unity3d.com/Packages/com.unity.postprocessing@2.0/manual/Manipulating-the-Stack.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating sonic ambience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Max Payne* famously used a strong, heavy heartbeat sound as sonic ambience.
    You could also try lowering the sound effects volume to convey the character''s
    focus when in slow motion. Plus, using audio filters on the camera could be an
    interesting option.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Gizmo to show the currently selected object in a scene panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gizmos are visual aids that are provided to game designers in the scene panel.
    In this recipe, we''ll highlight the **GameObject** that is currently selected
    in the **Hierarchy** in the Scene panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f152c1-9628-4647-9481-676bbfc23ce3.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a Gizmo to show the selected object in the Scene panel, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a 3D cube by choosing menu: Create | 3D Object | Cube.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class called `GizmoHighlightSelected`, and add an instance
    object as a component to the **3D Cube**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Make lots of duplicates of the 3D Cube, distributing them randomly around the
    scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you select one cube in the Hierarchy, you should see three colored wireframe
    spheres drawn around the selected **GameObject** in the Scene panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an object is selected in a scene, if it contains a scripted component that
    includes the `OnDrawGizmosSelected()` method, then that method is invoked. Our
    method draws three concentric wireframe spheres in three different colors around
    the selected object.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more from the Gizmos Unity manual entry at [https://docs.unity3d.com/Manual/GizmosMenu.html](https://docs.unity3d.com/Manual/GizmosMenu.html).
  prefs: []
  type: TYPE_NORMAL
- en: Editor snap-to grid drawn by Gizmo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the positioning of objects needs to be restricted to specific increments,
    it is useful to have a grid drawn in the scene panel to help ensure that new objects
    are positioned based on those values, and also code to snap objects to that grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use Gizmos to draw a grid with a customizable grid size,
    color, number of lines, and line length. The result of following this recipe will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca48e620-10dd-4f23-8869-30f6b9ec56b5.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a Gizmo to show the selected object in the Scene panel, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the Scene panel, turn off the Skybox view (or simply toggle off all the
    visual settings) so that you have a plain background for your grid work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/edc2955b-cb99-479a-9bd6-36a6262e21bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The display, and updating the child objects, will be performed by a script
    class called `GridGizmo.` Create a new C# script class called `GridGizmo` which
    contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use an Editor script to add a new menu item to the **GameObject** menu.
    Create a folder named `Editor`, and in that folder, create a new C# script class
    called `EditorGridGizmoMenuItem,` which contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add another **Editor** script for a custom Inspector display (and
    updater) for the `GridGizmo` components. Also, in your **Editor** folder, create
    a new C# script class called `EditorGridGizmo,` which contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `GizmoGrid` GameObject to the scene by choosing menu: GameObject
    | Create New Snapgrid. A new GameObject named ___snap-to-grid___ should be added
    to the Hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/513c2646-a955-4770-9b14-51dedb35c136.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select GameObject ___snap-to-grid___, and modify some of its properties in
    the Inspector. You can change the grid size, the color of the grid lines, the
    number of lines, and their length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a2e5b99-a671-492f-bb5f-dfd780a2b2f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a **3D Cube** by choosing menu: Create | 3D Object | Cube. Now, drag
    the **3D Cube** into the Hierarchy and child it to GameObject ___snap-to-grid___.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need a small script class so that, each time the GameObject is moved
    (in Editor mode), it asks for its position to be snapped by the parent scripted
    component `SnapToGizmoGrid.` Create a C# script class called `SnapToGizmoGrid` and
    add an instance object as a component to the **3D Cube**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Make lots of duplicates of the 3D cube, distributing them randomly around the
    scene—you'll find that they snap to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select GameObject ___snap-to-grid___ again, and modify some of its properties
    in the Inspector. You'll see that the changes are instantly visible in the scene,
    and that all child objects that have a scripted component of `SnapToGizmoGrid`
    are snapped to any new grid size changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EditorGridGizmoMenuItem` script class adds a new item to the GameObject
    menu. When selected, a new GameObject is added to the Hierarchy named ___snap-to-grid___,
    positioned at (0, 0, 0), and containing an instance object component of the `GridGizmo`
    script class.
  prefs: []
  type: TYPE_NORMAL
- en: '`GridGizmo` draws a 2D grid based on public properties for grid size, color,
    number of lines, and line length. Regarding the `SetGrid(...)` method, as well
    as updating the integer grid size variable grid, it also invokes the `SnapAllChildren()`
    method, so that each time the grid size is changed, all child GameObjects are
    snapped into the new grid positions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SnapToGridGizmo` script class includes an Editor attribute `[ExecuteInEditMode]` so
    that it will receive `Update()` messages when its properties are changed at design
    time in the Editor. Each time `Update()` is invoked, it calls the `SnapPositionToGrid(...)` method
    in its parent `GridGizmo` instance object so that its position is snapped based
    on the current settings of the grid. To ensure this logic and code is not compiled
    into any final build of the game, the contents of `Update()` are wrapped in an
    #if UNITY_EDITOR compiler test. Such content is removed before a build is compiled
    for the final game.'
  prefs: []
  type: TYPE_NORMAL
- en: The `EditorGridGizmo` script class is a custom Editor Inspector component. This
    allows for both control of which properties are displayed in the Inspector, how
    they are displayed, and it allows actions to be performed when any values are
    changed. So, for example, after changes have been saved, the `sceneView.RepaintAll()`
    statement ensures that the grid is re-displayed, since it results in an `OnDrawGizmos()`
    message being sent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VR project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will go through the steps for setting up a basic VR scene
    in Unity, using the Vive VR headset on a Windows computer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need Steam VR with the Standing Only or Room-scale set up. If you have
    not done so yet, then follow these steps to set up your Vive headset so that it''s
    ready for Unity game development:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Steam
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Steam VR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug in your Vive headset
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Steam application window, run Steam VR (click VR at top right of the
    Steam app window):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c968814d-26da-4034-ad69-7ea398d8950a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Steam VR should run. Then, choose the Run Room Setup menu item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/336bc099-aeed-459a-9ea2-844b3b60c6be.png)'
  prefs: []
  type: TYPE_IMG
- en: Position your **Light Houses** to cover the space in the room that you want
    to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Room Setup screen, choose your room setup: Standing Only or Room-Scale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Standing Only:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the headset to set the center
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the headset to locate the floor
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Room-Scale:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Position your Light Houses to cover the space you want to use
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calibrate the floor by putting hand controllers on the floor
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk around room, using hand controllers with the trigger to trace the space
    you can safely move around
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can now explore Steam VR Home.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a basic VR Unity project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either work with a new 3D Unity project, or make a backup of any project to
    which you are about to add VR features to, since you will be adding a package
    that makes changes to many settings, and it could mess up settings in an existing
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the Main Camera from the Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the Unity Player settings in the Inspector by choosing menu: Edit |
    Project Settings | Player.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the Virtual Reality Supported option near the bottom of the Inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a3109a7-9e28-4f96-b4f8-59339bf45b32.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that you are logged into your Unity Account (before accessing the **Asset
    Store**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visit the **Asset Store** and search for Steam VR from the Valve Corporation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1c09bc6-95bd-47ba-aff2-7269daf0fa41.png)'
  prefs: []
  type: TYPE_IMG
- en: Download and import the package (you'll be warned about having made a backup
    before importing...).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose your preferred options from any pop-up about builds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9c88ce1-ab59-4890-bb43-55cefc8b9fbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag into the Scene a clone of the [CameraRig] prefab from folder: Project
    | SteamVR | Prefabs. You''ll see a 3D space representing your room setup (our
    examples show the rectangular-based space from the Standing only room setup):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4248b37c-4498-47d4-8677-b47024033440.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the Scene, put on your VR headset, and pick up your hand controllers. You
    should see 3D representations of the position, trigger settings, and so on of
    your hand controllers in the virtual space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import/create 3D Objects in your scene - for example, add a **3D Cube** to the
    scene inside the room space of the CameraRig.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the Scene, and try moving a virtual hand controller to collide with your
    3D cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e831433d-d831-4f4e-985c-20d6afba9e68.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the physics by adding a Rigid Body component to the 3D Cube (and turn off
    gravity), adding/making the Box Collider to the GameObject Controller (right)
    smaller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene - you should be able to push the **3D Cube** with the virtual
    hand controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've learned to set up Vive and locate and install the Steam VR package.
  prefs: []
  type: TYPE_NORMAL
- en: This package contains prefabs so that the headset and handset work in the standing/room
    space you set up.
  prefs: []
  type: TYPE_NORMAL
- en: You created a Unity project with the Vive prefabs. You then added a 3D Cube
    to the scene and interacted with it by adding colliders to the cube and a hand
    controller GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: This was tested with Unity 2017.4.9 LTS, since it wasn't fully working with
    a 2018 version at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some suggestions for taking this recipe further.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring free VR/XR samples/tutorials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some good sources of free sample VR projects to explore include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Technologies VR Samples: [https://assetstore.unity.com/packages/essentials/tutorial-projects/vr-samples-51519](https://assetstore.unity.com/packages/essentials/tutorial-projects/vr-samples-51519):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/85037417-68e6-4b71-97c0-9dcd3bf12294.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A good tutorial on Vive and Unity from **Ray Wenderlick**: [https://www.raywenderlich.com/792-htc-vive-tutorial-for-unity](https://www.raywenderlich.com/792-htc-vive-tutorial-for-unity)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Valve Lab Renderer on the Unity **Asset Store**: [https://assetstore.unity.com/packages/tools/the-lab-renderer-63141](https://assetstore.unity.com/packages/tools/the-lab-renderer-63141)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vive input utility on the Unity **Asset Store**: [https://assetstore.unity.com/packages/tools/integration/vive-input-utility-64219](https://assetstore.unity.com/packages/tools/integration/vive-input-utility-64219)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup with Oculus Rift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Oculus Rift setup is similar to that with the Vive, although it actually
    integrates a little better with Unity. You need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Oculus runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setup for room/standing for the Infrared Cameras.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no need download any package, and no need to remove the Main Camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can learn more about this at the Oculus Rift Unity documentation site: [https://developer.oculus.com/documentation/unity/latest/concepts/book-unity-gsg/](https://developer.oculus.com/documentation/unity/latest/concepts/book-unity-gsg/).
  prefs: []
  type: TYPE_NORMAL
- en: Using a Single Pass if working with the Lightweight Rendering Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re using the **Lightweight Rendering Scripted Pipeline**, then you
    need to choose Single Pass for the Stereo `RenderingMethod*` property when setting
    up XR in the settings, having chosen menu: Edit | Project Settings | Player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83728dea-ec7e-42df-b271-f7baaf42f31f.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding 360-degree videos to a VR project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Earth VR is great fun! This screenshot from a live VR session shows
    the virtual hand controller, and a virtual screen menu showing photos and text
    about 6 suggested locations to visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc4d85ec-70eb-4248-b0ae-d1a5d2d2a560.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Affordable, 360-degree cameras means that it''s easy to create your own, or
    find free online 360-degree images and video clips. In this recipe, we''ll learn
    how to add a 360-degree video clip as a Skybox in a VR project. You will also
    learn how the 360-degree video clips can be played on the surface of 3D objects,
    including the inside of a sphere—a bit like **Google Earth** **VR** mode when
    you raise the sphere to your head to view its 360-degree image contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75d955a8-4647-4f29-a940-7c7caf872ba1.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have provided a short `Snowboarding_Polar.mp4` video in
    the `16_07` folder. This project builds on the previous one (a basic VR project),
    so make a copy of that and work on the copy.
  prefs: []
  type: TYPE_NORMAL
- en: Special thanks to Kris Szczurowski for permission to use his snowboarding 360-degree
    video clip, and for his help with these VR project recipes. Good luck with the
    PhD!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add 360-degree videos to a VR project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import your 360-degree polar format video clip into your Unity project (in our
    example, this is `Snowboarding_Polar.mp4`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the video asset in the Project panel, and in the Inspector, make a note
    of its resolution (we''ll need this later), for example, 2,560 x 1,280:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ff1ec98d-08af-4b97-84cd-72fa612bff4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new empty GameObject named video-player by choosing menu: Create |
    Empty.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select video-player in the Hierarchy, and in the Inspector, add a component
    **Video Player** component by choosing: Add Component | Video | Video Player.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Project panel, drag your video asset file, for example, `Snowboarding_Polar`,
    into the Video Clip property of the Video Player component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Render Texture asset file named `VideoRenderTexture` by choosing
    menu: Create | Render Texture.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Resolution of the `VideoRenderTexture` to match the video asset resolution,
    for example, 2,560 x 1,280:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7c5b0c4-f7d1-474c-98cf-3673af46ca4e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Hierarchy, select GameObject video-player, and for the Video Player component,
    set the target texture to be `VideoRenderTexture.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Material named `video_m` by choosing menu: Create | Material.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `video_m` selected in the Project panel, change its **Shader** to Skybox
    | Panoramic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebada947-0ba7-4ab0-9554-1767103f2731.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Inspector, for the Spherical HDR property, click the Select button and
    choose Texture `VideoRenderTexture:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c47c37b3-eadc-4341-93da-4e2ff85c51c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the Lighting Settings panel, choose menu: Window | Rendering | Lighting
    Settings. In the Inspector, set the Skybox Material to `video_m:`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/abb53f02-7924-4d3f-919c-8aacc58207b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Play the Scene, put on your VR headset, and you should see the 360-degree video
    playing all around you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have created a GameObject with a Video Player component, and made it play
    your 360-degree video. You made this component render to a Render Texture of the
    same dimensions as your video.
  prefs: []
  type: TYPE_NORMAL
- en: You created a Skybox-panomaric **Material,** and selected your Render Texture
    as the Texture for this **Material**. You then set this **Material** as the Skybox
    for the Lighting Settings.
  prefs: []
  type: TYPE_NORMAL
- en: This was tested with Unity 2017.4.9 LTS, since it wasn't fully working with
    a 2018 version at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some suggestions for taking this recipe further.
  prefs: []
  type: TYPE_NORMAL
- en: Playing 360-degree videos on the surface of a 3D object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To play 360-degree videos on the surface of a 3D object, perform the aforementioned
    steps, but do not set the Skybox to `video_m`. Instead, set the Material of the
    Mesh Renderer component of your 3D object to `video_m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0d10053-1637-4007-a206-ffdc5c7c0a2a.png)'
  prefs: []
  type: TYPE_IMG
- en: This works for 3D objects with inverted normals, for example, a hollow 3D Sphere
    that you can look at from the inside.
  prefs: []
  type: TYPE_NORMAL
- en: Working with VR content inside a VR environment – the XR Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An exciting project from Unity is the XR-Editor, which is a VR environment
    that allows you to edit a scene in VR. The project provides great examples of
    VR UI elements, including 3D menus and laser pointer selectors. It allows you
    to see Console reports in the environment and interact with the Hierarchy of GameObjects:
    In this screenshot we can see the main Workspace menu displayed on the virtual
    left hand controller, and the virtual right hand controller is being presented
    as a rotary menu for actions that can be performed on the currently selected GameObject.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ''Select Parent'' option is currently selected in this rotary menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72c28544-4eea-466e-9f79-189bf674f627.png)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we will set up the XR-Editor for use in a Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start this recipe with a copy of the Basic VR project created in the recipe
    before the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it ...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with VR content inside a VR environment in the XR Editor, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the TextMeshPro package, choosing menu: Window | Package Manager, and
    selecting Text Mesh Pro.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the Editor XR package from the links on the Unity blog page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://rebrand.ly/EditorVR-package](http://rebrand.ly/EditorVR-package)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blogs.unity3d.com/2016/12/15/editorvr-experimental-build-available-today/](https://blogs.unity3d.com/2016/12/15/editorvr-experimental-build-available-today/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the EditorXR-package package into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Agree to the prompt on-screen about patching the Input Manager settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f65fe051-8584-4922-9545-ae429c19dfc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There should be a new item on the Window Menu, Window | EditorXR. Choose this
    menu item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25a2b73d-bd37-400e-a1f5-570d17506e68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A new, floating EditorXR application window should now be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41b2e007-5428-42a2-845a-a9d6dae982d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Put on your VR headset and start creating. Do NOT run the scene—Editor XR works
    at **Design Time**, not **Run-Time**, so do NOT play the **Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You display the main menu by directing the laser pointer of one virtual hand
    controller onto the menu bar on the other hand controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/694c1e4c-c9b3-4614-9c5e-b6b7ef75dbd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll then get a cube-like, multi-sided, rotatable main menu, from which
    you can choose items with the laser pointer. For example on the Workspaces side
    of the menu object there are options to display the **Console**, **Hierarchy**,
    **Inspector**, **Locked Objects**, **MiniWorld** and **Profiler** panels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/252da0f6-8be2-4779-95f9-c480a27e1848.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can choose the Primatives menu where you can create new 3D objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d1278e2-8370-40c3-aeff-9a1b50d9d616.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With a GameObject selected, a wheel-menu offers actions, such as deleting or
    selecting the parent, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/daf5e253-5abc-4994-a196-e00930081c13.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you learned how to install and start interacting with Unity's
    Editor-XR.
  prefs: []
  type: TYPE_NORMAL
- en: This was tested with Unity 2017.4.9 LTS, since it wasn't fully working with
    a 2018 version at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Editor XR/VR at the Unity blog at [https://blogs.unity3d.com/2016/12/15/editorvr-experimental-build-available-today/](https://blogs.unity3d.com/2016/12/15/editorvr-experimental-build-available-today/)[.](https://blogs.unity3d.com/2016/12/15/editorvr-experimental-build-available-today/)
  prefs: []
  type: TYPE_NORMAL
