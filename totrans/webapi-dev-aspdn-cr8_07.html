<html><head></head><body>
<div id="_idContainer054">
<h1 class="chapter-number" id="_idParaDest-140"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-141"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.2.1">Data Access in ASP.NET Core (Part 3: Tips)</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B18971_06.xhtml#_idTextAnchor245"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we learned how to manage relationships between entities using the EF Core Fluent API. </span><span class="koboSpan" id="kobo.5.2">We introduced three types of relationships: one-to-one, one-to-many, and many-to-many. </span><span class="koboSpan" id="kobo.5.3">We also learned how to perform </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">CRUD</span></strong><span class="koboSpan" id="kobo.7.1"> operations on related entities. </span><span class="koboSpan" id="kobo.7.2">With the knowledge we gained from </span><a href="B18971_06.xhtml#_idTextAnchor245"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.9.1">, we can now build a simple data access layer for most web API applications. </span><span class="koboSpan" id="kobo.9.2">However, there are still some scenarios that we need to handle properly. </span><span class="koboSpan" id="kobo.9.3">For example, how do we improve the performance of data access? </span><span class="koboSpan" id="kobo.9.4">And what should we do if there are </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">concurrency conflicts?</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will cover some advanced topics related to data access in ASP.NET Core, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">DbContext</span></strong><span class="koboSpan" id="kobo.13.1"> pooling, performance optimization, raw SQL queries, and concurrency conflicts. </span><span class="koboSpan" id="kobo.13.2">We will also discuss some tips and tricks that can help you write </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">better code.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">We will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.18.1"> pooling</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Tracking versus </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">no-tracking queries</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">IQueryable </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">versus IEnumerable</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Client versus </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">server evaluation</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Raw </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">SQL queries</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Bulk operations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Concurrency conflicts</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Reverse engineering</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Other </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">ORM frameworks</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">After reading this chapter, you will have gained a deeper understanding of EF Core and be able to use it more effectively in your applications. </span><span class="koboSpan" id="kobo.32.2">You will have learned how to use no-tracking queries to improve query performance, as well as how to use raw SQL queries to execute complex queries. </span><span class="koboSpan" id="kobo.32.3">Additionally, you will understand how to use bulk operations to improve the performance of bulk data operations. </span><span class="koboSpan" id="kobo.32.4">Furthermore, you will be able to handle concurrency conflicts for large-scale applications and use reverse engineering to generate the entity classes and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">DbContext</span></strong><span class="koboSpan" id="kobo.34.1"> class from an </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">existing database.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.36.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.37.1">The code examples in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8</span></a><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">You can use VS 2022 or VS Code to open </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the solutions.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.41.1">Understanding DbContext pooling</span></h1>
<p><span class="koboSpan" id="kobo.42.1">In the </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.43.1">previous chapter, we learned how to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">DbContext</span></strong><span class="koboSpan" id="kobo.45.1"> instance as a scoped service in the DI container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">AddDbContext()</span></strong><span class="koboSpan" id="kobo.47.1"> extension method. </span><span class="koboSpan" id="kobo.47.2">By default, a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">DbContext</span></strong><span class="koboSpan" id="kobo.49.1"> instance is created for each request, which is generally not a problem since it is a lightweight object that does not consume many resources. </span><span class="koboSpan" id="kobo.49.2">However, in a high-throughput application, the cost of setting up various internal services and objects for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">DbContext</span></strong><span class="koboSpan" id="kobo.51.1"> instance can add up. </span><span class="koboSpan" id="kobo.51.2">To address this, EF Core provides a feature called </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">DbContext pooling</span></strong><span class="koboSpan" id="kobo.53.1">, which allows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">DbContext</span></strong><span class="koboSpan" id="kobo.55.1"> instance to be reused across </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">multiple requests.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">To </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.58.1">enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">DbContext</span></strong><span class="koboSpan" id="kobo.60.1"> pooling, you can replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">AddDbContext()</span></strong><span class="koboSpan" id="kobo.62.1"> method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">AddDbContextPool()</span></strong><span class="koboSpan" id="kobo.64.1"> method. </span><span class="koboSpan" id="kobo.64.2">This resets the state of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">DbContext</span></strong><span class="koboSpan" id="kobo.66.1"> instance when it is disposed of, stores it in a pool, and reuses it when a new request comes in. </span><span class="koboSpan" id="kobo.66.2">By reducing the cost of setting up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">DbContext</span></strong><span class="koboSpan" id="kobo.68.1"> instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">DbContext</span></strong><span class="koboSpan" id="kobo.70.1"> pooling can significantly improve the performance of your application for </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">high-throughput scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">You can find the sample code for this section from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">/samples/chapter7/EfCoreDemo</span></strong><span class="koboSpan" id="kobo.74.1"> folder in this chapter's </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Program.cs</span></strong><span class="koboSpan" id="kobo.78.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">EfCoreDemo</span></strong><span class="koboSpan" id="kobo.80.1"> project. </span><span class="koboSpan" id="kobo.80.2">The following code shows how to enable </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1"> pooling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
services.AddDbContextPool&lt;InvoiceDbContext&gt;(options =&gt;{
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});</span></pre>
<p><span class="koboSpan" id="kobo.84.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">AddDbContextPool()</span></strong><span class="koboSpan" id="kobo.86.1"> method takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">poolSize</span></strong><span class="koboSpan" id="kobo.88.1"> parameter, which specifies the maximum number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">DbContext</span></strong><span class="koboSpan" id="kobo.90.1"> instances that can be stored in the pool. </span><span class="koboSpan" id="kobo.90.2">The default value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">1024</span></strong><span class="koboSpan" id="kobo.92.1">, which is usually sufficient for most applications. </span><span class="koboSpan" id="kobo.92.2">If the pool is full, EF Core will start creating new </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">DbContext</span></strong><span class="koboSpan" id="kobo.94.1"> instances </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">To validate</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.97.1"> whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">DbContext</span></strong><span class="koboSpan" id="kobo.99.1"> pooling can improve the performance of the application, we can run a performance test. </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Grafana k6</span></strong><span class="koboSpan" id="kobo.101.1"> is an open-source</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.102.1"> load-testing tool that can be used to test the performance of web APIs. </span><span class="koboSpan" id="kobo.102.2">To use k6, you need to install NodeJS here: </span><a href="https://nodejs.org/"><span class="koboSpan" id="kobo.103.1">https://nodejs.org/</span></a><span class="koboSpan" id="kobo.104.1">. </span><span class="koboSpan" id="kobo.104.2">Then you can download it from </span><a href="https://k6.io/docs/get-started/installation/"><span class="koboSpan" id="kobo.105.1">https://k6.io/docs/get-started/installation/</span></a><span class="koboSpan" id="kobo.106.1">. </span><span class="koboSpan" id="kobo.106.2">k6 has packages for various platforms, including Windows, Linux, and macOS. </span><span class="koboSpan" id="kobo.106.3">Install k6 on </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">your machine.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">You can find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">script.js</span></strong><span class="koboSpan" id="kobo.110.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">k6</span></strong><span class="koboSpan" id="kobo.112.1"> folder in the project. </span><span class="koboSpan" id="kobo.112.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">script.js</span></strong><span class="koboSpan" id="kobo.114.1"> file is a k6 script that contains the test scenarios. </span><span class="koboSpan" id="kobo.114.2">The following code shows the content of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">script.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.116.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.117.1">
import http from 'k6/http';import { sleep } from 'k6';
export const options = {
    vus: 500,
    duration: '30s',
  };
export default function () {
  http.get('http://localhost:5249/api/Invoices?page=1&amp;pageSize=10');
  sleep(1);
}</span></pre>
<p><span class="koboSpan" id="kobo.118.1">This is a basic k6 test script that runs a 30-second, 500-VU load test. </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">Virtual users</span></strong><span class="koboSpan" id="kobo.120.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.121.1">VUs</span></strong><span class="koboSpan" id="kobo.122.1">) are</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.123.1"> the number of concurrent users that will be simulated. </span><span class="koboSpan" id="kobo.123.2">The test script will send </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">GET</span></strong><span class="koboSpan" id="kobo.125.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">/api/Invoices?page=1&amp;pageSize=10</span></strong><span class="koboSpan" id="kobo.127.1"> endpoint for </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">30 seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">First, use </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.130.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">AddDbContext()</span></strong><span class="koboSpan" id="kobo.132.1"> method to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">DbContext</span></strong><span class="koboSpan" id="kobo.134.1">, and run the application using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">dotnet run</span></strong><span class="koboSpan" id="kobo.136.1"> command. </span><span class="koboSpan" id="kobo.136.2">Then, open a new terminal and run the following command to start the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">k6 test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
k6 run script.js</span></pre> <p><span class="koboSpan" id="kobo.139.1">Next, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">AddDbContextPool()</span></strong><span class="koboSpan" id="kobo.141.1"> method to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">DbContext</span></strong><span class="koboSpan" id="kobo.143.1">, and test the application again using the same k6 script. </span><span class="koboSpan" id="kobo.143.2">You can compare the results of the two tests to see whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">DbContext</span></strong><span class="koboSpan" id="kobo.145.1"> pooling improves the performance of the application. </span><span class="koboSpan" id="kobo.145.2">For example, one test result of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">AddDbContext()</span></strong><span class="koboSpan" id="kobo.147.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.149.1"><img alt="Figure 7.1 – The test result of using the AddDbContext() method" src="image/B18971_07_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.150.1">Figure 7.1 – The test result of using the AddDbContext() method</span></p>
<p><span class="koboSpan" id="kobo.151.1">The following is the result of using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">AddDbContextPool</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.153.1"> method:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.154.1"><img alt="Figure 7.2 – The test result of using the AddDbContextPool() method" src="image/B18971_07_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.155.1">Figure 7.2 – The test result of using the AddDbContextPool() method</span></p>
<p><span class="koboSpan" id="kobo.156.1">When </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.157.1">using </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">AddDbContext()</span></strong><span class="koboSpan" id="kobo.159.1">, the average request duration is 1.07 s and 7,145 requests are completed, while when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">AddDbContextPool()</span></strong><span class="koboSpan" id="kobo.161.1">, the average request duration is 782.36 ms and 8,530 requests are completed. </span><span class="koboSpan" id="kobo.161.2">The results show that </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">DbContext</span></strong><span class="koboSpan" id="kobo.163.1"> pooling can improve the performance of the application. </span><span class="koboSpan" id="kobo.163.2">Note that your results may vary depending on your machine’s configuration. </span><span class="koboSpan" id="kobo.163.3">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">dotnet run</span></strong><span class="koboSpan" id="kobo.165.1"> command is used to run the application in development mode, which is not optimized for performance. </span><span class="koboSpan" id="kobo.165.2">So, this test is just for demonstration purposes and cannot reflect the real performance of the application. </span><span class="koboSpan" id="kobo.165.3">However, it can give you an idea of how </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">DbContext</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.167.1">pooling works.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.168.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.169.1">For most applications, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">DbContext</span></strong><span class="koboSpan" id="kobo.171.1"> pooling is not necessary. </span><span class="koboSpan" id="kobo.171.2">You should enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">DbContext</span></strong><span class="koboSpan" id="kobo.173.1"> pooling only if you have a high-throughput application. </span><span class="koboSpan" id="kobo.173.2">Therefore, before enabling </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">DbContext</span></strong><span class="koboSpan" id="kobo.175.1"> pooling, it is important to test your application’s performance with and without it to see whether there’s any </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">noticeable improvement.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">In summary, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">DbContext</span></strong><span class="koboSpan" id="kobo.179.1"> pooling can improve the performance of high-throughput applications, it’s not a one-size-fits-all solution. </span><span class="koboSpan" id="kobo.179.2">Be sure to evaluate your application’s specific needs before deciding whether to enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">DbContext</span></strong><span class="koboSpan" id="kobo.181.1"> pooling </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">or </span><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.183.1">not.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.184.1">Understanding the difference between tracking versus no-tracking queries</span></h1>
<p><span class="koboSpan" id="kobo.185.1">In this section, we will discuss the difference between tracking and no-tracking queries. </span><span class="koboSpan" id="kobo.185.2">What</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.186.1"> are tracking queries and no-tracking queries? </span><span class="koboSpan" id="kobo.186.2">Let us start from </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">the beginning!</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">In the early days of .NET, the term </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">SqlHelper</span></strong><span class="koboSpan" id="kobo.190.1"> was </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.191.1">popular to refer to a static class that provided a set of methods to execute SQL queries. </span><span class="koboSpan" id="kobo.191.2">While SqlHelper simplified the process of executing SQL queries, developers still had to manage connection and transaction objects, write boilerplate code to map results to model objects, and work directly with </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the database.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.193.1">ORM</span></strong><span class="koboSpan" id="kobo.194.1"> frameworks such as EF Core were created to solve these problems. </span><span class="koboSpan" id="kobo.194.2">They not only simplify the process of executing SQL queries and mapping the results to model objects but also provide the ability to track changes made to the entities returned by queries. </span><span class="koboSpan" id="kobo.194.3">When changes are saved, EF Core generates the appropriate SQL queries to update the database. </span><span class="koboSpan" id="kobo.194.4">This is called tracking and is a significant benefit of using an ORM framework such as </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">EF Core.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">However, tracking comes at a cost. </span><span class="koboSpan" id="kobo.196.2">This can add overhead and memory usage, especially when dealing with a large number </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">of entities.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">We introduced a little bit about tracking in </span><a href="B18971_05.xhtml#_idTextAnchor198"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.199.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">Let's see an example of tracking. </span><span class="koboSpan" id="kobo.200.3">You can find the sample code for this section from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">/samples/chapter7/EfCoreDemo</span></strong><span class="koboSpan" id="kobo.202.1"> folder in this chapter's </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">In the sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">EfCoreDemo</span></strong><span class="koboSpan" id="kobo.206.1"> project, you can find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">GetInvoice</span></strong><span class="koboSpan" id="kobo.208.1"> action in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.210.1"> class. </span><span class="koboSpan" id="kobo.210.2">The following code shows how the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">tracking works:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
[HttpGet("{id}")]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; GetInvoice(Guid id)
{
    if (context.Invoices == null)
    {
        return NotFound();
    }
    logger.LogInformation($"Invoice {id} is loading from the database.");
    var invoice = await context.Invoices.FindAsync(id);
    logger.LogInformation($"Invoice {invoice?.Id} is loaded from the database."
</span><span class="koboSpan" id="kobo.212.2">    logger.LogInformation($"Invoice {id} is loading from the context.");
    invoice = await context.Invoices.FindAsync(id);
    logger.LogInformation($"Invoice {invoice?.Id} is loaded from the context.")
    if (invoice == null)
    {
        return NotFound();
    }
    return invoice;
}</span></pre>
<p><span class="koboSpan" id="kobo.213.1">In the</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.214.1"> preceding code, we added some logging statements to see how EF Core calls the database. </span><span class="koboSpan" id="kobo.214.2">Run the application and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">GetInvoice</span></strong><span class="koboSpan" id="kobo.216.1"> action. </span><span class="koboSpan" id="kobo.216.2">You will see an output in the console </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.218.1">
info: BasicEfCoreDemo.Controllers.InvoicesController[0]      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loading from the database.
</span><span class="koboSpan" id="kobo.218.2">info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (30ms) [Parameters=[@__get_Item_0='?' </span><span class="koboSpan" id="kobo.218.3">(DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loaded from the database.
</span><span class="koboSpan" id="kobo.218.4">info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loading from the context.
</span><span class="koboSpan" id="kobo.218.5">info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loaded from the context.</span></pre>
<p><span class="koboSpan" id="kobo.219.1">When we</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.220.1"> call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">context.Invoices.FindAsync(id)</span></strong><span class="koboSpan" id="kobo.222.1"> method for the first time, EF Core will query the database and return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Invoice</span></strong><span class="koboSpan" id="kobo.224.1"> entity. </span><span class="koboSpan" id="kobo.224.2">The second time, EF Core will return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">Invoice</span></strong><span class="koboSpan" id="kobo.226.1"> entity from the context because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Invoice</span></strong><span class="koboSpan" id="kobo.228.1"> entity is already in </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">the context.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.230.1">Find() versus Single()</span></p>
<p class="callout"><span class="koboSpan" id="kobo.231.1">When we get an entity from the database by its primary key, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Find()</span></strong><span class="koboSpan" id="kobo.233.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.235.1"> methods. </span><span class="koboSpan" id="kobo.235.2">Also, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Single()</span></strong><span class="koboSpan" id="kobo.237.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.239.1"> methods. </span><span class="koboSpan" id="kobo.239.2">They are similar, but they are not the same. </span><span class="koboSpan" id="kobo.239.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Find()</span></strong><span class="koboSpan" id="kobo.241.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.243.1"> methods are methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">DbSet</span></strong><span class="koboSpan" id="kobo.245.1"> class. </span><span class="koboSpan" id="kobo.245.2">If an entity with the given primary key values is being tracked by the context, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Find()</span></strong><span class="koboSpan" id="kobo.247.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.249.1"> methods will return the tracked entity without making a request to the database. </span><span class="koboSpan" id="kobo.249.2">Otherwise, EF Core will make a query to the database to get the entity, attach it to the context, and return it. </span><span class="koboSpan" id="kobo.249.3">But if you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Single()</span></strong><span class="koboSpan" id="kobo.251.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.253.1"> methods, EF Core will always make a query to the database to get the entity. </span><span class="koboSpan" id="kobo.253.2">The same is true for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">First()</span></strong><span class="koboSpan" id="kobo.255.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">FirstOrDefault()</span></strong><span class="koboSpan" id="kobo.257.1"> methods. </span><span class="koboSpan" id="kobo.257.2">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Find()</span></strong><span class="koboSpan" id="kobo.259.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.261.1"> methods are more efficient for getting an entity by its primary key. </span><span class="koboSpan" id="kobo.261.2">But in rare cases, </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Find()</span></strong><span class="koboSpan" id="kobo.263.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.265.1"> may return outdated data if the entity is updated in the database after it is loaded into the context. </span><span class="koboSpan" id="kobo.265.2">For example, if you use the bulk-update </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">ExecuteUpdateAsync()</span></strong><span class="koboSpan" id="kobo.267.1"> method, the update will not be tracked by </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">DbContext</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">Then, if you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Find()</span></strong><span class="koboSpan" id="kobo.271.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.273.1"> to get the entity from </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">DbContext</span></strong><span class="koboSpan" id="kobo.275.1">, you will get the outdated data. </span><span class="koboSpan" id="kobo.275.2">In this case, you should use </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Single()</span></strong><span class="koboSpan" id="kobo.277.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.279.1"> to get the entity from the database again. </span><span class="koboSpan" id="kobo.279.2">In most cases, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Find()</span></strong><span class="koboSpan" id="kobo.281.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">FindAsync()</span></strong><span class="koboSpan" id="kobo.283.1"> methods to get an entity by its primary key when you are sure the entity is always tracked by </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">An entity has</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.288.1"> one of the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">EntityState</span></strong><span class="koboSpan" id="kobo.290.1"> values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Detached</span></strong><span class="koboSpan" id="kobo.292.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Added</span></strong><span class="koboSpan" id="kobo.294.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Unchanged</span></strong><span class="koboSpan" id="kobo.296.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Modified</span></strong><span class="koboSpan" id="kobo.298.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Deleted</span></strong><span class="koboSpan" id="kobo.300.1">. </span><span class="koboSpan" id="kobo.300.2">We introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">EntityState</span></strong><span class="koboSpan" id="kobo.302.1"> enum in </span><a href="B18971_05.xhtml#_idTextAnchor198"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.303.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">The following is how the </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">states change:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.306.1">All the entities that are returned by the query (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Find()</span></strong><span class="koboSpan" id="kobo.308.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Single()</span></strong><span class="koboSpan" id="kobo.310.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">First()</span></strong><span class="koboSpan" id="kobo.312.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">ToList()</span></strong><span class="koboSpan" id="kobo.314.1">, and their </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">async</span></strong><span class="koboSpan" id="kobo.316.1"> overloads) are in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Unchanged</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1"> state</span></span></li>
<li><span class="koboSpan" id="kobo.319.1">If you update the properties of the entity, EF Core will change the state </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Modified</span></strong></span></li>
<li><span class="koboSpan" id="kobo.322.1">If you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Remove()</span></strong><span class="koboSpan" id="kobo.324.1"> method on the entity, EF Core will change the state </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Deleted</span></strong></span></li>
<li><span class="koboSpan" id="kobo.327.1">If you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Add()</span></strong><span class="koboSpan" id="kobo.329.1"> method on the entity, EF Core will change the state </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Added</span></strong></span></li>
<li><span class="koboSpan" id="kobo.332.1">If you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Attach()</span></strong><span class="koboSpan" id="kobo.334.1"> method on the untracked entity, EF Core will track the entity and set the state </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Unchanged</span></strong></span></li>
<li><span class="koboSpan" id="kobo.337.1">If you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Detach()</span></strong><span class="koboSpan" id="kobo.339.1"> method on the tracked entity, EF Core will not track the entity and will change the state </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Detached</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.342.1">Note that EF Core can track the changes at the property level, meaning that if you update a property of an entity, EF Core will only update the property when you call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">SaveChanges</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">To retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">EntityEntry</span></strong><span class="koboSpan" id="kobo.347.1"> object for an entity, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Entry()</span></strong><span class="koboSpan" id="kobo.349.1"> method, which contains the state of the entity and the changed properties. </span><span class="koboSpan" id="kobo.349.2">Use the sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">EfCoreDemo</span></strong><span class="koboSpan" id="kobo.351.1"> project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">/samples/chapter7/EfCoreDemo</span></strong><span class="koboSpan" id="kobo.353.1"> folder. </span><span class="koboSpan" id="kobo.353.2">You can find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">PutInvoice</span></strong><span class="koboSpan" id="kobo.355.1"> action within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">InvoicesController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
context.Entry(invoice).State = EntityState.Modified;await context.SaveChangesAsync();</span></pre>
<p><span class="koboSpan" id="kobo.359.1">In the </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.360.1">preceding code snippet, we obtained the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">EntityEntry</span></strong><span class="koboSpan" id="kobo.362.1"> object for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Invoice</span></strong><span class="koboSpan" id="kobo.364.1"> entity using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">Entry()</span></strong><span class="koboSpan" id="kobo.366.1"> method and set its state to </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Modified</span></strong><span class="koboSpan" id="kobo.368.1">. </span><span class="koboSpan" id="kobo.368.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">SaveChanges()</span></strong><span class="koboSpan" id="kobo.370.1"> is called, EF Core persists the changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">By default, tracking is enabled in EF Core. </span><span class="koboSpan" id="kobo.372.2">However, there may be scenarios where you do not want EF Core to track changes to entities. </span><span class="koboSpan" id="kobo.372.3">For instance, in read-only queries within </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Get</span></strong><span class="koboSpan" id="kobo.374.1"> actions, where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">DbContext</span></strong><span class="koboSpan" id="kobo.376.1"> only exists for the duration of the request, tracking is not necessary. </span><span class="koboSpan" id="kobo.376.2">Disabling tracking can enhance performance and save memory. </span><span class="koboSpan" id="kobo.376.3">If you don’t intend to modify entities, you should disable tracking by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">AsNoTracking()</span></strong><span class="koboSpan" id="kobo.378.1"> method on the query. </span><span class="koboSpan" id="kobo.378.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
// To get the invoice without trackingvar invoice = await context.Invoices.AsNoTracking().FirstOrDefaultAsync(x =&gt; x.Id == id);
// To return a list of invoices without tracking
var invoices = await context.Invoices.AsNoTracking().ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.381.1">If you have lots of read-only queries and you feel it is tedious to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">AsNoTracking()</span></strong><span class="koboSpan" id="kobo.383.1"> method every time, you can disable tracking globally when you configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">DbContext</span></strong><span class="koboSpan" id="kobo.385.1">. </span><span class="koboSpan" id="kobo.385.2">The following code shows how to </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder){
    base.OnConfiguring(optionsBuilder);
    optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
}</span></pre>
<p><span class="koboSpan" id="kobo.388.1">For any other queries that you want to track, you can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">AsTracking()</span></strong><span class="koboSpan" id="kobo.390.1"> method on the query, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
// To get the invoice with trackingvar invoice = await context.Invoices.AsTracking().FirstOrDefaultAsync(x =&gt; x.Id == id);
// To return a list of invoices with tracking
var invoices = await context.Invoices.AsTracking().ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.393.1">In the </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.394.1">preceding code, we explicitly call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">AsTracking()</span></strong><span class="koboSpan" id="kobo.396.1"> method to enable tracking for the query, so that we can update the entity and save the changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the database.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.398.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.399.1">If an entity is a keyless entity, EF Core will never track it. </span><span class="koboSpan" id="kobo.399.2">Keyless entity types do not have keys defined on them. </span><span class="koboSpan" id="kobo.399.3">They are configured by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">[Keyless]</span></strong><span class="koboSpan" id="kobo.401.1"> data annotation or a Fluent API </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">HasNoKey()</span></strong><span class="koboSpan" id="kobo.403.1"> method. </span><span class="koboSpan" id="kobo.403.2">The keyless entity is often used for read-only queries or views. </span><span class="koboSpan" id="kobo.403.3">We will not discuss keyless entities in detail in this book. </span><span class="koboSpan" id="kobo.403.4">You can refer to the official documentation at </span><a href="https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types"><span class="koboSpan" id="kobo.404.1">https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types</span></a><span class="koboSpan" id="kobo.405.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">more information.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Using no-tracking queries is a good way to improve performance for read-only scenarios. </span><span class="koboSpan" id="kobo.407.2">However, keep in mind that if you disable tracking, you will not be able to update the entities when you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">SaveChanges()</span></strong><span class="koboSpan" id="kobo.409.1"> method because EF Core cannot detect changes to untracked entities. </span><span class="koboSpan" id="kobo.409.2">So, it is important to consider the implications of using no-tracking queries before </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">implementing them.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">In addition to non-tracking queries, there are other factors that can affect the performance of data queries in EF Core. </span><span class="koboSpan" id="kobo.411.2">We will explore the differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">IQueryable</span></strong><span class="koboSpan" id="kobo.413.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.415.1"> and how they impact query performance in the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">ne</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.417.1">xt section.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.418.1">Understanding the difference between IQueryable and IEnumerable</span></h1>
<p><span class="koboSpan" id="kobo.419.1">When </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.420.1">working with EF Core, you have two interfaces available to query the database: </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">IQueryable</span></strong><span class="koboSpan" id="kobo.422.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.424.1">. </span><span class="koboSpan" id="kobo.424.2">Although these interfaces may seem similar at first glance, they have important differences that can affect your application’s performance. </span><span class="koboSpan" id="kobo.424.3">In this section, we will discuss the differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">IQueryable</span></strong><span class="koboSpan" id="kobo.426.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.428.1">, how they work, and when to use each </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">You might be familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.432.1"> interface. </span><span class="koboSpan" id="kobo.432.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.434.1"> interface is a standard .NET interface that is used to represent a collection of objects. </span><span class="koboSpan" id="kobo.434.2">It is used to iterate through the collection. </span><span class="koboSpan" id="kobo.434.3">Many .NET collections implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.436.1"> interface, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">List</span></strong><span class="koboSpan" id="kobo.438.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Array</span></strong><span class="koboSpan" id="kobo.440.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Dictionary</span></strong><span class="koboSpan" id="kobo.442.1">, and so on. </span><span class="koboSpan" id="kobo.442.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.444.1"> interface has a single method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">GetEnumerator</span></strong><span class="koboSpan" id="kobo.446.1">, which returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">IEnumerator</span></strong><span class="koboSpan" id="kobo.448.1"> object. </span><span class="koboSpan" id="kobo.448.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">IEnumerator</span></strong><span class="koboSpan" id="kobo.450.1"> object is used to iterate through </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the collection.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">The first difference between </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">IQueryable</span></strong><span class="koboSpan" id="kobo.454.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.456.1"> is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">IQueryable</span></strong><span class="koboSpan" id="kobo.458.1"> is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">System.Linq</span></strong><span class="koboSpan" id="kobo.460.1"> namespace, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.462.1"> is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">System.Collections</span></strong><span class="koboSpan" id="kobo.464.1"> namespace. </span><span class="koboSpan" id="kobo.464.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">IQueryable</span></strong><span class="koboSpan" id="kobo.466.1"> interface inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.468.1"> interface, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">IQueryable</span></strong><span class="koboSpan" id="kobo.470.1"> can do everything that </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.472.1"> does. </span><span class="koboSpan" id="kobo.472.2">But why do we need the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">IQueryable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1"> interface?</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">One of the key differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">IQueryable</span></strong><span class="koboSpan" id="kobo.477.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.479.1"> is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">IQueryable</span></strong><span class="koboSpan" id="kobo.481.1"> is used to query data from a specific data source, such as a database. </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.483.1"> is used to iterate through a collection in memory. </span><span class="koboSpan" id="kobo.483.2">When we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">IQueryable</span></strong><span class="koboSpan" id="kobo.485.1">, the query will be translated into a specific query language, such as SQL, and executed against the data source to get the results when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">ToList()</span></strong><span class="koboSpan" id="kobo.487.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">ToAway()</span></strong><span class="koboSpan" id="kobo.489.1">) method or iterate the items in </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the collection.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">Download the sample code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">/samples/chapter7/EfCoreDemo</span></strong><span class="koboSpan" id="kobo.493.1"> folder in the chapter's GitHub repository. </span><span class="koboSpan" id="kobo.493.2">You can find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">GetInvoices</span></strong><span class="koboSpan" id="kobo.495.1"> action in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">InvoicesController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.497.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">First, let's use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">IQueryable</span></strong><span class="koboSpan" id="kobo.500.1"> interface to query </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
// Use IQueryablelogger.LogInformation($"Creating the IQueryable...");
var list1 = context.Invoices.Where(x =&gt; status == null || x.Status == status);
logger.LogInformation($"IQueryable created");
logger.LogInformation($"Query the result using IQueryable...");
var query1 = list1.OrderByDescending(x =&gt; x.InvoiceDate)
    .Skip((page - 1) * pageSize)
    .Take(pageSize);
logger.LogInformation($"Execute the query using IQueryable");
var result1 = await query1.ToListAsync();
logger.LogInformation($"Result created using IQueryable");</span></pre>
<p><span class="koboSpan" id="kobo.503.1">In the </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.504.1">preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">context.Invoices</span></strong><span class="koboSpan" id="kobo.506.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">DbSet&lt;TEntity&gt;</span></strong><span class="koboSpan" id="kobo.508.1"> object, which implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">IQueryable</span></strong><span class="koboSpan" id="kobo.510.1"> interface. </span><span class="koboSpan" id="kobo.510.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">Where()</span></strong><span class="koboSpan" id="kobo.512.1"> method is used to filter the invoices by status, and returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">IQueryable</span></strong><span class="koboSpan" id="kobo.514.1"> object. </span><span class="koboSpan" id="kobo.514.2">Then, we use some other methods to sort and paginate the invoices. </span><span class="koboSpan" id="kobo.514.3">When we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">ToListAsync()</span></strong><span class="koboSpan" id="kobo.516.1"> method, the query will be translated into a SQL query and executed against the database to get the results. </span><span class="koboSpan" id="kobo.516.2">The logs show the execution order of </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.518.1">
info: BasicEfCoreDemo.Controllers.InvoicesController[0]      Creating the IQueryable...
</span><span class="koboSpan" id="kobo.518.2">info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      IQueryable created
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Query the result using IQueryable...
</span><span class="koboSpan" id="kobo.518.3">info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Execute the query using IQueryable
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (49ms) [Parameters=[@__p_0='?' </span><span class="koboSpan" id="kobo.518.4">(DbType = Int32), @__p_1='?' </span><span class="koboSpan" id="kobo.518.5">(DbType = Int32)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      ORDER BY [i].[InvoiceDate] DESC
      OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Result created using IQueryable</span></pre>
<p><span class="koboSpan" id="kobo.519.1">From the logs, we</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.520.1"> can see that the query is executed against the database when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">ToListAsync()</span></strong><span class="koboSpan" id="kobo.522.1"> method. </span><span class="koboSpan" id="kobo.522.2">The query contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">ORDER BY</span></strong><span class="koboSpan" id="kobo.524.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">OFFSET</span></strong><span class="koboSpan" id="kobo.526.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">FETCH NEXT</span></strong><span class="koboSpan" id="kobo.528.1"> clauses, which means the query is executed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">database server.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">Next, let us use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.532.1"> interface to query </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
// Use IEnumerablelogger.LogInformation($"Creating the IEnumerable...");
var list2 = context.Invoices.Where(x =&gt; status == null || x.Status == status).AsEnumerable();
logger.LogInformation($"IEnumerable created");
logger.LogInformation($"Query the result using IEnumerable...");
var query2 = list2.OrderByDescending(x =&gt; x.InvoiceDate)
    .Skip((page - 1) * pageSize)
    .Take(pageSize);
logger.LogInformation($"Execute the query using IEnumerable");
var result2 = query2.ToList();
logger.LogInformation($"Result created using IEnumerable");</span></pre>
<p><span class="koboSpan" id="kobo.535.1">In the </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.536.1">preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">AsEnumerable()</span></strong><span class="koboSpan" id="kobo.538.1"> method to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">IQueryable</span></strong><span class="koboSpan" id="kobo.540.1"> object to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.542.1"> object. </span><span class="koboSpan" id="kobo.542.2">Then, we sort and paginate the invoices and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">ToList()</span></strong><span class="koboSpan" id="kobo.544.1"> method to get the results. </span><span class="koboSpan" id="kobo.544.2">The logs show the execution order of </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
info: BasicEfCoreDemo.Controllers.InvoicesController[0]      Creating the IEnumerable...
</span><span class="koboSpan" id="kobo.546.2">info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      IEnumerable created
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Query the result  using IEnumerable...
</span><span class="koboSpan" id="kobo.546.3">info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Execute the query using IEnumerable
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Result created using IEnumerable</span></pre>
<p><span class="koboSpan" id="kobo.547.1">Look at the logs. </span><span class="koboSpan" id="kobo.547.2">The generated SQL query does not contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">ORDER BY</span></strong><span class="koboSpan" id="kobo.549.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">OFFSET</span></strong><span class="koboSpan" id="kobo.551.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">FETCH NEXT</span></strong><span class="koboSpan" id="kobo.553.1"> clauses, which means the query fetched all the invoices from the database and then filtered, sorted, and paged the invoices in memory. </span><span class="koboSpan" id="kobo.553.2">If we have a large number of entities in the database, the second query will be very slow </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">and inefficient.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">Now, we can see the difference between the two interfaces. </span><span class="koboSpan" id="kobo.555.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">IQueryable</span></strong><span class="koboSpan" id="kobo.557.1"> interface is a deferred execution query, which means the query is not executed when we add </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.558.1">more conditions to the query. </span><span class="koboSpan" id="kobo.558.2">The query will be executed against the database when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">ToList()</span></strong><span class="koboSpan" id="kobo.560.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">ToArray()</span></strong><span class="koboSpan" id="kobo.562.1"> methods or iterate the items in the collection. </span><span class="koboSpan" id="kobo.562.2">So, in complex and heavy queries, we should always use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">IQueryable</span></strong><span class="koboSpan" id="kobo.564.1"> interface to avoid fetching all the data from the database. </span><span class="koboSpan" id="kobo.564.2">Be careful when you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">ToList()</span></strong><span class="koboSpan" id="kobo.566.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ToArray()</span></strong><span class="koboSpan" id="kobo.568.1"> methods because </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">ToList()</span></strong><span class="koboSpan" id="kobo.570.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">ToArray()</span></strong><span class="koboSpan" id="kobo.572.1"> (and their </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">async</span></strong><span class="koboSpan" id="kobo.574.1"> overloads) will execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">query immediately.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.576.1">What LINQ methods can cause the query to be executed immediately?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.577.1">There are a couple of operations that result in the query being </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">executed immediately:</span></span></p>
<ul>
<li class="callout"><span class="koboSpan" id="kobo.579.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">for</span></strong><span class="koboSpan" id="kobo.581.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">foreach</span></strong><span class="koboSpan" id="kobo.583.1"> loop to iterate the items in </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">the collection</span></span></li>
<li class="callout"><span class="koboSpan" id="kobo.585.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">ToList()</span></strong><span class="koboSpan" id="kobo.587.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">ToArray()</span></strong><span class="koboSpan" id="kobo.589.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">Single()</span></strong><span class="koboSpan" id="kobo.591.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">SingleOrDefault()</span></strong><span class="koboSpan" id="kobo.593.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">First()</span></strong><span class="koboSpan" id="kobo.595.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">FirstOrDefault()</span></strong><span class="koboSpan" id="kobo.597.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Count()</span></strong><span class="koboSpan" id="kobo.599.1"> methods, or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">async</span></strong><span class="koboSpan" id="kobo.601.1"> overloads of </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">these methods</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.603.1">In this section, we explored the differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">IQueryable</span></strong><span class="koboSpan" id="kobo.605.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.607.1">. </span><span class="koboSpan" id="kobo.607.2">It is important to understand why we should use </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">IQueryable</span></strong><span class="koboSpan" id="kobo.609.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.611.1"> when querying the database for complex and heavy queries. </span><span class="koboSpan" id="kobo.611.2">Loading all the data from the database can cause performance issues if there are a large number of entities in </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">Moving on, we will discuss another factor that can affect performance: </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">c</span><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.615.1">lient evaluation.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.616.1">Client evaluation versus server evaluation</span></h1>
<p><span class="koboSpan" id="kobo.617.1">In this section, we</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.618.1"> will discuss the difference between client evaluation and server evaluation. </span><span class="koboSpan" id="kobo.618.2">In the old versions of EF Core (earlier than EF Core 3.0), the wrong usage of LINQ queries that have client evaluation can cause significant performance issues. </span><span class="koboSpan" id="kobo.618.3">Let's see what client evaluation and server </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">evaluation are.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">When we use EF Core to query data from the database, we can just write LINQ queries, and EF Core will translate the LINQ queries into SQL queries and execute them against the database. </span><span class="koboSpan" id="kobo.620.2">However, sometimes, the LINQ operation must be executed</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.621.1"> on the client side. </span><span class="koboSpan" id="kobo.621.2">Check the following code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">SearchInvoices</span></strong><span class="koboSpan" id="kobo.623.1"> action method in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">InvoicesController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.625.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
var list = await context.Invoices    .Where(x =&gt; x.ContactName.Contains(search) || x.InvoiceNumber.Contains(search))
    .ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.627.1">When we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">Contains()</span></strong><span class="koboSpan" id="kobo.629.1"> method, EF Core can translate the LINQ query into the following </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">SQL query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.631.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (4ms) [Parameters=[@__search_0='?' </span><span class="koboSpan" id="kobo.631.2">(Size = 32), @__search_0_1='?' </span><span class="koboSpan" id="kobo.631.3">(Size = 32) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE (@__search_0 LIKE N'') OR CHARINDEX(@__search_0, [i].[ContactName]) &gt; 0 OR (@__search_0_1 LIKE '') OR CHARINDEX(@__search_0, [i].[InvoiceNumber]) &gt; 0</span></pre>
<p><span class="koboSpan" id="kobo.632.1">You can see that the SQL query uses some native SQL functions to filter the data, which means that the SQL query is executed on the database server.  </span><span class="koboSpan" id="kobo.632.2">This is called </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">server evaluation</span></strong><span class="koboSpan" id="kobo.634.1">. </span><span class="koboSpan" id="kobo.634.2">EF Core tries to run server evaluation as much </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">Now, let's say we want to return the GST tax amount for each invoice. </span><span class="koboSpan" id="kobo.636.2">We can transfer the entity to a new object with the GST tax amount. </span><span class="koboSpan" id="kobo.636.3">Of course, the better way is to add a property for the tax in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">Invoice</span></strong><span class="koboSpan" id="kobo.638.1"> entity. </span><span class="koboSpan" id="kobo.638.2">The following is a demonstration of how to </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">static</span></strong><span class="koboSpan" id="kobo.642.1"> method to calculate the GST </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">tax amount:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.644.1">
private static decimal CalculateTax(decimal amount){
    return amount * 0.15m;
}</span></pre>
<p><span class="koboSpan" id="kobo.645.1">Update</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.646.1"> the code </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
var list = await context.Invoices    .Where(x =&gt; x.ContactName.Contains(search) || x.InvoiceNumber.Contains(search))
    .Select(x =&gt; new Invoice
    {
        Id = x.Id,
        InvoiceNumber = x.InvoiceNumber,
        ContactName = x.ContactName,
        Description = $"Tax: ${CalculateTax(x.Amount)}. </span><span class="koboSpan" id="kobo.648.2">{x.Description}",
        Amount = x.Amount,
        InvoiceDate = x.InvoiceDate,
        DueDate = x.DueDate,
        Status = x.Status
    })
    .ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.649.1">We updated the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">Description</span></strong><span class="koboSpan" id="kobo.651.1"> property by adding the GST tax calculation. </span><span class="koboSpan" id="kobo.651.2">When we run the application and call the endpoint, we will see the generated SQL query is the same as the previous query. </span><span class="koboSpan" id="kobo.651.3">But the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">Description</span></strong><span class="koboSpan" id="kobo.653.1"> property has been updated in the result. </span><span class="koboSpan" id="kobo.653.2">This means the conversion is done on the client side. </span><span class="koboSpan" id="kobo.653.3">This is called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.654.1">client evaluation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">This kind of client evaluation is acceptable because the query does need to fetch the data from the database. </span><span class="koboSpan" id="kobo.656.2">The cost is very low. </span><span class="koboSpan" id="kobo.656.3">However, it might cause problems for some queries. </span><span class="koboSpan" id="kobo.656.4">For example, we want to query the invoices that have a GST tax amount greater than $10. </span><span class="koboSpan" id="kobo.656.5">Update the code </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
var list = await context.Invoices    .Where(x =&gt; (x.ContactName.Contains(search) || x.InvoiceNumber.Contains(search)) &amp;&amp; CalculateTax(x.Amount) &gt; 10)
    .ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.659.1">When </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.660.1">we call the endpoint, we will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">following error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.662.1">
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]      An unhandled exception has occurred while executing the request.
</span><span class="koboSpan" id="kobo.662.2">      System.InvalidOperationException: The LINQ expression 'DbSet&lt;Invoice&gt;()
          .Where(i =&gt; i.ContactName.Contains(__search_0) || i.InvoiceNumber.Contains(__search_0) &amp;&amp; InvoicesController.CalculateTax(i.Amount) &gt; 10)' could not be translated. </span><span class="koboSpan" id="kobo.662.3">Additional information: Translation of method 'BasicEfCoreDemo.Controllers.InvoicesController.CalculateTax' failed. </span><span class="koboSpan" id="kobo.662.4">If this method can be mapped to your custom function, see https://go.microsoft.com/fwlink/?linkid=2132413 for more information. </span><span class="koboSpan" id="kobo.662.5">Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable', 'AsAsyncEnumerable', 'ToList', or 'ToListAsync'. </span><span class="koboSpan" id="kobo.662.6">See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.</span></pre>
<p><span class="koboSpan" id="kobo.663.1">The error message is very clear. </span><span class="koboSpan" id="kobo.663.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">CalculateTax()</span></strong><span class="koboSpan" id="kobo.665.1"> method is not supported by EF Core. </span><span class="koboSpan" id="kobo.665.2">In old versions of EF Core (earlier than EF Core 3.0), EF Core will fetch all the data from the database and then filter the data in memory. </span><span class="koboSpan" id="kobo.665.3">It could cause performance issues. </span><span class="koboSpan" id="kobo.665.4">After EF Core 3.0, EF Core will throw an exception if the query cannot be translated correctly, to avoid potential </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">performance issues.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">But if you</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.668.1"> are sure the client evaluation is safe, such as when dealing with a small data size, you can explicitly use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">AsEnumerable()</span></strong><span class="koboSpan" id="kobo.670.1"> method (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">AsAsyncEnumerable()</span></strong><span class="koboSpan" id="kobo.672.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">ToList()</span></strong><span class="koboSpan" id="kobo.674.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">ToListAsync()</span></strong><span class="koboSpan" id="kobo.676.1">) to force EF Core to fetch all the data and then execute the query on the client side. </span><span class="koboSpan" id="kobo.676.2">Make sure you know what you </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">are doing.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.678.1">Why must the CalculateTax() method be static?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.679.1">EF Core caches the compiled query due to the expensive nature of compiling the query. </span><span class="koboSpan" id="kobo.679.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">CalculateTax()</span></strong><span class="koboSpan" id="kobo.681.1"> method is not static, EF Core will need to maintain a reference to a constant expression of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.683.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">CalculateTax()</span></strong><span class="koboSpan" id="kobo.685.1"> instance method, which could potentially lead to memory leaks. </span><span class="koboSpan" id="kobo.685.2">To prevent this, EF Core throws an exception if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">CalculateTax()</span></strong><span class="koboSpan" id="kobo.687.1"> method is not static. </span><span class="koboSpan" id="kobo.687.2">Making the method static will ensure that EF Core does not capture constant in </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">the instance.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">The latest version of EF Core offers the benefit of preventing potential performance issues caused by client evaluation. </span><span class="koboSpan" id="kobo.689.2">If you encounter an exception similar to a previous one, you can review the query to ensure it is being </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">translated correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">Next, we will discuss how to use raw SQL queries in EF Core. </span><span class="koboSpan" id="kobo.691.2">For some scenarios, we need to write raw SQL queries to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">complex queries.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.693.1">Using raw SQL queries</span></h1>
<p><span class="koboSpan" id="kobo.694.1">Although</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.695.1"> EF Core can translate most LINQ queries into SQL queries, which is very convenient, sometimes we need to write raw SQL queries if the required query cannot be written in LINQ, or the generated SQL query is not efficient. </span><span class="koboSpan" id="kobo.695.2">In this section, we will explore how to use raw SQL queries in </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">EF Core.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">EF Core provides several methods to execute raw </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">SQL queries:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">FromSql()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">FromSqlRaw()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">SqlQuery()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">SqlQueryRaw()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">ExecuteSql()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">ExecuteSqlRaw()</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.705.1">When we</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.706.1"> execute raw SQL queries, we must be careful to avoid SQL injection attacks. </span><span class="koboSpan" id="kobo.706.2">Let's see when we should use raw SQL queries and how to use them properly. </span><span class="koboSpan" id="kobo.706.3">You can download the sample code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">/samples/chapter7/EfCoreDemo</span></strong><span class="koboSpan" id="kobo.708.1"> folder in the chapter's </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">GitHub repository.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.710.1">FromSql() and FromSqlRaw()</span></h2>
<p><span class="koboSpan" id="kobo.711.1">We can</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.712.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">FromSql()</span></strong><span class="koboSpan" id="kobo.714.1"> method to create a LINQ query based on an interpolated string. </span><span class="koboSpan" id="kobo.714.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">FromSql()</span></strong><span class="koboSpan" id="kobo.716.1"> method is available in EF Core 7.0 and later versions. </span><span class="koboSpan" id="kobo.716.2">There is a similar method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">FromSqlInterpolated()</span></strong><span class="koboSpan" id="kobo.718.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">older versions.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">To execute the raw SQL query, we</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.721.1"> just need to pass the interpolated string to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">FromSql()</span></strong><span class="koboSpan" id="kobo.723.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.725.1">
var list = await context.Invoices    .FromSql($"SELECT * FROM Invoices WHERE Status = 2")
    .ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.726.1">We can also pass parameters to the raw SQL query. </span><span class="koboSpan" id="kobo.726.2">For example, we want to query the invoices that have a </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">specific status:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.728.1">
[HttpGet][Route("status")]
public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(string status)
{
    // Omitted for brevity
    var list = await context.Invoices
        .FromSql($"SELECT * FROM Invoices WHERE Status = {status}")
        .ToListAsync();
    return list;
}</span></pre>
<p><span class="koboSpan" id="kobo.729.1">Wait, is it</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.730.1"> safe to insert a string into the SQL query directly? </span><span class="koboSpan" id="kobo.730.2">What if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">status</span></strong><span class="koboSpan" id="kobo.732.1"> parameter is </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">'; DROP TABLE Invoices; --</span></strong><span class="koboSpan" id="kobo.734.1">? </span><span class="koboSpan" id="kobo.734.2">Will it cause a SQL </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">injection attack?</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">That is a</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.737.1"> good question. </span><span class="koboSpan" id="kobo.737.2">Let us see how EF Core handles the parameters. </span><span class="koboSpan" id="kobo.737.3">Run the application and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">/api/invoices/status?status=AwaitPayment</span></strong><span class="koboSpan" id="kobo.739.1"> endpoint. </span><span class="koboSpan" id="kobo.739.2">We will see the generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.741.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (41ms) [Parameters=[p0='?' </span><span class="koboSpan" id="kobo.741.2">(Size = 4000)], CommandType='Text', CommandTimeout='30']
      SELECT * FROM Invoices WHERE Status = @p0</span></pre>
<p><span class="koboSpan" id="kobo.742.1">The parameter is not inserted into the SQL query directly. </span><span class="koboSpan" id="kobo.742.2">Instead, EF Core uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">@p0</span></strong><span class="koboSpan" id="kobo.744.1"> parameter placeholder and passes the parameter value to the SQL query. </span><span class="koboSpan" id="kobo.744.2">This is called a parameterized query. </span><span class="koboSpan" id="kobo.744.3">It is safe to use the parameterized query to avoid SQL injection attacks. </span><span class="koboSpan" id="kobo.744.4">So, we do not need to worry about the safety of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">FromSql</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.746.1"> method.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.747.1">Why FromSql() is safe to use</span></p>
<p class="callout"><span class="koboSpan" id="kobo.748.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">FromSql()</span></strong><span class="koboSpan" id="kobo.750.1"> method expects a parameter as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">FormattableString</span></strong><span class="koboSpan" id="kobo.752.1"> type. </span><span class="koboSpan" id="kobo.752.2">So, it is required to use the interpolated string syntax by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">$</span></strong><span class="koboSpan" id="kobo.754.1"> prefix. </span><span class="koboSpan" id="kobo.754.2">The syntax looks like regular C# string interpolation, but it is not the same thing. </span><span class="koboSpan" id="kobo.754.3">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">FormattableString</span></strong><span class="koboSpan" id="kobo.756.1"> type can include interpolated parameter placeholders. </span><span class="koboSpan" id="kobo.756.2">The interpolated parameter values will be automatically converted to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">DbParameter</span></strong><span class="koboSpan" id="kobo.758.1"> type. </span><span class="koboSpan" id="kobo.758.2">So, it is safe to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">FromSql()</span></strong><span class="koboSpan" id="kobo.760.1"> method to avoid SQL </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">injection attacks.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">For some scenarios, we might need to build dynamic SQL queries. </span><span class="koboSpan" id="kobo.762.2">For example, we want to query the invoices according to user input, which specifies the property name and property value. </span><span class="koboSpan" id="kobo.762.3">For this case, we cannot use </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">FromSql</span></strong><span class="koboSpan" id="kobo.764.1"> because it is not allowed to </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.765.1">parameterize the column names. </span><span class="koboSpan" id="kobo.765.2">We need to </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.766.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">FromSqlRaw</span></strong><span class="koboSpan" id="kobo.768.1"> instead. </span><span class="koboSpan" id="kobo.768.2">However, we must be careful to avoid SQL injection attacks. </span><span class="koboSpan" id="kobo.768.3">It is the developer’s responsibility to make sure the SQL query is safe. </span><span class="koboSpan" id="kobo.768.4">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.770.1">
[HttpGet][Route("free-search")]
public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(string propertyName, string propertyValue)
{
    if (context.Invoices == null)
    {
        return NotFound();
    }
    // Do something to sanitize the propertyName value
    var value = new SqlParameter("value", propertyValue);
    var list = await context.Invoices
        .FromSqlRaw($"SELECT * FROM Invoices WHERE {propertyName} = @value", value)
        .ToListAsync();
    return list;
}</span></pre>
<p><span class="koboSpan" id="kobo.771.1">In the preceding example, the column name is not parameterized. </span><span class="koboSpan" id="kobo.771.2">Therefore, we must be careful to avoid SQL injection attacks. </span><span class="koboSpan" id="kobo.771.3">It is required to sanitize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">propertyName</span></strong><span class="koboSpan" id="kobo.773.1"> value to make sure it is safe. </span><span class="koboSpan" id="kobo.773.2">Maybe you can check whether the value contains any special characters, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">;</span></strong><span class="koboSpan" id="kobo.775.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">--</span></strong><span class="koboSpan" id="kobo.777.1">, and so on. </span><span class="koboSpan" id="kobo.777.2">If the value contains any special characters, you can throw an exception or remove the special characters before executing the SQL query. </span><span class="koboSpan" id="kobo.777.3">Also, if you allow the user to specify the column name, it will increase the effort to validate the column name because you need to check whether the column </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.778.1">name exists in the database or whether the column has the correct index. </span><span class="koboSpan" id="kobo.778.2">Make sure you know what you </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">are doing.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">propertyValue</span></strong><span class="koboSpan" id="kobo.782.1"> is parameterized, so it is safe </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">After you </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.785.1">build the SQL query using </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">FromSql()</span></strong><span class="koboSpan" id="kobo.787.1">, you can then apply the LINQ query operators to filter the data as you want. </span><span class="koboSpan" id="kobo.787.2">Remember that it is better to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">FromSql()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.789.1">than </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">FromSqlRaw()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.792.1">When we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">FromSql()</span></strong><span class="koboSpan" id="kobo.794.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">FromSqlRaw()</span></strong><span class="koboSpan" id="kobo.796.1"> methods, keep in mind that there are </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">some limitations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.798.1">The data returned from the SQL query must contain all the properties of the entity, otherwise, EF Core cannot map the data to </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">the entity.</span></span></li>
<li><span class="koboSpan" id="kobo.800.1">The column names returned from the SQL query must match the column names that the entity properties are </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">mapped to.</span></span></li>
<li><span class="koboSpan" id="kobo.802.1">The SQL query can only query one table. </span><span class="koboSpan" id="kobo.802.2">If you need to query multiple tables, you can build the raw query first and then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">Include()</span></strong><span class="koboSpan" id="kobo.804.1"> method t</span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.805.1">o include the </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">related entities.</span></span></li>
</ul>
<h2 id="_idParaDest-149"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.807.1">SqlQuery() and SqlQueryRaw()</span></h2>
<p><span class="koboSpan" id="kobo.808.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">FromSql()</span></strong><span class="koboSpan" id="kobo.810.1"> method is</span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.811.1"> useful when we want to </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.812.1">query entities from the database using a raw SQL query. </span><span class="koboSpan" id="kobo.812.2">For some cases, we want to execute the raw SQL query and return a scalar value or non-entity type. </span><span class="koboSpan" id="kobo.812.3">For example, we want to query the IDs of invoices that have a specific status. </span><span class="koboSpan" id="kobo.812.4">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">SqlQuery()</span></strong><span class="koboSpan" id="kobo.814.1"> method to execute the raw SQL query and return a list of IDs. </span><span class="koboSpan" id="kobo.814.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
[HttpGet][Route("ids")]
public ActionResult&lt;IEnumerable&lt;Guid&gt;&gt; GetInvoicesIds(string status)
{
    var result = context.Database
        .SqlQuery&lt;Guid&gt;($"SELECT Id FROM Invoices WHERE Status = {status}")
        .ToList();
    return result;
}</span></pre>
<p><span class="koboSpan" id="kobo.817.1">The </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.818.1">translated SQL </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.819.1">query is </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.821.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (22ms) [Parameters=[p0='?' </span><span class="koboSpan" id="kobo.821.2">(Size = 4000)], CommandType='Text', CommandTimeout='30']
      SELECT Id FROM Invoices WHERE Status = @p0</span></pre>
<p><span class="koboSpan" id="kobo.822.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">SqlQuery()</span></strong><span class="koboSpan" id="kobo.824.1"> method is used on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">Database</span></strong><span class="koboSpan" id="kobo.826.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">DbContext</span></strong><span class="koboSpan" id="kobo.828.1"> object. </span><span class="koboSpan" id="kobo.828.2">It is not available on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">DbSet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.830.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.831.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">SqlQueryRaw()</span></strong><span class="koboSpan" id="kobo.833.1"> method</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.834.1"> is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">SqlQuery()</span></strong><span class="koboSpan" id="kobo.836.1"> method, but </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.837.1">it allows us to build dynamic SQL queries like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">FromSqlRaw()</span></strong><span class="koboSpan" id="kobo.839.1"> method. </span><span class="koboSpan" id="kobo.839.2">Similarly, you must take responsib</span><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.840.1">ility to avoid SQL </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">injection attacks.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.842.1">ExecuteSql() and ExecuteSqlRaw()</span></h2>
<p><span class="koboSpan" id="kobo.843.1">For some </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.844.1">scenarios, where</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.845.1"> we do not need return values, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">ExecuteSql</span></strong><span class="koboSpan" id="kobo.847.1"> method to execute a raw SQL query. </span><span class="koboSpan" id="kobo.847.2">Normally, it is used to update or delete data or call</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.848.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.849.1">stored procedure</span></strong><span class="koboSpan" id="kobo.850.1">. </span><span class="koboSpan" id="kobo.850.2">For example, when we need to delete all invoices that have a specific status, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">ExecuteSql()</span></strong><span class="koboSpan" id="kobo.852.1"> method to execute the raw SQL query. </span><span class="koboSpan" id="kobo.852.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.854.1">
[HttpDelete][Route("status")]
public async Task&lt;ActionResult&gt; DeleteInvoices(string status)
{
    var result = await context.Database
        .ExecuteSqlAsync($"DELETE FROM Invoices WHERE Status = {status}");
    return Ok();
}</span></pre>
<p><span class="koboSpan" id="kobo.855.1">In this way, we </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.856.1">do not need to load the entities </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.857.1">from the database and then delete them one by one. </span><span class="koboSpan" id="kobo.857.2">It is much more efficient to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">ExecuteSql()</span></strong><span class="koboSpan" id="kobo.859.1"> method to execute the raw </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">SQL query.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">ExecuteSqlRaw()</span></strong><span class="koboSpan" id="kobo.863.1"> method is</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.864.1"> similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">ExecuteSql()</span></strong><span class="koboSpan" id="kobo.866.1"> method, but</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.867.1"> it allows us to build dynamic SQL queries like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">FromSqlRaw()</span></strong><span class="koboSpan" id="kobo.869.1"> method. </span><span class="koboSpan" id="kobo.869.2">Similarly, you must be very careful to sanitize the SQL query to avoid SQL </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">injection attacks.</span></span></p>
<p><span class="koboSpan" id="kobo.871.1">In this section, we introduced how to use raw SQL queries in EF Core. </span><span class="koboSpan" id="kobo.871.2">We discussed the differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">FromSql()</span></strong><span class="koboSpan" id="kobo.873.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">FromSqlRaw()</span></strong><span class="koboSpan" id="kobo.875.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">SqlQuery()</span></strong><span class="koboSpan" id="kobo.877.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">SqlQueryRaw()</span></strong><span class="koboSpan" id="kobo.879.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">ExecuteSql()</span></strong><span class="koboSpan" id="kobo.881.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">ExecuteSqlRaw()</span></strong><span class="koboSpan" id="kobo.883.1">. </span><span class="koboSpan" id="kobo.883.2">We also discussed the limitations of these methods. </span><span class="koboSpan" id="kobo.883.3">Again, we must be very careful to avoid SQL injection attacks when we use raw </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">SQL queries.</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">In one of the examples in this section, we showed you how to run a raw SQL query to delete a set of entities. </span><span class="koboSpan" id="kobo.885.2">EF Core 7.0 introduces a bulk operations feature that can make this easier. </span><span class="koboSpan" id="kobo.885.3">There are two new methods available for bulk operations, </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">ExecuteUpdate()</span></strong><span class="koboSpan" id="kobo.887.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">ExecuteDelete()</span></strong><span class="koboSpan" id="kobo.889.1">, which provide a more efficient way to update or delete data. </span><span class="koboSpan" id="kobo.889.2">In the following section, </span><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.890.1">we will discuss this feature in </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">more detail.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.892.1">Using bulk operations</span></h1>
<p><span class="koboSpan" id="kobo.893.1">In this </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.894.1">section, we will explore how to effectively update/delete data using EF Core. </span><span class="koboSpan" id="kobo.894.2">EF Core 7.0 or later offers the ability of bulk operations, which are easy to use and can improve the performance of update/delete operations. </span><span class="koboSpan" id="kobo.894.3">To take advantage of this feature, ensure you are using the most recent version of </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">EF Core.</span></span></p>
<p><span class="koboSpan" id="kobo.896.1">As we mentioned in the previous section, EF Core tracks the changes in entities. </span><span class="koboSpan" id="kobo.896.2">To update an entity, normally, we need to load the entity from the database, update the entity properties, and then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">SaveChanges()</span></strong><span class="koboSpan" id="kobo.898.1"> method to save the changes to the database. </span><span class="koboSpan" id="kobo.898.2">This is a very common scenario. </span><span class="koboSpan" id="kobo.898.3">Deleting an entity is similar. </span><span class="koboSpan" id="kobo.898.4">However, if we want to update or delete a large number of entities, it is not efficient to load the entities one by one and then update or delete them. </span><span class="koboSpan" id="kobo.898.5">For these scenarios, it is not required to track the changes in the entities. </span><span class="koboSpan" id="kobo.898.6">So, it would be better to use the bulk operations feature to update or </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">delete data.</span></span></p>
<p><span class="koboSpan" id="kobo.900.1">We can use a raw SQL query to update or delete data using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">ExecuteSql()</span></strong><span class="koboSpan" id="kobo.902.1"> method. </span><span class="koboSpan" id="kobo.902.2">However, it lacks strong type support. </span><span class="koboSpan" id="kobo.902.3">Hardcoding the column names in the SQL query is not a good practice. </span><span class="koboSpan" id="kobo.902.4">From EF Core 7.0, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">ExecuteUpdate()</span></strong><span class="koboSpan" id="kobo.904.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">ExecuteDelete()</span></strong><span class="koboSpan" id="kobo.906.1"> methods to update or delete data. </span><span class="koboSpan" id="kobo.906.2">Note that these two methods do not involve the entity tracking feature. </span><span class="koboSpan" id="kobo.906.3">So, once you call these two methods, the changes will be executed immediately. </span><span class="koboSpan" id="kobo.906.4">There is no need to call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">SaveChanges()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.908.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">Next, let us see how to use these two methods. </span><span class="koboSpan" id="kobo.909.2">We will show you how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">ExecuteUpdate()</span></strong><span class="koboSpan" id="kobo.911.1"> method and what SQL query is generated. </span><span class="koboSpan" id="kobo.911.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">ExecuteDelete()</span></strong><span class="koboSpan" id="kobo.913.1"> method is similar. </span><span class="koboSpan" id="kobo.913.2">The sample code is located at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">/samples/chapter7/EfCoreDemo</span></strong><span class="koboSpan" id="kobo.915.1"> folder in the chapter's </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">GitHub repository.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.917.1">ExecuteUpdate()</span></h2>
<p><span class="koboSpan" id="kobo.918.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">ExecuteUpdate()</span></strong><span class="koboSpan" id="kobo.920.1"> method </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.921.1">is used to update data without loading the entities from the database. </span><span class="koboSpan" id="kobo.921.2">You can use it to update one or more entities by adding the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">Where()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.923.1"> clause.</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">For example, we want to update the status of the invoices that were created before a specific date. </span><span class="koboSpan" id="kobo.924.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.926.1">
[HttpPut][Route("status/overdue")]
public async Task&lt;ActionResult&gt; UpdateInvoicesStatusAsOverdue(DateTime date)
{
    var result = await context.Invoices
        .Where(i =&gt; i.InvoiceDate &lt; date &amp;&amp; i.Status == InvoiceStatus.AwaitPayment)
        .ExecuteUpdateAsync(s =&gt; s.SetProperty(x =&gt; x.Status, InvoiceStatus.Overdue));
    return Ok();
}</span></pre>
<p><span class="koboSpan" id="kobo.927.1">The generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.929.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (46ms) [Parameters=[@__p_0='?' </span><span class="koboSpan" id="kobo.929.2">(DbType = DateTimeOffset)], CommandType='Text', CommandTimeout='30']
      UPDATE [i]
      SET [i].[Status] = 'Overdue'
      FROM [Invoices] AS [i]
      WHERE [i].[InvoiceDate] &lt; @__p_0 AND [i].[Status] = 'AwaitPayment'</span></pre>
<p><span class="koboSpan" id="kobo.930.1">This query can update multiple invoices at the same time. </span><span class="koboSpan" id="kobo.930.2">It does benefit from the strong type support but has the same efficiency as the raw SQL query. </span><span class="koboSpan" id="kobo.930.3">If you need to update more </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.931.1">than one property, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">SetProperty()</span></strong><span class="koboSpan" id="kobo.933.1"> method multiple times, as seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.935.1">
var result = await context.Invoices        .Where(i =&gt; i.InvoiceDate &lt; date &amp;&amp; i.Status == InvoiceStatus.AwaitPayment)
        .ExecuteUpdateAsync(s =&gt;
            s.SetProperty(x =&gt; x.Status, InvoiceStatus.Overdue)
            .SetProperty(x =&gt; x.LastUpdatedDate, DateTime.Now));</span></pre>
<p><span class="koboSpan" id="kobo.936.1">In addition, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">Where()</span></strong><span class="koboSpan" id="kobo.938.1"> clause can reference the other entities. </span><span class="koboSpan" id="kobo.938.2">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">ExecuteUpdate()</span></strong><span class="koboSpan" id="kobo.940.1"> method is always recommended to update multipl</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.941.1">e entities, instead of using the raw </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">SQL query.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.943.1">ExecuteDelete()</span></h2>
<p><span class="koboSpan" id="kobo.944.1">Similarly, we </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.945.1">can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">ExecuteDelete()</span></strong><span class="koboSpan" id="kobo.947.1"> method to delete data without loading the entities from the database. </span><span class="koboSpan" id="kobo.947.2">This method can be used to delete one or more entities by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">Where</span></strong><span class="koboSpan" id="kobo.949.1"> clause. </span><span class="koboSpan" id="kobo.949.2">For example, we want to delete the invoices that were created before a specific date. </span><span class="koboSpan" id="kobo.949.3">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.951.1">
await context.Invoices.Where(x =&gt; x.InvoiceDate &lt; date).ExecuteDeleteAsync();</span></pre> <p><span class="koboSpan" id="kobo.952.1">Again, these bulk operations do not track the changes in the entities. </span><span class="koboSpan" id="kobo.952.2">If a </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">DbContext</span></strong><span class="koboSpan" id="kobo.954.1"> instance already loaded the entities, after the bulk update or delete, the entities in the context will still keep the old values. </span><span class="koboSpan" id="kobo.954.2">So, be careful when using these </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">bulk operations.</span></span></p>
<p><span class="koboSpan" id="kobo.956.1">In this section, we discussed how to use the bulk operations feature in EF Core. </span><span class="koboSpan" id="kobo.956.2">We introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">ExecuteUpdate()</span></strong><span class="koboSpan" id="kobo.958.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">ExecuteDelete()</span></strong><span class="koboSpan" id="kobo.960.1"> methods, which can be used to update or delete data without loading the entities from the database. </span><span class="koboSpan" id="kobo.960.2">Compared to a raw SQL query, these two methods have strong type support. </span><span class="koboSpan" id="kobo.960.3">It is recommended to use these two methods to update or delete </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">multiple entities.</span></span></p>
<p><span class="koboSpan" id="kobo.962.1">Next, we will learn how to </span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.963.1">manage concurrency conflicts when </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">updating data.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.965.1">Understanding concurrency conflicts</span></h1>
<p><span class="koboSpan" id="kobo.966.1">An API endpoint </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.967.1">can be called by multiple clients at the same time. </span><span class="koboSpan" id="kobo.967.2">If the endpoint updates data, the data may be updated by another client before the current client completes the update. </span><span class="koboSpan" id="kobo.967.3">When the same entity is updated by multiple clients, it can cause a concurrency conflict, which may result in data loss or inconsistency, or even cause data corruption. </span><span class="koboSpan" id="kobo.967.4">In this section, we will discuss how to handle concurrency conflicts in EF Core. </span><span class="koboSpan" id="kobo.967.5">You can download the sample project </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">ConcurrencyConflictDemo</span></strong><span class="koboSpan" id="kobo.969.1"> from  the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">/samples/chapter7/ConcurrencyConflictDemo</span></strong><span class="koboSpan" id="kobo.971.1"> folder in the chapter's </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.973.1">There are two ways to </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.974.1">handle </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">concurrency conflicts:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.976.1">Pessimistic concurrency control</span></strong><span class="koboSpan" id="kobo.977.1">: This uses database locks to prevent multiple </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.978.1">clients from updating the same entity at the same time. </span><span class="koboSpan" id="kobo.978.2">When a client tries to update an entity, it will first acquire a lock on the entity. </span><span class="koboSpan" id="kobo.978.3">If the lock is acquired successfully, only this client can update the entity, and all other clients will be blocked from updating the entity until the lock is released. </span><span class="koboSpan" id="kobo.978.4">However, this approach may result in performance issues when the number of concurrent clients is large because managing locks is expensive. </span><span class="koboSpan" id="kobo.978.5">EF Core does not have built-in support for pessimistic </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">concurrency control.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.980.1">Optimistic concurrency control</span></strong><span class="koboSpan" id="kobo.981.1">: This way does not involve locks; instead, a version</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.982.1"> column is used to detect concurrency conflicts. </span><span class="koboSpan" id="kobo.982.2">When a client tries to update an entity, it will first get the value of the version column, and then compare this value with the old value when updating the entity. </span><span class="koboSpan" id="kobo.982.3">If the value of the version column is the same, it means that no other client has updated the entity. </span><span class="koboSpan" id="kobo.982.4">In this case, the client can update the entity. </span><span class="koboSpan" id="kobo.982.5">But if the value of the version column is different from the old value, it means that another client has updated </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.983.1">the entity. </span><span class="koboSpan" id="kobo.983.2">In this case, EF Core will throw an exception to indicate the concurrency conflict. </span><span class="koboSpan" id="kobo.983.3">The client can then handle the exception and retry the </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">update operation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.985.1">Let's see an example </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.986.1">of concurrency conflicts. </span><span class="koboSpan" id="kobo.986.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">ConcurrencyConflictDemo</span></strong><span class="koboSpan" id="kobo.988.1"> project, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">Product</span></strong><span class="koboSpan" id="kobo.990.1"> entity with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">Inventory</span></strong><span class="koboSpan" id="kobo.992.1"> property, which is used to store the number of products in stock. </span><span class="koboSpan" id="kobo.992.2">We want to create an API endpoint to sell a product. </span><span class="koboSpan" id="kobo.992.3">When a client calls this endpoint, it will pass the product ID and the number of products to sell. </span><span class="koboSpan" id="kobo.992.4">The endpoint will then update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">Inventory</span></strong><span class="koboSpan" id="kobo.994.1"> property by subtracting the number of products to sell. </span><span class="koboSpan" id="kobo.994.2">The logic is </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.996.1">The client calls the API endpoint to sell </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">a product.</span></span></li>
<li><span class="koboSpan" id="kobo.998.1">The application gets the product from </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">the database.</span></span></li>
<li><span class="koboSpan" id="kobo.1000.1">The application checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">Inventory</span></strong><span class="koboSpan" id="kobo.1002.1"> property to make sure that the number of products in stock is enough for </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">the sale</span></span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">:</span></span><ul><li><span class="koboSpan" id="kobo.1005.1">If the number of products in stock is enough, the application subtracts the number of products being sold from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">Inventory</span></strong><span class="koboSpan" id="kobo.1007.1"> property and then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">SaveChanges()</span></strong><span class="koboSpan" id="kobo.1009.1"> method to save the changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">the database</span></span></li><li><span class="koboSpan" id="kobo.1011.1">If the number of products in stock is not enough, the application returns an error message to </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">the client</span></span></li></ul></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1013.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1014.1">The example project uses the following code to reset the database in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1016.1"> file when the </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">application starts:</span></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">dbContext.Database.EnsureDeleted();</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">dbContext.Database.EnsureCreated();</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.1020.1">So, when you run the application, the database will be reset, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">Inventory</span></strong><span class="koboSpan" id="kobo.1022.1"> property of product 1 will be set </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">15</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1026.1">The following code</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.1027.1"> shows the first version of the implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">API endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1029.1">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity)
{
    if (context.Products == null)
    {
        return Problem("Entity set 'SampleDbContext.Products' is null.");
    }
    var product = await context.Products.FindAsync(id);
    if (product == null)
    {
        return NotFound();
    }
    if (product.Inventory &lt; quantity)
    {
        return Problem("Not enough inventory.");
    }
    product.Inventory -= quantity;
    await context.SaveChangesAsync();
    return product;
}</span></pre>
<p><span class="koboSpan" id="kobo.1030.1">There should be some other logic that handles the order creation and payment, and so on. </span><span class="koboSpan" id="kobo.1030.2">We will not discuss that here; instead, we will focus on the concurrency conflicts caused by </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.1031.1">the product </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">inventory update:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1033.1">To simulate this concurrent scenario, we can pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">delay</span></strong><span class="koboSpan" id="kobo.1035.1"> parameter to add a delay before saving the changes to the database. </span><span class="koboSpan" id="kobo.1035.2">The following code shows how to add </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">a delay:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity, int delay = 0){    // Omitted code for brevity    await Task.Delay(TimeSpan.FromSeconds(delay));    product.Inventory -= quantity;    await context.SaveChangesAsync();    return product;}</span></pre></li> <li><span class="koboSpan" id="kobo.1038.1">Now, let us try to call the API endpoint twice in a short time. </span><span class="koboSpan" id="kobo.1038.2">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">POST</span></strong><span class="koboSpan" id="kobo.1040.1"> request will pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">delay</span></strong><span class="koboSpan" id="kobo.1042.1"> parameter with a value of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1"> seconds:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
http://localhost:5273/api/Products/1/sell/10?delay=2</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1046.1">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">POST</span></strong><span class="koboSpan" id="kobo.1048.1"> request will pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">delay</span></strong><span class="koboSpan" id="kobo.1050.1"> parameter with a value of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1"> seconds:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1053.1">http://localhost:5273/api/Products/1/sell/10?delay=3</span></pre></li> <li><span class="koboSpan" id="kobo.1054.1">Send the first request and then send the second request in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">2</span></strong><span class="koboSpan" id="kobo.1056.1"> seconds. </span><span class="koboSpan" id="kobo.1056.2">The expected result should be that the first request will succeed and the second request will fail. </span><span class="koboSpan" id="kobo.1056.3">But actually, both requests will succeed. </span><span class="koboSpan" id="kobo.1056.4">The responses show that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">Inventory</span></strong><span class="koboSpan" id="kobo.1058.1"> property of the product is updated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">5</span></strong><span class="koboSpan" id="kobo.1060.1">, which is incorrect. </span><span class="koboSpan" id="kobo.1060.2">The initial value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">Inventory</span></strong><span class="koboSpan" id="kobo.1062.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">15</span></strong><span class="koboSpan" id="kobo.1064.1">, and we sold 20 products, so how can the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">Inventory</span></strong><span class="koboSpan" id="kobo.1066.1"> property be updated </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1070.1">Let us see what </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.1071.1">happens in </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">the application:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1073.1">Client A calls the API endpoint to sell a product and wants to sell </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">10 products.</span></span></li>
<li><span class="koboSpan" id="kobo.1075.1">Client A checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">Inventory</span></strong><span class="koboSpan" id="kobo.1077.1"> property and finds that the number of products in stock is 15, which is enough </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">to sell.</span></span></li>
<li><span class="koboSpan" id="kobo.1079.1">Almost at the same time, client B calls the API endpoint to sell a product and wants to sell </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">10 products.</span></span></li>
<li><span class="koboSpan" id="kobo.1081.1">Client B checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">Inventory</span></strong><span class="koboSpan" id="kobo.1083.1"> property and finds that the number of products in stock is 15 because client A has not updated the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">Inventory</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1085.1">property yet.</span></span></li>
<li><span class="koboSpan" id="kobo.1086.1">Client A subtracts 10 from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">Inventory</span></strong><span class="koboSpan" id="kobo.1088.1"> property, which results in a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">5</span></strong><span class="koboSpan" id="kobo.1090.1">, and saves the changes to the database. </span><span class="koboSpan" id="kobo.1090.2">Now, the number of products in stock </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1094.1">Client B also subtracts 10 from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">Inventory</span></strong><span class="koboSpan" id="kobo.1096.1"> property and saves the changes to the database. </span><span class="koboSpan" id="kobo.1096.2">The problem is that the number of products in stock has been updated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">5</span></strong><span class="koboSpan" id="kobo.1098.1"> by client A, but client B does not know this. </span><span class="koboSpan" id="kobo.1098.2">So, client B also updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">Inventory</span></strong><span class="koboSpan" id="kobo.1100.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">5</span></strong><span class="koboSpan" id="kobo.1102.1">, which </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">is incorrect.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1104.1">This is an example of concurrency conflict. </span><span class="koboSpan" id="kobo.1104.2">Multiple clients try to update the same entity at the same time, and the result is not what we expected. </span><span class="koboSpan" id="kobo.1104.3">In this case, client B should not be able to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Inventory</span></strong><span class="koboSpan" id="kobo.1106.1"> property because the number of products in stock is not enough. </span><span class="koboSpan" id="kobo.1106.2">However, if the application does not handle concurrency conflicts, we may end up with incorrect data in </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1108.1">To solve this problem, EF Core provides optimistic concurrency control. </span><span class="koboSpan" id="kobo.1108.2">There are two ways to use optimistic </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">concurrency control:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1110.1">Native database-generate</span><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.1111.1">d </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">concurrency token</span></span></li>
<li><span class="koboSpan" id="kobo.1113.1">Application-managed </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">concurrency token</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1115.1">Let us see how to use these two ways to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">concurrency conflicts.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.1117.1">Native database-generated concurrency token</span></h2>
<p><span class="koboSpan" id="kobo.1118.1">Some</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.1119.1"> databases, such as SQL Server, provide a native mechanism to handle concurrency conflicts. </span><span class="koboSpan" id="kobo.1119.2">To use the native database-generated concurrency token in SQL Server, we need to create a new property for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">Product</span></strong><span class="koboSpan" id="kobo.1121.1"> class and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">[Timestamp]</span></strong><span class="koboSpan" id="kobo.1123.1"> attribute to it. </span><span class="koboSpan" id="kobo.1123.2">The following code shows the updated </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
public class Product{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Inventory { get; set; }
    // Add a new property as the concurrency token
    public byte[] RowVersion { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1127.1">In the Fluent API configuration, we need to add the following code to map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">RowVersion</span></strong><span class="koboSpan" id="kobo.1129.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">rowversion</span></strong><span class="koboSpan" id="kobo.1131.1"> column in </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1133.1">
modelBuilder.Entity&lt;Product&gt;()    .Property(p =&gt; p.RowVersion)
    .IsRowVersion();</span></pre>
<p><span class="koboSpan" id="kobo.1134.1">If you prefer to use the data annotation configuration, you can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">[Timestamp]</span></strong><span class="koboSpan" id="kobo.1136.1"> attribute to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">RowVersion</span></strong><span class="koboSpan" id="kobo.1138.1"> property, and EF Core will automatically map it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">rowversion</span></strong><span class="koboSpan" id="kobo.1140.1"> column in the database, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1142.1">
public class Product{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Inventory { get; set; }
    // Add a new property as the concurrency token
    [Timestamp]
    public byte[] RowVersion { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1143.1">Do not </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.1144.1">forget to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">dotnet ef migrations add AddConcurrencyControl</span></strong><span class="koboSpan" id="kobo.1146.1"> command to create a new migration. </span><span class="koboSpan" id="kobo.1146.2">There is no need to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">dotnet ef database update</span></strong><span class="koboSpan" id="kobo.1148.1"> command this time because we have the code to reset the database when the </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">application starts.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1150.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1151.1">If you want to configure the mapping in Fluent API, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">following code:</span></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">modelBuilder.Entity&lt;Product&gt;()</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1"> .Property(p =&gt; </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">p.RowVersion)</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1"> .</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">IsRowVersion();</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.1158.1">This will generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">following migration:</span></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">migrationBuilder.AddColumn&lt;byte[]&gt;(</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">name: "RowVersion",</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">table: "Products",</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">type: "rowversion",</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">rowVersion: true,</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">nullable: false,</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">defaultValue: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">new byte[0]);</span></strong></span></p>
<p><span class="koboSpan" id="kobo.1168.1">Now, let's try to call the API endpoint again. </span><span class="koboSpan" id="kobo.1168.2">Use the same requests as before, one with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">delay</span></strong><span class="koboSpan" id="kobo.1170.1"> parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">2</span></strong><span class="koboSpan" id="kobo.1172.1"> seconds, and the other with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">delay</span></strong><span class="koboSpan" id="kobo.1174.1"> parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">3</span></strong><span class="koboSpan" id="kobo.1176.1"> seconds. </span><span class="koboSpan" id="kobo.1176.2">This time, we should see that the first request will succeed, but the second request </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.1177.1">will fail with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">DbUpdateConcurrencyException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1"> exception:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1180.1">
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]      An unhandled exception has occurred while executing the request.
</span><span class="koboSpan" id="kobo.1180.2">      Microsoft.EntityFrameworkCore.DbUpdateConcurrencyException: The database operation was expected to affect 1 row(s), but actually affected 0 row(s); data may have been modified or deleted since entities were loaded. </span><span class="koboSpan" id="kobo.1180.3">See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.</span></pre>
<p><span class="koboSpan" id="kobo.1181.1">Check the database. </span><span class="koboSpan" id="kobo.1181.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">Inventory</span></strong><span class="koboSpan" id="kobo.1183.1"> column of product 1 has been updated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">5</span></strong><span class="koboSpan" id="kobo.1185.1">, which </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">is correct.</span></span></p>
<p><span class="koboSpan" id="kobo.1187.1">If you check the SQL statement generated by EF Core, you will find that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">rowversion</span></strong><span class="koboSpan" id="kobo.1189.1"> column is included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">WHERE</span></strong><span class="koboSpan" id="kobo.1191.1"> clause of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">UPDATE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1"> statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1194.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (1ms) [Parameters=[@p1='?' </span><span class="koboSpan" id="kobo.1194.2">(DbType = Int32), @p0='?' </span><span class="koboSpan" id="kobo.1194.3">(DbType = Int32), @p2='?' </span><span class="koboSpan" id="kobo.1194.4">(Size = 8) (DbType = Binary)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Products] SET [Inventory] = @p0
      OUTPUT INSERTED.[RowVersion]
      WHERE [Id] = @p1 AND [RowVersion] = @p2;</span></pre>
<p><span class="koboSpan" id="kobo.1195.1">By using concurrency control, EF Core not only checks the ID of the entity but also checks the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">rowversion</span></strong><span class="koboSpan" id="kobo.1197.1"> column. </span><span class="koboSpan" id="kobo.1197.2">If the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">rowversion</span></strong><span class="koboSpan" id="kobo.1199.1"> column is </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.1200.1">not the same as the value in the database, it means that the entity has been updated by another client, and the current update operation should </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">be aborted.</span></span></p>
<p><span class="koboSpan" id="kobo.1202.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">rowversion</span></strong><span class="koboSpan" id="kobo.1204.1"> column type is available for SQL Server, but not for other databases, such as SQLite. </span><span class="koboSpan" id="kobo.1204.2">Different databases may have different types of concurrency tokens, or may not support the concurrency token at all. </span><span class="koboSpan" id="kobo.1204.3">Please check the documentation of the database you are using to see whether it supports the built-in concurrency token. </span><span class="koboSpan" id="kobo.1204.4">If not, you need to use the applica</span><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.1205.1">tion-managed concurrency token, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">next section.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.1207.1">Application-managed concurrency token</span></h2>
<p><span class="koboSpan" id="kobo.1208.1">If the </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.1209.1">database does not support the built-in concurrency token, we can manually manage the concurrency token in the application. </span><span class="koboSpan" id="kobo.1209.2">Instead of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">rowversion</span></strong><span class="koboSpan" id="kobo.1211.1"> column, which can be automatically updated by the database, we can use a property in the entity class to manage the concurrency token and assign a new value to it every time the entity </span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">is updated.</span></span></p>
<p><span class="koboSpan" id="kobo.1213.1">Here is an example of using the application-managed </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">concurrency token:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1215.1">First, we need to add a new property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">Product</span></strong><span class="koboSpan" id="kobo.1217.1"> class, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1219.1">
public class Product{    public int Id { get; set; }    public string Name { get; set; }    public int Inventory { get; set; }    // Add a new property as the concurrency token    public Guid Version { get; set; }}</span></pre></li> <li><span class="koboSpan" id="kobo.1220.1">Update the Fluent API configuration to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">Version</span></strong><span class="koboSpan" id="kobo.1222.1"> property as the </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">concurrency token:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1224.1">
modelBuilder.Entity&lt;Product&gt;()    .Property(p =&gt; p.Version)    .IsConcurrencyToken();</span></pre></li> <li><span class="koboSpan" id="kobo.1225.1">The </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.1226.1">corresponding data annotation configuration is </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1228.1">
public class Product{    public int Id { get; set; }    public string Name { get; set; }    public int Inventory { get; set; }    // Add a new property as the concurrency token    [ConcurrencyCheck]    public Guid Version { get; set; }}</span></pre></li> <li><span class="koboSpan" id="kobo.1229.1">Because this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">Version</span></strong><span class="koboSpan" id="kobo.1231.1"> property is not managed by the database, we need to manually assign a new value whenever the entity </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">is updated.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1233.1">The following code shows how to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">Version</span></strong><span class="koboSpan" id="kobo.1235.1"> property when the entity </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">is updated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1237.1">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity)
{
    // Omitted for brevity.
</span><span class="koboSpan" id="kobo.1237.2">    product.Inventory -= quantity;
    // Manually assign a new value to the Version property.
</span><span class="koboSpan" id="kobo.1237.3">    product.Version = Guid.NewGuid();
    await context.SaveChangesAsync();
    return product;
}</span></pre>
<p><span class="koboSpan" id="kobo.1238.1">You can </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.1239.1">use the application-managed concurrency token in SQL Server as well. </span><span class="koboSpan" id="kobo.1239.2">The only difference is that you need to manually assign a new value to the concurrency token property every time the entity is updated. </span><span class="koboSpan" id="kobo.1239.3">But if you use the built-in concurrency token in SQL Server, you do not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.1240.1">do that.</span></span></p>
<p><span class="koboSpan" id="kobo.1241.1">In the event of a concurrency conflict, it is essential to take the necessary steps to res</span><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.1242.1">olve the issue. </span><span class="koboSpan" id="kobo.1242.2">This will be addressed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1">following section.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.1244.1">Handling concurrency conflicts</span></h2>
<p><span class="koboSpan" id="kobo.1245.1">When a </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.1246.1">concurrency conflict occurs, EF Core will throw a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">DbUpdateConcurrencyException</span></strong><span class="koboSpan" id="kobo.1248.1"> exception. </span><span class="koboSpan" id="kobo.1248.2">We can catch this exception and handle it in the application. </span><span class="koboSpan" id="kobo.1248.3">For example, we can return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">409 Conflict</span></strong><span class="koboSpan" id="kobo.1250.1"> status code to the client, and let the client decide what to </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">do next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1252.1">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity)
{
    // Omitted for brevity.
</span><span class="koboSpan" id="kobo.1252.2">    product.Inventory -= quantity;
    try
    {
        await context.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException)
    {
        // Do not forget to log the error
        return Conflict($"Concurrency conflict for Product {product.Id}.");
    }
    return product;
}</span></pre>
<p><span class="koboSpan" id="kobo.1253.1">The </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.1254.1">preceding code returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">409 Conflict</span></strong><span class="koboSpan" id="kobo.1256.1"> status code to the client when a concurrency conflict occurs. </span><span class="koboSpan" id="kobo.1256.2">The client can then handle the exception and retry the </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">update operation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1258.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1259.1">Some databases provide different isolation levels to handle concurrency conflicts. </span><span class="koboSpan" id="kobo.1259.2">For example, SQL Server provides four isolation levels: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">ReadUncommitted</span></strong><span class="koboSpan" id="kobo.1261.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">ReadCommitted</span></strong><span class="koboSpan" id="kobo.1263.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">RepeatableRead</span></strong><span class="koboSpan" id="kobo.1265.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">Serializable</span></strong><span class="koboSpan" id="kobo.1267.1">. </span><span class="koboSpan" id="kobo.1267.2">The default isolation level is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">ReadCommitted</span></strong><span class="koboSpan" id="kobo.1269.1">. </span><span class="koboSpan" id="kobo.1269.2">Each isolation level has different behaviors when a concurrency conflict occurs and has its own pros and cons. </span><span class="koboSpan" id="kobo.1269.3">Higher levels of isolation provide more consistency but also reduce concurrency. </span><span class="koboSpan" id="kobo.1269.4">For more information, see </span><em class="italic"><span class="koboSpan" id="kobo.1270.1">Isolation Levels</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.1271.1">at </span></span><a href="https://learn.microsoft.com/en-gb/sql/t-sql/statements/set-transaction-isolation-level-transact-sql"><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">https://learn.microsoft.com/en-gb/sql/t-sql/statements/set-transaction-isolation-level-transact-sql</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1274.1">In this section, we discussed how to handle concurrency conflicts in EF Core. </span><span class="koboSpan" id="kobo.1274.2">We introduced two ways to handle concurrency conflicts: native database-generated concurrency tokens and application-managed concurrency tokens. </span><span class="koboSpan" id="kobo.1274.3">We also discussed how to handle exceptions when concurrency conflicts occur. </span><span class="koboSpan" id="kobo.1274.4">Concurrency conflicts are a common issue in a highly concurrent environment. </span><span class="koboSpan" id="kobo.1274.5">It is impo</span><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.1275.1">rtant to handle them properly to avoid data loss </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">or inconsistency.</span></span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.1277.1">Reverse engineering</span></h1>
<p><span class="koboSpan" id="kobo.1278.1">So far, we</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.1279.1"> have learned how to use EF Core to create a database schema from the entity classes. </span><span class="koboSpan" id="kobo.1279.2">This </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.1280.1">is called </span><em class="italic"><span class="koboSpan" id="kobo.1281.1">code-first</span></em><span class="koboSpan" id="kobo.1282.1">. </span><span class="koboSpan" id="kobo.1282.2">However, sometimes we need to work with an existing database. </span><span class="koboSpan" id="kobo.1282.3">In this case, we need to create the entity classes and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">DbContext</span></strong><span class="koboSpan" id="kobo.1284.1"> from the existing database schema. </span><span class="koboSpan" id="kobo.1284.2">This is called </span><em class="italic"><span class="koboSpan" id="kobo.1285.1">database-first</span></em><span class="koboSpan" id="kobo.1286.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.1287.1">reverse engineering</span></em><span class="koboSpan" id="kobo.1288.1">. </span><span class="koboSpan" id="kobo.1288.2">In this section, we will discuss how to use EF Core to reverse engineer the entity classes and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">DbContext</span></strong><span class="koboSpan" id="kobo.1290.1"> from an existing database schema. </span><span class="koboSpan" id="kobo.1290.2">This</span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.1291.1"> is useful when we want to migrate an existing application to </span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">EF Core.</span></span></p>
<p><span class="koboSpan" id="kobo.1293.1">Let's use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">EfCoreRelationshipsDemoDb</span></strong><span class="koboSpan" id="kobo.1295.1"> database as an example. </span><span class="koboSpan" id="kobo.1295.2">If you have not created this database, please follow the steps in </span><a href="B18971_06.xhtml#_idTextAnchor245"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1296.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.1297.1"> to create it. </span><span class="koboSpan" id="kobo.1297.2">The sample code is located at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">/samples/chapter7/EfCoreReverseEngineeringDemo</span></strong><span class="koboSpan" id="kobo.1299.1"> folder in the chapter's </span><span class="No-Break"><span class="koboSpan" id="kobo.1300.1">GitHub repository.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1301.1">First, let us create a new web API project. </span><span class="koboSpan" id="kobo.1301.2">Run the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">the terminal:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1303.1">dotnet new webapi -n EfCoreReverseEngineeringDemo</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1304.1">To use reverse engineering, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">Microsoft.EntityFrameworkCore.Design</span></strong><span class="koboSpan" id="kobo.1306.1"> NuGet package. </span><span class="koboSpan" id="kobo.1306.2">Navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">EfCoreReverseEngineeringDemo</span></strong><span class="koboSpan" id="kobo.1308.1"> folder, and run the following command in the terminal to </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">install it:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1310.1">dotnet add package Microsoft.EntityFrameworkCore.Design</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1311.1">Then, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">Microsoft.EntityFrameworkCore.SqlServer</span></strong><span class="koboSpan" id="kobo.1313.1"> NuGet package to </span><span class="No-Break"><span class="koboSpan" id="kobo.1314.1">the project:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1315.1">dotnet add package Microsoft.EntityFrameworkCore.SqlServer</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1316.1">If you use other database providers, such as SQLite, you need to install the corresponding NuGet package. </span><span class="koboSpan" id="kobo.1316.2">For example, to use SQLite, you need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">Microsoft.EntityFrameworkCore.Sqlite</span></strong><span class="koboSpan" id="kobo.1318.1"> NuGet package. </span><span class="koboSpan" id="kobo.1318.2">You can find the list of supported database providers </span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1">at </span></span><a href="https://learn.microsoft.com/en-us/ef/core/providers/"><span class="No-Break"><span class="koboSpan" id="kobo.1320.1">https://learn.microsoft.com/en-us/ef/core/providers/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.1322.1">Next, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">dbcontext scaffold</span></strong><span class="koboSpan" id="kobo.1324.1"> command to generate the entity classes and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">DbContext</span></strong><span class="koboSpan" id="kobo.1326.1"> from the database schema. </span><span class="koboSpan" id="kobo.1326.2">This command needs the connection string of the database and the name of the database provider. </span><span class="koboSpan" id="kobo.1326.3">We can run the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.1327.1">the terminal:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1328.1">dotnet ef dbcontext scaffold "Server=(localdb)\mssqllocaldb;Initial Catalog=EfCoreRelationshipsDemoDb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1329.1">By default, the generated files will be placed in the current directory. </span><span class="koboSpan" id="kobo.1329.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">--context-dir</span></strong><span class="koboSpan" id="kobo.1331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">--output-dir</span></strong><span class="koboSpan" id="kobo.1333.1"> options to specify the output </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.1334.1">directory of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">DbContext</span></strong><span class="koboSpan" id="kobo.1336.1"> and entity classes. </span><span class="koboSpan" id="kobo.1336.2">For example, we can run the following command to generate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">DbContext</span></strong><span class="koboSpan" id="kobo.1338.1"> and entity classes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">Data</span></strong><span class="koboSpan" id="kobo.1340.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">Models</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1342.1">folders, respectively:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.1343.1">dotnet ef dbcontext scaffold "Server=(localdb)\mssqllocaldb;Initial Catalog=EfCoreRelationshipsDemoDb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer --context-dir Data --output-dir Models</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1344.1">The default name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">DbContext</span></strong><span class="koboSpan" id="kobo.1346.1"> class will be the same as the database name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">EfCoreRelationshipsDemoDbContext</span></strong><span class="koboSpan" id="kobo.1348.1">.cs. </span><span class="koboSpan" id="kobo.1348.2">We can also change the name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">DbContext</span></strong><span class="koboSpan" id="kobo.1350.1"> class by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">--context</span></strong><span class="koboSpan" id="kobo.1352.1"> option. </span><span class="koboSpan" id="kobo.1352.2">For example, we can run the following command to change the name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">DbContext</span></strong><span class="koboSpan" id="kobo.1354.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1355.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">AppDbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.1358.1">dotnet ef dbcontext scaffold "Server=(localdb)\mssqllocaldb;Initial Catalog=EfCoreRelationshipsDemoDb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer --context-dir Data --output-dir Models --context AppDbContext</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1359.1">If the command executes successfully, we will see the generated files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">Data</span></strong><span class="koboSpan" id="kobo.1361.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">Models</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1363.1"> folders.</span></span></p></li> <li><span class="koboSpan" id="kobo.1364.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">AppDbContext.cs</span></strong><span class="koboSpan" id="kobo.1366.1"> file, and we will see a warning in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1367.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1368.1">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)#warning To protect potentially sensitive information in your connection string, you should move it out of source code. </span><span class="koboSpan" id="kobo.1368.2">You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. </span><span class="koboSpan" id="kobo.1368.3">For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263.        =&gt; optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Initial Catalog=EfCoreRelationshipsDemoDb;Trusted_Connection=True;");</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1369.1">This warning tells us that we should not store the connection string in the source code. </span><span class="koboSpan" id="kobo.1369.2">Instead, we should store it in a configuration file, such </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">appsettings.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1373.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">OnModelCreating</span></strong><span class="koboSpan" id="kobo.1375.1"> method, we</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.1376.1"> can see the entity classes and their relationships have been configured in Fluent API style. </span><span class="koboSpan" id="kobo.1376.2">If you prefer to use data annotations, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">--data-annotations</span></strong><span class="koboSpan" id="kobo.1378.1"> option when you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">dbcontext scaffold</span></strong><span class="koboSpan" id="kobo.1380.1"> command. </span><span class="koboSpan" id="kobo.1380.2">But as we mentioned in </span><a href="B18971_05.xhtml#_idTextAnchor198"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1381.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.1382.1">, Fluent API is more powerful than data annotations, and it is recommended to use </span><span class="No-Break"><span class="koboSpan" id="kobo.1383.1">Fluent API.</span></span></p>
<p><span class="koboSpan" id="kobo.1384.1">EF Core is smart enough to detect the relationships between the entity classes if your database schema follows the conventions. </span><span class="koboSpan" id="kobo.1384.2">However, if this is not the case, you may get unexpected results. </span><span class="koboSpan" id="kobo.1384.3">Please review the generated code carefully to make sure the relationships are </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">configured correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.1386.1">Keep in mind that the generated code is just a starting point. </span><span class="koboSpan" id="kobo.1386.2">Some models or properties may not be represented correctly in the database. </span><span class="koboSpan" id="kobo.1386.3">For example, if your models have inheritance, the generated code will not include the base class because the base class is not represented in the database. </span><span class="koboSpan" id="kobo.1386.4">Also, some column types may not be able to be mapped to the corresponding CLR types. </span><span class="koboSpan" id="kobo.1386.5">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1387.1">Status</span></strong><span class="koboSpan" id="kobo.1388.1"> column in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">Invoice</span></strong><span class="koboSpan" id="kobo.1390.1"> table is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1391.1">nvarchar(16)</span></strong><span class="koboSpan" id="kobo.1392.1"> type, which will be mapped to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">string</span></strong><span class="koboSpan" id="kobo.1394.1"> type in the generated code, instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">Status</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1396.1">enum type.</span></span></p>
<p><span class="koboSpan" id="kobo.1397.1">You can update the generated code to suit your needs, but be aware that the next time you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">dbcontext scaffold</span></strong><span class="koboSpan" id="kobo.1399.1"> command, the changes will be overwritten. </span><span class="koboSpan" id="kobo.1399.2">You</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.1400.1"> can use partial classes to add your own code to the generated classes, as the generated classes are declared </span><span class="No-Break"><span class="koboSpan" id="kobo.1401.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">partial</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1404.1">In this section, we discussed how to use EF Core to reverse engineer the entity classes and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">DbContext</span></strong><span class="koboSpan" id="kobo.1406.1"> from an existing database schema. </span><span class="koboSpan" id="kobo.1406.2">It should be noted that EF Core strongly prefers the code-first approach. </span><span class="koboSpan" id="kobo.1406.3">Unless you are working with an existing database, it is recommended to use the </span><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.1407.1">code-first approach to take advantage of the EF Core </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">migrations feature.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.1409.1">Other ORM frameworks</span></h1>
<p><span class="koboSpan" id="kobo.1410.1">In addition to EF Core, there are numerous other ORM frameworks available for .NET. </span><span class="koboSpan" id="kobo.1410.2">Some of the most popular include </span><span class="No-Break"><span class="koboSpan" id="kobo.1411.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1412.1">Dapper</span></strong><span class="koboSpan" id="kobo.1413.1"> (</span><a href="https://dapperlib.github.io/Dapper/"><span class="koboSpan" id="kobo.1414.1">https://dapperlib.github.io/Dapper/</span></a><span class="koboSpan" id="kobo.1415.1">): Dapper is a micro-ORM framework that is designed </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.1416.1">to </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.1417.1">be fast and lightweight. </span><span class="koboSpan" id="kobo.1417.2">Dapper does not support change tracking, but it is easy to use, and it is very fast. </span><span class="koboSpan" id="kobo.1417.3">As the official documentation says, “</span><em class="italic"><span class="koboSpan" id="kobo.1418.1">Dapper’s simplicity means that many features that ORMs ship with are stripped out. </span><span class="koboSpan" id="kobo.1418.2">It worries about the 95% scenario and gives you the tools you need most of the time. </span><span class="koboSpan" id="kobo.1418.3">It doesn’t attempt to solve every problem.</span></em><span class="koboSpan" id="kobo.1419.1">” The performance is one of the most important features of Dapper. </span><span class="koboSpan" id="kobo.1419.2">Maybe it is not fair to compare Dapper’s performance with EF Core, because EF Core provides many more features than Dapper. </span><span class="koboSpan" id="kobo.1419.3">If you are looking for a simple ORM framework that is fast and easy to use, Dapper is a good choice. </span><span class="koboSpan" id="kobo.1419.4">In some projects, Dapper is used with EF Core to provide the best of both worlds. </span><span class="koboSpan" id="kobo.1419.5">Dapper is open-source and originally developed by </span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1">Stack Overflow.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1421.1">NHibernate</span></strong><span class="koboSpan" id="kobo.1422.1"> (</span><a href="https://nhibernate.info/"><span class="koboSpan" id="kobo.1423.1">https://nhibernate.info/</span></a><span class="koboSpan" id="kobo.1424.1">): Like NUnit, NHibernate is a .NET implementation </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.1425.1">of the Hibernate ORM framework in Java. </span><span class="koboSpan" id="kobo.1425.2">It is a</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.1426.1"> mature, open-source ORM framework that has been around for a long time. </span><span class="koboSpan" id="kobo.1426.2">It is very powerful and flexible. </span><span class="koboSpan" id="kobo.1426.3">NHibernate is maintained by a community </span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">of developers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1428.1">PetaPoco</span></strong><span class="koboSpan" id="kobo.1429.1"> (</span><a href="https://github.com/CollaboratingPlatypus/PetaPoco"><span class="koboSpan" id="kobo.1430.1">https://github.com/CollaboratingPlatypus/PetaPoco</span></a><span class="koboSpan" id="kobo.1431.1">): PetaPoco is a tiny, fast, easy-to-use micro-ORM framework, which only had 1,000+ lines of code in the original </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.1432.1">version. </span><span class="koboSpan" id="kobo.1432.2">PetaPoco has a similar performance </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.1433.1">to Dapper because it uses dynamic method generation (MSIL) to assign column values to properties. </span><span class="koboSpan" id="kobo.1433.2">PetaPoco now supports SQL Server, SQL Server CE, MS Access, SQLite, MySQL, MariaDB, PostgreSQL, Firebird DB, and Oracle. </span><span class="koboSpan" id="kobo.1433.3">It uses T4 templates to generate the code. </span><span class="koboSpan" id="kobo.1433.4">PetaPoco is open-source and currently maintained by a few </span><span class="No-Break"><span class="koboSpan" id="kobo.1434.1">core developers.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1435.1">It is hard to say which one is the best. </span><span class="koboSpan" id="kobo.1435.2">It depends on your needs. </span><span class="koboSpan" id="kobo.1435.3">Dapper is known for its speed and performance, while EF Core is more feature-rich and provides better support for complex queries and relationships. </span><span class="koboSpan" id="kobo.1435.4">When deciding which framework to use for a particular task, consider the performance implications of each approach, </span><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.1436.1">and also the trade-offs between the features and flexibility of </span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">the framework.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.1438.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1439.1">In this chapter, we delved into some advanced topics of Entity Framework. </span><span class="koboSpan" id="kobo.1439.2">We started by exploring how to improve the performance of our application by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">DbContext</span></strong><span class="koboSpan" id="kobo.1441.1"> pooling and no-tracking queries. </span><span class="koboSpan" id="kobo.1441.2">We then learned how to execute raw SQL queries safely and efficiently using parameterized queries, and how to leverage the new bulk operations feature in EF Core for faster </span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">data manipulation.</span></span></p>
<p><span class="koboSpan" id="kobo.1443.1">Next, we looked at how to handle concurrency scenarios using optimistic concurrency control, which allows multiple users to access and modify the same data simultaneously without conflicts. </span><span class="koboSpan" id="kobo.1443.2">We also covered reverse engineering, a technique for generating entity classes and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">DbContext</span></strong><span class="koboSpan" id="kobo.1445.1"> classes from an existing database schema, which can save time and effort in creating a data </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">access layer.</span></span></p>
<p><span class="koboSpan" id="kobo.1447.1">To broaden our horizons beyond EF Core, we briefly introduced some other popular ORM frameworks, such as Dapper, NHibernate, and PetaPoco, and discussed their strengths and weaknesses. </span><span class="koboSpan" id="kobo.1447.2">By the end of this chapter, you should have a solid understanding of how to leverage EF Core in a web API project to efficiently access and manipulate data, as well as some insights into other ORM options available </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.1449.1">However, EF Core is a very large topic, and we cannot cover everything in this book. </span><span class="koboSpan" id="kobo.1449.2">For more information about EF Core, please refer to the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">at </span></span><a href="https://learn.microsoft.com/en-us/ef/"><span class="No-Break"><span class="koboSpan" id="kobo.1451.1">https://learn.microsoft.com/en-us/ef/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1452.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1453.1">In the next chapter, we will learn how to secure our web API project using authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">and authorization.</span></span></p>
</div>
</body></html>