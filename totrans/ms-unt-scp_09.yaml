- en: Chapter 9. Working with Textures, Models, and 2D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most game engines today orient their feature set towards the creation of 3D
    games rather than 2D in a general sense. This often, ironically, makes 3D tasks
    and workflows simpler than 2D ones, at least to pick up and get started with initially.
    In this chapter, we''ll explore a variety of 2D issues with some provisos. Since
    the release of Unity 4.3, a wide range of 2D features have been added to the editor:
    initially, a native sprite system and then, a new GUI system. While these are
    both useful in their respective ways, the main focus of this chapter will not
    be on these features specifically. The first reason is that a lot of tutorials
    already explain them in considerable detail, but the second and most important
    reason is that even with the added 2D features, there are still more fundamental
    questions that arise about working in 2D, in a looser sense. These include questions
    such as how to manipulate geometry such as the vertices and edges of 2D planes,
    how to adjust and animate texture coordinates, how to edit textures and also how
    to texture paint onto textures in real time using a brush-like system to create
    decals and blood splats, and so on. These questions are more 2D than 3D insofar
    as they pertain to geometry and textures in the 2D plane, but their relevance
    is to both 2D and 3D games generally. Their importance is highly significant today,
    though their coverage is somewhat under-represented in the tutorials available,
    so I have covered them here. Consequently, I''ll restrict this chapter mostly
    to the unconventional side of 2D.'
  prefs: []
  type: TYPE_NORMAL
- en: Skybox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Skybox might seem a strange place to begin an analysis of 2D, but it demonstrates
    an important feature set for cameras, specifically layering. The Skybox is essentially
    a cube-based background that''s attached to a camera to show clouds, skies, and
    other distant details that should always act as the backdrop to a scene, but it
    never represents anything that the player can move close to. It is always distant,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skybox](img/0655OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Skybox assets display a sky background for cameras
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with the default Skyboxes native to Unity is that they remain
    static and motionless by default. Most developers, however, want their skies and
    clouds to gently rotate, even when the camera is standing motionless, to portray
    the procession of a day or of time passing. Now, let's create an improved Skybox
    prefab using the Unity Skybox assets, two layered cameras, and a C# script file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final project for a rotating Skybox can be found in the book's companion
    files.
  prefs: []
  type: TYPE_NORMAL
- en: For the sample project created here, let's import the **Character Controllers**
    package for a first-person controller asset, the **Terrain Assets** package for
    terrain textures that we can paint onto a sample terrain, and the **Skyboxes**
    package for the Skybox textures, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: All these will be useful in building a sample project with a rotating Skybox.
  prefs: []
  type: TYPE_NORMAL
- en: '![Skybox](img/0655OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Importing Character Controllers, Skyboxes, and Terrain Assets
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s begin by creating the rotating Skybox prefab to make a reusable
    object. This object consists of three main parts or subobjects: a first-person
    controller that allows player movement and renders most scene objects, a second
    camera (the Skybox camera) that is rendered below the first-person camera and
    shows only the Skybox, and a cube object with inverted normals that surrounds
    the Skybox camera and shows each Skybox texture on each face.'
  prefs: []
  type: TYPE_NORMAL
- en: To start, create a new empty object at the scene origin (named `SkyBoxCamera`)
    and add a first-person controller object as a child. Then, create six **Quad**
    objects from the main menu (by navigating to **GameObject** | **3D Object** |
    **Quad**), aligning each object to the corners of the other, with the vertex snapping
    to form an inverted cube, that is, a cube whose faces are turned inwards, as shown
    in the following screenshot. This represents the mesh for the manual Skybox.
  prefs: []
  type: TYPE_NORMAL
- en: '![Skybox](img/0655OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a manual Skybox from six Quad objects
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scale the Quads if required and make sure that they contain and enclose the
    first-person controller, which should be at the center of the Skybox.
  prefs: []
  type: TYPE_NORMAL
- en: Assign the Skybox faces to a new layer, `SkyBoxLayer`, select the first-person
    controller camera, and then change the **Culling Mask** field to exclude the `SkyBoxLayer`
    layer. The first-person camera should render only foreground objects and not background
    ones. To achieve this, change the **Clear Flags** field to **Depth only** in the
    Object Inspector, as shown in the following screenshot. This renders the camera
    background to transparent, which allows lower-order cameras to show through, if
    any.
  prefs: []
  type: TYPE_NORMAL
- en: '![Skybox](img/0655OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making the camera background transparent
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a new and additional `Camera` object as a direct child object of
    the first-person camera and match its position, rotation, and scale. This allows
    the camera to inherit all the transformations from the first-person camera. The
    purpose of the secondary camera is to render only the Skybox object as a layer
    beneath the first-person camera while matching the first-person position and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, change the **Depth** value of the new camera to any value less
    than the depth of the first-person camera; such as `-1`. Remove any audio listener
    components where required.
  prefs: []
  type: TYPE_NORMAL
- en: '![Skybox](img/0655OT_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a second camera for Skybox rendering
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign a unique Skybox texture to each cube face and take care to align them
    seamlessly by rotating or adjusting the Quad alignment as needed. Then, change
    the material **Shader** type for the Skybox textures to **Unlit/Texture**, making
    the Skybox immune to scene lighting. The Skybox mesh should start taking shape,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skybox](img/0655OT_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding Skybox textures to the Quads
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, apply the following code sample 9-1 to the Skybox parent object to
    create its rotation behavior and to align it continuously to the camera position.
    This ensures that the Skybox is always centered on the camera wherever it travels
    in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, you now have a completed and enhanced Skybox, one that surrounds
    the camera and rotates to produce greater realism and life in your scenes. You
    can even go further by adding multiple stacked skyboxes within each other, each
    with transparency, to create additional effects such as fog, mist, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skybox](img/0655OT_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Completing a manual Skybox prefab
  prefs: []
  type: TYPE_NORMAL
- en: Procedural meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although Unity now offers a Quad primitive from the application menu, which
    you can access by navigating to **GameObject** | **3D Object** | **Quad**, it''s
    still useful to know how to create geometry manually, such as Quads. There are
    several reasons for this. First, you''ll frequently need to edit vertices in the
    script to move, animate, or distort meshes for various effects to create, for
    example, a jelly-like surface in a platform game that bends and wobbles whenever
    characters step on it. Second, you''ll need to edit the UV coordinates of a mesh,
    perhaps, to create animated or scrolling-texture effects, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Procedural meshes](img/0655OT_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating meshes from script
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code sample 9-2, which should be included inside the
    `Editor` folder of a project. It creates an editor add-on that generates a Quad
    in script with full customization over the location of the mesh pivot point. As
    we''ll see in the code comments, this sample features many useful tips:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 9-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 004**: This sample is coded as an editor plugin. As a result, the `UnityEditor`
    namespace is included. For more information on creating editor plugins, refer
    to [Chapter 8](ch08.html "Chapter 8. Customizing the Unity Editor"), *Customizing
    the Unity Editor*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 135**: The `OnSelectionChanged` event is called when the user changes
    their selection, with the mouse or keyboard, in the Unity Editor. Here, the `GetAssetPath`
    method is called to retrieve the currently open folder in the **Project** panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 140**: The `OnWizardCreate` function is called to generate a Quad mesh
    in script. This is created by filling a vertex and UV array and then populating
    that inside a `Mesh` object created in line 196.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 204**: Critically, the mesh itself is saved, not as an object in a specific
    scene, but as a general asset of the project from which many instances can be
    made as prefab objects. This is achieved with the `AssetDatabase` class. This
    is important to allow the mesh to be reusable across multiple scenes, if required,
    and also to allow its changes and details to be persistent across scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `AssetDatabase` class can be found online in the Unity
    documentation at [http://docs.unity3d.com/ScriptReference/AssetDatabase.html](http://docs.unity3d.com/ScriptReference/AssetDatabase.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Animating UVs – scrolling textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scrolling textures are a general purpose requirement for lots of games, and
    yet, they are not natively supported by Unity; that is, they require you to "get
    coding" for their implementation. Scrolling textures are useful for parallax effects;
    to move clouds, surfaces, and water; or to express motion or movement in the game.
    Typically, scrolling textures are seamless images whose pixels tile vertically
    and horizontally. This allows infinite scrolling and repetition, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating UVs – scrolling textures](img/0655OT_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scrolling texture on a Quad
  prefs: []
  type: TYPE_NORMAL
- en: 'When attached to a Quad, the following code sample 9-3 will animate its texture
    according to the horizontal and vertical speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MatScroller` class works with any `MeshRenderer` component and Quad object.
    A complete scrolling-texture project can be found in the book's companion files
    (code bundle).
  prefs: []
  type: TYPE_NORMAL
- en: Attach this script to your Quad object and tweak its scrolling speed to produce
    the results you need, as shown in the following screenshot. This will be useful
    to create animated sky backgrounds and backgrounds for side-scrolling shooter
    or platform games. It can also be useful to create flowing waterfalls and volumetric
    lighting when combined with transparency!
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating UVs – scrolling textures](img/0655OT_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tweaking texture-scrolling fields from the Object Inspector
  prefs: []
  type: TYPE_NORMAL
- en: Texture painting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many practical scenarios where it's necessary to paint pixels onto
    textures at runtime. Sometimes, the need itself will be trivial, such as displaying
    a decal texture (such as a foot print or written message) in front of another
    surface using alpha transparency. In these cases, you can simply workaround the
    issue with an alpha cut out plane positioned in front of another plane as the
    background. However, there are times when your needs are more complex, and you
    actually need to resort to true texture painting. For example, in a street-fighting
    game, blood splatters from punches and other attacks will fall to the ground and
    surrounding scenery, and you want to it remain as part of the environment texture.
    Another example might be a casual make-up artist game where the gamer must paint
    blusher or eye shadow onto a face mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you don't simply want to paint textured quads in front of the mesh as
    separate objects to create the appearance of textured decals. Instead, you really
    need to paint a source texture (such as a brush) onto a destination texture as
    applied to a mesh. Here, the painting does not just happen between two independent
    textures but with a mesh and its UV mapping intervening between them. In other
    words, a source texture must be applied or projected onto a mesh surface in the
    scene, and then, the brush pixels must be unprojected back onto the destination
    texture through the mesh UV mapping. This ensures that the brush pixels are painted
    to the correct place within the destination texture, as shown in the following
    screenshot. This method, therefore, allows any source texture of any size to be
    painted onto any 3D surface and its destination texture of any size via UV mapping.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore how this is achieved practically and effectively.
    Before getting started, however, it should be mentioned that texture painting
    in this way should be pursued as a last resort when alternative methods (such
    as cut out quads) are not adequate. This is because true texture painting is computationally
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Texture painting](img/0655OT_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Real-time painting of textured brushes onto other textures via a mesh and its
    UV mapping
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete texture painting project can be found in the book's companion files
    (code bundle).
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – creating a texture blending shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s recognize the two-layer approach that''s ideal here. First, we
    have the brush source texture itself, which will be painted onto a destination
    texture when the user clicks on a mesh in the scene, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 – creating a texture blending shader](img/0655OT_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The brush texture, where black is transparent (alpha)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the destination texture applied to the mesh onto which the brush
    strokes should be overlaid when painted, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 – creating a texture blending shader](img/0655OT_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Destination texture onto which brushes should be painted
  prefs: []
  type: TYPE_NORMAL
- en: However, we don't usually want the painted brush strokes overwriting or changing
    the original destination texture during the paint operation. This is because the
    destination texture could be applied to multiple objects in the scene (at least
    in theory), and overwriting or changing the pixels of the original will result
    in its effects being propagated to all objects using the texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it''d be better to separate the paint effects onto a separate texture
    with a transparent background, which is layered over the destination texture via
    a custom material. This creates a true separation between the destination texture
    and the paint effects, even though in appearance, it appears as one consolidated
    texture. To achieve this effect, a custom shader must be written, as shown in
    the following code sample 9-4\. This shader blends a top texture (with alpha transparency)
    on top of a background texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the shader is coded and saved, it appears as a selectable shader type for
    any material you create via the **Material** panel in the Object Inspector. This
    shader should be used for any object onto which details must be painted, as shown
    in the following screenshot. The `_MainTex` slot refers to the background texture
    onto which details must be overlaid but which must also be preserved from any
    true edits. The `_BlendTex` slot refers to the texture to be overlaid onto `_MainTex`,
    which preserves its alpha transparency. Typically, this slot will be populated
    at runtime from script by generating an alpha transparent texture to receive brush
    strokes, as we'll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 – creating a texture blending shader](img/0655OT_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A custom shader is created to blend the top-most texture onto the bottom-most
    texture
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – creating a texture painting script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve now created a shader that accepts two textures as input (the top and
    bottom textures) and blends the top over the bottom; this allows alpha transparency.
    This results in a Photoshop-layer style effect. This allows us to separate texture
    painting onto a top texture while preserving the pixels of the original background
    below it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 – creating a texture painting script](img/0655OT_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a texture painting script
  prefs: []
  type: TYPE_NORMAL
- en: Before moving further, however, we must first edit the brush texture asset we
    plan on using via Object Inspector. Specifically, select the brush texture from
    the **Project** panel in the Unity Editor and change **Texture Type** to **Advanced**.
    Enable the checkbox for **Read/Write Enabled**; this allows the texture to be
    accessed using texture-editing functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, enable **Alpha is Transparency** and disable **Generate Mip Maps**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 – creating a texture painting script](img/0655OT_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring textures for texture painting
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll need to create a texture-painting script that allows us to paint
    the brush texture, using the mouse, onto a 3D object in the scene via its UV coordinates.
    The script is shown in the following code sample 9-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 9-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 008**: The public variable in this line maintains a reference to a valid
    texture asset to be used as the brush graphic during paint operations. For each
    mouse click, this texture will be "laid down" or painted onto the variable `SurfaceTexture`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 015**: `SurfaceTexture` will reference a dynamically generated texture
    filled, by default, with transparent pixels, which will reveal any texture layered
    beneath. This texture will accept all brush strokes during a paint operation.
    In short, this texture will be fed into the `TextureBlender` shader as the `_BlendTex`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 026-031**: A new texture is generated during the `Start` function.
    The texture is in the RGBA32 format, which supports an alpha channel. The `SetPixels`
    function is used to batch fill (flood fill) the texture with pixels of the same
    color. More information on the `GetPixels` and `SetPixels` functions are considered
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 046**: In the `Update` function, mouse clicks are detected to initiate
    the texture-painting functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 048-059**: If a mouse button is pressed, the function should paint
    the brush texture onto the destination. `Physics.Raycast` is called in line 52
    to determine several things, such as to see whether a mesh object in the scene
    was hit by the ray. For this to work properly, the object should feature a `Collider`
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 062-072**: If a collision was detected, the UV coordinates of the hit
    location should be retrieved through the `textureCoord` variable of the `RaycastHit`
    structure. More information on this variable can be found online in the Unity
    documentation at [http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html](http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html).
    This member, is only valid if the intersected mesh has `MeshCollider`, as opposed
    to other collider types, such as `BoxCollider` or `CapsuleCollider`. However,
    this means that any object used as a texture-painting destination should feature
    a `MeshCollider` component, since it contains UV data. Lines 63–72 then convert
    the UV coordinates into absolute pixel positions, centering the brush source texture
    at the position of the cursor. The result of this code is to clearly identify
    a position on the source brush texture that should be the pivot or origin point,
    and to establish a pixel *x*, *y* coordinate location at which the source texture
    should be painted into the destination texture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 075**: Finally, the `PaintSourceToDestTexture` function is called to
    perform the paint operation itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 081**: The `PaintSourceToDestTexture` function accepts four arguments:
    `Source`, `Dest`, `Left`, and `Top`. On the basis of these, the `Source` texture
    is painted onto the `Dest` at the positions `Left` and `Top`. This function is
    declared as static, which means that no instance of this class needs to be declared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 084-087**: The first step in the texture-painting process is to retrieve
    all pixels in both the `Source` and `Dest` textures. This is achieved using the
    `GetPixels` function. More information on `GetPixels` can be found online in the
    Unity documentation at [http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html](http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html).
    Now, although each image is visually a two-dimensional array of pixels, the returned
    array from `GetPixels` is in fact linear (one-dimensional). This is the reason
    for both the `GetPixelFromArray` and `SetPixelFromArray` functions, which convert
    pixel *x* and *y* positions into linear array indices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 89-101**: Here, each pixel is retrieved from the `Source` texture and
    painted onto the destination. This checks to ensure that the brush texture is
    painted with the destination bounds and allows clipping, if required. This is
    necessary because a brush mark could, in principle, be made close to the texture
    edge; in this case, only a part of the brush would actually be painted onto the
    destination, as some pixels would be "cut off". Pixels are retrieved from the
    `Source` texture with `GetPixelFromArray`, and destination pixels are set with
    `SetPixelInArray`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 106-107**: Finally, the destination pixels are pushed back to the destination
    texture buffer, and the `Apply` function is called to confirm the operation. Unity
    also supports a `SetPixel` function (singular) as opposed to `SetPixels` (plural).
    However, `SetPixels` results in better performance as it repeats the calling of
    `SetPixel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 111-114**: The `GetPixelFromArray` function accepts an array of pixel
    data as well as the *x* and *y* coordinates of a pixel and the pixel width of
    the texture data. On the basis of this, it returns a linear index into the pixel
    array where you can find the pixel color value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 117-131**: The `SetPixelInArray` function changes the color of a pixel
    in a linear array. The method of change is determined by the argument `Blending`.
    If `Blending` is set to `false`, the source pixel would simply replace the destination
    pixel. If `Blending` is `true`, the source pixel would be blended or layered onto
    the destination pixel that preserves the alpha transparency. `Blending` should
    be set to `true` when painting alpha-transparent brushes onto the target texture
    to allow for the accumulation and blending of color values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – setting up texture painting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a working shader, texture-painting script, and configured
    textures, we''ll take a step-by-step run-through of configuring texture painting
    in Unity. Start from an empty project, including only our shader, texture painting
    script, and two configured textures: a background texture and a brush texture,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – setting up texture painting](img/0655OT_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting a texture-painting project
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the brush texture from the **Project** panel to a small size (such
    as `32 x 32`) and set its **Format** to **RGBA 32 bit** for alpha transparency,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – setting up texture painting](img/0655OT_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a brush texture
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new material using the **TextureBlender** shader and assign the background
    texture to the `MainTexture` slot, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – setting up texture painting](img/0655OT_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new material from our TextureBlender shader
  prefs: []
  type: TYPE_NORMAL
- en: Add a new **Quad**, **Plane**, or **Mesh** to the scene and remove its collider,
    if any. This object will receive the final painted output, although the click
    detection will occur on a duplicate mesh. I am keeping the final output mesh and
    the click-detection mesh separate to allow the destination mesh to have other
    collider types or components if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Quad has been added, assign the custom material to it with the **TextureBlender**
    shader, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – setting up texture painting](img/0655OT_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new Quad
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate **Quad**, add **Mesh Collider**, disable **Mesh Renderer**, and assign
    an empty diffuse material to it. This mesh will not render, but will detect mouse
    clicks and perform the paint operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, add the `TexturePainter` script to the object and assign the **Brush
    Texture** field to the brush texture itself and the **Dest Mat** field to the
    **Custom_Mat** material from the **Project** panel, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – setting up texture painting](img/0655OT_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a click detection quad
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the application and start clicking on your mesh. When you do, paint
    strokes will be applied to the texture and display on the viewport, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – setting up texture painting](img/0655OT_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Texture painting completed
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered extensive ground under a general remit of "2D-ness". 2D
    was defined here not so much in the conventional sense of 2D games, but with a
    texture-based understanding that's critical to both 2D and 3D games more generally.
    The topics included the operations and ideas that pertain to the 2D plane and
    within the 2D space. Specifically, it explored how to create rotating Skybox backgrounds
    by building a manual Skybox, combined with the camera depth settings to create
    a layered render. Then, it explored how to generate procedural geometry such as
    planes. With the addition of Unity Quads as primitives, the generation of planes
    is more limited when taken alone, but the methods and concepts deployed to generate
    the Quad are more useful, allowing us to edit and tweak any mesh, whether it is
    a Quad or not. The real-time editing of meshes is important to create a wide range
    of effects, from shockwave explosions to jelly-based trampolines. Moving forward,
    we examined the animation of mesh UVs. They allowed us to scroll indefinitely
    across a 2D background Quad, with a tile-able texture, which is useful for parallax
    effects as well as for water and other motion-based illusions. Finally, we considered
    dynamic texture painting on a mesh, where, using the mouse, we can click on a
    mesh to paint a source texture onto the mesh texture that allows its UV coordinates
    and the alpha transparency to blend. This feature set is especially powerful and
    has wide applicability to create real-time decals, such as bullet holes, blood
    splatters, and player-based drawing. In the next chapter, we will consider a range
    of tips and techniques to work better with Unity projects.
  prefs: []
  type: TYPE_NORMAL
