- en: Error Handling over the Wire
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线上错误处理
- en: This chapter will explore the many possible failure points of a distributed
    application, and how the impact of a failure can be felt by downstream consumers
    of your application. We'll examine how different errors are reported or detected
    depending on the severity, context, and stage of the life cycle of network traffic.
    We'll explore a variety of error-handling strategies as they are implemented in
    C#, and demonstrate how conventions and standards can be leveraged to ensure that
    your application behaves as expected for any potential downstream consumers. Finally,
    we'll look at how to generate meaningful errors for your application's consumers
    when their requests cannot be reasonably serviced.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨分布式应用的许多可能的故障点，以及故障的影响如何被你的应用的下游消费者感受到。我们将检查不同错误根据严重性、上下文和网络流量生命周期的阶段如何被报告或检测。我们将探讨C#中实现的多种错误处理策略，并展示如何利用约定和标准确保你的应用对任何潜在的下游消费者都表现出预期的行为。最后，我们将探讨如何在请求无法合理服务时为你的应用消费者生成有意义的错误。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How different points of failure should generate different error messages, and
    how to recover from them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的故障点应生成不同的错误消息，以及如何从中恢复
- en: Common error codes and messages returned by services that have correctly implemented
    their respective communication protocols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已正确实现各自通信协议的服务返回的常见错误代码和消息
- en: Strategies for handling different kinds of errors depending on the needs your
    application must meet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据应用必须满足的需求处理不同类型错误的策略
- en: Using status codes, errors, logs, and messages to generate and report your own
    errors for downstream consumers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态码、错误、日志和消息为下游消费者生成和报告自己的错误
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We''ll be writing a substantial amount of sample code, which can be found on
    GitHub here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    7](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%207)[.](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%207)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写大量的示例代码，这些代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%207](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%207)
- en: Check out the following video to see the code in action: [http://bit.ly/2HT1l9z](http://bit.ly/2HT1l9z)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[http://bit.ly/2HT1l9z](http://bit.ly/2HT1l9z)
- en: This chapter will introduce a resilient network client called **Polly** to demonstrate
    common error-recovery strategies. I'd recommend reading up on some of the features
    of that particular library here: [https://github.com/App-vNext/Polly.](https://github.com/App-vNext/Polly)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一个名为**Polly**的弹性网络客户端来演示常见的错误恢复策略。我建议在这里了解该特定库的一些功能：[https://github.com/App-vNext/Polly.](https://github.com/App-vNext/Polly)
- en: Multiple devices, multiple points of failure
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多设备，多故障点
- en: There is an inexhaustible number of problems that can occur on even simple software
    when you introduce the unpredictability of network interactions. A single off-by-one
    error in an upstream service could mean a missing the closing curly-brace in a
    JSON string, rendering an entire payload impossible to parse. **Internet service
    provider** (**ISP**) service interruptions or weak wireless signals can result
    in timeouts and incomplete payload delivery. Meanwhile, the stability of the remote
    system you're requesting a resource from is entirely out of your control. With
    all these factors introducing the potential for errors, we can't simply hope to
    avoid errors or exceptions in our software. We must assume they will occur, and
    design around that eventuality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你引入网络交互的不确定性时，即使是简单的软件也可能出现无数的问题。上游服务中一个简单的索引错误可能导致JSON字符串中缺少闭合花括号，使得整个有效负载无法解析。**互联网服务提供商**（**ISP**）服务中断或弱无线信号可能导致超时和有效负载不完整交付。同时，你请求资源的远程系统的稳定性完全超出你的控制。由于所有这些因素都引入了错误的可能性，我们不能简单地希望避免软件中的错误或异常。我们必须假设它们会发生，并围绕这种可能性进行设计。
- en: External dependencies
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部依赖
- en: In our time as professional engineers, we can count on one hand the number of
    application we wrote that neither served as a network dependency for a downstream
    consumer, nor had a dependency on an upstream network resource. Every time your
    software must make a network hop to access a necessary resource, you're introducing
    the risk of failure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们作为专业工程师的时间里，我们可以用一只手数的过来，我们写的应用程序既没有作为下游消费者的网络依赖，也没有对上游网络资源有依赖。每次你的软件必须进行网络跳转以访问必要的资源时，你都在引入失败的风险。
- en: As a rule, any time you are reading data from an external dependency, you must
    implement proper exception handling. Always assume that something could go wrong.
    We didn't do this in the last chapter because we didn't want to introduce unnecessary
    complexity while I was still trying to fully elucidate the concepts and uses of
    data streams. However, in this chapter, we'll be looking exclusively at error-handling
    strategies. And the first strategy is to *always* assume accessing external dependencies
    will eventually fail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，每次从外部依赖中读取数据时，你必须实现适当的异常处理。始终假设可能会出错。我们在上一章没有这样做，是因为我们不想在试图完全阐明数据流的概念和使用方法时引入不必要的复杂性。然而，在这一章中，我们将专门探讨错误处理策略。首先的策略是**始终**假设访问外部依赖最终会失败。
- en: This is fairly straightforward when you are handling the response from another
    external dependency, but what if your own software is a dependency for another
    application? The next strategy for resilient application behavior is to always
    assume that your own software will eventually fail. This will encourage you to
    account for that fact and provide fault tolerance and useful error messaging for
    anyone who may be using your software at the moment of failure. With that in mind,
    let's start with our network access code from the last chapter and modify it for
    better resiliency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理另一个外部依赖的响应时，这相当直接，但如果你自己的软件是另一个应用程序的依赖呢？对于具有弹性应用程序行为的下一个策略是始终假设你自己的软件最终会失败。这将鼓励你考虑到这一点，并为在失败时刻使用你软件的任何人提供容错性和有用的错误信息。考虑到这一点，让我们从上一章的网络访问代码开始，并对其进行修改以增强其弹性。
- en: 'Looking back at our method, we had the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的方法，我们有以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within this method, we have one external dependency. We could encounter a failure
    when we attempt to access and process the response we receive from the server.
    Any number of issues could arise here for any number of reasons, so we''ll want
    to wrap that code in a `try`/`catch` block, or apply an exception filter in our
    code (more on that shortly). We''ll start with a simple `try`/`catch` block, looking
    at an incredibly useful built-in `Exception` class for our purposes, the `WebException`
    class. So let''s catch that, and see what kind of utility we can get from it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们有一个外部依赖。当我们尝试访问和处理从服务器收到的响应时，可能会遇到失败。由于任何原因，都可能在这里出现任何数量的问题，因此我们希望将这段代码包裹在`try`/`catch`块中，或者在代码中应用异常过滤器（稍后会更详细地介绍）。我们将从一个简单的`try`/`catch`块开始，查看对我们目的非常有用的内置`Exception`类，即`WebException`类。所以让我们捕捉它，看看我们能从中获得什么样的效用：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, you'll note that we don't have to look for exceptions until we block our
    code and wait for the response to return. If we kick off an asychronous task and,
    while executing, that task throws an error, it doesn't reach our code until we
    `await` the result of that task. When we catch the error that we know we'll get
    (since the [test-domain.com](http://test-domain.com/) resource doesn't actually
    exist), we catch it as `WebException`. This class is the base exception class
    you will receive from any network-specific exceptions your code encounters. What
    makes this especially useful, as opposed to the `catchall Exception` class, is
    the availability of the network error-specific `Status` property.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你会注意到我们不必在阻塞我们的代码并等待响应返回之前寻找异常。如果我们启动一个异步任务，在执行过程中该任务抛出错误，那么它不会到达我们的代码，直到我们`await`该任务的结果。当我们捕获我们知道的错误（因为[http://test-domain.com/](http://test-domain.com/)资源实际上不存在）时，我们将其捕获为`WebException`。这个类是你从代码中遇到的任何特定于网络的异常中接收到的基异常类。与`catchall
    Exception`类相比，使其特别有用的是网络错误特定的`Status`属性可用。
- en: In this sample, we're merely logging the status and the exception message to
    our console. If the code existed in an API that we wrote, however, and was exposed
    exposed to downstream entities over a network, we would be responsible for returning
    a meaningful status code of our own. Doing so ensures that if our specific application
    code is the primary point of failure in a process pipeline, we are providing as
    much information as possible to reliably respond to, and recover from, our exceptions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只是在控制台记录状态和异常消息。然而，如果这段代码存在于我们编写的API中，并且通过网络暴露给下游实体，我们就需要负责返回一个有意义的自定义状态码。这样做可以确保如果我们的特定应用程序代码是流程中的主要故障点，我们将尽可能提供信息，以便可靠地响应和恢复异常。
- en: Parsing the exception status for context
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析异常状态以获取上下文
- en: When there is an error status returned in `WebException`, the value of that
    property can tell us a lot about what failed and why. The `Status` property is
    an instance of the `WebExceptionStatus` enum, and the values returned can tell
    us a lot about the conditions that caused our external dependency to fail. It
    may have been a routing issue, or an inability to resolve a cache lookup or to
    maintain an active connection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`WebException`中返回错误状态时，该属性的值可以告诉我们很多关于失败原因的信息。`Status`属性是`WebExceptionStatus`枚举的一个实例，返回的值可以告诉我们很多关于导致我们的外部依赖失败的条件。这可能是一个路由问题，或者无法解析缓存查找或保持活跃连接。
- en: The information you can discern simply from checking the value of the status
    code can tell you a lot about what specifically failed and what recovery strategy
    is most likely to yield positive results. For example, if your exception has a `Status`
    of `NameResolutionFailure`, you can safely assume that retrying the request won't
    be an effective strategy. If the DNS failed to identify the host based on the
    provided name at your first attempt, subsequent attempts with the same hostname
    are unlikely to prove fruitful. However, if you receive an error status of the `Timeout` type,
    you could potentially increase your timeout threshold on your request client and
    submit a series of retries, up to a predetermined maximum timeout length.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过检查状态码的值，你可以了解到很多关于具体失败原因和最有可能产生积极结果的恢复策略。例如，如果你的异常的`Status`是`NameResolutionFailure`，你可以安全地假设重试请求不会是一个有效的策略。如果在第一次尝试中DNS未能根据提供的名称识别主机，那么使用相同主机名的后续尝试不太可能取得成效。然而，如果你收到一个`Timeout`类型的错误状态，你可能会增加请求客户端的超时阈值并提交一系列重试，直到达到预定的最大超时长度。
- en: The documentation for the `WebException` status is freely available, and it's
    up to you to identify which possible exception statuses you can encounter. Furthermore,
    once you know where or what in the request chain failed, you can determine the
    best recovery strategy for your application code. The main takeaway here, though,
    is that you should check for and attempt to recover from the `WebException` occurrences
    at any point in your application in which a request is transmitted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebException`状态的文档是免费可用的，你需要自己确定可能遇到的哪些可能的异常状态。此外，一旦你知道请求链中失败的位置或原因，你就可以确定最适合你应用程序代码的最佳恢复策略。然而，这里的主要启示是，你应该在任何请求传输的应用程序点检查并尝试从`WebException`事件中恢复。'
- en: Status codes and error messages
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态码和错误信息
- en: Now that we know where we should be checking for potential exceptions (or providing
    them for our consumers), it's important to understand what those exceptions could
    ultimately look like. Identifying the full scope of possible exceptions and writing
    recovery solutions for each possibility will make our code nearly bulletproof
    against the unreliability of distributed resource acquisitions. While we've already
    seen that we can access hugely useful information just by inspecting the `WebException` exception
    that is thrown by any failed network requests we could make, there's still a lot
    to understand about the standards of Internet status code specifications and exceptional
    response handling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们应该在哪里检查潜在的异常（或为我们消费者提供它们），了解这些异常可能最终看起来是什么样子是很重要的。确定可能的异常的完整范围并为每种可能性编写恢复解决方案将使我们的代码几乎对分布式资源获取的不可靠性具有防弹效果。虽然我们已经看到，我们只需检查由任何失败的网路请求抛出的`WebException`异常，就可以访问到极其有用的信息，但关于互联网状态码规范和异常响应处理的标准还有很多需要了解。
- en: Status messages and status codes
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态信息和状态码
- en: 'First, let''s look at a reliable approach to handling different status responses
    in the case of an error from an upstream dependency. Let''s use the same snippet
    of code from our earlier example, but respond more robustly to the variety of
    possible statuses we could receive. To keep our request code short, we''ll delegate
    the exception handling code to a different method named `ProcessException(WebException
    ex)`. The two parameters of this method will be the exception that was generated,
    as well as the original request that triggered the exceptional state in our code.
    This will give the exception-processing method sufficient context about the original
    request to attempt to recover gracefully from the error. So, inside the `catch`
    block of our earlier example, we''ll replace our two `Console.WriteLine()` statements
    accordingly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在处理上游依赖项错误的不同状态响应时的一个可靠方法。让我们使用我们之前示例中的相同代码片段，但更稳健地响应我们可能收到的各种状态。为了使我们的请求代码更短，我们将异常处理代码委托给一个名为`ProcessException(WebException
    ex)`的不同方法。这个方法的两参数将是生成的异常，以及触发我们代码中异常状态的原请求。这将给异常处理方法足够的上下文，以便尝试优雅地从错误中恢复。因此，在我们的早期示例的`catch`块中，我们将相应地替换我们的两个`Console.WriteLine()`语句：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, from within our `ProcessException(WebException ex)` method, we''ll switch
    on the possible value of the exception `Status` property, performing useful recovery
    logic based on the status or messages received:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`ProcessException(WebException ex)`方法内部，我们将根据异常的`Status`属性的可能值进行切换，根据接收到的状态或消息执行有用的恢复逻辑：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By using the descriptive and reliable status codes returned by `WebException`,
    we can group similar errors together, and respond to them with resolutions that
    will likely resolve the common issue for each of them. If there were issues with
    connectivity or timeouts, there may simply have been an issue with your ISP, or
    the remote host simply didn't have the resources loaded from the cache, and so
    took too long to process the request. In that case, simply trying again may well
    prove to be a consistently reliable solution. However, if the exception was due
    to an inability to resolve the target hostname, then subsequent requests will
    likely fail in the same way. They'd all be processed by the same DNS, so unless
    the request URI is updated to a valid host name, there's no benefit in retrying
    the request. Meanwhile, security issues can likely be resolved by refreshing authentication
    or authorization credentials.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`WebException`返回的描述性和可靠的状态代码，我们可以将类似的错误分组在一起，并针对它们提供解决方法，这些解决方法可能会解决每个问题的共同问题。如果有连接或超时问题，可能只是你的ISP有问题，或者远程主机没有从缓存中加载资源，因此处理请求花费了太多时间。在这种情况下，简单地重试可能确实是一个持续可靠的解决方案。然而，如果异常是由于无法解析目标主机名，那么后续请求可能会以相同的方式失败。它们都会由相同的DNS处理，除非请求URI更新为有效的域名，否则重试请求没有好处。同时，安全问题可能通过刷新身份验证或授权凭据来解决。
- en: You'll note that the default simply recommends publishing the inner message
    returned with the `WebException` class. This is because, in cases where there
    is no common status code returned by the server, the class itself will have some
    default messaging about what has probably gone wrong. So even if we get back an
    instance of `WebExceptionStatus.UnknownError`, there will likely still be useful
    information returned as part of the error message.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到默认建议发布与`WebException`类返回的内部消息。这是因为，在没有服务器返回通用状态代码的情况下，该类本身将有一些关于可能发生什么问题的默认消息。因此，即使我们得到`WebExceptionStatus.UnknownError`的实例，错误消息中也可能返回一些有用的信息。
- en: Useful error messages
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的错误消息
- en: If we find ourselves in a scenario where we cannot gracefully recover from a
    failed attempt to request resources from an upstream dependency, and we cannot
    proceed with the service our application provides, it's time to send an error
    message of our own. It is our responsibility to provide as much information about
    the failure state as we can for the user to understand what went wrong while avoiding
    sending back any potentially compromising details that could open our application
    up to vulnerabilities.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现自己处于一个场景中，无法优雅地从尝试从上游依赖项请求资源失败中恢复，并且无法继续提供我们的应用程序提供的服务，那么是时候发送我们自己的错误消息了。我们有责任尽可能提供关于失败状态的信息，以便用户理解出了什么问题，同时避免发送任何可能使我们的应用程序容易受到漏洞攻击的潜在敏感细节。
- en: This is where status codes become your best friend. When you're handling HTTP
    requests against your application, you should be as specific as you possibly can
    with which status codes you return. It may seem extremely simple to return a 500
    status code every time something goes wrong, with your own software, since 5XX
    is the blanket code designation for a server error. If you want people to be happy
    to use your services, though, I would recommend you don't. The more specific you
    can be with your status codes, the less work any of your consumers have to put
    in to understanding and recovering from issues on their own side of the equation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是状态码成为你最好朋友的地方。当你处理针对你应用的HTTP请求时，你应该尽可能具体地指定你返回的状态码。每次出问题时返回一个500状态码可能看起来非常简单，因为5XX是服务器错误的通用代码标识。然而，如果你想让人们愿意使用你的服务，我建议你不要这样做。你越具体地使用状态码，你的消费者在理解和从他们自己那一侧的问题中恢复时需要付出的努力就越少。
- en: Using the most specific status codes possible also gives us a risk-free way
    of communicating enough information about what went wrong, while not communicating
    anything that could put our software at risk. If you respond to a bad authentication
    request with a 401 status code (the status code for "unauthorized"), users will
    know that they have to adjust their authentication mechanism. However, if you
    simply returned a blanket 400 status code, along with a message indicating that
    the minimum character requirements for a password is eight, then you've just given
    potential malicious actors more information about your authentication scheme than
    they had before their failed attempt. And with malicious software, *any* information
    about the specifics of your system is dangerous.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尽可能具体的状态码也给我们提供了一个风险免费的方式来传达足够关于出了什么问题的信息，同时不传达任何可能使我们的软件处于风险中的信息。如果你用一个401状态码（表示“未授权”）响应一个错误的认证请求，用户就会知道他们需要调整他们的认证机制。然而，如果你只是返回一个通用的400状态码，以及一个表示密码最小字符要求为八个的消息，那么你刚刚给了潜在的恶意行为者比你之前尝试失败之前更多的关于你的认证方案的信息。而且，对于恶意软件来说，关于你系统具体信息的任何信息都是危险的。
- en: Understanding how much information is enough, versus too much, can be a delicate
    balancing act. Much of knowing what others will want to see from your software
    will come from experience. The more external services you see sending useless
    Something went wrong. Oops! error messages, the more you'll have an idea of what
    you would have wanted to know, and how you can do better in your own code in the
    future. A good rule of thumb when you're starting out, though, is that status
    codes should be as specific as possible, and error messages should be as vague
    as you can get away with. In HTTP, error status codes are all isolated to the
    4XX and 5XX values. These two groupings designate request servicing errors and
    server errors, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理解多少信息是足够的，与过多信息，可能是一种微妙的平衡行为。了解其他人将从你的软件中看到什么，很大程度上来自于经验。你看到的越多外部服务发送无用的“出了问题。哎呀！”错误消息，你就越会知道你想要知道什么，以及你如何在未来的代码中做得更好。然而，当你刚开始时，一个很好的经验法则是状态码应该尽可能具体，错误消息应该尽可能模糊。在HTTP中，错误状态码都集中在4XX和5XX值上。这两个分组分别指定请求服务错误和服务器错误。
- en: A request-servicing error relates to anything about the structure, origin, or
    nature of the request that caused the failure to occur. So, anything from requesting
    a resource that doesn't actually exist at the requested location (404 - Not Found),
    to requesting a resource with an HTTP verb that isn't supported by the listening
    server (405 - Method Not Allow) to requesting access to resources for which the
    client isn't authorized (401 - Unauthorized).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请求服务错误与导致失败发生的请求的结构、来源或性质有关。因此，从请求一个在请求位置实际上不存在的资源（404 - 未找到），到请求一个由监听服务器不支持HTTP动词的资源（405
    - 方法不允许），再到请求客户端未授权访问的资源（401 - 未授权）。
- en: Server errors, on the other hand, relate to issues that have occurred after
    a correct and well-formed address has been received. There are far fewer of these
    since most well-formed requests are considered well formed specifically because
    there is a server configured to process it. The reasons for a 5XX response range
    from failure of an upstream server to process some aspect of the client request
    (502 - Bad Gateway/504 - Gateway Timeout), to the target server simply being out
    of commission or unavailable at the time of the request (503 - Service Unavailable).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，服务器错误与在接收到正确且格式良好的地址之后发生的问题有关。这些问题的数量要少得多，因为大多数格式良好的请求被认为是格式良好的，特别是因为已经配置了服务器来处理它们。5XX响应的原因范围从上游服务器无法处理客户端请求的某些方面（502
    - 网关错误/504 - 网关超时），到目标服务器在请求时根本无法使用或不可用（503 - 服务不可用）。
- en: If you're sending correct error codes, it is incredibly unlikely that you will
    ever find yourself returning a 5XX error code explicitly from within your own
    code. If your software is written well, issues that cause it to throw an error
    will almost always be ultimately traceable to some aspect of an incoming request.
    When that happens, though, it is absolutely your responsibility to do your best
    to find out what, specifically, about the request caused the error, and report
    it back promptly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发送的是正确的错误代码，那么你几乎不可能在自己的代码中明确返回5XX错误代码。如果你的软件编写得很好，导致它抛出错误的问题几乎总是可以追溯到某个入站请求的某个方面。然而，当这种情况发生时，你有绝对的义务尽你所能找出是什么具体关于请求导致了错误，并迅速报告。
- en: Error-handling strategies
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理策略
- en: Now that we've seen the tools available to you when encountering error messages
    from network resources (and when sending error messages of your own), let's take
    a look at what to do with them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在遇到来自网络资源的错误消息（以及发送自己的错误消息）时你可以使用的工具，让我们来看看我们应该如何处理它们。
- en: How should we best respond to a `RequestCancelled` exception status? Which failure
    states are likely to have a common root cause, and thus a common shared solution?
    How should our software respond to our own users when we can't recover from errors
    further upstream? In this section, we'll take a look at each of these questions,
    and leave with some concrete approaches that can be adapted and scaled to almost
    any circumstance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何最好地响应`RequestCancelled`异常状态？哪些故障状态可能有一个共同的根源，因此有一个共同的共享解决方案？当我们无法从更上游的错误中恢复时，我们的软件应该如何对我们的用户做出响应？在本节中，我们将探讨这些问题中的每一个，并留下一些可以适应和扩展到几乎所有情况的具体方法。
- en: Resilient requests with Polly
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Polly实现弹性请求
- en: As we already saw in our previous code sample, it's not uncommon to respond
    to a number of similar error statuses with the same general recovery solution.
    This is a great practice for simplifying your code base, and can provide durable
    exception handling in a wide variety of common situations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的代码示例中已经看到的，用相同的一般恢复解决方案来响应多个类似错误状态并不罕见。这是一种简化代码库的绝佳实践，并且可以在各种常见情况下提供持久的异常处理。
- en: This act of associating common network issues into groups that can be resolved
    with similar strategies is exactly the idea behind the Polly library for resilient
    HTTP clients. While we're not looking specifically at HTTP now, it is one of the
    most robust libraries out there for one of the most common network protocols,
    so I think it bears examination as we continue to look at error-recovery strategies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将常见的网络问题分组，以便可以使用类似策略解决的行为，正是Polly库为弹性HTTP客户端背后的理念。虽然我们现在不是专门研究HTTP，但它是最健壮的库之一，用于处理最常见的网络协议之一，因此我认为在我们继续研究错误恢复策略时，它值得检查。
- en: 'The first order of business is to include the package in our project either
    through an explicit inclusion in the NuGet package manager, or with the following
    command-line input:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是将在我们的项目中包含该包，无论是通过在NuGet包管理器中明确包含，还是使用以下命令行输入：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once it's installed, we can declare a `Policy` class for how we plan to handle
    various network exceptions using Polly's declarative handler and recovery methods.
    The `Policy` class is a robust, transient container for a given task. We define
    a delegate, and then we provide that delegate to a `Policy` for execution. The
    `Policy` class then uses the actively-defined error handlers and their recovery
    definitions to execute the task, and then listen for and respond to exceptional
    states accordingly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，我们可以声明一个`Policy`类，用于使用Polly的声明性处理程序和恢复方法来处理各种网络异常。`Policy`类是一个健壮的、短暂的容器，用于特定的任务。我们定义一个委托，然后将该委托提供给`Policy`以执行。然后`Policy`类使用活动定义的错误处理程序及其恢复定义来执行任务，并相应地监听和响应异常状态。
- en: Exceptions that we want Polly to respond to are set with the generic `Handle<T>()`
    method, where `T` is some subclass of the `Exception` type. The `Handle<T>()`
    method also takes optional conditional parameters specifying the state of the
    `Exception` type we want to respond to with the corresponding recovery specification.
    This gives us the ability to define specific recovery strategies for different
    states. Let's look at this in action to see what I mean.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望Polly响应的异常使用通用的`Handle<T>()`方法设置，其中`T`是`Exception`类型的某个子类。`Handle<T>()`方法还接受可选的条件参数，指定我们想要使用相应的恢复规范响应的`Exception`类型的状态。这使我们能够为不同的状态定义特定的恢复策略。让我们看看这个动作，以了解我的意思。
- en: 'First, we''re going to define a method for requesting some remote resource.
    This will only be used for demonstration purposes, so we''ll want it to occasionally
    fail and occasionally succeed. For that, we''ll just generate a random number,
    and if the number is even, we''ll throw an exception; otherwise, we''ll return
    a valid response. Importantly, though, we''ll want to log our failed attempts
    onscreen so we can see the retry in action:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个用于请求某些远程资源的方法。这只是为了演示目的，所以我们希望它偶尔失败，偶尔成功。为此，我们只需生成一个随机数，如果数字是偶数，我们将抛出一个异常；否则，我们将返回一个有效的响应。然而，重要的是，我们希望在屏幕上记录我们的失败尝试，这样我们就可以看到重试的效果：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will be the delegate that we pass to our `Policy` object once we''ve defined
    our recovery strategy and want to try to execute it. Next, we''ll define behaviors
    for a couple of the error states we defined in our naive error-handling code from
    earlier. For the sake of readability, we''ll define some private class variables
    to hold the groups of the `WebExceptionStatus` values that we had logically lumped
    together:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们在定义了恢复策略并想要尝试执行它之后传递给我们的`Policy`对象的委托。接下来，我们将定义我们之前在简单的错误处理代码中定义的几个错误状态的行为。为了提高可读性，我们将定义一些私有类变量来保存我们逻辑上合并的`WebExceptionStatus`值组：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With that, we can easily define a `Policy` object that responds to `WebException`
    with a status in one of our groupings, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以轻松地定义一个`Policy`对象，该对象对具有我们分组中状态之一的`WebException`做出响应，如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that when we execute `Policy`, we specify that as long as we get `WebExceptionStatus`
    defined in our `connectionFailure` grouping, we want to retry the request. So,
    let''s now call this from a driver program a few times and see what our console
    looks like after each run. The assumption is due to the sufficient randomness
    of the pseudo-random number generator, there should be at least a few runs that
    fail multiple times before returning a valid response. (Note that, for the purposes
    of this demo, all of the Polly code exists in a `static PollyDemo` class). Let''s
    have a look at the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们执行`Policy`时，我们指定只要我们得到在`connectionFailure`分组中定义的`WebExceptionStatus`，我们希望重试请求。所以，现在让我们从这个驱动程序程序中多次调用它，看看每次运行后我们的控制台看起来像什么。假设由于伪随机数生成器的足够随机性，应该至少有几次运行在返回有效响应之前多次失败。（注意，为了演示的目的，所有的Polly代码都存在于一个`static
    PollyDemo`类中）。让我们看一下以下代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you have your IDE configured to break on errors, you'll get a pause in execution
    every time your code fails. Just running this code myself, though, I saw an instant
    success, and then five consecutive retries before my code successfully executed.
    The fact that I was able to define that in fewer than 10 lines of code is incredible,
    and speaks to the value of Polly in providing resiliency to an application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经将你的IDE配置为在错误时中断，那么每次你的代码失败时，你都会在执行中暂停。然而，我自己运行这段代码时，我看到了立即的成功，然后是五次连续的重试，我的代码才成功执行。我能够在不到10行代码中定义这一点是令人难以置信的，这也说明了Polly在为应用程序提供弹性方面的价值。
- en: However, if we want to truly mirror the behavior we established in our naive
    error-handling code from earlier, we want to respond to a variety of exceptional
    states with specific recovery codes based on which state was reached. For that,
    Polly allows you to define multiple state handlers and then wrap them together
    in a `PolicyWrap` class, which does precisely. It will allow you to define the
    recovery policies for as many conditional states as you need, and then wrap them
    up in a single common policy to be respected when your `PolicyWrap` instance's
    `Execute(delegate)` method is called.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要真正地反映我们在之前简单错误处理代码中建立的行为，我们希望根据达到的状态对各种异常状态响应以特定的恢复代码。为此，Polly允许你定义多个状态处理器，然后将它们包装在`PolicyWrap`类中，这正是它所做的事情。它将允许你为所需的任何条件状态定义恢复策略，然后将它们包装在一个单一的共同策略中，当调用`PolicyWrap`实例的`Execute(delegate)`方法时，将遵守这个策略。
- en: 'To demonstrate this, we''ll define a few additional exceptional states for
    our delegate, such that if the random number generated is divisible by `3`, we''ll
    throw a name resolution error, and if the number is divisible by `4`, we''ll throw
    a security error:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将为我们的代理定义几个额外的异常状态，这样如果生成的随机数能被`3`整除，我们将抛出一个名称解析错误；如果数字能被`4`整除，我们将抛出一个安全错误：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have a random chance that at least one of our exceptional conditions
    is met, let's define the behavior for each circumstance. As you might have noticed
    from my console messages, we'll use a different strategy for each specific error
    case. Polly defines a small number of policies out of the box, and you can invoke
    each one in the case for which it is most useful. I won't go into all of them
    now, but I will take a moment to encourage you to read up on Polly's documentation
    ([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)). It's
    longer than this whole chapter, but well written and immeasurably useful for anyone
    looking to provide more reliable stability to a production application. For now
    though, we'll just be looking at the `Circuit-breaker` policy and the `Fallback`
    policy. These two seem most useful for our use cases since they most closely match
    the strategy we identified in our naive approach.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在有随机机会满足我们的至少一个异常条件，让我们定义每种情况下的行为。正如你可能从我的控制台消息中注意到的，我们将为每个特定的错误情况使用不同的策略。Polly默认定义了一些策略，你可以在最需要的情况下调用每个策略。现在我不会详细介绍所有这些策略，但我会花点时间鼓励你阅读Polly的文档([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly))。它比这一整章都要长，但写得很好，对于任何希望为生产应用程序提供更可靠稳定性的开发者来说，它都是极其有用的。不过，现在我们只关注`Circuit-breaker`策略和`Fallback`策略。这两个策略似乎对我们用例最有用，因为它们与我们先前简单方法中确定的战略最为接近。
- en: The `Fallback` policy is by far the simpler of the two. It simply allows you
    to designate an alternative response to return in the event of the specified exception
    being handled. In our example, since we'll be using `Fallback` for our security
    exceptions, we'll simply return a new instance of `HttpResponseMessage` with a
    401 status code set to notify our downstream consumers that there is an issue
    with authorization that needs to be resolved.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fallback`策略是两个中较简单的一个。它仅仅允许你在处理指定的异常时返回一个替代响应。在我们的例子中，由于我们将使用`Fallback`来处理我们的安全异常，我们将简单地返回一个新的`HttpResponseMessage`实例，并将状态码设置为401，以通知我们的下游消费者存在需要解决的问题，即授权问题。'
- en: The Circuit-breaker policy designates that multiple failed attempts to resolve
    a request should open the circuit to the requested resource, and stop subsequent
    requests before they start. This is useful in scenarios like the one we've defined
    for name resolution failures, where, based on the error message subsequent attempts
    are no more likely to be successful than the original request. Opening the circuit
    (and thus stopping the flow of requests over that circuit) gives the upstream
    system a chance to recover without being bombarded by a series of retry attempts.
    You can configure the circuit to open after a designated number of failed attempts
    or after a designated timeout, and you can set it to stay open for as long as
    you determine would probably be necessary to allow the upstream system to recover.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器策略指定，在多次尝试解决请求失败后，应该打开电路到请求的资源，并在请求开始之前停止后续请求。这在像我们为名称解析失败定义的场景中很有用，在这种情况下，基于错误消息，后续尝试成功的可能性并不比原始请求更高。打开电路（从而停止通过该电路的请求流）给上游系统一个机会，在没有被一系列重试尝试轰炸的情况下恢复。你可以配置电路在指定数量的失败尝试或指定超时后打开，并且你可以设置它保持打开状态，直到你认为这可能是必要的，以便允许上游系统恢复。
- en: Unlike the retry policy and its variants, though, the Circuit-breaker doesn't
    actually do anything in response to errors being thrown. In fact, it will always
    re-throw any caught errors; even if the circuit has already been broken. If you
    want to retry requests after the designated reset period for an open circuit,
    you are free to implement that behavior yourself, but by default, the Polly `spec`
    doesn't do so with its Circuit-breaker implementation. So in our example, we're
    going to break the circuit after only one failed attempt, and we'll still need
    to look for the appropriate error messages in `try`/`catch` from our calling code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与重试策略及其变体不同，然而，断路器在响应抛出的错误时实际上并不做任何事情。事实上，它总是会重新抛出任何捕获到的错误；即使电路已经断开。如果你想在开放电路指定的重置周期后重试请求，你可以自由地实现这种行为，但默认情况下，Polly的`spec`不会在其断路器实现中这样做。因此，在我们的示例中，我们将在只有一次失败尝试后断开电路，我们仍然需要在调用代码的`try`/`catch`中查找适当的错误消息。
- en: 'With that in mind, let''s update our previous example. The first thing we''ll
    do is add a method to return the 401 status code in `HttpResponseMessage` for
    our `Fallback` policy:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们更新我们之前的示例。我们首先要做的是为我们的`Fallback`策略添加一个方法，返回`HttpResponseMessage`中的401状态码：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we''ll set policies for each of our two alternative error states, and
    wrap them accordingly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将为我们的两种替代错误状态设置策略，并相应地包装它们：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, in our revised method, we define a policy for each possible scenario we
    want to respond to, including the specific state of the exception that should
    be handled and the recovery process we want to implement. Of note, though, are
    the two different calls to the `Policy.Wrap()` method. The reason for this is
    that using the `Fallback()` method on a strongly-typed instance of `Policy<HttpResponseMessage>`
    is the only way we can designate the type of the return object from the delegate
    method we passed into `Fallback()`. However, by strongly typing the policy, we
    can't `Wrap()` it with the other weakly-typed policies in a single call. The `Wrap()`
    method of strongly-typed policies can take at most one argument. So the workaround
    for this is to first wrap all of the weakly-typed policies we've defined, and
    then use that wrapped `Policy` instance as the input to the `Wrap()` call on our
    strongly-typed `Policy`. This is confusing, initially, I realize, but will become
    clearer as you work with Polly, read their excellent documentation, and most importantly,
    implement these error-handling strategies in any networked software you write.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的改进方法中，我们为每个我们想要响应的可能场景定义一个策略，包括应该处理的特定异常状态和我们要实施的恢复过程。值得注意的是，我们调用了`Policy.Wrap()`方法两次。这样做的原因是，在`Policy<HttpResponseMessage>`的强类型实例上使用`Fallback()`方法是唯一能够指定我们传递给`Fallback()`的委托方法返回对象类型的方式。然而，通过强类型化策略，我们无法在单个调用中将它`Wrap()`到其他弱类型策略中。强类型策略的`Wrap()`方法最多只能接受一个参数。因此，这个问题的解决方案是首先将我们定义的所有弱类型策略包装起来，然后使用那个包装好的`Policy`实例作为输入到我们强类型`Policy`的`Wrap()`调用。我明白这最初可能会让人困惑，但随着你使用Polly、阅读他们出色的文档以及最重要的是，在编写的任何网络软件中实施这些错误处理策略，这将会变得更加清晰。
- en: 'To make our driver program a little simpler to use for test purposes (instead
    of having to run the program by hand two dozen times to see all possible outcomes),
    we''ll update that as well. Let''s have a look at the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的驱动程序程序在测试目的上使用起来更简单（而不是手动运行程序二十多次来查看所有可能的结果），我们也将更新它。让我们看一下以下代码：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run that program once (maybe twice, since randomness is random, after all) and
    you should see the appropriate log statements for each of our possible scenarios.
    I'm counting on you to understand the nature of the flow of control through our
    program to understand why the results onscreen demonstrate the promised functionality
    of the `Policy` objects we defined.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该程序一次（也许两次，因为毕竟随机性是随机的）你应该会看到我们每个可能场景的适当日志语句。我指望你能理解我们程序中控制流的本质，以了解为什么屏幕上的结果展示了我们定义的`Policy`对象所承诺的功能。
- en: As we move forward and look at specific implementations of different network
    protocols, we'll be leaning heavily on Polly to define our recovery strategies.
    There's a lot of depth to the library, and you'll get out of it whatever you choose
    to put in to learning it. With this foundation, though, you'll be well equipped
    to move forward through the rest of this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进并查看不同网络协议的具体实现，我们将大量依赖Polly来定义我们的恢复策略。这个库有很多深度，你可以从中得到你选择投入学习的任何东西。然而，有了这个基础，你将准备好继续阅读本书的其余部分。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a close look at how the .NET Core `WebException` class
    provides engineers with a stable, reliable, and informative interface for understanding
    network errors as they arise. We looked at where and when we should expect and
    account for network exceptions, and how we could inspect the `Status` property
    of those exceptions to determine their root cause. We also considered our responsibility
    in providing meaningful exception messaging, as well as the value of providing
    as specific a status code as possible for any consumers of our software. Finally,
    we looked at some common strategies, and an extremely useful library in the form
    of Polly, for consistently recovering from network exceptions to maximize our
    application's up time and increase our consumers' trust in our software. It will
    be important to keep these ideas of resilience and optimization in mind going
    forward.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了.NET Core `WebException`类如何为工程师提供一个稳定、可靠且信息丰富的接口，以便在出现网络错误时理解它们。我们讨论了何时以及如何预期和解释网络异常，以及如何检查这些异常的`Status`属性以确定其根本原因。我们还考虑了提供有意义的异常消息的责任，以及为我们的软件的任何消费者提供尽可能具体的状态代码的价值。最后，我们探讨了常见的策略，以及一个极其有用的库Polly，用于持续地从网络异常中恢复，以最大化我们的应用程序的运行时间和增加消费者对我们软件的信任。在未来的工作中，保持这些弹性和优化的想法将非常重要。
- en: In our next chapter, we'll be stepping into the world of low-level data transmission
    and host-to-host communication.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入低级数据传输和主机间通信的世界。
- en: Questions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is one thing we should always assume about external dependencies?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该始终假设关于外部依赖性的一件事是什么？
- en: What are the two categories of error status codes in HTTP?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP中的错误状态代码分为哪两类？
- en: Which property of the `WebException` class can we use to determine the nature
    of the exception we received?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`WebException`类的哪个属性来确定我们收到的异常的性质？
- en: What does Polly's fallback policy provide for an exception state?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Polly的回退策略为异常状态提供了什么？
- en: How does a Circuit-breaker policy specification differ from a `retry` policy
    specification?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电路断路器策略规范与`retry`策略规范有何不同？
- en: Write a sample method that combines `fallback` and `retry` policies based on
    the `StatusCode` of the response from a sample request.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个示例方法，该方法基于从示例请求的响应中的`StatusCode`结合`fallback`和`retry`策略。
- en: In which circumstances would you not want to retry a web request after an initial
    failure?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪些情况下，你不想在初始失败后重试网络请求？
- en: Further reading
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about specific error-handling strategies with various network
    software architectures, check out the book *Learning ASP.NET Core 2.0*, by *Jason
    De Oliveira* and *Michel Bruche**t*. This will provide more in-depth guidance
    on error handling in ASP.NET Core-based HTTP application scenarios. The book is
    available electronically or in print, here: [https://www.packtpub.com/application-development/learning-aspnet-core-20.](https://www.packtpub.com/application-development/learning-aspnet-core-20)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关各种网络软件架构的具体错误处理策略的更多信息，请参阅*Jason De Oliveira*和*Michel Bruche**t*合著的《*学习ASP.NET
    Core 2.0*》。这本书将为基于ASP.NET Core的HTTP应用场景中的错误处理提供更深入的指导。本书电子版或印刷版均可购买，链接如下：[https://www.packtpub.com/application-development/learning-aspnet-core-20.](https://www.packtpub.com/application-development/learning-aspnet-core-20)
- en: 'Alternatively, I would once again recommend *C# 7 and .NET: Designing Modern
    Cross-platform Applications,* by*Mark J. Price* and *Ovais Mehboob Ahmed Khan*.
    The content on exception handling is useful and well focused for many common use
    cases. Once again, the link to purchase as an e-book or printed copy is here: [https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications.](https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我再次推荐由*Mark J. Price*和*Ovais Mehboob Ahmed Khan*合著的《*C# 7和.NET：设计现代跨平台应用*》。关于异常处理的内容对许多常见用例来说很有用，并且聚焦良好。再次提醒，购买电子书或印刷版的链接在这里：[https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications.](https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications)
