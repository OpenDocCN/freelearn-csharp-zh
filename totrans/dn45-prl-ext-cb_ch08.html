<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>8. Async</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;8.&#160;Async">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08"></a>Chapter&#160;8.&#160;Async</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will cover the following recipes:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Creating an <code class="literal">async</code> method</li>
            <li class="listitem" style="list-style-type: disc">Handling <code class="literal">Exceptions</code> in asynchronous code</li>
            <li class="listitem" style="list-style-type: disc">Cancelling an asynchronous operation</li>
            <li class="listitem" style="list-style-type: disc">Cancelling <code class="literal">async</code> operation after timeout period</li>
            <li class="listitem" style="list-style-type: disc">Processing multiple <code class="literal">async</code> tasks as they complete</li>
            <li class="listitem" style="list-style-type: disc">Improving performance of <code class="literal">async</code> solution with <code class="literal">Task.WhenAll</code></li>
            <li class="listitem" style="list-style-type: disc">Using <code class="literal">async</code> for file access</li>
            <li class="listitem" style="list-style-type: disc">Checking the progress of an asynchronous task</li>
          </ul>
        </div>
        <div class="section" title="Introduction">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title" id="sigil_toc_id_10"><a id="ch08lvl1sec79"></a>Introduction</h1>
              </div>
            </div>
          </div>
          <p>We've all seen client applications that do not respond to mouse events or update the display for noticeable periods of time. This delay is likely the result of code holding on to the single UI thread for far too long. Maybe it is waiting for network I/O or maybe it is performing an intensive computation. Meanwhile, the user is left sitting there waiting, as our application grinds to a halt. The answer to this problem is asynchrony.</p>
          <p>How is the concept of asynchrony different from parallelism? <a id="id559" class="indexterm"></a>Parallelism, with which you are quite familiar by this point in the book, is mainly about application performance. Parallelism enables developers to perform CPU intensive work on multiple threads at once, taking advantage of modern multi-core computer architectures. Asynchrony on the other hand, is a superset of concurrency. It includes concurrency as well as other asynchronous calls which are more I/O bound than CPU bound. Let's say you are saving a large file to your hard drive or you want to download some data from the server. These kinds of I/O bound tasks are ideal for asynchrony. Asynchrony is a pattern which yields control instantly, and waits for a callback or other notification to occur before continuing.</p>
          <p>So, just do things using an asynchronous pattern and your UI responsiveness problems are solved, right? Well, yes, but there is one small problem. Asynchronous code is difficult, at least historically speaking. However, asynchrony is taking a huge leap forward in terms of usability. Microsoft has delivered this by building on the <code class="literal">Task</code> functionality in .NET 4.5, as well as the addition of two new keywords to the .NET Framework: <code class="literal">async</code> and <code class="literal">await</code>.</p>
          <p>In this chapter, we will walk through several recipes that show how to maintain a responsive UI or scalable services by using the new <span class="strong"><strong>Task-based Asynchronous Pattern</strong></span>
<a id="id560" class="indexterm"></a> (<span class="strong"><strong>TAP</strong></span>) of the .NET Framework 4.5.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Creating an async method">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec80"></a>Creating an async method</h1>
            </div>
          </div>
        </div>
        <p>The TAP is a new pattern for <a id="id561" class="indexterm"></a>asynchronous programming in .NET Framework 4.5. It is based on a task, but in this case a task doesn't represent work which will be performed on another thread. In this case, a task is used to represent arbitrary asynchronous operations.</p>
        <p>Let's start learning how <code class="literal">async</code> and <code class="literal">await</code> work by creating a <span class="strong"><strong>Windows Presentation</strong></span>
<a id="id562" class="indexterm"></a>
<span class="strong"><strong> Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>) application that accesses the web using <code class="literal">HttpClient</code>. This kind of network access is ideal for seeing TAP in action. The application will get the contents of a classic book from the web, and will provide a count of the number of words in the book.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec143"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's go to Visual Studio<a id="id563" class="indexterm"></a> 2012 and see how to use the <code class="literal">async</code> and <code class="literal">await</code> keywords to maintain a responsive UI by doing the web communications asynchronously.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">WordCountAsync</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create a simple user interface containing <code class="literal">Button</code> and <code class="literal">TextBlock</code>:<div class="informalexample"><pre class="programlisting">&lt;Window x:Class="WordCountAsync.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WordCountAsync" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
    Content="Start" 
    HorizontalAlignment="Left" 
    Margin="219,195,0,0" 
    VerticalAlignment="Top" 
    Width="75" 
    RenderTransformOrigin="-0.2,0.45" 
    Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResults" 
      HorizontalAlignment="Left" 
      Margin="60,28,0,0" 
      TextWrapping="Wrap" 
      VerticalAlignment="Top" 
      Height="139" 
      Width="411"/&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;</pre>
</div><div class="mediaobject"><img src="graphics/0225OT_08_01.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to<a id="id564" class="indexterm"></a> the <span class="strong"><strong>Project</strong></span> and add a reference to <code class="literal">System.Net.Http</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre>
</div></li>
              <li class="listitem">At the top<a id="id565" class="indexterm"></a> of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre>
</div></li>
              <li class="listitem">Add a button click event for the <code class="literal">StartButton</code> and add the <code class="literal">async</code> modifier to the method signature to indicate that this will be a <code class="literal">async</code> method. Please note that <code class="literal">async</code> methods that return <code class="literal">void</code> are normally only used for event handlers, and should be avoided.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  
}</pre>
</div></li>
              <li class="listitem">Next, let's create a <code class="literal">async</code> method called <code class="literal">GetWordCountAsync</code> that returns <code class="literal">Task&lt;int&gt;</code>. This method will create <code class="literal">HttpClient</code> and call its <code class="literal">GetStringAsync</code> method to download the book contents as a string. It will then use the <code class="literal">Split</code> method to split the string into a <code class="literal">wordArray</code>. We can return the count of the <code class="literal">wordArray</code> as our <code class="literal">return</code> value.<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync()
{
  TextResults.Text += "Getting the word count for Origin of Species...\n";
  var client = new HttpClient();
  var bookContents = await client.GetStringAsync(@"http://www.gutenberg.org/files/2009/2009.txt");
  var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return wordArray.Count();           
}</pre>
</div></li>
              <li class="listitem">Finally, let's complete the implementation of our button click event. The <code class="literal">Click</code> event handler will just call <code class="literal">GetWordCountAsync</code> with the <code class="literal">await</code> keyword and display the results to <code class="literal">TextBlock</code>.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  var result = await GetWordCountAsync();
  TextResults.Text += String.Format("Origin of Species word count: {0}",result);
}</pre>
</div></li>
              <li class="listitem">In Visual Studio <a id="id566" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button, and your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_02.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec144"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In the TAP, asynchronous methods are marked with an <code class="literal">async</code> modifier. The <code class="literal">async</code> modifier on a method does<a id="id567" class="indexterm"></a> not mean that the method will be scheduled to run asynchronously on a worker thread. It means that the method contains control flow that involves waiting for the result of an asynchronous operation, and will be rewritten by the compiler to ensure that the asynchronous operation can resume this method at the right spot.</p>
          <p>Let me try to put this a little more simply. When you add the <code class="literal">async</code> modifier to a method, it indicates that the method will wait on an asynchronous code to complete. This is done with the <code class="literal">await</code> keyword. The compiler actually takes the code that follows the <code class="literal">await</code> keyword in an <code class="literal">async</code> method and turns it into a continuation that will run after the result of the <code class="literal">async</code> operation is available. In the meantime, the method is suspended, and control returns to the method's caller.</p>
          <p>If you add the <code class="literal">async</code> modifier to a method, and then don't <code class="literal">await</code> anything, it won't cause an error. The method will simply run synchronously.</p>
          <p>An <code class="literal">async</code> method can <a id="id568" class="indexterm"></a>have one of the three return types: <code class="literal">void</code>, <code class="literal">Task</code>, or <code class="literal">Task&lt;TResult&gt;</code>. As mentioned before, a task in this context doesn't mean that this is something that will execute on a separate thread. In this case, task is just a container for the asynchronous work, and in the case of <code class="literal">Task&lt;TResult&gt;</code>, it is a promise that a result value of type <code class="literal">TResult</code> will show up after the asynchronous operation completes.</p>
          <p>In our application, we use the <code class="literal">async</code> keyword to mark the button click event handler as asynchronous, and then we wait for the <code class="literal">GetWordCountAsync</code> method<a id="id569" class="indexterm"></a> to complete by using the <code class="literal">wait</code> keyword.</p>
          <div class="informalexample">
            <pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  StartButton.Enabled = false;
  var result = await GetWordCountAsync();
  TextResults.Text += String.Format("Origin of Species word count: {0}",
..................  result);
  StartButton.Enabled = true;
}</pre>
          </div>
          <p>The code that follows the a<code class="literal">wait</code> keyword, in this case, the same line of code that updates <code class="literal">TextBlock</code>, is turned by the compiler into a continuation that will run after the <code class="literal">integer</code> result is available.</p>
          <p>If the <code class="literal">Click</code> event is fired again while this asynchronous task is in progress, another asynchronous task is created and awaited. To prevent this, it is a common practice to disable the button that is clicked.</p>
          <p>It is a convention to name an asynchronous method with an <code class="literal">Async</code> postfix, as we have done with <code class="literal">GetWordCountAsync</code>.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Handling Exceptions in asynchronous code">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec81"></a>Handling Exceptions in asynchronous code</h1>
            </div>
          </div>
        </div>
        <p>So how would you add <code class="literal">Exception</code> handling to code that is executed asynchronously? In previous asynchronous<a id="id570" class="indexterm"></a> patterns, this was very difficult to achieve. In C# 5.0 it is much more straightforward because you just have to wrap the asynchronous function call with a standard <code class="literal">try</code>/<code class="literal">catch</code> block.</p>
        <p>On the surface <a id="id571" class="indexterm"></a>this sounds easy, and it is, but there is more going on behind the scene that will be explained right after we build our next example application.</p>
        <p>For this recipe, we will return to our classic books word count scenario, and we will be handling an <code class="literal">Exception</code> thrown by <code class="literal">HttpClient</code> when it tries to get the book contents using an incorrect URL.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec145"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's build another WPF<a id="id572" class="indexterm"></a> application and take a look at<a id="id573" class="indexterm"></a> how to handle <code class="literal">Exceptions</code> when something goes wrong in one of our asynchronous methods.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncExceptions</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create a simple user interface containing <code class="literal">Button</code> and a <code class="literal">TextBlock</code>:<div class="informalexample"><pre class="programlisting">&lt;Window x:Class="WordCountAsync.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WordCountAsync" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
    Content="Start" 
    HorizontalAlignment="Left" 
    Margin="219,195,0,0" 
    VerticalAlignment="Top" 
    Width="75" 
    RenderTransformOrigin="-0.2,0.45" 
    Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResults" 
      HorizontalAlignment="Left" 
      Margin="60,28,0,0" 
      TextWrapping="Wrap" 
      VerticalAlignment="Top" 
      Height="139" 
      Width="411"/&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;</pre>
</div></li>
              <li class="listitem">Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Framework</strong></span> from the menu on the left side of the <span class="strong"><strong>Reference Manager</strong></span>, and then add a reference to <code class="literal">System.Net.Http</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre>
</div></li>
              <li class="listitem">At the top<a id="id574" class="indexterm"></a> of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of <a id="id575" class="indexterm"></a>the book into a word array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre>
</div></li>
              <li class="listitem">Now let's create our <code class="literal">GetWordCountAsync</code> method. This method will be very similar to the last recipe, but it will be trying to access the book on an incorrect URL. The asynchronous code will be wrapped in a <code class="literal">try</code>/<code class="literal">catch</code> block to handle <code class="literal">Exception</code>. We will also use a <code class="literal">finally</code> block to dispose of <code class="literal">HttpClient</code>.<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync()
{
  ResultsTextBlock.Text += "Getting the word count for Origin of Species...\n";
  var client = new HttpClient();            
  try
  {
    var bookContents = await client.GetStringAsync(@"http://www.gutenberg.org/files/2009/No_Book_Here.txt");
    var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  catch (Exception ex)
  {
    ResultsTextBlock.Text += String.Format("An error has occurred: {0} \n", ex.Message);
    return 0;
  }
  finally
  {
    client.Dispose();
  }
  
}</pre>
</div></li>
              <li class="listitem">Finally, let create the <code class="literal">Click</code> event handler for our <code class="literal">StartButton</code>. This is pretty much the same as the last recipe, just wrapped in a <code class="literal">try</code>/<code class="literal">catch</code> block. Don't forget to add the <code class="literal">async</code> modifier to the method signature.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{            
  try
  {
    var result = await GetWordCountAsync();
    ResultsTextBlock.Text += String.Format("Origin of Species word count: {0}", 
        result);
  }
  catch(Exception ex)
  {
    ResultsTextBlock.Text += String.Format("An error has occurred: {0} \n", 
            ex.Message);
  } 
}</pre>
</div></li>
              <li class="listitem">Now, in Visual<a id="id576" class="indexterm"></a> Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button. Your application should appear as<a id="id577" class="indexterm"></a> shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_03.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec146"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>Wrapping your asynchronous code in a <code class="literal">try</code>/<code class="literal">catch</code> block is pretty easy. In fact, it hides some of the complex work Visual Studio 2012 to doing for us.</p>
          <p>To understand this, you need to think about the context in which your code is running.</p>
          <p>When the TAP is used in Windows Forms or WPF applications, there's already a context that the code is running in, such as the message loop UI thread. When <code class="literal">async</code> calls are made in those applications, the awaited code goes off to do its work asynchronously and the <code class="literal">async</code> method<a id="id578" class="indexterm"></a> exits back to its caller. In other words, the program execution returns to the message loop UI thread.</p>
          <p>The <code class="literal">Console</code> applications <a id="id579" class="indexterm"></a>don't have the concept of a context. When the code hits an awaited call inside the <code class="literal">try</code> block, it will exit back to its caller, which in this case is <code class="literal">Main</code>. If there is no more code after the awaited call, the application ends without the <code class="literal">async</code> method ever finishing.</p>
          <p>To alleviate this issue, Microsoft included <code class="literal">async</code> compatible context with the TAP that is used for <code class="literal">Console</code> apps or unit test apps to prevent this inconsistent behavior. This new context is called <code class="literal">GeneralThreadAffineContext</code>.</p>
          <p>Do you really need to understand these context issues to handle async <code class="literal">Exceptions</code>? No, not really. That's part of the beauty of the Task-based Asynchronous Pattern.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Cancelling an asynchronous operation">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec82"></a>Cancelling an asynchronous operation</h1>
            </div>
          </div>
        </div>
        <p>In .NET 4.5,<a id="id580" class="indexterm"></a> asynchronous operations can be cancelled in the same way that parallel tasks can be cancelled, by passing in <code class="literal">CancellationToken</code> and calling the <code class="literal">Cancel</code> method on <code class="literal">CancellationTokenSource</code>.</p>
        <p>In this recipe, we are going to create a WPF application that gets the contents of a classic book over the web and performs a word count. This time though we are going to set up a <span class="strong"><strong>Cancel</strong></span> button that we can use to cancel the <code class="literal">async</code> operation if we don't want to wait for it to finish.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec147"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's create a WPF application to show how we can add cancellation to our asynchronous methods.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncCancellation</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our<a id="id581" class="indexterm"></a> user interface. In this case, the UI contains <code class="literal">TextBlock</code>, <code class="literal">StartButton</code>, and <code class="literal">CancelButton</code>.<div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncCancellation.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="AsyncCancellation" Height="400" Width="599"&gt;
    &lt;Grid Width="600" Height="400"&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start" 
        HorizontalAlignment="Left" 
        Margin="142,183,0,0" 
        VerticalAlignment="Top" 
        Width="75" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;Button x:Name="CancelButton" 
        Content="Cancel" 
        HorizontalAlignment="Left" 
        Margin="379,185,0,0" 
        VerticalAlignment="Top" 
        Width="75" 
        Click="CancelButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
        HorizontalAlignment="Left" 
        Margin="27,24,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Height="135" 
        Width="540"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre>
</div></li>
              <li class="listitem">Next, open up <code class="literal">MainWindow.xaml.cs</code>, click on the <span class="strong"><strong>Project Explorer</strong></span>, and add a reference to <code class="literal">System.Net.Http</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre>
</div></li>
              <li class="listitem">At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre>
</div></li>
              <li class="listitem">Next, let's create the <code class="literal">GetWordCountAsync</code> method<a id="id582" class="indexterm"></a>. This method is very similar to the method explained before. It needs to be marked as asynchronous with the <code class="literal">async</code> modifier and it returns <code class="literal">Task&lt;int&gt;</code>. This time however, the <a id="id583" class="indexterm"></a>method takes a <code class="literal">CancellationToken</code> parameter. We also need to use the <code class="literal">GetAsync</code> method of <code class="literal">HttpClient</code> instead of the <code class="literal">GetStringAsync</code> method, because the former supports cancellation, whereas the latter does not. We will add a small delay in the method so we have time to cancel the operation before the download completes.<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  TextResult.Text += "Getting the word count for Origin of Species...\n";            
  var client = new HttpClient();
  await Task.Delay(500);
  try
  {
    HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
    var words = await response.Content.ReadAsStringAsync();
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  finally
  {
    client.Dispose();
  }
}</pre>
</div></li>
              <li class="listitem">Now, let's create the <code class="literal">Click</code> event handler for our <code class="literal">CancelButton</code>. This method just needs to check if <code class="literal">CancellationTokenSource</code> is <code class="literal">null</code>, and if not, it calls the <code class="literal">Cancel</code> method.<div class="informalexample"><pre class="programlisting">private void CancelButton_Click(object sender, RoutedEventArgs e)
{
  if (cts != null)
  {
    cts.Cancel();
  }
}</pre>
</div></li>
              <li class="listitem">Ok, let's finish up by adding a <code class="literal">Click</code> event handler for <code class="literal">StartButton</code>. This method is the same as explained before, except we also have a <code class="literal">catch</code> block that specifically handles <code class="literal">OperationCancelledException</code>. Don't forget to mark the method<a id="id584" class="indexterm"></a> with the <code class="literal">async</code> modifier.<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  TextResult.Text += "Getting the word count for Origin of Species...\n";            
  var client = new HttpClient();
  await Task.Delay(500);
  try
  {
    HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
    var words = await response.Content.ReadAsStringAsync();
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  finally
  {
    client.Dispose();
  }
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project Click on the <span class="strong"><strong>Start</strong></span> button, then the <span class="strong"><strong>Cancel</strong></span> button. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_04.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec148"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>Cancellation is an aspect of user interaction that you need to consider to build a professional <code class="literal">async</code>
<a id="id585" class="indexterm"></a> application. In this example, we implemented cancellation by using a <span class="strong"><strong>Cancel</strong></span> button, which is one of the most common ways to surface cancellation functionality in a GUI application.</p>
          <p>In this recipe, cancellation follows a very common flow.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">The caller (start button click event handler) creates a <code class="literal">CancellationTokenSource</code> object.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  cts = new CancellationTokenSource();            
  ...
}</pre>
</div></li>
              <li class="listitem">The caller calls a cancelable method, and passes <code class="literal">CancellationToken</code> from <code class="literal">CancellationTokenSource</code> (<code class="literal">CancellationTokenSource.Token</code>).<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(<span class="strong"><strong>CancellationToken ct</strong></span>)
{
  ...
  HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", <span class="strong"><strong>ct</strong></span>);
  ...
}</pre>
</div></li>
              <li class="listitem">The cancel button click event handler requests cancellation using the <code class="literal">CancellationTokenSource</code> object (<code class="literal">CancellationTokenSource.Cancel()</code>).<div class="informalexample"><pre class="programlisting">private void CancelButton_Click(object sender, RoutedEventArgs e)
{
  if (cts != null)
  {
    cts.Cancel();
  }
}</pre>
</div></li>
              <li class="listitem">The task <a id="id586" class="indexterm"></a>acknowledges the cancellation by throwing <code class="literal">OperationCancelledException</code>, which we handle in a <code class="literal">catch</code> block in the start button click event handler.</li>
            </ol>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Cancelling async operation after timeout period">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec83"></a>Cancelling async operation after timeout period</h1>
            </div>
          </div>
        </div>
        <p>Another common scenario for cancelling asynchronous tasks is to set a timeout period by using the <code class="literal">CancellationTokenSource.CancelAfter</code> method. This method schedules the cancellation of any<a id="id587" class="indexterm"></a> associated tasks that aren't complete within the period of time that's designated by the <code class="literal">CancelAfter</code> expression.</p>
        <p>In this recipe, we are going to create a WPF application that gets the contents of a classic book over the web and performs a word count. This time though, we are going to set a timeout period after which the task gets cancelled.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec149"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how we can create an asynchronous task that cancels after a specified timeout period.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">CancelAfterTimeout</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by opening <code class="literal">MainWindow.xaml</code> and add the following XAML to create our user interface:<div class="informalexample"><pre class="programlisting">&lt;Window x:Class="CancelAfterTimeout.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,264,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
        HorizontalAlignment="Left" 
        Margin="48,10,0,0" TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Height="213" 
        Width="420"/&gt;
        &lt;Label Content="Timeout (in ms):" 
         HorizontalAlignment="Left" 
         Margin="163,227,0,0" 
         VerticalAlignment="Top"/&gt;
        &lt;TextBox x:Name="TextTimeout" 
        HorizontalAlignment="Left" 
        Height="23" 
        Margin="277,231,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Width="50"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre>
</div><div class="mediaobject"><img src="graphics/0225OT_08_05.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span> and add a reference to <code class="literal">System.Net.Http</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code><a id="id588" class="indexterm"></a> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre>
</div></li>
              <li class="listitem">At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre>
</div></li>
              <li class="listitem">Next, let's create the <code class="literal">GetWordCountAsync</code> method. This method is exactly the same as the last recipe. It needs to be marked as asynchronous with the <code class="literal">async</code> modifier and it returns <code class="literal">Task&lt;int&gt;</code>. The method takes a <code class="literal">CancellationToken</code> parameter. We will add a small delay in the method so we have time to cancel<a id="id589" class="indexterm"></a> the operation before the download completes.<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  TextResult.Text += "Getting the word count for Origin of Species...\n";            
  var client = new HttpClient();
  await Task.Delay(500);
  try
  {
    HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
    var words = await response.Content.ReadAsStringAsync();
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  finally
  {
    client.Dispose();
  }
}</pre>
</div></li>
              <li class="listitem">Ok, let's finish up by adding a <code class="literal">Click</code> event handler for <code class="literal">StartButton</code>. This method is similar to the last recipe, except we call the <code class="literal">CancellationTokenSource.CancelAfter</code> method<a id="id590" class="indexterm"></a>, passing it the value of our <code class="literal">timeout</code> textbox. Don't forget to mark the method with the <code class="literal">async</code> modifier.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  StartButton.IsEnabled = false;
  try
  {
    tokenSource = new CancellationTokenSource();
    var timeoutPeriod = int.Parse(TextTimeout.Text);
    tokenSource.CancelAfter(timeoutPeriod);                
    await GetWordCount(tokenSource.Token);                                
  }
  catch (OperationCanceledException)
  {
    TextResult.Text += "The operation was cancelled. \n";
  }
  catch (Exception)
  {
    TextResult.Text += "The operation failed to complete due to an exception. \n";
  }
  finally
  {
    StartButton.IsEnabled = true;
  }
}</pre>
</div></li>
              <li class="listitem">In Visual Studio<a id="id591" class="indexterm"></a> 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Set the <code class="literal">timeout</code> value to <code class="literal">100</code>. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_06.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec150"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The application is very similar to the application we created in the last recipe, except this time the <code class="literal">Cancel</code> button isn't used. The actual cancellation follows a similar flow however.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">The caller (start button click event handler) creates a <code class="literal">CancellationTokenSource</code> object, and then calls the <code class="literal">CancelAfter</code> method to pass in the <code class="literal">timeout</code> value.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  StartButton.IsEnabled = false;
  try
  {
    tokenSource = new CancellationTokenSource();
    var timeoutPeriod = int.Parse(TextTimeout.Text);
    tokenSource.CancelAfter(timeoutPeriod);                
    ...                                
  }
  ...
}</pre>
</div></li>
              <li class="listitem">The caller calls<a id="id592" class="indexterm"></a> a cancelable method, and passes <code class="literal">CancellationToken</code> from <code class="literal">CancellationTokenSource</code> (<code class="literal">CancellationTokenSource.Token</code>).<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  ...
  HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
  ...
}</pre>
</div></li>
              <li class="listitem">After the timeout period expires, <code class="literal">CancellationTokenSource</code> triggers a cancellation same as if we had made a call to <code class="literal">CancellationTokenSource.Cancel</code>.<div class="informalexample"><pre class="programlisting">private void CancelButton_Click(object sender, RoutedEventArgs e)
{
  if (cts != null)
  {
    cts.Cancel();
  }
}</pre>
</div></li>
            </ol>
          </div>
          <p>The task acknowledges the cancellation by throwing <code class="literal">OperationCancelledException</code>, which we handle in a <code class="literal">catch</code> block in the start button click event handler.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Processing multiple async tasks as they complete">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec84"></a>Processing multiple async tasks as they complete</h1>
            </div>
          </div>
        </div>
        <p>Many of the methods of the <code class="literal">Task</code> class that we learned about in <a class="link" href="ch01.html" title="Chapter&#160;1.&#160;Getting Started with Task Parallel Library">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Task Parallel Library</em></span>, are as useful when writing an asynchronous code as they are when writing a<a id="id593" class="indexterm"></a> parallel code. In this recipe, we are going to download the contents of multiple books and use <code class="literal">Task.WhenAny</code> to process them as they finish.</p>
        <p>This application will use a <code class="literal">while</code> loop to create a collection of tasks. Each task downloads the contents of a specified book. In each iteration of a loop, an awaited call to <code class="literal">WhenAny</code> returns the task in the collection of tasks that finishes first. That task is removed from the collection and processed. The loop repeats until the collection contains no more tasks.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec151"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's create a WPF application that creates multiple asynchronous tasks and processes them as they complete.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncMultipleRequest</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our user interface:<div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncMultipleRequest.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,264,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
           HorizontalAlignment="Left" 
           Margin="48,10,0,0" 
           TextWrapping="Wrap" 
           VerticalAlignment="Top" 
           Height="213" Width="420"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre>
</div></li>
              <li class="listitem">Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span>, and add a reference to <code class="literal">System.Net.Http</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Documents;
using System.Net.Http;</pre>
</div></li>
              <li class="listitem">At the top of <a id="id594" class="indexterm"></a>the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre>
</div></li>
              <li class="listitem">Let's start by creating a helper function that builds a list of <code class="literal">KeyValuePair&lt;string,string&gt;</code> which represents our book titles and URLs.<div class="informalexample"><pre class="programlisting">private List&lt;KeyValuePair&lt;string, string&gt;&gt; GetBookUrls()
{
  var urlList = new List&lt;KeyValuePair&lt;string, string&gt;&gt;
  {
    new KeyValuePair&lt;string,string&gt;("Origin of Species",
          "http://www.gutenberg.org/files/2009/2009.txt"),
    new KeyValuePair&lt;string,string&gt;("Beowulf",
          "http://www.gutenberg.org/files/16328/16328-8.txt"),
    new KeyValuePair&lt;string,string&gt;("Ulysses",
          "http://www.gutenberg.org/files/4300/4300.txt")
  };
  return urlList;
}</pre>
</div></li>
              <li class="listitem">Now let's create an <code class="literal">async</code> method that does the book download and returns <code class="literal">KeyValuePair&lt;string, int&gt;</code> that represents our book titles and word count. This method will need to accept a <code class="literal">KeyValuePair&lt;string, string&gt;</code> parameter representing the book title and URL. The method also needs an <code class="literal">HttpClient</code> parameter.<div class="informalexample"><pre class="programlisting">async Task&lt;KeyValuePair&lt;string,int&gt;&gt; ProcessBook(KeyValuePair&lt;string,string&gt; book, HttpClient client)
{
  var bookContents = await client.GetStringAsync(book.Value);
  var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return new KeyValuePair&lt;string,int&gt;(book.Key,wordArray.Count());
}</pre>
</div></li>
              <li class="listitem">Now we need to create another <code class="literal">async</code> method called <code class="literal">GetMultipleWordCount</code>. This method executes a query on our list of books. Each query calls the <code class="literal">ProcessBook</code> method to actually do the download and obtain the word count. After the query, we set up a <code class="literal">while</code> loop that loops while our list of book processing tasks is greater than zero. Each iteration of the loop awaits a call to <code class="literal">Task.WhenAny</code>. When a task is completed, the <a id="id595" class="indexterm"></a>results are written out and <code class="literal">Task</code> is removed from the <code class="literal">Task</code> list. This method takes no parameters and returns <code class="literal">Task</code>.<div class="informalexample"><pre class="programlisting">public async Task GetMultipleWordCount()
{
  var client = new HttpClient();
  var results = new List&lt;KeyValuePair&lt;string, int&gt;&gt;();
  var urlList = GetBookUrls();
  IEnumerable&lt;Task&lt;KeyValuePair&lt;string,int&gt;&gt;&gt; bookQuery =
    from book in urlList select ProcessBook(book, client);
  List&lt;Task&lt;KeyValuePair&lt;string,int&gt;&gt;&gt; bookTasks = bookQuery.ToList();
  while (bookTasks.Count &gt; 0)
  {
    Task&lt;KeyValuePair&lt;string, int&gt;&gt; firstFinished = await Task.WhenAny(bookTasks);
    bookTasks.Remove(firstFinished);
    var thisBook = await firstFinished;
    TextResult.Text += String.Format("Finished downloading {0}. Word count: {1}\n", 
      thisBook.Key, 
      thisBook.Value);
  }
}</pre>
</div></li>
              <li class="listitem">Finally, let's create our start button click event handler. The handler only needs to call the <code class="literal">GetMultipleWordCount</code> method<a id="id596" class="indexterm"></a>.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  TextResult.Text += "Started downloading books...\n";
  await GetMultipleWordCount();
  TextResult.Text += "Finished downloading books...\n";
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_07.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec152"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>We have already seen in the previous recipes that the <code class="literal">WhenAny</code> method of the <code class="literal">Task</code> class can be used on a list <a id="id597" class="indexterm"></a>of parallel tasks to continue processing when any of the tasks in the array is complete.</p>
          <p>Even though a task in the <code class="literal">async</code> context doesn't mean that our list of <code class="literal">async</code> tasks are running in parallel on separate worker threads, we can still use the <code class="literal">WhenAny</code> method<a id="id598" class="indexterm"></a> to handle <code class="literal">async</code> requests as they complete.</p>
          <p>In this recipe, we downloaded the text of multiple books and displayed the word count of each of the books as the download finished. The start button's click event handler doesn't do much other than add some text to <code class="literal">TextBlock</code> and <code class="literal">await</code> a call to the <code class="literal">GetMultipleWordCount</code> method. After creating <code class="literal">HttpClient</code>, the <code class="literal">GetMultipleWordCount</code> method makes a call to the <code class="literal">GetBookUrls</code> helper method that we created, which just returns a list of three books and their URLs.</p>
          <p>After getting the list of <a id="id599" class="indexterm"></a>books and their URLs, the <code class="literal">GetMultipleWordCount</code> method creates <code class="literal">IEnumerable&lt;Task&lt;TResult&gt;&gt;</code> by executing a LINQ query that calls the <code class="literal">ProcessBook</code> method on each <code class="literal">book</code> in the list.</p>
          <div class="informalexample">
            <pre class="programlisting">var bookQuery = from book in urlList select ProcessBook(book, client);
var bookTasks = bookQuery.ToList();</pre>
          </div>
          <p>Next, we set up a <code class="literal">while</code> loop on the condition that <code class="literal">bookTasks.Count</code> is greater than zero. In the body of the <code class="literal">while</code> loop, we <code class="literal">await</code> a call to the <code class="literal">Task.WhenAny</code> method, which will return when the first list of tasks is complete. We then remove this <code class="literal">Task</code> from <code class="literal">bookTasks</code> so the count is decremented. Below that, we await the <code class="literal">firstFinished</code> task variable. This has the effect of the compiler creating a continuation for us at this point that will run, as soon as the <code class="literal">task</code> variable <code class="literal">firstFinished</code> is completed, the compiler-created continuation will contain the code to update the <code class="literal">TextBlock</code> with the word count for the book.</p>
          <div class="informalexample">
            <pre class="programlisting">var firstFinished = await Task.WhenAny(bookTasks);
bookTasks.Remove(firstFinished);
var thisBook = await firstFinished;

// The compiler will create a continuation at this point that will run
//  when the task referenced by the firstFinished variable completes.
TextResult.Text += String.Format("Finished downloading {0}. Word count: {1}\n", 
  thisBook.Key, 
  thisBook.Value);</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Improving performance of async solution with Task.WhenAll">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec85"></a>Improving performance of async solution with Task.WhenAll </h1>
            </div>
          </div>
        </div>
        <p>We have already seen how we can use the <code class="literal">Task.WhenAny</code> method to handle asynchronous <a id="id600" class="indexterm"></a>tasks as they complete. You will also find the <code class="literal">Task.WhenAll</code> method very useful in the asynchronous context.<a id="id601" class="indexterm"></a> In some applications that create multiple asynchronous requests, it can improve application performance by using <code class="literal">Task.WhenAll</code> to hold off on processing results until all the asynchronous tasks have completed.</p>
        <p>In this recipe, we are going to create a WPF application that downloads the contents of multiple books asynchronously, but holds off on processing the results until all the tasks have completed.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec153"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncMultipleRequest</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by <a id="id602" class="indexterm"></a>opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our user interface:<a id="id603" class="indexterm"></a><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncMultipleRequest.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,264,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
           HorizontalAlignment="Left" 
           Margin="48,10,0,0" 
           TextWrapping="Wrap" 
           VerticalAlignment="Top" 
           Height="213" Width="420"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre>
</div></li>
              <li class="listitem">Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span>, and add a reference to <code class="literal">System.Net.Http</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Documents;
using System.Net.Http;</pre>
</div></li>
              <li class="listitem">At the top <a id="id604" class="indexterm"></a>of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split<a id="id605" class="indexterm"></a> the contents of the book into a word array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre>
</div></li>
              <li class="listitem">Let's start by creating a helper function that builds a list of <code class="literal">KeyValuePair&lt;string,string&gt;</code>, which represents our book titles and URLs.<div class="informalexample"><pre class="programlisting">private List&lt;KeyValuePair&lt;string, string&gt;&gt; GetBookUrls()
{
  var urlList = new List&lt;KeyValuePair&lt;string, string&gt;&gt;
  {
    new KeyValuePair&lt;string,string&gt;("Origin of Species",
          "http://www.gutenberg.org/files/2009/2009.txt"),
    new KeyValuePair&lt;string,string&gt;("Beowulf",
          "http://www.gutenberg.org/files/16328/16328-8.txt"),
    new KeyValuePair&lt;string,string&gt;("Ulysses",
          "http://www.gutenberg.org/files/4300/4300.txt")
  };
  return urlList;
}</pre>
</div></li>
              <li class="listitem">Now let's create a <code class="literal">async</code> method that performs the book download and returns <code class="literal">KeyValuePair&lt;string, int&gt;</code> that represents our book titles and word count. This method will need to accept a <code class="literal">KeyValuePair&lt;string, string&gt;</code> parameter representing the book title and URL. The method also needs a <code class="literal">HttpClient</code> parameter.<div class="informalexample"><pre class="programlisting">async Task&lt;KeyValuePair&lt;string,int&gt;&gt; ProcessBook(KeyValuePair&lt;string,string&gt; book, HttpClient client)
{
  var bookContents = await client.GetStringAsync(book.Value);
  var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return new KeyValuePair&lt;string,int&gt;(book.Key,wordArray.Count());
}</pre>
</div></li>
              <li class="listitem">Next, we need to create the <code class="literal">GetWordCount</code> method. This method will execute a LINQ query to call the <code class="literal">ProcessBook</code> method on each <code class="literal">book</code> in the list of books.<a id="id606" class="indexterm"></a> It then calls <code class="literal">Task.WhenAll</code> to <code class="literal">await</code> the tasks completed of all of the tasks. When<a id="id607" class="indexterm"></a> all tasks have finished, it needs to write the results to the <code class="literal">TextBlock</code> in a <code class="literal">for</code> loop.<div class="informalexample"><pre class="programlisting">public async Task GetWordCount()
{            
  var urlList = GetBookUrls();
  var wordCountQuery = from book in urlList select ProcessBook(book);
  Task&lt;KeyValuePair&lt;string,int&gt;&gt;[] wordCountTasks = wordCountQuery.ToArray();
  KeyValuePair&lt;string, int&gt;[] wordCounts = await Task.WhenAll(wordCountTasks);
  foreach (var book in wordCounts)
  {
    TextResult.Text += String.Format("Finished processing {0} : Word count {1} \n", 
      book.Key, book.Value);
  }
}</pre>
</div></li>
              <li class="listitem">Lastly, the start button click event handler just needs to call the <code class="literal">GetWordCount</code> method and <code class="literal">await</code> the task.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  
  TextResult.Text = "Started downloading books...\n";
  Task countTask = GetWordCount();
  await countTask;            
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should have results as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_08.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec154"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, the <code class="literal">GetWordCount</code> method<a id="id608" class="indexterm"></a> calls the <code class="literal">ProcessBook</code> method for each book in the list by executing<a id="id609" class="indexterm"></a> a LINQ <a id="id610" class="indexterm"></a>query. This returns an <code class="literal">IEnumerable&lt;Task&lt;TResult&gt;&gt;</code>, when we turn in to an array of tasks by calling the <code class="literal">ToArray</code> method.</p>
          <div class="informalexample">
            <pre class="programlisting">var urlList = GetBookUrls();
var wordCountQuery = from book in urlList select ProcessBook(book);
var wordCountTasks = wordCountQuery.ToArray();</pre>
          </div>
          <p>Next, we just <code class="literal">await</code> a call to the <code class="literal">Task.WhenAll</code> method which will return when all of the asynchronous tasks complete. Finally, we just use a <code class="literal">for</code> loop to update the <code class="literal">TextBlock</code>.</p>
          <div class="informalexample">
            <pre class="programlisting">var wordCounts = await Task.WhenAll(wordCountTasks);
foreach (var book in wordCounts)
{
  TextResult.Text += String.Format("Finished processing {0} : Word count {1} \n", book.Key, book.Value);
}</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using async for file access">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec86"></a>Using async for file access</h1>
            </div>
          </div>
        </div>
        <p>Until now, we have created applications that use <code class="literal">async</code> for web access, using <code class="literal">HttpClient</code>. Another<a id="id611" class="indexterm"></a> common use for <code class="literal">async</code> is performing asynchronous file I/O without blocking the main thread.</p>
        <p>In this recipe, we are going to create a WPF application that can write to and read from a file asynchronously. The application will have two text boxes, one containing the text to write to a file, and the other containing text to read from a file.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec155"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncFileAccess</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our user interface:<div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncFileAccess.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Label Content="Text to Write" 
        HorizontalAlignment="Left" 
        Margin="49,24,0,0" 
        VerticalAlignment="Top" 
        Width="87"/&gt;
        &lt;Button x:Name="WriteButton" 
        Content="Write to File" 
        HorizontalAlignment="Left" 
        Margin="212,139,0,0" 
        VerticalAlignment="Top" 
        Width="75" 
        Click="WriteButton_Click"/&gt;
        &lt;TextBox x:Name="TextWrite" 
        HorizontalAlignment="Left" 
        Height="66" Margin="54,55,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" Width="420"/&gt;
        &lt;TextBox x:Name="TextRead" 
        HorizontalAlignment="Left" 
        Height="66" 
        Margin="54,200,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Width="420"/&gt;
        &lt;Label Content="Text from File" 
        HorizontalAlignment="Left" 
        Margin="51,167,0,0" 
        VerticalAlignment="Top" 
        Width="87"/&gt;
        &lt;Button x:Name="ReadButton" 
        Content="Read from File" 
        HorizontalAlignment="Left" 
        Margin="205,277,0,0" 
        VerticalAlignment="Top" 
        Width="94" 
        Click="ReadButton_Click"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;.</pre>
</div><div class="mediaobject"><img src="graphics/0225OT_08_09.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Add the<a id="id612" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Windows;</pre>
</div></li>
              <li class="listitem">At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">path</code> constant for the path of the text file you will be writing. This can be any path you like.<div class="informalexample"><pre class="programlisting">string path = @"C:\temp\temp.txt";</pre>
</div></li>
              <li class="listitem">Next, let's create a <code class="literal">async</code> method called <code class="literal">WriteToFileAsync</code> that returns <code class="literal">Task</code>. This method gets a <code class="literal">Unicode</code> encoded <code class="literal">byte</code> array of the text in our <code class="literal">TextBox</code>, creates a file stream, and writes the text to the file.<div class="informalexample"><pre class="programlisting">private async Task WriteToFileAsync(string path, string content)
{
  byte[] encodedContent = Encoding.Unicode.GetBytes(content);
  using(FileStream stream = new FileStream(path,FileMode.Append,
       FileAccess.Write,
       FileShare.None,
       bufferSize: 4096,
       useAsync:true))
       {
         await stream.WriteAsync(encodedContent,
                    0,
                    encodedContent.Length);
       };
}</pre>
</div></li>
              <li class="listitem">Now create an asynchronous <code class="literal">Click</code> event handler for the <code class="literal">Write</code> button. Here, we just need to <code class="literal">await</code> a call to <code class="literal">WriteFileAsync</code>, passing it the input string.<div class="informalexample"><pre class="programlisting">private async void WriteButton_Click(object sender, RoutedEventArgs e)
{
  WriteButton.IsEnabled = false;
  string content = TextWrite.Text;
  await WriteToFileAsync(path, content);
  WriteButton.IsEnabled = true;
}</pre>
</div></li>
              <li class="listitem">Now,<a id="id613" class="indexterm"></a> let's create an asynchronous method called <code class="literal">ReadFromFileAsync</code> that returns <code class="literal">Task&lt;string&gt;</code>. This method creates <code class="literal">FileStream</code> and reads the contents of the file into <code class="literal">string</code>.<div class="informalexample"><pre class="programlisting">private async Task&lt;string&gt; ReadFromFileAsync(string path)
{
  using (FileStream stream = new FileStream(path, 
                  FileMode.Open,
                  FileAccess.Read, 
                  FileShare.Read, 
                  bufferSize: 4096, 
                  useAsync: true))
  {
    var sb = new StringBuilder();
    byte[] buffer = new byte[0x1000];
    int bytesRead;
    while((bytesRead = await stream.ReadAsync(buffer, 
                      	  0, 
                      	  buffer.Length))!=0)
    {
      string content = Encoding.Unicode.GetString(buffer,
                            0,
                            bytesRead);
      sb.Append(content);
    }
    return sb.ToString();
  }
}</pre>
</div></li>
              <li class="listitem">Finally, let's create the read button click handler. This <code class="literal">async</code> method just needs to<a id="id614" class="indexterm"></a> check for the existence of the file, and <code class="literal">await</code> a call to <code class="literal">ReadFromFileAsync</code>. Set the results of the method call to the proper <code class="literal">TextBox</code>.<div class="informalexample"><pre class="programlisting">private async void ReadButton_Click(object sender, RoutedEventArgs e)
{
  if (File.Exists(path) == false)
  {
    TextRead.Text = "There was an error reading the file.";
  }
  else
  {
    try
    {
      string content = await ReadFromFileAsync(path);
      TextRead.Text = content;
    }
    catch(Exception ex)
    {
      TextRead.Text = ex.Message;
    }                
  }
}</pre>
</div></li>
              <li class="listitem">In Visual <a id="id615" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_010.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec156"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The <code class="literal">Click</code> event handler is pretty straightforward. It is marked with the <code class="literal">async</code> keyword because it awaits a call to <code class="literal">WriteToFileAsync</code>. You must have noticed that we disabled the <code class="literal">Write</code> button at the start of the method and enabled it again at the end. This is a good practice to control reentrancy with <code class="literal">async</code> methods. The UI is free to respond to clicks and will fire the <code class="literal">Click</code> event handler again, if it receives a click.</p>
          <div class="informalexample">
            <pre class="programlisting">private async void WriteButton_Click(object sender, RoutedEventArgs e)
{
  WriteButton.IsEnabled = false;
  string content = TextWrite.Text;
  await WriteToFileAsync(path, content);
  WriteButton.IsEnabled = true;
}</pre>
          </div>
          <p>The <code class="literal">WriteToFileAsync</code> method<a id="id616" class="indexterm"></a> gets a <code class="literal">Unicode</code> encoded <code class="literal">byte</code> array of the input string then creates <code class="literal">FileStream</code> with <code class="literal">Write</code> access in the <code class="literal">Append</code> mode. Once <code class="literal">stream</code> is open, we <code class="literal">await</code> a call to the <code class="literal">WriteAsync</code> method of <code class="literal">FileStream</code>, passing it our <code class="literal">byte</code> array.</p>
          <div class="informalexample">
            <pre class="programlisting">byte[] encodedContent = Encoding.Unicode.GetBytes(content);
using(FileStream stream = new FileStream(path,FileMode.Append,
     FileAccess.Write,FileShare.None,bufferSize: 4096,useAsync:true))
     {
       await stream.WriteAsync(encodedContent,0,encodedContent.Length);
     };</pre>
          </div>
          <p>The <code class="literal">ReadFromFileAsync</code> method<a id="id617" class="indexterm"></a> just creates <code class="literal">FileStream</code> in open mode with read access. Once the <code class="literal">stream</code> is <a id="id618" class="indexterm"></a>open, we <code class="literal">await</code> a call to the <code class="literal">ReadAsync</code> method of <code class="literal">FileStream</code> in a <code class="literal">while</code> loop, and read its contents.</p>
          <div class="informalexample">
            <pre class="programlisting">var sb = new StringBuilder();
byte[] buffer = new byte[0x1000];
int bytesRead;
while((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length))!=0)
{
  string content = Encoding.Unicode.GetString(buffer,0,bytesRead);
  sb.Append(content);
}
return sb.ToString();</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Checking the progress of an asynchronous task">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch08lvl1sec87"></a>Checking the progress of an asynchronous task</h1>
            </div>
          </div>
        </div>
        <p>If an asynchronous functionality in your application involves a noticeable delay while the user waits for the result, you might want to inform users that there will be a wait and provide a sense of <a id="id619" class="indexterm"></a>how long the wait might be. The progress and cancellation features of the <code class="literal">async</code> programming model enable you to deliver on these needs.</p>
        <p>In this recipe, we are going to create a WPF application that uses the progress events of <code class="literal">WebClient</code> to display the status of a <code class="literal">Download</code> task with a <code class="literal">ProgressBar</code>.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec157"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's create a WPF application and see how we can add progress reporting to our asynchronous operations.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncProgress</code> as <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Begin by opening <code class="literal">MainWindow.xaml</code> and add the following XAML to create our user interface:<div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncProgress.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="AsyncProgress" Height="400" Width="525" ResizeMode="NoResize"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,288,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
        HorizontalAlignment="Left" 
        Margin="48,10,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Height="213" 
        Width="420"/&gt;
        &lt;ProgressBar x:Name="DownloadProgress" 
        HorizontalAlignment="Left" 
        Height="20" 
        Margin="48,249,0,0" 
        VerticalAlignment="Top" 
        Width="420"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre>
</div><div class="mediaobject"><img src="graphics/0225OT_08_011.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Add the<a id="id620" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.ComponentModel;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using System.Windows;</pre>
</div></li>
              <li class="listitem">At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array. Also add a <code class="literal">string</code> constant for the user agent header for a <code class="literal">WebClient</code>.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";</pre>
</div></li>
              <li class="listitem">Now let's add a method called <code class="literal">client_DownloadFileCompleted</code> that will be the event handler for the <code class="literal">DownloadFileCompleted</code> event of a <code class="literal">WebClient</code>. This method just needs to add some text to <code class="literal">TextBlock</code> to indicate that the download has finished.<div class="informalexample"><pre class="programlisting">void client_DownloadFileCompleted(object sender, AsyncCompletedEventArgs e)
{
  TextResult.Text += " Download completed. \n";
}</pre>
</div></li>
              <li class="listitem">Next,<a id="id621" class="indexterm"></a> create a method called <code class="literal">client_DownloadProgressChanged</code><a id="id622" class="indexterm"></a>. This method will be the event handler for the WebClient's <code class="literal">DownloadProgressChanged</code> event, and needs to calculate the bytes received, the total bytes, the percentage complete, and update the progress bar.<div class="informalexample"><pre class="programlisting">void client_DownloadProgressChanged(object sender, DownloadProgressChangedEventArgs e)
{
  double bytesIn = double.Parse(e.BytesReceived.ToString());
  double totalBytes = double.Parse(e.TotalBytesToReceive.ToString());
  double percentage = bytesIn / totalBytes * 100;
  DownloadProgress.Value = int.Parse(Math.Truncate(percentage).ToString());
}</pre>
</div></li>
              <li class="listitem">Now we need to create our asynchronous <code class="literal">GetWordCountAsync</code> method<a id="id623" class="indexterm"></a>. This method returns <code class="literal">Task&lt;int&gt;</code>, and after creating <code class="literal">WebClient</code>, and wiring up the <code class="literal">DownloadFileCompletedEvent</code> and <code class="literal">DownloadProgressChanged</code> events, it awaits a call to the <code class="literal">DownloadStringTaskAsync</code> method of <code class="literal">WebClient</code> to download the contents of the book and split the words into an array of strings.<div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCount()
{
  TextResult.Text += " Getting the word count for Origin of Species...\n";
  var client = new WebClient();
  client.Headers.Add("user-agent", headerText);
  client.DownloadProgressChanged += new 
      DownloadProgressChangedEventHandler(client_DownloadProgressChanged);
  client.DownloadFileCompleted += 
      new AsyncCompletedEventHandler(client_DownloadFileCompleted);
  Task&lt;string&gt; wordsTask = 
    client.DownloadStringTaskAsync(new Uri("http://www.gutenberg.org/files/2009/2009.txt"));
  var words = await wordsTask;
  var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return wordArray.Count();
}</pre>
</div></li>
              <li class="listitem">Finally,<a id="id624" class="indexterm"></a> let's create an asynchronous <code class="literal">Click</code> event handler for <code class="literal">StartButton</code>. This button just writes some text to <code class="literal">TextBlock</code> and awaits a call to <code class="literal">GetWordCountAsync</code>.<div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  TextResult.Text += "Started downloading Origin of Species...\n";
  Task&lt;int&gt; countTask = GetWordCountAsync();
  int result = await countTask;
  TextResult.Text += String.Format("Finished downloading. Word count: {0}\n", result);
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should display the results as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_08_012.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch08lvl2sec158"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>This application was able to show the progress of its download by wiring up two events of the <code class="literal">WebClient</code> class: <code class="literal">DownloadProgressChanged</code> and <code class="literal">DownloadFileCompleted</code>. It then calls the<a id="id625" class="indexterm"></a> <code class="literal">DownloadStringTaskAsync</code> method<a id="id626" class="indexterm"></a> of <code class="literal">WebClient</code>, which triggers the events as the download progresses.</p>
          <div class="informalexample">
            <pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync()
{
  ...
  client.DownloadProgressChanged += 
      new DownloadProgressChangedEventHandler(client_DownloadProgressChanged);
  client.DownloadFileCompleted += 
      new AsyncCompletedEventHandler(client_DownloadFileCompleted);
  Task&lt;string&gt; wordsTask = 
      client.DownloadStringTaskAsync(new Uri("http://www.gutenberg.org/files/2009/2009.txt"));
  ...
}</pre>
          </div>
          <p>The event handler for <code class="literal">DownloadFileCompleted</code> is pretty self-explanatory. The event handler for <code class="literal">DownloadProgressChanged</code> is where the calculation of the progress actually happens. Each time the event fires, we get the number of bytes the <code class="literal">WebClient</code> has received, the total number of bytes to receive, and we calculate the percentage completed of the download. Finally, we set the<a id="id627" class="indexterm"></a> <code class="literal">Value</code> property of <code class="literal">ProgressBar</code> with the results of the <code class="literal">percentage</code> calculation.</p>
          <div class="informalexample">
            <pre class="programlisting">void client_DownloadProgressChanged(object sender, DownloadProgressChangedEventArgs e)
{
  double bytesIn = double.Parse(e.BytesReceived.ToString());
  double totalBytes = double.Parse(e.TotalBytesToReceive.ToString());
  double percentage = bytesIn / totalBytes * 100;
  DownloadProgress.Value = int.Parse(Math.Truncate(percentage).ToString());
}</pre>
          </div>
        </div>
      </div>
    </div>
</body>
</html>