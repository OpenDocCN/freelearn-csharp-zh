- en: 20 Modular Monolith
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20 模块化单体
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您开始之前：加入我们的Discord书友社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file172.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file172.png)'
- en: In the ever-evolving software development landscape, choosing the right architecture
    is like laying the foundation for a building. The architecture dictates how the
    software is structured, impacting its scalability, maintainability, and overall
    success. Traditional monolithic architecture and microservices have long been
    the dominant paradigms, each with advantages and challenges.However, a new architectural
    style has been gaining traction—Modular Monoliths. This approach aims to offer
    the best of both worlds by combining the simplicity of monoliths with the flexibility
    of microservices. It serves as a middle ground that addresses some of the complexities
    associated with microservices, making it particularly appealing for small to medium-sized
    projects or teams transitioning from a traditional monolithic architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断演变的软件开发领域中，选择正确的架构就像为建筑奠定基础。架构决定了软件的结构，影响着其可扩展性、可维护性和整体成功。传统的单体架构和微服务长期以来一直是主导范式，各有其优势和挑战。然而，一种新的架构风格正在获得关注——模块化单体。这种方法旨在通过结合单体和微服务的简单性与灵活性，提供两者的最佳结合。它作为一个中间地带，解决了与微服务相关的一些复杂性，使其特别适合小型到中型项目或从传统单体架构过渡的团队。
- en: I wrote an article about this in 2017 entitled *Microservices Aggregation*.
    I recently read the name *Modular Monolith* and loved it better. This architectural
    style is gaining traction, yet it is not entirely new. The Modular Monolith style
    is a way to modularize and organize an application, lowering our chances of creating
    a big ball of mud.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在2017年写了一篇关于这个主题的文章，标题为《微服务聚合》。我最近看到了“模块化单体”这个名字，觉得它更好。这种架构风格正在获得关注，但它并不完全新颖。模块化单体风格是一种模块化和组织应用程序的方法，降低了我们创建一团糟的可能性。
- en: 'This chapter aims to provide a comprehensive understanding of Modular Monoliths.
    We delve into its core principles, advantages, and key components and explore
    when and how to implement this architecture. We build upon our nano e-commerce
    application to get hands-on insights into Modular Monoliths'' practical applications.
    Additionally, we discuss how they compare with other architectural styles to help
    you make informed decisions for your next projects.By the end of this chapter,
    you should have a solid grasp of Modular Monoliths, why they might be the right
    choice for your project, and how to implement them.In this chapter, we cover the
    following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在全面了解模块化单体。我们深入探讨其核心原则、优势以及关键组件，并探讨何时以及如何实施这种架构。我们基于我们的纳米电子商务应用，以获得模块化单体在实际应用中的实践经验。此外，我们讨论了它们与其他架构风格的比较，以帮助您为您的下一个项目做出明智的决定。在本章结束时，您应该对模块化单体有一个牢固的理解，了解为什么它们可能是您项目的正确选择，以及如何实施它们。在本章中，我们将涵盖以下主题：
- en: What is a Modular Monolith?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模块化单体？
- en: Advantages of Modular Monoliths
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化单体的优势
- en: Key Components of a Modular Monolith
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化单体的关键组件
- en: Implementing a Modular Monolith
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施模块化单体
- en: Project—Modular Monolith
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目—模块化单体
- en: Transitioning to Microservices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向微服务过渡
- en: Challenges and Pitfalls
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战与陷阱
- en: Let’s start by exploring what is a Modular Monolith.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨什么是模块化单体开始。
- en: What is a Modular Monolith?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是模块化单体？
- en: 'A Modular Monolith is an architectural style that aims to combine the best
    aspects of traditional monolithic architectures and microservices. It organizes
    the software application into well-defined, loosely coupled modules. Each is responsible
    for a specific business capability. However, unlike microservices, all these modules
    are deployed as a single unit like a monolith.The core principles of a Modular
    Monolith are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化单体是一种旨在结合传统单体架构和微服务的最佳特性的架构风格。它将软件应用程序组织成定义良好、松散耦合的模块。每个模块负责特定的业务能力。然而，与微服务不同，所有这些模块都作为一个单一单元部署，就像单体一样。模块化单体的核心原则是：
- en: Treat each module as a microservice.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个模块视为一个微服务。
- en: Deploy the application as a single unit.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序作为单一单元部署。
- en: 'Here are the fundamental principles of a successful microservice as studied
    in *Chapter 19*, *Introduction to Microservices Architecture*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是成功微服务的基本原则，这些原则在*第19章*，*微服务架构简介*中进行了研究：
- en: Each microservice should be a cohesive unit of business.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该是一个业务上的统一单元。
- en: Each microservice should own its data.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该拥有自己的数据。
- en: Each microservice should be independent of the others.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该独立于其他微服务。
- en: In a nutshell, we get the best of both worlds. Yet, understanding how a Modular
    Monolith compares with other architectural styles is crucial for making informed
    decisions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们得到了两者的最佳结合。然而，了解模块化单体与其他架构风格相比如何，对于做出明智的决定至关重要。
- en: What are traditional Monoliths?
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传统单体是什么？
- en: In a traditional monolithic architecture, we build the application as a single,
    indivisible unit. This leads to the functionalities being tightly coupled together,
    making it difficult to make changes or scale specific features. This approach
    makes creating a big ball of mud easier, particularly when the team invests little
    effort in domain modeling and analysis before and during development.On top of
    that, while this approach is simple and straightforward, it lacks the flexibility
    and scalability of more modern architectures.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单体架构中，我们将应用程序构建为一个单一、不可分割的单元。这导致功能紧密耦合在一起，使得更改或扩展特定功能变得困难。这种方法使得创建一个大泥球更容易，尤其是在团队在开发和开发前后的领域建模和分析投入很少努力的情况下。此外，尽管这种方法简单直接，但它缺乏更现代架构的灵活性和可扩展性。
- en: A monolith does not have to be indivisible, yet most end up this way because
    it is easy to create tight coupling in a single application.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个单体不一定是不可分割的，然而大多数最终都变成了这样，因为在一个单一应用程序中创建紧密耦合很容易。
- en: Let’s look at microservices next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来看看微服务。
- en: What are microservices?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务是什么？
- en: Microservices architecture, on the other hand, takes modularity to the extreme.
    Each service is a completely independent unit, running in its own environment.
    Microservices architecture allows for high scalability and flexibility but comes
    at the cost of increased operational complexity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，微服务架构将模块化推向了极致。每个服务都是一个完全独立的单元，在自己的环境中运行。微服务架构允许高度的可扩展性和灵活性，但代价是增加了操作复杂性。
- en: '*Chapter 19*, *Introduction to Microservices Architecture*, covers this topic
    more in-depth.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*第19章*，*微服务架构简介*更深入地探讨了这一主题。'
- en: The following sections delve deeper into this emerging architectural style,
    starting with its advantages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节更深入地探讨了这种新兴的架构风格，从其优势开始。
- en: Advantages of Modular Monoliths
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化单体的优势
- en: One of the best things about Modular Monoliths is that they are easy to manage.
    You don't have to worry about many moving parts like with microservices. Everything
    is in one place but still separated into modules. This makes it easier for us
    to keep track of things and to work with them.With Modular Monoliths, each module
    is like its own small project. We can test, fix, or improve a module without affecting
    the others. This is great because it lets us focus on one thing at a time, which
    improves productivity by lowering the cognitive load required to work on that
    feature.When it's time to release the software, we only have one application to
    deploy. Even though it has many modules, we treat them like one deployable unit.
    This makes managing deployments much more straightforward as we don’t have to
    juggle multiple services like we would with microservices.Modular Monoliths can
    save us money because we don't need as many resources since we deploy a single
    monolith. Because of that, we don't need a team to manage and run complicated
    infrastructure. We don't need to worry about distributed tracing between our services,
    which reduces the upfront monitoring cost. This deployment style is highly beneficial
    when starting a project with a small team or if the team is not proficient with
    microservices architecture.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化单体最优秀的一点是它们易于管理。你不必担心像微服务那样有许多移动部件。所有东西都在一个地方，但仍然被分割成模块。这使得我们更容易跟踪事物并与它们一起工作。在模块化单体中，每个模块就像是一个独立的小项目。我们可以测试、修复或改进一个模块，而不会影响其他模块。这很好，因为它让我们一次专注于一件事情，这通过降低工作在该功能上所需的认知负荷来提高生产力。当是时候发布软件时，我们只有一个应用程序需要部署。尽管它有许多模块，但我们把它们当作一个可部署的单元来处理。这使得管理部署变得更加直接，因为我们不需要像处理微服务那样处理多个服务。模块化单体可以为我们节省金钱，因为我们不需要像部署单个单体那样多的资源。正因为如此，我们不需要一个团队来管理和运行复杂的基础设施。我们不必担心服务之间的分布式跟踪，这减少了前期监控成本。这种部署方式在用小型团队开始项目或团队不熟悉微服务架构时非常有用。
- en: Modular Monoliths can still be valuable even if you are part of a large team,
    part of a larger organization, or have experience with microservices architecture.
    It is not one or the other kind of scenario.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使你是大型团队或大型组织的一部分，或者有微服务架构的经验，模块化单体仍然很有价值。这并不是一种或另一种场景。
- en: 'As we just explored, Modular Monoliths bring many advantages:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才探讨的，模块化单体带来了许多优势：
- en: The reduced operational complexity makes deploying a complex application as
    a single unit easier than microservices.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了操作复杂性，使得将复杂应用程序作为一个单一单元部署比微服务更容易。
- en: They improve our development and testing experience because of their simplicity,
    improving our efficiency.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过其简单性改善了我们的开发和测试体验，提高了我们的效率。
- en: They are easier to manage than most traditional monoliths because modules are
    well segregated.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们比大多数传统的单体应用更容易管理，因为模块被很好地隔离了。
- en: They are more cost-effective than microservices.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们比微服务更经济高效。
- en: The following section looks at what makes up a Modular Monolith.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将探讨构成模块化单体的是什么。
- en: Key Components of a Modular Monolith
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化单体的关键组件
- en: The first thing to know about Modular Monoliths is that they are composed of
    different parts called **modules**. Each module is like a mini-app that performs
    a specific job. This job is related to a particular business capability. A business
    capability comes from the business domain and aims at a cohesive group of scenarios.
    Such a group is called a bounded context in DDD. Think of each module as a microservice
    or a well-defined chunk of the domain.That separation means everything we need
    to complete a specific task is in one module, which makes it easier for us to
    understand and work on the software because we don’t have to jump from one place
    to another to get things done. So, if one module needs an update or has a problem,
    we can fix it without touching the others. This segregation is also perfect for
    testing since we can test each module in isolation to ensure it works well. For
    example, one module might handle a shopping cart while another takes care of the
    shipping, but we piece all modules together in a final aggregated application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模块化单体，首先要知道的是，它们由称为**模块**的不同部分组成。每个模块就像一个迷你应用程序，执行特定的任务。这项任务与特定的业务能力相关。业务能力来自业务领域，旨在针对一组连贯的场景。这样的组在领域驱动设计中被称为边界上下文。将每个模块视为一个微服务或定义良好的领域块。这种分离意味着完成特定任务所需的一切都在一个模块中，这使得我们更容易理解和处理软件，因为我们不需要从一个地方跳到另一个地方来完成事情。因此，如果一个模块需要更新或出现问题，我们可以修复它而不会影响到其他模块。这种隔离对于测试也非常完美，因为我们可以在隔离的情况下测试每个模块，以确保其正常工作。例如，一个模块可能处理购物车，而另一个模块则负责处理运输，但我们将这些模块拼接到一个最终聚合的应用程序中。
- en: We can create the modular monolith as a single project. However, in a .NET-specific
    environment, when each module comprises one or more assemblies, it is harder to
    create unwanted coupling between modules. We explore this in the project we are
    about to build.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以将模块化单体作为一个单一的项目来创建。然而，在.NET特定的环境中，当每个模块包含一个或多个程序集时，创建模块之间的不必要耦合会更加困难。我们将在即将构建的项目中探讨这一点。
- en: 'The **module aggregator**—the monolith—is responsible for loading and serving
    the modules as if they were just one application.Even though each module is independent,
    they still need to talk to each other sometimes. For example, the product catalog
    module might need to tell the shopping cart module that an employee has added
    a new product to the catalog. There are many ways to make this communication happen.
    One of the best ways to keep a low coupling level between the modules is to leverage
    event-driven architecture. On top of loose coupling, this opens doors like scaling
    the Modular Monolith by migrating one or more modules to a microservices architecture;
    more on that later.Here''s a diagram that represents these relationships:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块聚合器**——单体——负责加载和提供模块，就像它们只是一个应用程序一样。尽管每个模块都是独立的，但它们有时仍然需要相互通信。例如，产品目录模块可能需要通知购物车模块，员工已将新产品添加到目录中。有许多方法可以实现这种通信。保持模块之间低耦合水平的一种最佳方法是通过利用事件驱动架构。在松散耦合的基础上，这还打开了诸如通过将一个或多个模块迁移到微服务架构来扩展模块化单体的大门；关于这一点，稍后还会详细介绍。以下是一个表示这些关系的图：'
- en: '![Figure 20.1: Diagram representing the relationships between the module aggregator,
    the modules, and an event broker.](img/file173.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图20.1：表示模块聚合器、模块和事件代理之间关系的图](img/file173.png)'
- en: 'Figure 20.1: Diagram representing the relationships between the module aggregator,
    the modules, and an event broker.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1：表示模块聚合器、模块和事件代理之间关系的图
- en: Now that we have explored the key components of a Modular Monolith, the next
    section discusses planning and implementing one.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了模块化单体的关键组件，下一节将讨论其规划和实现。
- en: Implementing a Modular Monolith
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现模块化单体
- en: 'Planning is essential before building a Modular Monolith. We must consider
    what each module does and how modules work together. A good plan helps us avoid
    problems later on.Choosing the right tools to create a lean stack is also essential.
    The good news is that we don''t need to define a large shared stack since each
    module is independent. Like a slice in Vertical Slice architecture, each module
    can determine its patterns and data sources. Yet, we must define a few common
    elements to assemble a Modular Monolith successfully. Here are a few items to
    consider to improve the chances of success of a Modular Monolith:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建模块化单体之前进行规划至关重要。我们必须考虑每个模块的功能以及模块如何协同工作。一个好的计划有助于我们避免以后出现问题。选择合适的工具来创建精简的堆栈也是至关重要的。好消息是，我们不需要定义一个大的共享堆栈，因为每个模块都是独立的。就像垂直切片架构中的一个切片一样，每个模块可以确定其模式和数据源。然而，我们必须定义一些共同元素，以成功组装模块化单体。以下是一些考虑事项，以提高模块化单体成功的可能性：
- en: The modules share a URL space.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块共享一个 URL 空间。
- en: The modules share the configuration infrastructure.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块共享配置基础设施。
- en: The modules share a single dependency injection object graph (one container).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块共享单个依赖注入对象图（一个容器）。
- en: The modules share the inter-module communication infrastructure (event broker).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块共享模块间通信的基础设施（事件代理）。
- en: 'We can mitigate the first two elements using the module name as a discriminator.
    For example, using the `/{module name}/{module space}` URI space would yield the
    following results (`products`, `baskets`, and `customers` are modules):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模块名称作为区分符来减轻前两个元素。例如，使用 `/{"模块名称"}/{模块空间}` URI 空间会产生以下结果（`products`、`baskets`
    和 `customers` 是模块）：
- en: '`/products`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/products`'
- en: '`/products/123`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/products/123`'
- en: '`/baskets`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/baskets`'
- en: '`/customers`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/customers`'
- en: 'Using the module name as the top-level key of the configuration also makes
    it easy to avoid conflicts, like `{module name}:{key}`, or like the following
    JSON (say from the `appsettings.json` file):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块名称作为配置的最高级键也使得避免冲突变得容易，如 `{模块名称}:{键}`，或者如下面的 JSON（例如来自 `appsettings.json`
    文件）：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can mitigate the last two elements by managing the shared code in a certain
    way. For example, limiting the amount of shared code reduces the chances of conflict
    between the modules. Yet, multiple modules globally configuring ASP.NET Core or
    a third-party library can result in conflicts; centralizing those configurations
    into the aggregator instead and treating them as a convention will help mitigate
    most issues. Cross-cutting concerns like exception handling, JSON serialization,
    logging, and security are great candidates for this.Lastly, sharing a single way
    to communicate between modules and configuring it in the aggregator will help
    mitigate the communication issues.Let's start planning the project next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以某种方式管理共享代码来减轻最后两个元素。例如，限制共享代码的数量可以减少模块之间冲突的机会。然而，多个模块全局配置 ASP.NET Core
    或第三方库可能会导致冲突；将这些配置集中到聚合器中，并将它们视为约定，将有助于减轻大多数问题。跨切面关注点，如异常处理、JSON 序列化、日志记录和安全，是这种方法的理想候选者。最后，共享模块间通信的单一种方式并在聚合器中配置它将有助于减轻通信问题。让我们开始规划项目。
- en: Planning the project
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划项目
- en: 'Planning is a crucial part of any software. Without a plan, you increase your
    chances of building the wrong thing. A plan does not guarantee success, but it
    improves your chances. Overplanning is the other side of this coin. It can lead
    to **analysis paralysis**, which means you may never even deliver your project
    or that it will take you so long to deliver it that it will be the wrong product
    because the needs changed along the way and you did not adapt.Here''s a high-level
    way to accomplish planning a Modular Monolith. You don''t have to execute all
    the steps in order. You can perform many of them iteratively, or multiple people
    or teams can even work on them in parallel:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 规划是任何软件的关键部分。没有计划，你增加构建错误东西的机会。计划并不能保证成功，但它提高了你的机会。过度规划是另一面。它可能导致**分析瘫痪**，这意味着你可能永远无法交付你的项目，或者它将花费你如此长的时间来交付，以至于它将是一个错误的产品，因为需求在途中发生了变化，而你没有适应。以下是一个规划模块化单体的高级方法。你不必按顺序执行所有步骤。你可以迭代地执行许多步骤，或者多个人或团队甚至可以并行工作：
- en: Analyse and model the domain.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析和建模领域。
- en: Identify and design the modules.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别并设计模块。
- en: Identify the interactions between modules and design the integration events
    that cover those interactions.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别模块之间的交互并设计覆盖这些交互的集成事件。
- en: 'Once we are done planning, we can develop and operate the application. Here
    are a few high-level steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成规划，我们就可以开发和操作应用程序。以下是一些高级步骤：
- en: Build and test the modules in isolation.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在隔离状态下构建和测试模块。
- en: Build and test the module aggregator application that integrates one or more
    modules.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和测试集成一个或多个模块的模块聚合器应用程序。
- en: Deploy, operate, and monitor the monolith.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署、操作和监控单体。
- en: 'Implementing a Modular Monolith, like any program, is a step-by-step process.
    We plan, build, test, and then deploy it. Each part is simple enough on its own,
    and when we piece all of them together, we get an easy-to-maintain system. Even
    if continuously improving the application and refining the analysis and the model
    over time should yield the best results, having a good idea of the high-level
    domain—the modules—and at least a vague view of their interactions before starting
    will help avoid mistakes and potentially significant refactoring further down
    the road. Here’s a general representation of this process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实施模块化单体，就像任何程序一样，是一个逐步的过程。我们规划、构建、测试，然后部署它。每个部分本身都足够简单，当我们把它们拼在一起时，我们得到一个易于维护的系统。即使持续改进应用程序、细化分析和模型随着时间的推移会产生最佳结果，但在开始之前对高级领域——模块——有一个好的理解，以及至少对它们之间交互的模糊看法，将有助于避免错误，并可能避免进一步的重大重构。以下是此过程的通用表示：
- en: ∞
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ∞
- en: 'Figure 20.2: A partial Agile and DevOps view of the Modular Monolith phases'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.2：模块化单体阶段的敏捷和DevOps部分视图
- en: Next, we plan our nano e-commerce application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们规划我们的纳米电子商务应用程序。
- en: Analyzing the domain
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析领域
- en: 'As we continue to iterate over the nano e-commerce application we built in
    *Chapter 18* and *Chapter 19*, the domain analysis will be very short. Moreover,
    we are not expanding the application further than products and baskets because
    the application is already too large to fit in a single chapter. Of course, this
    time, we are making it a Modular Monolith. Here are the high-level entities and
    their relationships:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续迭代我们在第18章和第19章中构建的纳米电子商务应用程序时，领域分析将会非常简短。此外，我们不会将应用程序扩展到产品和服务车之外，因为应用程序已经太大，无法放入单个章节。当然，这次，我们将其构建为模块化单体。以下是高级实体及其关系：
- en: '![Figure 20.3: The high-level entities of our nono e-commerce app and their
    relationships](img/file174.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图20.3：我们的纳米电子商务应用程序的高级实体及其关系](img/file174.png)'
- en: 'Figure 20.3: The high-level entities of our nono e-commerce app and their relationships'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.3：我们的纳米电子商务应用程序的高级实体及其关系
- en: As the diagram shows, we have a `Product` entity that could benefit from more
    details like categories, hence the `...` box. We also have the `BasketItem` entity
    we use for people to save their shopping baskets to the database. Finally, a `Customer`
    entity represents the person to whom a shopping basket belongs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如图表所示，我们有一个`Product`实体，它可以从更多细节中受益，如类别，因此有`...`框。我们还有一个`BasketItem`实体，我们用它来将人们的购物车保存到数据库中。最后，一个`Customer`实体代表拥有购物车的人。
- en: We did not implement a `Customer` class, yet the customer is conceptually present
    through the `CustomerId` property.
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管我们没有实现`Customer`类，但客户概念上通过`CustomerId`属性存在。
- en: Next, we split this subset of the domain into modules.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这个领域子集拆分为模块。
- en: Identifying the modules
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别模块
- en: 'Now that we have identified the entities, it is time to map them into modules.
    Let’s start with the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了实体，是时候将它们映射到模块中。让我们从以下图表开始：
- en: '![Figure 20.4: Modules (bounded context) separation and entities relationships.](img/file175.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图20.4：模块（边界上下文）分离和实体关系。](img/file175.png)'
- en: 'Figure 20.4: Modules (bounded context) separation and entities relationships.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.4：模块（边界上下文）分离和实体关系。
- en: As expected, we have a product catalog, a shopping basket, and a customer management
    modules. What’s new here is the relationships between the entities. The catalog
    mainly manages the `Product` entity, yet the shopping basket needs to know about
    it to operate. The same logic applies to the `Customer` entity. In this case,
    the shopping basket only needs to know the unique identifier of each entity, but
    another module could need more information.Based on that high-level view, we need
    to create three modules. In our case, we continue with only two modules. In an
    actual application, we’d have more than three modules since we’d have to manage
    the purchases, the shipping, the inventory, and more.Let’s look at the interactions
    between the modules.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们有一个产品目录、购物车和客户管理模块。这里的新颖之处在于实体之间的关系。目录主要管理 `Product` 实体，但购物车需要了解它才能操作。同样的逻辑也适用于
    `Customer` 实体。在这种情况下，购物车只需要知道每个实体的唯一标识符，但另一个模块可能需要更多信息。基于这个高级视图，我们需要创建三个模块。在我们的案例中，我们继续使用两个模块。在实际应用中，我们会拥有超过三个模块，因为我们还需要管理购买、运输、库存等。让我们看看模块之间的交互。
- en: Identifying the interactions between modules
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别模块之间的交互
- en: 'Based on our analysis and limited to the two modules we are building, the shopping
    basket module needs to know about the products. Here’s our `BasketItem` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的分析和限于我们正在构建的两个模块，购物车模块需要了解产品。以下是我们的 `BasketItem` 类：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding class shows that we only need to know about the unique product
    identifier. So, with an event-driven mindset, the shopping basket module wants
    to be notified when:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类显示我们只需要了解独特的商品标识符。因此，以事件驱动的思维方式，购物车模块希望在以下情况下得到通知：
- en: A product is created.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个产品。
- en: A product is deleted.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品被删除。
- en: 'With those two events, the basket module can manage its cache of products and
    only allow customers to add existing items to their shopping basket. It can also
    remove items from customers’ shopping baskets when unavailable. Here’s a diagram
    representing these flows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个事件，购物车模块可以管理其产品缓存，并只允许客户将现有商品添加到他们的购物车中。当商品不可用时，它还可以从客户的购物车中移除商品。以下是一个表示这些流程的图表：
- en: '![Figure 20.5: The integration event flows between the catalog and the basket
    modules.](img/file176.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图20.5：目录模块和购物车模块之间的集成事件流](img/file176.png)'
- en: 'Figure 20.5: The integration event flows between the catalog and the basket
    modules.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.5：目录模块和购物车模块之间的集成事件流。
- en: Now that we have analyzed the domain and the modules, before building anything,
    let's define our stack.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了领域和模块，在构建任何东西之前，让我们定义我们的技术栈。
- en: Defining our stack
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义我们的技术栈
- en: We know we are using ASP.NET Core and C#. We continue leveraging minimal APIs,
    yet MVC could achieve the same. We also continue to leverage *EF Core*, *ExceptionMapper*,
    *FluentValidation*, and *Mapperly*. But what about the modules and the other shared
    aspects of the project? Let's have a look.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们正在使用 ASP.NET Core 和 C#。我们继续利用最小化 API，但 MVC 也能实现同样的效果。我们还继续利用 *EF Core*、*ExceptionMapper*、*FluentValidation*
    和 *Mapperly*。但模块和其他项目的共享方面怎么办？让我们看看。
- en: The module structure
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块结构
- en: 'We are using a flexible yet straightforward module structure. You can organize
    your projects however you like; this is not a prescriptive approach. For example,
    you can get inspired by other architectural styles, like Clean Architecture, or
    invent your own based on your own experience, context, and work environment.In
    our case, I opted for the following directory structure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是灵活且直接的模块结构。你可以以任何你喜欢的方式组织你的项目；这不是一种规定的方法。例如，你可以从其他架构风格中汲取灵感，如 Clean Architecture，或者根据自己的经验、背景和工作环境发明自己的架构。在我们的案例中，我选择了以下目录结构：
- en: The `applications` directory contains the deployable applications, like the
    aggregator. We could add user interfaces in this directory or other deployable
    applications, like the BFF we built in Chapter 19\. Each application is contained
    within its own subdirectory.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applications` 目录包含可部署的应用程序，如聚合器。我们可以在该目录中添加用户界面或其他可部署的应用程序，如第19章中构建的 BFF。每个应用程序都包含在其自己的子目录中。'
- en: The `modules` directory contains the modules, each within its own subdirectory.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules` 目录包含模块，每个模块都在自己的子目录中。'
- en: The `shared` directory contains the shared projects.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared` 目录包含共享项目。'
- en: In real-world software, we could extend this setup and add `infrastructure`,
    `docs`, and `pipelines` directories to store our Infrastructure as Code (IaC),
    documentation, and CI/CD pipelines next to our code.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在现实世界的软件中，我们可以扩展这个设置，并添加`infrastructure`、`docs`和`pipelines`目录来存储我们的基础设施即代码（IaC）、文档和CI/CD流水线，这些都与我们的代码相邻。
- en: 'What I like about this mono-repo-inspired structure is that each module and
    application is self-contained. For example, the aggregator’s API, contracts, and
    tests are next to each other:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这种由单一代码库启发的结构，因为每个模块和应用程序都是自包含的。例如，聚合器的API、合约和测试都紧挨在一起：
- en: '![Figure 20.6: The aggregator’s directory and project hierarchy.](img/file177.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图20.6：聚合器的目录和项目层次结构。](img/file177.png)'
- en: 'Figure 20.6: The aggregator’s directory and project hierarchy.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.6：聚合器的目录和项目层次结构。
- en: 'The modules are organized similarly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的组织方式类似：
- en: '![Figure 20.7: The modules'' subdirectories and catalog’s project hierarchy.](img/file178.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图20.7：模块的子目录和目录的项目层次结构。](img/file178.png)'
- en: 'Figure 20.7: The modules'' subdirectories and catalog’s project hierarchy.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.7：模块的子目录和目录的项目层次结构。
- en: I kept the REPR prefix since it’s based on Chapter 18’s code, but I changed
    the code structure a bit. In this version, I got rid of the nested classes and
    created one class per file. This follows a more classic .NET convention and allows
    us to extract the API contracts to another assembly. If you remember, in Chapter
    19, the BFF project referenced the two APIs to reuse their `Query`, `Command`,
    and `Response` contracts. We fix this problem through the `Contracts` class library
    projects in this solution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我保留了REPR前缀，因为它基于第18章的代码，但我稍微改变了代码结构。在这个版本中，我废除了嵌套类，并为每个文件创建了一个类。这遵循了更经典的.NET约定，并允许我们将API合约提取到另一个程序集。如果你记得，在第19章中，bff项目引用了两个API以重用它们的`Query`、`Command`和`Response`合约。我们通过这个解决方案中的`Contracts`类库项目解决这个问题。
- en: Why is it a problem? The BFF depends on all the microservices, including their
    logic and dependencies. This is a recipe to introduce unwanted coupling. Moreover,
    since it inherits all the dependencies transitively, it increases its deployment
    size and vulnerability surface; more dependencies and more code means more possibilities
    for a malicious actor to find an exploitable hole.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么这是个问题？bff依赖于所有微服务，包括它们的逻辑和依赖。这是一个引入不必要耦合的配方。此外，由于它继承所有依赖项，它增加了其部署大小和脆弱性表面；更多的依赖和代码意味着恶意行为者找到可利用漏洞的可能性更大。
- en: On top of the API contracts, the `Contracts` projects also contain the integration
    events. We could have separated the API contracts and the integration events if
    the application was larger; in this case, we only have two integration events.
    Design choices must be taken relative to the current project and context.Let’s
    explore the URI space next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在API合约之上，`Contracts`项目还包含了集成事件。如果应用程序更大，我们可以将API合约和集成事件分开；在这种情况下，我们只有两个集成事件。设计选择必须根据当前项目和上下文来考虑。接下来，让我们探索URI空间。
- en: The URI space
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: URI空间
- en: 'The modules of this application follow the previously discussed URI space:
    `/{module name}/{module space}`. Each module has a `Constants` file at its root
    that looks like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的模块遵循之前讨论的URI空间：`/{module name}/{module space}`。每个模块在其根目录都有一个`Constants`文件，看起来像这样：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use the `ModuleName` constant in the `{module name}ModuleExtensions` files
    to set the URI prefix and tag the endpoints like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`{module name}ModuleExtensions`文件中使用`ModuleName`常量来设置URI前缀，并像这样标记端点：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this in place, both modules self-register themselves in the correct URI
    space.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，这两个模块都会在正确的URI空间中自我注册。
- en: We can apply these types of conventions in many different ways. In this case,
    we opted for simplicity, which is the most error-prone, leaving the responsibility
    to the mercy of each module. With a more framework-oriented mindset, we could
    create a strongly typed module contract that gets loaded automatically, like an
    `IModule` interface. The aggregator could also create the root groups and enforce
    the URI space.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以用许多不同的方式应用这些类型的约定。在这种情况下，我们选择了简单性，这是最容易出现错误的，将责任留给了每个模块。如果我们有更面向框架的思维模式，我们可以创建一个强类型模块合约，它会被自动加载，就像一个`IModule`接口。聚合器也可以创建根组并强制执行URI空间。
- en: Next, we explore the data space.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探索数据空间。
- en: The data space
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据空间
- en: Since we are following the microservices architecture tenets and each module
    should own its data, we must find a way to ensure our data contexts do not conflict.The
    project uses the EF Core in-memory provider to develop locally. For production,
    we plan on using SQL Server. One excellent way to ensure our `DbContext` classes
    do not conflict with each other is to create one database schema per context.
    Each module has one context, so one schema per module. We don’t have to overthink
    this; we can reuse the same idea as the URI and leverage the module name. So,
    each module will group its tables under the `{module name}` schema instead of
    `dbo` (the default SQL Server schema).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循微服务架构原则，并且每个模块应该拥有自己的数据，我们必须找到一种确保我们的数据上下文不会冲突的方法。项目使用 EF Core 内存提供程序进行本地开发。对于生产环境，我们计划使用
    SQL Server。确保我们的 `DbContext` 类之间不冲突的一个很好的方法是为每个上下文创建一个数据库架构。每个模块有一个上下文，所以每个模块一个架构。我们不必过度思考；我们可以重用与
    URI 相同的想法，并利用模块名称。因此，每个模块将把其表分组在 `{模块名称}` 架构下，而不是 `dbo`（SQL Server 的默认架构）。
- en: We can apply different security rules and permissions to each schema in SQL
    Server, so we could craft a very secure database model by expanding this. For
    instance, we could employ multiple users possessing minimal privileges, utilize
    different connection strings within the modules, etc.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以在 SQL Server 中为每个架构应用不同的安全规则和权限，因此我们可以通过扩展这个方法来构建一个非常安全的数据库模型。例如，我们可以使用具有最小权限的多个用户，在模块中使用不同的连接字符串等。
- en: 'In code, doing this is reflected by setting the default schema name in the
    `OnModelCreating` method of each `DbContext`. Here’s the `ProductContext` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这样做是通过在每个 `DbContext` 的 `OnModelCreating` 方法中设置默认架构名称来体现的。以下是一个 `ProductContext`
    类的例子：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code makes all `ProductContext`’s tables part of the `products`
    schema. We then apply the same for the basket module:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使所有 `ProductContext` 的表都成为 `products` 架构的一部分。然后我们为购物车模块做同样的处理：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code makes all `BasketContext`’s tables part of the `baskets`
    schema.Due to the schema, both contexts are safe from hindering the other. But
    wait! Both contexts have a `Products` table; what happens then? The catalog module
    uses the `products.products` table, while the basket module uses the `baskets.products`
    table. Different schema, different tables, case closed!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使所有 `BasketContext` 的表都成为 `baskets` 架构的一部分。由于架构的存在，这两个上下文都不会相互阻碍。但是等等！这两个上下文都有一个
    `Products` 表；那么会发生什么呢？目录模块使用 `products.products` 表，而购物车模块使用 `baskets.products`
    表。不同的架构，不同的表，问题解决！
- en: We can apply these notions to more than Modular Monolith as it is general SQL
    Server and EF Core knowledge.
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以将这些概念应用到不仅仅是模块化单体架构上，因为它是一般性的 SQL Server 和 EF Core 知识。
- en: If you are using another relational database engine that does not offer schema
    or a NoSQL database, you must also think about this. Each NoSQL database has different
    ways to think about the data, and it would be impossible to cover them all here.
    The important piece is to find a discriminator that segregates the data of your
    modules. At the limit, it can even be one different database per module; however,
    this increases the operational complexity of the application.Next, we explore
    the message broker.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不提供架构或 NoSQL 数据库的其他关系型数据库引擎，你也必须考虑这一点。每个 NoSQL 数据库都有不同的数据思考方式，在这里不可能全部涵盖。重要的是要找到一个区分器，将模块的数据分开。在最极端的情况下，甚至可以每个模块一个不同的数据库；然而，这会增加应用程序的操作复杂性。接下来，我们探讨消息代理。
- en: The message broker
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息代理
- en: 'To handle the integration events between the catalog and the basket modules,
    I decided to pick MassTransit. To quote their GitHub project:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理目录模块和购物车模块之间的集成事件，我决定选择 MassTransit。引用他们的 GitHub 项目：
- en: '*MassTransit is a free, open-source distributed application framework for .NET.
    MassTransit makes it easy to create applications and services that leverage message-based,
    loosely-coupled asynchronous communication for higher availability, reliability,
    and scalability.*'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*MassTransit 是一个免费的、开源的分布式应用程序框架，适用于 .NET。MassTransit 使得创建利用基于消息的、松散耦合的异步通信的应用程序和服务变得容易，从而提高了可用性、可靠性和可伸缩性。*'
- en: 'I picked MassTransit because it is a popular project with 5,800 GitHub stars
    as of 2023 and supports many providers, including in-memory. Moreover, it offers
    many features that are way above our needs. Once again, we could have used anything.
    For example, MediatR could have also done the job.The `REPR.API` project—the aggregator—and
    the modules depend on the following NuGet package to use MassTransit:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择MassTransit，因为它是一个拥有5,800 GitHub星标的流行项目，截至2023年支持许多提供者，包括内存中的。此外，它提供了许多超出我们需求的功能。再一次，我们可以使用任何东西。例如，MediatR也可以完成这项工作。《REPR.API》项目—聚合器—以及模块依赖于以下NuGet包来使用MassTransit：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our usage is very simple; the aggregator registers and configures MassTransit
    like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用法非常简单；聚合器像这样注册和配置MassTransit：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The highlighted line delegates the registration of event consumers to the basket
    module. The `AddBasketModuleConsumers` method is part of the `BasketModuleExtensions`
    class and contains the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行将事件消费者的注册委托给了购物篮模块。`AddBasketModuleConsumers`方法是`BasketModuleExtensions`类的一部分，并包含以下代码：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ProductEventsConsumers` class manages the two events. The `AddConsumers`
    method is part of MassTransit. We explore the `ProductEventsConsumers` class in
    the project section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductEventsConsumers`类管理两个事件。`AddConsumers`方法是MassTransit的一部分。我们在项目部分探讨了`ProductEventsConsumers`类。'
- en: We would register the event consumers of other modules here if we had more.
    Yet the delegation of that registration to each module makes it modular.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们有更多模块，我们会在这里注册其他模块的事件消费者。然而，将注册委托给每个模块使其模块化。
- en: Next, we write some C# code to transform our microservices application into
    a Modular Monolith.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写一些C#代码，将我们的微服务应用程序转换为模块化单体。
- en: Project—Modular Monolith
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目—模块化单体
- en: This project has the same building block as *Chapter 18* and *Chapter 19*, but
    we use the Modular Monolith approach. On top of the previous versions, we leverage
    events to enable the shopping basket to validate the existence of a product before
    allowing customers to add it to their shopping basket.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目与*第18章*和*第19章*具有相同的构建块，但我们使用了模块化单体方法。在之前的版本之上，我们利用事件来允许购物篮在允许客户将其添加到购物篮之前验证产品的存在。
- en: 'The complete source code is available on GitHub: [https://adpg.link/gyds](https://adpg.link/gyds)'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上找到：[https://adpg.link/gyds](https://adpg.link/gyds)
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The test projects in the solution are empty. They only exist for the organizational
    aspect of the solution. As an exercise, you can migrate the tests from *Chapter
    18* and adapt them to this new architectural style.
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决方案中的测试项目是空的。它们仅存在于解决方案的组织方面。作为一个练习，你可以将*第18章*中的测试迁移过来，并适应这种新的架构风格。
- en: Let’s start with the communication piece.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通信部分开始。
- en: Sending events from the catalog module
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从目录模块发送事件
- en: 'For the catalog to communicate the events that the basket module needs, it
    must define the following new operations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让目录模块能够传达购物篮模块需要的事件，它必须定义以下新操作：
- en: Create products
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品
- en: Delete products
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除产品
- en: 'Here are the API contracts we must create in the `REPR.Products.Contracts`
    project to support those two operations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`REPR.Products.Contracts`项目中，我们必须创建以下API契约来支持这两个操作：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The API contracts should look very familiar by now and are similar to those
    from previous chapters. We then need the following two event contracts:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，API契约应该已经很熟悉了，并且与之前章节中的契约相似。然后我们需要以下两个事件契约：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The two event classes are also very straightforward, but their name is in the
    past tense because an event happened in the past. So, the module creates the product
    and then notifies its subscribers that a product was created (in the past). Exactly
    like we studied in *Chapter 19*, *Introduction to Microservices Architecture*.
    Moreover, the events are simple data containers, like an API contract—a DTO—is.How
    do we send those events? Let’s have a look at the `CreateProductHandler` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个事件类也非常简单，但它们的名称是过去时，因为过去发生了一个事件。所以，模块创建了产品，然后通知其订阅者一个产品已经被创建（过去）。这与我们在*第19章*中学习的*微服务架构简介*完全一样。此外，事件是简单的数据容器，就像API契约——一个DTO一样。我们如何发送这些事件？让我们看看`CreateProductHandler`类：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we inject an `IBus` interface from MassTransit in the
    `CreateProductHandler` class. We also inject an object mapper and an EF Core `ProductContext`.
    The `HandleAsync` method does the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`CreateProductHandler`类中注入了MassTransit的`IBus`接口，我们还注入了一个对象映射器和EF
    Core的`ProductContext`。`HandleAsync`方法执行以下操作：
- en: Creates the product and saves it to the database.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建产品并将其保存到数据库中。
- en: Publishes a `ProductCreated` event (highlighted code).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布一个 `ProductCreated` 事件（高亮代码）。
- en: Returns a `CreateProductResponse` instance based on the new product.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据新产品返回一个 `CreateProductResponse` 实例。
- en: 'The `Publish` method sends the event to the configured pipe, which is in memory
    in our case. The code passes a `CancellationToken.None` argument here because
    we don’t want this operation to be canceled by any external force because the
    change is already saved in the database.Because of the mapping code, the publishing
    code may be hard to understand in a book. The `MapToIntegrationEvent` method converts
    a `Product` object to a `ProductCreated` instance, so the `productCreated` variable
    is of type `ProductCreated`. Here’s the *Mapperly* mapper class with that method
    highlighted:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publish` 方法将事件发送到配置的管道，在我们的案例中是在内存中。这里代码传递了一个 `CancellationToken.None` 参数，因为我们不希望任何外部力量取消此操作，因为更改已经保存在数据库中。由于映射代码，发布代码在书中可能难以理解。`MapToIntegrationEvent`
    方法将 `Product` 对象转换为 `ProductCreated` 实例，因此 `productCreated` 变量的类型为 `ProductCreated`。以下是具有突出显示该方法的
    *Mapperly* 映射类：'
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `DeleteProductHandler` class follows a similar pattern but publishes the
    `ProductDeleted` event instead.Now, let’s explore how the basket module consumes
    those events.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteProductHandler` 类遵循类似的模式，但发布的是 `ProductDeleted` 事件。现在，让我们探索篮子模块如何消费这些事件。'
- en: Consuming the events from the basket module
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从篮子模块消费事件
- en: 'The basket module wants to cache existing products. We can achieve this in
    different ways. In this case, we create the following `Product` class that we
    persist in the database:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 篮子模块想要缓存现有产品。我们可以用不同的方式实现这一点。在这种情况下，我们创建以下 `Product` 类并将其持久化到数据库中：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make use of it, we must expose the following property from the `BasketContext`
    class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，我们必须从 `BasketContext` 类中公开以下属性：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can start to leverage this cache. Firstly, we must populate it when
    the catalog module creates a product and remove that product when deleted. The
    `ProductEventsConsumers` class handles both events. Here’s the skeleton of this
    class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始利用这个缓存。首先，我们必须在目录模块创建产品时填充它，在删除产品时移除该产品。`ProductEventsConsumers` 类处理这两个事件。以下是这个类的框架：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The highlighted code represents the two event handlers. The `IConsumer<TMessage>`
    interface contains the `Consume` method. Implementing the interface twice with
    a different `TMessage` generic parameter prescribes implementing the two `Consume`
    methods in the `ProductEventsConsumers` class. Each method handles its own event.When
    a product is created in the product module, the following method is executed in
    the basket module (I removed the logging code for brevity):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮代码表示两个事件处理器。`IConsumer<TMessage>` 接口包含 `Consume` 方法。通过使用不同的 `TMessage` 泛型参数实现接口两次，规定在
    `ProductEventsConsumers` 类中实现两个 `Consume` 方法。每个方法处理其自己的事件。当产品模块中创建产品时，篮子模块将执行以下方法（为了简洁，我移除了日志代码）：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code adds a new product to the database if it does not exist.
    If it does exist, it does nothing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在产品不存在时将其添加到数据库中。如果它已经存在，则不执行任何操作。
- en: We could add telemetry here to log and flag the conflict and explore how to
    solve it. If the product already exists, the event was received twice, which may
    indicate an issue with our system.
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以在此处添加遥测来记录和标记冲突，并探索如何解决它。如果产品已经存在，事件被接收了两次，这可能表明我们的系统存在问题。
- en: 'Here’s the flow of what happens when an employee creates a new product:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是当员工创建一个新产品时发生流程的概述：
- en: '![Figure 20.8: A diagram showcasing the sequence of operations when someone
    adds a product to the system.](img/file179.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.8：展示有人向系统中添加产品时操作序列的图表](img/file179.png)'
- en: 'Figure 20.8: A diagram showcasing the sequence of operations when someone adds
    a product to the system.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.8：展示有人向系统中添加产品时操作序列的图表。
- en: 'Let’s review the operations:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下操作：
- en: A client sends a POST request to the API (the aggregator application). The catalog
    module receives the request.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向 API（聚合应用程序）发送 POST 请求。目录模块接收请求。
- en: The catalog creates the product and adds it to the database.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目录创建产品并将其添加到数据库中。
- en: The catalog then publishes the `ProductCreated` event using MassTransit.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目录随后使用 MassTransit 发布 `ProductCreated` 事件。
- en: In the basket module, the `Consume` method of the `ProductEventsConsumers` class
    gets called by MassTransit in reaction to the `ProductCreated` event.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在篮子模块中，`ProductEventsConsumers` 类的 `Consume` 方法在 MassTransit 对 `ProductCreated`
    事件的反应中被调用。
- en: The basket module adds the product's identifier to the database to its materialized
    view.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 购物车模块将产品的标识符添加到数据库的物化视图中。
- en: 'Now that we know how the `ProductEventsConsumers` class handles the `ProductCreated`
    events, let’s explore the `ProductDeleted` events (logging code omitted for brevity):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`ProductEventsConsumers`类如何处理`ProductCreated`事件，让我们探索`ProductDeleted`事件（为了简洁，省略了日志代码）：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding `Consume` method removes the products from people’s shopping baskets
    and the materialized view. If the product does not exist, the method does nothing
    because there’s nothing to handle.A similar flow happens when an employee deletes
    a product from the catalog and publishes a `ProductDeleted` event. The basket
    module then reacts to the event and updates its cache (materialized view).Now
    that we have explored this exciting part of the project, let’s look at the aggregator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`Consume`方法从人们的购物车和物化视图中删除产品。如果产品不存在，则该方法不执行任何操作，因为没有要处理的内容。当员工从目录中删除产品并发布`ProductDeleted`事件时，也会发生类似的流程。购物车模块随后对事件做出反应并更新其缓存（物化视图）。现在我们已经探索了这个项目的这个令人兴奋的部分，让我们来看看聚合器。
- en: Inside the aggregator
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在聚合器内部
- en: 'The aggregator application is like an empty shell that loads the other assemblies
    and configures the cross-cutting concerns. It references the modules, then assembles
    and boots the application. Here’s the first part of the `Program.cs` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合应用程序就像一个空壳，它加载其他组件并配置跨切面关注点。它引用模块，然后组装并启动应用程序。以下是`Program.cs`文件的第一部分：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code registers the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码注册了以下内容：
- en: '*FluentValidation*; it also scans the assemblies for validators.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FluentValidation*；它还会扫描组件以查找验证器。'
- en: The `IWebClient` interface that we use to seed the database (the `AddApiHttpClient`
    method).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用来初始化数据库的`IWebClient`接口（即`AddApiHttpClient`方法）。
- en: '*ExceptionMapper*.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异常映射器*。'
- en: The modules' dependencies (highlighted)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的依赖关系（高亮显示）
- en: '*MassTransit*; it also registers the consumers from the basket module (highlighted).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MassTransit*；它还注册了来自购物车模块的消费者（高亮显示）。'
- en: 'The container we register those dependencies into is also used for and by the
    modules because the aggregator is the host. Those dependencies are shared across
    the modules.The second part of the `Program.cs` file is the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些依赖项注册到的容器也用于模块，因为聚合器是宿主。这些依赖项在模块之间共享。`Program.cs`文件的第二部分如下：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code registers the `ExceptionMapper` middleware, then the modules.
    It also adds a seeding endpoint (highlighted). If you remember, we were seeding
    the database using the `DbContext` in the previous versions. However, since the
    basket module needs to receive the events from the catalog to build a materialized
    view, it is more convenient to seed the database through the catalog module. In
    this version, the program seeds the database when a client hits the `/` endpoint.
    By default, when starting the application, Visual Studio should open a browser
    at that URL, which will seed the database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码注册了`ExceptionMapper`中间件，然后是模块。它还添加了一个初始化端点（高亮显示）。如果你记得，我们之前使用`DbContext`来初始化数据库。然而，由于购物车模块需要从目录接收事件以构建物化视图，因此通过目录模块初始化数据库更为方便。在这个版本中，程序在客户端访问`/`端点时初始化数据库。默认情况下，当启动应用程序时，Visual
    Studio应该在URL中打开浏览器，这将初始化数据库。
- en: Seeding the database by sending a GET request to the `/` endpoint is very convenient
    for an academic scenario where we use in-memory databases. However, this could
    be disastrous in a production environment because it would reseed the database
    whenever someone hits that endpoint.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过向`/`端点发送GET请求来初始化数据库在学术场景中使用内存数据库时非常方便。然而，在生产环境中这可能会造成灾难，因为每次有人访问该端点时都会重新初始化数据库。
- en: Let’s explore the `IWebClient`, next.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来探索`IWebClient`。
- en: Exploring the REST API HttpClient
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索REST API HttpClient
- en: 'In the `shared` directory, the `REPR.API.HttpClient` project contains the REST
    API client code. The code is very similar to the previous project, but the `IProductsClient`
    now exposes a create and delete method (highlighted):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shared`目录中，`REPR.API.HttpClient`项目包含REST API客户端代码。代码与上一个项目非常相似，但现在的`IProductsClient`现在公开了创建和删除方法（高亮显示）：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On top of this, the project only references the `Contracts` projects, limiting
    its dependencies to the classes it needs. It does not reference the complete modules
    anymore. This makes this project easy to reuse. For example, we could build another
    project, like a user interface (UI), then reference and use this typed client
    to query the API (modular monolith) from that .NET UI.Since we created this client
    for a microservices application, we have two base downstream service URLs—one
    for the product microservice and one for the basket microservice. This nuance
    suits us well since we may want to migrate our monolith to microservices later.
    In the meantime, all we have to do is set the two keys to the same host, like
    the following `appsettings.json` file from the aggregator:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之上，项目仅引用`Contracts`项目，限制其依赖性仅限于它需要的类。它不再引用完整的模块。这使得该项目易于重用。例如，我们可以构建另一个项目，如用户界面（UI），然后引用并使用此类型客户端从.NET
    UI查询API（模块化单体）。由于我们为微服务应用程序创建了此客户端，我们有两个基础下游服务URL——一个用于产品微服务，一个用于购物车微服务。这种细微差别非常适合我们，因为我们可能希望在以后将单体迁移到微服务。与此同时，我们只需将两个键设置为同一主机即可，如下所示`appsettings.json`文件来自聚合器：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With these configurations, the `AddApiHttpClient` method configures two `HttpClient`
    with the same `BaseAddress` value, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些配置，`AddApiHttpClient`方法配置了两个具有相同`BaseAddress`值的`HttpClient`，如下所示：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And voilà, we have a functional typed client we can reuse and a working modular
    monolith. Let’s test this out next.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们有一个可重用的功能化客户端和一个工作模块化单体。让我们接下来测试一下。
- en: Sending HTTP requests to the API
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向API发送HTTP请求
- en: 'Now that we have a working modular monolith, we can reuse similar HTTP requests
    than the previous versions.At the root of the REPR.API project, we can use the
    following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作模块化单体，我们可以重用与之前版本相似的HTTP请求。在REPR.API项目的根目录中，我们可以使用以下内容：
- en: The `API-Products.http` file contains requests to the product module.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`API-Products.http`文件包含对产品模块的请求。'
- en: The `API-Baskets.http` file contains requests to the basket module.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`API-Baskets.http`文件包含对购物车模块的请求。'
- en: 'A new outcome in this API compared to the previous versions is when we try
    to add a product that does not exist in the catalog to our basket, like the following
    request:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前版本相比，这个API的新功能是当我们尝试将不在目录中的产品添加到购物车时，如下所示请求：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since the product `5` does not exist, the API returns the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于产品`5`不存在，API返回以下内容：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That error confirms that the validation works as expected. But how are we validating
    this?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该错误确认验证按预期工作。但我们是如何验证这个的呢？
- en: Validating the existence of a product
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证产品的存在性
- en: 'In the *add item* feature, the `AddItemValidator` class ensures the product
    exists while validating the `AddItemCommand` object. To achieve this, we leverage
    the `MustAsync` and `WithMessage` methods from FluentValidation. Here’s the code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在*添加项目*功能中，`AddItemValidator`类在验证`AddItemCommand`对象的同时确保产品存在。为了实现这一点，我们利用FluentValidation的`MustAsync`和`WithMessage`方法。以下是代码：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code implements the same rules as the previous versions but also
    calls the `ProductExistsAsync` method that fetches the requested product from
    the cache. If the result is `false`, the validation fails with the message “*The
    Product does not exist.*”.Here’s the resulting flow of this change:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了与之前版本相同的规则，但还调用了从缓存中检索请求产品的`ProductExistsAsync`方法。如果结果是`false`，验证失败，消息为“*该产品不存在*”。以下是此更改的结果流程：
- en: The client calls the API.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端调用API。
- en: The validation middleware calls the validator.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证中间件调用验证器。
- en: The validator fetches the record from the database and validates its existence.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证器从数据库中检索记录并验证其存在性。
- en: If the product does not exist, the request is short-circuited here and returned
    to the client. Otherwise, it continues to the `AddItemHandler` class.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果产品不存在，请求在这里被短路并返回给客户端。否则，它继续到`AddItemHandler`类。
- en: With this in place, we covered all new scenarios from this project. We also
    explored how the aggregator connects the modules together and how easy it is to
    keep our modules independent.Next, we get the BFF back into the project and explore
    how to transition our modular monolith to a microservices architecture.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些配置，我们覆盖了该项目中所有新的场景。我们还探讨了聚合器如何将模块连接在一起，以及保持我们的模块独立有多容易。接下来，我们将bff（最佳朋友）带回项目中，并探讨如何将我们的模块化单体过渡到微服务架构。
- en: Transitioning to Microservices
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向微服务过渡
- en: You don’t have to transition your monolith to microservices; deploying a monolith
    is fine if it fits your needs. However, if ever you need to, you could shield
    your aggregator with a gateway or a reverse proxy so you can extract modules into
    their own microservices and reroute the requests without impacting the clients.
    This would also allow you to gradually transfer the traffic to the new service
    while keeping the monolith intact in case of an unexpected failure.In a modular
    monolith, the aggregator registers most dependencies, so when migrating, you must
    also migrate this shared setup. One way to not duplicate code would be to create
    and reference a shared assembly containing those registrations. This makes it
    easier to manage the dependencies and shared configurations, but it is also coupling
    between the microservices and the aggregator. Leveraging the code of this shared
    assembly is even easier when the microservices are part of the same mono-repo;
    you can reference the project directly without managing a NuGet package. Yet,
    when you update the library, it updates all microservices and the monolith, voiding
    the deployment independence of each application.Once again, consider keeping the
    monolith intact versus the operational complexity that deploying microservices
    would bring.In the solution, the `REPR.BFF` project is a migration of *Chapter
    19* code. The code and the logic are almost the same. It leverages the `REPR.API.HttpClient`
    project and configures the downstream base addresses in its `appsettings.Development.json`
    file. The `REPR.BFF.http` file at the root of the project contains a few requests
    to test the application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必将单体应用转换为微服务；如果单体应用符合您的需求，部署单体应用是可以的。然而，如果您需要的话，您可以使用网关或反向代理来保护聚合器，这样您就可以将模块提取到它们自己的微服务中，并重新路由请求，而不会影响客户端。这也会让您能够逐步将流量转移到新服务，同时保持单体应用在意外故障发生时保持完整。在模块化单体中，聚合器注册了大多数依赖项，因此在迁移时，您还必须迁移这个共享设置。避免代码重复的一种方法就是创建并引用一个包含这些注册的共享程序集。这使得管理依赖项和共享配置变得更容易，但这也使得微服务和聚合器之间产生了耦合。当微服务是同一单体仓库的一部分时，利用这个共享程序集的代码甚至更容易；您可以直接引用项目，而无需管理NuGet包。然而，当您更新库时，它会更新所有微服务以及单体应用，从而消除了每个应用的部署独立性。再次强调，考虑保持单体应用完整与部署微服务带来的运营复杂性之间的权衡。在解决方案中，`REPR.BFF`项目是对第19章代码的迁移。代码和逻辑几乎相同。它利用了`REPR.API.HttpClient`项目，并在其`appsettings.Development.json`文件中配置了下游的基本地址。项目根目录下的`REPR.BFF.http`文件包含了一些用于测试应用的请求。
- en: 'The code is available on GitHub: [https://adpg.link/bn1F](https://adpg.link/bn1F).
    I suggest playing with the live application, which will yield a better result
    than copying the code in the book a second time. The relationships between the
    projects are also more evident in Visual Studio than written in a book. Feel free
    to refactor the projects, add tests, or add features. The best way to learn is
    to practice!'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码可在GitHub上找到：[https://adpg.link/bn1F](https://adpg.link/bn1F)。我建议您尝试使用实时应用程序，这会比再次复制书中的代码得到更好的结果。在Visual
    Studio中，项目之间的关系比在书中写出来更为明显。请随意重构项目、添加测试或添加功能。最好的学习方法是实践！
- en: Next, let’s have a look at challenges and pitfalls.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看挑战和陷阱。
- en: Challenges and Pitfalls
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战和陷阱
- en: 'It is a misconception that monoliths are only suitable for small projects or
    small teams. A well-built monolith can go a long way, which is what a modular
    structure and a good analysis bring. Modular Monoliths can be very powerful and
    work well for different sizes of projects. It is essential to consider the pros
    and cons of each approach when selecting the application pattern for a project.
    Maybe a cloud-native, serverless, microservices application is what your next
    project needs, but perhaps a well-designed Modular Monolith would achieve the
    same performance at a tremendously lower cost.To help you make those decisions,
    here are some potential challenges and how to avoid or mitigate them:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 认为单体应用仅适用于小型项目或小型团队是一种误解。一个构建良好的单体应用可以走得很远，这正是模块化结构和良好分析带来的结果。模块化单体可以非常强大，并且适用于不同规模的项目。在选择项目的应用程序模式时，考虑每种方法的优缺点是至关重要的。也许云原生、无服务器、微服务应用正是您下一个项目需要的，但也许一个精心设计的模块化单体可以在成本极低的情况下实现相同的表现。为了帮助您做出这些决定，以下是一些潜在的挑战以及如何避免或减轻它们：
- en: '**Too much complexity within a module:** One risk is making the modules too
    complex. Like any piece of code, it becomes harder to manage a module if it does
    too many things. Moreover, the bigger the piece of software, the more chance the
    shiny initial design starts to bleed into a big ball of mud. We can avoid this
    by keeping each module focused on a specific part of the domain and by applying
    the SRP.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块内部过于复杂**：一个风险是使模块过于复杂。就像任何代码片段一样，如果模块做得太多，管理模块就会变得困难。此外，软件块越大，最初闪亮的设计开始变得混乱的可能性就越大。我们可以通过保持每个模块专注于领域特定的一部分，并应用SRP（单一职责原则）来避免这种情况。'
- en: '**Poorly defined module boundaries:** If the boundaries between modules are
    unclear, it can create problems. For example, if two modules do similar things,
    it can confuse developers and lead to one part of the system depending on the
    wrong module. Another example is when two modules that should be part of the same
    bounded context are separated. In that case, the chances are that the two modules
    will interact a lot with each other, creating chattiness and significantly increasing
    the coupling between them. We avoid this with good planning, domain analysis,
    and ensuring each module has a specific job (SRP).'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块边界定义不明确**：如果模块之间的边界不明确，可能会引起问题。例如，如果两个模块做类似的事情，可能会让开发者困惑，导致系统的一部分依赖于错误的模块。另一个例子是当两个本应属于同一边界上下文的模块被分开时。在这种情况下，两个模块之间可能会大量交互，产生冗余，并显著增加它们之间的耦合度。我们可以通过良好的规划、领域分析和确保每个模块有一个特定的任务（SRP）来避免这种情况。'
- en: '**Scaling:** Even though Modular Monoliths are easier to manage, they carry
    the monolith issues when they must scale up. We must deploy the whole application,
    so we can''t scale modules independently. Moreover, even if modules own their
    data, they probably share one database, which must also be scaled as a whole.
    If scaling the whole system is impossible, we can migrate specific modules to
    microservices. We can also extract in-memory services to distributed ones, like
    using a distributed cache instead of a memory cache, leveraging a cloud-based
    event broker instead of an in-memory one, or even having compute or data-intensive
    modules start using their own database so they partially scale independently.
    However, these solutions make the deployment and the infrastructure more complex,
    gradually moving towards complex infrastructure, which defeats the monolith’s
    benefits.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展性**：尽管模块化单体更容易管理，但当它们需要扩展时，它们仍然携带单体的问题。我们必须部署整个应用程序，因此不能独立扩展模块。此外，即使模块拥有自己的数据，它们可能共享一个数据库，这个数据库也必须作为一个整体进行扩展。如果整个系统的扩展是不可能的，我们可以将特定模块迁移到微服务。我们还可以将内存中的服务提取为分布式服务，例如使用分布式缓存而不是内存缓存，利用基于云的事件代理而不是内存代理，或者让计算密集型或数据密集型模块开始使用它们自己的数据库，这样它们就可以部分独立扩展。然而，这些解决方案使得部署和基础设施变得更加复杂，逐渐向复杂的基础设施转变，这抵消了单体的一些好处。'
- en: '**Eventual consistency:** Keeping data in sync between modules can be challenging.
    We can handle this using event-driven architecture. Using an in-memory message
    broker is low-latency and high-fidelity (no network involved), which is a good
    first step towards learning and dealing with eventual consistency and breaking
    the monolith into microservices (if the transition is ever needed). However, a
    more resilient transport is recommended for production, so the system resists
    to failures, increasing the synchronization latency. You do not have to use events
    if you prefer to remove this complexity; a well-designed relational database can
    do the trick.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：在模块间保持数据同步可能具有挑战性。我们可以通过使用事件驱动架构来处理这个问题。使用内存中的消息代理具有低延迟和高保真度（不涉及网络），这是学习处理最终一致性和将单体拆分为微服务（如果需要过渡）的良好第一步。然而，对于生产环境，建议使用更健壮的传输方式，以便系统能够抵抗故障，增加同步延迟。如果你更喜欢去除这种复杂性，则不需要使用事件；一个设计良好的关系型数据库也能做到这一点。'
- en: '**Transition to microservices:** Moving an application to microservices architecture
    after the fact can be a significant undertaking. However, starting with an event-powered
    Modular Monolith should make the journey less painful.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡到微服务**：在事后将应用程序迁移到微服务架构可能是一项重大任务。然而，从事件驱动的模块化单体开始应该会使这个过程不那么痛苦。'
- en: While Modular Monoliths offer many benefits, they can also pose challenges.
    The key is to plan well, keep things simple, and be ready to adapt as the program
    evolves.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模块化单体提供了许多好处，但它们也可能带来挑战。关键是做好规划，保持简单，并随时准备随着程序的发展而适应。
- en: Conclusion
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we learned about the Modular Monolith architectural style,
    which blends the simplicity of monolithic architectures with the flexibility of
    microservices. This architectural style organizes software applications into distinct,
    loosely coupled modules, each responsible for a specific business capability.
    Unlike microservices, we deploy these modules as a single unit, like a monolith.
    We discussed the benefits of Modular Monoliths, including easier overall management,
    sound development and testing experiences, cost-effectiveness, and a simplified
    deployment model.We saw that a Modular Monolith comprises modules, a module aggregator,
    and an inter-module communication infrastructure—event-driven in this case.We
    learned that analyzing the domain, designing the modules, and identifying the
    interactions between modules before starting the development improves the chances
    of success of the product.We touched on transitioning from a Modular Monolith
    to a microservices architecture, which involves extracting modules into separate
    microservices and rerouting requests.We also highlighted the importance of knowing
    potential challenges and pitfalls. These include module complexity, poorly defined
    module boundaries, scaling limitations, and eventual consistency caused by an
    asynchronous communication model.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们学习了模块化单体架构风格，它将单体架构的简单性与微服务的灵活性相结合。这种架构风格将软件应用程序组织成独立的、松散耦合的模块，每个模块负责特定的业务能力。与微服务不同，我们将这些模块作为一个单一单元部署，就像单体一样。我们讨论了模块化单体的好处，包括更易于整体管理、良好的开发和测试体验、成本效益以及简化的部署模型。我们了解到，模块化单体由模块、模块聚合器和模块间通信基础设施组成——在这种情况下是事件驱动的。我们学习了在开始开发之前分析领域、设计模块和识别模块间交互可以提高产品的成功机会。我们简要提到了从模块化单体过渡到微服务架构，这涉及到将模块提取为单独的微服务并重新路由请求。我们还强调了了解潜在挑战和陷阱的重要性。这些包括模块复杂性、模块边界定义不明确、扩展限制以及由异步通信模型引起的最终一致性。 '
- en: Questions
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: What are the core principles of a Modular Monolith?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块化单体的核心原则是什么？
- en: What are the advantages of Modular Monoliths?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块化单体有哪些优势？
- en: What are traditional Monoliths?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传统单体是什么？
- en: Are poorly defined module boundaries indeed beneficial to a Modular Monolith?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块边界定义不明确真的对模块化单体有益吗？
- en: Is it true that transitioning an application to microservices architecture can
    be a significant undertaking?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序过渡到微服务架构是否真的是一项重大任务？
- en: Further reading
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here is a link to build upon what we learned in the chapter:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个链接，可以基于本章所学的内容进行扩展：
- en: 'Microservices Aggregation (Modular Monolith): [https://adpg.link/zznM](https://adpg.link/zznM)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务聚合（模块化单体）：[https://adpg.link/zznM](https://adpg.link/zznM)
- en: 'When (modular) monolith is the better way to build software: [https://adpg.link/KBGB](https://adpg.link/KBGB)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当（模块化）单体是构建软件的更好方式时：[https://adpg.link/KBGB](https://adpg.link/KBGB)
- en: 'Source code: [https://adpg.link/gyds](https://adpg.link/gyds)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：[https://adpg.link/gyds](https://adpg.link/gyds)
- en: An end is simply a new beginning
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束只是新的开始
- en: This may be the end of the book, but it is also the continuation of your journey
    into software architecture and design. I hope you found this to be a refreshing
    view of design patterns and how to design SOLID apps.Depending on your goals and
    current situation, you may want to explore one or more application-scale design
    patterns in more depth, start your next personal project, start a business, apply
    for a new job, or all of those. No matter your goals, keep in mind that designing
    software is technical but also an art. There is rarely one way to implement a
    feature but multiple acceptable ways. Every decision has trade-offs, and experience
    is your best friend, so keep programming, learn from your mistakes, become better,
    and continue. The path to mastery is a never-ending continuous learning loop.
    Remember that we are all born knowing next to nothing, so not knowing something
    is expected; we need to learn. Please ask questions, read, experiment, learn,
    and share your knowledge with others. Explaining a concept to someone is extremely
    rewarding and reinforces your own learning and knowledge.Now that this book is
    complete, you may find interesting articles on my blog ([https://adpg.link/blog](https://adpg.link/blog)).
    Feel free to reach out on Discord, Twitter `@CarlHugoM` ([https://adpg.link/twit](https://adpg.link/twit)),
    or LinkedIn ([https://adpg.link/edin](https://adpg.link/edin)). I hope you found
    the book educational and approachable and that you learned many things. I wish
    you success in your career.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是这本书的结束，但也是你进入软件架构和设计旅程的延续。希望你觉得这是一个对设计模式和如何设计SOLID应用程序的新鲜视角。根据你的目标和当前情况，你可能想要更深入地探索一个或多个应用规模的设计模式，开始你的下一个个人项目，开始一项业务，申请一份新工作，或者所有这些。无论你的目标是什么，请记住，设计软件既是技术也是艺术。实现一个功能很少只有一种方式，而是有多种可接受的方式。每个决策都有权衡，经验是你的最佳朋友，所以继续编程，从你的错误中学习，变得更好，并继续前进。精通之路是一个永无止境的持续学习循环。记住，我们都是一无所知地出生的，所以不知道某件事是预期的；我们需要学习。请提问，阅读，实验，学习，并将你的知识与他人分享。向某人解释一个概念是非常有回报的，并加强你自己的学习和知识。现在这本书已经完成，你可能会在我的博客上找到有趣的文章（[https://adpg.link/blog](https://adpg.link/blog)）。在Discord、Twitter
    `@CarlHugoM` ([https://adpg.link/twit](https://adpg.link/twit))或LinkedIn ([https://adpg.link/edin](https://adpg.link/edin))上随意联系我。我希望你觉得这本书既教育性强又易于接近，并且学到了很多东西。祝你事业成功。
- en: Answers
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: We must treat each module as a microservice and deploy the application as a
    single unit—a monolith.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将每个模块视为一个微服务，并将应用程序作为一个单一单元——一个单体。
- en: A few moving parts make the application simpler. Each module is independent,
    making modules loosely coupled. Its simple deployment model leads to cost-effective
    hosting and ease of deployment.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几个运动部件使得应用程序更加简单。每个模块都是独立的，使得模块之间松散耦合。其简单的部署模型导致成本效益高且易于部署。
- en: Traditional monolithic architectures build the application as a single, indivisible
    unit, often resulting in tightly coupled functionalities.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传统的单体架构将应用程序构建为一个单一、不可分割的单元，通常会导致功能紧密耦合。
- en: False. Poorly defined module boundaries hinder the health of the application.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。定义不明确的模块边界会阻碍应用程序的健康。
- en: True. Even if a well-conceived Modular Monolith can help, the transition will
    be a journey.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确。即使一个精心设计的模块化单体可以帮助，过渡也将是一个旅程。
