- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Building a Real-Time Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建实时游戏
- en: In this chapter, we will build a multi-player, head-to-head game app with real-time
    communication. In the app, you will be able to connect to a game server and view
    a list of other players that are also connected. You can then select a player
    to request a game with them and, provided they accept, play a game of *Sticks
    & Stones*. We will look at how we can use SignalR to implement a real-time connection
    with the server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个支持多人、面对面实时通讯的游戏应用。在应用中，您将能够连接到游戏服务器并查看其他已连接玩家的列表。然后，您可以选择一个玩家请求与他们玩游戏，如果他们接受，就可以玩一场*棍棒与石头*游戏。我们将探讨如何使用SignalR实现与服务器的实时连接。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to use SignalR in a .NET MAUI app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在.NET MAUI应用中使用SignalR
- en: How to use control templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用控件模板
- en: How to use XAML triggers to update the interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用XAML触发器更新界面
- en: How to use XAML styling in a .NET MAUI app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在.NET MAUI应用中使用XAML样式
- en: Let’s get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before you start building the app for this project, you need to build the backend
    that we detailed in *Chapter 9*, *Setting Up a Backend for a Game Using Azure
    Services*. You will also need to have Visual Studio for Mac or PC installed, as
    well as the .NET MAUI components. See *Chapter 1*, *Introduction to .NET MAUI*,
    for more details on how to set up your environment. The source code for this chapter
    is available in this book’s GitHub repository: [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建此项目的应用之前，您需要构建我们在*第9章*中详细说明的后端，即*使用Azure服务设置游戏后端*。您还需要安装Visual Studio for
    Mac或PC，以及.NET MAUI组件。有关如何设置环境的更多详细信息，请参阅*第1章*，*.NET MAUI简介*。本章的源代码可在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main)。
- en: Project overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: When building a head-to-head game app, it is really important to have real-time
    communication because the user expects the other players’ moves to arrive more
    or less immediately. To achieve this, we will use SignalR, which is a library
    for real-time communication. SignalR will use WebSockets if they are available
    and, if not, it will have several fallback options it can use instead. In the
    app, we will use SignalR to send updates on player and game status through the
    Azure Functions that we built in *Chapter 9*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个面对面游戏应用时，拥有实时通讯功能非常重要，因为用户期望其他玩家的动作能够尽可能快地到达。为了实现这一点，我们将使用SignalR，这是一个用于实时通讯的库。如果WebSocket可用，SignalR将使用WebSocket，如果不可用，它将提供几个备选方案。在应用中，我们将使用SignalR通过我们在*第9章*中构建的Azure
    Functions发送玩家和游戏状态更新。
- en: The build time for this project is about 180 minutes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的构建时间大约为180分钟。
- en: Getting started
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: We can use either Visual Studio on a PC or Mac to complete this project. To
    build an iOS app using Visual Studio for PC, you have to have a Mac connected.
    If you don’t have access to a Mac at all, you can choose to just build the Android
    part of the app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PC上的Visual Studio或Mac来完成这个项目。要使用PC上的Visual Studio构建iOS应用，您必须连接一台Mac。如果您根本无法访问Mac，您可以选择只构建应用的Android部分。
- en: Let’s review from *Chapter 9* what the game is all about.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*第9章*回顾一下游戏的主要内容。
- en: An overview of the game
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏概述
- en: '*Sticks & Stones* is a turn-based social game based on the concepts of two
    childhood games mashed into one, Dots and Boxes ([https://en.wikipedia.org/wiki/Dots_and_boxes](https://en.wikipedia.org/wiki/Dots_and_boxes))
    and Tic-Tac-Toe ([https://en.wikipedia.org/wiki/Tic-tac-toe](https://en.wikipedia.org/wiki/Tic-tac-toe)).
    The game board is laid out in a three-by-three grid. Each player will take a turn
    placing a stick along the side of a box, between two dots, to earn one point.
    If a stick completes a box, then the player takes ownership of the box, earning
    five points. The game is won when a player owns three boxes in a row, horizontally,
    vertically, or diagonally. If no player can own three boxes in a row, the winner
    of the game is determined by the player with the highest score.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*棍与石*是一款基于两个童年游戏概念结合而成的回合制社交游戏，即点与框（[https://en.wikipedia.org/wiki/Dots_and_boxes](https://en.wikipedia.org/wiki/Dots_and_boxes)）和井字棋（[https://en.wikipedia.org/wiki/Tic-tac-toe](https://en.wikipedia.org/wiki/Tic-tac-toe)）的概念。游戏板以三乘三的网格布局。每位玩家将轮流在方框的旁边、两个点之间放置一根棍子，以获得一分。如果一根棍子完成了一个方框，那么该玩家将获得该方框的所有权，获得五分。当玩家在一条水平、垂直或对角线上拥有三个方框时，游戏获胜。如果没有任何玩家能够连续拥有三个方框，则游戏获胜者由得分最高的玩家决定。'
- en: To keep the app and the service side relatively simple, we will eliminate a
    lot of state management. When the player opens the app, they will have to connect
    to the game service. They will have to provide a gamer tag, or username, and an
    email address. Optionally, they can upload a picture of themselves to use as a
    profile picture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用和服务端相对简单，我们将消除大量的状态管理。当玩家打开应用时，他们需要连接到游戏服务。他们需要提供一个游戏标签、用户名或电子邮件地址。可选地，他们可以上传自己的照片作为头像。
- en: Once connected, the player will then see a list of all the other players connected
    to the same game service; this is called the Lobby. The player’s status of either
    **Ready to play** or **In a match** is displayed along with the player’s gamer
    tag and profile picture. If the player is not in a match, a button is available
    to challenge the player to a match.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，玩家将看到所有连接到同一游戏服务的其他玩家的列表；这被称为大厅。玩家的状态（**准备游戏**或**正在比赛中**）将与玩家的游戏标签和头像一起显示。如果玩家不在比赛中，将有一个按钮可供挑战其他玩家进行比赛。
- en: Challenging a player to a match will cause the app to prompt the opponent to
    respond to the challenge, either accept or decline it. If the opponent accepts
    the challenge, then both players are navigated to a new game board where the player
    who received the challenge will have the first turn. Both players’ statuses will
    update to **In a match** in all the other players’ lobbies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 向玩家发起比赛邀请会导致应用提示对手回应挑战，无论是接受还是拒绝。如果对手接受挑战，那么两位玩家将被导航到一个新的游戏板，接受挑战的玩家将先走一步。所有其他玩家的大厅中，两位玩家的状态都将更新为**正在比赛中**。
- en: Play will alternate between players as they choose a location to place a single
    stick. Each time a stick is placed by a player, the game board and score will
    update on both players’ devices. When a stick is placed that completes one or
    more squares, the player then wins that square, and a pile of stones is placed
    in the center of the square. When all sticks have been placed, or a player owns
    three stones in a row, the game is over, the players navigate back to the Lobby,
    and their status is updated to “Ready to play.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家们将轮流选择放置一根棍子的位置。每次玩家放置一根棍子，游戏板和分数将在两位玩家的设备上更新。当放置的棍子完成一个或多个方格时，该玩家赢得该方格，并在方格中心放置一堆石头。当所有棍子都放置完毕，或者某个玩家在一条直线上拥有三颗石头时，游戏结束，玩家们将被导航回大厅，他们的状态更新为“准备游戏”。
- en: If a player leaves the app during a game, then they will have forfeited the
    match and the remaining opponent will be credited with the win and navigated back
    to the Lobby.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在游戏中离开应用，那么他们将放弃比赛，剩余的对手将被计入胜利，并导航回大厅。
- en: Now that we understand what we want to build, let’s get down to the details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了我们想要构建的内容，那么让我们深入细节。
- en: We recommend that you use the same solution we used in *Chapter 9*, *Setting
    Up a Backend for a Game Using Azure Services*, because this will make code sharing
    easier. If you don’t want to go through all of *Chapter 9*, you can get the completed
    source from *Chapter 9**,* at [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用我们在 *第 9 章*，*使用 Azure 服务设置游戏后端* 中使用的相同解决方案，因为这会使代码共享更容易。如果您不想阅读 *第 9
    章* 的全部内容，您可以从 *第 9 章* 中获取完成的源代码，[https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main)。
- en: 'We will build this app in four sections:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分四个部分来构建这个应用程序：
- en: '**Services** – All the classes that are needed to connect and interact with
    the Azure Functions backend that was built in *Chapter 9*, *Setting Up a Backend
    for a Game Using* *Azure Services*.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务** – 所需的所有类，用于连接并与在 *第 9 章*，*使用 Azure 服务设置游戏后端* 中构建的 Azure 函数后端进行交互。'
- en: '**Connect page** – This will consist of the view and view model needed to allow
    a user to connect to the game server as a player.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接页面** – 这将包括允许用户作为玩家连接到游戏服务器的视图和视图模型。'
- en: '**Lobby page** – The Lobby is where the player can send and receive challenges
    with other players. In this section, we will build the view and view model for
    the lobby.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大厅页面** – 大厅是玩家可以与其他玩家发送和接收挑战的地方。在本节中，我们将构建大厅的视图和视图模型。'
- en: '**Game page** – This is where players can take turns playing a game of *Sticks
    and Stones*. In this section, we will build the view and view model needed to
    make that happen.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏页面** – 这是玩家可以轮流玩 *棍子和石头* 游戏的地方。在本节中，我们将构建实现这一功能的视图和视图模型。'
- en: Let’s start by creating the project for the .NET MAUI app.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建 .NET MAUI 应用程序的项目。
- en: Building the game app
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏应用程序
- en: 'It’s time to start building the app. Open the `SticksAndStones` solution from
    the previous chapter and follow these steps to create the project:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建应用程序了。从上一章打开 `SticksAndStones` 解决方案，按照以下步骤创建项目：
- en: 'Open the **Create a new project** wizard by selecting **File**, **Add**, then
    **New Project…** from the Visual Studio menu:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 Visual Studio 菜单中的 **文件**，**添加**，然后 **新建项目…** 来打开 **创建新项目** 向导：
- en: '![Figure 10.1 – File | Add | New Project…](img/B19214_10_1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 文件 | 添加 | 新项目…](img/B19214_10_1.jpg)'
- en: Figure 10.1 – File | Add | New Project…
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 文件 | 添加 | 新项目…
- en: 'In the search field, type `maui` and select the **.NET MAUI App** item from
    the list, or select it from **Recent project templates** if it is listed:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 `maui` 并从列表中选择 **.NET MAUI 应用** 项，或者如果列出，从 **最近的项目模板** 中选择它：
- en: "![Figure 10.2 – Create a new p\uFEFFroject](img/B19214_10_2.jpg)"
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 创建新项目](img/B19214_10_2.jpg)'
- en: Figure 10.2 – Create a new project
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 创建新项目
- en: Click **Next**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'Enter `SticksAndStones.App` as the name of the app and, under **Solution**,
    select **Add to solution**, as shown in the following screenshot:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序名称输入为 `SticksAndStones.App`，并在 **解决方案** 下选择 **添加到解决方案**，如图下所示：
- en: '![Figure 10.3 – Configure your new project](img/B19214_10_3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 配置您的新的项目](img/B19214_10_3.jpg)'
- en: Figure 10.3 – Configure your new project
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 配置您的新的项目
- en: Click **Next**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'The last step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For the purposes of this book, we
    will assume that you will be using .NET 7:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将提示您选择支持 .NET Core 的版本。在撰写本文时，.NET 6 可用为 **长期支持**（**LTS**），.NET 7 可用为 **标准期限支持**。为了本书的目的，我们假设您将使用
    .NET 7：
- en: '![Figure 10.4 – Additional information](img/B19214_10_4.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 补充信息](img/B19214_10_4.jpg)'
- en: Figure 10.4 – Additional information
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 补充信息
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **创建** 完成设置，并等待 Visual Studio 创建项目。
- en: 'Now we have created the .NET MAUI project for our game screens, let’s configure
    it so that it’s ready to add the services and views. We will need to add a project
    reference to the `SticksAndStones.Shared` project, as well as a few NuGet packages.
    Follow these steps to complete the setup of the `SticksAndStones.App` project:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的游戏屏幕创建了 .NET MAUI 项目，让我们配置它，以便它可以添加服务和视图。我们需要将 `SticksAndStones.Shared`
    项目添加为项目引用，以及一些 NuGet 包。按照以下步骤完成 `SticksAndStones.App` 项目的设置：
- en: Right-click the `SticksAndStones.App` project in **Solution Explorer** and select
    **Properties**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **Solution Explorer** 中的 `SticksAndStones.App` 项目，并选择 **Properties**。
- en: In the `Default namespace`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Default namespace` 中。
- en: Change the `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`。
- en: This will split the project name on `"."`, using only the first part and replacing
    any spaces with underscores.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将根据 `"."` 分割项目名称，仅使用第一部分，并将任何空格替换为下划线。
- en: Add a NuGet Package reference to `CommunityToolkit.Mvvm` as, in other chapters,
    we will be using this package to simplify the implementation of data bindings
    to properties and commands.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 NuGet 包引用添加到 `CommunityToolkit.Mvvm`，因为在其他章节中，我们将使用此包来简化数据绑定到属性和命令的实现。
- en: Add a NuGet Package reference to `CommunityToolkit.Maui`. We will be using the
    `GravatarImageSource` class from this package to render an avatar for the user.
    For .NET 7, you will need to use version 6.1.0 of the NuGet package. 7.0+ has
    .NET 8 as a dependency.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 NuGet 包引用添加到 `CommunityToolkit.Maui`。我们将使用此包中的 `GravatarImageSource` 类来渲染用户的头像。对于
    .NET 7，您需要使用 NuGet 包的 6.1.0 版本。7.0+ 版本以 .NET 8 为依赖项。
- en: 'Open the `MauiProgram.cs` file and add the highlighted line shown here:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 文件，并添加此处显示的突出显示行：
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will configure `CommunityToolkit` for use within the app.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为应用程序内的 `CommunityToolkit` 配置。
- en: Add a NuGet package reference to `Microsoft.Extensions.Logging.Abstractions`.
    This package is used to log messages from the Azure Functions functions for debugging.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 NuGet 包引用添加到 `Microsoft.Extensions.Logging.Abstractions`。此包用于记录 Azure Functions
    函数的消息以进行调试。
- en: Add a NuGet package reference to `Microsoft.Extensions.Logging.Debugging`. This
    package is used to log messages from the Azure Functions functions for debugging.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 NuGet 包引用添加到 `Microsoft.Extensions.Logging.Debugging`。此包用于记录 Azure Functions
    函数的消息以进行调试。
- en: Add a NuGet package reference to `Microsoft.AspNetCore.SignalR.Client`. This
    package is required for the app to connect to the SignalR Hub we created in *Chapter
    9* and receive messages.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 NuGet 包引用添加到 `Microsoft.AspNetCore.SignalR.Client`。此包对于应用程序连接到我们在第 9 章中创建的
    SignalR Hub 并接收消息是必需的。
- en: Add a Project reference to the `SticksAndStones.Shared` project. This will give
    us access to the messages and objects we created in *Chapter 9*.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目引用添加到 `SticksAndStones.Shared` 项目。这将使我们能够访问在第 9 章中创建的消息和对象。
- en: That’s it for project creation. Next, we will start with creating classes that
    interact directly with our service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建到此结束。接下来，我们将开始创建与我们的服务直接交互的类。
- en: Creating the game services
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏服务
- en: 'The first thing we will do is create a service that will be used to communicate
    with the Azure Functions functions service created in *Chapter 9*, *Setting Up
    a Backend for a Game Using Azure Services*. The service will be broken down into
    three main classes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个服务，该服务将用于与在第 9 章中创建的 Azure Functions 函数服务进行通信，即使用 Azure 服务设置游戏后端。该服务将分为三个主要类：
- en: '`GameService` – Methods and properties for calling the Azure Functions and
    receiving SignalR messages.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameService` – 用于调用 Azure Functions 和接收 SignalR 消息的方法和属性。'
- en: '`ServiceConnection` – Holds the references to `HttpClient` and SignalR Hub
    instances. Also provides methods for safely making calls using `HttpClient`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceConnection` – 包含对 `HttpClient` 和 SignalR Hub 实例的引用。同时提供用于安全调用 `HttpClient`
    的方法。'
- en: '`Settings` – Stores and retrieves the URL for the server used by `HttpClient`.
    It also stores the connection details provided by the user.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Settings` – 存储和检索 `HttpClient` 所使用的服务器 URL。它还存储用户提供的连接详细信息。'
- en: We will start with the `Settings` class since both `GameService` and `ServiceConnection`
    will depend on `Settings`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `Settings` 类开始，因为 `GameService` 和 `ServiceConnection` 都将依赖于 `Settings`。
- en: Creating the Settings service
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Settings 服务
- en: 'The `Settings` service is used to store values that are needed between app
    runs. It will use the .NET MAUI `Preferences` class to store these values in a
    cross-platform manner. Use the following steps to implement the `Settings` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Settings` 服务用于存储应用程序运行之间所需的价值。它将使用 .NET MAUI 的 `Preferences` 类以跨平台方式存储这些值。使用以下步骤实现
    `Settings` 类：'
- en: In the `SticksAndStones.App` project, create a new folder named `Services`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目中，创建一个名为 `Services` 的新文件夹。
- en: In the newly created `Services` folder, create a new class named `Settings`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的 `Services` 文件夹中，创建一个名为 `Settings` 的新类。
- en: Make the class public.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类设置为公共。
- en: 'Create a `const string` field named `LastPlayerKey` and initialize it like
    so:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `LastPlayerKey` 的 `const string` 字段，并按如下方式初始化：
- en: '[PRE1]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a `const string` field named `ServerUrlKey` and initialize it like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ServerUrlKey` 的 `const string` 字段，并按如下方式初始化：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two fields are used by the .NET MAUI `Preferences` class to store the
    values for the server URL and the login details for the last time the user logged
    in.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个字段被 .NET MAUI 的 `Preferences` 类用来存储服务器 URL 和用户上次登录的登录详情。
- en: 'Add a `private const string` field named `ServerUrlDefault` as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `ServerUrlDefault` 的 `private const string` 字段，如下所示：
- en: '[PRE3]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You may need to adjust the port number, highlighted in the preceding listing,
    for your specific development environment. Azure Functions will display the server
    URL when started from Visual Studio, as shown in the following screenshot:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能需要调整前面列表中突出显示的端口号，以适应你特定的开发环境。Azure Functions 将在从 Visual Studio 启动时显示服务器
    URL，如下面的屏幕截图所示：
- en: '![Figure 10.5 – Azure Functions console output](img/B19214_10_5.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – Azure Functions 控制台输出](img/B19214_10_5.jpg)'
- en: Figure 10.5 – Azure Functions console output
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – Azure Functions 控制台输出
- en: Using the Azure Functions hosted in Azure
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用托管在 Azure 中的 Azure Functions
- en: If you followed the steps in the *Chapter 9* section called *Deploying the functions
    to Azure*, then you can use the URL for the Azure Function App created in *Chapter
    9*, in the *Creating the Azure service for functions* section. The URL is displayed
    on the **Overview** tab of the Azure Functions App.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了 *第 9 章* 部分中名为 *将函数部署到 Azure* 的步骤，那么你可以在 *创建函数的 Azure 服务* 部分中使用 *第 9 章*
    中创建的 Azure Function App 的 URL。该 URL 显示在 Azure Functions App 的 **概览** 选项卡上。
- en: 'Now, add a `public string` property named `ServerUrl` with the following implementation:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为 `ServerUrl` 的 `public string` 属性，其实现如下：
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code will get the server URL from the `Preferences` store if it is present;
    if not, it will use the `serverUrlDefault` value. The property will store the
    new value in the `Preferences` store.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果存在，此代码将从 `Preferences` 存储中获取服务器 URL；如果不存在，它将使用 `serverUrlDefault` 值。该属性将在
    `Preferences` 存储中存储新值。
- en: 'Add the following `using` declarations at the top of the `Settings.cs` file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Settings.cs` 文件的顶部添加以下 `using` 声明：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will enable us to use our model and the `JsonSerializer` classes.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使我们能够使用我们的模型和 `JsonSerializer` 类。
- en: 'Create a new property named `LastPlayer` that is of the `Player` type, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `LastPlayer` 的新属性，其类型为 `Player`，如下所示：
- en: '[PRE6]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the property `set` method will convert the `Player` object to a `Json`
    string before storing it in `Preferences` and, when getting the property, if it
    exists in the `Preferences` store, convert the stored `Json` to a `Player` object.
    If there is no value in the `Preferences` store, then the `get` method will return
    an empty `Player` object.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，属性的 `set` 方法将在将 `Player` 对象存储在 `Preferences` 之前将其转换为 `Json` 字符串，在获取属性时，如果它在
    `Preferences` 存储中存在，则将存储的 `Json` 转换为 `Player` 对象。如果没有在 `Preferences` 存储中找到值，则
    `get` 方法将返回一个空的 `Player` 对象。
- en: 'The final step for the `Settings` class is to register it with the dependency
    injection container. Open the `MauiProgram.cs` file in the `SticksAndStones.App`
    project, then add the following highlighted code to the `CreateMauiApp` method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Settings` 类的最终步骤是将它注册到依赖注入容器中。打开 `SticksAndStones.App` 项目的 `MauiProgram.cs`
    文件，然后在 `CreateMauiApp` 方法中添加以下突出显示的代码：'
- en: '[PRE7]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the `Settings` class complete, we can now focus on the `ServiceConnection`
    class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `Settings` 类的完成，我们现在可以专注于 `ServiceConnection` 类。
- en: Creating the ServiceConnection class
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 ServiceConnection 类
- en: The `ServiceConnection` class encapsulates the functionality needed to communicate
    with the Azure Functions service. It has methods to call the function methods
    and return the results, with appropriate error handling. It is also responsible
    for initializing the SignalR Hub instance that is used for real-time communication.
    The `ServiceConnection` class has a couple of dependencies that we need, so let’s
    put them together first.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceConnection` 类封装了与 Azure Functions 服务通信所需的功能。它具有调用函数方法并返回结果的方法，并具有适当的错误处理。它还负责初始化用于实时通信的
    SignalR Hub 实例。`ServiceConnection` 类有几个我们需要的依赖项，所以让我们先放在一起。'
- en: 'The first thing to add is logging. Having logging during debugging can be very
    helpful in figuring out problems, especially when dealing with asynchronous processes.
    Communicating with Azure Functions will have a lot of asynchronous operations.
    To enable logging while debugging, add the highlighted code to the `CreateMauiApp`
    method in the `MauiProgram` class in the `SticksAndStones.App` project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要添加的是日志。在调试期间有日志可以帮助找出问题，尤其是在处理异步过程时。与Azure Functions通信将涉及大量的异步操作。为了在调试时启用日志记录，将高亮代码添加到`SticksAndStones.App`项目中的`MauiProgram`类的`CreateMauiApp`方法：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will add an instance of `ILoggingProvider` to the services container. The
    `ILoggerProvider` instance will provide instances of `ILogger<T>`. This will enable
    the use of `ILogger<T>` as a dependency in the `ServiceConnection` class constructor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在服务容器中添加一个`ILoggingProvider`实例。`ILoggerProvider`实例将提供`ILogger<T>`实例。这将使`ILogger<T>`能够在`ServiceConnection`类构造函数中作为依赖项使用。
- en: More on logging providers
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于日志提供者的信息
- en: Read more about how logging providers work, and logging in general, at [https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers)了解更多关于日志提供者如何工作以及日志的一般信息。
- en: Now, when making requests to APIs using HTTP, it is a common and good practice
    to use asynchronous calls so that you do not block the main or UI thread. All
    UI updates, such as animation, button clicks, taps on the screen, or text changes,
    happen on the UI thread. HTTP calls can take a non-trivial amount of time to complete,
    which can cause the app to become unresponsive to a user.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当使用HTTP向API发出请求时，使用异步调用是一种常见且良好的做法，这样就不会阻塞主线程或UI线程。所有UI更新，如动画、按钮点击、屏幕上的轻触或文本更改，都发生在UI线程上。HTTP调用可能需要相当长的时间才能完成，这可能导致应用程序对用户无响应。
- en: 'Error handling in asynchronous programming can be difficult. To help with errors
    when making API calls, we are going to use a couple of classes to encapsulate
    the exceptions; these classes are `AsyncError` and `AsyncExceptionError`. We need
    `AsyncError` and `AsyncExceptionError` because it is a bad practice to serialize
    and deserialize any class instances that derive from `System.Exception`. Not all
    classes derived from `System.Exception` are serializable, and even if they are,
    you may not be able to deserialize them due to a missing type – for example, the
    type is available on the server but not on the client. Create a new file named
    `AsyncError.cs` in the `SticksAndStones.App` project and replace the contents
    with the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程中的错误处理可能很困难。为了帮助在调用API时处理错误，我们将使用几个类来封装异常；这些类是`AsyncError`和`AsyncExceptionError`。我们需要`AsyncError`和`AsyncExceptionError`，因为将任何从`System.Exception`派生的类实例序列化和反序列化都是一种不好的做法。并非所有从`System.Exception`派生的类都是可序列化的，即使它们是可序列化的，也可能由于缺少类型而无法反序列化——例如，类型在服务器上可用但在客户端不可用。在`SticksAndStones.App`项目中创建一个名为`AsyncError.cs`的新文件，并用以下代码替换其内容：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `AsyncError` class has a single property, `Message`. The `Message` property
    is decorated with the `JsonPropertyName` attribute so that it can be serialized
    if needed, using a lowercase version of the property name. `AsyncExceptionError`
    inherits from `AsyncError` and adds an additional property, `InnerException`.
    The `InnerException` property is also attributed with `JsonPropertyName`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncError`类有一个单独的属性`Message`。`Message`属性被`JsonPropertyName`属性装饰，以便在需要时可以序列化，使用属性名的小写版本。`AsyncExceptionError`从`AsyncError`继承并添加了一个额外的属性`InnerException`。`InnerException`属性也被`JsonPropertyName`属性装饰。'
- en: 'The last class we will need is `AsyncLazy<T>`. You may have already used `Lazy<T>`
    in other applications you have written. It’s very handy when you want to delay
    the creation of a class until right before you need it. If you never need it,
    it doesn’t get created. But `Lazy<T>` does not work great with asynchronous programming,
    so if you wanted to lazy instantiate a class that is created asynchronously, that
    becomes tedious. Luckily for us, Stephen Toub, who works for Microsoft on the
    .NET team, created `AsyncLazy<T>`. To add it to the `SticksAndStones.App` project,
    create a new file named `AsyncLazy~1.cs` and replace the contents with the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要最后一个类 `AsyncLazy<T>`。你可能已经在你编写的一些其他应用程序中使用了 `Lazy<T>`。当你想要延迟创建一个类直到你真正需要它时，它非常方便。如果你永远不需要它，它就不会被创建。但是
    `Lazy<T>` 与异步编程不太兼容，所以如果你想要异步创建一个类，这会变得很繁琐。幸运的是，Stephen Toub，他在微软的 .NET 团队工作，创建了
    `AsyncLazy<T>`。要将它添加到 `SticksAndStones.App` 项目中，创建一个名为 `AsyncLazy~1.cs` 的新文件，并用以下内容替换其内容：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Learn more about AsyncLazy<T>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 AsyncLazy<T>
- en: 'Visit the .NET blog to learn more about how Stephen Toub created the `AsyncLazy<T>`
    class: [https://devblogs.microsoft.com/pfxteam/asynclazyt/](https://devblogs.microsoft.com/pfxteam/asynclazyt/).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 .NET 博客了解更多关于 Stephen Toub 创建 `AsyncLazy<T>` 类的信息：[https://devblogs.microsoft.com/pfxteam/asynclazyt/](https://devblogs.microsoft.com/pfxteam/asynclazyt/)。
- en: 'That completes the changes needed to start implementing the `ServiceConnection`
    class. To create the class, follow these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了开始实现 `ServiceConnection` 类所需的所有更改。要创建该类，请按照以下步骤操作：
- en: Create a new class named `ServiceConnection` in the `SticksAndStones.App` project
    in the `Services` folder.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `Services` 文件夹中创建一个名为 `ServiceConnection` 的新类。
- en: 'Change the class to `public sealed` and inherit from `IDisposable`:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '将类改为 `public sealed` 并继承自 `IDisposable`:'
- en: '[PRE11]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Modify the namespace declarations at the top of the file to the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件顶部的命名空间声明修改为以下内容：
- en: '[PRE12]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are needed to reference the types needed in the following steps.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是在以下步骤中需要的，以引用所需的类型。
- en: 'Add the following `private` fields to the class:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下 `private` 字段：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `serializerOptions` is used to make sure the JSON that is sent and received
    from the Azure Functions functions can be serialized and deserialized properly.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`serializerOptions` 用于确保从 Azure Functions 函数发送和接收的 JSON 可以正确地序列化和反序列化。'
- en: 'Now, add a `public` property named `Hub`. The type for `Hub` is `AsyncLazy<HubConnection>`.
    `HubConnection` is the type from the SignalR client library that is used to receive
    messages from the SignalR service. The property should look like the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为 `Hub` 的 `public` 属性。`Hub` 的类型为 `AsyncLazy<HubConnection>`。`HubConnection`
    是来自 SignalR 客户端库的类型，用于从 SignalR 服务接收消息。该属性应如下所示：
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`HubConnection` is initialized in the `ConnectHub` method. But first, let’s
    add the constructor.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HubConnection` 在 `ConnectHub` 方法中初始化。但首先，让我们添加构造函数。'
- en: 'The constructor for the `ServiceConnection` class has two parameters: `ILogger`
    **<ServiceConnection>** and a `Settings` parameter. In the body of the constructor,
    the `private` fields created in *step 3* are initialized as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ServiceConnection` 类的构造函数有两个参数：`ILogger<ServiceConnection>` 和一个 `Settings`
    参数。在构造函数的主体中，初始化在 *步骤 3* 中创建的 `private` 字段如下：'
- en: '[PRE15]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `logger` and `settings` parameters are provided by the .NET MAUI dependency
    injection service. The `httpClient` field is initialized and it’s `BaseAddress`
    is assigned the settings `ServerUrl` property as a URI. Then, `DefaultHeaders`
    is modified to indicate to the server that the results are expected to be in JSON
    format. The `serializerOptions` instance is initialized to the defaults for `Web`,
    which is consistent with the formatting used by Azure Functions. Finally, the
    `log` field is initialized with the `logger` parameter value.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`logger` 和 `settings` 参数由 .NET MAUI 依赖注入服务提供。`httpClient` 字段被初始化，并且它的 `BaseAddress`
    被分配为设置 `ServerUrl` 属性作为 URI。然后，`DefaultHeaders` 被修改以指示服务器期望结果以 JSON 格式返回。`serializerOptions`
    实例被初始化为 `Web` 的默认值，这与 Azure Functions 使用的格式一致。最后，`log` 字段被初始化为 `logger` 参数的值。'
- en: 'Now, let’s implement the `Dispose` method. It will clean up any values that
    will potentially hold on to any native resources, such as networks, file handles,
    and so on. The two values that this class has references to that need to be disposed
    of are `httpClient` and `Hub`. Note that we will not have to call `Dispose` ourselves
    as the .NET MAUI dependency injection system will do that. Add the following code
    to the `ServiceConnection` class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现`Dispose`方法。它将清理任何可能持有任何原生资源的值，例如网络、文件句柄等。这个类中需要释放引用的两个值是`httpClient`和`Hub`。请注意，我们不需要自己调用`Dispose`，因为.NET
    MAUI依赖注入系统会为我们完成这个操作。将以下代码添加到`ServiceConnection`类中：
- en: '[PRE16]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, add the class to dependency injection by adding the following highlighted
    line of code to the `MauiProgram.cs` file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将以下高亮显示的代码行添加到`MauiProgram.cs`文件中，将类添加到依赖注入中：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Initializing the `Hub` property will happen in the `ConnectHub` method. The
    configuration for the SignalR SignalR Hub connection is returned to the app in
    the `Connect` function result. Since we haven’t and won’t make that call before
    this class is constructed, we can’t create the `Hub` in the constructor. The configuration
    is needed before you can initialize the `Hub` instance. The `ConnectHub` method
    has a single parameter of `ConnectionInfo`. Add the method using the following
    code snippet:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Hub`属性的初始化将在`ConnectHub`方法中发生。SignalR Hub连接的配置作为`Connect`函数的结果返回给应用程序。由于我们在这个类构造之前没有也不会调用那个方法，所以我们不能在构造函数中创建`Hub`。在初始化`Hub`实例之前需要配置。`ConnectHub`方法有一个名为`ConnectionInfo`的单个参数。使用以下代码片段添加该方法：'
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method initializes the `Hub` property to a new `AsyncLazy<HubConnection>`
    instance. The constructor for `AsyncLazy<T>` takes `Func<T>`, which is provided
    using the anonymous method syntax. The anonymous method is also decorated as an
    `async` method, meaning that it will contain an awaited method call. The anonymous
    method takes no parameters and, in the body, starts by creating a new `HubConnectionBuilder`.
    Then, the `WithUrl` extension method is called on `HubConnectionBuilder` to set
    the URL for the SignalR service and provide the `AccessToken` value needed to
    make the connection. `AccessTokenProvider` is a `Task<string>` so the `config.AccessToken`
    is provided through another `async` anonymous function. The `WithAutomaticReconnect`
    method sets `HubConnection` instance to automatically try reconnecting the SignalR
    service if the connection is lost. If `WithAutomaticReconnect` isn’t called, then
    the app is responsible for reconnecting if the connection is lost. The `HubConnection`
    instance is created by calling `HubConnectionBuilder.Build`. The `Hub` instance
    is then started with `StartAsync`, which is awaited, and then the `Hub` is returned.
    The thing to remember here is that when `ConnectHub` is called, the anonymous
    function isn’t executed. The method won’t be called until the first time a property
    or method of the `Hub` property is accessed.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将`Hub`属性初始化为一个新的`AsyncLazy<HubConnection>`实例。`AsyncLazy<T>`的构造函数接受`Func<T>`，它通过匿名方法语法提供。匿名方法也被标记为`async`方法，这意味着它将包含一个等待的方法调用。匿名方法不接受任何参数，在方法体中，首先创建一个新的`HubConnectionBuilder`。然后，在`HubConnectionBuilder`上调用`WithUrl`扩展方法来设置SignalR服务的URL并提供建立连接所需的`AccessToken`值。`AccessTokenProvider`是`Task<string>`，因此`config.AccessToken`通过另一个`async`匿名函数提供。`WithAutomaticReconnect`方法将`HubConnection`实例设置为在连接丢失时自动尝试重新连接SignalR服务。如果没有调用`WithAutomaticReconnect`，则当连接丢失时，应用程序负责重新连接。通过调用`HubConnectionBuilder.Build`创建`HubConnection`实例。然后，通过`StartAsync`启动`Hub`实例，这是等待的，然后返回`Hub`。这里要记住的是，当调用`ConnectHub`时，匿名函数不会执行。该方法只有在第一次访问`Hub`属性的一个属性或方法时才会被调用。
- en: 'The `ServiceConnection` class contains two helper functions that are used from
    the `GameService` class to make HTTP requests to the Azure Functions service.
    The first, `GetAsync<T>`, takes two parameters: a URL and a dictionary of query
    parameters to pass along with the URL. It returns an instance, `T`, and `AsyncError`
    as a `Tuple`. The `GetAsync` method will use the `GET` HTTP method when making
    the HTTP request. The other helper method, `PostAsync<T>`, uses the `POST` HTTP
    method and accepts two parameters: a URL, and an object to send in the body of
    the request formatted as JSON. It will return an instance of `T` from the response.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceConnection` 类包含两个辅助函数，这些函数从 `GameService` 类中使用，以向 Azure Functions 服务发送
    HTTP 请求。第一个是 `GetAsync<T>`，它接受两个参数：一个 URL 和一个字典，该字典包含要随 URL 一起传递的查询参数。它返回一个 `T`
    实例和 `AsyncError` 作为 `Tuple`。`GetAsync` 方法在发起 HTTP 请求时将使用 `GET` HTTP 方法。另一个辅助方法是
    `PostAsync<T>`，它使用 `POST` HTTP 方法，并接受两个参数：一个 URL 和一个对象，该对象作为请求体中的 JSON 格式发送。它将从响应中返回
    `T` 的一个实例。'
- en: '`The` `GetAsync<T>` and `PostAsync<T>` use a couple of helper methods; use
    the following code snippet to add them to the `ServiceConnection` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAsync<T>` 和 `PostAsync<T>` 使用几个辅助方法；使用以下代码片段将它们添加到 `ServiceConnection`
    类中：'
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `GetUriBuilder` method will return a new `UriBuilder` from the provided
    URL and `Dictionary` of key-value pairs to use in the query string. The `GetError`
    method will return either an `AsyncError` object or `AsyncExceptionError` object
    based on the status code or the contents of the response from the HTTP method
    call.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetUriBuilder` 方法将返回一个新的 `UriBuilder`，该 `UriBuilder` 从提供的 URL 和键值对 `Dictionary`
    中获取，用于查询字符串。`GetError` 方法将根据状态码或 HTTP 方法调用响应的内容返回 `AsyncError` 对象或 `AsyncExceptionError`
    对象。'
- en: 'Now, we can add the `GetAsync<T>` method to the `ServiceConnection` class using
    the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码将 `GetAsync<T>` 方法添加到 `ServiceConnection` 类中：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While this method is a little long, what it is doing is not all that complicated.
    First, it uses the `GetUriBuilder` method to create the `UriBuilder` instance
    and build the `fullUri` string value from that. Then, it makes an HTTP `GET` call
    using `the HttpClient` instance to the URL. If there is any failure, the exception
    handler will catch it and return an `AsynExceptionError`. If there are no errors
    in making the request and the response code indicates success, then the result
    is processed and returned. Otherwise, the result content is read for an error,
    and if it is found, it is returned. When the `GetAsync<T>` method returns, it
    will always return two items: the response of the `T` type and `AsyncError`. If
    either one of them isn’t present, then their default value is returned or `null`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法有点长，但它所做的事情并不复杂。首先，它使用 `GetUriBuilder` 方法创建 `UriBuilder` 实例，并从该实例构建 `fullUri`
    字符串值。然后，它使用 `HttpClient` 实例向 URL 发起 HTTP `GET` 请求。如果发生任何失败，异常处理程序将捕获它并返回 `AsynExceptionError`。如果没有错误发生，并且响应代码指示成功，则处理并返回结果。否则，将读取结果内容以查找错误，如果找到，则返回。当
    `GetAsync<T>` 方法返回时，它将始终返回两个项目：`T` 类型的响应和 `AsyncError`。如果其中任何一个不存在，则返回它们的默认值或
    `null`。
- en: 'Review and add the following code snippet to the `ServiceConnection` class
    to implement the `PostAsync<T>` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 审查并添加以下代码片段到 `ServiceConnection` 类以实现 `PostAsync<T>` 方法：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method is mostly the same as `GetAsync<T>` with a couple of minor changes.
    First, it does not need to call `GetUriBuilder` to add the parameters to the `Uri`
    `QueryString`, as the parameters are sent as part of the request body. Second,
    it uses the HTTP `POST` method instead of `GET`. With those changes, much of the
    method is error handling to make sure that we return the right data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法基本上与 `GetAsync<T>` 相同，但有一些小的变化。首先，它不需要调用 `GetUriBuilder` 将参数添加到 `Uri` 的 `QueryString`
    中，因为参数作为请求体的一部分发送。其次，它使用 HTTP `POST` 方法而不是 `GET`。有了这些变化，方法的大部分是错误处理，以确保我们返回正确的数据。
- en: And that completes the `ServiceConnection` class. `ServiceConnection` and the
    `Settings` service classes will be used in the next section, where we create the
    `GameService` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了 `ServiceConnection` 类。`ServiceConnection` 和 `Settings` 服务类将在下一节中使用，其中我们将创建
    `GameService` 类。
- en: Creating the GameService class
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 `GameService` 类
- en: The `GameService` class is a layer between the UI and the network. It uses the
    `ServiceConnection` class, which handles the specific network calls to create
    the logic we need to interact with the Azure Functions functions. For each of
    the functions that we created in *Chapter 9*, there is a corresponding method
    in the `GameService` class to make the call to the function and return the result,
    if any.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameService` 类是 UI 和网络之间的一个层。它使用 `ServiceConnection` 类来处理特定的网络调用，以创建我们需要与
    Azure Functions 交互的逻辑。对于我们在 *第 9 章* 中创建的每个函数，`GameService` 类都有一个对应的方法来调用函数并返回结果（如果有的话）。'
- en: 'Follow these steps to create and initialize the class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建和初始化类：
- en: Create a new class named `GameService` in the `SticksAndStones.App` project
    under the `Services` folder.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `Services` 文件夹下创建一个名为 `GameService` 的新类。
- en: 'Change the class definition to `public sealed` and inherit from the `IDisposable`
    interface:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类定义更改为 `public sealed` 并从 `IDisposable` 接口继承：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following namespace declarations to the top of the file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命名空间声明添加到文件顶部：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `GameService` class will depend on both the `Settings` service and the
    `ServiceConnection` service, so we need to add them to the constructor and store
    the references in class fields, as shown here:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameService` 类将依赖于 `Settings` 服务和 `ServiceConnection` 服务，因此我们需要将它们添加到构造函数中，并将引用存储在类字段中，如下所示：'
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the `IDisposable` interface by adding the following method to the
    `GameService` class:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向 `GameService` 类添加以下方法来实现 `IDisposable` 接口：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, add the class to dependency injection by adding the following highlighted
    line of code to the `MauiProgram.cs` file:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将以下高亮显示的代码行添加到 `MauiProgram.cs` 文件中，将类添加到依赖注入中：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will start with the `Connect` method. `Connect` will accept a `Player` object
    to connect as and return an updated `Player` object. Additionally, if the connection
    is successful, it will configure the SignalR Hub. To create the `Connect` function,
    follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `Connect` 方法开始。`Connect` 将接受一个要连接的 `Player` 对象，并返回一个更新的 `Player` 对象。此外，如果连接成功，它将配置
    SignalR Hub。要创建 `Connect` 函数，请按照以下步骤操作：
- en: 'Create a `private` field of `SemaphoreSlim` called `semaphoreSlim` and initialize
    the field with a new instance with an initial and maximum count of `1`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `semaphoreSlim` 的 `private` 字段，并使用一个具有初始和最大计数为 `1` 的新实例初始化该字段：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`The SemaphoreSlim` class is a great way to limit the number of threads performing
    an operation at a time. In our case, we only want one thread making the network
    calls at a time. It will be used in all the methods that make network calls from
    the `GameService` class.'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SemaphoreSlim` 类是限制一次执行操作线程数量的好方法。在我们的情况下，我们只想让一个线程在每次进行网络调用。它将在所有从 `GameService`
    类进行网络调用的方法中使用。'
- en: '`GameService` will track the current player in a `public` property called `CurrentPlayer`;
    add the property to the class using the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameService` 将在名为 `CurrentPlayer` 的 `public` 属性中跟踪当前玩家；使用以下代码将属性添加到类中：'
- en: '[PRE28]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The property is initialized to an empty `Player` object.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性被初始化为一个空的 `Player` 对象。
- en: 'Once the user has connected as a player, we will also need somewhere to store
    the list of online players. To do that, add the following property to the `GameService`
    class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户以玩家身份连接，我们还需要一个地方来存储在线玩家的列表。为此，将以下属性添加到 `GameService` 类中：
- en: '[PRE29]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`The GameService` class also tracks the current status of the connection in
    a property called `IsConnected`; add the property using the following code snippet
    to the `GameService` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameService` 类在名为 `IsConnected` 的属性中跟踪当前连接状态；使用以下代码片段将属性添加到 `GameService`
    类中：'
- en: '[PRE30]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a `public async` method named `Connect` to the `GameService` class. It
    should return `Task<Player>` and take a single `Player` as a parameter, as shown:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为 `Connect` 的 `public async` 方法添加到 `GameService` 类中。它应该返回 `Task<Player>`
    并接受一个 `Player` 参数，如下所示：
- en: '[PRE31]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Within the `Connect` method, the first step is to make sure there is only one
    thread operating in the method at a time:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Connect` 方法中，第一步是确保一次只有一个线程在该方法中操作：
- en: '[PRE32]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This uses the `async`/`await` structures in C# to create a lock that only releases
    when there are enough open slots in `SemaphoreSlim`. Since `the` `SemaphoreSlim`
    instance was only initialized with a single slot, only one thread can process
    the `Connect` method at a time.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使用 C# 中的 `async`/`await` 结构创建一个锁，只有当 `SemaphoreSlim` 中有足够的开放槽位时才会释放。由于 `SemaphoreSlim`
    实例仅初始化了一个槽位，因此一次只能有一个线程处理 `Connect` 方法。
- en: 'To make sure `the` `SemaphoreSlim` instance releases the slot, we need to add
    exception handling around the rest of the method and call `Release` at the end.
    Add the following code snippet to the `Connect` method:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保 `the` `SemaphoreSlim` 实例释放槽位，我们需要在方法的其他部分添加异常处理，并在最后调用 `Release`。将以下代码片段添加到
    `Connect` 方法中：
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `try`/`finally` block ensures that we will always call `Release` at the
    conclusion of the method, which will prevent `the` `SemaphoreSlim` instance from
    being starved, preventing any additional thread from entering the method. Lastly,
    we return the value of `CurrentPlayer`, which we will set next within the `try`
    block.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`try`/`finally` 块确保我们将在方法结束时始终调用 `Release`，这将防止 `the` `SemaphoreSlim` 实例被饿死，防止任何其他线程进入该方法。最后，我们返回
    `CurrentPlayer` 的值，我们将在 `try` 块中设置它。'
- en: There is another way to handle SemaphoreSlim
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 `SemaphoreSlim` 的另一种方法是
- en: 'Using a `try`/`catch`/`finally` block works, but it is a little clunky if you
    handle all your exceptions properly, or don’t have any. Tom Dupont has published
    a helper class on his blog that allows you to use a `using` statement to manage
    the lifetime of `the` `SemaphoreSlim` instance. You can read his post at [http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html](http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html).
    Here is an example of using his extension:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `try`/`catch`/`finally` 块是可行的，但如果您正确处理所有异常或没有异常，则略显笨拙。Tom Dupont 在他的博客上发布了一个辅助类，允许您使用
    `using` 语句来管理 `the` `SemaphoreSlim` 实例的生命周期。您可以在他的帖子 [http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html](http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html)
    中阅读他的帖子。以下是他扩展的示例：
- en: '`using var handle =` `semaphoreSlim.UseWaitAsync();`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`using var handle =` `semaphoreSlim.UseWaitAsync();`'
- en: 'Within the `try` block, add the following lines of code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `try` 块中，添加以下代码行：
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This block of code handles the call to the `Connect` function in the Azure Functions
    service. We start by setting the passed-in player details as the `CurrentPlayer`
    property. Then, `the player` instance is packaged into a `ConnectRequest` object
    and we pass that into a call to `PostAsync<T>` on the `ServiceConnection` instance.
    The URL is created from the `ServerUrl` property stored in the `Settings` service
    concatenated with `/Connect`. The response is expected to be of the `ConnectResponse`
    type and we store that in response. If we do not get any error, then we can call
    `ConnectHub` on the `ServiceConnection` instance, populate our `Players` collection,
    and set `the` `CurrentPlayer` property to the returned `Player` instance, which
    will have additional details from the server. If anything goes awry, then the
    error object will be populated, and we will send a message that contains that
    error to the UI.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码块处理 Azure Functions 服务中 `Connect` 函数的调用。我们首先将传入的玩家详细信息设置为 `CurrentPlayer`
    属性。然后，将 `player` 实例打包成一个 `ConnectRequest` 对象，并将其传递给 `ServiceConnection` 实例上的 `PostAsync<T>`
    调用。URL 是从存储在 `Settings` 服务中的 `ServerUrl` 属性拼接 `/Connect` 创建的。预期的响应类型为 `ConnectResponse`，并将其存储在
    `response` 中。如果我们没有收到任何错误，那么我们可以在 `ServiceConnection` 实例上调用 `ConnectHub`，填充我们的
    `Players` 集合，并将 `the` `CurrentPlayer` 属性设置为返回的 `Player` 实例，该实例将包含来自服务器的额外详细信息。如果发生任何问题，则错误对象将被填充，我们将向
    UI 发送包含该错误的消息。
- en: '`ServiceError` is the first message that we need to send to `ViewModel` instances
    from `the GameService` class. It is used to send errors from `the` `ServiceConnection`
    instance to `ViewModel` instances. We will add the `ServiceError` class in the
    next steps.'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ServiceError` 是我们需要从 `GameService` 类发送到 `ViewModel` 实例的第一个消息。它用于将 `ServiceConnection`
    实例的错误发送到 `ViewModel` 实例。我们将在下一步添加 `ServiceError` 类。'
- en: In the `SticksAndStones.App` project, create a new folder named `Messages`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目中，创建一个名为 `Messages` 的新文件夹。
- en: Create a new class named `ServiceError` in the `Messages` folder of the `SticksAndStones.App`
    project.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `Messages` 文件夹中创建一个名为 `ServiceError` 的新类。
- en: 'The `ServiceError` message is a simple wrapper around the `AyncError` object
    that can be used to send a message back to a view model. Replace the contents
    of the `ServiceError.cs` file with the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ServiceError` 消息是对 `AyncError` 对象的简单包装，可用于向视图模型发送消息。将 `ServiceError.cs` 文件的内容替换为以下内容：'
- en: '[PRE35]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, since we are using `SemaphoreSlim` and it can hold onto native resources,
    we should make sure that those are released properly. Add the following highlighted
    code to the `Dispose` method to clean up the `semaphoreSlim` field:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于我们正在使用 `SemaphoreSlim` 并且它可以保留原生资源，我们应该确保这些资源被正确释放。将以下高亮代码添加到 `Dispose`
    方法中以清理 `semaphoreSlim` 字段：
- en: '[PRE36]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The concludes the `Connect` method for now.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了当前的 `Connect` 方法。
- en: 'The next three methods are called from the `Lobby` page. The first method is
    used to refresh the list of players. It is called when the user pulls down the
    list causing a refresh, or if the SignalR Hub is reconnected. To implement `the`
    `RefreshPlayerList` method, follow these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个方法是从 `Lobby` 页面调用的。第一个方法用于刷新玩家列表。当用户下拉列表以刷新或如果 SignalR Hub 重新连接时，将调用此方法。要实现
    `the` `RefreshPlayerList` 方法，请按照以下步骤操作：
- en: '`the` `RefreshPlayerList` method takes no arguments and returns `Task`; add
    the method to the `GameService` class as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`the` `RefreshPlayerList` 方法不接受任何参数并返回 `Task`；将此方法添加到 `GameService` 类中，如下所示：'
- en: '[PRE37]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To refresh the list of players when the SignalR Hub reconnects, add the following
    highlighted code to the `Connect` method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 SignalR Hub 重新连接时，刷新玩家列表，请将以下高亮代码添加到 `Connect` 方法中：
- en: '[PRE38]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line of code is interesting. First, we await `service.Hub`, then set the
    `Reconnected` event to an anonymous function that calls `RefreshPlayerList`. If
    you recall, the `Hub` property in the `ServiceConnection` class is `AsyncLazy<T>`.
    The first time we reference the `Hub` property, it will initialize itself, asynchronously,
    hence the `await` call.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码很有趣。首先，我们等待 `service.Hub`，然后设置 `Reconnected` 事件为一个匿名函数，该函数调用 `RefreshPlayerList`。如果你还记得，`ServiceConnection`
    类中的 `Hub` 属性是 `AsyncLazy<T>`。第一次引用 `Hub` 属性时，它将异步初始化自身，因此有 `await` 调用。
- en: 'The next method that is used from the `Lobby` page is `IssueChallenge`. The
    `IssueChallenge` method is called from the `Lobby` page when a player wishes to
    play a match against another player. The `IssueChallenge` method does not return
    any value since the actual response to the challenge will come back through the
    SignalR Hub. The method will send the request to the server and handle any errors,
    as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个从 `Lobby` 页面使用的方法是 `IssueChallenge`。当玩家希望与其他玩家进行比赛时，`Lobby` 页面会调用 `IssueChallenge`
    方法。由于实际的挑战响应将通过 SignalR Hub 返回，因此 `IssueChallenge` 方法不返回任何值。该方法将向服务器发送请求并处理任何错误，如下所示：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the preceding code to the `GameService` class. The `SendChallengeResponse`
    method, which is called when the opposing player responds to a challenge, is very
    similar to the `IssueChallenge` method, as shown:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码添加到 `GameService` 类中。当对手响应挑战时调用的 `SendChallengeResponse` 方法与 `IssueChallenge`
    方法非常相似，如下所示：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the `SendChallengeResponse` method to the `GameService` class. That completes
    the methods needed to support the `Lobby` page. The final page in our app is the
    `Game` page. There are three more methods that are needed by the `Game` page.
    Follow these steps to add them:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `SendChallengeResponse` 方法添加到 `GameService` 类中。这样就完成了支持 `Lobby` 页面所需的方法。我们应用中的最后一页是
    `Game` 页面。还需要三个由 `Game` 页面需要的方法。按照以下步骤添加它们：
- en: 'Add the `EndTurn` method, which will send the player’s move to the `Game` server,
    using the following code snippet:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `EndTurn` 方法，该方法将玩家的移动发送到 `Game` 服务器，使用以下代码片段：
- en: '[PRE41]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`EndTurn` is very similar to the `IssueChallenge` and `SendChallengeResponse`
    methods, with a minor exception: it returns the updated `Game` object and an error
    message if present.'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EndTurn` 方法与 `IssueChallenge` 和 `SendChallengeResponse` 方法非常相似，只有一个小的例外：它返回更新后的
    `Game` 对象和错误消息（如果有的话）。'
- en: '`the` `GetPlayerId` method is a small helper function to search the `Players`
    list and return the `Player` instance that matches the ID passed in. Use the following
    code snippet to add the `GetPlayerById` method:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`the` `GetPlayerId` 方法是一个小的辅助函数，用于搜索 `Players` 列表并返回与传入的 ID 匹配的 `Player` 实例。使用以下代码片段添加
    `GetPlayerById` 方法：'
- en: '[PRE42]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`the` `GetMatchById` method is the last method that will make a call to the
    backend. In this case, it will retrieve a `Match` object given an ID. Using the
    following code snippet, add `GetMatchById` to the `GameService` class:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`the` `GetMatchById` 方法是最后一个将调用后端的方法。在这种情况下，它将根据 ID 获取一个 `Match` 对象。使用以下代码片段将
    `GetMatchById` 添加到 `GameService` 类中：'
- en: '[PRE43]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The final piece to `the` `GameService` class is the handling of the events
    received through the SignalR Hub. To refresh our memory from *Chapter 9*, the
    backend functions will send the following events to the clients via SignalR:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameService` 类的最后一部分是处理通过 SignalR Hub 接收的事件。为了从 *第 9 章* 中刷新我们的记忆，后端函数将通过 SignalR
    将以下事件发送到客户端：'
- en: '`PlayerUpdatedEventArgs`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerUpdatedEventArgs`'
- en: '`ChallengeEventArgs`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChallengeEventArgs`'
- en: '`GameStartedEventArgs`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameStartedEventArgs`'
- en: '`GameUpdatedEventArgs`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameUpdatedEventArgs`'
- en: 'We will handle each of these events in the `GameService` method. To implement
    the handlers for these events, follow these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `GameService` 方法中处理这些事件中的每一个。要实现这些事件的处理器，请按照以下步骤操作：
- en: 'When the `Hub` receives `PlayerUpdatedEventArgs`, we will need to update `Player`
    in the `Players` collection with the new values. We will create a helper function
    to handle that work, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `Hub` 接收到 `PlayerUpdatedEventArgs` 时，我们需要使用新值更新 `Players` 集合中的 `Player`。我们将创建一个辅助函数来处理这项工作，如下所示：
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `PlayerStatusChangedHandler` method will locate the changed player in the
    `Players` collection and update the relevant fields of the instance or add it
    if it doesn’t exist.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PlayerStatusChangedHandler` 方法将在 `Players` 集合中定位已更改的玩家并更新实例的相关字段或如果不存在则添加它。'
- en: 'To call `the` `PlayerStatusUpdateHandler` class when the `PlayerUpdated` event
    is received, add the following highlighted code to the `Connect` method:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到 `PlayerUpdated` 事件时调用 `PlayerStatusUpdateHandler` 类，请将以下突出显示的代码添加到 `Connect`
    方法：
- en: '[PRE45]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The other three events will send messages to the `ViewModel` instance using
    `WeakReferenceManager`. First, we need to add the message types, using the following
    steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个事件将通过 `WeakReferenceManager` 向 `ViewModel` 实例发送消息。首先，我们需要添加消息类型，按照以下步骤操作：
- en: Add a new class named `ChallengeReceived` to the `Messages` folder in the `SticksAndStones.App`
    project.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `Messages` 文件夹中添加一个名为 `ChallengeReceived` 的新类。
- en: 'Replace the contents of the `ChallengeReceived.cs` file with the following:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换 `ChallengeReceived.cs` 文件的内容：
- en: '[PRE46]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Add a new class named `MatchStarted` in the `Messages` folder of the `SticksAndStones.App`
    project.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `Messages` 文件夹中添加一个名为 `MatchStarted` 的新类。
- en: 'Replace the contents of the `MatchStarted.cs` file with the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换 `MatchStarted.cs` 文件的内容：
- en: '[PRE47]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Add a new class named `MatchUpdated` to the `SticksAndStones.App` project in
    the `Messages` folder.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `Messages` 文件夹中添加一个名为 `MatchUpdated` 的新类。
- en: 'Replace the contents of the `MatchUpdated.cs` file with the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换 `MatchUpdated.cs` 文件的内容：
- en: '[PRE48]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To send a message when the event is received, add the following highlighted
    code to the `Connect` method in the `GameService` class:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到事件时发送消息，请将以下突出显示的代码添加到 `GameService` 类中的 `Connect` 方法：
- en: '[PRE49]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That concludes the `GameService` class. We have all the methods needed to interact
    with the backend functions and we are handling the events that are being sent
    to the clients. The next portion of the chapter will add the pages needed to present
    the screens to the user, starting with the **Connect** page.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `GameService` 类。我们拥有了与后端功能交互所需的所有方法，并且我们正在处理发送到客户端的事件。本章的下一部分将添加用于向用户展示屏幕所需的页面，从
    **连接** 页面开始。
- en: Creating the Connect page
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建连接页面
- en: 'The **Connect** page, as shown in *Figure 10**.6*, is the first screen a user
    is presented with after the app loads. The page contains four main elements: an
    entry box for the player’s gamer tag, an entry box for the player’s email address,
    an image control for the player’s avatar, and the **Connect** button.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.6* 所示的 **连接** 页面，是应用加载后用户首先看到的屏幕。该页面包含四个主要元素：玩家游戏标签的输入框、玩家电子邮件地址的输入框、玩家头像的图像控件以及
    **连接** 按钮。
- en: '![Figure 10.6 – The Connect page](img/B19214_10_6.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 连接页面](img/B19214_10_6.jpg)'
- en: Figure 10.6 – The Connect page
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 连接页面
- en: 'The **Connect** page will consist of several parts:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接** 页面将包含几个部分：'
- en: A `ViewModel` file called `ConnectViewModel.cs`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `ConnectViewModel.cs` 的 `ViewModel` 文件
- en: A XAML file called `ConnectView.xaml`, which contains the layout
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `ConnectView.xaml` 的 XAML 文件，其中包含布局
- en: A code-behind file called `ConnectView.xaml.cs`, which will carry out the data-binding
    process
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `ConnectView.xaml.cs` 的代码隐藏文件，将执行数据绑定过程
- en: A XAML file containing the layout for a custom button control, called `ActivityButton.xaml`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含自定义按钮控件布局的 XAML 文件，称为 `ActivityButton.xaml`
- en: The code-behind for `ActivityButton` in `ActivityButton.xaml.cs`
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityButton.xaml.cs` 中 `ActivityButton` 的代码隐藏'
- en: We will begin the implementation of the `ConnectViewModel` first.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现 `ConnectViewModel`。
- en: Adding ConnectViewModel
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 ConnectViewModel
- en: '`ConnectViewModel` – along with `LobbyViewModel` and `GameView` model – will
    inherit from a single base class called `ViewModelBase`. The `ViewModelBase` class
    provides the necessary functionality to implement refreshing the page. Not all
    pages will use this feature, but it will be available. To add `ViewModelBase`,
    follow these steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectViewModel` 与 `LobbyViewModel` 和 `GameView` 模型一起将继承自一个名为 `ViewModelBase`
    的单一基类。`ViewModelBase` 类提供了实现页面刷新所需的功能。并非所有页面都会使用此功能，但它将是可用的。要添加 `ViewModelBase`，请按照以下步骤操作：'
- en: Create a new folder named `ViewModels` in the `SticksAndStones.App` project.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目中创建一个名为 `ViewModels` 的新文件夹。
- en: Add a new class named `ViewModelBase` in the `ViewModels` folder.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中添加一个名为 `ViewModelBase` 的新类。
- en: 'Add the following namespace declarations at the top of the `ViewModelBase.cs`
    file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModelBase.cs` 文件顶部添加以下命名空间声明：
- en: '[PRE50]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Change the class declaration to `public abstract partial` and derive the class
    from `ObservableRecipient`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类声明更改为 `public abstract partial` 并从 `ObservableRecipient` 派生类：
- en: '[PRE51]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a `private bool` field named `canRefresh` with the `ObservableProperty`
    attribute:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `canRefresh` 的 `private bool` 字段，并使用 `ObservableProperty` 属性：
- en: '[PRE52]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add a `private bool` field named `isRefreshing` with the `ObservableProperty`
    attribute:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `isRefreshing` 的 `private bool` 字段，并使用 `ObservableProperty` 属性：
- en: '[PRE53]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add a `private` method named `CanExecuteRefresh` that takes no parameters and
    returns a `bool`. The method signature and implementation are in the following
    code snippet:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个无参数返回 `bool` 类型的 `private` 方法名为 `CanExecuteRefresh`。方法签名和实现如下代码片段所示：
- en: '[PRE54]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add a new `protected virtual` method named `RefreshInternal` that returns a
    `Task` and its implementation returns `Task.CompletedTask`, as shown here:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `RefreshInternal` 的新 `protected virtual` 方法，它返回一个 `Task`，其实现返回 `Task.CompletedTask`，如下所示：
- en: '[PRE55]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the `Refresh` method as shown here:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加如下所示的 `Refresh` 方法：
- en: '[PRE56]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `Refresh` method is a `Command`, meaning that it can be bound to XAML elements
    as `RefreshCommand`. The `CanExecuteRefresh` method is used to determine the enabled/disabled
    state for the command. The command itself flips the `IsRefreshing` Boolean and
    calls the `RefreshInternal` method where classes derived from `ViewModelBase`
    would put the specific implementation.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Refresh` 方法是一个 `Command`，这意味着它可以绑定到 XAML 元素作为 `RefreshCommand`。`CanExecuteRefresh`
    方法用于确定命令的启用/禁用状态。命令本身翻转 `IsRefreshing` 布尔值并调用 `RefreshInternal` 方法，在从 `ViewModelBase`
    派生的类中放置具体的实现。'
- en: 'Now that `ViewModelBase` has been implemented, we can implement `ConnectViewModel`.
    The `ConnectViewModel` class has bindable properties for the player’s gamer tag
    and email address and various states for commands. Finally, there is a command
    to establish a connection to the game services. Let’s implement the `ConnectViewModel`
    class by following these steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ViewModelBase` 已经实现，我们可以实现 `ConnectViewModel`。`ConnectViewModel` 类具有可绑定的玩家游戏标签和电子邮件地址属性以及各种命令状态。最后，有一个用于建立与游戏服务的连接的命令。让我们按照以下步骤实现
    `ConnectViewModel` 类：
- en: Create a new class named `ConnectViewModel` in the `ViewModels` folder.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中创建一个名为 `ConnectViewModel` 的新类。
- en: 'Alter the class definition to `public partial` and derive from `ViewModelBase`,
    as shown here:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类定义更改为 `public partial` 并从 `ViewModelBase` 派生，如下所示：
- en: '[PRE57]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`ConnectViewModel` depends on `GameService` and the `Settings` service so let’s
    add a constructor to acquire them through dependency injection and `private` fields
    to store their values, as shown here:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConnectViewModel` 依赖于 `GameService` 和 `Settings` 服务，因此让我们添加一个构造函数来通过依赖注入获取它们，并添加
    `private` 字段来存储它们的值，如下所示：'
- en: '[PRE58]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To use the `GameService` and `Settings` classes, you’ll need to add a namespace
    declaration to the top of the file:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `GameService` 和 `Settings` 类，您需要在文件顶部添加一个命名空间声明：
- en: '[PRE59]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add a `private string` field named `gamerTag` attributed with `ObservableProperty`
    to make it bindable, as shown in the following code snippet:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码片段中添加一个名为 `gamerTag` 的 `private string` 字段，并使用 `ObservableProperty` 属性来使其可绑定，如下所示：
- en: '[PRE60]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add a `private string` field named `emailAddress` attributed with `ObservableProperty`
    to make it bindable, as shown in this code snippet:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码片段中添加一个名为 `emailAddress` 的 `private string` 字段，并使用 `ObservableProperty` 属性来使其可绑定，如下所示：
- en: '[PRE61]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the constructor for `ConnectViewModel`, initialize the bindable properties
    from the last time the user connected, as shown in the following snippet:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ConnectViewModel` 的构造函数中，从用户上次连接时初始化可绑定属性，如下所示：
- en: '[PRE62]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The **Connect** page does not need to refresh the view, so disable that functionality
    by adding the following line of code to the beginning of the constructor:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Connect` 页面不需要刷新视图，因此通过在构造函数开头添加以下行代码来禁用该功能：'
- en: '[PRE63]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To implement the `Connect` command, we will need four things: a `string` indicating
    the status of the command, a `bool` to indicate the current state of the command,
    a method to return if the command is enabled, and the method for the command itself.
    To add the status as a string, add the following code above the constructor in
    the `ConnectViewModel` class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `Connect` 命令，我们需要四样东西：一个表示命令状态的 `string`，一个表示命令当前状态的 `bool`，一个返回命令是否启用的方法，以及命令本身的方法。要将状态作为字符串添加，请在
    `ConnectViewModel` 类的构造函数上方添加以下代码：
- en: '[PRE64]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We mark this field with `ObservableProperty` so that it is bindable into the
    view.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `ObservableProperty` 标记此字段，以便它可以绑定到视图中。
- en: 'To add the `isConnecting` field to track the state of the command, add the
    following code under the `connectStatus` field:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `isConnecting` 字段添加以跟踪命令的状态，请在 `connectStatus` 字段下添加以下代码：
- en: '[PRE65]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `CanExecuteConnect` method will return `true` if the command is enabled,
    and `false` if not. Add the method using the following code snippet under the
    `isConnecting` field:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanExecuteConnect` 方法将在命令启用时返回 `true`，否则返回 `false`。请在 `isConnecting` 字段下方使用以下代码片段添加方法：'
- en: '[PRE66]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `Connect` command will call a `Connect` method to establish the connection
    with the game server. This is mostly just to keep the methods small and manageable.
    Add the following private `Connect` method to the `ConnectViewModel` class:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Connect` 命令将调用 `Connect` 方法与游戏服务器建立连接。这主要是为了保持方法小且易于管理。请将以下私有 `Connect` 方法添加到
    `ConnectViewModel` 类中：'
- en: '[PRE67]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This method will call the `Connect` method on the `GameService` class passing
    in the player details. If the connection is successful, then the user is navigated
    to the Lobby page, unless they are currently in a game, in which case, they are
    navigated to the Game page.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将在 `GameService` 类上调用 `Connect` 方法，传入玩家详细信息。如果连接成功，则用户将被导航到大厅页面，除非他们当前正在玩游戏，在这种情况下，他们将被导航到游戏页面。
- en: Navigation in .NET MAUI Shell
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI Shell 中的导航
- en: 'In .NET MAUI, navigation is performed by calling `GotoAsync` from the `Shell`
    object. The `Shell` object can be obtained by either casting `App.Current.MainPage`
    to a `Shell` object, or by using the `Shell.Current` property. The route passed
    to `GotoAsync` can be either relative to the current location or absolute. The
    valid forms of relative and absolute routes are as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，导航是通过从 `Shell` 对象调用 `GotoAsync` 来实现的。`Shell` 对象可以通过将 `App.Current.MainPage`
    强制转换为 `Shell` 对象，或者使用 `Shell.Current` 属性来获取。传递给 `GotoAsync` 的路由可以是相对于当前位置的，也可以是绝对路径。相对和绝对路由的有效形式如下：
- en: '`• route` – The route will be searched for upward from the current position
    and, if found, pushed onto the navigation stack'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`• route` – 路由将从当前位置向上搜索，如果找到，将被推送到导航堆栈'
- en: '`• /route` – The route will be searched for downward from the current position
    and, if found, pushed onto the navigation stack'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`• /route` – 路由将从当前位置向下搜索，如果找到，将被推送到导航堆栈'
- en: '`• //route` – The route will be searched for upward from the current position
    and, if found, will replace the navigation stack'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`• //route` – 路由将从当前位置向上搜索，如果找到，将替换导航堆栈'
- en: '`• ///route` – The route will be searched for downward from the current position
    and, if found, will replace the navigation stack'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`• ///route` – 路由将从当前位置向下搜索，如果找到，将替换导航堆栈'
- en: To learn more about routes and navigation, visit [https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于路由和导航的信息，请访问 [https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation)。
- en: 'Add the method implementing the `Connect` command to the bottom of the `Connect`
    **ViewModel** class using the following code snippet:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段将实现 `Connect` 命令的方法添加到 `Connect` **ViewModel** 类的底部：
- en: '[PRE68]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The command is very straightforward. It sets the `IsConnecting` and `ConnectStatus`
    properties, then updates the `Player` values from the view. Then, it calls `Connect`,
    passing in the current `Player` instance. The ID of the returned player is captured
    and set back on `LastPlayer` in `Settings`. Finally, the `ConnectStatus` and `IsConnecting`
    properties are set back to their defaults.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令非常直接。它设置 `IsConnecting` 和 `ConnectStatus` 属性，然后从视图更新 `Player` 值。然后，它调用 `Connect`，传入当前的
    `Player` 实例。返回的玩家 ID 被捕获并设置回 `Settings` 中的 `LastPlayer`。最后，将 `ConnectStatus` 和
    `IsConnecting` 属性设置回默认值。
- en: 'To wrap things up, we need to add a couple of attributes to make sure that
    properties are updated appropriately as values change. For instance, when the
    `IsConnecting` property is changed, we need to ensure that the `CanExecuteConnect`
    method is evaluated again. To do this, we add the `NotifyCanExecuteChangeFor`
    attribute to the `IsConnecting` field, as shown here:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了总结，我们需要添加一些属性以确保值更改时属性得到适当的更新。例如，当 `IsConnecting` 属性更改时，我们需要确保再次评估 `CanExecuteConnect`
    方法。为此，我们在 `IsConnecting` 字段上添加 `NotifyCanExecuteChangeFor` 属性，如下所示：
- en: '[PRE69]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since the `gamerTag` field and `emailAddress` field are also referenced in
    the `CanExecuteConnect` method, we should add the attribute to those fields as
    well, as shown here:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `gamerTag` 字段和 `emailAddress` 字段也在 `CanExecuteConnect` 方法中被引用，因此我们应将这些字段也添加属性，如下所示：
- en: '[PRE70]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We have nearly completed `ConnectViewModel`. The final feature to implement
    is the handling of messages that we may receive from `GameService`. The `ObservableObject`
    implementation from `CommunityToolkit` provides a feature to make subscribing
    and unsubscribing to these messages clean. To implement the message handlers,
    follow these steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了 `ConnectViewModel` 的实现。要实现的功能是处理可能从 `GameService` 收到的消息。`CommunityToolkit`
    的 `ObservableObject` 实现提供了一个使订阅和取消订阅这些消息变得简洁的功能。要实现消息处理程序，请按照以下步骤操作：
- en: 'Add a new `private` method named `OnServiceError` to the `ConnectViewModel`
    class, using the following code snippet:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ConnectViewModel` 类中添加一个名为 `OnServiceError` 的新 `private` 方法，使用以下代码片段：
- en: '[PRE71]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We will subscribe to the `ServiceError` messages from the `OnActivated` event
    method of the `ObservableObject` class, Add the following method to the `ConnectViewModel`
    class to subscribe to the `ServiceError` message:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从 `ObservableObject` 类的 `OnActivated` 事件方法订阅 `ServiceError` 消息。将以下方法添加到 `ConnectViewModel`
    类中，以订阅 `ServiceError` 消息：
- en: '[PRE72]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To unsubscribe from the `ServiceError` messages, add the following method to
    the `ConnectViewModel` class:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要取消订阅 `ServiceError` 消息，请将以下方法添加到 `ConnectViewModel` 类中：
- en: '[PRE73]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the constructor for `ConnectViewModel`, we need to enable the `OnActivated`
    and `OnDeactivated` events that are raised by `ObservableObject`. These events
    are the recommended places to subscribe and unsubscribe to messages. Add the following
    line of code to the end of the constructor to enable the events:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ConnectViewModel` 的构造函数中，我们需要启用由 `ObservableObject` 触发的 `OnActivated` 和 `OnDeactivated`
    事件。这些事件是推荐订阅和取消订阅消息的地方。将以下代码行添加到构造函数的末尾以启用事件：
- en: '[PRE74]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Setting `IsActive` to `true` will cause the `OnActivated` event to fire. Setting
    it to `false` will cause the `OnDeactivated` event to fire.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `IsActive` 设置为 `true` 将触发 `OnActivated` 事件。将其设置为 `false` 将触发 `OnDeactivated`
    事件。
- en: 'To have the `OnDeactivated` event fire, we need to set `IsActive` to `false`.
    In the `Connect` method, add the highlighted line of code:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要触发 `OnDeactivated` 事件，我们需要将 `IsActive` 设置为 `false`。在 `Connect` 方法中添加以下突出显示的代码行：
- en: '[PRE75]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Open the `MauiProgram.cs` file in the `SticksAndStones.App` project and add
    the following highlighted line to register `ConnectViewModel` with dependency
    injection:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `MauiProgram.cs` 文件中打开，并将以下突出显示的行添加到注册 `ConnectViewModel`
    以进行依赖注入：
- en: '[PRE76]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This concludes the implementation of `ConnectViewModel`. The `ConnectViewModel`
    class controls the entry of the user’s gamer tag and email. It connects the user
    to the game server using their player details.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `ConnectViewModel` 的实现。`ConnectViewModel` 类控制用户游戏标签和电子邮件的输入。它使用玩家的详细信息将用户连接到游戏服务器。
- en: Adding the Connect view
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加连接视图
- en: 'The `Connect` view looks fairly simple, but there is a lot to it. We will break
    down the creation of the view into three sections:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connect` 视图看起来相当简单，但其中有很多内容。我们将创建视图的创建分为三个部分：'
- en: 'Creating the `ActivityButton` control:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `ActivityButton` 控件：
- en: The `ActivityButton` control is the button used to initiate a connection to
    the backend services. While a simple button might do the trick, what if we had
    an animation that indicated the `connect` operation was in progress and the text
    of the button updated as well? That is what `ActivityButton` will do, in a reusable
    control.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ActivityButton`控件是用于启动与后端服务连接的按钮。虽然一个简单的按钮可能可以完成任务，但如果有一个动画指示`connect`操作正在进行，并且按钮的文本也更新了会怎样？这正是`ActivityButton`将要做的，在一个可重用的控件中。'
- en: 'Creating the images:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图片：
- en: There are a few images used on this page. All of them were generated using AI.
    We’ll explore how that was done.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个页面上使用了一些图片。所有这些图片都是使用AI生成的。我们将探讨这是如何完成的。
- en: 'Building the view:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建视图：
- en: This is where we bring `ActivityButton` together with our custom images and
    the built-in controls of .NET MAUI to make `ConnectView` appear as it does in
    the figures.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们将`ActivityButton`与我们的自定义图片和.NET MAUI的内置控件结合起来，使`ConnectView`看起来像图中的样子。
- en: Let’s start by building the `ActivityButton` control.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建`ActivityButton`控件开始。
- en: Creating the ActivityButton control
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建ActivityButton控件
- en: So, what is this `ActivityButton` control? It’s basically a button with an `ActivityIndicator`
    that will only show up while the task behind the button is doing its work. The
    complexity of this control comes from the fact that we are making a general-purpose
    control instead of a specialized control. So, for all intents and purposes, it
    needs to act like a normal `Button` and `ActivityIndicator`. We are only going
    to implement the feature that we need for this application, but even then, it’s
    still a reusable control.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个`ActivityButton`控件是什么？它基本上是一个带有`ActivityIndicator`的按钮，只有在按钮背后的任务正在工作时才会显示出来。这个控件复杂性的来源在于我们正在制作一个通用控件而不是一个专用控件。因此，从所有目的和用途来看，它需要表现得像一个正常的`Button`和`ActivityIndicator`。我们只为这个应用程序实现所需的特性，即便如此，它仍然是一个可重用的控件。
- en: 'From `Button`, we want to have the following XAML attributes:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Button`，我们希望有以下XAML属性：
- en: '`Text`, `FontFamily`, and `FontSize`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text`、`FontFamily`和`FontSize`'
- en: '`Command` and `CommandParameter`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`和`CommandParameter`'
- en: From `ActivityIndicator`, we will have `IsRunning`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ActivityIndicator`，我们将有`IsRunning`。
- en: 'Each of these XAML elements will be bindable, like their original properties.
    An example of what the XAML might look like for declaring this control as an element
    would be as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这些XAML元素将像它们的原始属性一样可绑定。以下是一个示例，说明如何声明这个控件作为一个元素：
- en: '[PRE77]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This listing comes from the actual XAML we will be creating for `ConnectView.xaml`
    later in this section.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表来自本节稍后我们将创建的`ConnectView.xaml`的实际XAML。
- en: 'The attributes that are copied from the two underlying controls need to be
    able to bind to the view model. This requires that they are implemented as bound
    properties. To create a bound property, you need two things: a property and a
    `BindableProperty` that references the property. The `BindableProperty` provides
    the functionality to keep the view model property, which implements `INotifyPropertyChanged`,
    with the property of the control. Let’s create the `Command` bindable property
    as an example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个底层控件复制的属性需要能够绑定到视图模型。这要求它们被实现为绑定属性。要创建一个绑定属性，你需要两样东西：一个属性和一个引用该属性的`BindableProperty`。`BindableProperty`提供了保持实现`INotifyPropertyChanged`的视图模型属性与控件属性的功能。以下是一个创建`Command`绑定属性的示例：
- en: Create a new folder named `Controls` in the `SticksAndStones.App` project.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SticksAndStones.App`项目中创建一个名为`Controls`的新文件夹。
- en: Add a new .NET MAUI `ContentView` (XAML) called `ActivityButton`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的.NET MAUI `ContentView`（XAML）名为`ActivityButton`。
- en: Open the `ActivityButton.xaml.cs` file.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ActivityButton.xaml.cs`文件。
- en: 'Create a new `public ICommand` property named `Command`, as shown in the following
    listing:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Command`的`public ICommand`属性，如下所示：
- en: '[PRE78]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`BindableProperty` properties have a circular reference with the properties
    they are bound to, so you will get red squigglies until we complete the next step.
    This looks like almost every other property we have created, except that the `get`
    and `set` methods are just delegating to the `GetValue` and `SetValue` methods,
    respectively. `GetValue` and `SetValue` are provided by the `BindableObject` class,
    which `ContentView` ultimately inherits from. `GetValue` and `SetValue` are the
    `BindableObject` equivalents to `INotifyPropertyChanged` for view models. Calling
    them not only stores the values but also sends notifications that the value has
    changed.'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BindableProperty`属性与它们所绑定到的属性之间存在循环引用，因此直到我们完成下一步，你将得到红色的波浪线。这看起来几乎与我们所创建的每个属性都一样，除了`get`和`set`方法只是分别委托给`GetValue`和`SetValue`方法。`GetValue`和`SetValue`由`BindableObject`类提供，`ContentView`最终从这个类继承。`GetValue`和`SetValue`是视图模型中`INotifyPropertyChanged`的等价物。调用它们不仅存储值，还会发送通知，表明值已更改。'
- en: 'Now, add the `BindableProperty` property for the `Command` property, using
    the following code snippet:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为`Command`属性添加`BindableProperty`属性，使用以下代码片段：
- en: '[PRE79]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`CommandProperty` is of the `BindableProperty` type and is created by using
    the `Create` factory method of the `BindableProperty` class. We pass in the name
    of the property we are binding to (`Command`), the type that property returns
    (`Icommand`), the declaring type (which is `ActivityButton` in this case), and
    then what mode we want the binding to have. There are four options for `BindingMode`:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CommandProperty`是`BindableProperty`类型，并使用`BindableProperty`类的`Create`工厂方法创建。我们传入我们正在绑定的属性的名称（`Command`），该属性返回的类型（`Icommand`），声明类型（在这种情况下是`ActivityButton`），然后是我们想要绑定的模式。`BindingMode`有四个选项：'
- en: '`OneWay` – The default, propagates changes from the source (the view model)
    to the target (the control)'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneWay` —— 默认选项，将更改从源（视图模型）传播到目标（控件）'
- en: '`OneWayToSource` – This is the reverse of `OneWay`, propagating changes from
    the target (the control) to the source (the view model)'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneWayToSource` —— 这是`OneWay`的反向，将更改从目标（控件）传播到源（视图模型）'
- en: '`TwoWay` – This propagates changes in both directions'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TwoWay` —— 这在两个方向上传播更改'
- en: '`OneTime` – This propagates the changes only when `BindingContext` changes
    and all `INotifyPropertyChanged` events are ignored'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneTime` —— 仅当`BindingContext`更改时传播更改，并忽略所有`INotifyPropertyChanged`事件'
- en: These two pieces – the normal property that you would use in most of your C#
    classes, and `BindableProperty` – provide the complete functionality we need to
    create the custom control.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个组件——你将在大多数C#类中使用的一般属性，以及`BindableProperty`——提供了我们创建自定义控件所需的所有功能。
- en: Now that we understand how to implement `BindableProperty` on a XAML control,
    we can complete the implementation of `ActivityButton`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在XAML控件上实现`BindableProperty`，我们可以完成`ActivityButton`的实现。
- en: 'Let’s start by updating the XAML and then we will follow that with the remaining
    `BindableProperty` implementations. The following steps will walk you through
    creating the control:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更新XAML，然后我们将继续剩余的`BindableProperty`实现。以下步骤将指导你创建控件：
- en: 'The template we chose to create the XAML and `.cs` files is not quite what
    we need for `ActivityButton`. We will need to alter the underlying root control
    from `ContentView` to `Frame`. We use `Frame` to wrap our layout with a border.
    Open the `ActivityButton.cs` file and update the class definition to inherit from
    `Frame` instead of `ContentView`, as follows:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择的用于创建XAML和`.cs`文件的模板并不完全符合我们为`ActivityButton`的需求。我们需要将底层根控件从`ContentView`更改为`Frame`。我们使用`Frame`来用边框包裹我们的布局。打开`ActivityButton.cs`文件，并更新类定义以从`ContentView`继承到`Frame`，如下所示：
- en: '[PRE80]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <Frame
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<Frame`'
- en: x:Class="SticksAndStones.Controls.ActivityButton">
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x:Class="SticksAndStones.Controls.ActivityButton">
- en: </ContentView to Frame, also remove the contents of Frame as we won’t be reusing
    it.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </ContentView to Frame，同时删除Frame的内容，因为我们不会重新使用它。
- en: '[PRE81]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Let’s name our control to make it easier to reference it later. Typically, in
    C#, if you want to reference the instance of the class, you will use the `this`
    keyword. That doesn’t exist by default in XAML so add the `x:Name` attribute with
    the value of `this` to mimic C#.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们给我们的控件命名，以便以后更容易引用它。通常，在C#中，如果你想引用类的实例，你会使用`this`关键字。在XAML中默认不存在`this`，所以添加`x:Name`属性并使用`this`的值来模拟C#。
- en: Update the `Frame` element and add the `BackgroundColor` attribute with a value
    of `{x:StaticResource Primary}`. `Primary` is defined in the `Resources/Styles/Colors.xaml`
    file and we can reference it using the `StaticResource` extension method.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Frame` 元素并添加 `BackgroundColor` 属性，其值为 `{x:StaticResource Primary}`。`Primary`
    在 `Resources/Styles/Colors.xaml` 文件中定义，我们可以使用 `StaticResource` 扩展方法来引用它。
- en: Update the `Frame` element and add the `CornerRadius` attribute with a value
    of `5`. This will give our button rounded corners.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Frame` 元素并添加 `CornerRadius` 属性，其值为 `5`。这将给我们的按钮带来圆角。
- en: 'Add the `Padding` attribute with a value of `12` to the `Frame` element. This
    will ensure that there is plenty of whitespace around the control. The `Frame`
    element should now look like the following:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Padding` 属性的值设置为 `12` 添加到 `Frame` 元素。这将确保在控件周围有足够的空白。`Frame` 元素现在应该看起来像以下：
- en: '[PRE82]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To get `ActivityIndicator` and `Label` centered side by side within `Frame`,
    we will use `HorizontalStackLayout` contained in `VerticalStackLayout`. `StackLayout`
    controls ignore the alignment options for the direction of the control, so, for
    example, `VerticalStackLayout` ignores the `VerticalOptions` property of its children
    and `HorizontalStackLayout` ignores the `HorizontalOptions` property of its children.
    This is because, by its nature, `HorizontalStackLayout` is in control of laying
    out its children in the horizontal plane, and the same is true for `VerticalStackLayout`,
    except in the vertical plane. Add the following highlighted code to the XAML:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 `Frame` 中使 `ActivityIndicator` 和 `Label` 侧边对齐，我们将使用包含在 `VerticalStackLayout`
    中的 `HorizontalStackLayout`。`StackLayout` 控件忽略控制方向的对齐选项，例如，`VerticalStackLayout`
    忽略其子控件的 `VerticalOptions` 属性，而 `HorizontalStackLayout` 忽略其子控件的 `HorizontalOptions`
    属性。这是因为，根据其本质，`HorizontalStackLayout` 控制在水平平面上布局其子控件，同样，`VerticalStackLayout`
    也是如此，只是在垂直平面上。将以下突出显示的代码添加到 XAML 中：
- en: '[PRE83]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Within the `HorizontalStackLayout` element, add the following XAML:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HorizontalStackLayout` 元素内，添加以下 XAML：
- en: '[PRE84]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`ActivityIndicator` will have a `Height` and `Width` value of `15` and a `Color`
    value of `White`. The `IsRunning` and `IsVisible` properties are bound to the
    control’s `IsRunning` property. We haven’t created the `IsRunning` property yet,
    so this won’t work until we do. The `x:Reference` markup extension allows us to
    bind the property to the parent control, which we named `this` in *step 3*.'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ActivityIndicator` 将具有 `Height` 和 `Width` 值为 `15` 和 `Color` 值为 `White`。`IsRunning`
    和 `IsVisible` 属性绑定到控件的 `IsRunning` 属性。我们尚未创建 `IsRunning` 属性，因此这不会工作，直到我们这样做。`x:Reference`
    标记扩展允许我们将属性绑定到父控件，我们在 *步骤 3* 中将其命名为 `this`。'
- en: 'Now, we can add `Label` within `HorizontalStackLayout` using the following
    XAML:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下 XAML 在 `HorizontalStackLayout` 内添加 `Label`：
- en: '[PRE85]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When the user taps or clicks anywhere in `Frame`, `Command` should be run.
    To configure that, we will use `GestureRecognizer`. `GestureRecognizer` is XAML’s
    way of providing event handlers. There are several different kinds of `GestureRecognizer`:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在 `Frame` 的任何地方点击或轻触时，应运行 `Command`。为此，我们将使用 `GestureRecognizer`。`GestureRecognizer`
    是 XAML 提供事件处理程序的方式。有几种不同类型的 `GestureRecognizer`：
- en: '`DragGestureRecognizer` and `DropGestureRecognizer`'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DragGestureRecognizer` 和 `DropGestureRecognizer`'
- en: '`PanGestureRecognizer`'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PanGestureRecognizer`'
- en: '`PinchGestureRecognizer`'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PinchGestureRecognizer`'
- en: '`PointerGestureRecognizer`'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointerGestureRecognizer`'
- en: '`SwipeGestureRecognizer`'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwipeGestureRecognizer`'
- en: '`TapGestureRecognizer`'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TapGestureRecognizer`'
- en: 'For `ActivityButton`, we are interested in `TapGestureRecognizer`. Since the
    action to take is undefined until this control is used on a view, `TapGestureRecognizer`
    will invoke a command when `Frame` is tapped. Add the following XAML to the `Frame`
    element to create `TapGestureRecognizer`:'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `ActivityButton`，我们关注的是 `TapGestureRecognizer`。由于在此控件在视图中使用之前，要执行的操作尚未定义，因此当
    `Frame` 被点击时，`TapGestureRecognizer` 将调用一个命令。将以下 XAML 添加到 `Frame` 元素以创建 `TapGestureRecognizer`：
- en: '[PRE86]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `Command` attribute and the `CommandParameter` attribute of `TapGestureRecognizer`
    are set to bind to the parent controls’ `Command` and `CommandParameter` properties.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TapGestureRecognizer` 的 `Command` 属性和 `CommandParameter` 属性设置为绑定到父控件的 `Command`
    和 `CommandParameter` 属性。'
- en: 'If the `IsRunning` property is `true`, then `Frame` should be disabled, and
    the reverse is true as well. `DataTrigger` is a XAML way of setting properties
    of one control based on changes in another control’s properties. To add the triggers
    for `Frame`, add the highlighted XAML to the control:'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `IsRunning` 属性为 `true`，则 `Frame` 应该被禁用，反之亦然。`DataTrigger` 是一种 XAML 方法，用于根据另一个控件属性的变化设置一个控件的属性。要为
    `Frame` 添加触发器，请将突出显示的 XAML 添加到控件：
- en: '[PRE87]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'That concludes the XAML portion of the control. Open the `ActivityButton.xaml.cs`
    file and we can add the missing properties, starting with `CommandParameter`:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了控件的XAML部分。打开`ActivityButton.xaml.cs`文件，我们可以添加缺失的属性，从`CommandParameter`开始：
- en: '[PRE88]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Add the previous code listing to the `ActivityButton` class. Other than the
    name, there isn’t anything significant about this property from the `Command`
    property. `CommandParameter` allows you to specify parameters to pass to `Command`,
    but using XAML.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将前面的代码列表添加到`ActivityButton`类中。除了名称外，这个属性与`Command`属性没有显著的不同。`CommandParameter`允许你通过XAML指定传递给`Command`的参数。
- en: 'The `Label` control is populated from the `Text` property. To add the `Text`
    property, add the following code to the `ActivityButton` class:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Label`控件是从`Text`属性填充的。要添加`Text`属性，请将以下代码添加到`ActivityButton`类中：'
- en: '[PRE89]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the case of the `Text` property, `returnType` has changed to `string`, but
    otherwise, it’s similar to `Command` and `CommandParameter`.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`Text`属性的情况下，`returnType`已更改为`string`，但除此之外，它与`Command`和`CommandParameter`类似。
- en: 'The next property we need to implement is the `IsRunning` property, as follows:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来需要实现的是`IsRunning`属性，如下所示：
- en: '[PRE90]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To allow the size and font of the text to be changed, we implement the `FontSize`
    and `FontFamily` properties:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许更改文本的大小和字体，我们实现了`FontSize`和`FontFamily`属性：
- en: '[PRE91]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: That completed `ActivityButton`. We will use `ActivityButton` in the *Creating
    the Connect view* section right after we create the images we need for the game.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了`ActivityButton`。在我们创建游戏所需的图像之后，我们将立即在*创建连接视图*部分使用`ActivityButton`。
- en: Creating images using Bing Image Creator
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Bing图片创建器创建图像
- en: 'There are a few images that are used in the game. They are as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中使用了几个图像。它们如下所示：
- en: A horizontal stick
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根水平的棍子
- en: A vertical stick
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根垂直的棍子
- en: A pile of stones
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一堆石头
- en: Creating these images can be quite time-consuming and, based on your artistic
    abilities, not quite what you expected. It is quite possible that for your app
    you may opt to hire a graphics designer or artist to create your digital assets
    for you. Recently, a new option has become available, and that is to use AI to
    generate images. In this section, we will look at how to use **Bing Image Creator**
    to create the images that are needed for the game.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些图像可能相当耗时，并且根据你的艺术能力，可能并不完全符合你的预期。对于你的应用程序，你可能选择雇佣图形设计师或艺术家为你创建数字资产。最近，出现了一个新的选项，那就是使用AI生成图像。在本节中，我们将探讨如何使用**Bing
    Image Creator**来创建游戏所需的图像。
- en: Bing Image Creator uses an English description of the scene that you would like
    to see and attempts to create it. There are a few keywords that you can use to
    direct the Image Creator in the artistic style of the image to create, such as
    *game art*, *digital art*, or *photorealistic*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Bing图片创建器使用你想要看到的场景的英文描述，并尝试创建它。你可以使用一些关键词来指导图片创建器以创建图像的艺术风格，例如*游戏艺术*、*数字艺术*或*逼真*。
- en: 'Let’s get started by creating the stick image:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建棍子图像开始：
- en: Open [https://bing.com/create](https://bing.com/create) in Microsoft Edge or
    your favorite web browser.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Microsoft Edge或你喜欢的网页浏览器中打开[https://bing.com/create](https://bing.com/create)。
- en: If asked, log in with your Microsoft account. This can be the same account that
    you used in *Chapter 9* to log in to the Azure portal.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，请使用你的Microsoft账户登录。这可以是你用于在*第9章*中登录Azure门户的相同账户。
- en: 'In the prompt box, type in the following prompt, then press **Create**:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示框中，输入以下提示，然后按**创建**：
- en: '[PRE92]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Image Creator will generate four different images based on your description.
    If you aren’t satisfied with the result, adjust the description slightly and try
    again. The more descriptive you are, the better your result. Try to get a stick
    that is nearly vertical or horizontal since it will be easier to rotate and crop
    the image. It will also look much better if it is on a bright white background.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Image Creator将根据你的描述生成四张不同的图像。如果你对结果不满意，可以稍微调整描述并再次尝试。描述越详细，结果越好。尽量创建一个几乎垂直或水平的棍子，因为它将更容易旋转和裁剪图像。如果它是在明亮的白色背景上，看起来也会更好。
- en: '![Figure 10.7 – An Image Creator sample set of images](img/B19214_10_7.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – Image Creator的图像样本集](img/B19214_10_7.jpg)'
- en: Figure 10.7 – An Image Creator sample set of images
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – Image Creator的图像样本集
- en: Once you have an image you are satisfied with, click on the image to open it
    up.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有一个满意的图片，点击图片以打开它。
- en: Click the **Download** button to save the image to your local computer.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下载**按钮将图片保存到你的本地计算机。
- en: Now, open the downloaded file in your favorite image editor. The images created
    by Image Creator are roughly 1024 x 1024, and ideally, the image should be a 3:9
    ratio, or around 300 x 900 pixels. Using your image editor tools, crop the image
    so that it is roughly 300 x 900 pixels.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您喜欢的图像编辑器中打开下载的文件。Image Creator 创建的图像大约是 1024 x 1024，理想情况下，图像应该是 3:9 的比例，或者大约
    300 x 900 像素。使用您的图像编辑器工具，裁剪图像，使其大约为 300 x 900 像素。
- en: Save the image as either `hstick.jpeg` if the stick is orientated horizontally,
    or `vstick.jpeg` if vertically, in the `Resources/Images` folder of the `SticksAndStones.App`
    project.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像保存为 `hstick.jpeg`，如果棍子是水平放置，或者保存为 `vstick.jpeg`，如果棍子是垂直放置，在 `SticksAndStones.App`
    项目的 `Resources/Images` 文件夹中。
- en: Using the same image editing tools, rotate the image 90 degrees so that it is
    the opposite orientation and save the image in the `Resources/``I``mages` folder
    as `hstick.jpeg` if the stick is now orientated horizontally, or `vstick.jpeg`
    if vertically.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的图像编辑工具，将图像旋转 90 度，使其方向相反，并将图像保存到 `Resources/``I``mages` 文件夹中，如果棍子现在是水平放置，则保存为
    `hstick.jpeg`，如果是垂直放置，则保存为 `vstick.jpeg`。
- en: 'We have nearly half of the images that we need to create. Let’s work on creating
    the stones next:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了所需创建的一半图像。让我们接下来创建石头：
- en: Open [https://bing.com/create](https://bing.com/create) in Microsoft Edge or
    your favorite web browser.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Microsoft Edge 或您喜欢的网页浏览器中打开 [https://bing.com/create](https://bing.com/create)。
- en: If asked, log in with your Microsoft account. This can be the same account that
    you used in *Chapter 9* to log in to the Azure portal.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，使用您的 Microsoft 账户登录。这可以与您在 *第 9 章* 中用于登录 Azure 门户的同一账户相同。
- en: 'In the prompt box, type in the following prompt, then press **Create**:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示框中，输入以下提示，然后按 **创建**：
- en: '[PRE93]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Work the prompt to get three stones nicely piled together, preferably on a
    white background, as shown here:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过处理提示，得到三块石头整齐堆叠在一起，最好是在白色背景上，如图所示：
- en: '![Figure 10.8 – Three stones on a white background](img/B19214_10_8.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 白色背景上的三块石头](img/B19214_10_8.jpg)'
- en: Figure 10.8 – Three stones on a white background
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 白色背景上的三块石头
- en: When you are satisfied with the generated image, click the image to open it.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您对生成的图像满意时，点击图像以打开它。
- en: Click the **Download** button to save the image to your local computer.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下载** 按钮将图像保存到您的本地计算机。
- en: Now, open the downloaded file in your favorite image editor. Since the stones
    are supposed to be a square image, we can just save the file into the `Resources/Images`
    folder as `stones.jpeg`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您喜欢的图像编辑器中打开下载的文件。由于石头应该是方形图像，我们只需将文件保存到 `Resources/Images` 文件夹中，文件名为 `stones.jpeg`。
- en: Don’t have an image editor?
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 没有图像编辑器？
- en: Don’t have a favorite image editor? If you are on Windows, Paint does the job
    nicely, or you can use Visual Studio to edit images. On macOS, you can use Preview.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 没有您喜欢的图像编辑器？如果您使用的是 Windows，Paint 可以很好地完成这项工作，或者您可以使用 Visual Studio 编辑图像。在 macOS
    上，您可以使用预览。
- en: Excellent, we now have the sticks and the stones needed to play the game, and
    that concludes the use of Image Creator to generate our game’s images. You can
    always go back to the site and review previous results, which is a nice feature.
    Now, we can move forward with creating the `Connect` view.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们现在有了玩游戏所需的棍子和石头，这也标志着 Image Creator 生成游戏图像的使用结束。您总是可以返回网站并查看以前的结果，这是一个很好的功能。现在，我们可以继续创建
    `Connect` 视图。
- en: Creating the Connect view
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建连接视图
- en: 'The `Connect` view is the first UI other than the splash screen the user is
    going to see in the app. *Figure 10**.6* provides a representation of what the
    final view will look like. The images may be different if you decide to generate
    your own of course. We will break this section into three parts. First, we will
    create the top portion of the view containing the static content, then move on
    to creating the middle portion of the view containing the entry controls, and
    then, finally, the **Connect** button. Let’s get started with the top section
    of the view by following these steps:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connect` 视图是用户在应用程序中除了启动画面外将看到的第一个 UI。*图 10**.6* 提供了最终视图的表示。如果您决定生成自己的图像，图像可能会有所不同。我们将把这个部分分为三个部分。首先，我们将创建包含静态内容的视图顶部部分，然后继续创建包含输入控制的视图中间部分，最后，创建
    **连接** 按钮。让我们通过以下步骤开始创建视图的顶部部分：'
- en: In the `SticksAndStones.App` project, create a folder named `Views`.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目中创建一个名为 `Views` 的文件夹。
- en: Right-click on the `Views` folder, select **Add**, and then click **New Item...**.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Views` 文件夹，选择 **添加**，然后点击 **新建项...**。
- en: If you are using Visual Studio 17.7 or later, click the **Show** **All** **Templates**
    button in the dialog that pops up; otherwise, move to the next step.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio 17.7 或更高版本，请点击弹出对话框中的 **显示所有模板** 按钮；否则，转到下一步。
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的 **C# Items** 节点下，选择 **.NET MAUI**。
- en: Select `ConnectView.xaml`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ConnectView.xaml`。
- en: Click **Add** to create the page.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加** 创建页面。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: '![Figure 10.9 – Adding a new .NET MAUI ContentPage (XAML)](img/B19214_10_9.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 添加新的 .NET MAUI ContentPage (XAML)](img/B19214_10_9.jpg)'
- en: Figure 10.9 – Adding a new .NET MAUI ContentPage (XAML)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 添加新的 .NET MAUI ContentPage (XAML)
- en: Change the title of the view to `Sticks &amp; Stones`. Since XAML is a dialect
    of XML, the ampersand (`&`) must be escaped as `&amp;` in the string.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图的标题更改为 `Sticks & Stones`。由于 XAML 是 XML 的方言，字符串中的 `&` 必须转义为 `&amp;`。
- en: 'Add the following highlighted namespaces to the `ContentView` element. They
    will provide us access to the classes in the `ViewModels`, `Controls`, and `Toolkit`
    namespaces:'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下突出显示的命名空间添加到 `ContentView` 元素中。它们将为我们提供访问 `ViewModels`、`Controls` 和 `Toolkit`
    命名空间中的类的能力：
- en: '[PRE94]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To make IntelliSense happy with the bindings we will be adding, define the
    view model that the view is using by adding the `x:DataType` attribute to the
    `ContentView` element, as shown:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 IntelliSense 对我们将要添加的绑定感到满意，通过在 `ContentView` 元素中添加 `x:DataType` 属性来定义视图所使用的视图模型，如下所示：
- en: '[PRE95]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We don’t want the user to use any navigation, such as the `Shell`-provided
    `Back` button, other than what is provided on this page, so disable it using the
    highlighted code in the following listing:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望用户使用任何导航，例如 `Shell` 提供的 `Back` 按钮，除了本页提供的之外，因此请使用以下列表中突出显示的代码禁用它：
- en: '[PRE96]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: <ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
- en: xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
- en: xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
- en: xmlns:controls=“clr-namespace:SticksAndStones.Controls”
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:controls=“clr-namespace:SticksAndStones.Controls”
- en: xmlns:toolkit=“http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:toolkit=“http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
- en: x:Class=“SticksAndStones.Views.ConnectView”
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x:Class=“SticksAndStones.Views.ConnectView”
- en: x:DataType=“viewModels:ConnectViewModel”
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x:DataType=“viewModels:ConnectViewModel”
- en: Title=“Sticks &amp; Stones”
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Title=“Sticks & Stones”
- en: NavigationPage.HasNavigationBar=“False”
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NavigationPage.HasNavigationBar=“False”
- en: 'Grid control that has four rows defined; add the following code within the
    ContentPage element:'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了四行的 `Grid` 控制器；在 `ContentPage` 元素内添加以下代码：
- en: '[PRE97]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`Grid` uses a `Margin` value of `40` to provide plenty of whitespace around
    the images and controls. The first row at `8` units will contain the logo for
    the app. The second row will contain the text `Sticks & Stones`. The third row
    will have the avatar image, email, and gamer tag entry controls. The final row
    will contain the `Connect` button.Recall that the `Height` units are relative,
    so row `0`, the first row, will be four times higher than row `1` and eight times
    higher than row `3`, the final row. The `*` symbol in the `Height` value indicates
    that the row can expand if needed.'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Grid` 使用 `40` 的 `Margin` 值来为图像和控制提供足够的空白。第 `8` 单位的第 `1` 行将包含应用的标志。第 `2` 行将包含文本
    `Sticks & Stones`。第 `3` 行将包含头像图像、电子邮件和游戏标签输入控件。最后一行将包含 `Connect` 按钮。记住，`Height`
    单位是相对的，所以第 `0` 行，即第一行，将是第 `1` 行的四倍高，是第 `3` 行，即最后一行的八倍高。`Height` 值中的 `*` 符号表示如果需要，该行可以扩展。'
- en: '[PRE98]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To arrange our generated images into a box-like layout, another `Grid` control
    is used. Add the following listing to the view between the `</Grid.RowDefinitions>`
    and `</``Grid>` tags:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将生成的图像排列成类似盒子的布局，我们使用另一个 `Grid` 控制器。在 `</Grid.RowDefinitions>` 和 `</Grid>`
    标签之间添加以下列表：
- en: '[PRE99]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This `Grid` control defines three rows and three columns. The content of `Grid`
    is entirely made up of `Image` controls. `Grid` is positioned in row `0` of its
    parent `Grid`. The children of the grid, the `Image` controls, are positioned
    by setting the `Grid.Row` and `Grid.Column` attributes on the `Image` control.
    The stick images use the `Aspect` attribute set to `Fill`. `Fill` allows the image
    to scale to completely fill the content area; to do so, it may not scale uniformly
    along both the *x* and *y* axis. The stones use an `Aspect` value of `AspectFit`.
    This will uniformly scale the image till at least one side fits, which may cause
    letterboxing. There are two more options for the `Aspect` property: `Center`,
    which does no scaling, and `AspectFill`, which will scale until both axes have
    filled the view, which may cause clipping.'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `Grid` 控件定义了三行和三列。`Grid` 的内容完全由 `Image` 控件组成。`Grid` 位于其父 `Grid` 的行 `0`。网格的子控件，即
    `Image` 控件，通过在 `Image` 控件上设置 `Grid.Row` 和 `Grid.Column` 属性来定位。棍子图像使用设置为 `Fill`
    的 `Aspect` 属性。`Fill` 允许图像缩放以完全填充内容区域；为此，它可能不会在 *x* 和 *y* 轴上均匀缩放。石头使用 `Aspect`
    值为 `AspectFit`。这将均匀缩放图像，直到至少一边适合，这可能会导致信封式显示。`Aspect` 属性还有两个其他选项：`Center`，它不进行缩放，和
    `AspectFill`，它将缩放直到两个轴都填满视图，这可能会导致裁剪。
- en: '`A Label` element containing the text `Connect to Sticks & Stones` is added
    to the outer `Grid` control and it’s placed in row `1`, which is the second row
    of `Grid`. Add the following code to the outer `Grid` control after the inner
    `Grid` control added in *step 11*:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部的 `Grid` 控件中添加一个包含文本 `Connect to Sticks & Stones` 的 `Label` 元素，并将其放置在行 `1`，即
    `Grid` 的第二行。在 *步骤 11* 中添加的内部 `Grid` 控件之后，将以下代码添加到外部的 `Grid` 控件中：
- en: '[PRE100]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The next section of the page contains the avatar image, gamer tag entry, and
    email entry controls. `HorizontalStackLayout` and `VerticalStackLayout` controls
    are used to arrange the controls. Add the following snippet to the outer `Grid`
    control after the `Label` control added in *step 12*:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面的下一部分包含头像图片、游戏标签输入和电子邮件输入控件。使用 `HorizontalStackLayout` 和 `VerticalStackLayout`
    控件来排列控件。在 *步骤 12* 中添加的 `Label` 控件之后，将以下代码片段添加到外部的 `Grid` 控件中：
- en: '[PRE101]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `HorizontalStackLayout` control is assigned to the `Grid` row `2`, the
    third row. It is also centered horizontally within the row. The first `VerticalStackLayout`
    arranges the controls that make up the avatar. It contains an `Image` element,
    whose source is set to an instance of `GravatarImageSource`. `GravatarImageSource`
    uses the `EmailAddress` property of `ConnectViewModel` is bound to the `Email`
    property of `GravatarImageSource`. The image will automatically update on changes
    to `EmailAddress`. The `Image` property uses the `MysteryPerson` value to provide
    a plain profile when there isn’t a Gravatar available for the email address. The
    second `VerticalStackLayout` contains two `Entry` controls: the first, for the
    gamer tag, is bound to the `Username` property of `ConnectViewModel`, and the
    second is bound to the `EmailAddress` property of `ConnectViewModel`. The `Keyboard`
    attribute determines which virtual keyboard is displayed when the focus is on
    the control. See [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard)
    for more information on customizing the keyboard.'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HorizontalStackLayout` 控件被分配到 `Grid` 的第二行，即第三行。它在该行内水平居中。第一个 `VerticalStackLayout`
    安排了组成头像的控件。它包含一个 `Image` 元素，其源设置为 `GravatarImageSource` 的实例。`GravatarImageSource`
    使用 `ConnectViewModel` 的 `EmailAddress` 属性并将其绑定到 `GravatarImageSource` 的 `Email`
    属性。当 `EmailAddress` 发生变化时，图片将自动更新。`Image` 属性使用 `MysteryPerson` 值在电子邮件地址没有可用的 Gravatar
    时提供一个简单的个人资料。第二个 `VerticalStackLayout` 包含两个 `Entry` 控件：第一个，用于游戏标签，绑定到 `ConnectViewModel`
    的 `Username` 属性，第二个绑定到 `ConnectViewModel` 的 `EmailAddress` 属性。`Keyboard` 属性确定当焦点在控件上时显示哪个虚拟键盘。有关自定义键盘的更多信息，请参阅
    [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard)。'
- en: 'The final control to add to `ConnectView` is the `Connect` button. Use the
    following snippet to add the button to the view:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加到 `ConnectView` 的最后一个控件是 `Connect` 按钮。使用以下代码片段将按钮添加到视图中：
- en: '[PRE102]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `Connect` button uses the `ActivityButton` control created in the *Creating
    the ActivityButton control*. The control is positioned in row `3`, the fourth
    row, and the `IsRunning` attribute is bound to the `ConnectViewModel.IsConnecting`
    method. The `Text` attribute of the button is bound to the `ConnectViewModel.ConnectStatus`
    property, and finally, `Command` is bound to the `ConnectViewModel.Connect` method.
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “连接”按钮使用在 *创建 ActivityButton 控件* 中创建的 `ActivityButton` 控件。控件位于第 3 行，第四行，`IsRunning`
    属性绑定到 `ConnectViewModel.IsConnecting` 方法。按钮的 `Text` 属性绑定到 `ConnectViewModel.ConnectStatus`
    属性，最后，`Command` 绑定到 `ConnectViewModel.Connect` 方法。
- en: 'Open the `MauiProgram.cs` file in the `SticksAndStones.App` project and add
    the following highlighted line to register `ConnectView` with dependency injection:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“SticksAndStones.App”项目中打开 `MauiProgram.cs` 文件，并将以下高亮行添加以使用依赖注入注册 `ConnectView`：
- en: '[PRE103]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we need to consume the `ConnectViewModel` instance through dependency
    injection and set it as the binding object. Open the `ConnectView.Xaml.cs` file
    and modify it as follows:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过依赖注入消耗 `ConnectViewModel` 实例并将其设置为绑定对象。打开 `ConnectView.Xaml.cs` 文件并按以下方式修改：
- en: '[PRE104]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Finally, we need to set `ConnectView` as the first view displayed. Open the
    `AppShell.xaml` file in the `SticksAndStones.App` project and update the contents
    of the `Shell` element as shown:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `ConnectView` 设置为第一个显示的视图。在 `SticksAndStones.App` 项目中打开 `AppShell.xaml`
    文件，并更新 `Shell` 元素的内容，如所示：
- en: '[PRE105]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The first of the three views in the app is complete. To test it out, follow
    these steps:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的三个视图中的第一个已经完成。要测试它，请按照以下步骤操作：
- en: In Visual Studio, right-click the `SticksAndStones.Functions` project in **Solution
    Explorer**, then select **Debug** | **Start** **Without Debugging**.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，在 **解决方案资源管理器** 中右键单击 `SticksAndStones.Functions` 项目，然后选择
    **调试** | **不调试启动**。
- en: In `SticksAndStones.App` project and select **Set as** **Startup Project**.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目中，选择 **设置为** **启动项目**。
- en: Press *F5* to start the `SticksAndStones.App` project using the debugger.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *F5* 启动 `SticksAndStones.App` 项目，使用调试器。
- en: The `Lobby` page, which will allow us to start games with other players.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: “大厅”页面，它将允许我们与其他玩家开始游戏。
- en: Creating the Lobby page
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建大厅页面
- en: The `Lobby` page displays the list of connected players and allows a player
    to challenge another to a match. As additional players connect to the server,
    they are added to the list of available players. *Figure 10**.10* shows the two
    views for the page, one with connected players, and the empty view when there
    are no additional players connected.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: “大厅”页面显示已连接玩家的列表，并允许玩家向其他玩家发起比赛挑战。随着更多玩家连接到服务器，他们将被添加到可用玩家列表中。*图 10.10* 显示了页面的两个视图，一个包含已连接玩家，另一个在没有其他玩家连接时为空视图。
- en: '![Figure 10.10 – The Lobby views](img/B19214_10_10.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 大厅视图](img/B19214_10_10.jpg)'
- en: Figure 10.10 – The Lobby views
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 大厅视图
- en: Each player is displayed on a card with their avatar image, gamer tag, status,
    and a button to allow the player to challenge the other to a match.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 每个玩家都显示在一个卡片上，其中包含他们的头像图像、游戏标签、状态以及一个按钮，允许玩家向其他玩家发起比赛挑战。
- en: This page is comprised of two `ViewModel` classes, not one. As you might expect,
    there is the `LobbyViewModel` class, the `LobbyViewModel` which class has a collection
    of `PlayerViewModel` instances. In addition to the `ViewModel` classes, there
    is the `LobbyView` class. Let’s get started by creating the `PlayerViewModel`
    class.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面由两个 `ViewModel` 类组成，而不是一个。正如你可能预期的，有一个 `LobbyViewModel` 类，该类有一个 `PlayerViewModel`
    实例的集合。除了 `ViewModel` 类之外，还有一个 `LobbyView` 类。让我们从创建 `PlayerViewModel` 类开始。
- en: Adding PlayerViewModel
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 PlayerViewModel
- en: '`PlayerViewModel` is very much like all our other `ViewModel` classes but with
    one slight difference: it isn’t bound directly to a view in the same way. Otherwise,
    it has the same purpose: abstract the model, in this case, `Player`, away from
    the UI that displays it. `PlayerViewModel` provides all the needed binding properties
    to display each individual player card in `LobbyView`. To add `PlayerViewModel`,
    follow these steps:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerViewModel` 与我们所有的其他 `ViewModel` 类非常相似，但有一点细微的区别：它没有直接绑定到视图。否则，它具有相同的目的：抽象模型，在这种情况下是
    `Player`，从显示它的 UI 中分离出来。`PlayerViewModel` 提供了显示每个单个玩家卡片在 `LobbyView` 中所需的所有绑定属性。要添加
    `PlayerViewModel`，请按照以下步骤操作：'
- en: In the `SticksAndStones.App` project, under the `ViewModels` folder, create
    a new class named `PlayerViewModel`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目中，在 `ViewModels` 文件夹下创建一个名为 `PlayerViewModel` 的新类。
- en: 'Add the following namespaces to the top of the file:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命名空间添加到文件顶部：
- en: '[PRE106]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Add the following code to the class:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE107]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This adds two `private` fields to hold the values of the arguments passed to
    the constructor. As with `ConnectViewModel`, the constructor arguments are provided
    by dependency injection.
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为构造函数传入的参数值添加两个 `private` 字段。与 `ConnectViewModel` 类似，构造函数的参数由依赖注入提供。
- en: 'The player card displays the player’s gamer tag, avatar, and status. Add the
    following code to the `PlayerViewModel` class to add the `Id` and `GamerTag` properties:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家卡片显示玩家的游戏标签、头像和状态。将以下代码添加到 `PlayerViewModel` 类中，以添加 `Id` 和 `GamerTag` 属性：
- en: '[PRE108]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: For `PlayerViewModel`, some of the properties that we bind to are not implemented
    with `ObservablePropertyAttribute`. That is because we are providing their values
    from the `Player` model directly. So, the `get` method of the property just returns
    the corresponding property of the model object. There is no defined `set` method,
    so this property is essentially a one-way data binding.
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `PlayerViewModel`，我们绑定的一些属性并没有使用 `ObservablePropertyAttribute` 实现。这是因为我们直接从
    `Player` 模型提供它们的值。因此，属性的 `get` 方法只是返回模型对象的相应属性。没有定义的 `set` 方法，所以这个属性本质上是一个单向数据绑定。
- en: 'The `Status` property is a little different since it does not exist on our
    `Player` model. The `Status` property is a textual indication of whether the player
    is in a match or not. The `Player` model does have a `MatchId` property, so if
    the `Player` model has a valid `MatchId` (i.e., not `Guid.Empty`), then the status
    would be `"In a match"`; otherwise, that status would be `"Waiting for opponent"`.
    Add the following code to `PlayerViewModel` to implement the `Status` property:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Status` 属性有一点不同，因为它不在我们的 `Player` 模型上存在。`Status` 属性是玩家是否在比赛中的文本指示。`Player`
    模型确实有一个 `MatchId` 属性，所以如果 `Player` 模型有一个有效的 `MatchId`（即，不是 `Guid.Empty`），则状态将是
    `"In a match"`；否则，该状态将是 `"Waiting for opponent"`。将以下代码添加到 `PlayerViewModel` 以实现
    `Status` 属性：'
- en: '[PRE109]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `IsInMatch` property is used to simplify the `Status` property implementation.
    It will also be used later in the class. The `Status` property is a simple switch
    on `IsInMatch` and returns the proper `string` value.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IsInMatch` 属性用于简化 `Status` 属性的实现。它也将在类中稍后使用。`Status` 属性是一个简单的基于 `IsInMatch`
    的开关，并返回适当的 `string` 值。'
- en: 'To add a command to handle the `Challenge` button, add the following code to
    the `PlayerViewModel` class:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加一个处理 `Challenge` 按钮的命令，将以下代码添加到 `PlayerViewModel` 类中：
- en: '[PRE110]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The command is prevented from executing while it is currently waiting for a
    challenge response, which makes sense – no need to nag the other player. The `IsChallenging`
    property is set to `true` while challenging and `false` when it is complete. The
    `CanChallenge` property is a combination of `IsInMatch` and `IsChallenging`, meaning
    that you can’t challenge the same player while you have an existing challenge
    in progress, and you can’t challenge a player who is already in a match with another
    player. `ChallengeStatus`, which is used as the text for the button, is bound
    to the `IsChallenging` value and updates when that property is updated. You may
    have noticed that our command takes a single parameter. This is used to operate
    on the correct player.
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当命令正在等待挑战响应时，它会阻止执行，这是有道理的——没有必要催促其他玩家。在挑战期间，`IsChallenging` 属性设置为 `true`，完成时设置为
    `false`。`CanChallenge` 属性是 `IsInMatch` 和 `IsChallenging` 的组合，这意味着你不能在有现有挑战进行时挑战同一玩家，也不能挑战已经与其他玩家进行比赛的玩家。用作按钮文本的
    `ChallengeStatus` 绑定到 `IsChallenging` 值，并在该属性更新时更新。你可能已经注意到我们的命令只接受一个参数。这是用来操作正确玩家的。
- en: That completes `PlayerViewModel`. Next, `LobbyViewModel` is used to encapsulate
    the collection of `PlayerViewModel` objects.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `PlayerViewModel` 的实现。接下来，使用 `LobbyViewModel` 来封装 `PlayerViewModel` 对象集合。
- en: Adding LobbyViewModel
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 LobbyViewModel
- en: '`LobbyViewModel` is a fairly straightforward implementation. It has a collection
    of `PlayerViewModel` objects that are exposed to the UI, it allows the user to
    pull to refresh the view, and it handles the messages of `ChallengeReceived`,
    `MatchStarted`, and `ServiceError`. Follow these steps to implement `LobbyViewModel`:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`LobbyViewModel` 的实现相当直接。它有一个暴露给 UI 的 `PlayerViewModel` 对象集合，允许用户下拉刷新视图，并处理
    `ChallengeReceived`、`MatchStarted` 和 `ServiceError` 消息。按照以下步骤实现 `LobbyViewModel`：'
- en: In the `SticksAndStones.App` project, inside the `ViewModels` folder, create
    a new class named `LobbyViewModel`.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目中，在 `ViewModels` 文件夹内，创建一个名为 `LobbyViewModel` 的新类。
- en: 'Add the following namespaces to the top of the file:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命名空间添加到文件顶部：
- en: '[PRE111]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Modify the class declaration to a `public partial` class that inherits from
    `ViewModelBase`, as shown:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类声明修改为从 `ViewModelBase` 继承的 `public partial` 类，如下所示：
- en: '[PRE112]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: private readonly GameService gameService;
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly GameService gameService;
- en: public ObservableCollection<PlayerViewModel> Players { get; init; }
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public ObservableCollection<PlayerViewModel> Players { get; init; }
- en: public LobbyViewModel(GameService gameService)
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public LobbyViewModel(GameService gameService)
- en: '{'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: this.gameService = gameService;
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: this.gameService = gameService;
- en: Players = new(from p in gameService.Players
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Players = new(from p in gameService.Players
- en: where p.Id != gameService.CurrentPlayer.Id
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: where p.Id != gameService.CurrentPlayer.Id
- en: select new PlayerViewModel(p, gameService));
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: select new PlayerViewModel(p, gameService));
- en: CanRefresh = true;
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CanRefresh = true;
- en: IsActive = true;
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IsActive = true;
- en: '}'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE113]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `GameService.Players` list will be updated as players connect to the server.
    However, these changes do not get propagated to the `LobbyViewModel.Players` collection
    automatically. By implementing a handler for the `CollectionChanged` event of
    the `GameService.Players` property, we can then update the `LobbyViewModel.Players`
    collection appropriately. Add the following method to the `LobbyViewModel` class:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着 `GameService.Players` 列表中的玩家连接到服务器，该列表将更新。然而，这些更改不会自动传播到 `LobbyViewModel.Players`
    集合。通过实现 `GameService.Players` 属性的 `CollectionChanged` 事件的处理程序，我们可以相应地更新 `LobbyViewModel.Players`
    集合。向 `LobbyViewModel` 类添加以下方法：
- en: '[PRE114]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `OnPlayersCollectionChanged` method is an implementation of `Notify` **CollectionChangedEventHandler**.
    It is called by the `Observable` **Collection.CollectionChanged** event. The event
    is called whenever an item in the collection is added, removed, or updated. It
    is also called when the entire collection is cleared. This method handled the
    `NotifyCollectionChangedAction` values of `Add`, `Remove`, and `Reset`.
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OnPlayersCollectionChanged` 方法是 `Notify` **CollectionChangedEventHandler**
    的实现。它由 `Observable` **Collection.CollectionChanged** 事件调用。每当集合中的项目被添加、删除或更新时，都会调用此事件。当整个集合被清除时，也会调用此事件。此方法处理
    `NotifyCollectionChangedAction` 的 `Add`、`Remove` 和 `Reset` 值。'
- en: 'The `Players.CollectionChanged` event is assigned to the `OnPlayers` **CollectionChanged**
    method in the `OnActivated` event handler. Add the `OnActivated` and `OnDeactivated`
    methods using the following listing:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnActivated` 事件处理程序中，将 `Players.CollectionChanged` 事件分配给 `OnPlayers` **CollectionChanged**
    方法。使用以下代码添加 `OnActivated` 和 `OnDeactivated` 方法：
- en: '[PRE115]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the `OnActivated` method, the `CollectionChanged` event is assigned to the
    `OnPlayersCollectionChanged` method and unassigned in the `OnDeactivated` method.
    In `OnActivated`, there is also a check to see whether the player is already in
    a match. If they are, then the app navigates to the `Match` view immediately.
    When navigating to the `Match` view, we send an argument for `Match`. This will
    be either the `MatchId` or the `Match` model.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `OnActivated` 方法中，将 `CollectionChanged` 事件分配给 `OnPlayersCollectionChanged`
    方法，并在 `OnDeactivated` 方法中取消分配。在 `OnActivated` 中，还有一个检查以查看玩家是否已经在比赛中。如果是，则应用程序立即导航到
    `Match` 视图。在导航到 `Match` 视图时，我们发送一个 `Match` 参数。这将要么是 `MatchId`，要么是 `Match` 模型。
- en: 'Open the `Constants.cs` file in the `SticksAndStones.Shared` project to add
    the following code snippet to the `Constants` class:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SticksAndStones.Shared` 项目的 `Constants.cs` 文件，将以下代码片段添加到 `Constants` 类中：
- en: '[PRE116]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'While in the Lobby, there are three messages that need to be handled: `ChallengeReceived`,
    `MatchStarted`, and `ServerError`. Add the code in the following listing to add
    the handlers for each of these messages:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大厅中，有三个消息需要处理：`ChallengeReceived`、`MatchStarted` 和 `ServerError`。将以下代码添加到每个消息的处理程序中：
- en: '[PRE117]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In `OnChallengeReceived`, the user is prompted to accept or decline the challenge.
    Their response is then sent to the challenger via the `SendChallengeResponse`
    method of the `GameService` class. `OnMatchStarted` will navigate the user to
    the `Match` view. Finally, `OnServiceError` will display the error to the user.
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `OnChallengeReceived` 中，用户被提示接受或拒绝挑战。然后，他们的响应通过 `GameService` 类的 `SendChallengeResponse`
    方法发送给挑战者。`OnMatchStarted` 将用户导航到 `Match` 视图。最后，`OnServiceError` 将错误显示给用户。
- en: 'Add the following snippet to the top of the `OnActivated` method to register
    to receive the messages:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnActivated` 方法的顶部添加以下代码片段以注册接收消息：
- en: '[PRE118]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Add the following snippet to the end of the `OnDecactived` method to stop receiving
    messages:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnDeactivated` 方法的末尾添加以下代码片段以停止接收消息：
- en: '[PRE119]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To refresh the `Players` list when the user pulls down on the list in the UI,
    add the following method to the `LobbyViewModel` class:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在 UI 中下拉列表时刷新 `Players` 列表，请向 `LobbyViewModel` 类添加以下方法：
- en: '[PRE120]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '`LobbyViewModel` needs to be registered with dependency injection, so open
    the `MauiProgram.cs` file and add the following highlighted line of code:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LobbyViewModel` 需要使用依赖注入进行注册，因此打开 `MauiProgram.cs` 文件并添加以下高亮显示的代码行：'
- en: '[PRE121]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '`LobbyViewModel` is now complete, and it is time to create the view!'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`LobbyViewModel` 现在已经完成，现在是时候创建视图了！'
- en: Adding the Lobby view
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加大厅视图
- en: '`The Lobby` view simply displays a list of connected players with their avatar,
    gamertag and current status. To build the `LobbyView` follow these steps:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`The Lobby` 视图简单地显示连接玩家的列表，包括他们的头像、游戏标签和当前状态。要构建 `LobbyView`，请按照以下步骤操作：'
- en: Right-click on the `Views` folder of the `SticksAndStone.App` project, select
    **Add**, and then click **New Item...**.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `SticksAndStone.App` 项目的 `Views` 文件夹，选择 **添加**，然后点击 **新建项...**。
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up; otherwise, move to the next step.
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio 17.7 或更高版本，请点击弹出对话框中的 **显示所有模板** 按钮；否则，转到下一步。
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的 **C# 项** 节点下，选择 **.****NET MAUI**。
- en: Select `LobbyView.xaml`.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `LobbyView.xaml`。
- en: Click **Add** to create the page.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加** 创建页面。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下截图查看前面的信息：
- en: '![](img/B19214_10_11.jpg)'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19214_10_11.jpg)'
- en: Figure 10.11 – Adding a new .NET MAUI ContentPage (XAML)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 添加新的 .NET MAUI 内容页 (XAML)
- en: 'Open the `LobbyView.xaml.cs` file and add the following `using` declaration:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `LobbyView.xaml.cs` 文件并添加以下 `using` 声明：
- en: '[PRE122]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Make the following highlighted changes to the constructor:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对构造函数进行以下高亮显示的更改：
- en: '[PRE123]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: These changes allow for dependency injection to supply the `LobbyViewModel`
    instance to the view, which is then assigned to `BindingContext`.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些更改允许依赖注入提供 `LobbyViewModel` 实例给视图，然后将其分配给 `BindingContext`。
- en: 'Open the `AppShell.xaml` file and add the following code snippet to the `ContentPage`
    element:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AppShell.xaml` 文件并将以下代码片段添加到 `ContentPage` 元素中：
- en: '[PRE124]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This registers the `"Lobby"` route and directs it to `LobbyView`.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将注册 `"Lobby"` 路由并将其指向 `LobbyView`。
- en: 'Open the `MauiProgram.cs` file and add the following highlighted line of code:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 文件并添加以下高亮显示的代码行：
- en: '[PRE125]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This will register `LobbyView` with dependency injection so that `DataTemplate`
    can locate it.
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使用依赖注入注册 `LobbyView`，以便 `DataTemplate` 可以定位它。
- en: Open the `LobbyView.xaml` file and change the `Title` attribute of the `ContentPage`
    element to `"Lobby"`.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `LobbyView.xaml` 文件并将 `ContentPage` 元素的 `Title` 属性更改为 `"Lobby"`。
- en: 'Add the following highlighted namespaces to the `LobbyView` element; they will
    provide us access to the classes in the `ViewModels`, `Controls`, and `Toolkit`
    namespaces:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下高亮显示的命名空间添加到 `LobbyView` 元素中；它们将为我们提供访问 `ViewModels`、`Controls` 和 `Toolkit`
    命名空间中的类：
- en: '[PRE126]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'To make IntelliSense happy with the bindings we will be adding, define the
    view model that the view is using by adding the `x:DataType` attribute to the
    `LobbyView` element, as shown:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 IntelliSense 对我们将要添加的绑定感到满意，通过在 `LobbyView` 元素中添加 `x:DataType` 属性来定义视图所使用的视图模型，如下所示：
- en: '[PRE127]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We don’t want the user to use any navigation, such as the `Shell`-provided
    `Back` button, other than what is provided on this page, so disable it using the
    highlighted code in the following listing:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望用户使用任何导航，例如此页面上提供的 `Shell` 提供的 `Back` 按钮，因此使用以下列表中的高亮代码禁用它：
- en: '[PRE128]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: <ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
- en: xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
- en: xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
- en: xmlns:controls=“clr-namespace:SticksAndStones.Controls”
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:controls=“clr-namespace:SticksAndStones.Controls”
- en: xmlns:toolkit=“ http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xmlns:toolkit=“ http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
- en: x:Class=“SticksAndStones.Views.ConnectView”
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x:Class=“SticksAndStones.Views.ConnectView”
- en: x:DataType=“viewModels:ConnectViewModel”
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x:DataType=“viewModels:ConnectViewModel”
- en: Title=“ConnectView”
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Title=“ConnectView”
- en: NavigationPage.HasNavigationBar=“False”
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NavigationPage.HasNavigationBar=“False”
- en: 'ContentPage with the following code snippet:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含以下代码片段的内容页：
- en: '[PRE129]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: For `LobbyView`, there is a vertical scrolling list of players. The root element
    is `RefreshView`. Its `IsRefreshing` attribute is bound to the `IsRefreshing`
    property of `LobbyViewModel`. `The` `Command` attribute for `RefreshView` is bound
    to `RefreshCommand`, which will end up executing the `RefreshInternal` method
    of `LobbyViewModel`. `IsRefreshing` and `RefreshCommand` are implemented in the
    `BaseViewModel` class. Inside `RefreshView` is `ScrollView`, which provides scrolling
    capability to have a large list. Inside `ScrollView` is `CollectionView`, which
    will display each `Player` instance as an individual item, so `ItemsSource` is
    bound to the `Players` property of `LobbyViewModel`. As there is no real need
    to select individual `Player` items, `SelectionMode` is set to `none`.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `LobbyView`，有一个垂直滚动的玩家列表。根元素是 `RefreshView`。它的 `IsRefreshing` 属性绑定到 `LobbyViewModel`
    的 `IsRefreshing` 属性。`RefreshView` 的 `Command` 属性绑定到 `RefreshCommand`，这将最终执行 `LobbyViewModel`
    的 `RefreshInternal` 方法。`IsRefreshing` 和 `RefreshCommand` 在 `BaseViewModel` 类中实现。在
    `RefreshView` 内部是 `ScrollView`，它提供了滚动能力以显示长列表。在 `ScrollView` 内部是 `CollectionView`，它将显示每个
    `Player` 实例作为一个单独的项目，因此 `ItemsSource` 绑定到 `LobbyViewModel` 的 `Players` 属性。由于没有真正需要选择单个
    `Player` 项目，`SelectionMode` 设置为 `none`。
- en: '[PRE130]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'When the list is empty, it is nice to display something to the user so that
    they aren’t left wondering what happened. `CollectionView` has an `EmptyView`
    property that is used to configure what is displayed when there are no items.
    Add the following code snippet immediately following the `ContentPage` start opening
    tag:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当列表为空时，向用户显示一些内容是很好的，这样他们就不会感到困惑。`CollectionView` 有一个 `EmptyView` 属性，用于配置在没有任何项目时显示的内容。在
    `ContentPage` 开始打开标签后立即添加以下代码片段：
- en: '[PRE131]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This defines a page resource containing `ContentView` with a `Key` value of
    `"BasicEmptyView"`. The view contains `StackLayout`, which has `Label` as a child
    with the text `"No players available"`. Appropriate styling is applied to make
    sure it’s large enough and has enough surrounding whitespace.
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这定义了一个包含 `ContentView` 的页面资源，其 `Key` 值为 `"BasicEmptyView"`。视图包含 `StackLayout`，其中有一个
    `Label` 子元素，其文本为 `"No players available"`。应用适当的样式以确保它足够大，并且有足够的周围空白。
- en: 'Add the following attribute to the `CollectionView` element:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `CollectionView` 元素添加以下属性：
- en: '[PRE132]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'This binds `BasicEmptyView` to the `EmptyView` property of `CollectionView`.
    *Figure 10**.12* shows the result if you run the app and log in:'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将 `BasicEmptyView` 绑定到 `CollectionView` 的 `EmptyView` 属性。*图 10**.12* 展示了运行应用并登录后的结果：
- en: '![Figure 10.12 – Lobby with no players](img/B19214_10_12.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 没有玩家的大厅](img/B19214_10_12.jpg)'
- en: Figure 10.12 – Lobby with no players
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 没有玩家的大厅
- en: 'The player card will also use a static resource, which just makes the file
    a little easier to read, and less indenting. Add the following code snippet to
    the `ContentView.Resources` element, under the `BasicEmptyView` element:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家卡片也将使用静态资源，这仅仅使文件更容易阅读，并且减少了缩进。在 `ContentView.Resources` 元素下，在 `BasicEmptyView`
    元素下添加以下代码片段：
- en: '[PRE133]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '`DataTemplate` will display the player’s avatar. To do so, it will use an `Image`
    control and `GravatarImageSource` the same way as was done in the *Creating the
    Connect view* section. A `DataTemplate` element is needed since this is used for
    `ItemTemplate`, then the obligatory `ContentView`. Then, `Border` is defined.
    It uses a special `Stroke` shape to round out the edges of the rectangle instead
    of having square corners, and a color of `AntiqueWhite` is applied as the `BackgroundColor`
    value. Additional shapes to use for `Border` include `Ellipse`, `Line`, `Path`,
    `Polygon`, `Polyline`, and `Rectangle`. See the `Border` documentation at [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border)
    for more details. Inside `Border`, there is a `Grid` control that defines three
    columns. The first column contains the avatar image and has a width of `50`, the
    next column contains the gamer tag and the status of the player, stacked vertically,
    and the third column contains the `Challenge` button.'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataTemplate` 将显示玩家的头像。为此，它将使用 `Image` 控件和 `GravatarImageSource`，就像在 *创建连接视图*
    部分中所做的那样。需要一个 `DataTemplate` 元素，因为这是用于 `ItemTemplate` 的，然后是必选的 `ContentView`。然后定义
    `Border`。它使用特殊的 `Stroke` 形状来使矩形的边缘圆润，而不是有直角，并将 `AntiqueWhite` 作为 `BackgroundColor`
    值应用。可用于 `Border` 的其他形状包括 `Ellipse`、`Line`、`Path`、`Polygon`、`Polyline` 和 `Rectangle`。有关更多详细信息，请参阅
    [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border)。在
    `Border` 内部有一个 `Grid` 控件，它定义了三列。第一列包含头像图像，宽度为 `50`，下一列包含玩家的游戏标签和状态，垂直堆叠，第三列包含
    `Challenge` 按钮。'
- en: For the avatar, the `AvatarView` control from `CommunityToolkit` is used. It
    provides a round version of the image.
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于头像，使用来自 `CommunityToolkit` 的 `AvatarView` 控件。它提供图像的圆形版本。
- en: The `Challenge` button uses the `ActivityButton` control, and is bound to the
    `IsChallenging`, `CanChallenge`, `ChallengeStatus`, and `ChallengeCommand` properties
    of `PlayerViewModel`.
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Challenge` 按钮使用 `ActivityButton` 控件，并将其绑定到 `PlayerViewModel` 的 `IsChallenging`、`CanChallenge`、`ChallengeStatus`
    和 `ChallengeCommand` 属性。'
- en: 'To use `PlayerCardViewTemplate` as `ItemTemplate` of `CollectionView`, add
    the following attribute to the `CollectionView` element:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `PlayerCardViewTemplate` 作为 `CollectionView` 的 `ItemTemplate`，请向 `CollectionView`
    元素添加以下属性：
- en: '[PRE134]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: That completes the `Lobby` page. At this point, you should be able to launch
    `SticksAndStone.Functions` and connect with the `SticksAndStones.App` project
    to see the different layouts provided by the `Lobby` view. There is only one more
    page to create to complete the game, and that is the `Match` page.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了 `Lobby` 页面。到这一点，你应该能够启动 `SticksAndStone.Functions` 并连接到 `SticksAndStones.App`
    项目，以查看 `Lobby` 视图提供的不同布局。还需要创建一个页面来完成游戏，那就是 `Match` 页面。
- en: Creating the Match page
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建比赛页面
- en: The `Match` page displays the game board with the players and score. It also
    manages the gameplay, allowing each player to take their turn placing a stick.
    As each player takes their turn, the board updates to show the current state of
    the match. Let’s get started with creating the `ViewModel` classes.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`Match` 页面显示带有玩家和分数的游戏板。它还管理游戏玩法，允许每个玩家轮流放置棍子。每个玩家轮流时，板会更新以显示比赛的当前状态。让我们开始创建
    `ViewModel` 类。'
- en: Creating the ViewModel classes
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 ViewModel 类
- en: There are two different `ViewModel` classes used in the `Match` page, just as
    there were in the `Lobby` page, one for the game and a second for the player details.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Match` 页面中使用了两个不同的 `ViewModel` 类，就像在 `Lobby` 页面中一样，一个用于游戏，另一个用于玩家详细信息。
- en: Adding MatchPlayerViewModel
  id: totrans-609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加 MatchPlayerViewModel
- en: '`MatchPlayerViewModel` is the abstraction between the `Player` model and `MatchView`.
    `MatchPlayerViewModel` needs to expose the `Id`, `GamerTag`, and `EmailAddress`
    values from the `Player` model to `MatchView`. In addition, since each player
    has a score, the player’s score from the `Match` model is exposed to `MatchView`.
    There are a couple of additional properties that are needed as well:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`MatchPlayerViewModel` 是 `Player` 模型和 `MatchView` 之间的抽象。`MatchPlayerViewModel`
    需要向 `MatchView` 暴露 `Player` 模型中的 `Id`、`GamerTag` 和 `EmailAddress` 值。此外，由于每个玩家都有一个分数，因此
    `Match` 模型中玩家的分数也暴露给 `MatchView`。还需要一些额外的属性：'
- en: '`IsPlayersTurn`:'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsPlayersTurn`:'
- en: This is used to determine whether `MatchPlayerViewModel` is the current player.
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这用于确定 `MatchPlayerViewModel` 是否是当前玩家。
- en: '`PlayerToken`:'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerToken`:'
- en: This is used to map each player to a token to track which player has placed
    which stick. A token, either `-1` or `1`, is used because it makes determining
    a winner easier than if it was using the `Id` property, which is a `Guid`. Review
    the *Processing turns section of* *Chapter 9*, for a refresher on how the winner
    is determined.
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这用于将每个玩家映射到一个令牌，以跟踪哪个玩家放置了哪个木棍。使用 `-1` 或 `1` 的令牌，因为这样比使用 `Id` 属性（它是 `Guid` 类型）更容易确定赢家。回顾第
    9 章的 *处理回合部分*，以刷新如何确定赢家。
- en: 'To create `MatchPlayerViewModel`, follow these steps:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `MatchPlayerViewModel`，请按照以下步骤操作：
- en: Create a new class named `MatchPlayerViewModel` in the `ViewModels` folder of
    the `SticksAndStones.App` project.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `ViewModels` 文件夹中创建一个名为 `MatchPlayerViewModel` 的新类。
- en: 'Modify the `using` declarations to the following at the top of the file:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `using` 声明修改为文件顶部的以下内容：
- en: '[PRE135]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Add the `public` and `partial` modifiers to the class and make it inherit from
    `ObservableObject`, as shown:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `public` 和 `partial` 修饰符添加到类中，并使其继承自 `ObservableObject`，如下所示：
- en: '[PRE136]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '`MatchPlayerViewModel` is an abstraction of both the `Player` and `Match` models,
    which will be passed in through the constructor. Create the fields and the constructor,
    as shown in the following listing:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MatchPlayerViewModel` 是 `Player` 和 `Match` 模型的抽象，将通过构造函数传入。创建字段和构造函数，如下所示列表所示：'
- en: '[PRE137]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `PlayerToken` property is `1` if the `Player` model is `PlayerOne` in the
    `Match` model; otherwise, it is `-1`. Add the `PlayerToken` property using as
    shown here:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `Player` 模型在 `Match` 模型中是 `PlayerOne`，则 `PlayerToken` 属性为 `1`；否则，为 `-1`。使用以下方式添加
    `PlayerToken` 属性：
- en: '[PRE138]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `IsPlayersTurn` property will return `true` if the `Player` model is the
    `NextPlayer` of the `Match` model, as shown here:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `Player` 模型是 `Match` 模型的 `NextPlayer`，则 `IsPlayersTurn` 属性将返回 `true`，如下所示：
- en: '[PRE139]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `Id`, `GamerTag`, and `EmailAddress` properties all just map directly to
    the corresponding property from the `Player` model. This is the same implementation
    that was used in `PlayerViewModel` for the `Lobby` page. Use the following listing
    to add the properties to `MatchPlayerViewModel`:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Id`、`GamerTag` 和 `EmailAddress` 属性都直接映射到 `Player` 模型中的相应属性。这与在 `PlayerViewModel`
    中用于 `Lobby` 页面的相同实现。使用以下列表将属性添加到 `MatchPlayerViewModel` 中：'
- en: '[PRE140]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The final property that is needed for `MatchPlayerViewModel` is the `Score`
    property. The `Score` property is mapped to either the `PlayerOneScore` or `PlayerTwoScore`
    property from the `Match` model, depending on which player the `Player` model
    is. Use the following listing to add the `Score` property to `MatchPlayerViewModel`:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MatchPlayerViewModel` 需要的最后一个属性是 `Score` 属性。`Score` 属性映射到 `Match` 模型中的 `PlayerOneScore`
    或 `PlayerTwoScore` 属性，具体取决于 `Player` 模型是哪个玩家。使用以下列表将 `Score` 属性添加到 `MatchPlayerViewModel`
    中：'
- en: '[PRE141]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: That is all there is to `MatchPlayerViewModel`. The next section will walk you
    through creating `MatchViewModel`.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `MatchPlayerViewModel` 的全部内容。下一节将指导您创建 `MatchViewModel`。
- en: Adding MatchViewModel
  id: totrans-632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加 MatchViewModel
- en: '`MatchViewModel` needs to provide the functionality for all the gameplay. It
    provides the two `MatchPlayerViewModel` objects for display in the header of the
    page, and the board to display where sticks have been played and which stones
    have been captured. It also provides the needed functionality for players to take
    their turn and forfeit the game if they choose. To implement `MatchViewModel`,
    follow these steps:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`MatchViewModel` 需要提供所有游戏功能。它提供两个用于在页面标题中显示的 `MatchPlayerViewModel` 对象，以及显示已放置木棍和已捕获石头的棋盘。它还提供了玩家进行回合和选择弃权的所需功能。要实现
    `MatchViewModel`，请按照以下步骤操作：'
- en: Create a new class in the `ViewModels` folder of the `SticksAndStones.App` project
    named `MatchViewModel`.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SticksAndStones.App` 项目的 `ViewModels` 文件夹中创建一个名为 `MatchViewModel` 的新类。
- en: 'Modify the `using` declarations section at the top of the page to match the
    following listing:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改页面顶部的 `using` 声明部分，以匹配以下列表：
- en: '[PRE142]'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Add the `public` and `partial` class modifiers to the class, inherit from `ViewModelBase`,
    and implement `IQueryAttributable`, as shown:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `public` 和 `partial` 类修饰符添加到类中，继承自 `ViewModelBase` 并实现 `IQueryAttributable`，如下所示：
- en: '[PRE143]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Recall that in `ConnectViewModel` and `LobbyViewModel`, when they navigate to
    `Match`, they pass an argument – either `MatchId` or the `Match` instance itself.
    `IQueryAttributable` is how that argument is passed to `MatchViewModel`. The implementation
    for `IQueryAttributable` is provided in a later step.
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下，在 `ConnectViewModel` 和 `LobbyViewModel` 中，当它们导航到 `Match` 时，会传递一个参数——要么是
    `MatchId`，要么是 `Match` 实例本身。`IQueryAttributable` 是如何将这个参数传递给 `MatchViewModel` 的。`IQueryAttributable`
    的实现将在后续步骤中提供。
- en: '`MatchViewModel` only has a single dependency, `GameService`, so add a field
    to store the instance and a constructor to accept the instance as a parameter,
    as shown in the following listing:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MatchViewModel` 只有一个依赖项，即 `GameService`，因此添加一个字段来存储实例，并添加一个接受实例作为参数的构造函数，如下所示：'
- en: '[PRE144]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'When `MatchViewModel` is loaded, it will need to process the arguments, either
    the `Match` instance or a `MatchId` value. Either argument will end up with a
    `Match` instance that is used for displaying the board in the view, and from that,
    create two instances of `MatchPlayerViewModel` for player one and player two.
    Add `match`, `playerOne`, and `playerTwo` fields to the `MatchViewModel` class
    to hold those instances, as shown here:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `MatchViewModel` 被加载时，它需要处理参数，无论是 `Match` 实例还是 `MatchId` 值。无论哪种参数，最终都会得到一个用于在视图中显示棋盘的
    `Match` 实例，并基于此创建两个 `MatchPlayerViewModel` 实例，分别用于玩家一和玩家二。将 `match`、`playerOne`
    和 `playerTwo` 字段添加到 `MatchViewModel` 类中，以保存这些实例，如下所示：
- en: '[PRE145]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '`IQueryAttributable` is used to process the arguments passed to the view model.
    Well, it is one way of doing it. The `IQueryAttributable` interface has only one
    method defined, `ApplyQueryAttributes`. The .NET MAUI routing system will automatically
    call the `ApplyQueryAttributes` method if the view model implements the `IQueryAttributable`
    interface. To add the implementation for `IQueryAttributable`, use the following
    listing:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IQueryAttributable` 用于处理传递给视图模型的参数。嗯，这是其中一种方法。`IQueryAttributable` 接口定义了一个方法，即
    `ApplyQueryAttributes`。.NET MAUI 路由系统将自动调用 `ApplyQueryAttributes` 方法，如果视图模型实现了
    `IQueryAttributable` 接口。要添加 `IQueryAttributable` 的实现，请使用以下代码列表：'
- en: '[PRE146]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '`ApplyQueryAttributes` has a single parameter query, which is a dictionary
    of key-value pairs with the key as a string and the value as an object. The key
    ID is the name of the parameter as was passed in – for example, `"Match"` or `"MatchId"`.
    The method will check for the existence of the `"Match"` key being present and
    get the value as `Match` if it is. If the `"MatchId"` key is present, then `GameService`
    is used to get the `Match` model from `Id`. If there is no value for `match`,
    then the method returns; otherwise; initialize the two instances of `GamePlayerViewModel`
    and store them and `Match` in the `ViewModel` properties. The `LoadMatch` method
    is called from `ApplyQueryAttributes` since we will need the same functionality
    when the `UpdateMatch` event is received.'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ApplyQueryAttributes` 有一个名为 `query` 的单个参数，它是一个键值对字典，键是一个字符串，值是一个对象。键 ID 是参数的名称，如
    `"Match"` 或 `"MatchId"`。该方法将检查 `"Match"` 键是否存在，如果存在，则将其值作为 `Match` 获取。如果存在 `"MatchId"`
    键，则使用 `GameService` 从 `Id` 获取 `Match` 模型。如果没有 `match` 的值，则该方法返回；否则，初始化两个 `GamePlayerViewModel`
    实例并将它们和 `Match` 存储在 `ViewModel` 属性中。`LoadMatch` 方法是从 `ApplyQueryAttributes` 调用的，因为我们将在接收到
    `UpdateMatch` 事件时需要相同的功能。'
- en: 'Before we can allow a player to choose a location to place a stick, it must
    be their turn. Create a property named `IsCurrentPlayersTurn` using the following
    listing:'
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在允许玩家选择放置棍子的位置之前，必须是他们的回合。使用以下代码创建一个名为 `IsCurrentPlayersTurn` 的属性：
- en: '[PRE147]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Anytime the `Match` object is updated, `IsCurrentPlayersTurn` needs to be updated
    as well, since it depends on values in the `Match` property. To have this happen
    automatically, use the `NotifyPropertyChangedFor` attribute from `CommunityToolkit`.
    Add the highlighted line in the following code listing:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何时间 `Match` 对象被更新时，`IsCurrentPlayersTurn` 也需要更新，因为它依赖于 `Match` 属性中的值。为了自动执行此操作，使用来自
    `CommunityToolkit` 的 `NotifyPropertyChangedFor` 属性。在以下代码列表中添加高亮行：
- en: '[PRE148]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Now, whenever the `Match` property is changed, the `NotfiyPropertyChanged` method
    will also be called for `IsCurrentPlayersTurn`. See *the Defining a ViewModel
    base class* sectionin *Chapter 2*, for a refresher on implementing the `INotifyPropertyChanged`
    interface.
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，每当 `Match` 属性发生变化时，`NotfiyPropertyChanged` 方法也会被调用以更新 `IsCurrentPlayersTurn`。参见
    *第2章* 中的 *定义 ViewModel 基类* 部分，以复习实现 `INotifyPropertyChanged` 接口。
- en: 'The game allows the player to try out different positions of the stick before
    committing. If this is the current player’s turn, the one connected and using
    the app, then the `SelectStick` method will place a stick at the location chosen
    by the user. The choice is not sent to the server until the user clicks the `lastSelectedStick`
    field. Add the following listing to implement the `SelectStick` method:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏允许玩家在提交之前尝试不同的棒的位置。如果这是当前玩家的回合，即连接并使用应用的玩家，那么 `SelectStick` 方法将在用户选择的位置放置一根棒。选择不会发送到服务器，直到用户点击
    `lastSelectedStick` 字段。添加以下代码以实现 `SelectStick` 方法：
- en: '[PRE149]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The value of `-1` for `lastSelectedStick` is used to mean no stick. The `SelectStick`
    method is exposed as a `Command` instance via `RelayCommandAttribute`. The `Is`
    **CurrentPlayersTurn** property is used to determine whether the command can execute.
    Recall from *Chapter 9* that the `Sticks` elements will have one of three values:
    `-1` for player one, `0` for empty, and `1` for player two. After determining
    whether the stick position is valid, the method raises the `OnPropertyChanged`
    event for the `Match` property, which causes the bindings to update.'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`lastSelectedStick` 的 `-1` 值用于表示没有棒。`SelectStick` 方法通过 `RelayCommandAttribute`
    暴露为一个 `Command` 实例。使用 `Is CurrentPlayersTurn` 属性来确定命令是否可以执行。回想一下 *第 9 章*，`Sticks`
    元素将具有三个值之一：玩家一的 `-1`，空位的 `0`，以及玩家二的 `1`。在确定棒的位置是否有效后，该方法会引发 `Match` 属性的 `OnPropertyChanged`
    事件，这会导致绑定更新。'
- en: 'After deliberating on which position to place their next stick, the player
    has three options: send their move to the server and end their turn, be indecisive
    and undo their move, or give up and exit the match. Add the `Play` method to `MatchViewModel`
    using the following code snippet:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在考虑将下一根棒放在哪个位置后，玩家有三个选择：将他们的移动发送到服务器并结束他们的回合，犹豫不决并撤销他们的移动，或者放弃并退出比赛。使用以下代码片段将
    `Play` 方法添加到 `MatchViewModel`：
- en: '[PRE150]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The `Play` method is exposed as a `Command` so that it can be bound to by UI
    elements.
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Play` 方法被暴露为一个 `Command`，以便它可以被 UI 元素绑定。'
- en: 'The `Undo` method is called when the player taps the `lastSelectedStick` position
    and the value of `lastSelectedStick`. Add the `Undo` method, as shown in the following
    code listing:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家轻触 `lastSelectedStick` 位置和 `lastSelectedStick` 的值时，会调用 `Undo` 方法。添加 `Undo`
    方法，如下代码所示：
- en: '[PRE151]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Again, the `RelayCommand` attribute is applied to the method to allow it to
    be bound to by UI elements.
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，将 `RelayCommand` 属性应用于方法，以便它可以被 UI 元素绑定。
- en: 'The `Forfeit` method is called when the player uses the `Forfeit` method to
    the `MatchViewModel` class:'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当玩家使用 `Forfeit` 方法调用 `MatchViewModel` 类时，会调用 `Forfeit` 方法：
- en: '[PRE152]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'When the opposing player sends their move to the server, it is received in
    the app as a `MatchUpdated` event from the SignalR service. Add the handler for
    the `MatchUpdated` event using the following listing:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对手玩家将他们的移动发送到服务器时，它作为来自 SignalR 服务的 `MatchUpdated` 事件在应用中接收。使用以下代码添加 `MatchUpdated`
    事件的处理器：
- en: '[PRE153]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'To register the `MatchUpdated` event handler, the `Register` method is called
    from `OnActivated`, and `UnRegister` is called from `OnDeactivated`, as shown
    in the following listing:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要注册 `MatchUpdated` 事件处理器，从 `OnActivated` 中调用 `Register` 方法，从 `OnDeactivated`
    中调用 `UnRegister`，如下所示：
- en: '[PRE154]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Register `MatchViewModel` with dependency injection by adding the following
    highlighted line of code to the `CreateMauiApp` method in the `MauiProgram.cs`
    file:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `MauiProgram.cs` 文件中的 `CreateMauiApp` 方法中添加以下高亮代码行，使用依赖注入注册 `MatchViewModel`：
- en: '[PRE155]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Why is it called IQueryAttributable? That feels awkward
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么叫 IQueryAttributable？这感觉有点尴尬
- en: The reason behind the name of the interface is that naming things is hard. The
    system for passing arguments to a view model can be either declarative or not.
    The declarative way uses `QueryPropertyAttribute` to map the query parameter to
    a property on the view model. If you choose not to use the attributes, but instead
    handle the mapping yourself manually, you declare your class `IQueryAttributable`,
    as in I could have used `QueryPropertyAttribute` but I choose not to. For more
    information, visit [https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 接口名称背后的原因是命名事物很难。传递参数到视图模型的系统可以是声明性的或不声明性的。声明性方式使用 `QueryPropertyAttribute`
    将查询参数映射到视图模型上的属性。如果你选择不使用属性，而是手动处理映射，你可以声明你的类为 `IQueryAttributable`，例如，我本可以使用
    `QueryPropertyAttribute` 但我选择不这样做。更多信息，请访问 [https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data)。
- en: Adding the Match view
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 Match 视图
- en: 'This page is complex, so we are going to break it down into smaller, more manageable
    chunks. First, the basic page layout is defined including the commands that are
    available to the player: `Play`, `Undo`, and `Forfeit`. Next, the scoreboard area
    is defined with the player’s gamer tag, Gravatar, and scores. Finally, the game
    board is defined and laid out in a three-by-three grid. Let’s get started by creating
    the view and the layout.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面很复杂，所以我们将将其分解成更小、更易于管理的块。首先，定义基本页面布局，包括玩家可用的命令：`Play`、`Undo` 和 `Forfeit`。接下来，定义计分板区域，包括玩家的游戏标签、Gravatar
    和分数。最后，定义并布局游戏板，形成一个三行三列的网格。让我们开始创建视图和布局。
- en: Create the view
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'The `Match` view is not unlike any of the other views that have been created
    except that it has many more elements than preview views. Let’s get started by
    creating the view and some basic elements by following these steps:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`Match` 视图与其他创建的视图没有太大区别，除了它比预览视图有更多元素。让我们按照以下步骤开始创建视图和一些基本元素：'
- en: Right-click on the `Views` folder of the `SticksAndStone.App` project, select
    **Add**, and then click **New Item...**.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `SticksAndStone.App` 项目的 `Views` 文件夹，选择 **Add**，然后点击 **New Item...**。
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up; otherwise, move to the next step.
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio 17.7 或更高版本，请点击弹出的对话框中的 **Show all Templates** 按钮；否则，请跳到下一步。
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的 **C# Items** 节点下，选择 **.NET MAUI**。
- en: Select `MatchView`.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `MatchView`。
- en: Click **Add** to create the page.
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Add** 以创建页面。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: '![Figure 10.13 – Adding a new .NET MAUI ContentPage (XAML)](img/B19214_10_13.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 添加新的 .NET MAUI ContentPage (XAML)](img/B19214_10_13.jpg)'
- en: Figure 10.13 – Adding a new .NET MAUI ContentPage (XAML)
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 添加新的 .NET MAUI ContentPage (XAML)
- en: 'Open the `MatchView.xaml.cs` file and add the following `using` declaration:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MatchView.xaml.cs` 文件，并添加以下 `using` 声明：
- en: '[PRE156]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Make the following highlighted changes to the constructor:'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对构造函数进行以下突出显示的更改：
- en: '[PRE157]'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: These changes allow for dependency injection to supply the `MatchViewModel`
    instance to the view, which is then assigned to `BindingContext`.
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些更改允许依赖注入提供 `MatchViewModel` 实例给视图，然后将其分配给 `BindingContext`。
- en: 'Open the `AppShell.xaml` file and add the following code snippet to the `ContentPage`
    element:'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AppShell.xaml` 文件，并将以下代码片段添加到 `ContentPage` 元素中：
- en: '[PRE158]'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This registers the `"Match"` route and directs it to `MatchView`.
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将注册 `"Match"` 路由并将其指向 `MatchView`。
- en: 'Open the `MauiProgram.cs` file and add the following highlighted line of code:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 文件，并添加以下突出显示的代码行：
- en: '[PRE159]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This will register `MatchView` with dependency injection so that `DataTemplate`
    can locate it.
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将注册 `MatchView` 以进行依赖注入，以便 `DataTemplate` 可以找到它。
- en: Open the `MatchView.xaml` file and remove the `Title` attribute of the `ContentPage`
    element.
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MatchView.xaml` 文件，并移除 `ContentPage` 元素的 `Title` 属性。
- en: 'Add the following highlighted namespaces to the `MatchView` element. They will
    provide us access to the classes in the `ViewModels`, `Converters`, and `Controls`
    namespaces:'
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的命名空间添加到 `MatchView` 元素中。它们将为我们提供访问 `ViewModels`、`Converters` 和 `Controls`
    命名空间中的类：
- en: '[PRE160]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'To make IntelliSense happy with the bindings we will be adding, define the
    view model that the view is using by adding the `x:DataType` attribute to the
    `MatchView` element, as shown:'
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 IntelliSense 对我们将要添加的绑定感到满意，定义视图所使用的视图模型，通过在 `MatchView` 元素中添加 `x:DataType`
    属性来实现，如下所示：
- en: '[PRE161]'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '`MatchView` uses a few icons from the Font Awesome font library, so we will
    need to download and install the library so that it is available in the app.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`MatchView` 使用了 Font Awesome 字体库中的几个图标，因此我们需要下载并安装这个库，以便在应用中可用。'
- en: Downloading and configuring Font Awesome
  id: totrans-700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载和配置 Font Awesome
- en: Font Awesome is a free collection of images packaged into a font. .NET MAUI
    has excellent support for using Font Awesome in toolbars, navigation bars, and
    all over the place. It’s not strictly needed to make this app, but we think that
    it’s worth the extra round trip since you are most likely going to need something
    like this in your new killer app.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome 是一个包含在字体中的图像集合。.NET MAUI 对在工具栏、导航栏等地方使用 Font Awesome 提供了出色的支持。虽然制作这个应用不是必需的，但我们认为这额外的往返是值得的，因为你很可能在你的新杀手级应用中需要类似的东西。
- en: 'Downloading the font is straightforward. Please note the renaming of the file
    – it is not really needed but it’s easier to edit configuration files and such
    if they have a simpler name. Follow these steps to acquire and copy the font to
    each project:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 下载字体很简单。请注意文件的重命名——这实际上不是必需的，但如果文件名更简单，编辑配置文件等会更容易。按照以下步骤获取并复制字体到每个项目中：
- en: Browse to [https://fontawesome.com/download](https://fontawesome.com/download).
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 [https://fontawesome.com/download](https://fontawesome.com/download)。
- en: Click the **Free for Desktop** button to download Font Awesome.
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Free for Desktop** 按钮下载 Font Awesome。
- en: Unzip the downloaded file, then locate the `otfs` folder.
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载的文件，然后找到 `otfs` 文件夹。
- en: Rename the `Font Awesome 5 Free-Solid-900.otf` file to `FontAwesome.otf` (you
    can keep the original name, but it’s just less to type if you rename it). Your
    filename may be different since Font Awesome is continually updating but it should
    be similar.
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Font Awesome 5 Free-Solid-900.otf` 文件重命名为 `FontAwesome.otf`（你可以保留原始名称，但如果重命名会少输入一些）。由于
    Font Awesome 持续更新，你的文件名可能不同，但应该相似。
- en: Copy `FontAwesome.otf` to the `Resources/Fonts` folder in the `SticksAndStones.App`
    project.
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FontAwesome.otf` 复制到 `SticksAndStones.App` 项目的 `Resources/Fonts` 文件夹中。
- en: 'It would be nice if all that was needed was to copy the font file into the
    project folders. A lot does happen with just that action. The default .NET MAUI
    template includes all the fonts in the `Resources/Fonts` folder with the following
    item definition in the `News.csproj` file:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要将字体文件复制到项目文件夹中就足够了，那就太好了。默认的 .NET MAUI 模板在 `News.csproj` 文件中包含了所有字体，并在
    `Resources/Fonts` 文件夹中定义了以下项目：
- en: '[PRE162]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'This ensures that the font files are processed and included in the app package
    automatically. What is left is to register the font with the .NET MAUI runtime
    so it is available to our XAML resources. To do that, add the following highlighted
    line to the `MauiProgram.cs` file:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了字体文件被处理并自动包含在应用包中。剩下要做的就是将字体注册到 .NET MAUI 运行时中，使其对 XAML 资源可用。为此，将以下高亮行添加到
    `MauiProgram.cs` 文件中：
- en: '[PRE163]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This line adds an alias that we can use in the next section to create static
    resources. The first parameter is the filename for the font file, and the second
    is the alias for the font that you can use in the `FontFamily` attribute.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行添加了一个别名，我们可以在下一节中使用它来创建静态资源。第一个参数是字体文件的文件名，第二个参数是你可以用于 `FontFamily` 属性的字体别名。
- en: Defining the layout
  id: totrans-713
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义布局
- en: 'Now that Font Awesome is installed and configured in .NET MAUI, `TitleView`
    can use it. Add the custom title area and the main layout by following these steps:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Font Awesome 已安装并配置在 .NET MAUI 中，`TitleView` 可以使用它。按照以下步骤添加自定义标题区域和主要布局：
- en: 'First, override `TitleView` of the `Shell` element and provide a new container
    to hold the buttons:'
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，覆盖 `Shell` 元素的 `TitleView` 并提供一个新容器来存放按钮：
- en: '[PRE164]'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The buttons are arranged in two segments, one aligned to the left or start of
    the window and the other aligned to the right or end of the window.
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按钮分为两个部分，一个对齐到窗口的左侧或起始位置，另一个对齐到右侧或结束位置。
- en: 'The player can at any point decide they no longer wish to continue playing.
    To exit the match, the player can use the `Start` section of `TitleView` and bind
    `ForfeitCommand` in `MatchViewModel`, add the highlighted code from the following
    snippet :'
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家可以在任何时候决定他们不再想继续游戏。要退出比赛，玩家可以使用 `TitleView` 的 `Start` 部分，并在 `MatchViewModel`
    中绑定 `ForfeitCommand`，添加以下片段中的高亮代码：
- en: '[PRE165]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'When it is the player’s turn, they have two buttons that are enabled, `Play`
    and `Undo`. The `Play` and `Undo` buttons are placed in the `TitleView` area of
    the .NET MAUI page. Add the following highlighted code to add the `Play` and `Undo`
    buttons to `TitleView`:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当轮到玩家时，他们有两个可用的按钮，`Play` 和 `Undo`。`Play` 和 `Undo` 按钮放置在 .NET MAUI 页面的 `TitleView`
    区域。将以下高亮代码添加到 `TitleView` 以添加 `Play` 和 `Undo` 按钮：
- en: '[PRE166]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Remove the default `VerticalStackLayout` element in `ContentView` and add the
    following code:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ContentView` 中删除默认的 `VerticalStackLayout` 元素，并添加以下代码：
- en: '[PRE167]'
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This adds a `Grid` control with four rows. The first and third rows will contain
    the scoreboard and the game board, respectively, while the second and fourth rows
    are padding.
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这添加了一个具有四行的 `Grid` 控件。第一行和第三行将包含计分板和游戏板，而第二行和第四行是填充。
- en: The main layout is ready. Next, the scoreboard is added to the first row of
    the layout.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 主布局已准备就绪。接下来，将计分板添加到布局的第一行。
- en: Creating the scoreboard
  id: totrans-726
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建计分板
- en: 'The scoreboard contains each player’s avatar, gamer tag, and score. The elements
    are bound to the respective fields of `MatchPlayerViewModel` for the player. The
    `Match` object has two properties, `PlayerOne` and `PlayerTwo`, each of which
    is a `MatchPlayerViewModel`. To add the scoreboard, follow these steps:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 计分板包含每个玩家的头像、游戏标签和分数。这些元素绑定到玩家的 `MatchPlayerViewModel` 对应字段。`Match` 对象有两个属性，`PlayerOne`
    和 `PlayerTwo`，每个属性都是一个 `MatchPlayerViewModel`。要添加计分板，请按照以下步骤操作：
- en: 'Each player is identified by a different color. To add each color as a resource,
    open the `Colors.xaml` file in the `Resources/Styles` folder of the `SticksAndStones.App`
    project and add the following lines to the `ResourceDictionary` element:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个玩家都有一个不同的颜色来识别。要将每种颜色添加为资源，打开 `SticksAndStones.App` 项目的 `Resources/Styles`
    文件夹中的 `Colors.xaml` 文件，并将以下行添加到 `ResourceDictionary` 元素中：
- en: '[PRE168]'
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The scoreboard uses `HorizontalStackLayout` for the outer container. Add the
    following code to the `Grid` element:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计分板使用 `HorizontalStackLayout` 作为外部容器。将以下代码添加到 `Grid` 元素中：
- en: '[PRE169]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '`HorizontalStackLayout` is assigned to row `0` of the `Grid`, and its contents
    are bound to the `Players` property of the view model, using `BindableLayout.ItemsSource`.
    `BindableLayout` is the underlying interface that supports all layout controls,
    such as `AbsoluteLayout` and `FlexLayout`.'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HorizontalStackLayout` 被分配到 `Grid` 的行 `0`，其内容通过 `BindableLayout.ItemsSource`
    绑定到视图模型的 `Players` 属性。`BindableLayout` 是支持所有布局控件（如 `AbsoluteLayout` 和 `FlexLayout`）的底层接口。'
- en: 'Each player will have their own card within `HorizontalStackLayout`. Since
    the control is bound to the `Players` property, which is an array of `MatchPlayerViewModels`,
    the `BindableLayout.ItemTemplate` property provides the view that each item in
    `Players` is displayed with. The cards are laid out using a `Border` element and
    nested `VerticalStackLayout` elements. Add the following highlighted code to `HorizontalStackLayout`:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个玩家在 `HorizontalStackLayout` 中都有自己的卡片。由于控件绑定到 `Players` 属性，该属性是一个 `MatchPlayerViewModels`
    数组，因此 `BindableLayout.ItemTemplate` 属性提供了在 `Players` 中显示每个项目的视图。卡片使用 `Border`
    元素和嵌套的 `VerticalStackLayout` 元素进行布局。将以下高亮代码添加到 `HorizontalStackLayout`：
- en: '[PRE170]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The `Border` element is the outermost container for the player card. To set
    the border color and background color of the `Border` element based on `PlayerToken`,
    triggers are used ([https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers))
    – specifically, `DataTrigger` is used to set attribute values based on some other
    value. Add the following code to the `Border` element:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Border` 元素是玩家卡片的最高级容器。要根据 `PlayerToken` 设置 `Border` 元素的边框颜色和背景颜色，使用触发器（[https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers)）——具体来说，使用
    `DataTrigger` 来根据其他值设置属性值。将以下代码添加到 `Border` 元素：'
- en: '[PRE171]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The `DataTrigger` binding attribute is compared to the `Value` attribute. If
    they are equal, then the `Setter` elements of `DataTrigger` are executed. In this
    case, if the `PlayerToken` property is `-1`, then set the `Stroke` and `BackgroundColor`
    attributes of `Border` to the `PlayerOne` color that was defined in *step 1*.
    Otherwise, if the `PlayerToken` property is equal to `-1`, then set the `Stroke`
    and `BackgroundColor` attributes to the `PlayerTwo` color.
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataTrigger` 绑定属性与 `Value` 属性进行比较。如果它们相等，则执行 `DataTrigger` 的 `Setter` 元素。在这种情况下，如果
    `PlayerToken` 属性为 `-1`，则将 `Border` 的 `Stroke` 和 `BackgroundColor` 属性设置为在 *步骤 1*
    中定义的 `PlayerOne` 颜色。否则，如果 `PlayerToken` 属性等于 `-1`，则将 `Stroke` 和 `BackgroundColor`
    属性设置为 `PlayerTwo` 颜色。'
- en: '`VerticalStackLayout` contains another `VerticalStackLayout` and `Border` element,
    as shown in the following highlighted code:'
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VerticalStackLayout` 包含另一个 `VerticalStackLayout` 和 `Border` 元素，如下所示突出显示的代码：'
- en: '[PRE172]'
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Within the second `VerticalStackLayout` are a `Label` and a `FlexLayout`. Add
    the following highlighted code:'
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个 `VerticalStackLayout` 中有一个 `Label` 和一个 `FlexLayout`。添加以下突出显示的代码：
- en: '[PRE173]'
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: <FlexLayout Margin="3">
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <FlexLayout Margin="3">
- en: <toolkit:AvatarView FlexLayout.Order="0" Margin="0" BackgroundColor="LightGrey"
    HeightRequest="85" WidthRequest="85" CornerRadius="50" VerticalOptions="Center"
    HorizontalOptions="Center">
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <toolkit:AvatarView FlexLayout.Order="0" Margin="0" BackgroundColor="LightGrey"
    HeightRequest="85" WidthRequest="85" CornerRadius="50" VerticalOptions="Center"
    HorizontalOptions="Center">
- en: <toolkit:AvatarView.ImageSource>
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <toolkit:AvatarView.ImageSource>
- en: <toolkit:GravatarImageSource
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <toolkit:GravatarImageSource
- en: Email="{Binding EmailAddress}"
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Email="{Binding EmailAddress}"
- en: Image="MysteryPerson" />
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Image="MysteryPerson" />
- en: </toolkit:AvatarView.ImageSource>
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </toolkit:AvatarView.ImageSource>
- en: <toolkit:AvatarView.Triggers>
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <toolkit:AvatarView.Triggers>
- en: <DataTrigger TargetType="toolkit:AvatarView" Binding="{Binding Path=PlayerToken}"
    Value="-1">
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <DataTrigger TargetType="toolkit:AvatarView" Binding="{Binding Path=PlayerToken}"
    Value="-1">
- en: <Setter Property="FlexLayout.Order" Value="1" />
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Setter Property="FlexLayout.Order" Value="1" />
- en: </DataTrigger>
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </DataTrigger>
- en: </toolkit:AvatarView.Triggers>
  id: totrans-753
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </toolkit:AvatarView.Triggers>
- en: </toolkit:AvatarView>
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </toolkit:AvatarView>
- en: <Label FlexLayout.Order="1" Text="{Binding Score}" FontSize="48" Padding="5"
    MinimumWidthRequest="65" HorizontalTextAlignment="Center">
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Label FlexLayout.Order="1" Text="{Binding Score}" FontSize="48" Padding="5"
    MinimumWidthRequest="65" HorizontalTextAlignment="Center">
- en: <Label.Triggers>
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Label.Triggers>
- en: <DataTrigger TargetType="Label" Binding="{Binding Path=PlayerToken}" Value="-1">
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <DataTrigger TargetType="Label" Binding="{Binding Path=PlayerToken}" Value="-1">
- en: <Setter Property="FlexLayout.Order" Value="0" />
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Setter Property="FlexLayout.Order" Value="0" />
- en: </DataTrigger>
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </DataTrigger>
- en: </Label.Triggers>
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </Label.Triggers>
- en: </Label>
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </Label>
- en: FlexLayout control, the order in which the FlexLayout children are displayed
    is governed by the FlexLayout.Order attribute. Similar to Grid with its Grid.Row
    and Grid.Column properties on its children, the Order attribute is set on the
    child. The order of the children in FlexLayout is changed through the use of Trigger.
    On AvatarView, DataTrigger will set the FlexLayout.Order attribute to "1" if the
    PlayerToken property is equal to -1, which is PlayerTwo. On the Label, DataTrigger
    sets the FlexLayout.Order attribute to "0", effectively swapping the two elements.
  id: totrans-762
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FlexLayout 控件，FlexLayout 子项显示的顺序由 FlexLayout.Order 属性控制。类似于 Grid 控件，其子项的 Grid.Row
    和 Grid.Column 属性，Order 属性设置在子项上。FlexLayout 中子项的顺序通过使用触发器来改变。在 AvatarView 上，如果
    PlayerToken 属性等于 -1，即 PlayerTwo，DataTrigger 将 FlexLayout.Order 属性设置为 "1"。在 Label
    上，DataTrigger 将 FlexLayout.Order 属性设置为 "0"，从而有效地交换了两个元素。
- en: '[PRE174]'
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'And that concludes the scoreboard. The final part of `MatchView` is the largest:
    the board. Read on to learn how to create the board visuals.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了记分板。`MatchView` 的最后一部分是最大的：棋盘。继续阅读以了解如何创建棋盘视觉效果。
- en: Creating the game board
  id: totrans-765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建游戏棋盘
- en: 'The game board is composed of three different elements. These elements are
    dots in the corners of each square, sticks (both horizontal and vertical), and
    stones. These elements are laid out as shown here:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏棋盘由三个不同的元素组成。这些元素是每个方格角落的点、横竖棒（水平和垂直）和石头。这些元素按照以下所示布局：
- en: '![Figure 10.14 – The game board](img/B19214_10_14.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 游戏棋盘](img/B19214_10_14.jpg)'
- en: Figure 10.14 – The game board
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 游戏棋盘
- en: 'The board uses a `Grid` control to provide the basic layout. Using 7 columns
    and 7 rows will provide cells for each of the elements: 16 dots, 9 stones, and
    24 sticks. Add the following code to provide the basic layout of the game board
    to the top-level `Grid` element:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘使用 `Grid` 控件来提供基本布局。使用 7 列和 7 行将为每个元素提供单元格：16 个点、9 个石头和 24 根棒。将以下代码添加到顶级 `Grid`
    元素以提供游戏棋盘的基本布局：
- en: '[PRE175]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Let’s start by adding the corners to the grid, since they are the simplest.
    To define a corner, use a `Label` with the text `"&#x26AB;"`, which is the hexadecimal
    character code for a dot. To center the dot horizontally and vertically, set `HorizontalOptions`
    and `VerticalOptions` to `"Center"`. Your basic element would look like the following:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加网格的角落开始，因为它们是最简单的。要定义一个角落，使用带有文本 `"&#x26AB;"` 的 `Label`，这是点的十六进制字符代码。为了水平垂直居中点，将
    `HorizontalOptions` 和 `VerticalOptions` 设置为 `"Center"`。您的基本元素看起来如下所示：
- en: '[PRE176]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Without the `Grid.Row` and `Grid.Column` attributes, the `Label` will be put
    into row `0` and column `0`. There are 16 corners in the grid, and they occupy
    all the even-numbered cells, so `(0,0)`, `(0,2)`, `(0,4)`, `(0,6)`, `(2,0)`, `(2,2)`,
    and so on. Fully defined labels for the first row would look like the following:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`Grid.Row`和`Grid.Column`属性，`Label`将被放置在行`0`和列`0`。网格中有16个角落，它们占据了所有偶数单元格，所以`(0,0)`、`(0,2)`、`(0,4)`、`(0,6)`、`(2,0)`、`(2,2)`等等。第一行的完全定义的标签如下所示：
- en: '[PRE177]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'When you work this out for all 16 rows, that’s a lot of duplication of the
    `Text`, `HorizontalOptions`, and `VerticalOptions` attributes. By using a `Style`
    element, that duplication can be eliminated. A `Style` element contains `Setter`
    elements such as the `DataTrigger` elements. When `Style` is applied to the element,
    the `Setter` elements are used to update the target element’s attributes. Use
    the following steps to add the corner elements to the `Grid` control using `Style`:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为所有16行都这样做时，就会有很多`Text`、`HorizontalOptions`和`VerticalOptions`属性的重复。通过使用`Style`元素，可以消除这种重复。`Style`元素包含`Setter`元素，如`DataTrigger`元素。当`Style`应用于元素时，`Setter`元素用于更新目标元素的属性。使用以下步骤通过`Style`将角落元素添加到`Grid`控件中：
- en: 'Add the following `Style` element to the `ContentPage.Resources` element:'
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`Style`元素添加到`ContentPage.Resources`元素中：
- en: '[PRE178]'
  id: totrans-777
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: This `Style` element is identified by the `x:Key` attribute.
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`Style`元素通过`x:Key`属性进行标识。
- en: Add a `Label` to the `Grid` control created at the start of this section.
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节开头创建的`Grid`控件中添加一个`Label`。
- en: Set the `Grid.Row` attribute of the `Label` to `0`.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Label`的`Grid.Row`属性设置为`0`。
- en: Set the `Grid.Column` attribute of the `Label` to `0`.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Label`的`Grid.Column`属性设置为`0`。
- en: Set the `Style` attribute to the `{StaticResource dotLabel}` value. The `Style`
    attribute is used to specify which style should be applied to the element. Since
    `Style` is defined in the `ContentView.Resources` element, it is a `StaticResource`.
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Style`属性设置为`{StaticResource dotLabel}`值。`Style`属性用于指定应用于元素的样式。由于`Style`在`ContentView.Resources`元素中定义，它是一个`StaticResource`。
- en: 'The completed `Label` should look like the following:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的`Label`应如下所示：
- en: '[PRE179]'
  id: totrans-784
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Now, copy the `Label` just created and increase the `Grid.Column` value by two,
    and repeat this step until you have four `Label` elements with the same `Grid.Row`
    value.
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制刚刚创建的`Label`，并将`Grid.Column`值增加两个，重复此步骤，直到你有四个具有相同`Grid.Row`值的`Label`元素。
- en: Copy the last `Label` created in *step 7* and increase the `Grid.Row` value
    by two and reset the value of `Grid.Column` to `0`. Now, repeat *step 7* using
    the updated `Grid.Row` value, and stop when there are four labels with a `Grid.Row`
    value of `6`.
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制在第7步中创建的最后一个`Label`，并将`Grid.Row`值增加两个，并将`Grid.Column`的值重置为`0`。现在，使用更新的`Grid.Row`值重复第7步，直到有四个具有`Grid.Row`值为`6`的标签。
- en: 'The labels should look like the following listing:'
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签应如下所示：
- en: '[PRE180]'
  id: totrans-788
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Now that the corners are done, we can start on the game pieces: the sticks
    and stones. Since the sticks and stones have some similarities, we can create
    a common control to help display them all. However, they are visualized entirely
    differently. What is needed is a common interface to define the `BindableProperty`
    properties and use that on different layouts.`.NET` `MAUI` `uses` `ControlTemplate`
    resources to allow for the customization, or even complete replacement, of the
    visual elements that comprise a control. Many controls in .NET MAUI can be customized
    using a `ControlTemplate`, if they derive from `ContentView` or `ContentPage`.
    Let’s get started with the sticks and stones by adding the custom control, then
    the `ControlTemplate` resources for sticks and stones, by following these steps:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 现在角落处理完毕，我们可以开始制作游戏棋子：木棍和石头。由于木棍和石头有一些相似之处，我们可以创建一个通用的控件来显示它们。然而，它们的可视化方式完全不同。所需的是一个通用的接口来定义`BindableProperty`属性，并在不同的布局中使用它。`.NET`
    `MAUI`使用`ControlTemplate`资源来允许对构成控件的视觉元素进行自定义，甚至完全替换。在.NET MAUI中，许多控件可以通过`ControlTemplate`进行自定义，如果它们从`ContentView`或`ContentPage`派生。让我们从添加自定义控件开始，然后按照以下步骤添加木棍和石头的`ControlTemplate`资源：
- en: Create a new class in the `Controls` folder of the `SticksAndStones.App` project
    named `GamePieceView`.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SticksAndStones.App`项目的`Controls`文件夹中创建一个新的类，命名为`GamePieceView`。
- en: 'Update the class definition to match the following listing:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新类定义以匹配以下列表：
- en: '[PRE181]'
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Add a `string` property and a `BindableProperty` property named `GamePiecePosition`
    and `GamePiecePositionProperty`, respectively, as shown in the following listing:'
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `GamePiecePosition` 的 `string` 属性和一个名为 `GamePiecePositionProperty` 的
    `BindableProperty`，如下所示：
- en: '[PRE182]'
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '`GamePiecePosition` is used to determine the array index in either `Sticks`
    or `Stones` properties on `GameViewModel`.'
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GamePiecePosition` 用于确定 `GameViewModel` 上的 `Sticks` 或 `Stones` 属性中的数组索引。'
- en: 'Add an `int` property and `BindableProperty` named `GamePieceState` and `GamePieceStateProperty`,
    respectively, as shown in the following listing:'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `GamePieceState` 的 `int` 属性和一个名为 `GamePieceStateProperty` 的 `BindableProperty`，如下所示：
- en: '[PRE183]'
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '`GamePieceState` is the owner of the piece: `1` for `PlayerOne`, `0` for no
    one, and `-1` for `PlayerTwo`.'
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GamePieceState` 是棋子的所有者：`1` 表示 `PlayerOne`，`0` 表示无人，`-1` 表示 `PlayerTwo`。'
- en: 'Add a `string` property and `BindableProperty` named `GamePieceDirection` and
    `GamePieceDirectionProperty`, respectively, as shown in the following listing:'
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `GamePieceDirection` 的 `string` 属性和一个名为 `GamePieceDirectionProperty`
    的 `BindableProperty`，如下所示：
- en: '[PRE184]'
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '`GamePieceDirection` is only needed for `Sticks` and is either `Horizontal`
    or `Vertical`.'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GamePieceDirection` 仅适用于 `Sticks`，可以是 `Horizontal` 或 `Vertical`。'
- en: 'Open the `MatchView.Xaml` file again and let’s add a control template for all
    the sticks. Add the following snippet to the `ContentView.Resources` element:'
  id: totrans-802
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开 `MatchView.Xaml` 文件，并为所有棍子添加一个控件模板。将以下代码片段添加到 `ContentView.Resources` 元素中：
- en: '[PRE185]'
  id: totrans-803
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: This defines a `ControlTemplate` element with a key of `StickViewControlTemplate`.
    The key is used to apply the `ControlTemplate` element to the control.
  id: totrans-804
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这定义了一个具有 `StickViewControlTemplate` 键的 `ControlTemplate` 元素。键用于将 `ControlTemplate`
    元素应用于控件。
- en: 'There are two elements to each stick visual: the number displayed on a label,
    and the stick image, which uses the `Image` control inside a border to give it
    the outline, colored by the player that placed the stick. The other interesting
    aspect is that the `Label` and `Border` controls need to be layered on top of
    one another. To accomplish this, a `Grid` control is used and both elements are
    placed in the same cell. To add the `Grid`, `Label`, `Border`, and `Image` controls,
    use the following listing, and add them to the `ControlTemplate` element:'
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个棍子视觉元素有两个部分：标签上显示的数字和棍子图像，图像使用 `Image` 控件在边框内显示，并由放置棍子的玩家着色。另一个有趣的方面是 `Label`
    和 `Border` 控件需要叠加在一起。为了实现这一点，使用了一个 `Grid` 控件，并将两个元素放置在同一单元格中。要添加 `Grid`、`Label`、`Border`
    和 `Image` 控件，请使用以下列表，并将它们添加到 `ControlTemplate` 元素中：
- en: '[PRE186]'
  id: totrans-806
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '`Grid` has `Margin` and `Padding` values of `0` so that it doesn’t occupy any
    screen real estate. The `Label` control’s `Text` attribute is bound using `TemplateBinding`
    to the `GamePiecePosition` property. `TemplateBinding` differs slightly from `Binding`
    in that `TemplateBinding` uses the control this `ControlTemplate` is applied to
    as `DataContext`. Since this `ControlTemplate` will be applied to instances of
    `GamePieceView`, it will bind to the `Bindable` properties of those controls.'
  id: totrans-807
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Grid` 的 `Margin` 和 `Padding` 值为 `0`，这样它就不会占用任何屏幕空间。`Label` 控件的 `Text` 属性使用
    `TemplateBinding` 绑定到 `GamePiecePosition` 属性。`TemplateBinding` 与 `Binding` 有所不同，因为
    `TemplateBinding` 使用应用于此 `ControlTemplate` 的控件作为 `DataContext`。由于此 `ControlTemplate`
    将应用于 `GamePieceView` 的实例，因此它将绑定到这些控件的 `Bindable` 属性。'
- en: 'Inspecting the `Image` control from *step 7*, you’ll find that it doesn’t specify
    which image is displayed. For `Sticks`, one of two images is displayed: either
    `hstick.jpeg` for horizontal sticks or `vstick.jpeg` for vertical sticks, and
    if there is no stick at that location, then the control should not be visible.
    The following listing uses `DataTrigger` to set the values of `IsVisible` and
    `Source` of the `Image` control using `TemplateBinding` to the `GamePieceState`
    and `GamePieceDirection` properties. Add this code to the `Image` control of `ControlTemplate`:'
  id: totrans-808
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查 *第7步* 中的 `Image` 控件，你会发现它没有指定显示哪个图像。对于 `Sticks`，会显示两个图像中的一个：水平棍子显示 `hstick.jpeg`，垂直棍子显示
    `vstick.jpeg`，如果该位置没有棍子，则控件不应可见。以下列表使用 `DataTrigger` 通过 `TemplateBinding` 将 `IsVisible`
    和 `Source` 的值设置为 `Image` 控件的 `GamePieceState` 和 `GamePieceDirection` 属性。将此代码添加到
    `ControlTemplate` 的 `Image` 控件中：
- en: '[PRE187]'
  id: totrans-809
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The `Border` control also uses `DataTrigger` to outline the stick in the color
    of the player that placed the stick. Add the following code to the `Border` element,
    after `Image`:'
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Border` 控件也使用 `DataTrigger` 以放置棍子的玩家的颜色来勾勒出棍子。在 `Image` 之后添加以下代码到 `Border`
    元素中：'
- en: '[PRE188]'
  id: totrans-811
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Two triggers are needed to switch between `PlayerOne` (`1`) and `PlayerTwo`
    (`-1`). The `Stroke` attribute of the `Border` control is set to the color resource
    of the player. If neither trigger is active, then the default `Stroke` value of
    `Transparent` from the `Border` element is used. In this way, if there is no stick,
    `GamePieceState` is `0`, and the border is transparent. If `GamePieceState` is
    `1`, then `Stroke` will have the color defined by the resource named `PlayerOne`,
    and if `GamePieceState` is `-1`, then the `Stroke` value will be the resource
    named `PlayerTwo`.
  id: totrans-812
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要两个触发器来在`PlayerOne`（`1`）和`PlayerTwo`（`-1`）之间切换。`Border`控制的`Stroke`属性被设置为玩家的颜色资源。如果两个触发器都不活跃，则使用`Border`元素的默认`Stroke`值`Transparent`。这样，如果没有使用棒子，`GamePieceState`为`0`，边界将是透明的。如果`GamePieceState`为`1`，则`Stroke`将具有由名为`PlayerOne`的资源定义的颜色，如果`GamePieceState`为`-1`，则`Stroke`值将是名为`PlayerTwo`的资源。
- en: 'When the user is making their move during their turn, they will tap or click
    on the label to place their stick in that position. To call `SelectStickCommand`
    when that occurs, the `Border` control binds `TapGestureRecognizer` to the `GameViewModel.SelectStickCommand`
    property and passes `GamePiecePosition` along as a parameter. Add the following
    listing to the `Border` element, after the `Border.Triggers` element:'
  id: totrans-813
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在他们的回合中移动时，他们将通过点击标签来放置他们的棒子在那个位置。为了在发生这种情况时调用`SelectStickCommand`，`Border`控制将`TapGestureRecognizer`绑定到`GameViewModel.SelectStickCommand`属性，并将`GamePiecePosition`作为参数传递。将以下列表添加到`Border`元素之后，在`Border.Triggers`元素之后：
- en: '[PRE189]'
  id: totrans-814
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Finally, take a close look at the `Label` element; you will see that the `IsVisible`
    attribute is set to `False`. If there is no stick placed at this position, then
    we need the label with the position displayed. That can be accomplished by using
    `DataTrigger`; the label’s `IsVisible` property can be set to `True`, making the
    label visible if `GamePieceState` is `0`, meaning no stick has been placed there
    yet. Add the following listing to the `Label` element:'
  id: totrans-815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，仔细看看`Label`元素；你会看到`IsVisible`属性被设置为`False`。如果没有在这个位置放置棒子，我们需要显示位置的标签。这可以通过使用`DataTrigger`来实现；如果`GamePieceState`为`0`，即还没有放置棒子，则可以将标签的`IsVisible`属性设置为`True`，使标签可见。将以下列表添加到`Label`元素中：
- en: '[PRE190]'
  id: totrans-816
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'That completes the control template for the sticks. Next, create the control
    template for `Stones` by following these steps:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了棒子的控制模板。接下来，按照以下步骤创建`Stones`的控制模板：
- en: 'Right below the `ControlTemplate` created for the sticks, add the following
    code:'
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为棒子创建的`ControlTemplate`下方添加以下代码：
- en: '[PRE191]'
  id: totrans-819
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Just like with the control template for sticks, the `ControlTemplate` uses a
    key to locate the right template.
  id: totrans-820
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像棒子的控制模板一样，`ControlTemplate`使用一个键来定位正确的模板。
- en: 'The `Stones` template is a little less complex than the `Sticks` template.
    Here, we just have the `Border` control with an `Image` control as a child. `DataTrigger`
    is used again to select the right border color, and if the stones are not present,
    then the border is not visible. Use the following code sample and add it to the
    `ControlTemplate` created in *step 1*:'
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stones`模板比`Sticks`模板简单一些。在这里，我们只有一个作为子控件的`Border`控制和`Image`控制。再次使用`DataTrigger`来选择正确的边界颜色，如果石头不存在，则边界不可见。使用以下代码示例并将其添加到在*步骤1*中创建的`ControlTemplate`中：'
- en: '[PRE192]'
  id: totrans-822
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: You may have noticed a difference between the triggers in this listing versus
    the triggers in the `Sticks` control template. In `Sticks`, the `IsVisible` attribute
    was set on `Image`, not `Border`, and you may want to know why that is. The explanation
    is simple; if the border is not visible, it will not receive `TapGuesture` events.
    The `Grid` element cannot register `GestureRecognizer`, so the event cannot be
    captured there either.
  id: totrans-823
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到这个列表中的触发器与`Sticks`控制模板中的触发器有所不同。在`Sticks`中，`IsVisible`属性是在`Image`上设置的，而不是在`Border`上，你可能想知道为什么是这样。解释很简单；如果边界不可见，它将不会收到`TapGuesture`事件。`Grid`元素无法注册`GestureRecognizer`，因此事件也无法在那里被捕获。
- en: 'The `ControlTemplates` that are needed for the stick and stone images are in
    place; now, they need to be associated with the `GamePieceView` control elements.
    A `Style` can set the `ControlTemplate` property of a `GamePieceView` element,
    but how will it determine that this element is a stick or a stone? `Style` elements
    have a `Class` property that can be used to further refine which styles are applied
    to a control. If the control has a matching class name listed in its `StyleClass`
    attribute, then that `Style` element is applied. Let’s use sticks as an example,
    by following these steps:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 需要用于棍子和石头图像的`ControlTemplates`已经就位；现在，它们需要与`GamePieceView`控件元素关联。`Style`可以设置`GamePieceView`元素的`ControlTemplate`属性，但它如何确定这个元素是棍子还是石头？`Style`元素有一个`Class`属性，可以用来进一步细化应用于控件的风格。如果控件在其`StyleClass`属性中列出了匹配的类名，则应用该`Style`元素。让我们以棍子为例，按照以下步骤进行：
- en: 'Add a new `Style` element to the `ContentView.Resources` element, as shown
    in the following listing:'
  id: totrans-825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`Style`元素添加到`ContentView.Resources`元素中，如下所示列表：
- en: '[PRE193]'
  id: totrans-826
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'This style is only applied to elements that are of the `GamePiece` type and
    have the `Stick` class listed in the `StyleClass` attribute. A matching element
    might look like the following:'
  id: totrans-827
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此样式仅应用于类型为`GamePiece`且在`StyleClass`属性中列出`Stick`类的元素。匹配的元素可能如下所示：
- en: '[PRE194]'
  id: totrans-828
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The highlighted sections show the parts of the control that are used to match
    the `Style` element. `StyleClass` can have more than one name listed; just use
    a comma to separate the names.
  id: totrans-829
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 突出的部分显示了用于匹配`Style`元素的控件部分。`StyleClass`可以列出多个名称；只需使用逗号分隔名称。
- en: 'Add a new `Style` element. This time, it will be to apply `StoneViewControlTemplate`,
    as shown in the following listing:'
  id: totrans-830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`Style`元素。这次，它将应用于`StoneViewControlTemplate`，如下所示列表：
- en: '[PRE195]'
  id: totrans-831
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'That is all that is required for the stick and stone elements to be added to
    the game board grid. To add the remaining elements, follow these steps:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 棒子和石头元素添加到游戏板网格中所需的所有内容都已具备。要添加剩余的元素，请按照以下步骤进行：
- en: 'There are seven rows of sticks: four rows of three and three rows of four.
    They are nearly identical, but not quite. Locate the `Grid` that defines the gameboard;
    it will already have the corner dots added. Right after the 16 dot elements, add
    the following listing for the first row of sticks:'
  id: totrans-833
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有七行棍子：四行三列和三行四列。它们几乎相同，但又不完全相同。定位定义游戏板的`Grid`；它已经添加了角落的点。在16个点元素之后，添加以下列表以添加第一行棍子：
- en: '[PRE196]'
  id: totrans-834
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Each stick in the first row is displayed horizontally. Each stick is given its
    own position in the `GamePiecePosition` attribute and `GamePieceState` is bound
    to the `Game.Sticks` object for this stick. The `Sticks` array is zero-based so
    the indexes for the array are one less than `GamePiecePosition`.
  id: totrans-835
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行中的每根棍子都是水平显示的。每根棍子都分配了其在`GamePiecePosition`属性中的位置，并且`GamePieceState`绑定到该棍子的`Game.Sticks`对象。`Sticks`数组是从零开始的，所以数组的索引比`GamePiecePosition`少一个。
- en: 'Add the code for the second row of sticks using the following listing:'
  id: totrans-836
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下列表添加第二行棍子的代码：
- en: '[PRE197]'
  id: totrans-837
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: These elements are all `Vertical` instead of `Horizontal`; otherwise, they follow
    the same pattern as the previous step. Keep on going to add the remaining rows.
  id: totrans-838
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些元素都是`Vertical`而不是`Horizontal`；否则，它们遵循与上一步相同的模式。继续添加剩余的行。
- en: 'Use the following listing to add the third row of sticks:'
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下列表添加第三行棍子：
- en: '[PRE198]'
  id: totrans-840
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Use the following listing to add the fourth row of sticks:'
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下列表添加第四行棍子：
- en: '[PRE199]'
  id: totrans-842
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Use the following listing to add the fifth row of sticks:'
  id: totrans-843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下列表添加第五行棍子：
- en: '[PRE200]'
  id: totrans-844
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Use the following listing to add the sixth row of sticks:'
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下列表添加第六行棍子：
- en: '[PRE201]'
  id: totrans-846
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Use the following listing to add the seventh row of sticks:'
  id: totrans-847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下列表添加第七行棍子：
- en: '[PRE202]'
  id: totrans-848
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The sticks are all added, so now we need to add the stones. Use the following
    listing to add the nine `Stone` elements to the game board `Grid` control following
    the sticks:'
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 棍子都已添加，现在我们需要添加石头。使用以下列表将九个`Stone`元素添加到游戏板`Grid`控件中，遵循棍子的顺序：
- en: '[PRE203]'
  id: totrans-850
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: This is a wrap on the game app. You can now test out the project in the next
    section.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对游戏应用的总结。你现在可以在下一节测试项目。
- en: Testing the completed project
  id: totrans-852
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试完成的项目
- en: 'This project has spanned two chapters, with *Chapter 9**, Setting Up a Backend
    for a Game Using Azure Services , and this chapter, Building a Real-Time Game*.
    Since this is a two-player turn-based game, getting all the components configured
    correctly can be a challenge. Follow these steps to test out your game locally
    on Windows:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目跨越了两个章节，包括*第9章*，使用Azure服务设置游戏后端，以及本章，构建实时游戏。由于这是一个两人回合制游戏，正确配置所有组件可能是一个挑战。按照以下步骤在Windows上本地测试你的游戏：
- en: The first step is to get the service running in the background. In Visual Studio,
    right-click the `SticksAndStones.Functions` project and select **Debug** | **Start
    Without Debugging** or press *Ctrl* + *F5*.
  id: totrans-854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是让服务在后台运行。在Visual Studio中，右键单击`SticksAndStones.Functions`项目，然后选择**调试** |
    **不调试启动**或按*Ctrl* + *F5*。
- en: '![Figure 10.15 – Starting the Azure Functions service](img/B19214_10_15.jpg)'
  id: totrans-855
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 启动Azure Functions服务](img/B19214_10_15.jpg)'
- en: Figure 10.15 – Starting the Azure Functions service
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 启动Azure Functions服务
- en: That should launch a terminal window with the Azure Functions service running.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会启动一个包含正在运行的Azure Functions服务的终端窗口。
- en: 'Now, two clients are needed to play the game. On Windows, that means the Windows
    client and the Android client. Start with the Windows client first, and use the
    same method that was used for Functions. Make sure the Windows target is selected
    in the **Debug** options:'
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，需要两个客户端来玩游戏。在Windows上，这意味着Windows客户端和Android客户端。首先启动Windows客户端，并使用与函数相同的方法。确保在**调试**选项中选择了Windows目标：
- en: '![Figure 10.16 – Selecting Windows as the Debug target](img/B19214_10_16.jpg)'
  id: totrans-859
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 选择Windows作为调试目标](img/B19214_10_16.jpg)'
- en: Figure 10.16 – Selecting Windows as the Debug target
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 选择Windows作为调试目标
- en: Right-click the `SticksAndStones.App` project and then select **Debug** | **Start
    Without Debugging** or press *Ctrl* + *F5*. A new window should open with the
    login page displayed.
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`SticksAndStones.App`项目，然后选择**调试** | **不调试启动**或按*Ctrl* + *F5*。应该会打开一个新窗口，显示登录页面。
- en: 'Now, switch the **Debug** target to Android:'
  id: totrans-862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将**调试**目标切换到Android：
- en: '![Figure 10.17 – Selecting Android as the Debug target](img/B19214_10_17.jpg)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 选择Android作为调试目标](img/B19214_10_17.jpg)'
- en: Figure 10.17 – Selecting Android as the Debug target
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 选择Android作为调试目标
- en: Now, either use *F5* to debug the app in an Android emulator, or *Ctrl* + *F5*
    to just run the app.
  id: totrans-865
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要么使用*F5*在Android模拟器中调试应用，要么使用*Ctrl* + *F5*仅运行应用。
- en: Log in to each app using a different email and gamer tag.
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的电子邮件和游戏标签登录到每个应用。
- en: '![Figure 10.18 – Log in to the game](img/B19214_10_18.jpg)'
  id: totrans-867
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 登录到游戏](img/B19214_10_18.jpg)'
- en: Figure 10.18 – Log in to the game
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 登录到游戏
- en: Challenge the other player to a match!
  id: totrans-869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其他玩家发起比赛！
- en: '![Figure 10.19 – Challenge issued](img/B19214_10_19.jpg)'
  id: totrans-870
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19 – 发出挑战](img/B19214_10_19.jpg)'
- en: Figure 10.19 – Challenge issued
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 – 发出挑战
- en: Try to best yourself in a game of *Sticks* *and Stones*!
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一场*棍子* *和石头*游戏中挑战自己吧！
- en: '![Figure 10.20 – The match has started](img/B19214_10_20.jpg)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – 比赛已经开始](img/B19214_10_20.jpg)'
- en: Figure 10.20 – The match has started
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – 比赛已经开始
- en: 'Android: cleartext http traffic to 10.0.2.2 not permitted'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: Android：不允许到10.0.2.2的明文http流量
- en: 'If you are attempting to test the game using the Android client, you will probably
    hit this error when you try to send a move to the server. Fortunately, the resolution
    is easy. Open the `MainApplication.cs` file in the `Platforms/Android` folder
    and modify the `Application` attribute on the `MainApplication` class to match
    the following:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用Android客户端测试游戏，当你尝试向服务器发送移动时，你可能会遇到这个错误。幸运的是，解决方案很简单。在`Platforms/Android`文件夹中打开`MainApplication.cs`文件，并将`MainApplication`类上的`Application`属性修改为以下内容：
- en: '`[Application(UsesCleartextTraffic =` `true)]`'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Application(UsesCleartextTraffic = true)]`'
- en: If you encounter any errors or something just doesn’t work the way you expect
    it to, go back through all the steps and make sure you didn’t miss anything. Otherwise,
    congratulations on making it through this project.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到任何错误或某些事情没有按预期工作，请返回所有步骤并确保你没有错过任何东西。否则，恭喜你完成了这个项目。
- en: Summary
  id: totrans-879
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That’s that! Excellent work! There is so much in the chapter that it is hard
    to keep this summary short. In this chapter, we created a game app that connects
    to our backend. We created a service that managed the calls to the backend service
    and handled errors, all asynchronously. We have learned how to respond to messages
    from SignalR, and how to send and receive messages within the app using the `IMessenger`
    interface. We created custom controls and used them across multiple pages. We
    learned how to style an app with XAML styling, how to use control templates, and
    how to select them using styles. We explored routes and how they work in a multi-page
    .NET MAUI app. We examined triggers and how we can use them to update the interface
    without using C# code and converters.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！做得好！这一章内容丰富，很难将其总结得简短。在这一章中，我们创建了一个连接到我们后端的游戏应用。我们创建了一个服务，用于管理对后端服务的调用并处理错误，所有操作都是异步进行的。我们学习了如何响应
    SignalR 的消息，以及如何在应用中使用 `IMessenger` 接口发送和接收消息。我们创建了自定义控件，并在多个页面中使用它们。我们学习了如何使用
    XAML 风格来设计应用，如何使用控件模板，以及如何通过样式来选择它们。我们探讨了路由及其在多页面 .NET MAUI 应用中的工作方式。我们检查了触发器，并了解了如何在不使用
    C# 代码和转换器的情况下使用它们来更新界面。
- en: Now, reward yourself and challenge a friend to a match in your new game.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，奖励自己，挑战一位朋友在你的新游戏中进行一场比赛。
- en: In the next chapter, we will dive into Blazor and .NET MAUI together.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将一起深入研究 Blazor 和 .NET MAUI。
