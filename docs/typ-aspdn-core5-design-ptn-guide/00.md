# 零、序言

设计模式是软件开发中许多常见问题的一组解决方案。它们对于任何有经验的开发人员和专业人员来说都是必不可少的，他们可以设计任何规模的软件解决方案。

我们从探索基本设计模式、体系结构原则、依赖项注入和其他 ASP.NET Core 机制开始。然后，我们探索面向小块软件的组件级模式。接下来，我们将讨论应用规模的模式和技术，在这里我们将探讨更高级别的模式以及如何将应用作为一个整体进行结构。本书涵盖了许多不可避免的 GoF 模式，如策略、单例、装饰、外观和复合。这些章节是根据规模和主题组织的，允许你从一个坚实的基础开始，然后在基础上慢慢构建，就像构建一个程序一样。本书中的许多用例结合了多个设计模式来显示替代用法。它还表明，设计模式是需要使用的工具，而不是需要担心的复杂概念。最后，我们处理客户端连接点，并使 ASP.NET Core 成为可行的全堆栈替代方案。

在本书的结尾，您将能够混合和匹配设计模式，并将学习如何思考架构。这本书是学习工艺背后的推理的旅程。

# 这本书是给谁的

这本书是为中间软件和 web 开发人员准备的，他们对.NET 有一定的了解，希望编写灵活、可维护和健壮的代码来构建可伸缩的 web 应用。这本书假定了解 C#编程和理解 HTTP 等 web 概念。

# 这本书涵盖的内容

## 第 1 节，原则和方法

本节包含本书的基础：单元测试和 xUnit 概述，坚实的原则，以及关于如何设计软件的一些理论和示例。

[*第 1 章*](01.html#_idTextAnchor015)*对.NET 的介绍*，包含了本书的先决条件和工作原理，以及一些对软件开发人员有用的重要主题。

[*第 2 章*](02.html#_idTextAnchor030)*测试 ASP.NET Core 应用*，向您介绍单元测试的基础知识和 xUnit 测试框架，以及一些帮助编写单元测试的良好实践和方法。

[*第 3 章*](03.html#_idTextAnchor042)*架构原则*为本书中使用的关键原则奠定了架构基础，对于任何试图编写“可靠代码”的工程师来说，这些原则都是极其重要的

## 第 2 节，ASP.NET Core 设计

本节介绍 ASP.NET Core 特定主题，包括模型-视图-控制器（MVC）、视图模型、DTO 和一些经典设计模式。我们还深入研究依赖注入，并探索 ASP.NET Core 中某些模式作为现代软件工程支柱的演变用法。

[*第 4 章*](04.html#_idTextAnchor056)*使用 Razor 的 MVC 模式*，介绍使用 Razor 和 ASP.NET Core MVC 渲染视图的模型视图控制器和视图模型设计模式。

[*第 5 章*](05.html#_idTextAnchor075)*Web API 的 MVC 模式*将带领您进一步了解 ASP.NET Core MVC 之旅，重点关注 Web API。我们探讨了数据传输对象（DTO）模式和 API 契约。

[*第 6 章*](06.html#_idTextAnchor099)*理解策略、抽象工厂和单例设计模式*，向您介绍三种基本的四人组（GoF）设计模式的传统实现：策略、抽象工厂和单例。

[*第 7 章*](07.html#_idTextAnchor124)*深入依赖注入*带着 ASP.NET Core 依赖注入容器畅游，向您介绍现代软件开发最重要的方面之一。本章将 ASP.NET Core 与坚实的原则联系起来。一旦确定了依赖注入的基础，我们将回顾前面的三种 GoF 设计模式，并使用依赖注入重新审视它们，从而为构建可测试、灵活和可靠的软件开辟道路。

[*第 8 章*](08.html#_idTextAnchor151)、*选项和日志模式*以 ASP.NET Core 相关主题为切入点进行挖掘。我们涵盖了不同的选项模式和提供给我们的抽象。我们还探讨了如何利用.NET5 中的登录功能。

## 第 3 节，按组件规模设计

本节重点介绍组件设计，我们将研究如何精心设计一个软件片段以实现特定目标。我们将探索更多的 GoF 模式，这些模式将帮助我们设计可靠的数据结构和组件，并通过将逻辑封装在更小的单元中简化代码的复杂性。

[*第 9 章*](09.html#_idTextAnchor171)*结构模式*向您介绍了四种新的 GoF 结构设计模式和一些变体，如透明立面和不透明立面。它还向您介绍了 Scrutor，这是一个开源项目，增加了对 decorator 依赖注入的支持。

[*第 10 章*](10.html#_idTextAnchor196)*行为模式*介绍了两种 GoF 行为设计模式，并将它们混合在一起作为对代码样本设计的最终改进而得出结论。

[*第 11 章*](11.html#_idTextAnchor211)*理解操作结果设计模式*，涵盖了操作结果设计模式的多个变体，构建了一个结果对象，使其承载的不仅仅是一个简单的结果。

## 第 4 节，按应用规模设计

本节向前迈进了一步，介绍了应用设计和分层、垂直切片和微服务。我们概述每种技术，确保您知道如何开始。我们还介绍了不同的组件级模式，这些模式有助于将这些体系结构样式组合在一起。

[*第 12 章*](12.html#_idTextAnchor230)*理解分层*向您介绍分层和清洁体系结构，涵盖表示层、域层、数据（持久性）层及其清洁体系结构对应层背后的主要目标，这是分层的最高点。它还强调了在过去几十年中发生的应用设计的演变，帮助您了解它从何处开始（本章的开头）和走向何处（本章的结尾）。

[*第 13 章*](13.html#_idTextAnchor248)*对象映射器入门*涵盖了对象映射（即，将一个对象复制到另一个对象），也称为翻译器模式、映射器模式和实体翻译器。本章最后介绍了 AutoMapper，一个开源库，帮助我们自动涵盖最常见的场景。

[*第 14 章*](14.html#_idTextAnchor261)、*中介和 CQRS 设计模式*介绍了命令查询责任分离（CQRS）和中介模式。在介绍了这两种模式之后，我们将探索一个名为 MediatR 的开源工具，它是许多后续主题的基础。

[*第 15 章*](15.html#_idTextAnchor282)*垂直切片架构入门*，介绍垂直切片架构。它使用了我们之前探索过的许多模式和工具，以一种不同的方式组合在一起来查看应用的设计。它还引入了 FluentValidation，它被添加到 MediatR 和 AutoMapper 中。

[*第 16 章*](16.html#_idTextAnchor291)*微服务体系结构介绍*，介绍微服务、微服务是什么、微服务不是什么，并讨论一些相关模式。这是一个理论章节，介绍了许多概念，如消息队列、事件、发布-订阅和网关模式。我们还重新访问了云级别的 CQR。在本章的最后，我们将探讨容器的基础知识。

## 第 5 节，客户端设计

本节介绍了在开发 ASP.NET Core 5 应用时可以使用的多种 UI 模式，如 Blazor、Razor 页面和各种类型的组件。它概述了 ASP.NET Core 5 在用户界面方面提供的功能，如果您感兴趣，还将介绍其他学习途径。

[*第 17 章*](17.html#_idTextAnchor325)*ASP.NET Core 用户界面*探讨了 ASP.NET Core 5 中可供我们使用的大部分 UI 元素，如剃须刀页面、局部视图、标记帮助器、视图组件、显示模板和编辑器模板。我们还探讨了多个 C#9 特性，例如仅限 init 的属性和记录类。

[*第 18 章*](18.html#_idTextAnchor348)*简要介绍 Blazor*，快速接触 Blazor 服务器，然后探索 Blazor WebAssembly（Wasm）来完成我们的旅程，并将 C#/.NET 转换为其他 JavaScript 技术的完整堆栈替代方案。我们将探讨 Razor 组件和模型视图更新设计模式。在本章结尾，我们将介绍一些你可以开始挖掘的可能性。

# 充分利用这本书

你必须知道 C#和如何编程。应掌握布尔逻辑、循环和其他基本编程结构，包括面向对象编程基础知识。对 ASP.NET 有一定的了解将是有益的。了解如何阅读 UML 类图和序列图是一项资产，但不是必需的。

代码示例和资源可在 GitHub（[上获得 https://net5.link/code](https://net5.link/code) ）。存储库根目录下的`README.md`文件中充满了帮助您找到所需代码和资源的信息。如果你找不到任何东西，请查看`README.md`文件——很可能你会找到指向你所寻找信息的指针。

大多数链接都以 https://net5.link/****因此，物理副本的读者可以轻松快速地键入 URL。

在本书中，我混合使用了 VisualStudio2019（有免费版本）和 VisualStudio 代码（免费）。我建议您使用其中一个或两个。IDE 与大部分内容无关。如果你够冲动的话，你可以用记事本（我不建议这样）。除非安装.NET SDK 附带的 Visual Studio，否则可能需要安装.NET 5 SDK。SDK 附带了`dotnet`CLI 以及用于运行和测试程序的构建工具。我在 Windows 上开发，但您应该能够使用其他操作系统。与操作系统相关的主题非常有限，甚至不存在。该代码可以在 Windows 和 Linux 上编译。

![](img/B11369_Preface_Table.jpg)

.NET 5 支持的 Linux:[https://github.com/dotnet/core/blob/master/release-notes/5.0/5.0-supported-os.md](https://github.com/dotnet/core/blob/master/release-notes/5.0/5.0-supported-os.md)

**如果您使用的是本书的数字版本，我们建议您自己键入代码或通过 GitHub 存储库访问代码（下一节提供链接）。这样做将帮助您避免与复制和粘贴代码相关的任何潜在错误。**

# 下载示例代码文件

您可以从 GitHub 的[下载本书的示例代码文件 https://net5.link/code](https://net5.link/code) 。如果代码有更新，它将在现有 GitHub 存储库中更新。

我们的丰富书籍和视频目录中还有其他代码包，请访问[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/) 。看看他们！

# 使用的约定

本书中使用了许多文本约定。

`Code in text`：表示文本中的码字、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄。下面是一个示例：“将下载的`WebStorm-10*.dmg`磁盘映像文件作为系统中的另一个磁盘装载。”

代码块设置如下：

```cs
html, body, #map {
 height: 100%; 
 margin: 0;
 padding: 0
}
```

当我们希望提请您注意代码块的特定部分时，相关行或项目以粗体显示：

```cs
[default]
exten => s,1,Dial(Zap/1|30)
exten => s,2,Voicemail(u100)
exten => s,102,Voicemail(b100)
exten => i,1,Voicemail(s0)
```

任何命令行输入或输出的编写方式如下：

```cs
$ mkdir css
$ cd css
```

**粗体**：表示一个新术语、一个重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词出现在文本中，如下所示。下面是一个示例：“从**管理**面板中选择**系统信息**

提示或重要提示

看起来像这样。

# 联系

我们欢迎读者的反馈。

**一般反馈**：如果您对本书的任何方面有疑问，请在邮件主题中提及书名，并发送电子邮件至 customercare@packtpub.com.

**勘误表**：尽管我们已尽一切努力确保内容的准确性，但还是会出现错误。如果您在本书中发现错误，如果您能向我们报告，我们将不胜感激。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)，选择您的书籍，单击 errata 提交表单链接，然后输入详细信息。

**盗版**：如果您在互联网上发现我们作品的任何形式的非法复制品，请您提供我们的位置地址或网站名称，我们将不胜感激。请联系我们 copyright@packt.com 与材料的链接。

**如果您有兴趣成为一名作家**：如果您对某个主题有专业知识，并且您有兴趣撰写或贡献一本书，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 审查

请留下评论。一旦你阅读并使用了这本书，为什么不在你购买它的网站上留下评论呢？然后，潜在读者可以看到并使用您的无偏见意见做出购买决定，我们 Packt 可以了解您对我们产品的看法，我们的作者可以看到您对他们书籍的反馈。非常感谢。

有关 Packt 的更多信息，请访问[Packt.com](http://packt.com)。