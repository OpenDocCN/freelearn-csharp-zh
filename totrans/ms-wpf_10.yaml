- en: Completing that Great User Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, it is easy to add form fields to a View and produce visually
    appealing and functionally adequate applications. However, it can take a lot more
    work to provide the end user with an interface that truly ticks all of the boxes.
    For example, how many times have you clicked on a button in an application and
    had the whole application freeze while it does some work?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look into solving this problem by using asynchronous
    programming, along with a number of other ways of improving the user experience
    for the end user. For example, we'll investigate enabling the users to customize
    their versions of the application using their own user preference settings.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss keeping the users informed by providing user feedback, and update
    our application framework by adding a feedback system. We'll explore a few alternative
    methods of providing in-application help files and documentation and a number
    of other ways of making the application more user friendly and the life of the
    users that much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Providing user feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One essential facet of a great application is keeping the end users up to date
    with what's going on in the application. If they click on a function button, they
    should be informed as to the progress or the status of the operation. Without
    adequate feedback, the user can be left wondering whether a particular operation
    worked and may attempt to run it several times, possibly causing errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is, therefore, essential to implement a feedback system in our application
    framework. So far in this book, we''ve seen the name of the `FeedbackManager`
    class in a few places, although we''ve seen very little implementation. Let''s
    now see how we can implement a working feedback system in our application framework,
    starting with the `Feedback` class that holds the individual feedback messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that our `Feedback` class implements the `IAnimatable` interface, which
    we saw earlier, along with the `INotifyPropertyChanged` interface. After declaring
    the private fields, we declare a number of useful constructor overloads.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have hardcoded a default feedback display duration of four
    seconds for the `duration` field. In the main constructor, we set the `Duration`
    property dependent upon the value of the `duration` input parameter; if the input
    parameter is the `TimeSpan.Zero` field, then the default value is used, but if
    the input parameter is a non-zero value, it will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `Message` property will hold the feedback message; the `Duration` property
    specifies the length of time that the message will be displayed; the `Type` property
    uses the `FeedbackType` enumeration that we saw earlier to specify the type of
    the message, and the `IsPermanent` property dictates whether the message should
    be permanently displayed until the user manually closes it or not.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of our `IAnimatable` class is shown beneath the other properties,
    and simply consists of the `Animatable` property, but our implementation of the
    `INotifyPropertyChanged` interface has been omitted for brevity, as we are using
    the default implementation that we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the `FeedbackCollection` class that will contain the individual
    `Feedback` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `FeedbackCollection` class extends the `BaseAnimatableCollection` class,
    which we saw earlier, and sets its generic type parameter to the `Feedback` class.
    This is a very simple class and declares a couple of constructors, passing any
    input parameters straight through to the base class constructors.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, it declares two `Add` methods, with the second simply creating
    a `Feedback` object from its input parameters and passing it to the first method.
    The first method first checks that the feedback message is not `null` or empty
    and that an identical message is not already contained in the feedback collection,
    before adding the new message to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our current implementation uses the base class `Add` method to add
    the new items to the end of the feedback collection. We could alternatively use
    the `Insert` method from the base class here to add new items to the start of
    the collection instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the `FeedbackManager` class that uses these two classes
    internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `FeedbackManager` class also implements the `INotifyPropertyChanged` interface,
    and in it we see the static `FeedbackCollection` field. Next, we see the static
    `instance` field, the private constructor, and the static `Instance` property
    of type `FeedbackManager`, which instantiates the `instance` field on the first
    use and tells us that this class follows the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The `Feedback` property follows and is the class access to the `FeedbackCollection`
    field. After that, we see a number of convenient overloads of the `Add` method
    that enables developers to add feedback using different parameters. Our implementation
    of the `INotifyPropertyChanged` interface here has again been omitted for brevity,
    but it uses our default implementation that we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now focus on the XAML of the `FeedbackControl` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We start by adding a number of XAML namespace prefixes for some of our application
    projects. Using the `Converters` prefix, we add instances of the `FeedbackTypeToImageSourceConverter`
    and `BoolToVisibilityConverter` classes that we saw earlier into the `UserControl.Resources`
    section. We also reuse our `AnimatedStackPanel` class from [Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml),
    *Mastering Practical Animations*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `SmallImageInButtonStyle` style, which is based on the `ImageInButtonStyle`
    style that we also saw earlier, and adds some sizing properties. After that, we
    see the `FeedbackStyle` style that defines what each feedback message will look
    like in our feedback control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Feedback` object will be rendered in three columns: the first contains
    an image that specifies the type of feedback, using the `FeedbackTypeToImageSourceConverter`
    class that we saw earlier; the second displays the message with a `TextWrapping`
    value of `Wrap`; the third holds a button with an image, using our `SmallImageInButtonStyle`
    style, which users can use to remove the message.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, as this is purely a UI control with no business logic in, we are
    able to use the code behind the file, even when using MVVM. As such, we attach
    event handlers for the `MouseEnter` and `MouseLeave` events to the `Grid` panel
    containing each `Feedback` object, and another for the `PreviewMouseLeftButtonDown`
    event to the delete button. The final resource that we have here is a `DropShadowEffect`
    instance that defines a small shadow effect.
  prefs: []
  type: TYPE_NORMAL
- en: For the feedback control, we define a `Border` element that uses a semi-transparent
    border brush and has a `BorderThickness` value of `1,0,1,1` and a `CornerRadius`
    value of `0,0,5,5`. These four values work like the `Margin` property and enable
    us to set different values for each of the four sides, or corners in the case
    of the `CornerRadius` property. In this way, we can display a rectangle that is
    only bordered on three sides, with rounded corners on two.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Visibility` property on this border is determined by the `HasFeedback`
    property of the `FeedbackControl` class via an instance of our `BoolToVisibilityConverter`
    class. Therefore, when there are no feedback objects to display, the border will
    be hidden. Also note that our `Shadow` resource is applied to the border `Effect`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the border, we declare a `ListBox` control, with its `ItemsSource` property
    set to the `Feedback` property of the `FeedbackControl` class and its height restricted
    to a maximum of three feedback items, after which vertical scrollbars will be
    shown. Its `ItemTemplate` property is set to the `FeedbackTemplate` that we defined
    in the resources section.
  prefs: []
  type: TYPE_NORMAL
- en: Its `ItemsPanel` property is set to the `AnimatedPanel` resource that we declared
    to animate the entrance and exit of the feedback items. Next, we remove the default
    border of the `ListBox` by setting the `BorderThickness` property to `0` and stretch
    the autogenerated `ListBoxItem` objects to fit the width of the `ListBox` control
    by setting the `HorizontalContentAlignment` property to `Stretch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the code behind our feedback control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We start by declaring the collection of `DispatcherTimer` instances that will
    be responsible for timing when each feedback object should be removed from the
    collection, according to its `Duration` property. We then see the declaration
    of the `Feedback` and `HasFeedback` Dependency Properties, along with their CLR
    wrappers and the `Feedback` property's `CollectionChanged` handler.
  prefs: []
  type: TYPE_NORMAL
- en: In the attached `Feedback_CollectionChanged` handler method, we call the `InitializeTimer`
    method, passing in each new non-permanent feedback item. Note that we need to
    use the `OfType` LINQ Extension Method to cast each item in the `NewItems` property
    of the `NotifyCollectionChangedEventArgs` class from type `object` to `Feedback`.
    Before returning control to the caller, we set the `HasFeedback` property accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the `InitializeTimer` method, we initialize a `DispatcherTimer` instance
    and set its interval to the value from the `Duration` property of the `feedback`
    input parameter. We then attach the `Timer_Tick` event handler, add the current
    time and the feedback object into the `Tag` property of the timer for later use,
    start the timer, and add it into the `timers` collection.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Timer_Tick` method, we access the timer from the `sender` input parameter,
    and the `Feedback` instance from its `Tag` property. The feedback item is then
    removed from the `Feedback` collection, the timer is stopped and removed from
    the `timers` collection, and the `Tick` event handler is detached.
  prefs: []
  type: TYPE_NORMAL
- en: In the `DeleteButton_PreviewMouseLeftButtonDown` method, we first cast the delete
    button from the `sender` input parameter. We then cast the `Feedback` object from
    the button's `DataContext` property and remove it from the `Feedback` collection.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Border_MouseEnter` method, we iterate through the `timers` collection
    and stop each timer. The interval of each timer and duration of each associated
    `Feedback` object is then set to the remaining time that they should be displayed
    for, in effect, pausing their durations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we see the `Border_MouseLeave` method, which re-initializes the `Tag`
    property of each timer in the timers collection, with the same feedback item and
    the current date and time, and restarts it when the user's mouse pointer leaves
    the feedback control.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the length of time that temporary feedback messages are displayed
    can be extended if the user moves their mouse pointer over the feedback control.
    This feature will hold the feedback messages in the control for as long as the
    user keeps their mouse pointer over the control, giving them ample time to read
    the messages. Let''s now see what this control looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50b658f8-1c36-4560-9489-144e8d742180.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have menu buttons at the top of your Views, then you could alternatively
    have the feedback appear at the bottom of the application, or even sliding in
    from one of the sides. Also note that the delete buttons have not been styled,
    so as to shorten this example, but they should be styled in line with the other
    controls in a real application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember from [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml),
    *Writing Custom Application Frameworks*, all of our View Models will have access
    to our new `FeedbackManager` class through the `FeedbackManager` property in our
    `BaseViewModel` class, and so we can replicate the feedback in the preceding image
    from any View Model like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's now move on to discover how we can make our applications more responsive
    by maximizing the utilization of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, all applications were developed as single threaded applications.
    However, when long running background processes were running, the application
    UI would freeze and become unresponsive, because the single thread was busy elsewhere.
    This problem and other performance bottlenecks led to the current era of asynchronous
    programming and multi threaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: In days gone by, creating multi-threaded applications was a complicated matter.
    With each successive version of the .NET Framework, Microsoft has striven to make
    this task easier. Originally, we only had the `Thread` class and then the `BackgroundWorker`
    class in .NET 2.0, but in .NET 4.0 they introduced the `Task` class, and in .NET
    4.5 they introduced the `async` and `await` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the latter methods of multithreading and add
    functionality to our application framework that will enable us to perform our
    data retrieval and update actions asynchronously. Let's start by looking at the
    `async` and `await` keywords first.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the Async and Await keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with these new keywords, Microsoft also added a plethora of methods across
    the .NET Framework that end with the suffix `Async`. As the suffix hints, these
    methods are all asynchronous and they are used in conjunction with the new keywords.
    Let's start with the basic rules.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, in order to use the `await` keyword in a method, the method signature must
    be declared with the `async` keyword. The `async` keyword enables us to use the
    `await` keyword in the method without error and is responsible for returning just
    the `T` generic type parameter from asynchronous methods whose signatures declare
    a return type of `Task<T>`. A method that is modified with the `async` keyword
    is known as an async method.
  prefs: []
  type: TYPE_NORMAL
- en: Async methods actually execute in a synchronous manner, until they reach an
    `await` expression. If there is no `await` keyword in the method, then the whole
    method will run synchronously and the compiler will output a warning.
  prefs: []
  type: TYPE_NORMAL
- en: While a portion of async methods run asynchronously, they don't in fact run
    on their own threads. No additional threads are created using the `async` and
    `await` keywords. Instead, they give the appearance of multithreading by using
    the current synchronization context, but only when the method is active and not
    when it is paused, while running an `await` expression.
  prefs: []
  type: TYPE_NORMAL
- en: When execution reaches an `await` keyword, the method is suspended until the
    awaited task has completed asynchronously. During this time, execution returns
    to the method caller. When the asynchronous action is complete, program execution
    returns to the method and the remainder of the code in it is run synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Async methods are required to have a particular signature. They all need to
    use the `async` modifier keyword, and in addition to this the names of async methods
    should end with the `Async` suffix to clearly signify that they are asynchronous
    methods. Another requirement of declaring async methods is that they cannot contain
    any `ref` or `out` input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The final requirement is that async methods can only use one of three return
    types: `Task`, the generic `Task<TResult>`, or `void`. Note that the generic type `TResult` parameter
    is the same as and can be replaced with `T`, but Microsoft refers to it as `TResult`
    simply because it specifies a return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'All async methods that return some meaningful result will use type `Task<TResult>`,
    where the actual type of the return value will be specified by the `TResult` generic
    type parameter. Therefore, if we want to return a `string` from our async method,
    we declare that our async method returns a parameter of type `Task<string>`. Let''s
    see an example of this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a simple async method that returns a `string` that represents the
    contents of the text file specified by the `filePath` input parameter. Note that
    the actual return type of the method is in fact `Task<string>`. In it, we first
    initialize the `fileContents` variable and then attempt to create a `StreamReader`
    instance from the `File.OpenText` method within the `using` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `using` statement, we attempt to populate the `fileContents` variable
    by awaiting the result of the `ReadToEndAsync` method of the `StreamReader` class.
    Up until this point, the method will run synchronously. The `ReadToEndAsync` method
    will be called, and then control will immediately return to the caller of our
    async method.
  prefs: []
  type: TYPE_NORMAL
- en: When the return value of the `ReadToEndAsync` method is ready, execution returns
    to our async method and continues where it left off. In our example, there is
    nothing else to do but return the result string, although async methods can contain
    any number of lines after the `await` keyword, or even multiple `await` keywords.
    Note that in a real-world application, we would log any exceptions that might
    be thrown from this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our async method just performs some function asynchronously, but does not
    return anything, then we use a return type of `Task`. That is, the task-based
    async method will return a `Task` object that enables it to be used with the `await`
    keyword, but the actual method will not return anything to the caller of that
    method. Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `SetTextFileContentsAsync` method, we first need to convert our input
    string to a byte array. For this reason, we now need to add a `using` directive
    for the `System.Text` namespace in addition to the three originally specified.
    Note that in this particular example, we are using `Unicode` encoding, but you
    are free to use any other encoding value here.
  prefs: []
  type: TYPE_NORMAL
- en: After using the `GetBytes` method to obtain a byte array from the `contents`
    input parameter, we initialize a new `FileStream` object within another `using`
    statement. Apart from the `bool` `useAsync` input parameter, the remaining parameters
    used in the `FileStream` constructor in this example are unimportant, and you
    are free to replace them with values that suit your requirements better.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `using` statement, we see the `await` keyword used with the `WriteAsync`
    method. Up until this point, this method will run synchronously, and on this line
    it will start execution of the `WriteAsync` method and then return control to
    the method caller.
  prefs: []
  type: TYPE_NORMAL
- en: As execution leaves the `using` statement, the `FileStream` instance will be
    closed and disposed of. As this method has nothing to return, the return type
    of the async method is `Task`, which enables it to be awaited by the calling code.
    Again, we would typically log any exceptions that might be thrown from this method,
    but this is omitted here for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Most of us will never use the third return type option of `void` when using
    MVVM, because it is primarily used in event handling methods. Note that async
    methods that return `void` cannot be awaited and that calling code cannot catch
    exceptions thrown from such async methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most commonly asked questions regarding async methods is "How can
    I create an async method from a synchronous method?" Luckily, there is a very
    simple solution to this using the `Task.Run` method, so let''s take a quick look
    at it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use a Lambda expression to specify the synchronous method to run in
    an asynchronous context. That''s all that we have to do to run a synchronous method
    asynchronously. However, what about the opposite requirement? Let''s now see how
    we can run an asynchronous method synchronously. Again, the `Task` class provides
    us with a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we saw at the end of [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*, in order to run an asynchronous method synchronously,
    we first need to instantiate a `Task` instance from our asynchronous method. Then,
    all we have to do is call the `RunSynchronously` method on that instance, and
    it will run synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Building asynchrony into our framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `Task` class, we can add functionality into our application framework
    that will enable us to call any data access method asynchronously. Furthermore,
    it will also enable us to run our data operations asynchronously when the application
    is running, and synchronously while testing. In order to achieve this, we will
    need to implement several parts, that go together to provide this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the first part that will wrap each data operation and hold the
    result value, if applicable, along with any feedback messages or error details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our abstract `DataOperationResult` class, we have a number of properties
    and constructor overloads. The first constructor is used for a successful set
    data operation and merely takes the `successText` input parameter, which is used
    to populate the `Description` property, unless it is `null` or empty, in which
    case a default successful operation message is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: The second constructor is to be used when an exception has been thrown during
    the data operation, and takes the exception and an error message as input parameters.
    In it, we first set the `Exception` property to the exception specified by the
    `exception` input parameter, and then we have a chance to catch common exceptions
    and replace the error messages with custom messages in plain English.
  prefs: []
  type: TYPE_NORMAL
- en: Although we are only checking for exceptions of type `SqlException` in this
    example, we could easily extend this to capture other well-known or expected exceptions,
    and replace their messages with custom messages using laymen terms, by adding
    the further `else...if` conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Error` property of enumeration type `DataOperationError` is used
    here to set and output the predefined error messages, and we'll see that in a
    moment. If the exception is not one that we were expecting, then we could choose
    to output the actual exception message, although that would mean little to the
    users and could be deemed confusing or even worrying.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we could log the exception in the database and output the message from
    the `errorText` input parameter. We check whether the `Error` property has been
    set, and if it has, we call our `GetDescription` Extension Method to retrieve
    the message that relates to the set enumeration member, and set it to the `Description`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we set the `Error` property to the `UndeterminedDataOperationError`
    member and the `Description` property to the value of the `errorText` input parameter
    if it is not `null` or empty, or the text associated with the selected enumeration
    member if it is. The third constructor is also used when an exception has been
    thrown, but when there is no predefined feedback message.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the constructors, we see the properties of the `DataOperationResult`
    class, most of which are self-explanatory. Of particular note is the `IsSuccess`
    property, which can be used by the calling code to determine what to do with the
    result. Let''s now take a look at the `DataOperationError` enumeration class that
    is used to hold the error descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we utilize the `DescriptionAttribute` class to relate a humanized
    error message with each enumeration member. We can use the `GetDescription` Extension
    Method that we saw earlier to access the text values from the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each enumeration member is assigned a number, and this could work well with
    the SQL Server error numbers if you were using SQL stored procedures or queries
    directly. For example, we could cast the SQL error code to the particular enumeration
    member to get the custom message for each error. Let''s now take a look at the
    two classes that extend the `DataOperationResult` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We start with the `GetDataOperationResult` class, which is used to return the
    result of get data operations, or the exception details if an error occurred.
    It adds a `ReturnValue` property of the generic type `T` to hold the return value
    of the data operation. Apart from this single member, it simply adds a number
    of constructors that each call the base class constructors.
  prefs: []
  type: TYPE_NORMAL
- en: The first is used when an exception has been thrown and sets the `ReturnValue`
    property to its default value, rather than leaving it as `null`. The second constructor
    is also used when an exception has been thrown, but when there is no predefined
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third constructor is used for a successful data operation and sets the
    `ReturnValue` property to the returned value. The fourth is also used for a successful
    data operation, but when there is no predefined success message. It calls the
    third constructor, passing the returned value and an empty string for the success
    message. Let''s now see the other class that extends the `DataOperationResult`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `SetDataOperationResult` class is used for set operations and so has no
    return value. Like the `GetDataOperationResult` class, its two constructors call
    the relevant base class constructors. The first is used when an exception has
    been thrown, and the second is used for a successful data operation and accepts
    an input parameter for the operation's success message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to add a new method into our `FeedbackManager` class to enable
    us to add the feedback messages from our `GetDataOperationResult` and `SetDataOperationResult`
    classes directly. We''ll also include a parameter that allows us to override whether
    each message will be displayed for its set duration, or until the user closes
    it manually. Let''s take a look at that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `DataOperationResult` base class as the input parameter
    here, so that either of our derived classes can be used with it. This method simply
    initializes a `Feedback` object from the `Description` and `IsSuccess` properties
    of the `DataOperationResult` class and passes it to the `Add` method that actually
    adds it to the `Feedback` collection.
  prefs: []
  type: TYPE_NORMAL
- en: If we're going to be making asynchronous calls to the UI feedback control, then
    we'll also need to ensure that they are made on the UI thread, so as to avoid
    the common `calling thread cannot access this object because a different thread
    owns it` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this, we need to add a reference to the `UiThreadManager` class,
    which we discussed earlier, into our `FeedbackManager` class, although here we
    add a reference to the `IUiThreadManager` interface instead to enable us to use
    a different implementation while testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `IUiThreadManager` interface, we simply need to wrap our single call
    to add feedback to the `FeedbackManager.Feedback` collection property with the
    `RunOnUiThread` method to run it on the UI thread. However, our `uiThreadManager`
    field needs to be initialized before any feedback is displayed, and we can do
    that from the first use of the `BaseViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first time that any View Model is instantiated, this base class constructor
    will be called and the instance of the `IUiThreadManager` interface in the `FeedbackManager`
    class will be initialized. Of course, in order to correctly resolve our instance
    of the `IUiThreadManager` interface at runtime, we'll first need to register it
    in the `App.xaml.cs` file, along with the other registrations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at this interface and the classes that implement it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IUiThreadManager` interface is a very simple affair and declares just
    three methods. The `RunOnUiThread` method is used to run code on the UI thread;
    the first `RunAsynchronously` method is used to run code asynchronously, and the
    second `RunAsynchronously` method is used to run methods that return something
    asynchronously. Let''s now see the classes that implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the `UiThreadManager` class, the `RunOnUiThread` method calls the `Invoke`
    method on the `Application.Current.Dispatcher` object to ensure that the method
    that is passed to it is queued to run on the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a dispatcher is responsible for maintaining the queue of work items
    for a particular thread, and each thread will have its own dispatcher. The `Application.Current`
    property returns the `Application` object for the current `AppDomain` object,
    and its `Dispatcher` property returns the dispatcher of the thread that was running
    when the application started – the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'As was seen earlier, the `RunAsynchronously` methods simply pass the methods
    specified by the `method` input parameters to the `Task.Run` method. We also saw
    an example of mocking the `RunAsynchronously` method in [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working With WPF*, but now let''s see the whole `MockUiThreadManager`
    class that we could use while testing our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `RunOnUiThread` method, we simply call the `DynamicInvoke` method of
    the `Delegate` class to run the method specified by the `method` input parameter.
    As we saw earlier, the `RunAsynchronously` methods use the `RunSynchronously`
    method of the `Task` class to run the methods specified by the `method` input
    parameters synchronously to avoid timing problems during testing.
  prefs: []
  type: TYPE_NORMAL
- en: In them, we first create a new `Task` object with the method specified by the
    `method` input parameter, then call the `RunSynchronously` method on it, and finally
    return the task. When called using the `await` keyword, this will actually return
    the result of the method instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see, perhaps the most important part of this functionality, where
    the `IUiThreadManager` interface is used, the `DataOperationManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `DataOperationManager` class starts with a couple of private fields, which
    represent the maximum number of attempts to retry each data operation in case
    there is a problem, and the instance of the `IUiThreadManager` interface to use
    to run our functions asynchronously when running the application.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor enables us to inject the `IUiThreadManager` dependency into
    the class and sets it to the private `UiThreadManager` property, which can only
    be accessed from within the class. Likewise, the `FeedbackManager` property is
    also private and enables us to pass feedback messages to the manager class to
    display them in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the generic `TryGet<TResult>` method that returns an object of
    the type `GetDataOperationResult<TResult>`. More specifically, it returns a generic
    object of the type `TResult` wrapped in one of our `GetDataOperationResult` objects.
    It first asserts that the `method` input parameter is not `null`, as this class
    is based around the required parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, we create a loop, with the number of its iterations determined
    by the value of the `maximumRetryCount` field, and inside the loop we try to run
    the function specified by the `method` input parameter. If the data operation
    is successful, we initialize a `GetDataOperationResult` object, passing the return
    value and success feedback message, and return it via the `WithFeedback` method.
  prefs: []
  type: TYPE_NORMAL
- en: If an error occurs and the maximum number of attempts have not yet been reached,
    then we use the asynchronous `Task.Delay` method to wait before attempting to
    run the method again. If the maximum number of errors has been reached, then the
    exception and error feedback message are wrapped in a `GetDataOperationResult`
    object and returned via the `WithFeedback` method.
  prefs: []
  type: TYPE_NORMAL
- en: One improvement that we could implement here would be to increase this delay
    time each time we retry the data operation. We could implement a function that
    returns an exponentially increasing number, based on the `maximumRetryCount` field,
    representing the millisecond value that will be passed to the `Task.Delay` method.
    This would be more likely to handle short network drop outs better.
  prefs: []
  type: TYPE_NORMAL
- en: The `WithFeedback` method enables developers to suppress successful feedback
    messages, as they might not always need the users to receive feedback. For example,
    we may not need to inform them that their data objects were fetched from the database
    successfully, if they have been, or are soon to be, displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if the data operation was successful and the `isMessageSupressed`
    input parameter is `true`, the data operation result is returned directly, without
    feedback. Otherwise, the `dataOperationResult` input parameter object is passed
    to the `FeedbackManager` class to display the associated message, using the new
    methods that we added earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the asynchronous `TryGetAsync` method that simply calls the `TryGet`
    method via the `RunAsynchronously` method of the `UiThreadManager` class. After
    that, we have the `TrySet` method that is responsible for running all set data
    operations, and returns an object of the type `SetDataOperationResult`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is very similar to the `TryGet` method, except that it works for
    set data operations. Similarly, it first asserts that the `method` input parameter
    is not `null` and then runs the remainder of the code within a for loop. This
    again enables our retry capability, and is limited by the value of the `maximumRetryCount`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: In the method, we try to run the function specified by the `method` input parameter,
    and if the data operation is successful, we initialize a `SetDataOperationResult`
    object, passing just the success feedback message and return it via the `WithFeedback`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: If an error occurs and the number of attempts specified by the `maximumRetryCount`
    field has not yet been reached, then we use the `Task.Delay` method to wait before
    attempting to run the method again. If the maximum number of errors has been reached,
    then the exception and error feedback message are wrapped in a `SetDataOperationResult`
    object and returned via the `WithFeedback` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `WithFeedback` method used with the `SetDataOperationResult` objects works
    exactly the same as the earlier one that works with the generic `GetDataOperationResult`
    objects. Finally, we have some overloaded `TrySetAsync` methods that end up calling
    the `TrySet` method asynchronously via the `RunAsynchronously` method of the `UiThreadManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: One point to note here is that, currently, this class is located in the `Managers`
    project. If we were at all likely to need to swap out our data access technology,
    then we might prefer to move this class to the data access project for ease of
    removal. As it stands, we don't have that requirement, and so it is fine where
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of this `DataOperationManager` class in the `DataController`
    class that we saw earlier, with just a few changes. We can also replace its previous
    `SetAuditCreateFields` and `SetAuditUpdateFields` methods with some new methods
    that also update our data models that implement the `ISynchronizableDataModel`
    interface. Let''s take a look at the new code in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start this class with the `dataOperationManager` field of the type `DataOperationManager`.
    We don't need to use an interface here, as this class is safe to be used during
    testing. However, it contains a member of the type `IUiThreadManager`, and we
    need to be able to use different implementations of this, depending on whether
    we're running or testing the application.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we still need to inject the instance of the `dataOperationManager`
    field to use through the constructor, so that its instance of the `IUiThreadManager`
    interface can be resolved in the calling code. After the constructor, we see the
    private `DataOperationManager` property that can only be set from within the class.
  prefs: []
  type: TYPE_NORMAL
- en: The first of the new methods is the `AddProductAsync` method, and as a set operation
    it returns a `Task` of the type `SetDataOperationResult`. Internally, and like
    all async set operations here, it calls the `TrySetAsync` method of the `DataOperationManager`
    class. It passes the method to run asynchronously and the success and unspecified
    error text to be displayed as user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we pass the `product` input parameter to the `InitializeDataModel`
    method, before passing it to the `AddProduct` method of the `IDataProvider` instance,
    to initialize the base class `Auditable` property before it is stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: If the current instance also extends the `ISynchronizableDataModel` interface,
    then its `ObjectState` property will be set to the `Active` member of the `ObjectState`
    enumeration. This idea could easily be extended; if we had an `IIdentifiable`
    interface with a single identification property, we could initialize that here
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `DeleteProductAsync` method also returns a `Task` of the type `SetDataOperationResult` and
    calls the `TrySetAsync` method of the `DataOperationManager` class, but it uses
    a different overload, which enables the feedback message to be displayed permanently
    or until the user manually closes it. In this example, it is used to ensure that
    the user is aware that the product was deleted.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, we pass the `product` input parameter to the `DeleteDataModel`
    method, before passing it to the `DeleteProduct` method of the `IDataProvider`
    instance. This sets the `UpdatedOn` property of the `Auditable` class to the current
    date and time and the `UpdatedBy` property to the currently logged-in user. If
    the current instance extends the `ISynchronizableDataModel` interface, then its
    `ObjectState` property will also be set to a state of `Deleted`.
  prefs: []
  type: TYPE_NORMAL
- en: The next new method is the `GetProductsAsync` method, which is a get operation
    and returns a `Task` of the type `GetDataOperationResult<Products>`. Internally,
    and like all async get operations, it calls the `TryGetAsync` method of the `DataOperationManager`
    class. It passes the method to run asynchronously and the unspecified error text
    to be displayed as user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Of particular note here is the `bool` parameter that it passes, which suppresses
    any successful feedback message from being displayed. If there is an error, either
    the provided error message or a more well-defined custom error message will be
    displayed, but as no successful message is displayed, we simply pass an empty
    string through for that parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The final new data operation method is the `UpdateProduct` method, which is
    not asynchronous, and returns a `SetDataOperationResult` directly. Instead of
    the `TrySetAsync` method, it calls the `TrySet` method of the `DataOperationManager`
    class and passes the method to run the success and error messages and two `bool`
    parameters to signify that it should display the feedback normally.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, it passes the `product` input parameter to the `UpdateDataModel`
    method, before passing it to the `UpdateProduct` method of the `IDataProvider`
    instance. This sets the `UpdatedOn` property of the `Auditable` class to the current
    date and time and the `UpdatedBy` property to the currently logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: This gives an example of how we might build up our data operation methods, predominantly
    using asynchronous access methods but not restricted to having to do so. Of course,
    there are many ways of accessing data in an application, and you should experiment
    with the way that suits you best. This way would suit larger scale applications
    best, as there is a fair amount of overhead in creating this system.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s still one piece of the puzzle missing. Now that we''ve changed
    the constructor of the `DataController` class, we''ll also need to update our
    `BaseViewModel` class, which exposes it, again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `IDataProvider` implementation is resolved by the `DependencyManager`
    instance, along with the `IUiThreadManager` implementation that gets injected
    into the `DataOperationManager` object. In addition to this, we pass the value
    of the `StateManager.CurrentUser` property to the `DataController` class constructor
    to instantiate it each time it is requested.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a system in place that can run our data operations either synchronously
    or asynchronously and retry our data operations a specified number of times if
    they fail, before finally reporting custom feedback messages to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We can customize how long these messages remain visible before automatically
    disappearing, or whether they will automatically disappear or not, or even whether
    they are displayed in the first place or not. Even with these options, the system
    remains lightweight and can be easily added to.
  prefs: []
  type: TYPE_NORMAL
- en: Going the extra mile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most privately developed applications are primarily functional, with little
    time and effort spent on design concerns and even less on usability. How many
    times have we seen applications that throw out a stack trace to the end user when
    an error occurs, or validation messages that highlight errors with the camel case
    code names for fields, rather than the labels used in the UI?
  prefs: []
  type: TYPE_NORMAL
- en: In a good application, the end user should never be presented with any code-based
    terminology. If we were writing an English based application, we wouldn't output
    error messages in Spanish, so *why* output them in C#? This can confuse the user
    and even alarm them in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: How many times have you used an application that has an awkward process flow
    to perform each task that involves far more mouse clicks than is necessary? This
    section is dedicated to avoiding these kinds of situations and suggests a number
    of ways of improving the usability of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Producing in-application help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world, we would all create applications that were so intuitive that
    we wouldn't need to provide in-application help. However, with the complexity
    of some of today's applications, this is not always possible. It is therefore
    often helpful to provide the end users of our applications with some form of help
    that they can refer to when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways of doing this, with the first simply being to provide
    a link to a separate help file from the application. If we have a PDF, or other
    type of file that contains help for the users, we can add it to our solution in
    Visual Studio as a resource.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we can add a `Resources` folder into our solution and then select
    the Add New Item option in the new folder's context menu. After navigating to
    the help file in the Add New Item dialog and successfully adding it, we can view
    its properties by selecting it in the Solution Explorer and pressing *F4*, or
    right clicking it and selecting Properties from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: Once the properties are displayed, we can verify that the file has been added
    with a Build Action of Content and a Copy to Output Directory value of Copy always
    or Copy if newer, which ensures that our help file and its `Resources` folder
    will be copied to the folder that contains the application executable file, and
    that the newest version will always be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then add a menu item or button to our application, which the users can
    select to open the document directly. In our View Model command that is data bound
    to this control, we can call the `Start` method of the `Process` class, passing
    the path of the help file, to open the file in the default application on the
    user''s computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the folder path of the application executable file, using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, if our `Resources` folder is in the startup project, we could attain
    its folder path like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This utilizes the `DirectoryInfo` class to access the parent folder of the executable
    file, or the root directory of the project, and the `Combine` method of the `Path`
    class to create a file path that combines the new `Resources` folder with that
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t have a complete documentation file for our application, a quick
    and simple alternative would be to add an information icon to each View. This
    image control could display pertinent information to the users in a tooltip when
    they place their mouse pointer over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8383fe40-40bb-48f9-b5c2-4b12b43f1548.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the information icon from the Visual Studio Image Library that was discussed
    in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating Visually
    Appealing User Interfaces*, we can create these help points like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Either way, the idea is to provide the users of the application with any help
    that they may need right from the application itself. This not only improves the
    usability of our applications but also reduces user errors and increases data
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling user preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The users of our applications are likely to be very different to each other,
    or at least have their individual preferences. One user may prefer to work in
    one way, while another may have different preferences. Providing the ability for
    them to customize the application to suit the way they work will increase the
    usability of the application for them.
  prefs: []
  type: TYPE_NORMAL
- en: This may relate to the View that they prefer to see when the application starts,
    or to which particular options in each View that they prefer to use, or even to
    the size and position of the application when it was last used. There are any
    number of preferences that we can offer each user.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we can offer this customization functionality with minimal work, as
    the .NET Framework provides us with settings files for just this purpose. These
    settings can either have application or user scope and can be mixed and matched
    in each settings file.
  prefs: []
  type: TYPE_NORMAL
- en: Application settings are the same for each user and are suited to storing configuration
    settings, such as email server details or credentials. User settings can be different
    for each user and are suited to the kind of personal customizations just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the startup project will already have a settings file named `Settings.settings`.
    It can be found by opening the `Properties` folder in the Solution Explorer in
    Visual Studio, and opened by double-clicking on it. Alternatively, you can right-click
    on the project in the Solution Explorer, select the Properties option, and then
    select the Settings tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c19c851-ed84-4e7b-91d5-6289d9a0095c.png)'
  prefs: []
  type: TYPE_IMG
- en: Settings files can also be added to other projects although they are not typically
    available by default. In order to add a settings file to another project, we first
    need to open the project properties by right clicking on the project in the Solution
    Explorer and selecting the Properties option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project properties window, select the Settings tab and click the link
    that says This project does not contain a default settings file. Click here to
    create one. A settings file will be created within the project `Properties` folder
    in the Solution Explorer. We are then free to start adding our user preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d80b38d1-0f81-44f9-85fe-cb1d23184363.png)'
  prefs: []
  type: TYPE_IMG
- en: To add our custom settings, click a blank row in the settings file and enter
    the name, data type, scope, and default value of the setting. The name will be
    used in code, and so it cannot contain spaces. We can select our own custom data
    types, although whichever type we select must be serializable. The default value
    is the initial value that the setting will have before the user changes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Settings will usually be loaded upon application startup and saved just before
    application shutdown. As such, it is customary to attach event handlers to the
    `Loaded` and `Closed` events in the `MainWindow.xaml.cs` file, although we can
    also do it in the `App.xaml.cs` file if we have configured the application to
    use it. We can see a typical example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We attach the two event handlers in the constructor, right after the components
    are initialized. In the `MainWindow_Loaded` method, we instantiate an instance
    of the `MainWindowViewModel` class, call its `LoadSettings` method, and set it
    as the window's `DataContext` property value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainWindow_Closed` method, we access the instance of the `MainWindowViewModel`
    class from the `DataContext` property, but, this time, call its `SaveSettings`
    method. Now, let''s see these methods in the `MainWindowViewModel.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that we need to do in the `L``oadSettings` method is to call
    the `Reload` method on the default instance of the settings file. This loads the
    settings from the settings file into the `Default` object. From there, we set
    each settings property to its corresponding property that we created in our `StateManager`
    class, for use in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the values of each user''s personal settings are not stored in the
    `Settings.settings` file. Instead, they are stored in their `AppData` folder,
    which is hidden by default. The exact file path can be found using the `ConfigurationManager`
    class, but to find it we''ll need to add a reference to the `System.Configuration`
    DLL and use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, that resolves to the following file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that the folder in the `CompanyName` folder is named using a particular
    identification number that relates to the current settings and application version.
    Over time and after making changes, new folders will appear here with new identification
    numbers, but this is all totally transparent to the users as their previous settings
    will be safely transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Extending common courtesies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One area of application development where we can easily make great improvements
    is usability. Many applications these days are created with little or no concern
    for the end users that will be using the application each day.
  prefs: []
  type: TYPE_NORMAL
- en: We've probably all seen applications that spew out exception stack traces when
    errors occur, and while we, as developers, may find that useful, it can be confusing
    or even alarming for the end users. Instead of worrying the end users unnecessarily,
    we can output stack traces and any other pertinent information about each error
    to an `Errors` table in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Extending this idea further, it is good working practice to totally avoid using
    any development terms or phrases anywhere in the application that the users can
    see. That includes all UI labels along with any additional external help files
    and documentation. Using terms of this kind will make the application more difficult
    to use, especially for new users. All but the best known abbreviations should
    also be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further humanize our application by paying attention to the small details.
    How often have you come across an application that displays a label that says
    something like "1 passengers" or "2 item." While this is a very simple problem
    to fix, it is commonly found in many applications. Let''s create a new Extension
    Method to encapsulate this useful functionality in an `IntegerExtensions` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we simply use String Interpolation to append an `s` to the
    end of the `wordToAdjust` input parameter when the value of the this `input` parameter
    is not `1`. While this will work for most words that we are likely to use, it
    is worth noting that there are some groups of words that this will not work with.
  prefs: []
  type: TYPE_NORMAL
- en: For example, some words, such as "Activity," ending with a "y" in their singular
    form, will end with "ies" when pluralized. However, this problem can be easily
    addressed by either adding a new overload of our `Pluralize` method or an additional
    input parameter that enables the users of our code to specify the transformation
    that they require.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method, we now have a really simple way to always ensure that our
    spelling is correct when dealing with quantities. Let''s see how we might use
    this method to pluralize the word `Ticket`, but only when the amount of tickets
    in the `Tickets` collection is not `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'An extension to this method could combine this functionality with the actual
    number to output `6 Tickets` , for example. Let''s take a look at this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Combine` method is very similar to the `Pluralize` method, except that
    it also includes the value of the `input` input parameter in the text output.
    We could also extend this method in the same way that we could extend the `Pluralize`
    method to handle the pluralization of words other than those that just require
    an `s` to be appended. We can also use it in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way that we could humanize our textual output would be to provide a
    selection summary field that displays a comma-separated list of the selected items
    in a collection control. Clearly, this wouldn''t be required for controls that
    only allow single selections to be made; however, it could be a useful confirmation
    for those using multiple selection collection controls. Let''s see how we could
    declare a `ToCommaSeparatedString` method now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a method that we can call on any collection that is either of
    the type of, or extends, the `IEnumerable<T>` interface and receives a string
    back that contains a comma-separated list of each contained element. We can either
    call it with a string collection or implement the `object.ToString` method in
    our classes, as that will be called on each element.
  prefs: []
  type: TYPE_NORMAL
- en: This method uses the `StringBuilder` class to build the comma-separated list.
    As the `StringBuilder` class has a slight overhead when being initialized and
    when exporting the constructed string, tests have shown that it only really offers
    an improvement in time over basic string concatenation when appending 10 or more
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: You may therefore prefer to refactor this method to remove the `StringBuilder`
    object, although you may also find that the difference in milliseconds is negligible.
    Returning to the method, after declaring the `StringBuilder` object, we initialize
    the `index` variable, which is used to specify which separator to join each string
    with.
  prefs: []
  type: TYPE_NORMAL
- en: When the `index` variable equals zero and no strings have yet been added to
    the `StringBuilder` object, no separator will be appended. After that, we check
    whether the current string is the last in the collection, and if it is, we prepend
    `" and "` to it; otherwise, we prepend a comma and a space to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After each iteration, we increment the `index` variable, and when finished,
    we return the output from the `StringBuilder` object. It could be used to display
    a comma-separated list of the products that a user has selected like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are many ways that we can humanize our output for the
    end users, to make them feel more at ease when using our applications. Let's now
    move on to see other ways that we can provide that great user experience for our
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Unburdening the end user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many things that we can do to make the life of the end users easier.
    One simple example would be to set the focus in a form to the first field, so
    that users can start typing as soon as they load a View, without first needing
    to focus it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw one way to do this using an Attached Property in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*, but we can also achieve this easily,
    by first adding a new `bool` property into our `BaseViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we can add a style resource into the application resources in the `App.xaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This assumes that we already have a default style that we want to use for our
    `TextBox` controls and that our new style will be based on that, but add this
    additional focusable functionality. It simply consists of a single data trigger
    that uses the `FocusedElement` property of the `FocusManager` class to focus the
    `TextBox` element that has this style applied to it when the `IsFocused` property
    is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, all we need to do to focus a particular `TextBox` control in a View
    is to apply this style to it and set the `IsFocused` property from the `BaseViewModel`
    class to `true` in the appropriate place in the related View Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `TextBox` control will become focused as the property becomes
    `true` , and so if the property is already `true`, we may need to first set it
    to `false` before again setting it to `true` to get this to work. For example,
    if the property was `true` before the View was loaded, then the `TextBox` control
    would not become focused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another simple example of making our application users'' lives easier would
    be to pre-populate any form fields that we may be able to. For example, if our
    application has a login screen that uses the users'' Windows username, we could
    fill in the user name field in the form after accessing it from the `WindowsIdentity`
    class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Another example of this might be to pre-populate form fields with the most commonly
    used values. We could perhaps fill in a date field with today's date or an Amount
    Paid field to the total amount, if that is what the users typically do.
  prefs: []
  type: TYPE_NORMAL
- en: We do, however, need to be careful when doing this because if we get the default
    value(s) wrong, it could backfire and actually take the users longer to delete
    the default value and replace it with the value that they want than to just input
    the value directly. Remember, the idea is to save the users time and make them
    more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, we can save the users of our applications a great amount of time.
    If we have the chance to ask them exactly what they do and how they would use
    the application on a day-to-day basis, then we can usually program a lot of their
    operations into functions in the application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if any users have to repeatedly edit a number of files with the
    same data, perhaps to add, remove, or update a particular field, then we could
    build that functionality straight into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of making them edit a single record at a time, we could provide a View
    where they set the field, or fields to change, and the new value(s), along with
    the ability to select multiple records, and therefore save them a great deal of
    time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: All menial, or repetitive tasks can be programmed into functions, and so writing
    a good application is not just restricted to making pretty and asynchronous UIs but
    also to making it highly usable. Furthermore, the more useful the application
    is, the more productive the users will become, and the more lavish the praise
    that will be bestowed on us and our development teams, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed further ways to improve our applications, making
    them as useful to the end users as possible. We investigated how we could implement
    a custom user feedback system to keep the users informed with the status of the
    operations that they perform.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined how to make our applications asynchronous, so that our UI won't
    freeze when the application is performing long running operations. We then looked
    at one way of building this asynchronous behavior right into our application framework
    so that we can run any data access operation asynchronously with minimal code.
  prefs: []
  type: TYPE_NORMAL
- en: We ended with a short section dedicated to improving the way that our applications
    are perceived by the end users. In it, we detailed a number of ways of accomplishing
    this, from providing in-application help and user preferences to paying attention
    to the smaller details and implementing work-heavy functions to save the users
    from having to manually do the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be looking at a number of ways to improve the performance
    of our applications, from utilizing the power of installed graphics cards to writing
    more efficient code. We'll also look into how we can improve the efficiency of
    our data bindings and resources, and investigate other techniques, such as data
    virtualization.
  prefs: []
  type: TYPE_NORMAL
