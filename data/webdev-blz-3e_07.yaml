- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Creating an API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 API
- en: When running Blazor using WebAssembly (InteractiveWebAssembly or InteractiveAuto)
    we need to be able to retrieve data and also change our data. For that to work,
    we need an API to access the data. In this chapter, we will create a web API using
    **Minimal API**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 WebAssembly 运行 Blazor（InteractiveWebAssembly 或 InteractiveAuto）时，我们需要能够检索数据并更改我们的数据。为了实现这一点，我们需要一个
    API 来访问数据。在本章中，我们将使用 **Minimal API** 创建一个 Web API。
- en: When using Blazor Server, the API will be secured by the page (if we add an
    **Authorize** attribute), so we get that for free. But with WebAssembly, everything
    will be executed in the browser, so we need something that WebAssembly can communicate
    with to update the data on the server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Blazor Server 时，API 将由页面（如果我们添加 **Authorize** 属性）进行保护，因此我们免费获得这个功能。但是，与
    WebAssembly 一起使用时，所有操作都将执行在浏览器中，因此我们需要 WebAssembly 可以与之通信以更新服务器上的数据。
- en: 'To do this, we will need to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要涵盖以下主题：
- en: Creating the service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务
- en: Creating the client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建客户端
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have read the previous chapters or use the `Chapter06` folder
    as a starting point.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经阅读了前面的章节或使用 `Chapter06` 文件夹作为起点。
- en: You can find the source code for this chapter’s end result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter07).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章最终结果的源代码：[https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter07)。
- en: Creating the service
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: There are many ways to create a service, such as via REST.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务有多种方式，例如通过 REST。
- en: For those who haven’t worked with REST before, **REST** stands for **representational
    state transfer**. Simply put, it is a way for machines to talk to other devices
    using HTTP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些之前没有使用过 REST 的人来说，**REST** 代表 **representational state transfer**。简单来说，它是一种机器使用
    HTTP 与其他设备通信的方式。
- en: 'With REST, we use different HTTP verbs for different operations. They could
    look something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 中，我们使用不同的 HTTP 动词来执行不同的操作。它们可能看起来像这样：
- en: '| **URI** | **Verb** | **Action** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **URI** | **Verb** | **Action** |'
- en: '| `/BlogPosts` | Get | Gets a list of blog posts |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `/BlogPosts` | Get | 获取博客文章列表 |'
- en: '| `/BlogPosts` | Post | Creates a new blog post |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `/BlogPosts` | Post | 创建新的博客文章 |'
- en: '| `/BlogPosts/{id}` | Get | Gets a blog post with a specific ID |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `/BlogPosts/{id}` | Get | 获取具有特定 ID 的博客文章 |'
- en: '| `/BlogPosts/{id}` | Put | Replaces a blog post |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `/BlogPosts/{id}` | Put | 替换博客文章 |'
- en: '| `/BlogPosts/{id}` | Patch | Updates a blog post |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `/BlogPosts/{id}` | Patch | 更新博客文章 |'
- en: '| `/BlogPosts/{id}` | Delete | Deletes a blog post |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `/BlogPosts/{id}` | Delete | 删除博客文章 |'
- en: 'Table 7.1: Rest calls'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1：REST 调用
- en: We will implement an API for **Tags**, **Categories**, and **blog posts**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 **标签**、**类别**和 **博客文章**实现 API。
- en: Since the API takes care of whether the `Post` should be created, we’ll cheat
    and only implement `Put` (replace) because we don’t know whether we are creating
    or updating the data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API 负责处理 `Post` 是否应该被创建，我们将作弊并仅实现 `Put`（替换），因为我们不知道我们是创建还是更新数据。
- en: We will implement the API in the **BlazorWebApp** project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 **BlazorWebApp** 项目中实现 API。
- en: Learning about Minimal APIs
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Minimal API
- en: Before we jump into implementing the Minimal API, let’s take a moment to learn
    about it. Back in November 2019, one of the members of the **Distributed Application
    Runtime** (**Dapr**) team wrote a couple of tutorials on how to build a distributed
    calculator using different languages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现 Minimal API 之前，让我们花点时间了解一下它。回到 2019 年 11 月，**分布式应用运行时**（**Dapr**）团队的一名成员编写了几个教程，介绍了如何使用不同的语言构建分布式计算器。
- en: They had examples using Go, Python, Node.js, and .NET Core. The code showed
    how much harder it was to write a distributed calculator in C# than in other languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 他们提供了使用 Go、Python、Node.js 和 .NET Core 的示例。代码展示了在 C# 中编写分布式计算器比在其他语言中要困难得多。
- en: Microsoft asked various non-.NET developers what their perception was of C#.
    Their response wasn’t great. Then, Microsoft asked them to complete a tutorial
    using an early version of Minimal APIs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 微软询问了各种非 .NET 开发者他们对 C# 的看法。他们的回应并不理想。然后，微软让他们使用 Minimal APIs 的早期版本完成一个教程。
- en: After the tutorial, they were asked about their perception, and their response
    had shifted and was now more positive; it felt like home.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在教程之后，他们被询问他们的看法，他们的回应发生了变化，现在更加积极；感觉就像在家一样。
- en: The goal of Minimal APIs was to reduce complexity and ceremony and embrace minimalism.
    I thought that “minimal” meant that I wouldn’t be able to do everything, but digging
    deeper into the code, I soon realized that was not the case.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最小 API 的目标是减少复杂性和仪式，拥抱简约。我以为“最小”意味着我无法做所有事情，但深入代码后，我很快意识到并非如此。
- en: From my point of view, Minimal APIs are a much nicer way to code APIs. The idea
    is that if we need to, we can grow our API, and as soon as we feel like it, we
    can move our code into a controller to get more structure. At my workplace, we
    switched to Minimal APIs because we think the syntax is much nicer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的角度来看，最小 API 是编写 API 的更好方式。其理念是，如果我们需要，我们可以扩展我们的 API，一旦我们觉得合适，我们可以将代码移动到控制器中以获得更多结构。在我的工作场所，我们转向了最小
    API，因为我们认为语法更简洁。
- en: 'A very simple sample of adding a Minimal API would be just adding this line
    in `Program.cs`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 添加最小 API 的一个非常简单的示例就是在 `Program.cs` 中添加这一行：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We say that if we navigate to a URL without specifying any route, just `"/"`,
    we return a string with `"Hello World"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到一个没有指定任何路由的 URL，只是 `"/"`，我们将返回一个包含 `"Hello World"` 的字符串。
- en: This is, of course, the simplest example possible, but it is possible to implement
    more complex things as well, as we will see in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个可能的简单示例，但也可以实现更复杂的事情，正如我们将在下一节中看到的那样。
- en: Adding the API controllers
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 API 控制器
- en: 'We have three data models: blog posts, Tags, and Categories.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个数据模型：博客文章、标签和分类。
- en: Let’s create three different files, one for each data model, to demonstrate
    that there are friendly ways to add more complex APIs using Minimal APIs. For
    a small project, it would probably make more sense to add everything in `Program.cs`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建三个不同的文件，每个数据模型一个，以展示使用最小 API 添加更复杂 API 的友好方式。对于一个小项目，可能更合理的是在 `Program.cs`
    中添加所有内容。
- en: Adding APIs for handling blog posts
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加处理博客文章的 API
- en: Let’s start by adding the API methods for handling blog posts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加处理博客文章的 API 方法。
- en: 'Execute the following steps to create the API:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建 API：
- en: In the `BlazorWebApp` project, add a new folder called `Endpoints`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp` 项目中，添加一个名为 `Endpoints` 的新文件夹。
- en: In the `Endpoints` folder, create a class called `BlogPostEndpoints.cs`. The
    idea is to create an extension method we can use later in `Program.cs`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Endpoints` 文件夹中，创建一个名为 `BlogPostEndpoints.cs` 的类。目的是创建一个扩展方法，我们可以在 `Program.cs`
    中稍后使用。
- en: 'Add these `using` statements at the top of the file:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文件顶部添加这些 `using` 语句：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Replace the class with the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类替换为以下代码：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we are creating an extension method, we must ensure the class is static.
    The `MapBlogPostApi` method uses the `this` keyword, which makes the method available
    on any `WebApplication` class.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个扩展方法，我们必须确保类是静态的。`MapBlogPostApi` 方法使用 `this` 关键字，这使得该方法在任何 `WebApplication`
    类上都可用。
- en: We set up the Minimal API by using `MapGet` and a path, which means that the
    method will run if we access that path with the correct parameters using a `Get`
    verb.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过使用 `MapGet` 和一个路径来设置最小 API，这意味着如果使用 `Get` 动词通过正确的参数访问该路径，该方法将运行。
- en: The method takes a couple of parameters. The first is of the `IBlogApi` type,
    which will use dependency injection to get an instance of the class we need, in
    this case, `BlogApiJsonDirectAccess`, which will access the JSON files we have
    stored.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法接受几个参数。第一个是 `IBlogApi` 类型，它将使用依赖注入来获取我们需要的类的实例，在这种情况下，是 `BlogApiJsonDirectAccess`，它将访问我们存储的
    JSON 文件。
- en: The other parameters will use the query string (since we are using the `query`
    attribute); in most cases, a Minimal API will figure these things out, but it’s
    never wrong to nudge it in the right direction.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他参数将使用查询字符串（因为我们使用的是 `query` 属性）；在大多数情况下，最小 API 会自动处理这些事情，但引导它走向正确的方向从不会错。
- en: We have created a method that returns the data directly from the database (the
    same API the Blazor Server project is using).
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了一个直接从数据库返回数据的方法（与 Blazor 服务器项目使用的相同 API）。
- en: We also need to make sure to call it from `Program.cs`.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要确保从 `Program.cs` 中调用它。
- en: 'In `Program.cs`, add the following namespace:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加以下命名空间：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, add the following code just above `app.Run();`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还在 `app.Run();` 之上添加以下代码：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s time to test the API; make sure to start the `BlazorWebApp` project. In
    .NET 6, the port numbers are random, so replace `{REPLACEWITHYOURPORTNUMBER}`
    with the port number for your project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候测试 API 了；确保启动 `BlazorWebApp` 项目。在 .NET 6 中，端口号是随机的，所以将 `{REPLACEWITHYOURPORTNUMBER}`
    替换为你的项目端口号。
- en: 'Go to the following URL: `https://localhost:{REPLACEWITHYOURPORTNUMBER}/Api/BlogPosts?numberofposts=10&startindex=0`
    (the port number might be something else). We will get some JSON back with a list
    of our blog posts.'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请访问以下网址：`https://localhost:{REPLACEWITHYOURPORTNUMBER}/Api/BlogPosts?numberofposts=10&startindex=0`（端口号可能不同）。我们将获取一些JSON返回，其中包含我们的博客文章列表。
- en: We are off to a good start! Now, we need to implement the rest of the API as
    well.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经取得了良好的开端！现在，我们需要实现API的其余部分。
- en: 'In the `Endpoints`/`BlogPostEndpoint.cs` file, in the `MapBlogPostApi` method,
    let’s add the code to get the blog post count:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Endpoints/BlogPostEndpoint.cs`文件中，在`MapBlogPostApi`方法中，让我们添加获取博客文章计数的代码：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We use the `Get` verb but with another route.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`Get`动词，但使用另一个路由。
- en: 'We also need to be able to get one blog post. Add the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要能够获取一篇博客文章。添加以下代码：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we are using the *Get* verb but with another URL, containing the
    ID for `Post` that we want to get.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`Get`动词，但使用另一个包含我们想要获取的`Post` ID的URL。
- en: 'We are using a string as an ID and some databases, like RavenDB, for example,
    use an ID that looks like this: `CollectionName/IdOfThePost`; we also make sure
    to add `*` to the parameter. This way, it will use anything that comes after as
    an ID, otherwise it would interpret the slash as part of the routing and not find
    the endpoint.'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用一个字符串作为ID，例如，像RavenDB这样的数据库使用类似这样的ID：`CollectionName/IdOfThePost`；我们还确保在参数中添加`*`。这样，它将使用任何跟在后面的内容作为ID，否则它将把斜杠解释为路由的一部分，而找不到端点。
- en: Next, we need an API that is protected, typically the one that updates or deletes
    things.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个受保护的API，通常是更新或删除内容的API。
- en: 'Let’s add an API that saves a blog post. Add the following code under the code
    we just added:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个保存博客文章的API。在刚刚添加的代码下方添加以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As I mentioned earlier in this chapter, we will only add one API for creating
    and updating blog posts, and we will use the `Put` verb (replace) to do that.
    We have added the `RequireAuthorization` method at the end, which will ensure
    that the user needs to be authenticated to call the method.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我在本章前面提到的，我们只会添加一个用于创建和更新博客文章的API，并且我们将使用`Put`动词（替换）来完成这个操作。我们在最后添加了`RequireAuthorization`方法，这将确保用户需要经过身份验证才能调用该方法。
- en: 'Next up, we add a code for deleting blog posts. To do this, add the following
    code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加删除博客文章的代码。为此，添加以下代码：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we use the `Delete` verb, and just as with saving, we add the
    `RequireAuthorization` method at the end.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`Delete`动词，就像保存一样，我们在最后添加了`RequireAuthorization`方法。
- en: Next, we need to do this for `Categories` and `Tags` as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要对`Categories`和`Tags`进行同样的操作。
- en: Adding APIs for handling Categories
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加处理类别的API
- en: 'Let’s start with `Categories`. Follow these steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Categories`开始。按照以下步骤操作：
- en: 'In the `Endpoints` folder, add a new class called `CategoryEndpoints.cs`. Replace
    the code with the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Endpoints`文件夹中，添加一个名为`CategoryEndpoints.cs`的新类。用以下代码替换代码：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `Program.cs`, add the following code just above `app.Run()`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在`app.Run()`上方添加以下代码：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These are all the methods needed to handle `Categories`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是处理`Categories`所需的所有方法。
- en: Next, let’s do the same thing with `Tags`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用`Tags`做同样的事情。
- en: Adding APIs for handling Tags
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加处理标签的API
- en: 'Let’s do the same things for Tags by following these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤为标签做同样的事情：
- en: 'In the `Endpoints` folder, add a new class called `TagEndpoints.cs`. Add the
    following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Endpoints`文件夹中，添加一个名为`TagEndpoints.cs`的新类。添加以下代码：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `Program.cs`, add the following code just above `app.Run()`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在`app.Run()`上方添加以下代码：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But wait! What about comments? The way we have implemented comments means that
    the component will never run as WebAssembly, so we don’t really need to implement
    it in the API. But we are not going to leave the comments hanging – let’s implement
    those as well!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！关于评论怎么办？我们实现评论的方式意味着该组件永远不会作为WebAssembly运行，所以我们实际上不需要在API中实现它。但我们不会让评论悬而未决——让我们也实现这些评论！
- en: Adding APIs for handling comments
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加处理评论的API
- en: 'Let’s do the same things for comments by following these steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤为评论做同样的事情：
- en: 'In the `Endpoints` folder, add a new class called `CommentEndpoints.cs`. Add
    the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Endpoints`文件夹中，添加一个名为`CommentEndpoints.cs`的新类。添加以下代码：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `Program.cs`, add the following code just above `app.Run()`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在`app.Run()`上方添加以下代码：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Great! We have an API! Now, it’s time to create the client that will access
    that API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们有了API！现在，是时候创建一个客户端来访问这个API了。
- en: Creating the client
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端
- en: To access the API, we need to create a client. There are many ways of doing
    this, but we will do it in the simplest way possible by writing the code ourselves.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问API，我们需要创建一个客户端。有多种方法可以做到这一点，但我们将以最简单的方式通过编写代码来实现。
- en: 'The client will implement the same `IBlogApi` interface. This way, we have
    the same code regardless of which implementation we are using, and direct JSON
    access with `BlogApiJsonDirectAccess` or `BlogApiWebClient`, which we are going
    to create next:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将实现相同的`IBlogApi`接口。这样，无论我们使用哪种实现，代码都是相同的，并且可以直接通过`BlogApiJsonDirectAccess`或`BlogApiWebClient`（我们接下来将要创建的）进行JSON访问：
- en: Right-click on the **Dependencies** node under `BlazorWebApp.Client` and select
    **Manage NuGet Packages**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp.Client`下的**Dependencies**节点上右键点击，并选择**Manage NuGet Packages**。
- en: Search for `Microsoft.AspNetCore.Components.WebAssembly.Authentication` and
    click **Install**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`Microsoft.AspNetCore.Components.WebAssembly.Authentication`并点击**Install**。
- en: Also, search for `Microsoft.Extensions.Http` and click **Install**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，搜索`Microsoft.Extensions.Http`并点击**Install**。
- en: In the `BlazorWebApp.Client` project, in the root of the project, add a new
    class and name it `BlogApiWebClient.cs`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp.Client`项目中，在项目根目录下添加一个新的类，并将其命名为`BlogApiWebClient.cs`。
- en: 'Open the newly created file and add the following namespaces:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的文件并添加以下命名空间：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add `IBlogApi` to the class and make it public like this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IBlogApi`添加到类中，并使其公开，如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some API calls will be public (do not require authentication), but `HttpClient`
    will be configured to require a token.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些API调用将是公开的（不需要认证），但`HttpClient`将被配置为需要令牌。
- en: The handling of tokens is handled automatically by Blazor, so we only need one
    client, and, in this case, we call it `Api`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 令牌的处理由Blazor自动处理，所以我们只需要一个客户端，在这个案例中，我们将其称为`Api`。
- en: 'To be able to call the API, we need to inject `HttpClient`. Add the following
    code to the class:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了能够调用API，我们需要注入`HttpClient`。将以下代码添加到类中：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, it’s time to implement calls to the API. Let’s begin with the *Get* calls
    for blog posts. Add the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现对API的调用了。让我们从博客文章的**Get**调用开始。添加以下代码：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use the `HttpClient` we injected and then call `GetFromJsonAsync`, which
    will automatically download the JSON and convert it into the class we supply to
    the generic method.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用注入的`HttpClient`，然后调用`GetFromJsonAsync`，这将自动下载JSON并将其转换为提供给泛型方法的类。
- en: 'Now, it gets a little trickier: we need to handle authentication. Luckily,
    this is built into `HttpClient` so we only need to handle `AccessTokenNotAvailableException`.
    If a token is missing, it will automatically try and renew it, but if there is
    a problem (for example, the user is not logged in), we can redirect to the login
    page.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，事情变得有点复杂：我们需要处理认证。幸运的是，这已经内置在`HttpClient`中，所以我们只需要处理`AccessTokenNotAvailableException`。如果令牌缺失，它将自动尝试更新它，但如果出现问题（例如，用户未登录），我们可以重定向到登录页面。
- en: We will come back to tokens and how authentication works in *Chapter 8*, *Authentication
    and Authorization*.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在**第8章**，**认证和授权**中回到令牌和认证的工作方式。
- en: Next, we add the API calls that need authentication, such as saving or deleting
    a blog post.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加需要认证的API调用，例如保存或删除博客文章。
- en: 'Add the following code under the code we just added:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码下方添加以下代码：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the call throws `AccessTokenNotAvailableException`, that means `HttpClient`
    couldn’t get or renew a token automatically, and the user needs to log in.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果调用抛出`AccessTokenNotAvailableException`，这意味着`HttpClient`无法自动获取或更新令牌，用户需要登录。
- en: This state should probably never happen because we will ensure that when the
    user navigates to that page, they will need to be logged in, but it’s better to
    be safe than sorry.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种状态可能永远不会发生，因为我们将会确保当用户导航到那个页面时，他们需要登录，但防患于未然总是好的。
- en: 'Now, we need to do the same for `Categories`. Add the following code to the
    `BlogApiWebClient` class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为`Categories`做同样的事情。将以下代码添加到`BlogApiWebClient`类中：
- en: '[PRE20]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next up, we will do the same for `Tags`. Add the following code just under
    the code we just added:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为`Tags`做同样的事情。将以下代码添加到我们刚刚添加的代码下方：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s not forget about our comments! Add the following code just under the
    code we just added:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们不要忘记我们的评论！将以下代码添加到我们刚刚添加的代码下方：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Great job! Our API client is now done!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们的API客户端现在已经完成了！
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create an API using Minimal APIs and an API
    client, which is an important part of most applications. This way, we can get
    blog posts from our database and show them when we are running on WebAssembly.
    It is worth mentioning that we can always run our applications using a web API;
    this is just to show that we can use different ways to access our data depending
    on what hosting model we are currently using.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Minimal APIs和API客户端创建一个API，这是大多数应用程序的重要组成部分。这样，我们就可以从数据库中获取博客文章，并在运行在WebAssembly时展示它们。值得一提的是，我们始终可以使用Web
    API来运行我们的应用程序；这只是为了展示我们可以根据当前使用的托管模型使用不同的方式来访问我们的数据。
- en: In the next chapter, we will add the login functionality to our sites and call
    our API for the first time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的网站添加登录功能，并首次调用我们的API。
