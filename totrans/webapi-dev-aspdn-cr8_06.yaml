- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Data Access in ASP.NET Core (Part 2 – Entity Relationships)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core中的数据访问（第二部分 - 实体关系）
- en: In [*Chapter 5*](B18971_05.xhtml#_idTextAnchor198), we introduced the fundamentals
    of `DbContext` class and how to use it to access data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18971_05.xhtml#_idTextAnchor198)中，我们介绍了`DbContext`类的基础知识以及如何使用它来访问数据。
- en: You can recap the basic concepts of relationships in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012),
    in the *Defining the Relationships between Resources* section, where we introduced
    relationships between resources. For example, in a blog system, a post has a collection
    of comments, and a user has a collection of posts. In an invoice system, an invoice
    has a collection of invoice items, and an invoice item belongs to an invoice.
    An invoice also has a contact, which can have one or more contact persons and
    can have one address.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[*第1章*](B18971_01.xhtml#_idTextAnchor012)的*定义资源之间的关系*部分回顾关系的基本概念，其中我们介绍了资源之间的关系。例如，在一个博客系统中，一篇帖子有一系列评论，一个用户有一系列帖子。在一个发票系统中，一个发票有一系列发票项，发票项属于发票。发票还有一个联系，它可以有一个或多个联系人，并且可以有一个地址。
- en: In this chapter, we will continue to explore the features of EF Core. We will
    learn how to manage relationships between entities using Fluent APIs. Finally,
    we will discuss how to implement CRUD operations for entities with relationships.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探索EF Core的功能。我们将学习如何使用Fluent APIs管理实体之间的关系。最后，我们将讨论如何为具有关系的实体实现CRUD操作。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding one-to-many relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解一对多关系
- en: Understanding one-to-one relationships
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解一对一关系
- en: Understanding many-to-many relationships
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多对多关系
- en: Understanding owned entities
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解拥有实体
- en: After reading this chapter, you should be able to configure relationships between
    entities using Fluent APIs in EF Core and implement CRUD operations for entities
    with relationships in your ASP.NET Core applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您应该能够使用EF Core的Fluent APIs配置实体之间的关系，并在您的ASP.NET Core应用程序中实现具有关系的实体的CRUD操作。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6).
    You can use VS 2022 or VS Code to open the solutions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6)找到。您可以使用VS
    2022或VS Code打开解决方案。
- en: 'You are expected to have basic knowledge of **Structured Query Language** (**SQL**)
    queries and **Language-Integrated Query** (**LINQ**). If you are not familiar
    with them, you can refer to the following resources:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 预期您对**结构化查询语言**（**SQL**）查询和**语言集成查询**（**LINQ**）有基本了解。如果您不熟悉它们，可以参考以下资源：
- en: '**SQL** **queries**: [https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL** **查询**: [https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)'
- en: '**LINQ**: [https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ**: [https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)'
- en: Understanding one-to-many relationships
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解一对多关系
- en: One-to-many relationships are the most common relationships in a relational
    database. They are also called **parent-child (children)** relationships. For
    example, an invoice has a collection of invoice items. In this section, we will
    learn how to configure a one-to-many relationship in EF Core and how to implement
    CRUD operations for entities with a one-to-many relationship.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多关系是关系型数据库中最常见的关系。它们也被称为**父子（子）**关系。例如，发票有一系列发票项。在本节中，我们将学习如何在EF Core中配置一对多关系，以及如何为具有一对多关系的实体实现CRUD操作。
- en: Let us continue to use the invoice sample application. You can find the sample
    code of the `EfCoreRelationshipsDemo` project in the `chapter6` folder. If you
    would like to test the code following the book, you can continue to work on the
    `BasicEfCoreDemo` project. Note that the `InvoiceDbContext` class has been renamed
    `SampleDbContext` in the sample code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用发票示例应用程序。您可以在`chapter6`文件夹中找到`EfCoreRelationshipsDemo`项目的示例代码。如果您想按照书中的说明测试代码，您可以继续在`BasicEfCoreDemo`项目上工作。请注意，示例代码中的`InvoiceDbContext`类已被重命名为`SampleDbContext`。
- en: Next, let us update the `Invoice` class and create an `InvoiceItem` class, then
    define the one-to-many relationship between them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新`Invoice`类并创建一个`InvoiceItem`类，然后定义它们之间的一对多关系。
- en: One-to-many configuration
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多配置
- en: To demonstrate a one-to-many relationship, we need to add a new class named
    `InvoiceItem` in the `Models` folder and add some additional properties to the
    `Invoice` class to represent the relationship between them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一对多关系，我们需要在`Models`文件夹中添加一个新的类名为`InvoiceItem`，并给`Invoice`类添加一些额外的属性来表示它们之间的关系。
- en: 'The code of the `InvoiceItem` class is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoiceItem`类的代码如下：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `InvoiceItem` class has a set of properties to store the invoice item data,
    such as `Name`, `Description`, `UnitPrice`, and so on. It also has an `InvoiceId`
    property to store the ID of the invoice that the invoice item belongs to, and
    an `Invoice` property to reference the invoice. To get started with the configuration
    process, follow these steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoiceItem`类有一组属性来存储发票项数据，例如`Name`、`Description`、`UnitPrice`等。它还有一个`InvoiceId`属性来存储发票项所属的发票ID，以及一个`Invoice`属性来引用发票。要开始配置过程，请按照以下步骤操作：'
- en: 'Update the `Invoice` class as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`Invoice`类：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we defined a relationship between `Invoice` and `InvoiceItem`.
    An invoice has a collection of invoice items, and an invoice item belongs to an
    invoice. It is a one-to-many relationship, where we can identify these terms:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了`Invoice`和`InvoiceItem`之间的关系。一张发票包含一系列的发票项，而一个发票项属于一个发票。这是一个一对多关系，我们可以识别以下术语：
- en: '`Invoice` is the principal entity.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoice`是主实体。'
- en: '`InvoiceItem` is the dependent entity. It has an `InvoiceId` foreign key property
    to identify the parent entity.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvoiceItem`是依赖实体。它有一个`InvoiceId`外键属性来识别父实体。'
- en: '`Id` property of the `Invoice` class is the principal key.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoice`类的`Id`属性是主键。'
- en: '`InvoiceId` property of the `InvoiceItem` class is the foreign key, which is
    used to store the principal key value of the parent entity.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvoiceItem`类的`InvoiceId`属性是外键，用于存储父实体的主键值。'
- en: '`InvoiceItems` property of the `Invoice` class is a collection navigation property.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoice`类的`InvoiceItems`属性是一个集合导航属性。'
- en: '`Invoice` property of the `InvoiceItem` class is a reference navigation property.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvoiceItem`类的`Invoice`属性是一个引用导航属性。'
- en: 'Because we added a new model, we need to update the `DbContext` class. Open
    the `SampleDbContext` class and add the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为添加了一个新的模型，我们需要更新`DbContext`类。打开`SampleDbContext`类并添加以下代码：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, it is a good practice to configure the mapping for the new model. Add
    a new class in the `Data` folder and name it `InvoiceItemConfiguration`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，配置新模型的映射也是一个好的实践。在`Data`文件夹中添加一个新的类，命名为`InvoiceItemConfiguration`：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we define navigation properties for `Invoice` and `InvoiceItem`, EF Core
    can discover the relationship between these two entities. Let us create a migration
    using the `dotnet ef migrations add AddInvoiceItem` command. Then, check the generated
    migration file. You will find that EF Core has added the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们为`Invoice`和`InvoiceItem`定义了导航属性，EF Core就可以发现这两个实体之间的关系。让我们使用`dotnet ef migrations
    add AddInvoiceItem`命令创建一个迁移。然后，检查生成的迁移文件。你会发现EF Core添加了以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: EF Core will create a new `InvoiceItems` table and add a foreign key constraint
    to the `InvoiceId` column. The name of the foreign key constraint is `FK_<dependent
    type name>_<principal type name>_<foreign key property name>`. It will also create
    an index on the `InvoiceId` column.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: EF Core将创建一个新的`InvoiceItems`表，并在`InvoiceId`列上添加一个外键约束。外键约束的名称是`FK_<依赖类型名称>_<主类型名称>_<外键属性名称>`。它还会在`InvoiceId`列上创建一个索引。
- en: Another thing you need to be aware of is that the `onDelete` action is set to
    `ReferentialAction.Cascade`, which means that if the parent entity is deleted,
    all related child entities will also be deleted.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件你需要注意的事情是，`onDelete`操作被设置为`ReferentialAction.Cascade`，这意味着如果父实体被删除，所有相关的子实体也将被删除。
- en: 'Let''s think about a question – what if we do not have the `InvoiceId` property
    in the `InvoiceItem` class? Can EF Core still discover the relationship between
    these two entities? You can use the `dotnet ef migrations remove` command to remove
    the last migration, delete the `InvoiceId` property in the `InvoiceItem` class,
    and then add a migration again. You will see that EF Core can still create a column
    named `InvoiceId` in the `InvoiceItems` table, and apply the foreign key constraint
    to it, which is called **shadow foreign key** property. This is because EF Core
    has its built-in convention to do this. There are a few scenarios where EF Core
    can discover one-to-many relationships between entities:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一个问题——如果我们没有在 `InvoiceItem` 类中拥有 `InvoiceId` 属性，EF Core 还能发现这两个实体之间的关系吗？你可以使用
    `dotnet ef migrations remove` 命令来删除最后一个迁移，删除 `InvoiceItem` 类中的 `InvoiceId` 属性，然后再次添加迁移。你会看到
    EF Core 仍然可以在 `InvoiceItems` 表中创建一个名为 `InvoiceId` 的列，并将其应用到外键约束上，这被称为**影子外键**属性。这是因为
    EF Core 有其内置的约定来做这件事。有几个场景下，EF Core 可以发现实体之间的一对多关系：
- en: The dependent entity has a reference navigation property to the principal entity
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从属实体有一个到主实体的引用导航属性
- en: The principal entity has a collection navigation property to the dependent entity
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主实体有一个到从属实体的集合导航属性
- en: The reference navigation property and the collection navigation property are
    included at both ends
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用导航属性和集合导航属性在两端都包含
- en: The reference navigation property and the collection navigation property are
    included at both ends, and the foreign key property is included in the dependent
    entity
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用导航属性和集合导航属性在两端都包含，外键属性包含在从属实体中
- en: 'We can explicitly configure the relationship between entities to change the
    default behavior of EF Core if the convention does not work for us. Follow these
    steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约定对我们不起作用，我们可以显式配置实体之间的关系来改变 EF Core 的默认行为。按照以下步骤操作：
- en: 'To explicitly configure the one-to-many relationship between entities, we can
    use the `HasOne()`, `WithMany()`, and `HasMany()`, `WithOne()` methods. Add the
    following code to the `InvoiceConfiguration` class:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显式配置实体之间的一对多关系，我们可以使用 `HasOne()`、`WithMany()`、`HasMany()` 和 `WithOne()` 方法。将以下代码添加到
    `InvoiceConfiguration` 类中：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `HasMany()` method is used to configure the collection navigation property,
    and the `WithOne()` method is used to configure the reference navigation property.
    The `HasForeignKey()` method is used to configure the foreign key property. So,
    the preceding code explicitly configures that one invoice can have many invoice
    items, and the `InvoiceId` property of the `InvoiceItem` class is the foreign
    key. If you add a migration now, you will find that EF Core will generate the
    same code as that generated by the convention.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HasMany()` 方法用于配置集合导航属性，而 `WithOne()` 方法用于配置引用导航属性。`HasForeignKey()` 方法用于配置外键属性。因此，前面的代码明确配置了一个发票可以有多个发票项，并且
    `InvoiceItem` 类的 `InvoiceId` 属性是外键。如果你现在添加一个迁移，你会发现 EF Core 会生成与约定生成相同的代码。'
- en: 'A relationship can be also defined for the `InvoiceItem` class. Remove the
    preceding configuration code for the `Invoice` class, and add the following code
    to the `InvoiceItemConfiguration` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以为 `InvoiceItem` 类定义关系。删除 `Invoice` 类的前置配置代码，并将以下代码添加到 `InvoiceItemConfiguration`
    类中：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It should be easy to understand now. The `HasOne()` method is used to configure
    the reference navigation property, and the `WithMany` method is used to configure
    the collection navigation property.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在应该容易理解了。`HasOne()` 方法用于配置引用导航属性，而 `WithMany` 方法用于配置集合导航属性。
- en: Note that we also explicitly configured the `OnDelete()` action to `Cascade`,
    which is the same as the one generated by the convention. But we can change it
    to other options if needed. That said, the Fluent API is more flexible than the
    convention.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们还明确配置了 `OnDelete()` 动作到 `Cascade`，这与约定生成的相同。但如果需要，我们可以将其更改为其他选项。也就是说，Fluent
    API 比约定更灵活。
- en: 'We just need to configure the relationship on one side of the relationship.
    So, please clean up the test code before you add the migration file and apply
    the migration to the database. After the migration is applied, you can check the
    database schema to see if the foreign key constraint is created, as shown in the
    following figure:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要在关系的一侧配置关系。因此，请在添加迁移文件并应用迁移到数据库之前清理测试代码。迁移应用后，你可以检查数据库模式，看看是否创建了外键约束，如图下所示：
- en: '![Figure 6.1 – A foreign key constraint is created in the database](img/B18971_06_1.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 数据库中创建了一个外键约束](img/B18971_06_1.jpg)'
- en: Figure 6.1 – A foreign key constraint is created in the database
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 数据库中创建了一个外键约束
- en: As a one-to-many relationship can be defined in either direction, which side
    should we configure the relationship on? It depends on the scenario. If the two
    entities have a strong one-to-many relationship, it does not really matter which
    side we configure the relationship on. But if the two entities are loosely coupled,
    we had better configure the relationship on the dependent entity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一对一关系可以在任一方向上定义，我们应该在哪个方向上配置关系呢？这取决于场景。如果两个实体之间有一对一的关系非常强，那么我们在哪一侧配置关系实际上并不重要。但如果两个实体之间是松散耦合的，我们最好在依赖实体上配置关系。
- en: For example, a `User` entity is shared by many other entities, such as `Post`,
    `Comment`, `Invoice`, and so on. Each `Post` entity can have an `Author` property
    that is a reference navigation property to the `User` entity, and `Comment` and
    `Invoice` also do the same. However, the `User` entity does not need to have the
    collection navigation properties to the `Post`, `Comment`, and `Invoice` entities.
    In this case, we should configure the relationship on the `Post`, `Comment`, and
    `Invoice` entities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`User` 实体被许多其他实体共享，例如 `Post`、`Comment`、`Invoice` 等。每个 `Post` 实体可以有一个 `Author`
    属性，它是对 `User` 实体的引用导航属性，`Comment` 和 `Invoice` 也同样如此。然而，`User` 实体不需要对 `Post`、`Comment`
    和 `Invoice` 实体有集合导航属性。在这种情况下，我们应该在 `Post`、`Comment` 和 `Invoice` 实体上配置关系。
- en: 'To configure this kind of relationship, we can ignore the parameter for the
    `WithMany` method, because the `User` entity does not have the collection navigation
    property to the `Post` entity, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置这种关系，我们可以忽略 `WithMany` 方法的参数，因为 `User` 实体没有对 `Post` 实体的集合导航属性，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, let's see how we implement CRUD operations for entities with a one-to-many
    relationship.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何实现具有一对一关系的实体的 CRUD 操作。
- en: One-to-many CRUD operations
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多 CRUD 操作
- en: CRUD operations for entities with a one-to-many relationship differ from those
    without a relationship. For example, when retrieving an invoice, we may need to
    query both the `Invoices` table and the `InvoiceItems` table in order to also
    retrieve the associated invoice items. Additionally, when deleting an invoice,
    we must consider whether to delete the related invoice items as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一对多关系的实体的 CRUD 操作与没有关系的实体不同。例如，当检索一个发票时，我们可能需要查询 `Invoices` 表和 `InvoiceItems`
    表，以便检索相关的发票项目。此外，当删除一个发票时，我们必须考虑是否也要删除相关的发票项目。
- en: EF Core can assist us in managing various scenarios. For instance, when we need
    to retrieve an invoice and its invoice items, EF Core can generate a `LEFT JOIN`
    query to join the two tables. To implement CRUD operations for entities with a
    one-to-many relationship, let us explore the following sections.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 可以帮助我们管理各种场景。例如，当我们需要检索一个发票及其发票项目时，EF Core 可以生成一个 `LEFT JOIN` 查询来连接两个表。为了实现具有一对一关系的实体的
    CRUD 操作，让我们探索以下部分。
- en: Creating data
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据
- en: 'First, let us create a new invoice with a few invoice items. You do not need
    to update the code of the `PostInvoice` action:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的发票，并包含一些发票项目。你不需要更新 `PostInvoice` 动作的代码：
- en: 'Run the application using `dotnet run`. Send a `POST` request to the `/api/Invoices`
    endpoint. The JSON body is like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 运行应用程序。向 `/api/Invoices` 端点发送一个 `POST` 请求。JSON 主体如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The exception is thrown because the `Invoice` class has a collection navigation
    property to the `InvoiceItem` class, and the `InvoiceItem` class has a reference
    navigation property to the `Invoice` class. So, there is a cycle in the JSON serialization.
    Some serialization frameworks, such as `Newtonsoft.Json`, `System.Text.Json`,
    do not allow such cycles. ASP.NET Core uses `System.Text.Json` for JSON serialization
    by default. So, we need to configure the `System.Text.Json` framework to ignore
    the cycle.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 异常被抛出是因为`Invoice`类有一个到`InvoiceItem`类的集合导航属性，而`InvoiceItem`类有一个到`Invoice`类的引用导航属性。因此，在JSON序列化中存在循环。一些序列化框架，如`Newtonsoft.Json`、`System.Text.Json`，不允许这样的循环。ASP.NET
    Core默认使用`System.Text.Json`进行JSON序列化。因此，我们需要配置`System.Text.Json`框架以忽略循环。
- en: 'Open the `Program.cs` file and add the following code to `builder.Services.AddControllers()`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，并在`builder.Services.AddControllers()`中添加以下代码：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another way to fix the exception is to use the `[JsonIgnore]` attribute to decorate
    the `Invoice` property in the `InvoiceItem` class. But if you have many entities
    with such a relationship, it is tedious to decorate all of them. Choose the way
    you prefer.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种修复异常的方法是在`InvoiceItem`类中用`[JsonIgnore]`属性装饰`Invoice`属性。但如果你有许多具有这种关系的实体，装饰所有这些实体会很麻烦。选择你喜欢的做法。
- en: 'This exception occurs after data is saved to the database. So, if you check
    the database, you will find that the invoice and the invoice items are saved to
    the database:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此异常发生在数据保存到数据库之后。因此，如果你检查数据库，你会发现在数据库中保存了发票和发票项目：
- en: '![Figure 6.2 – The invoice items are saved to the database with the invoice
    ID](img/B18971_06_2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 发票项目以发票ID保存到数据库中](img/B18971_06_2.jpg)'
- en: Figure 6.2 – The invoice items are saved to the database with the invoice ID
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 发票项目以发票ID保存到数据库中
- en: What is System.Text.Json?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是System.Text.Json？
- en: '`System.Text.Json` is a new JSON serialization framework provided since .NET
    Core 3.0\. It is faster and more efficient than `Newtonsoft.Json`. It is also
    the default JSON serialization framework in ASP.NET Core 3.0 and later versions.
    It is recommended to use `System.Text.Json` instead of `Newtonsoft.Json` in new
    projects.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Text.Json`是从.NET Core 3.0开始提供的一个新的JSON序列化框架。它比`Newtonsoft.Json`更快、更高效。它也是ASP.NET
    Core 3.0及以后版本的默认JSON序列化框架。建议在新项目中使用`System.Text.Json`而不是`Newtonsoft.Json`。'
- en: 'From the preceding example, you can see these points:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，你可以看到以下这些点：
- en: EF Core generates an `Id` property of the principal entity if it is not defined
    in the model.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core如果模型中未定义，将为主实体生成一个`Id`属性。
- en: EF Core generates an `Id` property of the dependent entity if it is not defined
    in the model.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core如果模型中未定义，将为从属实体生成一个`Id`属性。
- en: EF Core generates a foreign key property of the dependent entity, which is `InvoiceId`
    in this case, if it is not defined in the model.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core在模型中未定义的情况下，为从属实体生成一个外键属性，在这个例子中是`InvoiceId`。
- en: When the principal entity is added to the database, dependent entities are also
    added to the database automatically. You do not need to add dependent entities
    explicitly.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当主实体被添加到数据库时，从属实体也会自动添加到数据库中。你不需要显式添加从属实体。
- en: 'So, what if you want to add a new invoice item to an existing invoice? You
    can do it in two ways:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你想要向现有发票中添加一个新的发票项目，你可以通过两种方式来完成：
- en: Get the invoice first, then add the new invoice item to the `InvoiceItems` collection
    of the invoice, and then call the `SaveChanges()` method to save the changes to
    the database. This is an `Update` operation for the invoice, which means it should
    be a `PUT` action.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先获取发票，然后将新的发票项目添加到发票的`InvoiceItems`集合中，然后调用`SaveChanges()`方法将更改保存到数据库。这是发票的`Update`操作，意味着它应该是一个`PUT`操作。
- en: Create a new invoice item, set the `InvoiceId` property to the `Id` property
    of the invoice, and then call the `SaveChanges()` method to save the changes to
    the database. This is a `Create` operation for the invoice item, which means it
    should be a `POST` action. Also, you need to provide an endpoint for the invoice
    item separately.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的发票项目，将`InvoiceId`属性设置为发票的`Id`属性，然后调用`SaveChanges()`方法将更改保存到数据库。这是发票项目的`Create`操作，意味着它应该是一个`POST`操作。此外，你需要为发票项目单独提供一个端点。
- en: An invoice item cannot exist without an invoice. So, typically, you interact
    with the invoice item through the invoice. From a practical point of view, the
    first way is more common if the dependent entity count is not large. However,
    it depends on your scenario. If the principal entity has a large number of dependent
    entities, updating the entire principal entity may be inefficient and expensive.
    In this case, you can expose a separate endpoint to operate the dependent entity.
    For example, one blog post may have a large number of comments. It is common to
    add a new comment to a blog post, but it is not necessary to update the entire
    blog post and other comments. This is related to another concept, **domain-driven
    design** (**DDD**), which is to model domain objects and their relationships.
    We will talk about it in later chapters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一张发票项不能脱离发票而存在。因此，通常情况下，您会通过发票与发票项进行交互。从实际的角度来看，如果依赖实体的数量不是很大，第一种方式更为常见。然而，这取决于您的场景。如果主要实体有大量的依赖实体，更新整个主要实体可能既低效又昂贵。在这种情况下，您可以公开一个单独的端点来操作依赖实体。例如，一篇博客文章可能有大量的评论。向博客文章添加新评论是常见的，但更新整个博客文章和其他评论并不是必要的。这与另一个概念有关，即**领域驱动设计**（**DDD**），它是对领域对象及其关系的建模。我们将在后面的章节中讨论它。
- en: Querying data
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询数据
- en: 'Now we have an invoice and some invoice items in the database, we can send
    a `GET` request to the `/api/Invoices` endpoint. You can see the following response:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在数据库中有了发票和一些发票项，我们可以向`/api/Invoices`端点发送一个`GET`请求。您可以看到以下响应：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The response contains a list of invoices. But the `InvoiceItems` property is
    empty. This is because the `InvoiceItems` property is a collection navigation
    property. By default, EF Core does not include dependent entities in the query
    result, so you need to explicitly include these in the query result. Follow these
    steps to query the invoice and invoice items from the database:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含发票列表。但`InvoiceItems`属性为空。这是因为`InvoiceItems`属性是一个集合导航属性。默认情况下，EF Core不会在查询结果中包含依赖实体，因此您需要显式地将这些包含在查询结果中。按照以下步骤从数据库查询发票和发票项：
- en: 'Open the `InvoicesController.cs` file, and update the code of the `GetInvoices()`
    method to this:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`InvoicesController.cs`文件，并将`GetInvoices()`方法的代码更新如下：
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we use the `Include` method to include dependent entities
    in the query result.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`Include`方法将依赖实体包含在查询结果中。
- en: 'Restart the application and send the same request again. Now, you will see
    the result includes invoice items, as shown here:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序并再次发送相同的请求。现在，您将看到结果包括发票项，如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you see, when the LINQ query uses the `Include()` method to include dependent
    entities, EF Core will generate a `LEFT` `JOIN` query.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，当LINQ查询使用`Include()`方法包含依赖实体时，EF Core将生成一个`LEFT` `JOIN`查询。
- en: Important note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `Include()` method is a convenient way to include dependent entities. However,
    it may cause performance issues when the collection of dependent entities is large.
    For example, a post may have hundreds or thousands of comments. It is not a good
    idea to include all comments in the query result for a list page. In this case,
    it is not necessary to include dependent entities in the query.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Include()`方法是一个方便的方法来包含依赖实体。然而，当依赖实体的集合很大时，它可能会引起性能问题。例如，一个帖子可能有数百或数千条评论。在列表页的查询结果中包含所有评论并不是一个好主意。在这种情况下，没有必要在查询中包含依赖实体。'
- en: 'Note that the query includes `Invoice` data in each row of the result. For
    some scenarios, it may cause a so-called `AsSplitQuery()` method as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，查询在结果中的每一行都包含了`Invoice`数据。对于某些场景，它可能会引起所谓的`AsSplitQuery()`方法，如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The query contains two `SELECT` statements. The first `SELECT` statement is
    used to query the invoices. The second `SELECT` statement is used to query the
    invoice items. The `INNER JOIN` query is used to join the two queries.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询包含两个`SELECT`语句。第一个`SELECT`语句用于查询发票。第二个`SELECT`语句用于查询发票项。`INNER JOIN`查询用于连接这两个查询。
- en: 'You can also configure the default query-splitting behavior globally by using
    the `UseQuerySplittingBehavior()` method in the `OnConfiguring()` method of your
    `DbContext` class. The following code shows how to configure the default query
    splitting behavior to `SplitQuery` in the `SampleDbContext` class:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以通过在`DbContext`类的`OnConfiguring()`方法中使用`UseQuerySplittingBehavior()`方法来全局配置默认查询拆分行为。以下代码显示了如何在`SampleDbContext`类中将默认查询拆分行为配置为`SplitQuery`：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, you don’t need to use the `AsSplitQuery()` method in your LINQ
    queries. If you want to execute a specific query in a single query, you can use
    the `AsSingleQuery()` method like this:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，你不需要在你的 LINQ 查询中使用 `AsSplitQuery()` 方法。如果你想在一个查询中执行特定的查询，你可以使用 `AsSingleQuery()`
    方法，如下所示：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, split queries may cause other issues. For example, multiple queries
    increase the number of round trips to the database. In addition, if another thread
    modifies the data between the two queries, the result may be inconsistent. Therefore,
    you should consider the pros and cons of split queries to fit your scenarios.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拆分查询可能会导致其他问题。例如，多个查询会增加数据库往返次数的数量。此外，如果另一个线程在两个查询之间修改了数据，结果可能不一致。因此，你应该考虑拆分查询的优缺点，以适应你的场景。
- en: Retrieving data
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索数据
- en: 'Next, let''s see how to retrieve data by ID. In the `GetInvoice` action, we
    use `await _context.Invoices.FindAsync(id)` to find the invoice by its ID. Send
    a `Get` request to the `/api/Invoices/{id}` endpoint with a valid ID. You will
    see the response contains an empty `InvoiceItems` array. This is because the `InvoiceItems`
    property is not included in the query. To include the `InvoiceItems` property
    in the query, you can use the `Include` method in the LINQ query. The following
    code shows how to use the `Include` method to include the `InvoiceItems` property
    in the query:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何通过 ID 检索数据。在 `GetInvoice` 动作中，我们使用 `await _context.Invoices.FindAsync(id)`
    通过其 ID 查找发票。向 `/api/Invoices/{id}` 端点发送一个有效的 `Get` 请求。你将看到响应包含一个空的 `InvoiceItems`
    数组。这是因为查询中没有包含 `InvoiceItems` 属性。要包含 `InvoiceItems` 属性在查询中，你可以在 LINQ 查询中使用 `Include`
    方法。以下代码展示了如何使用 `Include` 方法将 `InvoiceItems` 属性包含在查询中：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The generated SQL query is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 查询如下：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The query contains two `SELECT` statements, and the `INNER JOIN` query is used
    to join the two statements. In this way, you can retrieve the invoice and invoice
    items in a single query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查询包含两个 `SELECT` 语句，并且使用 `INNER JOIN` 查询将两个语句连接起来。这样，你可以在单个查询中检索发票和发票项目。
- en: Deleting data
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'In the *One-to-many configuration* section, we introduced how to configure
    the `OnDelete` action to set the `DeleteBehavior` enum to `Cascade`. There are
    other options for the `DeleteBehavior` enum. Think about the following scenario
    in a one-to-many relationship:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *一对一配置* 部分，我们介绍了如何配置 `OnDelete` 动作，将 `DeleteBehavior` 枚举设置为 `Cascade`。`DeleteBehavior`
    枚举还有其他选项。考虑以下一对一关系中的场景：
- en: An invoice has a list of invoice items
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个发票有一系列发票项目
- en: A user deletes an invoice
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户删除一个发票
- en: 'In this case, you may want to delete the related invoice items when the invoice
    is deleted because an invoice item cannot exist without an invoice. This behavior
    is called **cascade delete**. To delete the data, follow these steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，当删除发票时，你可能想要删除相关的发票项目，因为一个发票项目不能在没有发票的情况下存在。这种行为被称为**级联删除**。要删除数据，请按照以下步骤操作：
- en: 'Run the application and send a `Delete` request to the `/api/Invoices/{id}`
    endpoint with a valid ID. You will see the invoice and the related invoice items
    are deleted from the database. Note that if the `OnDelete()` method is configured
    as `Cascade` or `ClientCascade`, loading related entities using the `Include()`
    method in the LINQ query is not required. The cascade delete behavior is applied
    at the database level. You can see the generated SQL query, which just deletes
    the `Invoice` entity, here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/api/Invoices/{id}` 端点发送一个有效的 `Delete` 请求。你将看到发票和相关发票项目从数据库中删除。请注意，如果
    `OnDelete()` 方法配置为 `Cascade` 或 `ClientCascade`，则在使用 LINQ 查询中的 `Include()` 方法加载相关实体时不需要。级联删除行为在数据库级别应用。你可以在这里看到生成的
    SQL 查询，它仅删除 `Invoice` 实体：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, in some scenarios, you may want to keep dependent entities when the
    principal entity is deleted, for example:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在某些场景中，你可能希望在删除主实体时保留依赖实体，例如：
- en: A category has a list of blog posts
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类别有一系列博客文章
- en: A user deletes a category
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户删除一个类别
- en: It is not necessary to delete blog posts when a category is deleted, because
    the blog posts can still exist without a category and can be assigned to another
    category. However, if a category is deleted, the `CategoryId` property of a blog
    post, which is a foreign key, will no longer match the primary key of any category.
    Therefore, you may want to set the `CategoryId` property to `null` when a category
    is deleted. This behavior is called `CategoryId` property is nullable. If the
    `CategoryId` property of a blog post entity is not nullable, EF Core will throw
    an exception when you try to delete a category because it will violate the foreign
    key constraint.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当删除类别时，没有必要删除博客文章，因为博客文章可以在没有类别的情况下存在，并且可以被分配给另一个类别。然而，如果删除类别，博客文章的外键属性 `CategoryId`
    将不再匹配任何类别的主键。因此，你可能希望在删除类别时将 `CategoryId` 属性设置为 `null`。这种行为被称为 `CategoryId` 属性是可空的。如果博客文章实体的
    `CategoryId` 属性不可空，当你尝试删除类别时，EF Core 将抛出异常，因为它将违反外键约束。
- en: In the sample code, there is an example of this case. You can find the `Category`
    and `Post` classes in the `Models` folder. Similar to the `Invoice` and `InvoiceItem`
    classes, they have a one-to-many relationship. However, the `CategoryId` property
    in the `Post` class is nullable. Therefore, you can set `DeleteBehavior` to `ClientSetNull`
    to nullify the `CategoryId` property when a category is deleted.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例代码中，有一个此类情况的示例。你可以在 `Models` 文件夹中找到 `Category` 和 `Post` 类。与 `Invoice` 和 `InvoiceItem`
    类类似，它们有一个一对一的关系。然而，`Post` 类中的 `CategoryId` 属性是可空的。因此，当删除类别时，你可以将 `DeleteBehavior`
    设置为 `ClientSetNull` 以使 `CategoryId` 属性为空。
- en: 'The following code shows how to configure `DeleteBehavior` to `ClientSetNull`:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码展示了如何将 `DeleteBehavior` 配置为 `ClientSetNull`：
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `OnDelete()` method, you can pass the `DeleteBehavior` enum to set `DeleteBehavior`
    to `ClientSetNull`. The `ClientSetNull` value means that the foreign key property
    will be set to `null` when the principal entity is deleted.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `OnDelete()` 方法中，你可以传递 `DeleteBehavior` 枚举来将 `DeleteBehavior` 设置为 `ClientSetNull`。`ClientSetNull`
    的值表示当主实体被删除时，外键属性将被设置为 `null`。
- en: 'In the `CategoriesController` class, you can find the `DeleteCategory()` method.
    It is similar to the `DeleteInvoice()` method in the `InvoicesController` class.
    The only difference is that we need to remove the relationship between the category
    and the blog posts before deleting the category. The following code shows how
    to remove the relationship between the category and the blog posts:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CategoriesController` 类中，你可以找到 `DeleteCategory()` 方法。它与 `InvoicesController`
    类中的 `DeleteInvoice()` 方法类似。唯一的区别是我们需要在删除类别之前移除类别和博客文章之间的关系。以下代码展示了如何移除类别和博客文章之间的关系：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can clear the `Posts` property of the category entity, or you can update
    the `Category` property of the blog posts to set it to `null`. In this way, the
    `CategoryId` property of the blog posts will be set to `null` when the category
    is deleted. Also, it is required to load related entities using the `Include`
    method, because EF Core needs to track the changes of related entities as well.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以清除类别实体的 `Posts` 属性，或者你可以更新博客文章的 `Category` 属性将其设置为 `null`。这样，当删除类别时，博客文章的
    `CategoryId` 属性将被设置为 `null`。此外，使用 `Include` 方法加载相关实体是必需的，因为 EF Core 需要跟踪相关实体的更改。
- en: 'Run the application and send a `Delete` request to the `/api/Categories/{id}`
    endpoint with a valid ID. Check the database, and you will see the category is
    deleted, but the blog posts are not deleted. Instead, the **CategoryId** property
    of the blog posts is set to **NULL**:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/api/Categories/{id}` 端点发送一个有效的 ID 的 `Delete` 请求。检查数据库，你会发现该类别已被删除，但博客文章并未被删除。相反，博客文章的
    **CategoryId** 属性被设置为 **NULL**：
- en: '![Figure 6.3 – The CategoryId property of the blog posts is set to NULL when
    the category is deleted](img/B18971_06_3.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 当类别被删除时，博客文章的 CategoryId 属性被设置为 NULL](img/B18971_06_3.jpg)'
- en: Figure 6.3 – The CategoryId property of the blog posts is set to NULL when the
    category is deleted
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 当类别被删除时，博客文章的 CategoryId 属性被设置为 NULL
- en: 'Check the generated SQL query, and you will see that EF Core executes two SQL
    queries. The first query is to update the `CategoryId` property of the blog posts
    to `null`. The second query is to delete the category. The generated SQL query
    is as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查生成的 SQL 查询，你会发现 EF Core 执行了两个 SQL 查询。第一个查询是将博客文章的 `CategoryId` 属性更新为 `null`。第二个查询是删除类别。生成的
    SQL 查询如下：
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That says the posts now have no category, which means the relationship between
    the category and the blog posts is removed. You can assign the blog posts to another
    category to recreate the relationship following your business logic.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着现在帖子没有分类，也就是说分类和博客文章之间的关系已经被移除。你可以将博客文章分配到另一个分类中，以根据你的业务逻辑重新创建这种关系。
- en: It is important to understand the consequences of deleting an entity when it
    has relationships. Keep in mind that some databases may not support cascading
    deletes. So, the `DeleteBehavior` enum contains quite a few values to allow you
    to fine-tune the behavior when deleting an entity. Generally, it is recommended
    to use `ClientCascade` or `ClientSetNull` because EF Core can perform cascading
    deletes or nullification if the database does not support cascading deletes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除具有关系的实体时，了解其后果是很重要的。请记住，某些数据库可能不支持级联删除。因此，`DeleteBehavior` 枚举包含很多值，以便你在删除实体时进行微调。通常，建议使用
    `ClientCascade` 或 `ClientSetNull`，因为 EF Core 可以在数据库不支持级联删除的情况下执行级联删除或置为空操作。
- en: 'So far, we have learned how to configure a one-to-many relationship and how
    to implement CRUD operations for entities with a one-to-many relationship. Next,
    let''s move on to another type of relationship: a one-to-one relationship.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何配置一对多关系以及如何为具有一对多关系的实体实现 CRUD 操作。接下来，让我们继续学习另一种类型的关系：一对一关系。
- en: Understanding one-to-one relationships
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解一对一关系
- en: A one-to-one relationship means that one entity has a relationship with only
    one entity of another type. For example, a bicycle requires one lock, which can
    only be used for that particular bicycle. Similarly, a person is only allowed
    to possess one driver’s license, which is designated for their use only. In our
    sample code, a `Contact` entity has only one `Address` entity, and an `Address`
    entity belongs to only one `Contact` entity. In the previous section, you learned
    how to configure a one-to-many relationship using the `HasOne()/WithMany()` and
    `HasMany()/WithOne()` methods. In this section, you will learn how to configure
    a one-to-one relationship using the `HasOne()` and `WithOne()` methods.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关系意味着一个实体只与另一个类型的单个实体有关联。例如，一辆自行车需要一个锁，这个锁只能用于那辆特定的自行车。同样，一个人只能拥有一个驾驶证，这个驾驶证仅供他们使用。在我们的示例代码中，一个
    `Contact` 实体只有一个 `Address` 实体，一个 `Address` 实体只属于一个 `Contact` 实体。在前一节中，你学习了如何使用
    `HasOne()/WithMany()` 和 `HasMany()/WithOne()` 方法配置一对多关系。在本节中，你将学习如何使用 `HasOne()`
    和 `WithOne()` 方法配置一对一关系。
- en: One-to-one configuration
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一配置
- en: 'In a one-to-one relationship, both sides have a reference navigation property.
    Technically, both sides have equal positions. However, to explicitly configure
    the relationship, we need to specify which side is the dependent side and which
    side is the principal side. The foreign key property is normally defined on the
    dependent side. In the following example, we will configure a one-to-one relationship
    between the `Contact` class and the `Address` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在一对一关系中，双方都有一个引用导航属性。技术上，双方处于平等的位置。然而，为了显式配置关系，我们需要指定哪一方是依赖方，哪一方是主方。外键属性通常定义在依赖方。在以下示例中，我们将配置
    `Contact` 类和 `Address` 类之间的一对一关系：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, a `ContactId` foreign key is defined in the `Address`
    class, which implies that the `Address` class is the dependent entity, and the
    `Contact` class is the principal entity. If you do not define a foreign key property
    here, EF Core will automatically choose one of the entities to be the dependent
    entity. However, because `Contact` and `Address` are equal in a one-to-one relationship,
    EF Core may not choose the correct entity as we expect. So, we need to explicitly
    define a foreign key property in the dependent entity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Address` 类中定义了一个 `ContactId` 外键，这意味着 `Address` 类是依赖实体，而 `Contact` 类是主实体。如果你在这里没有定义外键属性，EF
    Core 将会自动选择一个实体作为依赖实体。然而，由于 `Contact` 和 `Address` 在一对一关系中是平等的，EF Core 可能不会选择我们期望的正确实体。因此，我们需要在依赖实体中显式定义一个外键属性。
- en: 'The configuration of a one-to-one relationship is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关系的配置如下：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code uses `HasOne`/`WithOne` to define the one-to-one relationship.
    This can be defined in either the `Contact` configuration or `Address` configuration.
    The `HasForeignKey` method is used to specify the foreign key property. If you
    want to define the relationship in the `Contact` configuration, the code may look
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `HasOne`/`WithOne` 来定义一对一关系。这可以在 `Contact` 配置或 `Address` 配置中定义。使用 `HasForeignKey`
    方法来指定外键属性。如果您想在 `Contact` 配置中定义关系，代码可能如下所示：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the following code to add the migration and update the database:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以添加迁移并更新数据库：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will see the following code creates a `ContactId` foreign key on the `Addresses`
    table:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下代码在 `Addresses` 表上创建了一个 `ContactId` 外键：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After the migration is applied, the relationship between **Contacts** and **Addresses**
    is configured successfully, as shown in *Figure 6**.4*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移应用后，**联系人**和**地址**之间的关系配置成功，如图 *6.4* 所示。4*：
- en: '![Figure 6.4 – A ContactId foreign key is created on the Addresses table](img/B18971_06_4.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 在 `Addresses` 表上创建了一个 `ContactId` 外键](img/B18971_06_4.jpg)'
- en: Figure 6.4 – A ContactId foreign key is created on the Addresses table
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 在 `Addresses` 表上创建了一个 `ContactId` 外键
- en: Next, let's see how to implement CRUD operations for entities with a one-to-one
    relationship.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何实现具有一对一关系的实体的 CRUD 操作。
- en: One-to-one CRUD operations
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一 CRUD 操作
- en: The CRUD operations of a one-to-one relationship are similar to those of a one-to-many
    relationship. EF Core can simplify CRUD operations for you. So, in this section,
    we will not explain all CRUD operations in detail. You will find a controller
    named `ContactsController.cs` in the sample repo, which implements CRUD operations
    for the `Contact` entity. You can check the code for the details.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关系的 CRUD 操作与一对多关系的 CRUD 操作类似。EF Core 可以为您简化 CRUD 操作。因此，在本节中，我们不会详细解释所有 CRUD
    操作。您将在示例仓库中找到一个名为 `ContactsController.cs` 的控制器，该控制器实现了 `Contact` 实体的 CRUD 操作。您可以检查代码以获取详细信息。
- en: 'The `Contact` and `Address` entities have a one-to-one relationship, meaning
    each `Contact` entity has one `Address` property and each `Address` entity belongs
    to only one `Contact` property. To illustrate how to query a contact with its
    address, we will use this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact` 和 `Address` 实体之间存在一对一关系，这意味着每个 `Contact` 实体有一个 `Address` 属性，每个 `Address`
    实体只属于一个 `Contact` 属性。为了说明如何查询带有其地址的联系人，我们将使用以下示例：'
- en: 'To create a new contact with its address, you can send a `POST` request to
    the `api/contacts` endpoint. The request body is as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的联系人及其地址，您可以向 `api/contacts` 端点发送 `POST` 请求。请求体如下所示：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the JSON request body, the `address` object is a property of the `Contact`
    object. It is not required to send the `ContactId` property in the request body.
    EF Core will automatically set the `ContactId` property to the `Id` property of
    the `Contact` object.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 JSON 请求体中，`address` 对象是 `Contact` 对象的一个属性。在请求体中不需要发送 `ContactId` 属性。EF Core
    会自动将 `ContactId` 属性设置为 `Contact` 对象的 `Id` 属性。
- en: 'Similarly, when you query the contacts through the `api/contacts` endpoint,
    the `Address` object will not be included in the response body by default. You
    need to explicitly use the `Include` method to include the `Address` object in
    the query, as shown in the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，当您通过 `api/contacts` 端点查询联系人时，默认情况下不会在响应体中包含 `Address` 对象。您需要显式使用 `Include`
    方法将 `Address` 对象包含在查询中，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can check the `ContactsController.cs` file for other CRUD operations and
    test them in Postman or any other REST client you like.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查 `ContactsController.cs` 文件中的其他 CRUD 操作并在 Postman 或您喜欢的任何 REST 客户端中测试它们。
- en: 'We have explored two types of relationships: one-to-many and one-to-one. Now,
    let us delve into another type of relationship: many-to-many.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了两种关系类型：一对多和一对一。现在，让我们深入了解另一种关系类型：多对多。
- en: Understanding many-to-many relationships
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多对多关系
- en: A many-to-many relationship is when an entity can be associated with multiple
    entities and vice versa. For example, a movie can have many actors, and an actor
    can act in many movies; a post can have many tags, and a tag can have many posts;
    a student can enroll in many courses, and a course can have many students, and
    so on. In this section, we will introduce how to configure a many-to-many relationship
    in EF Core.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系是指一个实体可以与多个实体相关联，反之亦然。例如，一部电影可以有多个演员，一个演员可以出演多部电影；一篇文章可以有多个标签，一个标签可以有多个文章；一个学生可以报名多门课程，一门课程可以有多个学生，等等。在本节中，我们将介绍如何在
    EF Core 中配置多对多关系。
- en: Many-to-many configuration
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多配置
- en: 'In a many-to-many relationship, we need to define a collection navigation property
    on both sides. Here is an example of a many-to-many relationship between a `Movie`
    entity and an `Actor` entity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在多对多关系中，我们需要在两边定义一个集合导航属性。以下是一个 `Movie` 实体和 `Actor` 实体之间多对多关系的示例：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'EF Core can detect the many-to-many relationship automatically following the
    convention. If you run the `dotnet ef migrations add AddMovieAndActor` command
    to add a migration, you will see the following code in the migration file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 可以根据约定自动检测多对多关系。如果你运行 `dotnet ef migrations add AddMovieAndActor` 命令来添加迁移，你将在迁移文件中看到以下代码：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Besides the code that creates `Movies` and `Actors` tables, the migration file
    also creates a join table named `ActorMovie` to store the foreign keys for both
    sides. The `ActorMovie` table has two foreign key properties, `ActorsId` and `MoviesId`,
    to associate the `Actor` entity and the `Movie` entity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建 `Movies` 和 `Actors` 表的代码外，迁移文件还创建了一个名为 `ActorMovie` 的连接表来存储两边的外键。`ActorMovie`
    表有两个外键属性，`ActorsId` 和 `MoviesId`，用于关联 `Actor` 实体和 `Movie` 实体。
- en: However, sometimes the automatic detection of the many-to-many relationship
    may not meet our requirements. For example, we may want to call the table `MovieActor`
    instead of `ActorMovie`, we may want to specify the foreign key properties as
    `ActorId` and `MovieId` instead of `ActorsId` and `MoviesId`, or we may even want
    to add some additional properties to the join table. In these cases, we can explicitly
    configure the many-to-many relationship.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时自动检测的多对多关系可能不符合我们的要求。例如，我们可能希望将表名称为 `MovieActor` 而不是 `ActorMovie`，我们可能希望指定外键属性为
    `ActorId` 和 `MovieId` 而不是 `ActorsId` 和 `MoviesId`，或者我们甚至可能希望向连接表添加一些额外的属性。在这些情况下，我们可以显式配置多对多关系。
- en: 'First, we need to define a join entity to store the foreign keys for both sides.
    Here is an example of a join entity named `MovieActor`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个连接实体来存储两边的键。以下是一个名为 `MovieActor` 的连接实体的示例：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, we need to add a collection navigation property to the `Movie` and `Actor`
    entities:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要向 `Movie` 和 `Actor` 实体添加一个集合导航属性：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we configure the many-to-many relationship in the `Movie` configuration
    using the `HasMany()/WithMany()` methods, as shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `HasMany()/WithMany()` 方法在 `Movie` 配置中配置多对多关系，如下所示：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similarly, the configuration can be added to the `Actor` configuration as well.
    After adding the configuration, run the `dotnet ef migrations add AddMovieAndActor`
    command to add a migration; you will see the following code in the migration file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，配置也可以添加到 `Actor` 配置中。添加配置后，运行 `dotnet ef migrations add AddMovieAndActor`
    命令来添加迁移；你将在迁移文件中看到以下代码：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see that the join table is renamed `MovieActor`, and the foreign key
    properties are renamed `MovieId` and `ActorId`. Also, the `UpdateTime` property
    is added to the join table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到连接表已被重命名为 `MovieActor`，外键属性也被重命名为 `MovieId` 和 `ActorId`。此外，连接表中还添加了 `UpdateTime`
    属性。
- en: 'After the migration is applied, you can see the join table in the database:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移应用后，你可以在数据库中看到连接表：
- en: '![Figure 6.5 – The join table in the database](img/B18971_06_5.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 数据库中的连接表](img/B18971_06_5.jpg)'
- en: Figure 6.5 – The join table in the database
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 数据库中的连接表
- en: 'Another way (before EF Core 5.0) to configure a many-to-many relationship is
    to use the join entity to represent two separate one-to-many relationships. Here
    is an example of configuring a many-to-many relationship for the `Movie` and `Actor`
    entities:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EF Core 5.0 之前，配置多对多关系的另一种方式是使用连接实体来表示两个单独的一对多关系。以下是一个为 `Movie` 和 `Actor`
    实体配置多对多关系的示例：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we configured two one-to-many relationships for the `Movie`
    and `Actor` entities on the `MovieActor` join entity. Each one-to-many relationship
    uses the `HasMany(), WithMany()`, and `HasForeignKey()` methods to configure the
    relationship. This combination of one-to-one relationships creates a many-to-many
    relationship.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`MovieActor`连接实体上为`电影`和`演员`实体配置了两个一对一关系。每个一对一关系都使用`HasMany()`、`WithMany()`和`ForeignKey()`方法来配置关系。这种一对一关系的组合创建了一个多对多关系。
- en: You can use either way to configure a many-to-many relationship. The `HasMany()/WithMany()`
    methods is more convenient and easier to use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何一种方式来配置多对多关系。`HasMany()/WithMany()`方法更方便且易于使用。
- en: Many-to-many CRUD operations
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多CRUD操作
- en: 'In a many-to-many relationship, such as `Movie` and `Actor`, we may need to
    get the actors of a movie or get the movies of an actor. So, we need to expose
    both entities through the REST API. You can create two controllers using the following
    commands:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在多对多关系中，例如`电影`和`演员`，我们可能需要获取电影的演员或获取演员的电影。因此，我们需要通过REST API公开这两个实体。你可以使用以下命令创建两个控制器：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the application and create some movies and actors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并创建一些电影和演员。
- en: 'We can include the actors of a movie when creating a movie. For example, we
    can create a movie with a couple of actors using the following JSON payload format:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建电影时，我们可以包括电影的演员。例如，我们可以使用以下JSON有效载荷格式创建一个包含几个演员的电影：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will see the following result in the database:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在数据库中看到以下结果：
- en: '![Figure 6.6 – The join table has been populated](img/B18971_06_6.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 连接表已填充](img/B18971_06_6.jpg)'
- en: Figure 6.6 – The join table has been populated
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 连接表已填充
- en: 'Similarly, you can also include the movies of an actor when creating an actor.
    However, if we include related entities arbitrarily, we may end up with duplicate
    entities. For example, we create an actor with a couple of movies using the following
    JSON payload format:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你还可以在创建演员时包括演员的电影。然而，如果我们任意包含相关实体，我们可能会得到重复实体。例如，我们使用以下JSON有效载荷格式创建一个包含几个电影的演员：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As a result, you will have two movies with the same title in the database.
    To avoid this, there are some options:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据库中可能会有两个同名电影。为了避免这种情况，有一些选项：
- en: Add a unique index to the `Title` property of the `Movie` entity to ensure that
    the title is unique. This is the simplest solution and can prevent duplicate entities
    from being added to the database.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`电影`实体的`标题`属性添加唯一索引以确保标题唯一。这是最简单的解决方案，可以防止重复实体被添加到数据库中。
- en: Check if the entity already exists in the database before adding it.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加之前检查实体是否已存在于数据库中。
- en: Add movies and actors separately, and then update either the movie or the actor
    to include the other entity using the IDs of the other entity, instead of the
    whole entity.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别添加电影和演员，然后使用其他实体的ID更新电影或演员以包括其他实体，而不是整个实体。
- en: 'You can use a combination of the preceding options to improve the implementation.
    To add a unique index to the `Title` property of the `Movie` entity, you can update
    the following code of the `MovieConfiguration` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用前面选项的组合来改进实现。要向`电影`实体的`标题`属性添加唯一索引，你可以更新`MovieConfiguration`类的以下代码：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can make the same change to the `Name` property of the `Actor` entity. After
    the change, you need to create a new migration and apply it to the database. This
    helps to prevent duplicate entities on the database level. If a request contains
    duplicate entities, the database will throw an exception.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对`演员`实体的`名称`属性进行相同的更改。更改后，你需要创建一个新的迁移并将其应用到数据库中。这有助于在数据库级别防止重复实体。如果请求包含重复实体，数据库将抛出异常。
- en: It is possible to add or update related entities in the same request as the
    main entity. But sometimes, it might not be necessary. For example, an actor just
    acts in a new movie, and you want to create a new movie and add the actor to the
    movie. You can update the actor to include the new movie, but you have to send
    the whole actor entity in the request, including existing movies. It causes unnecessary
    data transfer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能在同一个请求中添加或更新与主实体相关的实体。但有时，这可能不是必要的。例如，一个演员只参与了一部新电影，你想要创建一个新电影并将演员添加到电影中。你可以更新演员以包括新电影，但必须发送整个演员实体到请求中，包括现有的电影。这会导致不必要的数据传输。
- en: 'To make the API easy to use, it is pragmatic to expose an additional API endpoint
    to update a collection of related entities only, rather than updating the whole
    entity. For example, we can create an `/api/actors/{id}/movies` endpoint to update
    the movies of an actor. It is a good practice to avoid updating a collection of
    related entities in the same request. We can just send the IDs of the related
    entities to the API endpoint. From the perspective of the API, the relationship
    is treated as a resource. In the `ActorsController.cs` file, you will find the
    following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 API 更易于使用，仅暴露一个额外的 API 端点来更新相关实体的集合，而不是更新整个实体，这是一种实用主义的方法。例如，我们可以创建一个 `/api/actors/{id}/movies`
    端点来更新演员的电影。避免在同一个请求中更新相关实体的集合是一种良好的做法。我们只需向 API 端点发送相关实体的 ID 即可。从 API 的角度来看，这种关系被视为一个资源。在
    `ActorsController.cs` 文件中，您将找到以下代码：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code exposes a few endpoints to add, get, and delete the movies
    of an actor. You can test the endpoints using the JSON payload format, as shown
    in the preceding code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码暴露了一些端点，用于添加、获取和删除演员的电影。您可以使用前面代码片段中显示的 JSON 负载格式测试这些端点：
- en: To add a movie to an actor, send a `POST` request to the `/api/actors/{id}/movies/{movieId}`
    endpoint. The `AddMovie` action will check if the movie already exists in the
    database. If it does, it will then check if the movie already exists in the movies
    of the actor. If not, it adds the movie to the collection and then saves the changes
    to the database.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向演员添加电影，向 `/api/actors/{id}/movies/{movieId}` 端点发送一个 `POST` 请求。`AddMovie` 动作将检查电影是否已经在数据库中存在。如果存在，它将检查电影是否已经在演员的电影中存在。如果没有，它将电影添加到集合中，并将更改保存到数据库中。
- en: To get the movies of an actor, send a `GET` request to the `/api/actors/{id}/movies`
    endpoint. The `GetMovies` action will return the movies of the actor. This endpoint
    can be updated to support pagination, sorting, and filtering.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取一个演员的电影，向 `/api/actors/{id}/movies` 端点发送一个 `GET` 请求。`GetMovies` 动作将返回该演员的电影。此端点可以更新以支持分页、排序和过滤。
- en: To delete a movie from an actor, send a `DELETE` request to the `/api/actors/{id}/movies/{movieId}`
    endpoint. The `DeleteMovie` action will remove the movie from the collection and
    then save the changes to the database. Note that it does not delete the movie
    from the database; it just deletes the relationship between the movie and the
    actor.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从演员中删除电影，向 `/api/actors/{id}/movies/{movieId}` 端点发送一个 `DELETE` 请求。`DeleteMovie`
    动作将从集合中删除电影，并将更改保存到数据库中。请注意，它不会从数据库中删除电影；它只是删除了电影和演员之间的关系。
- en: It is also possible to add a similar endpoint to the `MoviesController.cs` file
    to update the actors of a movie. You can use the same approach to implement endpoints.
    Try it yourself!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将类似的端点添加到 `MoviesController.cs` 文件中，以更新电影中的演员。您可以使用相同的方法实现端点。试试看吧！
- en: Important note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When you call the `/api/actors` endpoint, you may find that the response contains
    `MovieActors` as well. This is not useful for the client. You can use the `JsonIgnore`
    attribute to ignore the property when serializing the response.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用 `/api/actors` 端点时，您可能会发现响应中包含 `MovieActors`。这对于客户端来说并不有用。您可以使用 `JsonIgnore`
    属性在序列化响应时忽略该属性。
- en: 'We have now discussed three common types of relationships: one-to-many, one-to-one,
    and many-to-many. You should now have a good understanding of how to configure
    relationships and implement CRUD operations for entities with relationships. Let''s
    move on to our next topic: owned entity types.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论了三种常见的关系类型：一对一、一对多和多对多。您现在应该很好地理解了如何配置关系以及为具有关系的实体实现 CRUD 操作。让我们继续讨论下一个主题：拥有的实体类型。
- en: Understanding owned entities
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解拥有的实体
- en: In the previous sections, we have learned some relationships are optional, but
    some are required. For example, a post can exist without a category, but a student
    ID card cannot exist without a student. For the latter, we can say a student owns
    an ID card. Similarly, a contact owns an address. We can also find some examples
    of one-to-many relationships. For example, an invoice owns many invoice items
    because an invoice item cannot exist without an invoice. In this section, we will
    introduce the concept of owned entities.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了一些关系是可选的，但有些是必需的。例如，一篇文章可以没有分类存在，但学生身份证不能没有学生存在。对于后者，我们可以说学生拥有身份证。同样，联系人拥有地址。我们还可以找到一些一对多关系的例子。例如，发票拥有多个发票项，因为发票项不能没有发票存在。在本节中，我们将介绍拥有的实体的概念。
- en: 'Owned entity types are entity types that are part of the owner and cannot exist
    without the owner. You can use common one-to-one or one-to-many relationships
    to model the owned entities, but EF Core provides a more convenient way called
    owned entity types. You can use the `OwnsOne()` or `OwnsMany()` method to define
    owned entity types, instead of using the `HasOne()` or `HasMany()` method. For
    example, to configure the `InvoiceItem` entity as an owned entity type of the
    `Invoice` entity, you can use the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所属实体类型是所有者的一部分，没有所有者就无法存在。你可以使用常见的单一到单一或单一到多对关系来建模所属实体，但EF Core提供了一个更方便的方法，称为所属实体类型。你可以使用`OwnsOne()`或`OwnsMany()`方法来定义所属实体类型，而不是使用`HasOne()`或`HasMany()`方法。例如，要将`InvoiceItem`实体配置为`Invoice`实体的所属实体类型，你可以使用以下代码：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As shown in the preceding code, you can use the `OwnsMany()/WithOwner()` methods
    to configure the owned entity type. The `OwnsMany()/WithOwner()` method specifies
    the owner of the owned entity type. The `HasForeignKey()` method specifies the
    foreign key property of the owned entity type. The configuration of the `InvoiceItem`
    entity is stored in the `InvoiceConfiguration` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，你可以使用`OwnsMany()/WithOwner()`方法来配置所属实体类型。`OwnsMany()/WithOwner()`方法指定所属实体类型的所有者。`HasForeignKey()`方法指定所属实体类型的外键属性。`InvoiceItem`实体的配置存储在`InvoiceConfiguration`类中。
- en: 'Similarly, the configuration of the `Address` entity could be stored in the
    `ContactConfiguration` class like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Address`实体的配置可以像这样存储在`ContactConfiguration`类中：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When you use the `OwnsOne()/WithOwner()` methods, you do not need to specify
    the foreign key property because the owned entity type will be stored in the same
    table as the owner by default. You can use the `ToTable` method to specify the
    table name of the owned entity type.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`OwnsOne()/WithOwner()`方法时，你不需要指定外键属性，因为所属实体类型默认将存储在与所有者相同的表中。你可以使用`ToTable`方法来指定所属实体类型的表名。
- en: 'So, what is the difference between normal one-to-one or one-to-many and owned
    entity types? There are some differences:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，正常的一对一或多对一与所属实体类型之间有什么区别？有一些区别：
- en: You cannot create a `DbSet<T>` property for an owned entity type. You can only
    use the `DbSet<T>` property for the owner. That means you do not have any way
    to access the owned entity type directly. You must access the owned entity type
    through the owner.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能为所属实体类型创建`DbSet<T>`属性。你只能使用所有者的`DbSet<T>`属性。这意味着你没有直接访问所属实体类型的方法。你必须通过所有者来访问所属实体类型。
- en: When you query the owner, the owned entity type will be included automatically.
    You do not need to use the `Include()` method to include the owned entity type
    explicitly. So, please be careful if the owner has many owned entities. It may
    cause performance issues.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你查询所有者时，所属实体类型将自动包含。你不需要使用`Include()`方法显式包含所属实体类型。所以，如果所有者有多个所属实体，请务必小心，这可能会引起性能问题。
- en: If your entities have a simple one-to-one or one-to-many relationship and the
    data is not large, you can use owned entity types to simplify the configuration.
    However, if the relationship is complex and the data size is large, you would
    be better off using normal one-to-one or one-to-many relationships because you
    can decide which related entities to include explicitly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的实体具有简单的单一到单一或单一到多对关系，并且数据量不大，你可以使用所属实体类型来简化配置。然而，如果关系复杂且数据量较大，使用正常的单一到单一或单一到多对关系会更好，因为你可以显式决定包含哪些相关实体。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this comprehensive chapter, we delved into modeling relationships between
    entities in EF Core. We explored various common relationship types, including
    one-to-one, one-to-many, and many-to-many relationships. We learned how to configure
    these relationships using essential methods such as `HasOne()/WithMany()`, `HasMany()/WithOne()`,
    and `HasMany()/WithMany()`. To broaden our understanding, we also explored configuring
    owned entity types using the `OwnsOne()/WithOwner()` and `OwnsMany/WithOwner()`
    methods.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了EF Core中实体之间关系的建模。我们探讨了各种常见的关系类型，包括一对一、一对多和多对多关系。我们学习了如何使用`HasOne()/WithMany()`、`HasMany()/WithOne()`和`HasMany()/WithMany()`等基本方法来配置这些关系。为了拓宽我们的理解，我们还探讨了使用`OwnsOne()/WithOwner()`和`OwnsMany/WithOwner()`方法配置所属实体类型。
- en: To effectively operate on entities with relationships, we explained how to implement
    CRUD operations for each type of relationship. Particularly, we explained cascading
    delete operations, ensuring data integrity and efficient management of related
    entities.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地操作具有关系的实体，我们解释了如何为每种关系类型实现 CRUD 操作。特别是，我们解释了级联删除操作，确保数据完整性和相关实体的有效管理。
- en: The concepts learned in this chapter will help you model relationships between
    entities in your ASP.NET Core applications. In the next chapter, we will learn
    about some advanced topics of EF Core, such as concurrency control, performance
    tuning, and more.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本章学到的概念将帮助您在 ASP.NET Core 应用程序中建模实体之间的关系。在下一章中，我们将学习 EF Core 的一些高级主题，例如并发控制、性能调整等。
