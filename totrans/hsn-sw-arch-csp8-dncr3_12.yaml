- en: Design Patterns and .NET Core Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns can be defined as ready to use architectural solutions for common
    problems you encounter during software development. They are essential for understanding
    the .NET Core architecture and useful for solving ordinary problems that we face
    when designing any piece of software. In this chapter, we will look at the implementation
    of some design patterns. It is worth mentioning that this book doesn't explain
    all the known patterns we can use. The focus here is to explain the importance
    of studying and applying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns and their purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the available design patterns in .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about some of the use cases
    from WWTravelClub that you can implement with design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will require the following to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 or 2019 free Community Edition or better with all the database
    tools installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* subsection of [Chapter
    1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the Importance
    of Software Architecture*, explains how to create one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns and their purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to decide on the design of a system is challenging, and the responsibility
    associated with this task is enormous. As a software architect, we must always
    keep in mind that features such as great reusability, good performance, and good
    maintainability are key. This is where design patterns help and accelerate the
    design process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, design patterns are solutions that have already
    been discussed and defined so that they can solve common software architectural
    problems. This approach grew in popularity after the release of the book *Design
    Patterns – Elements of Reusable Object-Oriented Software*, where the **Gang of
    Four** (**GoF**) divided these patterns into three types:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A little bit later, Uncle Bob introduced the SOLID principles to the developers
    community, giving us the opportunity to efficaciously organize functions and data
    structures of each system into classes. SOLID principles indicate how these classes
    should be connected. It is worth mentioning that, compared to the design patterns
    presented by GoF, SOLID principles don't deliver code recipes. Instead, they give
    you the basic principles to follow when you design your solutions.
  prefs: []
  type: TYPE_NORMAL
- en: As technologies and software problems change, more patterns are conceived. The
    advance of cloud computing has brought a bunch of them, all of which can be found
    at [https://docs.microsoft.com/azure/architecture/patterns/](https://docs.microsoft.com/azure/architecture/patterns/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why you should always consider them is quite simple – as a software
    architect, you cannot spend time reinventing the wheel. However, there is another
    great reason for using them: you will find many patterns implemented in .NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next few subsections, we will cover some of the most well-known patterns.
    However, the idea of this chapter is to let you know that they exist and need
    to be studied so that you can accelerate and simplify your project. Moreover,
    each pattern with be presented with a C# code snippet so that you can easily implement
    them in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where you will have a complex object with different behaviors
    due to its configuration. Instead of setting this object up while using it, you
    may want to decouple its configuration from its usage, using a customized configuration
    already built. This way, you have different representations of the instances you
    are building. This is where you should use the Builder pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram shows the pattern that has been implemented for
    a scenario from this book''s use case. The idea behind this design choice is to
    simplify the way rooms from WWTravelClub are described:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7b5096e-d9e3-49f8-a384-606831fec9be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following code, the code for this is implemented in a way where
    the configurations of the instances aren''t set in the main program. Instead,
    you just build the objects using the `Construct()` method. This example is simulating
    the creation of different room styles (a single room and a family room) in the
    WWTravelClub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this implementation is quite simple but clarifies the reason
    why you need to implement a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a770151-f3f3-4c83-b37e-a4effe5208ea.png)'
  prefs: []
  type: TYPE_IMG
- en: As soon as you have the implementation, evolving this code becomes simpler and
    easier. For example, if you need to build a different style of room, you just
    have to create the concrete builder for that and you will be able to use it. Fortunately,
    if you need to increase the configuration settings for the product, all the concrete
    classes you used previously will be defined in the Builder interface and stored
    there so that you can update them with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory pattern is really useful in situations where you have multiple objects
    from the same abstraction and you don't know which need to be created by the time
    you start coding. This means you will have to create the instance according to
    a certain configuration or according to where the software is living at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s check out the WWTravelClub sample. Here, there''s a User
    Story that describes that this application will have customers from all over the
    world paying for their trips. However, in the real world, there are different
    payment services available for each country. The process of paying is similar
    for each country, but this system will have more than one payment service available.
    A good way to simplify this payment implementation is by using the Factory pattern.
    The following diagram shows the basic idea of its architectural implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94214e08-4bd1-45fc-9b37-fa26ce54fa97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that, since you have an interface that describes what the Payment Service
    for the application is, you can use the factory to change the concrete class according
    to the services that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the service's usage has been simplified due to the implemented pattern.
    If you were to use this code in a real-world application, you would change the
    instance's behavior by defining the service you need in the Factory.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you implement a Singleton in your application, you will have a single instance
    of the object implemented in the entire solution. This can be considered as one
    of the most used patterns in every application. The reason is simple – there are
    many use cases where you need some classes to have just one instance. Singletons
    solve this by providing a better solution than a global variable does.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Singleton pattern, the class is responsible for creating and delivering
    a single object that will be used by the application. In other words, the Singleton
    class creates a single instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73659067-540d-4379-a698-9df3fe07fafa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To do so, the object that''s created is `static` and is delivered in a static
    property or method. The following code implements the Singleton pattern, which
    has a `Message` property and a `Print()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Its usage is really simple – you just need to call the static property every
    time you need to use the Singleton object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the places where you may use this pattern is when you need to deliver
    the app configuration in a way that can be easily accessed from anywhere in the
    solution. For instance, let''s say you have some configuration parameters that
    are stored in a table that your app needs to query at several decision points.
    Instead of querying the configuration table directly, you can create a Singleton
    class to help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93719043-7e2b-43f3-9d1c-182662e4de97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, you will need to implement a cache in this Singleton, thus improving
    the performance of the system, since you will be able to decide whether the system
    will check each configuration in the database every time it needs it or if the
    cache will be used. The following screenshot shows the implementation of the cache
    where the configuration is loaded every 5 seconds. The parameter that is being
    read in this case is just a random number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2dfb9f8-0240-451d-826b-9ae519f91d8b.png)'
  prefs: []
  type: TYPE_IMG
- en: This is great for the application's performance. Besides, using parameters in
    several places in your code is simpler, since you don't have to create configuration
    instances everywhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Proxy pattern is used when you need to provide an object that controls access
    to another object. One of the biggest reasons why you should do this is related
    to the cost of creating the object that is being controlled. For instance, if
    the controlled object takes too long to be created or consumes too much memory,
    a proxy can be used to guarantee that the huge part of the object will only be
    created when it's required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram shows the class diagram of a Proxy pattern''s implementation
    for loading pictures from the Room, but only when requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17bd01c8-99ca-44a8-8311-d618f50ae1d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The client of this proxy will request its creation. Here, the proxy will only
    gather basic information (`Id`, `FileName`, and `Tags`) from the real object and
    won''t query `PictureData`. When `PictureData` is requested, the proxy will load
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If `PictureData` is requested again, since image data is already in place,
    the proxy will guarantee that image reloading will not be repeated. The following
    screenshot shows the result of running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54cf03cd-511a-4ad9-9fa6-98d6444855e9.png)'
  prefs: []
  type: TYPE_IMG
- en: This technique can be referred to as another well-known pattern: **lazy loading**.
    In fact, the Proxy pattern is a way of implementing lazy loading. For instance,
    in Entity Framework Core 2.1, as discussed in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*, you can turn on lazy loading
    using proxies. You can find out more about this at [https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading).
  prefs: []
  type: TYPE_NORMAL
- en: Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many cases where you need to execute a *command* that will affect
    the behavior of an object. The Command pattern can help you with this by encapsulating
    this kind of request in an object. The pattern also describes how to handle undo/redo
    support for the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s imagine that, on the WWTravelClub website, the users have
    the ability to evaluate the packages by specifying whether they like, dislike,
    or even love them. The following class diagram is an example of what can be implemented
    to create this rating system with the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69730dee-9393-4ae2-b992-7ba7e8fcbcc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the way this pattern works – if you need a different command, such as Hate,
    you don't need to change the code and classes that use the command. The Undo method
    can be added in a similar way to the Redo method. The full code sample for this
    is available in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Publisher/Subscriber pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing information from an object to a group of other objects is common in
    all applications. The Publisher/Subscriber pattern is almost mandatory when there's
    a large volume of components (subscribers) that will receive a message containing
    the information that was sent by the object (publisher).
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept here is quite simple to understand and is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52ef2ea5-0ab4-4c21-8abe-e8ba22065fa3.png)'
  prefs: []
  type: TYPE_IMG
- en: When you have an indefinite number of different possible subscribers, it is
    essential to decouple the component that broadcasts information from the components
    that consume it. The Publisher/Subscriber pattern does this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this pattern is complex, since distributing environments isn't
    a trivial task. Therefore, it is recommended that you consider already existing
    technologies for implementing the Message Broker that connects the Input Channel
    to the Output Channels, instead of building it from scratch. Azure Service Bus
    is a reliable implementation of this pattern, so all you need to do is connect
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ, which we mentioned in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*, is another
    service that can be used to implement a Message Broker, but it is a lower-level
    implementation of the pattern and requires several related tasks, such as retries,
    in case errors have to be coded manually.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Dependency Injection pattern is considered a good way to implement the
    Dependency Inversion principle. Besides, it forces all the other SOLID principles
    to be followed by the implementation. As we discussed at the beginning of this
    chapter, a way to keep the software''s structure strong and reliable is by following
    the SOLID design principles presented by Uncle Bob. These can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility**: A module or function should be responsible for a
    single purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-Closed**: A software artifact should be open for extension but closed
    for modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution**: The behavior of a program needs to remain unchanged
    when you substitute one of its components for another component that''s been defined
    by a supertype of the primer object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I****nterface Segregation**: Creating huge interfaces will cause dependencies
    to occur while you''re building concrete objects, but these are harmful to the
    system architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion**: The most flexible systems are the ones where object
    dependencies only refer to abstractions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concept is quite simple. Instead of creating instances of the objects that
    the component depends on, you just need to define their dependencies, declare
    their interfaces, and enable the reception of the objects by *injection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to perform dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the constructor of the class to receive the objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag some class properties to receive the objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define an interface with a method to inject all the necessary components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the implementation of the Dependency Injection
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2489a07f-eb5f-42fd-9aaf-320472e5bc56.png)'
  prefs: []
  type: TYPE_IMG
- en: Apart from this, dependency injection can be used with an **Inversion of Control**
    (**IoC**) container. This container enables the automatic injection of dependencies
    whenever they are asked for. There are several IoC container frameworks available
    on the market, but with .NET Core, there is no need to use third-party software
    since it contains a set of libraries to solve this in the `Microsoft.Extensions.DependencyInjection` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'This IoC container is responsible for creating and disposing of the objects
    that are requested. The implementation of dependency injection is based on Constructor
    types. There are three options for the injected component''s lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient**: The objects are created each time they are requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: The objects are created for each scope defined in the application. In
    a Web App, a *scope* is identified with a web request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: Each object has the same application lifetime, so a single object
    is reused to serve all the requests for a given type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way you are going to use these options depends on the business rules of
    the project you are developing. You need to be careful in deciding the correct
    one, since the behavior of the application will change according to the type of
    object you are injecting.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the available design patterns in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discovered in the previous sections, C# allows us to implement any of
    the aforementioned patterns. .NET Core provides many implementations in its SDK
    that follow all the patterns we've discussed, such as Entity Framework Core Proxy
    Lazy Loading. Another good example that's been available since .NET Core 2.1 is
    .NET Generic Host.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml), *Presenting ASP.NET
    Core MVC*, we will detail the hosting that's available for Web Apps in .NET Core.
    This web host helps us since the app's startup and lifetime management is set
    up alongside it. The idea of .NET Generic Host is to enable this pattern for applications
    that don't need HTTP implementation. With this Generic Host, any .NET Core program
    can have a Startup class where we can configure the Dependency Injection Engine.
    This can be really useful for creating multi-service apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more at .NET Generic Host at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host),
    which contains some sample code. The code provided in this book''s GitHub repository
    is simpler, but it focuses on the creation of a console app that can run a service
    for monitoring. The great thing about this is the way the console app is set up
    to run, where the builder configures the services that will be provided by the
    application, and the way logging will be managed. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code gives us an idea of how .NET Core uses design patterns. Using
    the Builder pattern, .NET Generic Host allows you to set the classes that will
    be injected as services. Apart from this, the Builder pattern helps you configure
    some other features, such as the way logs will be shown/stored. This configuration
    allows the services to inject `ILogger<out TCategoryName>` objects into any instance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood why design patterns help with the maintainability
    and reusability of the parts of the system you are building. We also looked at
    some typical use cases and code snippets that you can use in your projects. Finally,
    we presented .NET Generic Host, which is a good example of how .NET uses design
    patterns to enable code reusability and enforce best practices. All this content
    will help you while architecting a new software or even maintaining an existing
    one, since design patterns are solutions already known for some real life problems
    in software development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the domain-driven design approach. We will
    also learn how to use SOLID design principles so that we can map different domains
    to our software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are design patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between design patterns and design principles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Builder pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Factory pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Singleton pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Proxy pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Command pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Publisher/Subscriber pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it a good idea to implement the Dependency Injection pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some books and websites where you can find out more regarding
    what was covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*, Martin,
    Robert C. Pearson Education, 2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, Erica Gamma
    et al. Addison-Wesley, 1994.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns*, Robert C. Martin, 2000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to get more info about design patterns and architectural principles,
    please check these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to understand better the idea of generic hosts, follow this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a very good explanation about service bus messaging in this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about dependency injection checking these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
