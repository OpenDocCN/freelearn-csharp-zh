<html><head></head><body>
<div><h1 class="chapterNumber">9</h1>
<h1 class="chapterTitle" id="_idParaDest-179">Testing Your Enterprise Application</h1>
<p class="normal">When developing software, it is essential to ensure that an application is as bug-free as possible and that it satisfies all requirements. This can be done by testing all the modules while they are being developed or when the overall application has been either completely or partially implemented. This need has become more and more compelling in today’s agile and DevOps-driven software development landscape, where integrating testing at every stage of the development process is essential for the continuous delivery of reliable software. </p>
<p class="normal">While most of the key concepts covered by this chapter apply to a wide range of applications and environments, this chapter focuses on essential testing strategies for enterprise-level applications in C# and .NET environments.</p>
<p class="normal">Performing all the tests manually is not a feasible option since most of the tests must be executed each time the application is modified, and, as explained throughout this book, modern software is continuously being modified to adapt applications to the needs of a fast-changing market. Therefore, automated tests are indispensable in today’s fast-paced environment of continuous development. </p>
<p class="normal">This chapter discusses the most common types of tests needed to deliver reliable software and how to organize and automate them. More specifically, this chapter covers the following topics:</p>
<ul>
<li class="bulletList">Understanding unit and integration tests and their usage, which are the main tools to ensure software reliability and stability</li>
<li class="bulletList">Understanding the basics of <strong class="keyWord">test-driven development</strong> (<strong class="keyWord">TDD</strong>) and how and why it can dramatically reduce the probability of undiscovered bugs</li>
<li class="bulletList">Functional tests, which are the main tool for enforcing software specifications</li>
<li class="bulletList">Defining C# test-specific projects in Visual Studio to take full advantage of the testing tools available in the .NET ecosystem</li>
<li class="bulletList">Automating functional tests in C#</li>
</ul>
<p class="normal">This chapter will not only teach you the different types of tests and how to implement them but also how to effectively apply these techniques in your role as a .NET software architect to build robust, scalable enterprise applications.</p>
<h1 class="heading-1" id="_idParaDest-180">Technical requirements</h1>
<p class="normal">This chapter requires the Visual Studio 2022 free Community Edition or better, with all database tools installed. The code for this chapter is available at <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>.</p>
<h1 class="heading-1" id="_idParaDest-181">Understanding unit and integration tests</h1>
<p class="normal">Testing is an essential part of software development since it verifies both that the software is bug-free and that it conforms to the agreed specification. Delaying application testing until immediately<a id="_idIndexMarker603"/> after most of the application’s functionalities have been implemented in their <a id="_idIndexMarker604"/>entirety must be avoided for the following reasons:</p>
<ul>
<li class="bulletList">If a class or module has been incorrectly designed or implemented, it might have already influenced the way other modules were implemented. Therefore, at this point, fixing the problem might have a very high cost.</li>
<li class="bulletList">The possible combination of input that is needed to test all possible paths that execution can take grows exponentially with the number of modules or classes that are tested together. Thus, for instance, if the execution of a class method <code class="inlineCode">A</code> can take three different paths, while the execution of another method <code class="inlineCode">B</code> can take four paths, then testing <code class="inlineCode">A</code> and <code class="inlineCode">B</code> together would require 3 x 4 different inputs. In general, if we test several modules together, the total number of paths to test is the product of the number of paths to test in each module. If modules are tested separately, instead, the number of inputs required is just the sum of the paths needed to test each module. That’s why so-called unit tests verify each class method separately in an exhaustive way as soon as each class is designed. After that, the overall behavior correctness can be verified with an acceptably small number of so-called <em class="italic">integration tests</em>,<em class="italic"> because integration tests</em> just need to verify the various<a id="_idIndexMarker605"/> classes’ interaction patterns without analyzing all methods’ execution paths.</li>
<li class="bulletList">If a test of an aggregate made of <em class="italic">N</em> modules fails, then locating the origin of the bug among the <em class="italic">N</em> modules is usually a very time-consuming activity.</li>
<li class="bulletList">When <em class="italic">N</em> modules are tested together, we have to redefine all tests involving the <em class="italic">N</em> modules, even if just one of the <em class="italic">N</em> modules changes during the application’s life cycle.</li>
</ul>
<p class="normal">These considerations show that we need both to test each class method separately as soon as possible and to test for correct module integration.</p>
<p class="normal">That is why tests are organized into three stages, as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Unit tests</strong>: These verify that all<a id="_idIndexMarker606"/> or almost all execution paths of each method behave properly. They should be free from external dependencies, such as storage and databases, and should be quite complete; that is, they should cover most of the possible paths. This is usually feasible at an acceptable time cost because there are not too many possible execution paths for each method as compared to the possible execution paths of the whole application.</li>
<li class="bulletList"><strong class="keyWord">Integration tests</strong>: These are executed once the software passes all its unit tests. Integration tests verify that all modules interact properly to get the expected results. Integration tests do not need to be complete since unit tests will have already <a id="_idIndexMarker607"/>verified that all the execution paths of each module work properly. They need to verify as many patterns of interaction as possible, that is, as many ways in which the various modules may cooperate.</li>
<li class="bulletList"><strong class="keyWord">Acceptance tests</strong>: These are executed at the end of each sprint and/or before releasing the application. They <a id="_idIndexMarker608"/>verify that the output of a sprint or the final application satisfies both functional and non-functional requirements. Tests that verify functional requirements are called <strong class="keyWord">functional tests</strong>, while<a id="_idIndexMarker609"/> tests that verify performance<a id="_idIndexMarker610"/> requirements are called <strong class="keyWord">performance tests</strong>.</li>
</ul>
<p class="normal">Usually, each interaction pattern has more than one test associated with it: a typical activation of a pattern and some extreme cases of activation. For instance, if a whole pattern of interaction receives an array as input, we will write a test for the typical size of the array, a test with a <code class="inlineCode">null</code> array, a test with an empty array, and a test with a very big array. This way, we verify that the way the single module was designed is compatible with the needs of the whole interaction pattern. It is worth pointing out that, in our array example, <code class="inlineCode">null</code>, <code class="inlineCode">0</code>, <code class="inlineCode">1</code>, and <em class="italic">many</em> are equivalence classes that represent the whole universe of array values in an efficacious way.</p>
<p class="normal">With the preceding strategy in place, if we modify a single module without changing its public interface, we need to change the unit tests for that module.</p>
<p class="normal">If, instead, the change involves the way some modules interact, then we also have to add new integration tests or modify existing ones. However, usually, this is not a big problem since most of the tests are unit tests, so rewriting a large percentage of all integration tests does not require too much effort. Moreover, if the application was designed according to the <strong class="keyWord">Single Responsibility</strong>, <strong class="keyWord">Open/Closed</strong>, <strong class="keyWord">Liskov Substitution</strong>, <strong class="keyWord">Interface Segregation</strong>, or <strong class="keyWord">Dependency Inversion</strong> (<strong class="keyWord">SOLID</strong>) principles, the number of integration tests that must be<a id="_idIndexMarker611"/> changed after a single code modification should be small since the modification should affect just a few classes that interact directly with the modified method or class.</p>
<h2 class="heading-2" id="_idParaDest-182">Automating unit and integration tests</h2>
<p class="normal">At this point, it should be clear that <a id="_idIndexMarker612"/>both unit tests and integration tests will be reused <a id="_idIndexMarker613"/>during the entire lifetime of the software. That is why it is worth automating them. The automation of unit and integration tests avoids the possible errors of manual test execution and saves time. A whole battery of several thousand automated tests can verify software integrity following each small modification in a few minutes, thereby enabling the frequent changes needed in the CI/CD cycles of modern software.</p>
<p class="normal">As new bugs are found, new tests are added to discover them so that they cannot reappear in future versions of the software. This way, automated tests always become more reliable and protect the software more from bugs added as a result of new changes. Thus, the probability of adding new bugs (that are not immediately discovered) is greatly reduced.</p>
<p class="normal">The next subsection will give us the basics for organizing and designing automated unit and integration tests, as well <a id="_idIndexMarker614"/>as practical details<a id="_idIndexMarker615"/> on how to write a test in C# in the <em class="italic">Defining C# test projects in Visual Studio</em> section.</p>
<h2 class="heading-2" id="_idParaDest-183">Writing automated (unit and integration) tests</h2>
<p class="normal">Tests are not written from scratch; all software development platforms have tools that help us to both write tests and launch them (or some of them). Once the selected tests have been executed, these tools <a id="_idIndexMarker616"/>usually show a report and offer the possibility to debug the code of all failed tests.</p>
<p class="normal">More specifically, by and large, all unit and integration test frameworks are composed of three important parts:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord">Facilities for defining all tests</strong>: They verify whether the actual results correspond to the expected results. Usually, a test is organized into test classes, where each test call tests either a single application class or a single class method. Each test is split into three stages:<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord">Test preparation (</strong><em class="italic">Arrange</em><strong class="keyWord">)</strong>: The general environment needed by the test is prepared. This stage<a id="_idIndexMarker617"/> only prepares the global environment for tests, such as objects to inject into class constructors or simulations of database tables; it doesn’t prepare the individual inputs for each of the methods we’re going to test. Usually, the same preparation procedure is used in several tests, so test preparations are factored out into dedicated modules.</li>
<li class="numberedList"><strong class="keyWord">Test execution (</strong><em class="italic">Act</em><strong class="keyWord">/</strong><em class="italic">Assert</em><strong class="keyWord">)</strong>: The<a id="_idIndexMarker618"/> methods to test are invoked with adequate input (<em class="italic">Act</em>), and all results of their executions are compared with expected results (<em class="italic">Assert</em>) with constructs such as <code class="inlineCode">Assert.Equal(x,y)</code> and <code class="inlineCode">Assert.NotNull(x)</code>.</li>
<li class="numberedList"><strong class="keyWord">Tear-down</strong>: The whole<a id="_idIndexMarker619"/> environment is cleaned up to avoid the execution of a test influencing other tests. This step is the converse of <em class="italic">step 1</em>.</li>
</ol>
</li>
<li class="numberedList"><strong class="keyWord">Mock facilities</strong>: While integration tests use all (or almost all) classes involved in a pattern of object cooperation, in unit tests, the use of other application classes should be avoided because their purpose is to test each isolated method. Thus, if a class under test, say, <code class="inlineCode">A</code>, uses a method of another application class, <code class="inlineCode">B</code>, that is injected into its constructor in one of its methods, <code class="inlineCode">M</code>, and then, in order to test <code class="inlineCode">M</code>, we must inject a fake implementation of <code class="inlineCode">B</code>. It is worth pointing out that only classes that do some processing cannot be used by other classes being unit tested, while pure data classes can. Mock frameworks contain facilities to define implementations of interfaces and interface methods that return data that can be defined by the test designer. Typically, mock implementations are also able to report information on all mock method calls. Such mock implementations do not require the definition of actual class files but are done online in the test code by calling methods such as <code class="inlineCode">new Mock&lt;IMyInterface&gt;()</code>.</li>
<li class="numberedList"><strong class="keyWord">Execution and reporting tool</strong>: This is a visual configuration-based tool that the developer may use to decide which tests to launch and when to launch them. Moreover, it also<a id="_idIndexMarker620"/> shows the final outcome of the tests as a report containing all successful tests, all failed tests, each test’s execution time, and other information that depends on the specific tool and how it was configured. Usually, execution and reporting tools that are executed in development IDEs, such as Visual Studio, also give you the possibility of launching a debug session on each failed test.</li>
</ol>
<p class="normal">Since only interfaces allow a complete mock definition of all their methods, we should inject interfaces or pure data classes (that don’t need to be mocked) in class constructors and methods if we want to mock all dependencies in our unit tests. Therefore, for each cooperating class that we want to inject into another class and that we want to mock, we must define a corresponding interface.</p>
<p class="normal">Moreover, classes should use instances that are injected in their constructors or methods and not class instances available in the public static fields of other classes; otherwise, the results of the unit tests might appear not to be deterministic since these static values might not be set properly during the tests.</p>
<p class="normal">The subsection that follows focuses on functional and performance tests.</p>
<h2 class="heading-2" id="_idParaDest-184">Acceptance tests: writing functional and performance tests</h2>
<p class="normal">Acceptance tests define the contract <a id="_idIndexMarker621"/>between the project stakeholders and the development team. They are used to verify that the software developed actually behaves as it was agreed it would. Acceptance tests verify not only functional specifications but also constraints on the software usability and <strong class="keyWord">user interface</strong> (<strong class="keyWord">UI</strong>). Since they also have the purpose of <a id="_idIndexMarker622"/>showing how the software appears and behaves on actual computer monitors and displays, they are never completely automatic but consist mainly of lists of recipes and verifications that must be followed by an operator.</p>
<p class="normal">Sometimes, automatic <strong class="keyWord">functional tests</strong> are developed to verify just functional requirements, but <a id="_idIndexMarker623"/>some of these tests <a id="_idIndexMarker624"/>may also bypass the UI and inject the test input directly into the logic that is immediately behind the user interface. For instance, in the case of an ASP.NET Core MVC application (see <em class="chapterRef">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>), the whole website can be run in a complete environment that includes all the necessary storage filled with test data. Input is not provided to HTML pages but is injected directly into the ASP.NET Core controllers. Tests that bypass the user interface are called subcutaneous tests. ASP.NET <a id="_idIndexMarker625"/>Core supplies various tools to perform subcutaneous tests.</p>
<p class="normal">If possible, most automated acceptance tests should be defined as subcutaneous tests for the following reasons:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Automating the actual interaction with the user interface is a very time-consuming task.</li>
<li class="numberedList">User interfaces are changed frequently to improve their usability and to add new features, and small changes in a single application screen may force a complete rewrite of all tests that operate on that screen.</li>
</ol>
<p class="normal">In a few words, user interface tests are very expansive and have low reusability, so usually, complete adherence to specifications is tested with subcutaneous tests, and full tests involving the whole user interface are performed just to test the more common and/or more error-prone scenarios.</p>
<p class="normal">A common approach for testing the user interface is the usage of playback tools like <strong class="keyWord">Selenium IDE</strong> (<a href="https://www.selenium.dev/selenium-ide/">https://www.selenium.dev/selenium-ide/</a>) during <a id="_idIndexMarker626"/>manual tests so that each manual test can be repeated automatically. It’s likely that the code generated automatically by such tools is not robust enough to resist non-trivial changes in the HTML. The Selenium IDE playback code tries to resist HTML changes by attempting several selectors to identify each HTML element, but this only helps with small changes. Therefore, in general, playback code can be reused only for the parts of the application UI that are not affected by changes.</p>
<p class="normal">The Selenium software may also be used programmatically, that is, by describing user interface tests directly in the code. Selenium will be discussed in more detail in the <em class="italic">Automating functional tests in C#</em> section, while functional tests, in general, are discussed in the <em class="italic">Functional tests</em> section.</p>
<p class="normal"><strong class="keyWord">Performance tests</strong> apply a<a id="_idIndexMarker627"/> fake load to an application to see whether it can handle the typical production load, discover<a id="_idIndexMarker628"/> its load limits, and locate bottlenecks. The application is deployed in a staging environment that is a copy of the actual production environment in terms of hardware resources.</p>
<p class="normal">Then, fake requests are created and applied to the system, and response times and other metrics are collected. Fake request batches should have the same composition as the actual production batches. They can be generated from the actual production request logs if they are available.</p>
<p class="normal">If response times are not satisfactory, other metrics are collected to discover possible bottlenecks (low memory, slow storage, or slow software modules). Once located, a software component that is responsible for the problem can be analyzed in the debugger to measure the execution time of the various method calls involved in a typical request.</p>
<p class="normal">Failures in the performance tests may lead either to a redefinition of the hardware needed by the application or to the optimization of some software modules, classes, or methods.</p>
<p class="normal">Both Azure and Visual Studio offer tools to create fake loads and to report execution metrics. However, they have been declared obsolete and will be discontinued, so we will not describe them. As an alternative, there are both open-source and third-party tools that can be used. Some of them are listed in the <em class="italic">Further reading</em> section.</p>
<p class="normal">The next section describes a software development methodology that plays a central role in tests.</p>
<h1 class="heading-1" id="_idParaDest-185">Understanding the basics of test-driven development</h1>
<p class="normal"><strong class="keyWord">Test-driven development</strong> (<strong class="keyWord">TDD</strong>) is a <a id="_idIndexMarker629"/>software development methodology that gives a central role to unit tests. According to this methodology, unit tests are a formalization of the specifications of each class, so they must be written before the code of the class. Actually, a full test that covers all code paths univocally defines the code behavior, so it can be considered a specification for the code. It is not a formal specification that defines the code behavior through some formal language but a specification based on examples of behavior.</p>
<p class="normal">The ideal way to test software would be to write formal specifications of the whole software behavior and to verify with some wholly automatic tools whether the software that was actually produced conforms to them. In the past, some research effort was spent defining formal languages for describing code specifications, but expressing the behavior the developer has in mind with similar languages was a very difficult and error-prone task. Therefore, these attempts were quickly abandoned in favor of approaches based on examples. At that time, the main purpose was the automatic generation of code.</p>
<p class="normal">Nowadays, automatic code<a id="_idIndexMarker630"/> generation has been largely abandoned and survives in small application areas, such as the creation of device drivers. In these areas, the effort of formalizing the behavior in a formal language is worth the time saved in trying to test difficult-to-reproduce behaviors of parallel threads.</p>
<p class="normal">Unit tests were initially conceived as a way to encode example-based specifications in a completely independent way as part of a specific agile development methodology called <strong class="keyWord">extreme programming</strong>. However, since<a id="_idIndexMarker631"/> TDD proved to be very efficacious in preventing bugs, nowadays, TDD is used independently of extreme programming and is included as an obligatory prescription in other agile methodologies.</p>
<p class="normal">The practice of TDD proved that well-designed initial unit tests are enough to ensure an acceptable level of software stability, despite the fact that, usually, initial tests are not a “perfect” specification of the code. However, it is undoubtedly true that unit tests refined after finding hundreds of bugs act as reliable and substantially perfect code specifications.</p>
<p class="normal">Well-designed unit tests can’t be based on random inputs since you might need an infinite or at least an immense number of examples to define a code’s behavior this way univocally. However, the behavior can be defined with an acceptable number of inputs if you have all possible execution paths in mind. In fact, at this point, it is enough to select a typical example for each execution path.</p>
<p class="normal">That’s why writing a unit test for a method after that method has been completely coded is easy: it simply requires the selection of a typical instance for each execution path of the already-existing code. However, writing unit tests this way does not protect from errors in the design of the execution paths themselves.</p>
<div><p class="normal">Therefore, a unit test must be written before a method has been completely coded, but while writing unit tests, the developer must somehow forecast all execution paths by looking for extreme cases and by possibly adding more examples than are strictly needed.</p>
</div>
<p class="normal">For instance, while writing the code that sorts an array, we might start considering all possible extreme cases we<a id="_idIndexMarker632"/> are able to forecast before any line of useful method code has been written, that is:</p>
<ul>
<li class="bulletList">An empty array</li>
<li class="bulletList">A null array</li>
<li class="bulletList">A single-element array</li>
<li class="bulletList">An array with a few elements</li>
<li class="bulletList">An array with several elements</li>
<li class="bulletList">An already-ordered array</li>
<li class="bulletList">A partially ordered array</li>
<li class="bulletList">An extremely unordered array</li>
</ul>
<p class="normal">After the first version of the algorithm has been written and passes all of the above tests, other inputs that might cause different execution paths might be discovered by analyzing all execution paths. If this is the case, we add a new unit test for each different execution path discovered.</p>
<p class="normal">For instance, in the case of the array sorting method, suppose that we use a divide-and-conquer algorithm, like merge-sort, that recursively splits the array into two halves to recursively reduce the problem to a simpler one. For sure, the way that arrays with even or odd lengths are processed will be different, so we must add at least two new tests, one with an even-length array and the other with an odd-length array.</p>
<p class="normal">However, as developers can make mistakes while writing application code, they can also make mistakes in forecasting all possible execution paths while designing unit tests!</p>
<p class="normal">It seems we have identified a possible drawback of TDD: unit tests themselves may be wrong. That is, not only application code but also its associated TDD unit tests may be inconsistent with the behavior the developer has in mind. Therefore, in the beginning, unit tests can’t be considered software specifications but rather a possibly incorrect and incomplete description of the software behavior.</p>
<p class="normal">Therefore, we have two descriptions of the behavior we have in mind: the application code itself and its TDD unit tests that were written before the application code. However, this is not an issue because the theory of probability helps us!</p>
<div><p class="normal">What makes TDD work well in practice is the fact that the probability of making exactly the same error while writing the tests and while writing the code is very low. Therefore, whenever a test fails, there is an error either in the tests or in the application code, and conversely, if there is an error either in the application code or in the test, there is a very high probability that a test will fail. That is, the use of TDD ensures that most bugs are found immediately!</p>
</div>
<p class="normal">Now that we have <a id="_idIndexMarker633"/>understood why TDD is efficacious in preventing bugs and have learned how to select the inputs for our unit tests, we can move to the description of the TDD-based code-writing process.</p>
<p class="normal">Writing a class method or a chunk of code, say for finding the maximum of an array of integers with TDD, is a loop composed of three stages:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord">Red stage</strong>: At this stage, the developer <a id="_idIndexMarker634"/>writes an empty method, say <code class="inlineCode">MaximumGrade</code>, that throws <code class="inlineCode">NotImplementedException</code>, and also writes new unit tests for this method. These tests must necessarily fail because, at this time, no code implements the behavior they describe:
        <pre class="programlisting code"><code class="hljs-code">public int MaximumGrade(int[] grades)
{
    throw new NotImplementedException();
}
</code></pre>
</li>
<li class="numberedList"><strong class="keyWord">Green stage</strong>: In this stage, the <a id="_idIndexMarker635"/>developer writes the minimum code or makes the minimum modifications to existing code necessary to make all unit tests pass. Say we test <code class="inlineCode">MaximumGrade</code> with a null array, an array with <code class="inlineCode">0</code> elements, an array with just one element, and an array with several elements; the code that passes all tests might be:
        <pre class="programlisting code"><code class="hljs-code">int MaximumGrade(int[] grades)
{
    if(grades == null) return 0;
    int result= 0;
    for(int i = 0; i &lt; grades.Length; i++)
    {
        if (grades[i]&gt; result) result= grades[i];
    }
    return result;
}
</code></pre>
</li>
<li class="numberedList"><strong class="keyWord">Refactoring stage</strong>: Once the test is passed, the code is refactored to ensure good code quality and the <a id="_idIndexMarker636"/>application of best practices and patterns. In particular, in this stage, some code can be factored out in other methods or other classes. During this stage, we may also discover the need for other unit tests because new execution paths or new extreme cases are discovered or created. In the case of <code class="inlineCode">MaximumGrade</code>, at this stage, we might notice the following:<ul>
<li class="bulletList">Instead of returning 0 when the array is <code class="inlineCode">null</code>, it would be better to define a new exception and throw it.</li>
<li class="bulletList"><code class="inlineCode">foreach</code> is more efficient and more readable than <code class="inlineCode">for</code>.</li>
<li class="bulletList">What if all numbers are negative? We must create a new test with an array of negative numbers:</li>
</ul>
<pre class="programlisting code"><code class="hljs-code">int MaximumGrade(int[] grades)
{
    if(grades == null) throw new ArgumentException();
    int result= 0;
    foreach(int grade in grades)
    {
        if (grade &gt; result) result= grade;
    }
    return result;
}
</code></pre>
</li>
</ol>
<p class="normal">The loop stops as soon as all tests pass without writing new code or modifying the existing code.</p>
<p class="normal">When we repeat the red stage, the newly added test for the negative array will fail because of our inadequate initialization:</p>
<pre class="programlisting code"><code class="hljs-code">int result=0;
</code></pre>
<p class="normal">So, we need to replace it with:</p>
<pre class="programlisting code"><code class="hljs-code">int result= int.MinValue;
</code></pre>
<p class="normal">At this point, all tests pass again, and we move to the green stage again. There is no need for further refactoring, so the refactoring stage doesn’t modify our code, meaning we can exit the test loop: we are done!</p>
<p class="normal">Sometimes, it is very difficult to design the initial unit tests because it is quite difficult to imagine how the code might work and the execution paths it might take. In this case, you can get a better understanding <a id="_idIndexMarker637"/>of the specific algorithm to use by writing an initial sketch of the method code. In this initial stage, we need to focus just on the main execution path, completely ignoring extreme cases and input verifications. Once we get a clear picture of the main ideas behind an algorithm that should work, we can enter the standard three-stage TDD loop.</p>
<p class="normal">The next section discusses functional tests in detail.</p>
<h1 class="heading-1" id="_idParaDest-186">Functional tests</h1>
<p class="normal">These tests use the same techniques and tools as unit and integration tests but differ from them in that they are<a id="_idIndexMarker638"/> run only at the end of each sprint. They have the fundamental role of verifying that the current version of the entire software complies with its specifications.</p>
<p class="normal">Since functional tests also involve the UI, they <a id="_idIndexMarker639"/>need further tools to simulate, somehow, how the user acts in the UI. The need for extra tools is not the only challenge the UI brings with it because UIs also see frequent and major changes. Thus, we mustn’t design tests that depend on the UI’s graphical details, or we might be forced to rewrite all the tests completely at each UI change. We will discuss both the tools and the best practices for optimizing UI tests in the <em class="italic">Automating functional tests in C#</em> section.</p>
<p class="normal">Anyway, it is worth pointing out that sometimes it is better to renounce automated testing for some UI-related features and fall back to manual tests because the time investment is not justified by the short life of the UI code.</p>
<p class="normal">Whether automatic or manual, functional testing must be a formal process that is performed for the following purposes:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Functional tests represent the most important part of the contract between stakeholders and the development team, the other part being the verification of non-functional specifications. The way this contract is formalized depends on the nature of the relationship between the development team and stakeholders.</li>
<li class="numberedList">In the case of a supplier-customer relationship, the functional tests become part of the supplier-customer business contract for each sprint, and a team that works for the customer writes them. If the tests fail, then the sprint is rejected, and the supplier must run a supplementary sprint to fix all problems.</li>
<li class="numberedList">If there is no supplier-customer business relationship because the development team and the stakeholder belong to the same company, there is no business contract. In this case, the stakeholder, together with the team, writes an internal document that formalizes the requirements of the sprint. If the tests fail, usually, the sprint is not rejected, but the results of the tests are used to drive the specifications for the next sprints. Of course, if the failure percentage is high, the sprint may be rejected and should be repeated.</li>
<li class="numberedList">Formalized functional tests that run at the end of each sprint prevent any results achieved in previous sprints from being destroyed by new code.</li>
<li class="numberedList">When using an agile development methodology, maintaining an updated battery of functional tests is the best way to get a formal representation of the final system specifications since, during agile development, the specifications of the final system are not decided before development starts but are the result of the system’s evolution. Agile development and sprints are discussed in detail in <em class="chapterRef">Chapter 1</em>, <em class="italic">Understanding the Importance of Software Architecture</em>.</li>
</ol>
<p class="normal">Since the output of the first sprints may differ a lot from the final system in these early stages, it is not worth spending<a id="_idIndexMarker640"/> too much time writing detailed manual tests and/or automatized tests. Therefore, you may limit the user stories to just a few examples that will be used both as inputs for software development and as manual tests.</p>
<p class="normal">As system functionalities become more stable, it is worth investing time in writing detailed and formal functional tests for them. For each functional specification, we must write tests that verify their operation in extreme cases. For instance, in a cash withdrawal use case, we must write tests that verify all possibilities:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Not enough funds</li>
<li class="numberedList">Card expired</li>
<li class="numberedList">Wrong credentials</li>
<li class="numberedList">Repeated wrong credentials</li>
</ol>
<p class="normal">The following diagram sketches the whole process with all possible outcomes:</p>
<figure class="mediaobject"><img alt="Descrizione: Diagram  Description automatically generated" src="img/B19820_09_01.png"/></figure>
<p class="packt_figref">Figure 9.1: Withdrawal example</p>
<p class="normal">The user inserts their card, and <a id="_idIndexMarker641"/>the card may be accepted or rejected because it has expired. Then, the user tries their PIN with possible errors, so they might repeat the PIN entry till either they succeed or they reach a maximum number of attempts. Finally, the user enters the amount to withdraw and may get their money or a “Not enough funds” error.</p>
<p class="normal">In the case of manual tests, for each of the preceding scenarios, we must give all the details of all the steps involved in each operation and, for each step, the expected result.</p>
<p class="normal">An important decision is whether you want to automate all or a part of the functional tests since it is very expensive to write automated tests that simulate a human operator that interacts with a system’s UI. The final decision depends on the cost of the test implementation divided by the expected number of times it will be used.</p>
<p class="normal">In the case of CI/CD, the same functional test can be executed several times, but unluckily, functional tests are strictly tied to the way the UI is implemented, and, in modern systems, the UI is changed frequently. Therefore, in this case, a test is executed with exactly the same UI no more than a couple of times.</p>
<p class="normal">In order to overcome most of the problems related to the UI, some functional tests can be implemented as <strong class="keyWord">subcutaneous tests</strong>. Subcutaneous <a id="_idIndexMarker642"/>tests are a specific type of functional test designed to bypass the UI layer of an application. Instead of interacting with the application through its UI, like a user would, these tests directly interact with the application’s underlying<a id="_idIndexMarker643"/> logic. For example, in an ASP.NET Core application, a subcutaneous test might directly invoke the methods of a controller – the part of the application that handles incoming requests – rather than going through the process of sending these requests via a browser. This approach helps us focus on testing the core functionality of the application without the complexities of the UI.</p>
<p class="normal">In the user case in <em class="chapterRef">Chapter 21</em>, <em class="italic">Case Study</em>, we will see in practice how to design subcutaneous tests for an ASP.NET Core application.</p>
<p class="normal">Unfortunately, subcutaneous tests can’t verify all possible implementation errors since they can’t detect errors in the UI itself. Moreover, in the case of a web application, subcutaneous tests usually suffer from other limitations because they bypass the whole HTTP protocol.</p>
<p class="normal">In particular, in the case of ASP.NET Core applications, which will be described in <em class="chapterRef">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, if we call controller action methods directly, we bypass the whole ASP.NET Core pipeline that processes each request before passing it to the right action method. Therefore, authentication, authorization, CORS, and the behavior of other middleware in the ASP.NET Core pipeline will not be analyzed by the tests.</p>
<p class="normal">A complete automated functional test of a web application should do the following things:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Start an actual browser on the URL to be tested.</li>
<li class="numberedList">Wait so that any JavaScript on the page completes its execution.</li>
<li class="numberedList">Then, send commands to the browser that simulate the behavior of a human operator.</li>
<li class="numberedList">Finally, after each interaction with the browser, automatic tests should wait so that any JavaScript that was triggered by the interaction completes.</li>
</ol>
<p class="normal">Such tests can be executed using browser automatization <a id="_idIndexMarker644"/>tools like <strong class="keyWord">Selenium,</strong> which will be discussed in the <em class="italic">Automating functional tests in C#</em> section of this chapter.</p>
<div><p class="normal">It is worth pointing out that not all user interface tests can be automated since no automatic test can verify how the user interface appears and how usable it is.</p>
</div>
<p class="normal">As we’ve explored the intricacies of functional and subcutaneous testing, it’s become clear that a comprehensive testing strategy must encompass not only how the tests are performed but also how they<a id="_idIndexMarker645"/> are conceptualized and communicated. This brings us <a id="_idIndexMarker646"/>to <strong class="keyWord">Behavior-Driven Development </strong>(<strong class="keyWord">BDD</strong>), a methodology that builds upon the principles of functional testing by emphasizing business value and client-side behavior. BDD offers a structured approach to creating tests that are more closely aligned with user requirements and business objectives.</p>
<h1 class="heading-1" id="_idParaDest-187">Behavior-Driven Development (BDD)</h1>
<p class="normal">BDD conforms to the rules of TDD we already described but focuses mainly on business value and client-side behavior.</p>
<p class="normal">We discussed that the strength of unit tests is <a id="_idIndexMarker647"/>as follows: “It is very unlikely that when describing a behavior in two completely different ways, that is, with code and with examples, we might make exactly the same errors, so errors are discovered with a probability that is close to 100%.”</p>
<p class="normal">BDD uses the same approach, but the examples used in TDD must not depend on the specific way the functionality might be implemented. That is, examples must be as close as possible to pure specifications. This way, we are sure tests can’t influence the way functionality is implemented and vice versa; we are not influenced by pure technical facilities or constraints when writing specifications but focus mainly on the user needs.</p>
<p class="normal">Moreover, tests should use a vocabulary that can be understood by stakeholders. For these reasons, tests are described by a Given-When-Then syntax. The following is an example:</p>
<pre class="programlisting gen"><code class="hljs">Given the first number is 50
And the second number is 70
When the two numbers are added
Then the result should be 120
</code></pre>
<p class="normal"><code class="inlineCode">Given</code>, <code class="inlineCode">And</code>, <code class="inlineCode">When</code>, and <code class="inlineCode">Then</code> are keywords, while the remaining text is just natural language containing the example data.</p>
<p class="normal">The Given-When-Then formal<a id="_idIndexMarker648"/> language is called Gherkin. It can be translated into code either manually or with tools that are part of toolsets like Cucumber (<a href="https://cucumber.io/">https://cucumber.io/</a>) or SpecFlow in the <a id="_idIndexMarker649"/>case of .NET projects. SpecFlow is a Visual Studio extension that can be installed from the Visual Studio <strong class="keyWord">Extensions</strong> menu. Once installed, it adds a new kind of test project, a SpecFlow project.</p>
<p class="normal">In SpecFlow, Given-When-Then<a id="_idIndexMarker650"/> tests are defined in <code class="inlineCode">.feature</code> files, while natural language clauses contained in the description are transformed into code in the so-called step files. Step files are automatically created, but the code inside of them must be written by the developer. Below is the method that is in charge of translating into code the <code class="inlineCode">"Given the first number is 50"</code> clause:</p>
<pre class="programlisting code"><code class="hljs-code">[Given("the first number is (.*)")]
public void GivenTheFirstNumberIs(int number)
{
     _calculator.FirstNumber = number;
}
</code></pre>
<p class="normal">The attribute on top of the method is automatically created by SpecFlow, but the (.*) regular expression that extracts the datum from the natural language clause must be written by the developer.</p>
<p class="normal"><code class="inlineCode">_calculator</code> is a variable that must be created by the developer and that contains a class to test:</p>
<pre class="programlisting code"><code class="hljs-code">private readonly Calculator _calculator = new Calculator();
</code></pre>
<p class="normal">Once completely defined, SpecFlow tests are run by exploiting an underlying test framework supported by .NET. The underlying test framework to use is specified when the SpecFlow project is created.</p>
<div><p class="normal">While BDD and the Gherkin syntax can be used in unit, integration, and functional tests, the effort of writing tests in natural language and turning them into code is worth it only for functional tests because functional tests must be easily understood by stakeholders.</p>
</div>
<p class="normal">When writing unit tests, the BDD rule of the independence of tests from the implementation improves the tests’ quality and lifetime (fewer tests depend on implementation. Thus, they need to be updated less frequently). However, keep in mind that the classes that we are unit testing are themselves the result of implementation choices, so an excessive obsession with test independence might result in a waste of time.</p>
<p class="normal">After having described the theory behind testing, we are ready to move to practical implementations in C#. In the<a id="_idIndexMarker651"/> next section, we will list all test projects available in Visual Studio and describe xUnit in detail.</p>
<h1 class="heading-1" id="_idParaDest-188">Defining C# test projects in Visual Studio</h1>
<p class="normal">The .NET SDK contains project templates for three types of unit testing frameworks: MSTest, xUnit, and NUnit. When<a id="_idIndexMarker652"/> starting the new project wizard in Visual Studio, if you <a id="_idIndexMarker653"/>want to see the compatible versions of these testing frameworks for .NET C# applications, set the <strong class="keyWord">Project type</strong> to <strong class="keyWord">Test</strong>, the <strong class="keyWord">Language</strong> to <strong class="keyWord">C#</strong>, and the <strong class="keyWord">Platform</strong> as <strong class="keyWord">Linux</strong>. This configuration will allow you to identify and select the appropriate versions of MSTest, xUnit, and NUnit for your project.</p>
<p class="normal">The following screenshot shows the selection that should appear:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="img/B19820_09_02.png"/></figure>
<p class="packt_figref">Figure 9.2: Adding a test project</p>
<p class="normal">All the preceding projects automatically include the NuGet package for running all the tests in the Visual Studio test user interface (Visual Studio test runner). However, they do not include any facility for <a id="_idIndexMarker654"/>mocking interfaces, so you need to add the <code class="inlineCode">Moq</code> NuGet package, which contains a popular mocking framework.</p>
<p class="normal">All these test projects<a id="_idIndexMarker655"/> must contain a reference to the project to be tested.</p>
<p class="normal">In the next subsection, we will <a id="_idIndexMarker656"/>describe <strong class="keyWord">xUnit</strong>, but all three frameworks are quite similar and differ mainly in the names of the assert methods and the names of the attributes used to decorate various testing classes and methods.</p>
<h2 class="heading-2" id="_idParaDest-189">Using the xUnit test framework</h2>
<p class="normal">In xUnit, tests are methods <a id="_idIndexMarker657"/>decorated with either the <code class="inlineCode">[Fact]</code> or <code class="inlineCode">[Theory]</code> attributes. Tests are automatically discovered by the test runner, which lists all of them in the user interface so the user can run either all of them or just a selection of them.</p>
<p class="normal">A new instance of the test class is created before running each test, so the <em class="italic">test preparation</em> code contained in the class constructor is executed before each test of the class. If you also require <em class="italic">tear-down code</em>, the test class must implement the <code class="inlineCode">IDisposable</code> interface so that the tear-down code can be included in the <code class="inlineCode">IDisposable.Dispose</code> method.</p>
<p class="normal">The test code invokes the methods to be tested and then tests the results with methods from the <code class="inlineCode">Assert</code> static class, such as <code class="inlineCode">Assert.NotNull(x)</code>, <code class="inlineCode">Assert.Equal(x, y)</code>, and <code class="inlineCode">Assert.NotEmpty(IEnumerable x)</code>. Some methods verify whether a call throws an exception of a specific type, for instance:</p>
<pre class="programlisting code"><code class="hljs-code"> Assert.Throws&lt;MyException&gt;(() =&gt; {/* test code */ ...}).
</code></pre>
<p class="normal">When an assertion fails, an <a id="_idIndexMarker658"/>exception is thrown. A test fails if a not-intercepted exception is thrown either by the test code or by an assertion.</p>
<p class="normal">The following is an example of a method that defines a single test:</p>
<pre class="programlisting code"><code class="hljs-code">[Fact]
public void Test1()
{
    var myInstanceToTest = new ClassToTest();
    Assert.Equal(5, myInstanceToTest.MethodToTest(1));
}
</code></pre>
<p class="normal">The <code class="inlineCode">[Fact]</code> attribute is used when a method defines just one test, while the <code class="inlineCode">[Theory]</code> attribute is used when the same method defines several tests, each on a different tuple of data. Tuples of data can be specified in several ways and are injected into the test as method parameters.</p>
<p class="normal">The previous code can be modified to test <code class="inlineCode">MethodToTest</code> on several inputs as follows:</p>
<pre class="programlisting code"><code class="hljs-code">[Theory]
[InlineData(1, 5)]
[InlineData(3, 10)]
[InlineData(5, 20)]
public void Test1(int testInput, int testOutput)
{
    var myInstanceToTest = new ClassToTest();
    	 Assert.Equal(testOutput,
        myInstanceToTest.MethodToTest(testInput));
}
</code></pre>
<p class="normal">Each <code class="inlineCode">InlineData</code> attribute specifies a tuple to be injected into the method parameters. Since just simple constant data can be included as attribute arguments, xUnit also gives you the possibility to take all <a id="_idIndexMarker659"/>data tuples from a class that implements <code class="inlineCode">IEnumerable</code>, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">public class Test1Data: IEnumerable&lt;object[]&gt;
{
    public IEnumerator&lt;object[]&gt; GetEnumerator()
    {
        yield return new object[] { 1, 5};
        yield return new object[] { 3, 10 };
        yield return new object[] { 5, 20 };
    }
    IEnumerator IEnumerable.GetEnumerator()=&gt;GetEnumerator();  
}
...
[Theory]
[ClassData(typeof(Test1Data))]
public void Test1(int testInput, int testOutput)
{
    var myInstanceToTest = new ClassToTest();
    Assert.Equal(testOutput,
    myInstanceToTest.MethodToTest(testInput));
}
</code></pre>
<p class="normal">The type of class that provides the test data is specified with the <code class="inlineCode">ClassData</code> attribute.</p>
<p class="normal">It is also possible to take data from a static method of a class that returns <code class="inlineCode">IEnumerable</code> with the <code class="inlineCode">MemberData</code> attribute, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">[Theory]
[MemberData(nameof(MyStaticClass.Data),
    MemberType= typeof(MyStaticClass))]
public void Test1(int testInput, int testOutput)
{
    ...
</code></pre>
<p class="normal">The <code class="inlineCode">MemberData</code> attribute is passed the method name as the first parameter, and the class type in the <code class="inlineCode">MemberType</code> named parameter. If the static method is part of the same test class, the <code class="inlineCode">MemberType</code> parameter can be omitted.</p>
<p class="normal">The next subsection shows how<a id="_idIndexMarker660"/> to deal with some advanced preparation and tear-down scenarios.</p>
<h2 class="heading-2" id="_idParaDest-190">Advanced test preparation and tear-down scenarios</h2>
<p class="normal">Sometimes, the preparation <a id="_idIndexMarker661"/>code contains very time-consuming operations, such as opening a connection with a database that doesn’t need to be repeated before each test but that can be executed once before all the tests contained in the same class. In xUnit, this kind of test preparation code can’t be included in the test class constructor; since a different instance of the test class is created before every single test, it must be factored out in a separate class called a fixture class.</p>
<p class="normal">If we also need corresponding tear-down code, the fixture class must implement <code class="inlineCode">IDisposable</code>. In other test frameworks, such as NUnit, the test class instances are created just once instead, so they don’t need the fixture code to be factored out in other classes. However, test frameworks <a id="_idIndexMarker662"/>such as <strong class="keyWord">NUnit</strong>, which do not create a new instance before each test, may suffer from bugs because of unwanted interactions between test methods.</p>
<p class="normal">The following is an example of an xUnit fixture class that opens and closes a database connection:</p>
<pre class="programlisting code"><code class="hljs-code">public class DatabaseFixture : IDisposable
{
    public DatabaseFixture()
    {
        Db = new SqlConnection("MyConnectionString");
    }
    public void Dispose()
    {
        Db.Close()
    }
    public SqlConnection Db { get; private set; }
}
</code></pre>
<p class="normal">Since a fixture class instance is created just once before all tests associated with the fixture are executed and the same instance is disposed of immediately after the tests, then the database connection is created just once when the fixture class is created and is disposed of immediately after the<a id="_idIndexMarker663"/> tests when the fixture object is disposed of.</p>
<p class="normal">The fixture class is associated with each test class by letting the test class implement the empty <code class="inlineCode">IClassFixture&lt;T&gt;</code> interface as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public class MyTestsClass : IClassFixture&lt;DatabaseFixture&gt;
{
    private readonly DatabaseFixture fixture;
    public MyDatabaseTests(DatabaseFixture fixture)
    {
        this.fixture = fixture;
    }
    ...
}
</code></pre>
<p class="normal">A fixture class instance is automatically injected into the test class constructor in order to make all data computed in the fixture test preparation available for the tests. This way, for instance, in our previous example, we can get the database connection instance so that all test methods of the class can use it.</p>
<p class="normal">If we want to execute some test preparation code on all tests contained in a collection of test classes instead of a single test class, we must associate the fixture class with an empty class that represents the collection of test classes, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">[CollectionDefinition("My Database collection")]
public class DatabaseCollection : ICollectionFixture&lt;DatabaseFixture&gt;
{
    // this class is empty, since it is just a placeholder
}
</code></pre>
<p class="normal">The <code class="inlineCode">CollectionDefinition</code> attribute declares the name of the collection, and the <code class="inlineCode">IClassFixture&lt;T&gt;</code> interface has been replaced with <code class="inlineCode">ICollectionFixture&lt;T&gt;</code>.</p>
<p class="normal">Then, we declare that a test class <a id="_idIndexMarker664"/>belongs to the previously defined collection by applying it to the <code class="inlineCode">Collection</code> attribute with the name of the collection, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">[Collection("My Database collection")]
public class MyTestsClass
{
    DatabaseFixture fixture;
    public MyDatabaseTests(DatabaseFixture fixture)
    {
        this.fixture = fixture;
    }
    ...
}
</code></pre>
<p class="normal">The <code class="inlineCode">Collection</code> attribute declares which collection to use, while the <code class="inlineCode">DataBaseFixture</code> argument in the test class constructor provides an actual fixture class instance, so it can be used in all class tests.</p>
<p class="normal">Now that we have seen how to leverage fixture classes to share setup and cleanup code across multiple tests, enhancing our test organization and efficiency, we turn our attention to another powerful technique in our testing arsenal. The following section introduces the use of the <code class="inlineCode">Moq</code> framework, a tool that allows us to simulate the behavior of complex dependencies in our tests through mocking. This approach is crucial for isolating the component we are testing and verifying its behavior under controlled conditions without the need for the actual implementations of its dependencies.</p>
<h2 class="heading-2" id="_idParaDest-191">Mocking interfaces with Moq</h2>
<p class="normal">Mocking is a technique used in <a id="_idIndexMarker665"/>both unit testing to isolate classes from dependencies they have on other classes, so we can impute each test failure to the class under test. Classes<a id="_idIndexMarker666"/> are isolated from their dependencies by creating a mock or a fake version of each dependency.</p>
<p class="normal">Mocking capabilities are not included in any of the test frameworks we listed in this section, as they are not included in xUnit, so we must add another library that offers mocking capability. The <code class="inlineCode">Moq</code> framework, a popular tool in .NET, makes the mocking process super-easy.</p>
<p class="normal">Let’s explore how to use <code class="inlineCode">Moq</code> to create mocks and set up our tests effectively. Here, we will discuss just how to use <code class="inlineCode">Moq</code> to create mock classes. A practical and complete example that shows how to use <code class="inlineCode">Moq</code> in <a id="_idIndexMarker667"/>your tests in practice is in the <em class="italic">Testing the WWTravelClub application </em>section of <em class="chapterRef">Chapter 21</em>, <em class="italic">Case Study</em>.</p>
<p class="normal">As a first step, we need to install the <code class="inlineCode">Moq</code> NuGet package. Then, we need to add a <code class="inlineCode">using Moq</code> statement to our test files. A mock implementation is easily defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> var myMockDependency = new Mock&lt;IMyInterface&gt;();
</code></pre>
<p class="normal">The behavior of the mock dependency<a id="_idIndexMarker668"/> on specific inputs of the specific method can be defined with the <code class="inlineCode">Setup/Return</code> method pair as follows:</p>
<pre class="programlisting code"><code class="hljs-code">myMockDependency.Setup(x=&gt;x.MyMethod(5)).Returns(10);
</code></pre>
<p class="normal">We can add several <code class="inlineCode">Setup/Return</code> instructions for the same method. This way, we can specify an indefinite number of input/output behaviors.</p>
<p class="normal">Instead of specific input values, we may also use wildcards that match a specific type as follows:</p>
<pre class="programlisting code"><code class="hljs-code">myMockDependency.Setup(x =&gt; x.MyMethod(It.IsAny&lt;int&gt;()))
                  .Returns(10);
</code></pre>
<p class="normal">Where we replaced <code class="inlineCode">5</code> with its type, <code class="inlineCode">int</code>.</p>
<p class="normal">Once we have configured the mock dependency, we may extract the mocked instance from its <code class="inlineCode">Object</code> property and use it as if it were an actual implementation, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">var myMockedInstance=myMockDependency.Object;
...
myMockedInstance.MyMethod(10);
</code></pre>
<p class="normal">However, mocked methods are usually called by the code under test, so we just need to extract the mocked instance and use it as an input in our tests.</p>
<p class="normal">We may also mock properties and <strong class="keyWord">async</strong> methods as follows:</p>
<pre class="programlisting code"><code class="hljs-code">myMockDependency.Setup(x =&gt; x.MyProperty)
                  .Returns(42);
...
myMockDependency.Setup(x =&gt; x.MyMethodAsync(1))
                    .ReturnsAsync("aasas");
var res=await myMockDependency.Object
    .MyMethodAsync(1);
</code></pre>
<p class="normal">With <code class="inlineCode">async</code> methods, <code class="inlineCode">Returns</code> must be replaced by <code class="inlineCode">ReturnsAsync</code>.</p>
<p class="normal">Each mocked instance records all calls to its methods and properties, so we may use this information in our tests. The<a id="_idIndexMarker669"/> following code shows an example:</p>
<pre class="programlisting code"><code class="hljs-code">myMockDependency.Verify(x =&gt; x.MyMethod(1), Times.AtLeast(2));
</code></pre>
<p class="normal">The preceding statement asserts<a id="_idIndexMarker670"/> that <code class="inlineCode">MyMethod</code> has been invoked with the given arguments at least twice. There are also <code class="inlineCode">Times.Never</code>, and <code class="inlineCode">Times.Once</code> (which asserts that the method was called just once), and more.</p>
<p class="normal">The <code class="inlineCode">Moq</code> documentation summarized up to now should cover 99% of the needs that may arise in your tests, but <code class="inlineCode">Moq</code> also offers more complex options. The <em class="italic">Further reading</em> section contains the link to the complete documentation.</p>
<p class="normal">The <em class="italic">Testing the WWTravelClub application</em> section of <em class="chapterRef">Chapter 21</em>, <em class="italic">Case Study</em>, shows the practical usage of <code class="inlineCode">Moq</code> in a complex example.</p>
<p class="normal">After exploring the capabilities of <code class="inlineCode">Moq</code> and how it enhances our unit testing with effective mock implementations, we now turn our attention to a different facet of C# application testing – automating functional tests in ASP.NET Core applications. In this next section, we’ll dive into how various testing tools and techniques, including some we’ve just discussed, are applied to ensure our ASP.NET Core applications function as intended, both in isolation and when integrated with other systems and interfaces.</p>
<h1 class="heading-1" id="_idParaDest-192">Automating functional tests in C#</h1>
<p class="normal">Automated functional tests use<a id="_idIndexMarker671"/> the same test tools as unit and integration tests. That is, these tests can be embedded in the same xUnit, NUnit, or MSTest projects that we described in the previous section. However, in this case, we must add further tools that can<a id="_idIndexMarker672"/> interact with and inspect the UI.</p>
<p class="normal">In the remainder of this chapter, we will focus on web applications since they are the main focus of this book. Accordingly, if we are testing web APIs, we just need <code class="inlineCode">HttpClient</code> instances since they can easily interact with web API endpoints in both XML and JSON.</p>
<p class="normal">In the case of applications that return HTML pages, the interaction is more complex since we also need tools for parsing and interacting with the HTML page DOM tree.</p>
<p class="normal">The <em class="italic">Selenium</em> toolset is a great solution since it has drivers for simulating user interaction in all mainstream <a id="_idIndexMarker673"/>browsers and for programmatically accessing the browser DOM.</p>
<p class="normal">There are two basic options for testing a web application with the <code class="inlineCode">HttpClient</code> class:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord">Staging application</strong>: An <code class="inlineCode">HttpClient</code> instance connects with the actual <em class="italic">staging</em> web application through the internet/intranet, together with all other humans who are beta-testing the software. The advantage of this approach is that you are testing the <em class="italic">real stuff</em>, but tests<a id="_idIndexMarker674"/> are more difficult to conceive since you can’t control the initial state of the application before each test.</li>
<li class="numberedList"><strong class="keyWord">Controlled application</strong>: An <code class="inlineCode">HttpClient</code> instance connects with a local application that is configured, initialized, and launched before every single test. This scenario is completely analogous to the unit test scenario. Test results are reproducible, the initial state before each test is fixed, tests are easier to design, and the actual database can be<a id="_idIndexMarker675"/> replaced by a faster and easier-to-initialize in-memory database. However, in this<a id="_idIndexMarker676"/> case, you are far from the actual system’s operation.</li>
</ol>
<p class="normal">A good strategy is to use a <strong class="keyWord">controlled application</strong>, where you have full control of the initial state, for testing the extreme cases, and then use a <strong class="keyWord">staging application</strong> for testing random average cases on the <em class="italic">real stuff</em>.</p>
<p class="normal">The two subsections that follow describe both approaches. The two approaches differ only in the way that you define the fixtures of your tests.</p>
<h2 class="heading-2" id="_idParaDest-193">Testing the staging application</h2>
<p class="normal">In the case of staging <a id="_idIndexMarker677"/>applications, your tests just need a class that can issue HTTP requests, which in the case of .NET is the <code class="inlineCode">HttpClient</code> class. It is enough to define an efficient fixture that supplies the needed <code class="inlineCode">HttpClient</code> instances, avoiding the risk of running out of operating system connections. Efficient management of the underlying operating system connections can be achieved through the <code class="inlineCode">IHttpClientFactory</code> interface.</p>
<p class="normal">It is enough to add an <code class="inlineCode">HttpClient</code> management factory to a dependency injection container that will be used by the tests with:</p>
<pre class="programlisting code"><code class="hljs-code">services.AddHttpClient(),
</code></pre>
<p class="normal">where the <code class="inlineCode">AddHttpClient</code> extension belongs to the <code class="inlineCode">Microsoft.Extensions.DependencyInjection</code> namespace and is defined in the <code class="inlineCode">Microsoft.Extensions.Http</code> NuGet package. Therefore, our test fixture must create a dependency injection container, call the <code class="inlineCode">AddHttpClient</code> extension method, and finally build the container. The <a id="_idIndexMarker678"/>following fixture class does this job:</p>
<pre class="programlisting code"><code class="hljs-code">public class HttpClientFixture
{
    public HttpClientFixture()
    {
        var serviceCollection = new ServiceCollection();
        serviceCollection
            .AddHttpClient();
         ServiceProvider = serviceCollection.BuildServiceProvider();
    }
    public ServiceProvider ServiceProvider { get; private set; }
}
</code></pre>
<p class="normal">After the preceding definition, your tests should look as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public class MyUnitTestClass:IClassFixture&lt;HttpClientFixture&gt;
{
    private readonly ServiceProvider _serviceProvider;
    public UnitTest1(HttpClientFixture fixture)
    {
        _serviceProvider = fixture.ServiceProvider;
    }
    [Fact]
    public void MyTest()
    {
        var factory =
            _serviceProvider.GetService&lt;IHttpClientFactory&gt;())
       
            HttpClient client = factory.CreateClient();
    }
}
</code></pre>
<p class="normal">In <code class="inlineCode">Test1</code>, once you get an HTTP client, you can test the application by issuing an HTTP request and then by analyzing the response returned by the application.</p>
<p class="normal">The approach described above is adequate when the HTTP endpoints return data, for instance, in JSON format that can be turned into .NET data by a data serializer/deserializer and <a id="_idIndexMarker679"/>then compared with the expected data.</p>
<p class="normal">The next subsection describes how to test endpoints that return HTML.</p>
<h2 class="heading-2" id="_idParaDest-194">Testing the staging application with Selenium</h2>
<p class="normal">Most endpoints that return HTML are tested either<a id="_idIndexMarker680"/> manually or with playback tools, like Selenium IDE, on various browsers. Playback tools record all user actions<a id="_idIndexMarker681"/> performed on an actual browser and generate code that repeats the same action sequences with the help of browser drivers.</p>
<p class="normal">However, the code generated by playback tools is too sensitive to the DOM structure of each page, so most of the tests must be replaced after each relevant change in the user interface.</p>
<p class="normal">Therefore, the code of important and stable UI tests is better created manually in a way that is more robust to DOM changes. </p>
<p class="normal">For this purpose, the Selenium toolset contains the <code class="inlineCode">Selenium.WebDriver</code> NuGet package and a driver for each browser that you would like to adopt, such as, for instance, the <code class="inlineCode">Selenium.WebDriver.ChromeDriver</code> NuGet package for the Chrome browser.</p>
<p class="normal">Manual tests based on Selenium WebDriver look like this:</p>
<pre class="programlisting code"><code class="hljs-code">using OpenQA.Selenium;
using OpenQA.Selenium.ChromeDriver;
public class MyUnitTestClass:IClassFixture&lt;HttpClientFixture&gt;
{
    [Fact]
    public void MyTest()
    {
        Using (IWebDriver driver = new ChromeDriver())
        {
            driver.Navigate().GoToUrl("https://localhost:5001/mypage");
            //use driver to interact with the loaded page here
            ...
            var title = driver.Title;
           Assert().Equal("My Application – My Page", title);
           ...
	   var submitButton =
		driver.FindElement(By.ClassName("confirm-changes"));
 	   submitButton.Clikck();
 	   ...
       }
       
    }
}
</code></pre>
<p class="normal">Once the page to test has been loaded, <code class="inlineCode">driver</code> is used to explore the page content and to interact with page elements, like buttons, links, and input fields. As shown in the preceding code, the syntax for <a id="_idIndexMarker682"/>interacting with the browser is quite simple and intuitive. <code class="inlineCode">driver.FindElement</code> can find <a id="_idIndexMarker683"/>elements by CSS class name, by ID, and also through generic CSS selectors.</p>
<p class="normal">Adding CSS classes that characterize their role with HTML elements is a good technique for building robust UI tests.</p>
<p class="normal">The next subsection explains how to test an application that runs in a controlled environment.</p>
<h2 class="heading-2" id="_idParaDest-195">Testing a controlled application</h2>
<p class="normal">In this case, we create an ASP.NET Core server <a id="_idIndexMarker684"/>within the test application and test it with an <code class="inlineCode">HttpClient</code> instance. The <code class="inlineCode">Microsoft.AspNetCore.Mvc.Testing</code> NuGet package contains all that we need to create both an HTTP client and the server running the application.</p>
<p class="normal"><code class="inlineCode">Microsoft.AspNetCore.Mvc.Testing</code> contains a fixture class that does the job of launching a local web server and furnishing a client to interact with it. The predefined fixture class is <code class="inlineCode">WebApplicationFactory&lt;T&gt;</code>. The generic <code class="inlineCode">T</code> argument must be instantiated with the <code class="inlineCode">Program</code> class of your web project, that is, with an entry point for the web application.</p>
<p class="normal">Tests look like the following class:</p>
<pre class="programlisting code"><code class="hljs-code">public class MynitTest
    : IClassFixture&lt;WebApplicationFactory&lt;MyProject.Program&gt;&gt;
{
    private readonly
        WebApplicationFactory&lt;MyProject.Program&gt; _factory;
    public UnitTest1 (WebApplicationFactory&lt;MyProject.Program&gt; factory)
    {
        _factory = factory;
    }
    [Theory]
    [InlineData("/")]
    [InlineData("/Index")]
    [InlineData("/About")]
    ....
    public async Task MustReturnOK(string url)
    {
        var client = _factory.CreateClient();
        // here both client and server are ready
var response = await client.GetAsync(url);
        //get the response
        response.EnsureSuccessStatusCode();
        // verify we got a success return code.
    }
    ...
    ---
}
</code></pre>
<p class="normal">The <code class="inlineCode">Program</code> class must exist and<a id="_idIndexMarker685"/> must be defined as public. Otherwise, <code class="inlineCode">WebApplicationFactory</code> has no entry point for starting the application. Therefore, if the code in <code class="inlineCode">Program.cs</code> is not enclosed in a public class, as in the default project scaffolded by Visual Studio, you must turn the internal <code class="inlineCode">Program</code> class automatically generated by the C# compile into a public class. This is easily achieved by adding the following code at the end of the <code class="inlineCode">Program.cs</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">public partial class Program { }
</code></pre>
<p class="normal">If you want to analyze the HTML of the returned pages, you must also reference <strong class="keyWord">Selenium</strong> NuGet packages, as shown in the previous subsection. We will see how to use them in the example in the next section.</p>
<p class="normal">The simplest way to cope with databases in this type of test is to replace them with in-memory databases that are faster and automatically cleared whenever the local server is shut down and restarted.</p>
<p class="normal">Unfortunately, in-memory databases are <a id="_idIndexMarker686"/>not 100% compatible with the actual database used, so some tests might fail. Therefore, at least some of the tests might require the actual database.</p>
<p class="normal">When performing tests with actual databases, we must also add all the required instructions to clear or recreate from scratch a standard database in the constructor of a custom fixture that inherits from <code class="inlineCode">WebApplicationFactory&lt;T&gt;</code>. Note that deleting all database data is not as easy as it might appear, owing to integrity constraints. You have various options, but none is the best for all cases:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Delete the whole database and recreate it using SQL scripts or Entity Framework Core migrations, which will be analyzed in <em class="chapterRef">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>. This always works, but it is slow and requires a database user with high privileges.</li>
<li class="numberedList">Enclose a test database in a Docker image and recreate a new container at each new test (Docker will be discussed in <em class="chapterRef">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>). This is faster than recreating a new database from scratch but still slow.</li>
<li class="numberedList">Disable the database constraints and then clear all tables in any order. This technique sometimes doesn’t work and requires a database user with high privileges.</li>
<li class="numberedList">Delete all data in the right order, thus without violating all database constraints. This is not difficult if you keep an ordered delete list of all tables while the database grows and you add tables to the database. This delete list is a useful resource that you may also use to fix issues in database update operations and to remove old entries during production database maintenance. Unfortunately, this method also fails in the rare case of circular dependencies, such as a table that has a foreign key referring to itself.</li>
</ol>
<p class="normal">I prefer method 4 and revert to method 3 only in the rare case of difficulties due to circular dependencies.</p>
<h2 class="heading-2" id="_idParaDest-196">Recording tests with Selenium IDE</h2>
<p class="normal">The Selenium toolset contains browser extensions for recording and replaying browser tests. These are called Selenium IDE. You can <a id="_idIndexMarker687"/>download the extensions for Chrome and Firefox from <a href="https://www.selenium.dev/selenium-ide/">https://www.selenium.dev/selenium-ide/</a>, while the<a id="_idIndexMarker688"/> extension for Microsoft Edge is available from <a href="https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp">https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp</a>.</p>
<p class="normal">In Chrome, once installed, Selenium IDE can be run by clicking the extensions icon and then selecting the Selenium extension from the menu that appears, as shown in the screenshot below:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_09_03.png"/></figure>
<p class="packt_figref">Figure 9.3: Running Selenium IDE</p>
<p class="normal">You are prompted for the action you would like to perform, whether to create a new project, access an existing project, etc.</p>
<p class="normal">When you create a new project, you are prompted for the project name. At this point, Selenium IDE opens, and you can insert the application URL.</p>
<p class="normal">New tests can be created by clicking the plus button next to the tests list.</p>
<p class="normal">In order to record a test, select the test name and then click the record icon. A new browser window will open with the application URL. From this point, every action you perform on the application and its results will be recorded.</p>
<p class="normal">You can make assertions on the page content by right-clicking on a page element and selecting the appropriate action from<a id="_idIndexMarker689"/> the <strong class="screenText">Selenium</strong> <strong class="screenText">IDE &gt; Assert</strong> submenu. For instance, if you select the <strong class="screenText">Selenium IDE &gt; Assert &gt; Text</strong> command on a text element, the text value will be stored. When the test is executed, the content of the same text element will be compared with the previously stored value, and the test will fail if the two values are different.</p>
<p class="normal">Once all desired actions and assertions have been performed, return to the Selenium IDE window, click the stop recording button, and save the project.</p>
<p class="normal">Selenium IDE offers the option to run either a selected test or all tests.</p>
<h1 class="heading-1" id="_idParaDest-197">Summary</h1>
<p class="normal">In this chapter, we explained why it is worth automating software tests, and then we focused on the importance of unit tests. We also listed the various types of tests and their main features, focusing mainly on unit tests and functional tests. We analyzed the advantages of <strong class="keyWord">TDD</strong> and how to use it in practice. With this knowledge, you should be able to produce software that is both reliable and easy to modify.</p>
<p class="normal">Then, this chapter analyzed when it is worth automating some or all functional tests and described how to automate them in <code class="inlineCode">ASP.NET </code>Core applications.</p>
<p class="normal">Finally, we analyzed the main test tools available for .NET projects, focusing on xUnit, <code class="inlineCode">Moq</code>, <code class="inlineCode">Microsoft.AspNetCore.Mvc.Testing</code>, and <em class="italic">Selenium</em>, and showed how to use them in practice with the help of the book’s use case.</p>
<p class="normal"><em class="chapterRef">Chapter 21</em>, <em class="italic">Case Study</em>, applies all the test concepts described in this chapter to the book’s case study.</p>
<h1 class="heading-1" id="_idParaDest-198">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Why is it worth automating unit tests?</li>
<li class="numberedList">What is the main reason why TDD is able to discover most bugs immediately?</li>
<li class="numberedList">What is the difference between the <code class="inlineCode">[Theory]</code> and <code class="inlineCode">[Fact]</code> attributes of xUnit?</li>
<li class="numberedList">Which xUnit static class is used in test assertions?</li>
<li class="numberedList">Which methods allow the definition of the <code class="inlineCode">Moq</code> mocked dependencies?</li>
<li class="numberedList">Is it possible to mock <code class="inlineCode">async</code> methods with <code class="inlineCode">Moq</code>? If so, how?</li>
<li class="numberedList">Is it always worth automating UI functional tests in the case of quick CI/CD cycles?</li>
<li class="numberedList">What is the disadvantage of subcutaneous tests for ASP.NET Core applications?</li>
<li class="numberedList">What is the suggested technique for writing code-driven ASP.NET Core functional tests?</li>
<li class="numberedList">What is the suggested way of inspecting the HTML returned by a server?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-199">Further reading</h1>
<ul>
<li class="bulletList">While the documentation on xUnit included in this chapter is quite complete, it doesn’t include a few configuration options offered by xUnit. The full xUnit documentation is available at <a href="https://xunit.net/">https://xunit.net/</a>. Documentation for MSTest and NUnit can be found at <a href="https://github.com/microsoft/testfx">https://github.com/microsoft/testfx</a> and <a href="https://docs.nunit.org/">https://docs.nunit.org/</a>, respectively.</li>
<li class="bulletList">For more information on BDD and SpecFlow, refer to the Cucumber official website at <a href="https://cucumber.io/">https://cucumber.io/</a> and to the SpecFlow documentation at <a href="https://docs.specflow.org/">https://docs.specflow.org/</a>.</li>
<li class="bulletList">The full Moq documentation is available at <a href="https://github.com/moq/moq4/wiki/Quickstart">https://github.com/moq/moq4/wiki/Quickstart</a>.</li>
<li class="bulletList">Here are some links to performance test frameworks for web applications:<ul>
<li class="bulletList"><a href="https://jmeter.apache.org/">https://jmeter.apache.org/ (free and open source)</a></li>
<li class="bulletList"><a href="https://www.neotys.com/neoload/overview">https://www.neotys.com/neoload/overview</a></li>
<li class="bulletList"><a href="https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview">https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview</a></li>
</ul>
</li>
<li class="bulletList"><a href="https://www.microfocus.com/en-us/products/silk-performer/overview">https://www.microfocus.com/en-us/products/silk-performer/overview</a></li>
<li class="bulletList">More details on the <code class="inlineCode">Microsoft.AspNetCore.Mvc.Testing NuGet</code> package can be found in the official documentation at <a href="https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests">https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests</a>.</li>
<li class="bulletList">More information on Selenium IDE can be found on the official website: <a href="https://www.selenium.dev/selenium-ide/">https://www.selenium.dev/selenium-ide/</a>.</li>
<li class="bulletList">More information on Selenium WebDriver can be found on the official website: <a href="https://www.selenium.dev/documentation/webdriver/">https://www.selenium.dev/documentation/webdriver/</a>.</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>