<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor118"/>7</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor119"/>Reasoning about Expressions</h1>
			<p>So far, we’ve looked at the powerful metadata that is captured and how we can access it using reflection. We’ve also looked at how we can leverage this same metadata and generate code on the fly <span class="No-Break">at runtime.</span></p>
			<p>Using reflection and generating code as techniques in metaprogramming are extremely powerful, but they’re not applicable to all scenarios. It can also be very involved and produce hard-to-read and maybe even hard-to-maintain code going deep with reflection and <span class="No-Break">proxy generation.</span></p>
			<p>C# expressions can, for a lot of scenarios, represent a better approach or an additional approach for specific scenarios for doing runtime discovery and extraction <span class="No-Break">of metadata.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>What <span class="No-Break">are expressions?</span></li>
				<li>Traversing an <span class="No-Break">expression tree</span></li>
				<li>Using expressions as descriptors of members <span class="No-Break">on types</span></li>
			</ul>
			<p>From this chapter, you should understand what expressions are and how you can leverage them as a technique to reason about the running code <span class="No-Break">at runtime.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor120"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7</a>), and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Both the <strong class="source-in ine">GetMemberExpression()</strong> and <strong class="source-in ine">GetPropertyInfo()</strong> methods can be found in the <strong class="source-in ine">ExpressionExtensions.cs</strong> file in <strong class="source-in ine">Fundamentals</strong> in the <span class="No-Break">GitHub repository.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor121"/>What are expressions?</h1>
			<p><strong class="bo d">C# 3.0</strong> was introduced<a id="_idIndexMarker250"/> in <a id="_idIndexMarker251"/>late 2007, and its killer feature was something <a id="_idIndexMarker252"/>called<strong class="bo d"> Language-Integrated Query</strong> (<strong class="bo d">LINQ</strong>). With the underlying API model and combination of new capabilities in C#, it introduced a programming paradigm that bridges into the more functional programming space. The fluent interfaces and its use of lambdas can feel foreign if you’re used to more <span class="No-Break">object-oriented approaches.</span></p>
			<p>What it brought to the table was a way of expressing queries for data in a more natural native C# way. Not only does it do this for your in-memory collections, but also for any other data source, such as a database. It basically gave developers a uniform way of expressing queries, filters, <span class="No-Break">and projections.</span></p>
			<p>It did this by recognizing that a query operation consists of the following three <span class="No-Break">distinct</span><span class="No-Break"><a id="_idIndexMarker253"/></span><span class="No-Break"> parts:</span></p>
			<ul>
				<li>The <span class="No-Break">data source</span></li>
				<li>The <span class="No-Break">query expression</span></li>
				<li>Executing <span class="No-Break">the query</span></li>
			</ul>
			<p>Let’s look at an example without LINQ and compare it to how you could do the same with LINQ in a more <span class="No-Break">expressive way:</span></p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var filtered = new List&lt;int&gt;();
foreach (var item in items)
{
    if( item &gt;= 37 )
    {
        filtered.Add(item);
    }
}
Console.WriteLine(string.Join(',', filtered));</pre>
			<p>Running this would print out <strong class="source-in ine">42, 84, 37</strong>, as expected. The challenge with something like this is that it is very verbose and coupled to the data source and gives no room <span class="No-Break">for optimization.</span></p>
			<p>With LINQ and the recognition of the three distinct parts mentioned earlier that make up a query, there is a<a id="_idIndexMarker254"/> concept of <strong class="bo d">deferred execution</strong>. The actual execution of the query does not happen until you start enumerating it. That means you can build on the query while its final execution won’t occur until we really need the data. The execution is performed by the query provider, which could be the default in-memory one or <a id="_idIndexMarker255"/>something that represents a data source such as <span class="No-Break">a database.</span></p>
			<p>Representing the previous sample with LINQ is much <span class="No-Break">more expressive:</span></p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var selectedItems =
    from i in items
    where i &gt;= 37
    select i;
Console.WriteLine(string.Join(',', selectedItems));</pre>
			<p>The code becomes much more readable, but what happens behind the scenes is that it also becomes much more flexible in how it runs and makes it possible to optimize the execution as it sees fit for the data source the query is <span class="No-Break">running against.</span></p>
			<p>LINQ is a language feature of C#, and it can’t work without support from the .NET class libraries and the .NET runtime. This is where expressions <span class="No-Break">come in.</span></p>
			<p>As part of the base class libraries that were released at the same time, there was a new namespace called <strong class="source-in ine">System.Linq</strong> and another within it called <strong class="source-in ine">System.Linq.Expressions</strong>. This is where the <em class="ita ic">magic </em><span class="No-Break"><em class="ita ic">sauce</em></span><span class="No-Break"> lies.</span></p>
			<p>The C# compiler translates the native LINQ code using another feature that was introduced in C# 3.0 called extension methods. Extension methods are just static methods that look like they’re members of the actual type they extend, they can be used to form a fluent interface that can chain <span class="No-Break">method calls.</span></p>
			<p>Taking the previous LINQ code, we can express it using expressions and the extension methods that are found in the <span class="No-Break"><strong class="source-in ine">System.Linq</strong></span><span class="No-Break"> namespace:</span></p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var selectedItemsExpressions = items
    .Where(i =&gt; i &gt;= 37)
    .Select(i =&gt; i);
Console.WriteLine(string.Join(',',
  selectedItemsExpressions));</pre>
			<p>All three<a id="_idIndexMarker256"/> approaches discussed so far do the same thing and print out the same result. The biggest difference <span class="No-Break">is readability.</span></p>
			<p>Since our data source is just an in-memory array, the extension methods will reflect that and you’ll notice the signature of the <strong class="source-in ine">.Where()</strong> method <span class="No-Break">it uses:</span></p>
			<pre class="source-code">
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this
  IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt;
    predicate);</pre>
			<p>The first parameter is the source it extends, <strong class="source-in ine">IEnumerable&lt;TSource&gt;</strong>, and the second parameter is <strong class="source-in ine">Func&lt;int, bool&gt;</strong>. This means that you’re giving it a callback that will be called to decide whether or not the specific value, while it iterates through them, should be included <span class="No-Break">or not.</span></p>
			<p>This doesn’t really <a id="_idIndexMarker257"/>bring out the topic of this chapter. Let’s change it up a little to bring out the <span class="No-Break">real<a id="_idTextAnchor122"/> magic.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor123"/>Expression</h2>
			<p>For LINQ to work<a id="_idIndexMarker258"/> as intended with regard to different data sources and deferred execution, there is an interface called <strong class="source-in ine">IQueryable</strong>. The <strong class="source-in ine">IQueryable</strong> interface is something a data source can implement, and instead of having an imperative approach to just iterating the data source, it can now get the query represented as <span class="No-Break">an expression.</span></p>
			<p>An <strong class="source-in ine">IQueryable</strong> interface gives us different extension methods that expose <strong class="source-in ine">Expression</strong> as a type. Let’s change the array filtering up a little bit and introduce the concept of <span class="No-Break">a queryable:</span></p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var selectedItemsExpressions = items
    .AsQueryable()  // Making the array a queryable
    .Where(i =&gt; i &gt;= 37)
    .Select(i =&gt; i);
Console.WriteLine(string.Join(',', selectedItems
  Expressions));</pre>
			<p>The <strong class="source-in ine">.AsQueryable()</strong> array changes from an array, or more exactly, <strong class="source-in ine">IEnumerable&lt;int&gt;</strong> becomes <strong class="source-in ine">IQueryable&lt;int&gt;</strong>. That means we get access to a whole set of LINQ <a id="_idIndexMarker259"/>extension methods that are <span class="No-Break">extending </span><span class="No-Break"><strong class="source-in ine">IQueryable&lt;&gt;</strong></span><span class="No-Break">.</span></p>
			<p>If you look closer at the <strong class="source-in ine">.Where()</strong> method, you’ll notice that one of the extension methods now has the <span class="No-Break">following signature:</span></p>
			<pre class="source-code">
public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this
  IQueryable&lt;TSource&gt; source, Expression&lt;Func&lt;TSource,
    bool&gt;&gt; predicate);</pre>
			<p>The first parameter is the source it extends, and the second parameter is <strong class="source-in ine">Expression&lt;Func&lt;TSource, bool&gt;&gt;</strong>. This is the most significant part. The C# compiler recognizes anything that is an expression type, and instead of just creating a callback that gets called, it expands it into <span class="No-Break">an expression.</span></p>
			<p>In order for us to investigate what the compiler does, we can take the <strong class="source-in ine">where</strong> clause and separate it into its own line of code, enabling us to set a breakpoint in the debugger and look at what is <span class="No-Break">going on:</span></p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
// Extracted expression
Expression&lt;Func&lt;int, bool&gt;&gt; filter = (i) =&gt; i &gt;= 37;
var selectedItemsExpressions = items
    .AsQueryable()
    .Where(filter)
    .Select(i =&gt; i);
Console.WriteLine(string.Join(',', selectedItems
  Expressions));</pre>
			<p>With the expression extracted into its own line of code, we can easily see what the compiler generates for us. By setting a breakpoint after the <strong class="source-in ine">filter</strong> variable construction <a id="_idIndexMarker260"/>and looking at the <strong class="source-in ine">filter</strong> variable in the watch view of your debugger, you can see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B19418_07_1.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The filter expression</p>
			<p>As you can see, it is no longer just a callback. It has captured all the details of what you are expressing. Notice the <strong class="source-in ine">Body</strong> property. This is the inner expression. The type, in our case, is translated into <strong class="source-in ine">LogicalBinaryExpression</strong>, which holds three things <span class="No-Break">of importance:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-in ine">Left</strong></span></li>
				<li><span class="No-Break"><strong class="source-in ine">NodeType</strong></span></li>
				<li><span class="No-Break"><strong class="source-in ine">Right</strong></span></li>
			</ul>
			<p>The <strong class="source-in ine">Left</strong> property represents what is on the left-hand side of the expression, and the <strong class="source-in ine">Right</strong> property represents what is on the right-hand side. And in the middle of this, the operator, <strong class="source-in ine">NodeType</strong>, tells us the action it will <span class="No-Break">be performing.</span></p>
			<p>For both the <strong class="source-in ine">Left</strong> and <strong class="source-in ine">Right</strong> properties, you also see that their type is <strong class="source-in ine">Expression</strong>. The <strong class="source-in ine">Left</strong> expression, in this case, is <strong class="source-in ine">PrimitiveParameterExpression</strong>, representing the parameter, the value that will be passed if we are iterating or calling the expression. While the <strong class="source-in ine">Right</strong> expression<a id="_idIndexMarker261"/> becomes <strong class="source-in ine">ConstantExpression</strong>, holding the concrete value, the <strong class="source-in ine">NodeType</strong> property is set to <strong class="source-in ine">GreaterThanOrEqual</strong>, which is what was expres<a id="_idTextAnchor124"/>sed <span class="No-Break">by </span><span class="No-Break"><strong class="source-in ine">&gt;=</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor125"/>Lambda expression</h2>
			<p>When you <a id="_idIndexMarker262"/>use the <strong class="source-in ine">=&gt;</strong> notation, you form what is known as a <strong class="bo d">lambda expression</strong>. Lambda expressions are anonymous functions. Lambda expressions are divided into the following <span class="No-Break">two types:</span></p>
			<ul>
				<li><span class="No-Break">Expression lambdas</span></li>
				<li><span class="No-Break">Statement lambdas</span></li>
			</ul>
			<p>Expression lambdas are characterized by having the right side express an expression. An expression lambda returns the result of the expression and looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
(input parameters) =&gt; expression</pre>
			<p>This is the type of expression used in the expression you <span class="No-Break">saw earlier:</span></p>
			<pre class="source-code">
Expression&lt;Func&lt;int, bool&gt;&gt; filter = (i) =&gt; i &gt;= 37;</pre>
			<p>Its signature is defined by <strong class="source-in ine">Func&lt;int, bool&gt;</strong>, where the first generic argument is the type of the parameter used, and the last generic argument is the return type. You can have <span class="No-Break">multiple parameters.</span></p>
			<p>Statement lambdas are characterized by it being enclosed in braces, <strong class="source-in ine">{}</strong>, and typically having <span class="No-Break">multiple statements:</span></p>
			<pre class="source-code">
(input parameters) =&gt; { &lt;sequence of statements&gt; }</pre>
			<p>This could be something like the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
(string name) =&gt;
{
    var message = $"Hello {name}";
    Console.WriteLIne(message);
}</pre>
			<p>With a statement, a lambda is typically something that is not possible to reason about, as it will not form an expression tree but rather have multiple statements <span class="No-Break">within it.</span></p>
			<p>Lambdas represent <a id="_idIndexMarker263"/>a very powerful construct that can be used to gain insight into what is going on. It’s also a great way to help understand how expressions work and can <span class="No-Break">be <a id="_idTextAnchor126"/>constructed.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor127"/>Traversing an expression tree</h1>
			<p>An <strong class="source-in ine">Expression</strong> is a simple<a id="_idIndexMarker264"/> construct that represents a node in a tree. The expression has a node type, and the implementation decides what the node type expresses and means. This forms a tree that can be recursively traversed and <span class="No-Break">reasoned about.</span></p>
			<p>For lambda expressions, it means it has a body that consists of an expression that is of a specific type; this type could <a id="_idIndexMarker265"/>be a <strong class="bo d">Binary Expression</strong> that holds a left and a right and the node itself representing the operand (equals, not equals, and <span class="No-Break">so forth):</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B19418_07_2.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Binary expression</p>
			<p>Taking the example<a id="_idIndexMarker266"/> of <span class="No-Break">the filter:</span></p>
			<pre class="source-code">
Expression&lt;Func&lt;int, bool&gt;&gt; filter = (i) =&gt; i &gt;= 37;</pre>
			<p>Visually it looks like <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B19418_07_3.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 - A parameter larger than the constant expression</p>
			<p>The operand is <strong class="source-in ine">greater than or equal</strong>, the left-hand side accesses the parameter passed into it, and the right-hand side holds the constant value <span class="No-Break">of </span><span class="No-Break"><strong class="source-in ine">37</strong></span><span class="No-Break">.</span></p>
			<p>Expressions can also represent accessing a member on the type being passed in as <span class="No-Break">a parameter.</span></p>
			<p>Let’s say we have an object called <strong class="source-in ine">Employee</strong> that looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public record Employee(string FirstName, string LastName);</pre>
			<p>A filter accessing the first name and looking for a person called <strong class="source-in ine">Jane</strong> would look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Expression&lt;Func&lt;Employee, bool&gt;&gt; employeeFilter =
  (employee) =&gt; employee.FirstName == "Jane";</pre>
			<p>Dissecting the<a id="_idIndexMarker267"/> expression tree, we will see that it now changes into <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B19418_07_4.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Member access equal constant expression</p>
			<p>Since we’re now accessing a member, the left-hand expression is now <strong class="source-in ine">MemberAccessExpression</strong>. <strong class="source-in ine">MemberAccessExpression</strong> has an expression on it that represents the source that holds the member, in our case, a parameter being passed in. To get the actual member, <strong class="source-in ine">MemberAccessExpression</strong> holds a property called <strong class="source-in ine">Member</strong>. Since the member we’re accessing is a property, it will be the <span class="No-Break">actual </span><span class="No-Break"><strong class="source-in ine">PropertyInfo</strong></span><span class="No-Break">.</span></p>
			<p>Expressions are not just used for filters; they can represent other operations as well. We could have an expression that represents adding values, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Expression&lt;Func&lt;int, int&gt;&gt; addExpression = (i) =&gt; i + 42;</pre>
			<p>The expression itself now returns <strong class="source-in ine">int</strong> instead of <strong class="source-in ine">bool</strong>, takes the parameter passed to it, and <span class="No-Break">adds </span><span class="No-Break"><strong class="source-in ine">42</strong></span><span class="No-Break">.</span></p>
			<p>The expression tree <a id="_idIndexMarker268"/>is shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B19418_07_5.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Parameter adding constant expression</p>
			<p>As you can see, the node type is <strong class="source-in ine">Add</strong>. This is just one of many types of expressions you can use. You can create really complex structures and represent in an abstract way the core functionality of what the .NET runtime itself is capable of running. We will see more of the different types in <a href="B19418_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="ita ic">Chapter 8</em></span></a>, <em class="ita ic">Building and </em><span class="No-Break"><em class="ita ic">Executing<a id="_idTextAnchor128"/> Expressions</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor129"/>Using expressions as descriptors of members on types</h1>
			<p>Expressions<a id="_idIndexMarker269"/> represent a way of describing intent in a declarative fashion. Rather than with an imperative approach where we tell the computer exactly what to do, we can declaratively describe it and let the code decide the best way to <span class="No-Break">approach it.</span></p>
			<p>As we saw earlier with the filtering of numbers, the imperative approach using <strong class="source-in ine">foreach</strong> does not open for any other execution than what we have put in. While with the LINQ and expression approach, we describe what we want, and the execution is deferred, how it is handled and executed, we don’t know – but the results are <span class="No-Break">the same.</span></p>
			<p>This type of declarative thinking can be a very powerful way to describe what you want for your system and can also make your code more readable and easier for others to reason about. Imperative code requires you to thoroughly read and understand what the code does, while a declarative approach describes the desired outcome and is much easier to <span class="No-Break">reason about.</span></p>
			<p>Obviously, a declarative model is limited in its capabilities, while an imperative approach is fully flexible, and you can leverage the full power of the C# language. Combining the two methods is best if you can declaratively describe things using something such as a fluent interface and take full advantage of the C# extension methods to hold methods that represent the <span class="No-Break">imperative actions.</span></p>
			<p>Let’s take a look at a library called <strong class="source-in ine">FluentValidation</strong> (<a href="https://docs.fluentvalidation.net/en/latest/">https://docs.fluentvalidation.net/en/latest/</a>). It is a library that lets you fluently write validation of input. It takes full advantage of expressions and gives you a declarative model that is extensible using extension methods for describing <span class="No-Break">your intent.</span></p>
			<p>The following is the sample from <span class="No-Break">their documentation:</span></p>
			<pre class="source-code">
public class CustomerValidator : AbstractValidator&lt;Customer&gt;
{
  public CustomerValidator()
  {
    RuleFor(x =&gt; x.Surname).NotEmpty();
    RuleFor(x =&gt; x.Forename).NotEmpty().WithMessage("Please
      specify a first name");
    RuleFor(x =&gt; x.Discount).NotEqual(0).When(x =&gt;
      x.HasDiscount);
    RuleFor(x =&gt; x.Address).Length(20, 250);
    RuleFor(x =&gt; x.Postcode).Must(
      BeAValidPostcode).WithMessage("Please specify a
      valid postcode");
  }
  private bool BeAValidPostcode(string postcode)
  {
    // custom postcode validating logic goes here
  }
}</pre>
			<p>The validator<a id="_idIndexMarker270"/> inherits from a base type called <strong class="source-in ine">AbstractValidator&lt;&gt;</strong>, and on this type, there is a method called <strong class="source-in ine">RuleFor()</strong>. This method is the starting point for describing rules for properties on the type passed in as a generic argument to <strong class="source-in ine">AbstractValidator&lt;&gt;</strong>. The <strong class="source-in ine">RuleFor()</strong> signature looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public IRuleBuilderInitial&lt;T, TProperty&gt;
  RuleFor&lt;TProperty&gt;(Expression&lt;Func&lt;T, TProperty&gt;&gt;
    expression);</pre>
			<p>As you can see, the parameter for <strong class="source-in ine">RuleFor()</strong> is an expression. The expected expression is one that takes the type that was passed to <strong class="source-in ine">AbstractValidator&lt;&gt;</strong> as a parameter and returns any type. <strong class="source-in ine">TProperty</strong> will automatically be inferred by the C# compiler from <span class="No-Break">the expression.</span></p>
			<p><strong class="source-in ine">FluentValidation</strong> uses this expression to know what property you’re validating by inspecting <span class="No-Break">the expression.</span></p>
			<p>In <strong class="source-in ine">Fundamentals</strong> part of the code for the book, you’ll find a class called <strong class="source-in ine">ExpressionExtensions</strong> that has helper extension methods for doing the same type of inspection that <span class="No-Break"><strong class="source-in ine">FluentValidation</strong></span><span class="No-Break"> does.</span></p>
			<p>Since expressions can describe all kinds of members and the code for finding the member it represents is the same, there is a method for getting the expression that represents <span class="No-Break">the member:</span></p>
			<pre class="source-code">
public static MemberExpression GetMemberExpression(this
  Expression expression)
{
    var lambda = expression as LambdaExpression;
    if (lambda?.Body is UnaryExpression)
    {
        var unaryExpression = lambda.Body as
          UnaryExpression;
        return (MemberExpression)unaryExpression!.Operand!;
    }
    return (MemberExpression)lambda?.Body!;
}</pre>
			<p>The code <a id="_idIndexMarker271"/>assumes that the incoming expression is <strong class="source-in ine">LambdaExpression</strong> and then checks whether this is a <strong class="source-in ine">UnaryExpression</strong> that holds the member. If it is not <strong class="source-in ine">UnaryExpression</strong>, we assume it <span class="No-Break">is </span><span class="No-Break"><strong class="source-in ine">MemberExpression</strong></span><span class="No-Break">.</span></p>
			<p>If it is not <strong class="source-in ine">MemberExpression</strong>, this will cause an invalid cast exception. You might want to consider checking types and throw a more <span class="No-Break">specific exception.</span></p>
			<p>The reason for the check for <strong class="source-in ine">UnaryExpression</strong> is that for expressions that have the type of the value as <strong class="source-in ine">object</strong> and the actual value is a type that needs converting, casting, or unboxing for it to become the <strong class="source-in ine">object</strong> type, the compiler can decide to put in a unary expression that performs <span class="No-Break">this action.</span></p>
			<p>Once you have the member expression, we can get the actual member as the <strong class="source-in ine">System.Reflection</strong> type that represents a <span class="No-Break">property, </span><span class="No-Break"><strong class="source-in ine">PropertyInfo</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public static PropertyInfo GetPropertyInfo(this Expression
  expression)
{
    var memberExpression = GetMemberExpression(expression);
    return (PropertyInfo)memberExpression.Member!;
}</pre>
			<p>The code calls <strong class="source-in ine">GetMemberExpression()</strong> and casts <strong class="source-in ine">Member</strong> to <strong class="source-in ine">PropertyInfo</strong>. If the member is not <strong class="source-in ine">PropertyInfo</strong>, this will throw an exception. You might want to check for correctness and throw a more <span class="No-Break">specific exception.</span></p>
			<p>With <strong class="source-in ine">PropertyInfo</strong> returned, you <a id="_idIndexMarker272"/>now have all the information you need about the described property, its name an<a id="_idTextAnchor130"/>d type, <span class="No-Break">and more.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor131"/>Summary</h1>
			<p>In this chapter, we learned about a valuable member of the .NET class libraries called expressions. Thanks to the symbiosis of the C# compiler and the runtime, you get another approach to reason about the <span class="No-Break">running code.</span></p>
			<p>Expressions represent a structured approach for representing, well, expressions. There is somewhat of a resemblance to an abstract syntax tree, which all code compilers produce when parsing code. Something we’ll get more familiar with in <a href="B19418_15.xhtml#_idTextAnchor250"><span class="No-Break"><em class="ita ic">Chapter 15</em></span></a>, <em class="ita ic">Roslyn </em><span class="No-Break"><em class="ita ic">Compiler Extensions</em></span><span class="No-Break">.</span></p>
			<p>As we’ve seen in this chapter, the type of expressions can be for just capturing information, but they can also be more powerful and capture operations that can <span class="No-Break">be executed.</span></p>
			<p>In the next chapter, we will dive deeper into expressions and see how you can build out expressions at runtime that you can then <span class="No-Break">execute dynamically.</span></p>
		</div>
	</body></html>