- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Exploring Navigation and Routing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索导航和路由
- en: Routing and navigation are essential features in any modern web application.
    In a Blazor Web App, routing is the process that maps URLs to Razor components,
    allowing users to navigate between different views. Navigation refers to the actions
    and processes involved in moving from one route to another, whether through user
    interactions, programmatic commands, or other means. Blazor provides a flexible
    routing system that supports both static and interactive routing, depending on
    how you configure the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 路由和导航是任何现代Web应用程序的基本功能。在Blazor Web App中，路由是将URL映射到Razor组件的过程，使用户能够在不同的视图之间导航。导航指的是涉及从一个路由移动到另一个路由的动作和过程，无论是通过用户交互、程序性命令还是其他方式。Blazor提供了一个灵活的路由系统，支持静态和交互式路由，具体取决于如何配置应用程序。
- en: '**Static routing** occurs during static server-side rendering when prerendering
    is enabled. In this mode, the Blazor router, defined by the **Router** component
    in **Routes.razor** , performs routing based on the HTTP request path, mapping
    URLs directly to components. Conversely, when the Blazor router is set to an interactive
    render mode, it automatically transitions from static to **interactive routing**
    after the initial rendering on the server is completed. Interactive routing uses
    the document’s URL (the URL in the browser’s address bar) to determine which component
    to render dynamically, allowing an application to respond to user interactions
    and navigate without performing full HTTP requests. This approach enables dynamic
    content updates and seamless navigation within the application.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态路由**在启用预渲染的静态服务器端渲染期间发生。在此模式下，由**Routes.razor**中的**Router**组件定义的Blazor路由器根据HTTP请求路径执行路由，直接将URL映射到组件。相反，当Blazor路由器设置为交互式渲染模式时，在服务器上的初始渲染完成后，它会自动从静态路由转换为**交互式路由**。交互式路由使用文档的URL（浏览器地址栏中的URL）来确定要动态渲染哪个组件，允许应用程序响应用户交互并导航，而无需执行完整的HTTP请求。这种方法使得动态内容更新和应用内的无缝导航成为可能。'
- en: When comparing routing in Blazor to routing in ASP.NET Core, there are both
    similarities and key differences to consider. ASP.NET Core primarily uses controllers
    and actions for routing, where routes are typically defined in a centralized manner,
    often using attribute-based or conventional routing. In contrast, Blazor’s routing
    is component-based, directly mapping URLs to Razor components instead of controller
    actions. This component-based approach in Blazor allows a more modular and encapsulated
    routing experience, where each component can manage its own navigation logic.
    Additionally, Blazor supports navigation within a client-side browser, without
    requiring full-page reloads, which is a significant difference from traditional
    server-side routing in ASP.NET Core.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较Blazor中的路由与ASP.NET Core中的路由时，需要考虑相似之处和关键差异。ASP.NET Core主要使用控制器和操作进行路由，其中路由通常以集中化的方式定义，通常使用基于属性的或传统路由。相比之下，Blazor的路由是基于组件的，直接将URL映射到Razor组件而不是控制器操作。Blazor中的这种基于组件的方法允许更模块化和封装的路由体验，其中每个组件可以管理自己的导航逻辑。此外，Blazor支持客户端浏览器内的导航，无需完整页面刷新，这与ASP.NET
    Core中的传统服务器端路由有显著差异。
- en: In this chapter, we will cover aspects of routing and navigation in Blazor web
    apps using .NET 9. We will begin with enabling routes from multiple assemblies,
    essential for building modular applications and scenarios where you’ll leverage
    external NuGet packages. Then, we will explore parameterized routes, where you
    will learn to create dynamic and flexible URLs with route parameters. Then, we
    will discuss implementing unified **deep linking** for centralizing route definitions
    for easier management. We will also cover handling incorrect navigation requests
    and controlling navigation history to enhance the user experience. Near the end,
    we will explain how to execute asynchronous operations during navigation and cancel
    long-running tasks when users navigate away. Lastly, we will explore how to prevent
    unintentional data loss by prompting users about unsaved changes before navigating
    away from forms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用 .NET 9 在 Blazor 网络应用程序中路由和导航的各个方面。我们将从启用来自多个程序集的路由开始，这对于构建模块化应用程序和您将利用外部
    NuGet 包的场景至关重要。然后，我们将探讨参数化路由，您将学习如何使用路由参数创建动态和灵活的 URL。接着，我们将讨论实现统一的 **深度链接** 以集中管理路由定义。我们还将涵盖处理错误的导航请求和控制导航历史以增强用户体验。接近尾声时，我们将解释如何在导航期间执行异步操作，并在用户导航离开时取消长时间运行的任务。最后，我们将探讨如何在用户离开表单之前提示用户关于未保存的更改，以防止意外数据丢失。
- en: By the end of this chapter, you will understand how routing works in Blazor
    and how to implement various routing and navigation scenarios.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 Blazor 中的路由工作原理以及如何实现各种路由和导航场景。
- en: Routing and navigation are critical components that often impact entire application
    behavior. However, the recipes in this chapter are fully independent and don’t
    build on one another. This approach also means you can review and implement each
    recipe in isolation. Recipes begin with instructions on what working directory
    you should create and which sample files you need to execute the following task.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 路由和导航是影响整个应用程序行为的关键组件。然而，本章中的食谱完全独立，互不依赖。这种方法还意味着您可以单独审查和实现每个食谱。食谱开始于关于您应该创建哪个工作目录以及您需要执行以下任务所需的示例文件说明。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Enabling routes from multiple assemblies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用来自多个程序集的路由
- en: Working with parameterized routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与参数化路由一起工作
- en: Working with query parameters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与查询参数一起工作
- en: Implementing unified deep linking
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现统一的深度链接
- en: Handling incorrect navigation requests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误的导航请求
- en: Executing an asynchronous operation with navigation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航时执行异步操作
- en: Canceling a long-running task when users navigate away
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户导航离开时取消长时间运行的任务
- en: Controlling navigation history
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制导航历史
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before diving in, make sure that you have the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究之前，请确保您有以下条件：
- en: .NET 9 SDK installed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 .NET 9 SDK
- en: A modern IDE (that supports Blazor development)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 Blazor 开发的现代 IDE（Integrated Development Environment）
- en: A modern web browser (that supports WebAssembly)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 WebAssembly 的现代网络浏览器
- en: A Blazor project
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 项目
- en: We will build all recipes in a **BlazorCookbook.App** project, so all references
    will reflect that assembly. Make sure you adjust assembly references to match
    your project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 **BlazorCookbook.App** 项目中构建所有食谱，因此所有引用都将反映该程序集。请确保您调整程序集引用以匹配您的项目。
- en: 'You can find all the code written in this chapter and code samples on GitHub
    at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09)
    .'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章中编写的所有代码和代码示例：[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09)
    .
- en: Enabling routes from multiple assemblies
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用来自多个程序集的路由
- en: You might want to modularize your Blazor application by spreading routes across
    multiple assemblies. **Modularization** is the practice of breaking down an application
    into smaller, manageable, and independent modules, each responsible for a specific
    functionality. It’s an ideal development approach when working in big or distributed
    teams, as each team can deliver features independently. Modularization is also
    beneficial in larger applications, as you can encapsulate different features in
    separate assemblies. Blazor allows you to discover routable components from additional
    assemblies through the **Router** component’s API, for interactive routing, and
    the endpoint convention builder, for static route setups.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望通过在多个程序集中分散路由来模块化您的 Blazor 应用程序。**模块化**是将应用程序分解成更小、更易于管理和独立的模块的实践，每个模块负责特定的功能。当在大团队或分布式团队中工作时，这是一个理想的开发方法，因为每个团队可以独立交付功能。模块化对大型应用程序也有益，因为您可以将不同的功能封装在单独的程序集中。Blazor
    允许您通过 **Router** 组件的 API 发现来自额外程序集的可路由组件，用于交互式路由，以及用于静态路由设置的端点约定构建器。
- en: Let’s learn how to allow users to navigate to a component from an assembly different
    than our base project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何允许用户从不同于我们的基础项目的程序集中导航到组件。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we extend assemblies, where Blazor scans for routable components, copy
    the **BlazorCookbook.Library** project from the GitHub repository to your solution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们扩展程序集之前，Blazor 扫描可路由组件的位置，将 **BlazorCookbook.Library** 项目从 GitHub 仓库复制到您的解决方案中。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to allow Blazor to discover routes from different assemblies:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤允许 Blazor 从不同的程序集中发现路由：
- en: Navigate to the **BlazorCookbook.App** server-side project of your solution.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您解决方案中的 **BlazorCookbook.App** 服务器端项目。
- en: 'Open **BlazorCookbook.App.csproj** and add a reference to the **BlazorCookbook.Library**
    project:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **BlazorCookbook.App.csproj** 并添加对 **BlazorCookbook.Library** 项目的引用：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the **Program.cs** and locate a component mapping section. Use the **AddAdditionalAssemblies()**
    method to map routes from the **ExternalEventManager** assembly:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Program.cs** 并定位到组件映射部分。使用 **AddAdditionalAssemblies()** 方法映射来自 **ExternalEventManager**
    程序集的路由：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the **Routes** component and extend the array attached to the **AdditionalAssemblies**
    parameter with the **ExternalEventManager** assembly:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Routes** 组件，并将 **AdditionalAssemblies** 参数附加的数组扩展到包含 **ExternalEventManager**
    程序集：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we add all the configurations for routable component discoverability
    in the server-side project of the solution. In *step 2* , we find the **BlazorCookbook.App**
    project configuration file and reference the **BlazorCookbook.Library** project
    that you’ve copied from the GitHub repository. **BlazorCookbook.Library** contains
    an **ExternalEventManager** component, and we want our users to be able to navigate
    to it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在解决方案的服务器端项目中添加了所有可路由组件可发现性的配置。在 *第2步* 中，我们找到 **BlazorCookbook.App**
    项目的配置文件，并引用您从 GitHub 仓库复制的 **BlazorCookbook.Library** 项目。**BlazorCookbook.Library**
    包含一个 **ExternalEventManager** 组件，我们希望我们的用户能够导航到它。
- en: In *step 3* , we set up the discoverability of the static routing that might
    come from the **BlazorCookbook.Library** . We navigate to the **Program.cs** file
    of the **BlazorCookbook.App** project and locate where we build the endpoint convention
    of the application. The endpoint route builder starts from the **MapRazorComponents()**
    method call. At the end of the builder, we call the **AddAdditionalAssemblies()**
    method to map all the static routes from the **BlazorCookbook.App.Client** project.
    Now, we extend the additional assemblies’ array with the **ExternalEventManager**
    assembly. To make the registration type-safe, rather than a simple string, we
    use the **typeof()** method. The **typeof()** method in .NET allows us to obtain
    the **Type** object for a given type name, enabling reflection and metadata access
    at runtime. Additionally, it allows retrieval of the assembly containing the type,
    which solves our requirement perfectly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第3步* 中，我们设置了可能来自 **BlazorCookbook.Library** 的静态路由的可发现性。我们导航到 **BlazorCookbook.App**
    项目的 **Program.cs** 文件，并定位到构建应用程序端点约定的位置。端点路由构建器从 **MapRazorComponents()** 方法调用开始。在构建器末尾，我们调用
    **AddAdditionalAssemblies()** 方法来映射来自 **BlazorCookbook.App.Client** 项目的所有静态路由。现在，我们将
    **ExternalEventManager** 程序集扩展到额外的程序集数组中。为了使注册类型安全，而不是简单的字符串，我们使用 **typeof()**
    方法。.NET 中的 **typeof()** 方法允许我们获取给定类型名称的 **Type** 对象，从而在运行时启用反射和元数据访问。此外，它还允许检索包含类型的程序集，这完美地解决了我们的需求。
- en: In *step 4* , we navigate to the **Routes** component, still in the server-side
    project, to extend the discoverability of interactive routes. Here, we find our
    application **Router** configuration. By specifying assemblies with the **AppAssembly**
    and **AdditionalAssemblies** parameters, **Router** dynamically discovers and
    maps routes to components defined in those assemblies. In our case, again, we
    find that the client-side project assembly is already attached to the **AdditionalAssemblies**
    parameter of the **Router** . We extend the **AdditionalAssemblies** with reference
    to the **ExternalEventManager** assembly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们导航到服务器端项目中的 **Routes** 组件，以扩展交互式路由的可发现性。在这里，我们找到了我们的应用程序 **Router**
    配置。通过指定具有 **AppAssembly** 和 **AdditionalAssemblies** 参数的程序集，**Router** 可以动态发现并将路由映射到这些程序集中定义的组件。在我们的情况下，我们再次发现客户端项目程序集已经附加到
    **Router** 的 **AdditionalAssemblies** 参数。我们通过引用 **ExternalEventManager** 程序集扩展了
    **AdditionalAssemblies**。
- en: Working with parameterized routes
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用参数化路由进行工作
- en: In Blazor, parameterized routes allow you to pass parameters through the URL,
    making your application more dynamic and flexible. By leveraging route parameters,
    you can create components that respond to specific URL segments and render content
    based on those parameters. You can also use route parameters to persist the component
    state and allow users to bookmark it (which we explored at the beginning of [*Chapter
    5*](B22020_05.xhtml#_idTextAnchor165) ).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 中，参数化路由允许您通过 URL 传递参数，使您的应用程序更加动态和灵活。通过利用路由参数，您可以创建对特定 URL 段落做出响应的组件，并根据这些参数渲染内容。您还可以使用路由参数来持久化组件状态，并允许用户将其添加到书签（我们在
    [*第 5 章*](B22020_05.xhtml#_idTextAnchor165) 的开头进行了探索）。
- en: Let’s extend component routing with parametrized routes, enforcing parameter
    constraints.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过参数化路由扩展组件路由，强制参数约束。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before exploring parametrized routing, do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索参数化路由之前，执行以下操作：
- en: Create a **Chapter09** / **Recipe02** directory – this will be your working
    directory
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter09** / **Recipe02** 目录 – 这将是你的工作目录
- en: Copy **ExternalEventManager** from the **Chapter09** / **Recipe01** directory
    in the **BlazorCookbook.Library** project or the matching directory in the GitHub
    repository
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 **BlazorCookbook.Library** 项目中的 **Chapter09** / **Recipe01** 目录或 GitHub 仓库中的对应目录复制
    **ExternalEventManager**
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: 'Follow these steps to implement routes with parameters and intercept their
    values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现具有参数的路由并拦截它们的值：
- en: 'Navigate to the **ExternalEventManager** component and extend its routes with
    parametrized options:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **ExternalEventManager** 组件，并使用参数化选项扩展其路由：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In **ExternalEventManager** , initialize the **@code** block with two parameters
    – **EventId** and **Venue** :'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ExternalEventManager** 中，使用两个参数 – **EventId** 和 **Venue** 初始化 **@code**
    块：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Extend the **ExternalEventManager** markup by constructing a conditional display
    of the **Venue** and **EventId** values:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构建 **Venue** 和 **EventId** 值的条件显示来扩展 **ExternalEventManager** 标记：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we navigate to **ExternalEventManager** and extend the routing
    there. We add a new route that expects an **eventId** parameter by placing the
    parameter name in curly braces. We also declare that it must be of type **guid**
    . Blazor also supports route parameter constraints, which enhance your application’s
    security by automatically rejecting parameter values that don’t meet the specified
    constraints. Users providing incompatible values will receive a **404** error
    status code. While the route parameter name is case-insensitive, the constraint
    must follow the configured casing. As constraint support is limited, in the *See
    also* section for this recipe, there’s a link to all currently supported data
    types. In the last route we add, we declare the **venue?** optional route parameter
    by adding a **?** symbol at the end. Having an optional parameter means users
    can navigate to the page whether they provide the value of the **venue** or not,
    and we can adjust the display logic accordingly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们导航到 **ExternalEventManager** 并在那里扩展路由。我们添加了一个新的路由，该路由期望一个 **eventId**
    参数，通过将参数名称放在大括号中来放置参数名称。我们还声明它必须是 **guid** 类型。Blazor 还支持路由参数约束，这通过自动拒绝不符合指定约束的参数值来增强应用程序的安全性。提供不兼容值的用户将收到
    **404** 错误状态码。虽然路由参数名称不区分大小写，但约束必须遵循配置的大小写。由于约束支持有限，在食谱的 *另请参阅* 部分中有一个链接到所有当前支持的数据类型。在最后添加的路由中，我们通过在末尾添加一个
    **?** 符号来声明 **venue?** 可选路由参数。有一个可选参数意味着用户无论是否提供 **venue** 的值都可以导航到该页面，并且我们可以相应地调整显示逻辑。
- en: In *step 2* , we initialize a **@code** block in **ExternalEventManager** and
    declare two parameters, **EventId** and **Venue** , matching the names of the
    parameters added in the routes but following the Pascal case convention. That’s
    all it takes to enable Blazor to bind route parameters to the component’s properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们在**ExternalEventManager**中初始化一个**@code**块，并声明两个参数，**EventId**和**Venue**，与在路由中添加的参数名称匹配，但遵循Pascal大小写约定。这就是启用Blazor将路由参数绑定到组件属性所需的所有操作。
- en: In *step 3* , we construct a simple markup in **ExternalEventManager** . Below
    the existing **h1** element, we check whether **EventId** was set in the route
    and render its value in a paragraph. Lastly, we add another paragraph, below **EventId**
    , to display the current value of **Venue** or a message indicating that the user
    is viewing all venues (if **Venue** was not provided in the route). With this
    setup, you can test how different routes impact the component’s behavior.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 3**中，我们在**ExternalEventManager**中构建了一个简单的标记。在现有的**h1**元素下方，我们检查路由中是否设置了**EventId**，并在一个段落中渲染其值。最后，我们在**EventId**下方添加另一个段落，以显示**Venue**的当前值或表示用户正在查看所有场地的消息（如果路由中没有提供**Venue**）。通过这种设置，你可以测试不同的路由如何影响组件的行为。
- en: There’s more…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Alternatively, you can implement a *catch’em all* pattern to intercept route
    parameters. You can intercept an entire route segment into a string parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以实现一个“捕获所有”模式来拦截路由参数。你可以将整个路由段拦截为一个字符串参数：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We still declare the route parameter in curly braces and a matching **string**
    parameter in the **@code** block, similar to other routing cases. However, to
    indicate that we want to intercept an entire route segment, we prefix the parameter
    name with a ***** symbol. For example, when a user navigates to **/ch09r02/im/definitely/lost**
    , Blazor assigns **im/definitely/lost** to the **Path** value. You can still mix
    standard route parameters and constraints as long as the catch-all route segment
    parameter is the last in the route path.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在花括号中声明路由参数，并在**@code**块中声明一个匹配的**string**参数，类似于其他路由情况。然而，为了表示我们想要拦截整个路由段，我们在参数名称前加上一个*****符号。例如，当用户导航到**/ch09r02/im/definitely/lost**时，Blazor将**im/definitely/lost**分配给**Path**值。只要捕获所有路由段参数是路由路径中的最后一个，你仍然可以混合标准路由参数和约束。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'For the full list of data types that Blazor supports as route parameter constraints,
    check out the following Microsoft documentation link: [https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints](https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints)
    .'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Blazor支持作为路由参数约束的数据类型的完整列表，请参阅以下Microsoft文档链接：[https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints](https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints)。
- en: Working with query parameters
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用查询参数
- en: '**Query strings** and parameters are parts of a URL that allow you to pass
    optional data to a web application. They appear after the **?** symbol in a URL
    and consist of key-value pairs, separated by **=** and joined by **&** . The use
    of query parameters is useful for filtering data, pagination, and passing user-specific
    information without altering the URL structure significantly.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询字符串**和参数是URL的一部分，允许你向Web应用程序传递可选数据。它们出现在URL中的**?**符号之后，由**=**分隔的键值对组成，并由**&**连接。查询参数的使用对于过滤数据、分页以及在不显著改变URL结构的情况下传递用户特定信息非常有用。'
- en: Let’s enhance the routing by allowing the conditional passing of an event date
    that will be loaded dynamically.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过允许条件传递一个将被动态加载的事件日期来增强路由。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before exploring query parameters, do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索查询参数之前，请执行以下操作：
- en: Create a **Chapter09** / **Recipe03** directory – this will be your working
    directory
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter09** / **Recipe03**目录——这将是你的工作目录
- en: Copy **ExternalEventManager** from the *Working with parameterized routes* recipe
    or the **Chapter09** / **Recipe02** directory in the GitHub repository
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*使用参数化路由*配方或GitHub仓库中的**Chapter09** / **Recipe02**目录复制**ExternalEventManager**
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to intercept values from query parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明从查询参数中拦截值：
- en: 'Navigate to the **@code** block of the **ExternalEventManager** and introduce
    a **Date** parameter, but use a **SupplyParameterFromQuery** attribute to indicate
    that Blazor should intercept it from the query string:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **ExternalEventManager** 的 **@code** 块并引入一个 **Date** 参数，但使用 **SupplyParameterFromQuery**
    属性来指示 Blazor 应从查询字符串中拦截它：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the end of the **ExternalEventManager** markup, check whether **Date** is
    available and render another paragraph with the **Date** value:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ExternalEventManager** 标记的末尾，检查 **Date** 是否可用并渲染另一个包含 **Date** 值的段落：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to **ExternalEventManager** and declare a **Date**
    parameter. Instead of using the standard **Parameter** attribute, we leverage
    the **SupplyParameterFromQuery** variant, instructing Blazor to intercept parameters
    from the query string. There’s no need to manipulate routes; simply annotating
    the parameter with **SupplyParameterFromQuery** enables this functionality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们导航到 **ExternalEventManager** 并声明一个 **Date** 参数。我们不是使用标准的 **Parameter**
    属性，而是利用 **SupplyParameterFromQuery** 变体，指示 Blazor 拦截查询字符串中的参数。无需操作路由；只需使用 **SupplyParameterFromQuery**
    注释参数即可启用此功能。
- en: In *step 2* , we extend the **ExternalEventManager** markup. We check whether
    the **Date** value matches the default value of **DateTime** , which indicates
    that the parameter was not in the query string. If Blazor intercepts the **Date**
    parameter, we render a paragraph displaying its value. However, it’s important
    to note that the format of the date provided in the query string needs to match
    the culture settings of the application. By default, Blazor and .NET expect dates
    in the **MM-DD-YYYY** format, which is a default format in the **en-US** culture,
    reflecting the United States standard. If the date is provided in a different
    format, such as **DD-MM-YYYY** , it may not be parsed correctly unless the application’s
    culture is set appropriately. This can be adjusted either globally or within specific
    components by configuring the appropriate culture settings, ensuring that Blazor
    interprets the date in the desired format.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们扩展了 **ExternalEventManager** 标记。我们检查 **Date** 值是否与 **DateTime**
    的默认值匹配，这表示参数不在查询字符串中。如果 Blazor 拦截了 **Date** 参数，我们将渲染一个显示其值的段落。然而，需要注意的是，查询字符串中提供的日期格式需要与应用程序的文化设置相匹配。默认情况下，Blazor
    和 .NET 预期日期格式为 **MM-DD-YYYY**，这是 **en-US** 文化的默认格式，反映了美国标准。如果日期以不同的格式提供，例如 **DD-MM-YYYY**，则除非应用程序的文化设置适当，否则可能无法正确解析。这可以通过配置适当的文化设置来调整，无论是在全局范围内还是在特定组件中，以确保
    Blazor 以所需格式解释日期。
- en: There’s more…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'When your C# parameter name differs from the one provided in a query string,
    or when a parameter key is present multiple times in a query string and you need
    to intercept all values into an array, you must explicitly declare the **Name**
    property of the **SupplyParameterFromQuery** attribute:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 C# 参数名称与查询字符串中提供的不一致，或者当查询字符串中存在多个相同的参数键并且你需要将所有值拦截到一个数组中时，你必须显式声明 **SupplyParameterFromQuery**
    属性的 **Name** 属性：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this code, Blazor will intercept all the query parameters attached to the
    **seat** key and store them in the **Seats** array. You can then use that array
    to highlight or reserve seats with specific numbers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，Blazor 将拦截附加到 **seat** 键的所有查询参数并将它们存储在 **Seats** 数组中。然后你可以使用该数组来突出显示或预定具有特定编号的座位。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you’d like to learn more about globalization and culture settings in Blazor,
    check out the Microsoft Learn resource here: [https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization](https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization)
    .'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Blazor 中的全球化和文化设置的详细信息，请查看 Microsoft Learn 资源：[https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization](https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization)
    .
- en: Implementing unified deep linking
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现统一的深度链接
- en: '**Deep linking** in a web application is the ability to link directly to specific
    content or functionality. Implementing a unified deep linking service in your
    application centralizes route management, making the application more maintainable
    and scalable. It’s much easier to manage routing changes and avoid inconsistencies
    with all routes in one place.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中实现 **深度链接** 是直接链接到特定内容或功能的能力。在应用程序中实现统一的深度链接服务可以集中管理路由，使应用程序更易于维护和扩展。在一个地方管理路由更改并避免所有路由的不一致性要容易得多。
- en: Let’s move some routes to a static deep links container and update component
    routing to leverage these unified deep links.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些路由移动到静态深度链接容器中，并更新组件路由以利用这些统一的深度链接。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we encapsulate routes into a dedicated container, do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将路由封装到专用容器之前，请执行以下操作：
- en: Create a **Chapter03** / **Recipe04** directory – this will be your working
    directory
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**Chapter03**/**Recipe04**目录——这将是你的工作目录。
- en: Copy **ExternalEventManager** from the *Working with query parameters* recipe
    or the **Chapter09** / **Recipe03** directory in the GitHub repository
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“使用查询参数”配方或GitHub仓库中的**Chapter09**/**Recipe03**目录复制**ExternalEventManager**。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to introduce a container for routes in your application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在你的应用程序中引入路由容器：
- en: 'This time, create a **DeepLinks** static class, not a component:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，创建一个**DeepLinks**静态类，而不是一个组件：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the **DeepLinks** class, define three **const** routes that match the
    ones you have in **ExternalEventManager** :'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**DeepLinks**类内部，定义三个与**ExternalEventManager**中相同的**const**路由：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Navigate to **ExternalEventManager** , and replace the **@page** directives
    with the **@attribute** and **[Route]** attributes. Instead of providing the routes
    explicitly, leverage the **DeepLinks** constants:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**ExternalEventManager**，将**@page**指令替换为**@attribute**和**[Route]**属性。而不是显式提供路由，利用**DeepLinks**常量：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create a new **DeepLinks** class. **DeepLinks** is not a component
    but, rather, a **static** class, as it represents a fixed library that should
    be easily accessible in the entire application and won’t change through the application’s
    lifetime. In *step 2* , we declare three **const** routes for the **LandingPage**
    , **EventPage** , and **EventAtVenuePage** pages inside **DeepLinks** . These
    routes match the ones we already have explicitly declared in **ExternalEventManager**
    , so we copy those values here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们创建一个新的**DeepLinks**类。**DeepLinks**不是一个组件，而是一个**静态**类，因为它代表了一个在整个应用程序中应该易于访问的固定库，并且在整个应用程序的生命周期中不会改变。在*步骤2*中，我们在**DeepLinks**内部声明了三个**const**路由，用于**LandingPage**、**EventPage**和**EventAtVenuePage**页面。这些路由与我们在**ExternalEventManager**中明确声明的路由相匹配，因此我们在这里复制了那些值。
- en: In *step 3* , we navigate to **ExternalEventManager** and replace all **@page**
    directives with **@attribute** . With **@attribute** , we can leverage the **[Route]**
    attribute, which accepts a route as a parameter. We use the **DeepLinks** route
    repository to explicitly construct the same routing we had with **@page** directives.
    Even though we’ve encapsulated routes in **string** variables, Blazor still respects
    the constraints and optionality of the route parameters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们导航到**ExternalEventManager**并将所有**@page**指令替换为**@attribute**。使用**@attribute**，我们可以利用**[Route]**属性，该属性接受一个路由作为参数。我们使用**DeepLinks**路由仓库来显式构建与**@page**指令相同的路由。尽管我们已经将路由封装在**string**变量中，但Blazor仍然尊重路由参数的约束和可选性。
- en: You can leverage the **DeepLinks** class to safely set up navigation links in
    the application menu or anywhere else. By having routes as named objects, you
    avoid mistyping and reduce the risk of errors in your routing configuration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用**DeepLinks**类在应用程序菜单或任何其他地方安全地设置导航链接。通过将路由作为命名对象，你可以避免输入错误并减少路由配置中的错误风险。
- en: There’s more…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can extend the **DeepLinks** class with methods that allow you to generate
    stateful links and enable a more flexible and dynamic way to create URLs with
    route parameters. For instance, you can implement a method that accepts **EventId**
    and places it correctly in the **EventPage** route template:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过扩展**DeepLinks**类来添加方法，这些方法允许你生成有状态的链接，并启用一种更灵活和动态的方式来创建带有路由参数的URL。例如，你可以实现一个接受**EventId**并将其正确放置在**EventPage**路由模板中的方法：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When rendering a grid with events, you can leverage the **GetPage()** method
    and safely generate links to the event page with details. **GetPage()** accepts
    the **eventId** parameter and uses the **Replace()** extension method to insert
    parameters into the **EventPage** route template.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染包含事件的网格时，你可以利用**GetPage()**方法并安全地生成指向事件详情页面的链接。**GetPage()**接受**eventId**参数，并使用**Replace()**扩展方法将参数插入到**EventPage**路由模板中。
- en: Handling incorrect navigation requests
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不正确的导航请求
- en: Graceful handling of incorrect navigation requests is mandatory in modern web
    development to ensure a smooth and user-friendly experience. By preventing users
    from encountering confusing error messages or broken links, you make your application
    feel professional and reliable. While we have already covered unauthorized navigation
    in [*Chapter 8*](B22020_08.xhtml#_idTextAnchor273) , other error states might
    unexpectedly occur. How you handle broken links or mistyped URLs defines the quality
    of the user experience.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web开发中，优雅地处理错误的导航请求是强制性的，以确保流畅且用户友好的体验。通过防止用户遇到令人困惑的错误消息或损坏的链接，你让你的应用程序看起来更专业、更可靠。虽然我们已经在
    [*第8章*](B22020_08.xhtml#_idTextAnchor273) 中介绍了未经授权的导航，但其他错误状态可能会意外发生。你如何处理损坏的链接或输入错误的URL定义了用户体验的质量。
- en: Let’s implement a global, safe redirection to a friendly error page when users
    face unexpected navigation exceptions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个全局、安全的重定向，将用户重定向到一个友好的错误页面，当用户遇到意外的导航异常时。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before implementing the safe redirection, you must have something to redirect
    to. If you have been following along with the entire book or just scaffolded your
    project, you already have a routable **Error** component. Otherwise, you can get
    it from the **Modules** directory in the GitHub repository.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现安全重定向之前，你必须有一个可以重定向到的目标。如果你一直跟随整本书的内容，或者只是搭建了你的项目，你已经有了一个可路由的 **Error** 组件。否则，你可以从GitHub仓库中的
    **Modules** 目录中获取它。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to add a global safe redirection when user navigation fails:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤添加全局安全重定向，当用户导航失败时：
- en: Navigate to the **Program** file of the server-side project.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到服务器端项目的 **Program** 文件。
- en: 'After all the existing middleware registrations, use the **UseStatusCodePagesWithRedirects()**
    extension method of **WebApplication** to register an error redirection middleware
    and redirect users to the **/** **error** route:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有现有的中间件注册之后，使用 **WebApplication** 的 **UseStatusCodePagesWithRedirects()**
    扩展方法来注册一个错误重定向中间件，并将用户重定向到 **/** **error** 路由：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In Blazor apps, before the introduction of Blazor web apps, you would use the
    **NotFound** parameter of **Router** to handle users navigating to an unavailable
    route. Blazor web apps still support the **NotFound** parameter for backward compatibility,
    but leveraging the server-side middleware pipeline to resolve status codes provides
    much more flexibility.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor应用程序中，在Blazor Web应用程序引入之前，你会使用 **Router** 的 **NotFound** 参数来处理用户导航到不可用的路由。Blazor
    Web应用程序仍然支持 **NotFound** 参数以实现向后兼容性，但利用服务器端中间件管道来解析状态码提供了更大的灵活性。
- en: In *step 1* , we navigate to the **Program** file of the server-side project,
    where we configure the server-side middleware pipeline. In *step 2* , we locate
    where the existing middleware registrations end and use the **UseStatusCodePagesWithRedirects()**
    method to extend the middleware pipeline. With **UseStatusCodePagesWithRedirects()**
    , we define that whenever a server request results in an unhandled error status
    code, users get redirected to an **/error** page. With the **Error** component,
    we can customize the message, details, and next steps that our users see.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们导航到服务器端项目的 **Program** 文件，在那里我们配置服务器端中间件管道。在 *步骤 2* 中，我们找到现有中间件注册的结束位置，并使用
    **UseStatusCodePagesWithRedirects()** 方法扩展中间件管道。通过 **UseStatusCodePagesWithRedirects()**，我们定义了每当服务器请求导致未处理的错误状态码时，用户将被重定向到
    **/error** 页面。通过 **Error** 组件，我们可以自定义用户看到的消息、详细信息以及下一步操作。
- en: The added benefit of **UseStatusCodePagesWithRedirects()** is that it covers
    all unsuccessful status codes, not just the *route not* *found* case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**UseStatusCodePagesWithRedirects()** 的附加好处是它涵盖了所有不成功的状态码，而不仅仅是 *找不到路由* 的情况。'
- en: See also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: We’ve covered **UseStatusCodePagesWithRedirects()** , as it’s the method most
    commonly used in UI-based applications. However, it’s just one of the options
    from the **UseStatusCodePages()** family of methods. Handling ranges from simple
    text status representation to fully customized exception-handling logic and retries.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 **UseStatusCodePagesWithRedirects()** 方法，因为它是在基于UI的应用程序中最常用的方法。然而，它只是
    **UseStatusCodePages()** 方法家族中的一个选项。它可以从简单的文本状态表示处理到完全定制的异常处理逻辑和重试。
- en: 'You can find all available options, with examples of when and how to use each,
    in the Microsoft docs: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages)
    .'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Microsoft文档中找到所有可用选项及其使用示例：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages)
    .
- en: Executing an asynchronous operation with navigation
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行带有导航的异步操作
- en: In modern web applications, executing common logic during navigation can be
    crucial for maintaining a seamless user experience and gathering valuable insights.
    You can implement navigation event logging and achieve a better understanding
    of user behavior, identify the most frequently used features, and improve them
    accordingly. You can also implement periodic security checks and refresh a user’s
    access token seamlessly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络应用中，在导航期间执行常见逻辑对于保持无缝的用户体验和收集有价值的见解至关重要。你可以实现导航事件记录，更好地理解用户行为，识别最常使用的功能，并相应地改进它们。你还可以实现定期的安全检查并无缝刷新用户的访问令牌。
- en: Let’s log all navigation requests inside the application to understand better
    which features users use the most so that you can prioritize them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记录应用内所有的导航请求，以便更好地了解用户使用最多的功能，从而可以优先考虑它们。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will work inside the **Routes** component, which you must already have, as
    it’s an integral part of the Blazor application. No preparation is required in
    this recipe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在**Routes**组件内部工作，这是Blazor应用的一个基本组成部分。在这个菜谱中不需要进行任何准备。
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these instructions to trigger an operation on all navigation inside
    the app:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明在应用内的所有导航上触发操作：
- en: 'Navigate to the **Routes** component and inject a **Logger** instance:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Routes**组件并注入一个**Logger**实例：
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initialize an **@code** block in the **Routes** component, and implement a
    **LogNavigation()** method that accepts **NavigationContext** and logs the path
    that the user entered:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Routes**组件中初始化一个**@code**代码块，并实现一个接受**NavigationContext**并记录用户输入路径的**LogNavigation()**方法：
- en: '[PRE16]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the **Routes** markup, locate **Router** and attach the **LogNavigation()**
    method to its **OnNavigateAsync** callback:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Routes**标记中，找到**Router**并将**LogNavigation()**方法附加到其**OnNavigateAsync**回调：
- en: '[PRE17]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **Routes** component. You learned about **Routes**
    in the *Enabling routes from multiple assemblies* recipe. First, we inject an
    instance of **ILogger** . The **ILogger** interface simplifies logging information
    in applications and allows you to log messages with different severity levels
    (such as information, warning, or error) without depending on a specific logging
    implementation. **ILogger** allows you to provide a logger category, which is
    then reflected in logs, implying the log source. In our case, we declare the **Routes**
    as the logger category. You can find more logging resources in the *See also*
    section at the end of the recipe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们导航到**Routes**组件。你可以在**从多个程序集启用路由**菜谱中了解到**Routes**。首先，我们注入一个**ILogger**实例。**ILogger**接口简化了应用程序中的日志记录，并允许你使用不同的严重级别（如信息、警告或错误）记录消息，而不依赖于特定的日志实现。**ILogger**允许你提供一个日志类别，该类别随后会在日志中反映出来，意味着日志来源。在我们的案例中，我们将**Routes**声明为日志类别。你可以在菜谱末尾的**另请参阅**部分找到更多日志资源。
- en: In *step 2* , we initialize an **@code** block and implement a **LogNavigation()**
    method. **LogNavigation()** accepts **NavigationContext** , which provides information
    about the navigation event. By accessing the **Path** property of the **NavigationContext**
    , we can pass the navigation destination path to **Logger** and log the path the
    user navigated to.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们初始化一个**@code**代码块并实现一个**LogNavigation()**方法。**LogNavigation()**接受**NavigationContext**，它提供了关于导航事件的详细信息。通过访问**NavigationContext**的**Path**属性，我们可以将导航目标路径传递给**Logger**并记录用户导航到的路径。
- en: In *step 3* , we move to the **Routes** markup. Here, we find the **Router**
    construction. The **Router** component exposes an **OnNavigateAsync** callback,
    so we attach the **LogNavigation()** method there. Now, with each navigation request,
    **Router** will invoke the **OnNavigateAsync** callback and trigger the **LogNavigation()**
    method, effectively logging every path our users enter inside the application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们转向**Routes**标记。在这里，我们找到**Router**构造。**Router**组件公开一个**OnNavigateAsync**回调，因此我们在那里附加了**LogNavigation()**方法。现在，随着每个导航请求，**Router**将调用**OnNavigateAsync**回调并触发**LogNavigation()**方法，有效地记录用户在应用程序中输入的每个路径。
- en: By default, you will have a **Console** logger registered, but you can freely
    extend the logging behavior to cover your business use case. You can either implement
    your own logger or find multiple NuGet packages that support logging from different
    hosting models.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你将注册一个**Console**记录器，但你可以自由扩展日志行为以覆盖你的业务用例。你可以实现自己的记录器或找到多个支持从不同托管模型进行日志记录的NuGet包。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can learn more about logging by checking out the Microsoft learning resources:
    [https://learn.microsoft.com/en-us/dotnet/core/extensions/logging](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging)
    .'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看Microsoft学习资源了解更多关于日志记录的信息：[https://learn.microsoft.com/en-us/dotnet/core/extensions/logging](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging)。
- en: Canceling a long-running task when users navigate away
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当用户离开时取消长时间运行的任务
- en: Depending on the traffic in your application, long-running tasks can negatively
    impact performance and user experience if you don’t properly manage them. With
    components rendered in SSR mode, the server handles cancellations for you, similar
    to what happens in web API projects. But in interactive modes, when state is persisted
    either on the server or the client side when users navigate away from a page where
    a long-running task is in progress, it’s essential that you gracefully cancel
    the task to free up resources and prevent unnecessary processing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你应用程序的流量，如果你没有正确管理长时间运行的任务，它们可能会对性能和用户体验产生负面影响。在SSR模式下渲染的组件中，服务器为你处理取消，类似于在Web
    API项目中发生的情况。但在交互模式下，当用户从一个正在执行长时间运行任务的页面离开时，无论是在服务器端还是客户端持久化状态，优雅地取消任务以释放资源并防止不必要的处理是至关重要的。
- en: Let’s implement a graceful cancellation of long-running tasks with the help
    of Blazor’s **NavigationManager** and **CancellationToken** .
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助Blazor的**NavigationManager**和**CancellationToken**实现长时间运行任务的优雅取消。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore graceful cancellation of a long-running task when a user
    navigates away, do the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索当用户离开时优雅取消长时间运行的任务之前，请执行以下操作：
- en: Create a **Chapter09** / **Recipe07** directory – this will be your working
    directory
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter09**/**Recipe07**目录 – 这将是你的工作目录
- en: Copy the **ExternalEventManager** and **DeepLinks** files from the *Implementing
    unified deep linking* recipe or the **Chapter09** / **Recipe04** directory in
    the GitHub repository
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*实现统一深度链接*食谱或GitHub仓库中的**Chapter09**/**Recipe04**目录复制**ExternalEventManager**和**DeepLinks**文件
- en: As **DeepLinks** contains recipe-specific routes and routes in the application
    must be unique, update the paths with **ch09r07** to reflect the current recipe
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于**DeepLinks**包含特定于食谱的路由，并且应用程序中的路由必须是唯一的，因此将路径更新为**ch09r07**以反映当前食谱
- en: Copy the **Source** file from the **Chapter09** / **Data** directory in the
    GitHub repository
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter09**/**Data**目录复制**Source**文件
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to trigger graceful cancellation when a user navigates away:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤触发用户离开时的优雅取消：
- en: 'Navigate to the **ExternalEventManager** component, and then enhance it to
    render it in **InteractiveWebAssembly** mode and implement **IDisposable** . We
    will address the resulting compilation error shortly:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**ExternalEventManager**组件，然后增强它以在**InteractiveWebAssembly**模式下渲染并实现**IDisposable**。我们将很快解决由此产生的编译错误：
- en: '[PRE18]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the top of the **@code** block of **ExternalEventManager** , inject **NavigationManager**
    :'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ExternalEventManager**的**@code**块顶部，注入**NavigationManager**：
- en: '[PRE19]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Below the **Nav** injection, declare a **_cts** variable of type **CancellationTokenSource**
    :'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Nav**注入下方，声明一个类型为**CancellationTokenSource**的**_cts**变量：
- en: '[PRE20]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the end of the **@code** block of **ExternalEventManager** , implement a
    **CancelTask()** method, matching the signature for an **EventHandler** object
    returning **LocationChangedEventArgs** , which acts as a proxy to call the **Cancel()**
    method of the **_cts** object:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ExternalEventManager**的**@code**块末尾，实现一个**CancelTask()**方法，匹配返回**LocationChangedEventArgs**的**EventHandler**对象的签名，该对象作为代理来调用**_cts**对象的**Cancel()**方法：
- en: '[PRE21]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Below the **CancelTask()** method, override the **OnInitialized()** life cycle
    method and subscribe the **CancelTask()** method to the **LocationChanged** event
    exposed by the injected **Nav** :'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**CancelTask()**方法下方，重写**OnInitialized()**生命周期方法，并将**CancelTask()**方法订阅到注入的**Nav**暴露的**LocationChanged**事件：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next to **OnInitialized()** , implement a **Dispose()** method required by
    the **IDisposable** interface, where you safely unsubscribe from the **LocationChanged**
    event and gracefully dispose of the **_cts** instance:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**OnInitialized()**旁边，实现一个**Dispose()**方法，这是**IDisposable**接口要求的，在该方法中，我们安全地取消订阅**LocationChanged**事件，并优雅地处理**_cts**实例：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To complete the **@code** block, implement a **GetAsync()** method, where you
    get **eventId** from **Source** , and redirect the user to the event details page:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成**@code**块，实现一个**GetAsync()**方法，其中从**Source**获取**eventId**，并将用户重定向到事件详情页面：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Move to the **ExternalEventManager** markup area, and below the header, replace
    the fast-return clause when **EventId** is not set with a rendering of a button,
    allowing users to load an event if it has not yet loaded:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到**ExternalEventManager**的标记区域，在标题下方，用按钮的渲染替换当**EventId**未设置时的快速返回语句，允许用户在事件尚未加载时加载事件：
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **ExternalEventManager** component and declare
    it to render in **InteractiveWebAssembly** mode, as we want to monitor the execution
    of a long-running task to cancel it if needed. We also need **ExternalEventManager**
    to implement **IDisposable** . Declaring the component as **IDisposable** results
    in a compilation error, but we will resolve it before the end of the recipe.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们导航到**ExternalEventManager**组件，并声明它以**InteractiveWebAssembly**模式渲染，因为我们想监控长时间运行的任务的执行，以便在需要时取消它。我们还需要**ExternalEventManager**实现**IDisposable**。将组件声明为**IDisposable**会导致编译错误，但我们将在食谱结束前解决它。
- en: In *step 2* , we inject a **NavigationManager** instance at the top of the **@code**
    block of **ExternalEventManager** . The **NavigationManager** instance allows
    us to react to navigation and location changes. In *step 3* , we set up the backbone
    of graceful task cancellation by declaring a **CancellationTokenSource** variable.
    With **CancellationTokenSource** , we can signal and manage cancellation requests
    for asynchronous operations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们在**ExternalEventManager**的**@code**块顶部注入一个**NavigationManager**实例。**NavigationManager**实例允许我们响应导航和位置变化。在*步骤
    3*中，我们通过声明一个**CancellationTokenSource**变量来设置优雅任务取消的基础。使用**CancellationTokenSource**，我们可以发出和管理异步操作取消请求。
- en: In *step 4* , we implement a **CancelTask()** method with a signature matching
    an **EventHandler** object returning **LocationChangedEventArgs** . The **CancelTask()**
    method’s responsibility is to invoke **Cancel()** of the **_cts** instance and
    cancel all running operations, depending on that instance. We leverage the **?**
    operator, called a **null-conditional operator** , as it allows us to invoke a
    method or access to a member only if the preceding object ( **_cts** in this case)
    is not **null** . In *step 5* , we override the **OnInitialized()** life cycle
    method of **ExternalEventManager** and subscribe **CancelTask()** to the **LocationChanged**
    event exposed by **Nav** . Blazor triggers the **LocationChanged** event whenever
    a user navigates to a new location within the application. In *step 6* , we complete
    the implementation of **IDisposable** by constructing a **Dispose()** method.
    In the **Dispose()** method, we safely unsubscribe from the **LocationChanged**
    event to prevent memory leaks. We also dispose of the **_cts** instance using
    the **Dispose()** method it exposes. In *step 7* , we complete the **@code** block
    by implementing a **GetAsync()** method to test the graceful cancellation of a
    long-running task. As part of **GetAsync()** , we initialize a new **_cts** instance
    and call the **LoadAsync()** method of the **Source** class, passing in a **CancellationToken**
    sourced from the **_cts** instance. **CancellationToken** allows **LoadAsync()**
    to be aware of any cancellation requests as it executes. As we expect loading
    cancellations, we add a **_cts** state-check. With the **IsCancellationRequested**
    property, we can verify whether cancellation was requested and short-circuit the
    code execution. Lastly, if **LoadAsync()** completes, we redirect the user to
    the appropriate event details page.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 步* 中，我们实现了一个签名与 **EventHandler** 对象返回的 **LocationChangedEventArgs** 匹配的
    **CancelTask()** 方法。**CancelTask()** 方法的责任是调用 **_cts** 实例的 **Cancel()** 并取消所有基于该实例运行的操作。我们利用
    **?** 操作符，称为 **空条件操作符**，因为它允许我们仅在前面对象（在这种情况下为 **_cts**）不是 **null** 时调用方法或访问成员。在
    *第 5 步* 中，我们重写 **ExternalEventManager** 的 **OnInitialized()** 生命周期方法，并将 **CancelTask()**
    订阅到 **Nav** 暴露的 **LocationChanged** 事件。Blazor 在用户在应用程序内导航到新位置时触发 **LocationChanged**
    事件。在 *第 6 步* 中，我们通过构建一个 **Dispose()** 方法来完成 **IDisposable** 的实现。在 **Dispose()**
    方法中，我们安全地取消订阅 **LocationChanged** 事件以防止内存泄漏。我们还使用它暴露的 **Dispose()** 方法来处置 **_cts**
    实例。在 *第 7 步* 中，我们通过实现一个用于测试长时间运行任务优雅取消的 **GetAsync()** 方法来完成 **@code** 块。作为 **GetAsync()**
    的一部分，我们初始化一个新的 **_cts** 实例并调用 **Source** 类的 **LoadAsync()** 方法，传入来自 **_cts** 实例的
    **CancellationToken**。**CancellationToken** 允许 **LoadAsync()** 在执行过程中意识到任何取消请求。由于我们期望加载取消，我们添加了一个
    **_cts** 状态检查。使用 **IsCancellationRequested** 属性，我们可以验证是否请求了取消并短路代码执行。最后，如果 **LoadAsync()**
    完成，我们将用户重定向到适当的事件详情页面。
- en: In *step 8* , we move to the **ExternalEventManager** markup and add a simple
    button, allowing users to trigger **GetAsync()** and put the implementation to
    the test. You can run the application and click the **Get event** button. The
    **LoadAsync()** method from the **Source** has a hardcoded delay of five seconds
    and logs status messages to your browser console. If you navigate away from the
    **ExternalEventManager** page before the timer elapses, you will see that the
    saving request you’ve queued was gracefully canceled.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 8 步* 中，我们转向 **ExternalEventManager** 标记并添加了一个简单的按钮，允许用户触发 **GetAsync()**
    并对实现进行测试。您可以运行应用程序并点击 **获取事件** 按钮。**Source** 中的 **LoadAsync()** 方法有一个硬编码的五秒延迟，并将状态消息记录到您的浏览器控制台。如果您在计时器结束之前离开
    **ExternalEventManager** 页面，您将看到您已排队的保存请求被优雅地取消。
- en: '![Figure 9.1: Messages in the browser console, indicating graceful task cancellation](img/Figure_9.1_B22020.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：浏览器控制台中的消息，指示优雅的任务取消](img/Figure_9.1_B22020.jpg)'
- en: 'Figure 9.1: Messages in the browser console, indicating graceful task cancellation'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：浏览器控制台中的消息，指示优雅的任务取消
- en: Controlling navigation history
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制导航历史
- en: The **NavigationManager** in Blazor uses the browser’s **History API** to maintain
    navigation history. Manipulating navigation history is particularly useful when
    authenticating users with external identity providers, where users are redirected
    back to an application after authentication. It’s also beneficial when displaying
    intermediate pages that allow users to configure their application, but you want
    to restrict them from going backward in that process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor中的**NavigationManager**使用浏览器的**History API**来维护导航历史记录。操作导航历史记录在用外部身份提供者验证用户时特别有用，用户在验证后会被重定向回应用程序。当显示允许用户配置其应用程序的中间页面，但您希望限制他们在此过程中向后导航时，这也很有益。
- en: Let’s simulate intermediate page removal from the browser history and force
    users to navigate to the last stable page when they try to return to the intermediate
    stage.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟从浏览器历史记录中删除中间页面，并在用户尝试返回到中间阶段时强制他们导航到最后一个稳定页面。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore browser navigation history manipulations, do the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索浏览器导航历史记录操作之前，请执行以下操作：
- en: Create a **Chapter09** / **Recipe08** directory – this will be your working
    directory
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter09** / **Recipe08**目录——这将是你的工作目录
- en: Copy the **ExternalEventManager** and **DeepLinks** files from the *Canceling
    a long running task when users navigate away* recipe or the **Chapter09** / **Recipe07**
    directory in the GitHub repository
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“当用户导航离开时取消长时间运行的任务”食谱或GitHub仓库中的**Chapter09** / **Recipe07**目录复制**ExternalEventManager**和**DeepLinks**文件
- en: As **DeepLinks** contains recipe-specific routes and routes in the application
    must be unique, update the paths with **ch09r08** to reflect the current recipe
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于**DeepLinks**包含特定于食谱的路由，并且应用程序中的路由必须是唯一的，因此使用**ch09r08**更新路径以反映当前食谱
- en: Copy the **Source** file from the **Chapter09** / **Data** directory in the
    GitHub repository
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter09** / **Data**目录复制**Source**文件
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to replace an entry in the browser’s navigation history:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤替换浏览器导航历史记录中的条目：
- en: Navigate to the **@code** block of **ExternalEventManager** and find the **GetAsync()**
    method.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**ExternalEventManager**的**@code**块并找到**GetAsync()**方法。
- en: 'Inside **GetAsync()** , when invoking the **NavigateTo()** method of the injected
    **NavigationManager** , explicitly set the additional **replace** parameter to
    **true** :'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**GetAsync()**内部，在调用注入的**NavigationManager**的**NavigateTo()**方法时，明确设置额外的**replace**参数为**true**：
- en: '[PRE26]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **ExternalEventManager** . Here, in the **@code**
    block, we have a **GetAsync()** method that users trigger when retrieving event
    details from an external source. In *step 2* , we extend the **GetAsync()** navigation
    logic by passing **true** as the **replace** argument. With the **replace** argument
    in **NavigationManager.NavigateTo()** , we ensure that the current entry in the
    browser’s history is replaced with the new URL rather than adding a new entry.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们导航到**ExternalEventManager**。在这里，在**@code**块中，我们有一个**GetAsync()**方法，用户在从外部源检索事件详情时触发此方法。在*步骤2*中，通过将**true**作为**replace**参数传递来扩展**GetAsync()**的导航逻辑。在**NavigationManager.NavigateTo()**中的**replace**参数确保浏览器历史记录中的当前条目被新的URL替换，而不是添加新的条目。
- en: If a user hasn’t loaded any event yet, we will display a page with a button
    allowing them to load an event. After clicking the button, they get redirected
    to the event details page automatically. From there, when users try to navigate
    back, they will land on whatever page they were on before getting the event. The
    browser will not be aware of the intermediate step of loading the event in the
    first place.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未加载任何事件，我们将显示一个带有按钮的页面，允许他们加载事件。点击按钮后，他们将被自动重定向到事件详情页面。从那里，当用户尝试导航回时，他们将到达在获取事件之前所在的任何页面。浏览器将不会意识到最初加载事件的中间步骤。
