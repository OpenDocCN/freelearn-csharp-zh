- en: Chapter 10. Talk to the User – Adding Interactivity and UI Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a key press on the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting mouse movement and clicks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application that will use basic input for real-time control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used some of these functionality in the previous chapters, but here
    we will try to gain a more systematic overview of what kind of basic interactivity
    is possible with Cinder.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book we are writing a code that basically extends the functionality
    of the `cinder::app::AppBasic` class and base class `App` that it inherits. The
    methods that we are declaring and implementing are basically overrides of virtual
    functions that are built in the `AppBasic` and `App` classes and are called upon
    in certain events. Some of them can be called event handlers, and what they basically
    do is they respond to certain events that are happening during the application
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three basic methods that form the core of a Cinder application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods handle the events that are happening inside the application core
    and a user can't control whether these functions are called or not (it is possible
    to stop the execution of the method by using `return` or similar means at the
    beginning of the function implementation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then there are methods that can be used to execute code on certain events for
    example moving your mouse, pressing a key on the keyboard, scrolling the mouse
    wheel, and so on. These are the ones we will focus on during this chapter. So
    here is a list of methods (or event handlers) that we will override:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keyDown()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyUp()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileDrop()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseDown()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseUp()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseMove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseDrag()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create a simple drawing application that will use all of these events.
    To do so, we will need to create a new project. Open **TinderBox** and create
    a new project with the name `BasicEvents`. Open the project file (`xcode/BasicEvents.xcodeproj`
    on Mac OS X or `vc10\BasicEvents.sln` on Windows). Open the `BasicEventsApp.cpp`
    in the editor and let's start to add some code there.
  prefs: []
  type: TYPE_NORMAL
- en: Using mouseMove()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we will add a custom mouse cursor that will fall down slowly while we
    don''t move the mouse, and returns to the current mouse position when we move
    it. To do so we have to declare objects that will hold the x and y position of
    the cursor. Add the following line of code to the class declaration part of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This variable will hold the `x` and `y` positions of our cursor as `int` values.
    The `i` part of the `Vec2i` tells us that it is a two-dimensional vector that
    consists of integer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to initialize the value by setting it to the current mouse position
    at the application launch. Add the following line of code to the `setup()` method
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will get the current mouse position and assign it to our cursor position
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to draw a circle at the `cursorPos` coordinates. Let''s navigate
    to the `draw()` method implementation of our application and add the following
    line just after the `gl::clear()` function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've used this function before. This will draw a circle with the radius of
    10 pixels at the position defined by the `cursorPos` variable. Compile and run
    the project to see for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we want to add the falling motion to the circle. To do so, we will need
    to update the circle''s `y` position by each frame. In other words, we are going
    to increase the `y` coordinate of the circle by one frame each. Let''s navigate
    to the `update()` method implementation and add a simple line of code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let our cursor fall down. Finally we need to make it stick to the
    mouse on the `mouseMove` event. We will need to declare the `mouseMove()` method
    override in the class declaration of our application. Add the following line at
    the end of the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And the method implementation to the class implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is more than one way of getting the current mouse position and instead
    of `event.getPos()`. We could use `getMousePos()` and it would do the same thing
    that is assigned to the mouse position to the `cursorPos` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run our application to see the result as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using mouseMove()](img/9564_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should see a falling circle that sticks to the mouse as you move it.
  prefs: []
  type: TYPE_NORMAL
- en: Using mouseDown()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next event handler that we are going to implement is the `mouseDown()` handler.
    It will execute code every time we click on any of the mouse buttons. We will
    write code that will add a static circle on the screen every time we click the
    left mouse button. It will remove the first circle when we click the right mouse
    button.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we will need to declare a new variable that will be able to store
    more than one pair of coordinates for our generated circles. We could use an array
    of `Vec2i` objects but as we don't know the exact count of the circles we are
    going to create, we will use a C++ `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: A **vector** is a dynamic array that is able to store `std::vector::max_size`
    amount of objects of a certain type. A `vector` array changes it's size (or length)
    dynamically on element add (or push) and remove (or pop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code at the end of our class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible that the `mouseDown()` method is declared for us already. If
    so, don''t mention the second line of the code. If `mouseDown()` was not declared
    before, go ahead and add the event handler method to the class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell from the comments in the preceding code, it checks which mouse
    button has been pressed and then decides what to do next. As we stated before,
    a circle has to be created when you click the left-mouse button and a circle has
    to be removed when you click on the right-mouse button. Actually we do not create
    circles here, we just save their positions. In the `draw()` method we will be
    able to chose whether we want to draw circles or something else entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s navigate to the `draw()` method implementation and add the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To loop through a vector we have to use an iterator in this case. Vector iterators
    are objects that are designed to traverse the vector. In this case the iterator
    object is like a pointer and a `vector<Vec2i>` type iterator will point to a `Vec2i`
    object inside of it. By increasing and decreasing the iterator position we gain
    access to the next or previous item in the vector. It is possible to get the `begin()`
    and `end()` iterators from a vector and they point to the first and the past-the-end
    element of a vector respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To access an element through the iterator (that is similar to a pointer), we
    have to make use of the concept of **dereferencing** . To dereference a pointer
    we have to use an asterisk (`*`) before the pointer variable. If `i` is a pointer
    to the actual position of a circle, to access the actual `Vec2i` object that stores
    the coordinates, we have to use `*i`. To access properties of the object, we write
    `(*i).x` or `i->x`.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run the project. You should be able to add and remove circles by
    clicking on the right and left buttons of your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using mouseDown()](img/9564_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can do the same by using the `mouseUp()` event handler instead of `mouseDown()`.
    The only difference is that the code will be executed when you release the mouse
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Using mouseDrag()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next we are going to make use of the `mouseDrag()` event handler to draw a
    polyline on the screen. We will need another `vector` for storing the coordinates
    of the points that will actually form the polyline. Let''s declare the `vector`
    and `mouseDrag()` event handlers in the class declaration. Add the following line
    of code at the end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use `PolyLine<Vec2f>` here because `PolyLine` is a Cinder class that is used
    to store control point values of a line. We use `Vec2f` instead of `int`, because
    there is no `draw` function in Cinder that would accept a `PolyLine` class that
    consists of `int` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move to the next step and add the implementation of the `mouseDrag()`
    method to the class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will add a new position with the current mouse coordinates to the `PolyLine`
    each time a change in mouse position is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have to draw the `PolyLine`. So let''s navigate to the `draw()`
    method implementation and add the following line of code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gl::drawSolid` function will basically draw a filled polygon. The `PolyLine`
    itself defines the outline of the polygon. Compile and run the project to see
    what I mean to say. You should end up with an image similar to the one shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using mouseDrag()](img/9564_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to draw a line, use `gl::draw(line)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using keyDown()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be nice if we had the ability to clear the screen while the application
    is running instead of closing and reopening it to start again. Let''s make use
    of the `keyDown()` event handler to detect a key press. What we want to do is
    to erase all circles and the line when the *C* key is pressed. To do that, we
    need to declare the `keyDown()` method in the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have to implement this, so add the following code snippet at the end
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `keyDown()` method takes a `KeyEvent` parameter that contains the code of
    the key that is being pressed. Here we check if the key code represents the letter
    C on the keyboard and if that is `true`, we clear the `circlePositions` `vector`
    and `vector` values in the `PolyLine` object that actually stores the control
    points in the same manner as the `vector` `circlePositions` does.
  prefs: []
  type: TYPE_NORMAL
- en: You can do the same thing with the `keyUp()` event handler. We won't make a
    separate example of it now as it works exactly the same way when a key is released.
  prefs: []
  type: TYPE_NORMAL
- en: Using fileDrop()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we will do though is we will make use of the `fileDrop()` event handler
    to place a picture in the background. It takes `FileDropEvent` object as a parameter.
    It contains the path to the file that is being dropped on to the application window.
    To make use of that path, we need to add these lines at the top of the class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first include is needed because it contains the `gl::Texture` class that
    we will need in order to store the background image and to draw it by using the
    `gl::draw()` function. The `ImageIo.h` file is here because of the image loading
    functions that we will need to load an actual image into the `Texture` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to declare a variable that will store the background image and
    the `fileDrop()` event method itself. Add the following lines of code at the end
    of the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to implement the `fileDrop()` method. Add the following lines of
    code in the class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we are making use of the `try` and `catch` statement. By doing this we
    just make sure that our application does not crash if the wrong kind of file is
    being dropped. We load an image into the `background` variable if we are lucky
    or print an error message to the console if not.
  prefs: []
  type: TYPE_NORMAL
- en: Take a closer look on the `console()` function call. The `console()` function
    refers to the standard output or console. This is one of the best debugging tools
    in the world and you should consider using it if you are not using it already.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last thing missing, we have to draw the `background`. Go to the
    `draw()` method implementation and add the following code snippet right after
    the `gl::clear()` function call and before all the code we added to this method
    during this chapter. We do so because the background is the first thing that we
    need to draw in each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Before we draw a texture, we have to make sure that it actually exists. That's
    why we are using an extra if statement. Only then 'can' we draw the background
    texture within the bounds of our application window that is returned by the `getWindowBounds()`
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run our application. Drop an image file on to the window of our
    application and see what happens. You should see an image similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using fileDrop()](img/9564_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained a basic understanding about the built-in and mostly
    used events that any kind of application could make use of. We learned how to
    make use of mouse press, mouse drag, key press, and even file drop events. We
    also made use of some new drawing methods that were not explained in previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about communication between applications
    built-in Cinder, and other applications on the same or other networked computer
    by using Syphon and Open Sound Control message system.
  prefs: []
  type: TYPE_NORMAL
