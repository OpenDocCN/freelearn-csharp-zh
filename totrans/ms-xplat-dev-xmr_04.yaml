- en: Chapter 4. Local Data Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will find patterns and techniques to efficiently use,
    manage, and roam data on mobile devices. It also investigates SQLite database
    creation and usage strategies. The chapter is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Data in mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data roaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup/roaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data in mobile applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term "data" can refer to different types of information and storage locations
    in mobile app development. It can be used to describe a volatile state that is
    created and destroyed each time a view in the application is used, or it might
    refer to persisted settings and configuration information that are required to
    run the application, or even the data stored in the local filesystem. Each type
    of data is created and persisted or destroyed throughout the lifecycle of the
    application or a view in the application. We can talk about four distinct groups
    for this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Each data type is stored and accessed from different locations and each location
    has its own unique restriction and access models.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data in mobile applications](img/B04693_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data type storage locations
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile applications are generally *stateful*. Transient data that is used to
    visualize items on the UI or the data created by the user of the application falls
    into this category. The purpose of state is to maintain a consistent app experience
    across sessions, devices, and/or process lifecycle. Application settings or the
    current state of the view is a good example for this category.
  prefs: []
  type: TYPE_NORMAL
- en: App data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: App data generally refers to the data that is essential for the execution of
    the application. This data is created, stored, and managed by the application
    itself. It can be structured data storage or it might be the cached version of
    online application resources. This type of data can be raw, in the form of a SQLite
    database, or stored by other facilities on the current device by the current application.
  prefs: []
  type: TYPE_NORMAL
- en: App data stored in different locations can survive through different stages
    of an application lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: '![App data](img/B04693_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: App data lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: Local files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Local files are the stored items in the local filesystem. These files are generally
    created outside the lifecycle and/or scope of the application and are only made
    use of by the application. For instance, a photo taken by the user can later on
    be used by the mail client app as an attachment item.
  prefs: []
  type: TYPE_NORMAL
- en: External data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: External data can be described as the combination of all the other data sources
    that are used by the application during runtime. This can include network or web
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Application data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application data makes up the core of the data storage on Xamarin platforms
    and Windows Runtime. This data is specific to your application. It lives and eventually
    dies with it, and in most cases it is not relevant or even accessible by other
    applications running on the same device or even by the user who is using the application
    (at least directly).
  prefs: []
  type: TYPE_NORMAL
- en: The application has unrestricted access to application data, or so-called isolated
    storage, without having to ask for permission from the user or add a declaration
    and can (in most cases) write, read, and query items in this storage according
    to the type of the application data location.
  prefs: []
  type: TYPE_NORMAL
- en: Installation directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The installation directory is the innermost part of the accessible data storages
    and is the most intimate location for the application. Access to this location
    by the application is unrestricted but read-only. The access models on iOS, Android,
    and Windows Runtime vary greatly.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Xamarin.Android applications, the installation directory essentially refers
    to the compressed Android package (the `.apk` file), and the defined subdivisions
    are just abstractions of folders packaged and added to the manifest during the
    compilation. The installation directory and subfolders can be accessed in various
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android](img/B04693_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android package and the project tree
  prefs: []
  type: TYPE_NORMAL
- en: The most important location in the installation directory for Android apps is
    the `Resources` folder. Resources can be generalized as the UI-related items that
    will be used to render the views of the application. One of the resource types
    that can be included in the application package is the `drawable` type. Drawable
    resources are image resources and can exist in alternate flavors for different
    conditions and devices that the application runs on (see [Chapter 9](ch09.html
    "Chapter 9. Reusable UI Patterns"), *Reusable UI Patterns*). In order for the
    compiler to include the resources in the application package, the build action
    of each item in this folder has to be set to `AndroidResource`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to mention that Android packages do not allow filenames to contain
    uppercase characters, and yet Xamarin developers can include these types of files
    in their projects. Xamarin.Android deals with this by renaming the resources during
    compilation (for example, see the `XamarinLogo.png` file in the `drawable` folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically, they can be accessed using the generated `Resource` class
    to get the assigned resource ID and the `Resources` static class that provides
    access methods, or by using the `android.resource://` protocol and the resource
    identifier (or the package name together with the resource name). However, in
    most scenarios, using only the assigned id to use the resources with UI controls
    will suffice. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the declarative UI (layouts), the drawable resources folder can be accessed
    with the alias `@drawable`. Similarly, string resources can be accessed with `@string`.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important location in the installation directory is the `Assets` folder.
    The `Assets` folder is used for any raw assets that you want deployed together
    with your application (other than the `Resources` folder) and not to be processed
    by the compiler or the runtime. Assets can be retrieved with the `AssetManager`
    class, and the `Assets` property in the `Activity` class can be used to access
    the `AssetManager` class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Other resource types in the installation location, such as layouts, raw, and
    string resources can also be accessed in the described manner using the abstraction
    provided by Android runtime.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The building units of an iOS application, such as executable code and associated
    resources, are contained in a so-called **bundle**. A bundle is part of the application
    sandbox and the path to the bundle is determined by the operating system during
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Android applications, iOS application projects can also include compiled
    image resources (bundle resources). These items are then accessed using the abstraction
    layer provided by the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in order to access an image resource from the bundle directory,
    you would need to call the `FromFile` method on the `UIImage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the access model in Android applications, the bundle container is
    read-only and should not be modified. The simple reason for this is that iOS application
    bundles are signed by the publisher key and any change in the bundle container
    would invalidate the package signature.
  prefs: []
  type: TYPE_NORMAL
- en: Local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a both in the second part as well. Android and iOS runtimes provide
    different storage facilities for application data both in the form of structured
    data and raw content files.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the Android platform, **Shared Preferences** and **Internal Storage** are
    the two local storage options. Both of these options have different access models
    and your applications have read/write access to these locations.
  prefs: []
  type: TYPE_NORMAL
- en: Using `SharedPreferences` is the most basic way of storing data on the Android
    platform. This class provides a simple persistent dictionary implementation that
    allows the application to create, modify, and retrieve primitive data types (that
    is, `boolean`, `float`, `int`, `long`, `string`, and `string_array`) and their
    associated key. The size on these values is only restricted by the data type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, `SharedPreferences` is generally used to store configuration
    options selected by the user and is persisted across user sessions. There is also
    a base activity implementation, `PreferenceActivity`, to easily create and reuse
    a view for user preferences that makes use of the `SharedPreferences` for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage pattern for `SharedPreferences` class is straightforward. In order
    to use the default preferences for the activity or a custom preference file, the
    `Activity` class provides specialized methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the retrieve call, the preference file is created according to the `FileCreationMode`
    class selected if it did not exist already. To get the value of a preference entry,
    you can use one of the get methods provided by the class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To edit the values, the `Editor` class for the `SharedPreferences` class can
    be used. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Internal Storage** is the dedicated storage for your application. The application
    is free to create and retrieve any type of file (and folder) in this directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FileCreationMode` is an access modifier used in Android runtime to define
    the access type and permission levels of a file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Append**: If the file already exists, then write data to the end of the existing
    file instead of erasing. This is to be used with `Android.Content.Context.OpenFileOutput`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EnableWriteAheadLogging**: When this database''s open flag is set, the database
    is opened with write-ahead logging enabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MultiProcess**: legacy behavior in and before Gingerbread (Android 2.3) and
    is implied when targeting such releases. For applications targeting higher SDK
    versions, it must be set explicitly. When used together with `SharedPreferences`,
    the file on disk will be checked for modifications even if the shared preferences
    instance is already loaded in this process. This behavior is desired when the
    application has multiple processes accessing the same file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: This is the default file creation mode where the created file
    can only be accessed by the calling application (or all applications sharing the
    same user ID).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WorldReadable/WorldWritable**: Both deprecated in API level 17 for security
    vulnerabilities, they can pose to enable file access to application files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Files in this folder, without any manifest declaration, can be accessed with
    the designated methods on the application context or by using the Xamarin/Mono
    implementation of IO methods. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In addition to basic CRUD operations, you can also create additional folders
    and enumerate files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest data storage option on iOS applications are the property lists.
    (the `.plist` files). These files are designed to be used for relatively small
    amounts of data that can be represented with primitive data types. They can be
    defined as dictionaries or arrays that are serialized and persisted in XML format.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read and write to a property list directly using the associated classes
    (`NSArray` and `NSDictionary`). For instance, a simple implementation that creates
    and reads a property list would look similar to the following code (with additional
    diagnostic entries):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the preceding implementation would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to the local file storage, the iOS filesystem reserves several
    locations for applications; each of these locations have a specific purpose from
    the application's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '`Documents/`: The `Documents` library is generally designated for user-generated
    content. This folder should be used if the contents of the files are to be exposed
    to the user. Contents of this folder are backed up by iTunes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Documents/Inbox`: The `Inbox` folder is where files that are requested to
    be opened by the application are kept. An application can read and delete these
    files; it does not have privileges to modify these documents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Library/`: The `Library` folder is the root directory for the files that you
    don''t want to expose to the user. Applications can create files and additional
    folders in this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Library/Application Support`: This subdirectory in the library folder is generally
    used to contain files managed by your application, such as configuration files,
    templates, saved data, and purchases. Contents destined for this folder should
    be placed in a custom subdirectory with the bundle identifier or company ID of
    your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Library/Caches`: The `Caches` folder is used for non-essential, application
    created files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Library/Preferences`: App-specific preferences are stored in this folder.
    However, access to this folder should be done through the preferences API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmp/`: The `tmp` folder is another location for non-essential temporary files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to these library locations is possible using the `System.IO` namespace
    and associated classes.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Temporary storage and/or the cache directory is another location that the application
    does not need any specific permission. This is where non-essential files can be
    saved by the application to decrease network or processing time. The persistence
    of these folders is not guaranteed by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In both Android and iOS systems, designated cache and/or temp locations are
    accessed through the context properties and the CRUD operations can be performed
    using the `System.IO` namespace and the related classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Android, the cache directory can be accessed with the `CacheDir` property
    on the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On iOS, there are two separate locations for temporary files (`/temp/`) and
    cache files (`Library/Caches/`). Cache files are persisted for longer than the
    temporary data, but they still might be deleted by the system to free up disk
    space. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Neither of these directories are backed up or synchronized to iCloud.
  prefs: []
  type: TYPE_NORMAL
- en: Local filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On iOS, applications cannot programmatically access files external to the application
    sandbox (for example, an iOS application cannot programmatically navigate to the
    user's picture directory and pick a file). The bridge between the local filesystem
    and the iOS app's sandbox was limited to the image picker controller until iOS
    8\. iOS 8 introduces the new document picker controller and document provider
    API. In this interaction model, the application implementing the document provider
    extension creates the document picker UI and the host application uses this provided
    UI to let the user select the documents to be used in the host application execution
    (similar to the file open picker and provider capability on the Windows Runtime
    platform).
  prefs: []
  type: TYPE_NORMAL
- en: '![Local filesystem](img/B04693_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: UIImagePickerController
  prefs: []
  type: TYPE_NORMAL
- en: 'For Android, on top of the local file storage that is only app-specific, applications
    have access to two other locations: public and private external storage (depending
    on the hardware). External storage in this context refers to SD card storage,
    which is not available on iOS systems. On Android runtime, applications can have
    access to the root path (OS root path) and iterate through public folders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the returned paths for some of the internal and external
    paths on an Android filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output to these calls identifies the app-specific and public locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In spite of the fact that Android developers have access to a vast set of options
    for storage access methods, they are required to implement their own file picker
    dialogs or use interfaces provided by other installed applications (Android runtime
    also offers a provider-consumer type of file sharing implementation between applications).
  prefs: []
  type: TYPE_NORMAL
- en: '![Local filesystem](img/B04693_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A sample file browser implementation (Xamarin recipes)
  prefs: []
  type: TYPE_NORMAL
- en: If there is an application that, by default, handles the file dialogs (the activity
    that can handle `ActionGetContent` intent), it can be invoked with an intent and
    the result can be accessed through the `OnActivityResult` callback method.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite database implementations provide a relational persisted data structure
    in mobile application projects. Unlike the general server/client model that is
    used by relational databases, SQLite is a local database implementation and the
    data is stored in application local storage. Both Xamarin.iOS and Xamarin.Android
    application projects can include a SQLite database and associated implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use SQLite, developers are to choose to between the cross-platform
    implementation of ADO.Net, where the SQL queries are supposed to be created and
    included as plain text, or use the linq-2-entities access model of the SQLite.Net
    portable class library. It is available as a NuGet package and a component.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQLite](img/B04693_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SQLite.Net PCL
  prefs: []
  type: TYPE_NORMAL
- en: For the following demonstration, we will use the asynchronous version of the
    SQLite.Net library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation of the SQLite data access layer with SQLite.Net generally follows
    a code first database programming paradigm. In this pattern, developers first
    define their data model by creating entity classes and defining the data structure
    using the provided attributes. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once the data model implementation is finished, we can start creating the SQLite
    access methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a SQLite connection, first an application storage location
    has to be defined for the database file. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, `ISQLitePlatform` provides the much needed abstraction
    for the platform-specific APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the SQLite connection is ready for use, we can implement the data tables''
    access and creation methods. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now expose the tables through public properties in our data context,
    so the upper layers can execute queries against these tables. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to extend the data model with entity relations and cascade operations.
    There are also available extensions for the SQLite.Net PCL library for lazy loading
    and child-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will have a look at two common patterns that are common
    to mobile applications and how to implement these usage scenarios in a platform
    agnostic manner.
  prefs: []
  type: TYPE_NORMAL
- en: Application preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application preferences is a common scenario in mobile applications. In order
    to use the previously described property list on iOS and `SharedPreferences` on
    Android, a common dictionary interface is often the most appropriate approach.
    The interface would then be inherited on platform-specific projects and can be
    injected into the common library.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple demonstration, we can define a simple interface that will retrieve
    and save string values. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation on the Android side would use a simple dictionary using
    a shared preference implementation. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the iOS side, the implementation would use an `NSMutableDictionary` class
    to facilitate the preferences being edited by the user. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that the persisted dictionary has been implemented on both platforms, we
    can include the application settings as a singleton to be used with a dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation can be extended using the Settings API on the iOS platform
    and using the preferences views (`PreferencesFragment` and `PreferencesActivity`)
    on the Android platform to create a more native-looking implementation.
  prefs: []
  type: TYPE_NORMAL
- en: File picker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a cross-platform application project, if we are following an MVVM pattern,
    the view-model should reside in a shared project or a PCL so that the business
    logic can be shared between the apps. However, if we have a requirement to pick
    a file for processing, the method implementation should reside in the view itself
    since the platform-specific project that holds the view has access to platform
    features. Although it would be moving the business logic to the UI components,
    the work has to be done by the view.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, delegate the responsibility of the view model to the view
    without compromising the MVVM implementation. The delegation process can be executed
    through **Inversion of Control** (**IOC**) into the interface that defines the
    file picking operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this usage, we will use an interface called `IFilePickerService`.
    In this example, we just want to let the user pick a file and return the resulting
    file path back to the view-model and maybe the model. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this interface in the view-model to call for the view to execute
    the logic. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For Android implementation, we will be using the default file manager application
    that supports the respective intent type. We need to convert intent execution
    and the callback call on the `OnActivityResult` class into an asynchronous implementation.
    In order to do this, we will be using a task completion source. The code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The private variable will be initialized every time the intent is called and
    the result will be set in the callback method. With this pattern in mind, the
    interface method implementation would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the callback method implementation would be just setting the result
    on the `TaskCompletionSource` class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the `IFilePickerService` interface created, at least on the
    Android side, we have to register the type with the dependency injection provider
    we are using, and then we can rely on it to resolve the type in the view-model
    initialization. (We will be using the MVVMCross framework in this example.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The resulting application would execute the pick file command and open up the
    file browser, returning the file path back to the view model. If the user cancels
    the file selection, the task would throw an exception notifying that the operation
    has been cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: '![File picker](img/B04693_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default file browser
  prefs: []
  type: TYPE_NORMAL
- en: 'For the iOS side of the story, our job is a little easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this completed, we just need to register the type and we finally have a
    cross-platform implementation of a command relying on the dependency injected,
    platform-specific methods.
  prefs: []
  type: TYPE_NORMAL
- en: Backup/Roaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin target platforms both offer cloud sync and backup mechanisms. While
    the Android backup strategy is more of an async background process where backup
    and restore operations have to be initiated by the calling application, the iOS
    and iCloud roaming strategy provides seamless integration to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Android and Backup API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Backup API and Google-provided backup transport services provide an
    easily accessible way for application developers to back up and restore application
    data to remote cloud storage. It is possible to restore data after a factory reset
    or one device to another using the APIs provided by the `BackupManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Backup operations are executed by the `BackupManager` in Android runtime and
    operations related to the application data are delegated to the `BackupAgent`
    registered in the application manifest. It is important to remember the fact that
    your application has to be registered in the Android Backup Service. It is crucial
    to include the backup service key that you receive from the registration in the
    package manifest.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a `BackupAgent`, you must implement the `OnBackup` and `OnRestore`
    methods of the `BackupAgent` abstract class. In these methods, the old and new
    states of your data are served in the form of `ParcelFileDescriptor` (file metadata
    that can be used to access the actual file). In the restore method, you also receive
    the application version that might be helpful if the data structure has changed
    between application updates.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to create an agent is to use the existing agent template (`BackupAgentHelper`)
    and use the existing helper classes to back up and restore certain subsets of
    your application data.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the `SharedPreferencesBackupHelper` class is a generic implementation
    of a backup operator on `SharedPreferences` files that are used by your application.
    The preferences groups for the application can be passed onto the helper and the
    helper class can deal with the backup logic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Another helper class is the `FileBackupHelper` class that can be used to back
    up and restore application files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate the Backup API and a usual backup scenario, we can
    create a backup agent that will trace out the backup events and method executions.
    The implementation class should derive from the `BackupAgentHelper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To include this backup agent in our application, we can either edit the application
    manifest or use the `ApplicationAttribute` attribute in the assembly info. Both
    `AssemblyInfo.cs` and `AndroidManifest.xml` can be found under the `Properties`
    project folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android and Backup API](img/B04693_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Application manifest and AssemblyInfo
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `ApplicationManifest.xml` file, let''s add the backup agent and backup
    services key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding application manifest entry is how it would look if we were dealing
    with Java class libraries, not Xamarin and the JNI Bridge. In fact, this registration
    would throw an error as soon as a backup request is received. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To register the `PreferencesBackupService` class with the Android runtime,
    we need to add an identifier for the type itself. Since we are not using a namespace
    qualifier in the manifest declaration, we can register the class in the application
    default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to use the `Application` attribute to register our backup agent
    without the application manifest entries, the attributes would look similar to
    the following using the `AssemblyInfo.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the **android callable wrapper** (**ACW**) is created with the
    default naming convention for our backup agent and inserted into the application
    manifest, so we didn''t need to register our class additionally. The generated
    entry for the application manifest contains the MD5 hash of the pair namespace
    and the containing assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are developing with Visual Studio and running your application on Emulator,
    you can see the generated MD5 values for the Android exposed classes in the `<projectdir>\obj\<buildconfig>\android\src`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android and Backup API](img/B04693_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android source directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the registration is complete, we can override a couple of methods in the
    agent class to get the trace information. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now open an Android Adb Console and use the following commands to trigger
    a backup request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Once your data segments change, you can use the `DataChanged` method of the
    `BackupManager` class and use it to request restore operations. (Restore operations
    are, under normal circumstances, scheduled and performed by Android backup services,
    so the app does not need to explicitly call it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: iOS and ubiquitous storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use iCloud features in your iOS applications, they must be configured
    in the *Apple Provisioning Portal* and the project manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the provisioning portal, while creating the App ID, iCloud must be selected
    as one of the enabled services. Then, using the `<TeamID>.<BundeID>` format, the
    container identifier must be inserted into the `Entitlements.plist` file. The
    keys that have to be edited are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: On iOS, the simplest synchronization mechanism provided is for primitive data
    types in the form of key/value pairs. This is used for simple user preferences
    or application required values that need to be synchronized between separate clients.
    The total size of a key/value pair cannot exceed 64 kilobytes, while the maximum
    value size is 64 kB and key size is 64 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The synchronizing context can be accessed through the `NSUbiquitousKeyValueStore`
    class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same store, you can access the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The synchronization process does not happen right after the synchronize method
    is invoked. The process is initiated according to iCloud's own schedule; up-sync
    generally happens within 5 seconds, while the only way to exactly know when the
    down-sync occurs is by adding an `Observer` delegate to the `NSUbiquitousKeyValueStore`
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For synchronized files, the implementation is a little more complicated. While
    backup and restore scenarios are automatically handled by the iOS application
    and iTunes, for keeping a synchronized file storage, developers need to implement
    the `UIDocument` class to prepare type of documents that needs to be synced between
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: The `UbiquityContainer` directory is managed by the so-called daemons to coordinate
    the synchronization and modifications of the files on the iCloud context. In order
    not to cause concurrency problems and interfere with the daemon processing, the
    files in question need to be accessed and modified with the `NSFilePresenter`
    and `NSFileCoordinator` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to use the presenters and coordinators for file operations is
    to implement the `UIDocument` base class. There are two virtual methods that need
    to be implemented to read data and write data to documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to keep a synchronized context for serialized entity
    data for our application. First, we need to declare our class as inheriting and
    implementing the required constructor from the `UIDocument` class. The code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to implement the two virtual methods. The following load method
    defined just deserializes the data from the cloud into the entity defined in the
    generic class type definition. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can implement the save method that will serialize the object and
    serve the stream to be saved in the ubiquitous container. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to use this implementation with an example class, named
    `LocationInfo`, we can first implement a load file procedure (we are using a single
    file query for each location loaded, but this can be extended using queries like
    `ENDSWITH` or `CONTAINS`). The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the query returns, we can expand the object into the data needed. The
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoadLocationInfo` function in the example would simply try to open the
    file and deal with the loaded data. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are also subscribing to the data changed event with the notification
    name we defined in the `EntityDocument<T>` class (`string.Format("{0}DocumentModified",
    m_Type.Name` ). The reload implementation is simply gathering the object from
    the notification itself. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For saving and synchronizing the data, we just need to assign the new data
    and update the change count on the `UIDocument` class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This topic will be discussed further in [Chapter 5](ch05.html "Chapter 5. Networking"),
    *Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed some of the local storage containers and access
    strategies. In both of the Xamarin platforms, with the additional option to back
    up and synchronize the data to the cloud, developers can create a consistent user
    interface as well as stateful mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the network connectivity options and how
    to use connected data together with local storage options provided with the target
    Xamarin platforms.
  prefs: []
  type: TYPE_NORMAL
