<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-20">
    <a id="_idTextAnchor020">
    </a>
    
     1
    
   </h1>
   <h1 id="_idParaDest-21">
    <a id="_idTextAnchor021">
    </a>
    
     Working with Component-Based Architecture
    
   </h1>
   <p>
    
     Welcome to
    
    <em class="italic">
     
      Blazor Web Development Cookbook
     
    </em>
    
     .
    
    
     This book will be your comprehensive guide to enhancing your skills in building dynamic and scalable web applications with Blazor.
    
    
     It offers a collection of practical solutions and techniques for tackling the most common challenges in web development.
    
    
     In each chapter, we’ll dive into different areas of application development.
    
    
     This book is packed with detailed examples and actionable tips.
    
    
     We’ll explore a range of topics – from optimizing components, through
    
    <a id="_idIndexMarker000">
    </a>
    
     managing
    
    <strong class="bold">
     
      application state
     
    </strong>
    
     to increasing your application’s interactivity and security.
    
    
     Having such a resource will allow you to gain development velocity and focus on addressing
    
    
     
      business requirements.
     
    
   </p>
   <p>
    
     In this chapter, you’ll learn about the core principles of component-based architecture in Blazor.
    
    
     We’ll start by creating a basic
    
    <strong class="bold">
     
      component
     
    </strong>
    
     and progress to more complex aspects such as parameterization for reusability and handling required parameters.
    
    
     We’ll also explore advanced topics, such as building components with customizable content, implementing generic
    
    <a id="_idIndexMarker001">
    </a>
    
     components, and increasing
    
    <strong class="bold">
     
      loose coupling
     
    </strong>
    
     
      with
     
    
    
     <strong class="source-inline">
      
       DynamicComponent
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     By the end
    
    <a id="_idIndexMarker002">
    </a>
    
     of this chapter, you’ll be able to implement and optimize components in
    
    <strong class="bold">
     
      Blazor
     
    </strong>
    
     .
    
    
     Understanding
    
    <strong class="bold">
     
      component-based architecture
     
    </strong>
    
     is foundational
    
    <a id="_idIndexMarker003">
    </a>
    
     in building more sophisticated, interactive, and responsive web applications.
    
    
     It’s also essential for writing scalable, maintainable, and
    
    
     
      reusable code.
     
    
   </p>
   <p>
    
     We’re going to cover the following recipes in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Initializing
     
     
      
       a project
      
     
    </li>
    <li>
     
      Creating your first
     
     
      
       basic component
      
     
    </li>
    <li>
     
      Declaring parameters on
     
     
      
       a component
      
     
    </li>
    <li>
     
      Detecting render mode
     
     
      
       at runtime
      
     
    </li>
    <li>
     
      Ensuring that a parameter
     
     
      
       is required
      
     
    </li>
    <li>
     
      Passing values from the parent component
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        CascadingParameter
       
      </strong>
     
    </li>
    <li>
     
      Creating components with
     
     
      
       customizable content
      
     
    </li>
    <li>
     
      Making
     
     
      
       components generic
      
     
    </li>
    <li>
     
      Decoupling components
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        DynamicComponent
       
      </strong>
     
    </li>
   </ul>
   <h1 id="_idParaDest-22">
    <a id="_idTextAnchor022">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     You don’t need any paid tools or add-ons to kick off your Blazor journey.
    
    
     To aid with this, we’ve decided to limit the dependencies for the recipes in this book.
    
    
     You can pick up any topic independently whenever you
    
    
     
      need to.
     
    
   </p>
   <p>
    
     For this chapter, you’ll need
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      A modern IDE.
     
     
      We’ll be using Visual Studio 17.12.0, but any other is also fine, so long as it supports development in .
     
     
      
       NET 9.
      
     
    </li>
    <li>
     
      A modern
     
     
      
       web browser.
      
     
    </li>
    <li>
     
      The .NET 9 SDK.
     
     
      If it wasn’t part of your IDE installation, you can get it
     
     
      
       from
      
     
     <a href="https://dotnet.microsoft.com/en-us/download/dotnet/9.0">
      
       
        https://dotnet.microsoft.com/en-us/download/dotnet/9.0
       
      
     </a>
     
      
       .
      
     
    </li>
   </ul>
   <p>
    
     You can find all the code examples for this chapter on GitHub
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter01">
     
      
       https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter01
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-23">
    <a id="_idTextAnchor023">
    </a>
    
     Initializing a project
    
   </h1>
   <p>
    
     With .NET 9, the .NET team focused on improving the quality, stability, and performance of Blazor
    
    <a id="_idIndexMarker004">
    </a>
    
     applications.
    
    
     Thankfully, there are no breaking changes between .NET 8, so you can safely raise the target framework of your application.
    
    
     However, with .NET 8, Blazor got a whole new solution type and rendering experience, so we’ll review the steps required to initialize a new
    
    
     
      project here.
     
    
   </p>
   <p>
    
     Let’s initialize a
    
    <strong class="bold">
     
      Blazor Web App
     
    </strong>
    
     with a per-component rendering scope.
    
    
     It’s a strategic choice for our cookbook as it enables me to highlight various render mode caveats while we explore different areas of
    
    
     
      web development.
     
    
   </p>
   <h2 id="_idParaDest-24">
    <a id="_idTextAnchor024">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In this recipe, we’ll showcase initializing the project with the GUI provided as part of Visual Studio.
    
    
     So, start your IDE and
    
    
     
      dive in.
     
    
   </p>
   <p>
    
     If you’re
    
    <a id="_idIndexMarker005">
    </a>
    
     using the
    
    <strong class="bold">
     
      .NET CLI
     
    </strong>
    
     in your environment, I’ll provide equivalent commands in the
    
    <em class="italic">
     
      There’s
     
    </em>
    
     <em class="italic">
      
       more...
      
     </em>
    
    
     
      section.
     
    
   </p>
   <h2 id="_idParaDest-25">
    <a id="_idTextAnchor025">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Perform the
    
    <a id="_idIndexMarker006">
    </a>
    
     following steps to initialize the Blazor Web
    
    
     
      App project:
     
    
   </p>
   <ol>
    <li>
     
      Start Visual Studio and select
     
     <strong class="bold">
      
       Create a new project
      
     </strong>
     
      from the
     
     
      
       welcome window:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.1: Navigating to the project creation panel" src="img/B22020_01_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.1: Navigating to the project creation panel
    
   </p>
   <ol>
    <li value="2">
     
      Use the search bar at the top of the next panel to narrow the list of available project
     
     <a id="_idIndexMarker007">
     </a>
     
      types, select
     
     <strong class="bold">
      
       Blazor Web App
      
     </strong>
     
      , and confirm your choice by
     
     
      
       clicking
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.2: Selecting Blazor Web App from the available project types" src="img/B22020_01_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.2: Selecting Blazor Web App from the available project types
    
   </p>
   <ol>
    <li value="3">
     
      On the
     
     <strong class="bold">
      
       Configure your new project
      
     </strong>
     
      panel, define the project’s name and location and confirm these details by
     
     
      
       clicking
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.3: Setting the name and location of the new project" src="img/B22020_01_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.3: Setting the name and location of the new project
    
   </p>
   <ol>
    <li value="4">
     
      On
     
     <a id="_idIndexMarker008">
     </a>
     
      the
     
     <strong class="bold">
      
       Additional information
      
     </strong>
     
      panel, choose the
     
     
      
       following options:
      
     
     <ul>
      <li>
       <strong class="bold">
        
         .NET 9.0 (Standard Term Support)
        
       </strong>
       
        
         under
        
       
       
        <strong class="bold">
         
          Framework
         
        </strong>
       
      </li>
      <li>
       <strong class="bold">
        
         Auto (Server and WebAssembly)
        
       </strong>
       
        under
       
       <strong class="bold">
        
         Interactive
        
       </strong>
       
        <strong class="bold">
         
          render mode
         
        </strong>
       
      </li>
      <li>
       <strong class="bold">
        
         Per page/component
        
       </strong>
       
        under
       
       
        <strong class="bold">
         
          Interactivity location
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       On top of that, check the
      
      <strong class="bold">
       
        Include sample pages
       
      </strong>
      
       checkbox.
      
      
       Confirm your choice by
      
      
       
        clicking
       
      
      
       <strong class="bold">
        
         Create
        
       </strong>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 1.4: Configuring the project’s framework and interactivity" src="img/B22020_01_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.4: Configuring the project’s framework and interactivity
    
   </p>
   <p class="list-inset">
    
     Here’s
    
    <a id="_idIndexMarker009">
    </a>
    
     what your initial solution structure will
    
    
     
      look like:
     
    
   </p>
   <div><div><img alt="Figure 1.5: Initial project structure" src="img/B22020_01_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.5: Initial project structure
    
   </p>
   <h2 id="_idParaDest-26">
    <a id="_idTextAnchor026">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we started Visual Studio and selected the
    
    <strong class="bold">
     
      Create a new project
     
    </strong>
    
     option from the welcome menu.
    
    
     Since Visual Studio comes with many project templates preinstalled, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we utilized the search bar at the top of the panel and, by searching for the
    
    <strong class="source-inline">
     
      blazor
     
    </strong>
    
     keyword, we quickly found and selected
    
    <strong class="bold">
     
      Blazor Web App
     
    </strong>
    
     from the results list.
    
    
     We proceeded to the next stage by clicking the
    
    <strong class="bold">
     
      Next
     
    </strong>
    
     button.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we defined the project name and location.
    
    
     For this book, I chose
    
    <strong class="source-inline">
     
      BlazorCookbook.App
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      D:\packt
     
    </strong>
    
     .
    
    
     We continued the setup process by
    
    
     
      clicking
     
    
    
     <strong class="bold">
      
       Next
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we configured the project.
    
    
     Considering that we’ll focus on Blazor in .NET 9, we chose
    
    <strong class="bold">
     
      .NET 9.0 (Standard Term Support)
     
    </strong>
    
     from the
    
    <strong class="bold">
     
      Framework
     
    </strong>
    
     dropdown.
    
    
     Then, we chose a
    
    <strong class="bold">
     
      render mode
     
    </strong>
    
     for our
    
    <a id="_idIndexMarker010">
    </a>
    
     application from the
    
    <strong class="bold">
     
      Interactive render mode
     
    </strong>
    
     dropdown.
    
    
     With the
    
    <strong class="bold">
     
      None
     
    </strong>
    
     option, we effectively indicate that Blazor should use
    
    <strong class="bold">
     
      server-side rendering
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SSR
     
    </strong>
    
     ) mode.
    
    
     SSR is the fastest render mode as the markup is
    
    <a id="_idIndexMarker011">
    </a>
    
     statically generated on the server but offers limited to no interactivity.
    
    
     When we expect interactivity, we must choose from the interactive modes.
    
    
     Here,
    
    <strong class="bold">
     
      Server
     
    </strong>
    
     (represented in the code as
    
    <strong class="source-inline">
     
      InteractiveServer
     
    </strong>
    
     ) renders
    
    <a id="_idIndexMarker012">
    </a>
    
     components on the server with UI interactions managed
    
    <a id="_idIndexMarker013">
    </a>
    
     via a
    
    <strong class="bold">
     
      SignalR
     
    </strong>
    
     connection, allowing dynamic content updates while keeping component logic server-side.
    
    
     Alternatively,
    
    <strong class="bold">
     
      WebAssembly
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     ) renders components directly in the browser using
    
    <strong class="bold">
     
      WebAssembly
     
    </strong>
    
     , facilitating fully interactive experiences without server communication
    
    <a id="_idIndexMarker014">
    </a>
    
     for UI updates.
    
    
     Lastly, with the
    
    <strong class="bold">
     
      Auto (Server and WebAssembly)
     
    </strong>
    
     option (
    
    <strong class="source-inline">
     
      InteractiveAuto
     
    </strong>
    
     ), we let Blazor select the best rendering method based on the current environment state and network conditions.
    
    
     We want to explore various render mode behaviors, so
    
    <strong class="bold">
     
      Auto (Server and Webassembly)
     
    </strong>
    
     was the best option for us.
    
    
     For
    
    <strong class="bold">
     
      Interactivity location
     
    </strong>
    
     , we selected
    
    <strong class="bold">
     
      Per page/component
     
    </strong>
    
     so that we can define render modes at the component level, as opposed to
    
    <strong class="bold">
     
      Global
     
    </strong>
    
     , which would set the render mode globally across the project.
    
    
     We also checked the
    
    <strong class="bold">
     
      Include sample pages
     
    </strong>
    
     box to trigger the scaffold of a basic layout and CSS.
    
    
     We intentionally left
    
    <strong class="bold">
     
      Authentication type
     
    </strong>
    
     set to
    
    <strong class="bold">
     
      None
     
    </strong>
    
     to avoid unnecessary complexity, although we plan to revisit authentication in
    
    <a href="B22020_08.xhtml#_idTextAnchor273">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     .
    
    
     We finalized the project creation process by
    
    
     
      clicking
     
    
    
     <strong class="bold">
      
       Create
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     At this point, you should see the initial project structure.
    
    
     If you spot two projects,
    
    <strong class="source-inline">
     
      BlazorCookbook.App
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      BlazorCookbook.App.Client
     
    </strong>
    
     , that’s correct.
    
    
     Here,
    
    <strong class="source-inline">
     
      BlazorCookbook.App
     
    </strong>
    
     represents the server-side components of our application, while
    
    <strong class="source-inline">
     
      BlazorCookbook.App.Client
     
    </strong>
    
     is the client-side part that compiles into WebAssembly code.
    
    
     Everything that’s placed in
    
    <strong class="source-inline">
     
      BlazorCookbook.App.Client
     
    </strong>
    
     will be transmitted to the user’s browser, so you shouldn’t place any sensitive or confidential information there.
    
    
     Since
    
    <strong class="source-inline">
     
      BlazorCookbook.App
     
    </strong>
    
     references
    
    <strong class="source-inline">
     
      BlazorCookbook.App.Client
     
    </strong>
    
     , there’s no need to duplicate code, regardless of how it’s
    
    
     
      rendered initially.
     
    
   </p>
   <h2 id="_idParaDest-27">
    <a id="_idTextAnchor027">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     If your IDE doesn’t have a GUI similar to Visual Studio, you can leverage the cross-platform .NET CLI.
    
    
     Navigate to your working directory and run the following command to initialize a
    
    <a id="_idIndexMarker015">
    </a>
    
     Blazor Web App project with the same configuration that was outlined in
    
    
     <em class="italic">
      
       step 4
      
     </em>
    
    
     
      :
     
    
   </p>
   <pre class="console">
dotnet new blazor -o BlazorCookbook.App -int Auto --framework net9.0</pre>
   <h1 id="_idParaDest-28">
    <a id="_idTextAnchor028">
    </a>
    
     Creating your first basic component
    
   </h1>
   <p>
    
     A component is a
    
    <a id="_idIndexMarker016">
    </a>
    
     self-contained chunk of the
    
    <strong class="bold">
     
      user interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      UI
     
    </strong>
    
     ).
    
    
     A component in
    
    <a id="_idIndexMarker017">
    </a>
    
     Blazor is a .NET class with markup, created as a
    
    <strong class="bold">
     
      Razor
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      .razor
     
    </strong>
    
     ) file.
    
    
     In Blazor, components are the primary building blocks of any application and encapsulate markup, logic, and styling.
    
    
     They enable code reusability and increase code maintainability and testability.
    
    
     This modular approach streamlines the development
    
    
     
      process greatly.
     
    
   </p>
   <p>
    
     For our first
    
    <a id="_idIndexMarker018">
    </a>
    
     component, we’ll create a
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component that renders a tariff name and a price when the user navigates to
    
    
     
      a page.
     
    
   </p>
   <h2 id="_idParaDest-29">
    <a id="_idTextAnchor029">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into creating the first component, in your Blazor project, create a
    
    <strong class="source-inline">
     
      Recipe02
     
    </strong>
    
     directory – this will be your
    
    
     
      working directory.
     
    
   </p>
   <h2 id="_idParaDest-30">
    <a id="_idTextAnchor030">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Follow these steps to create your
    
    
     
      first component:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory that you
     
     
      
       just created.
      
     
    </li>
    <li>
     
      Use the
     
     <strong class="bold">
      
       Add New Item
      
     </strong>
     
      feature and create a
     
     
      
       Razor component:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.6: Adding a new Razor component prompt" src="img/B22020_01_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.6: Adding a new Razor component prompt
    
   </p>
   <ol>
    <li value="3">
     
      In the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component, add supporting
     
     
      
       HTML markup:
      
     
     <pre class="source-code">
&lt;div class="ticket"&gt;
    &lt;div class="name"&gt;Adult&lt;/div&gt;
    &lt;div class="price"&gt;10.00 $&lt;/div&gt;
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Add a
     
     <a id="_idIndexMarker019">
     </a>
     
      new
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component.
     
     
      Use the
     
     <strong class="source-inline">
      
       @page
      
     </strong>
     
      directive to make it navigable and render the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      
       component within:
      
     
     <pre class="source-code">
@page "/ch01r02"
&lt;Ticket /&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-31">
    <a id="_idTextAnchor031">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigated to
    
    <strong class="source-inline">
     
      Recipe02
     
    </strong>
    
     – our working directory.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we leveraged a built-in Visual Studio prompt to create files and create the first component:
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     .
    
    
     While building components in the Razor markup syntax, we named our component file
    
    <strong class="source-inline">
     
      Ticket.razor
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we added simple markup to
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     – we rendered
    
    <strong class="bold">
     
      Adult
     
    </strong>
    
     and
    
    <strong class="bold">
     
      10.00 $
     
    </strong>
    
     , which describe a given ticket.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we created our first page – the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     page.
    
    
     In Blazor, any component can become a page with the help of a
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directive, which requires a fixed path argument starting with
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      @page "/ch01r02"
     
    </strong>
    
     directive enables navigation to that component.
    
    
     In the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     markup, we embedded
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     using
    
    <a id="_idIndexMarker020">
    </a>
    
     the
    
    <strong class="bold">
     
      self-closing tag
     
    </strong>
    
     syntax – a simpler, more convenient equivalent of the explicit opening and closing tags (
    
    <strong class="source-inline">
     
      &lt;Ticket&gt;&lt;/Ticket&gt;
     
    </strong>
    
     ).
    
    
     However, we can only utilize it when the component doesn’t require any additional content
    
    
     
      to render.
     
    
   </p>
   <h2 id="_idParaDest-32">
    <a id="_idTextAnchor032">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     While componentization in Blazor offers numerous benefits, it’s essential to know when and how much to use it.
    
    
     Components are a great way to reuse representation markup with various data objects.
    
    
     They significantly enhance code readability and testability.
    
    
     However, caution is necessary – you can overdo componentization.
    
    
     Using too many components leads to increased reflection overhead and unnecessary complexities in managing render modes.
    
    
     It’s especially easy to overlook when you’re refactoring grids or forms.
    
    
     Ask yourself whether every cell must be a component and whether you need that input encapsulated.
    
    
     Always weigh what you might gain from higher markup granularity with the performance cost
    
    
     
      it brings.
     
    
   </p>
   <h1 id="_idParaDest-33">
    <a id="_idTextAnchor033">
    </a>
    
     Declaring parameters on a component
    
   </h1>
   <p>
    
     In Blazor, component parameters allow you to pass data into components.
    
    
     It’s the first step in making
    
    <a id="_idIndexMarker021">
    </a>
    
     your application dynamic.
    
    
     Component parameters are like method parameters in traditional programming.
    
    
     You can utilize the same primitive, as well as the reference and complex types.
    
    
     This results in code flexibility, simplified UI structures, and high
    
    
     
      markup reusability.
     
    
   </p>
   <p>
    
     Let’s create a parametrized component that represents a ticket so that we can display any incoming tariff and price without unnecessary code duplication or
    
    
     
      markup incoherence.
     
    
   </p>
   <h2 id="_idParaDest-34">
    <a id="_idTextAnchor034">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into component parameterization, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Creating your first basic component
      
     </em>
     
      recipe or copy its implementation from the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory of this book’s
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-35">
    <a id="_idTextAnchor035">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     To declare
    
    <a id="_idIndexMarker022">
    </a>
    
     parameters on your component, start with these
    
    
     
      foundational steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component, declare parameters in the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        code
       
      </strong>
     
     
      
       block:
      
     
     <pre class="source-code">
@code {
    [Parameter] public string Tariff { get; set; }
    [Parameter] public decimal Price { get; set; }
    [Parameter]
    public EventCallback OnAdded { get; set; }
}</pre>
    </li>
    <li>
     
      Modify the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      markup so that you can render values
     
     
      
       from parameters:
      
     
     <pre class="source-code">
&lt;div class="ticket"&gt;
    &lt;div class="name"&gt;@Tariff&lt;/div&gt;
    &lt;div class="price"&gt;
        @(Price.ToString("0.00 $"))
    &lt;/div&gt;
    &lt;div class="ticket-actions"&gt;
        &lt;button @onclick="@OnAdded"&gt;
            Add to cart
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      page and enhance it so that it renders in
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch01r03"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      Below the functional directives in the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component, add two parametrized instances of
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      .
     
     
      Implement an
     
     <strong class="source-inline">
      
       Add()
      
     </strong>
     
      method as a placeholder
     
     
      
       for interactivity:
      
     
     <pre class="source-code">
&lt;Ticket Tariff="Adult" Price="10.00m"
        OnAdded="@Add" /&gt;
&lt;Ticket Tariff="Child" Price="5.00m"
        OnAdded="@Add" /&gt;
@code {
    private void Add()
        =&gt; Console.WriteLine("Added to cart!");
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-36">
    <a id="_idTextAnchor036">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we extended the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component with a
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, which Blazor recognizes
    
    <a id="_idIndexMarker023">
    </a>
    
     as a container for the C# code.
    
    
     Within this
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, we used the
    
    <strong class="source-inline">
     
      Parameter
     
    </strong>
    
     attribute to mark properties that are settable externally, such as method arguments in C#.
    
    
     In our example, we used a string for a ticket tariff and a decimal for its price.
    
    
     For the last parameter, we used the
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     type.
    
    
     It’s a Blazor-specific
    
    <strong class="source-inline">
     
      struct
     
    </strong>
    
     that carries an invokable action with an additional benefit.
    
    
     When you change the UI state, you should use the
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     life cycle method to notify Blazor that something happened.
    
    
     By design,
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     triggers
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     automatically, so you can’t omit it accidentally.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we rebuilt the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     markup based on parameter values that we accessed using the
    
    <strong class="source-inline">
     
      @
     
    </strong>
    
     symbol.
    
    
     That symbol signaled to the compiler that we were switching to dynamic C# code.
    
    
     If you pair it with round brackets, you can embed complex code blocks as well, as we did when we formatted the price in a
    
    
     
      money format.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we created a navigable
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     page.
    
    
     This time, on top of the
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directive, we also declared a
    
    <strong class="source-inline">
     
      @rendermode
     
    </strong>
    
     directive, which allowed us to control how our component renders initially.
    
    
     We can choose from any of the render modes that a Blazor Web App supports, but as we expect some interactivity on the page, we opted for
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , in the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     , we implemented an
    
    <strong class="source-inline">
     
      Add()
     
    </strong>
    
     placeholder method that simulates adding a ticket to the cart.
    
    
     We also implemented the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     markup, where we rendered two
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     instances with different
    
    <a id="_idIndexMarker024">
    </a>
    
     parameters.
    
    
     You pass parameter values similarly to standard HTML attributes such as
    
    <strong class="source-inline">
     
      class
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      style
     
    </strong>
    
     .
    
    
     Blazor automatically recognizes that you’re calling a component, not an HTML element.
    
    
     Finally, we rendered
    
    <strong class="bold">
     
      Adult
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Child
     
    </strong>
    
     tickets and attached the
    
    <strong class="source-inline">
     
      Add()
     
    </strong>
    
     method to the exposed
    
    
     <strong class="source-inline">
      
       EventCallback
      
     </strong>
    
    
     
      parameter.
     
    
   </p>
   <h2 id="_idParaDest-37">
    <a id="_idTextAnchor037">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     You must be aware that the number of parameters can directly affect the rendering speed.
    
    
     That’s because the renderer uses reflection to resolve parameter values.
    
    
     Over-reliance on reflection can significantly hinder performance.
    
    
     You can optimize that process by
    
    <a id="_idIndexMarker025">
    </a>
    
     overriding the
    
    <strong class="source-inline">
     
      SetParametersAsync()
     
    </strong>
    
     method of the component life cycle, though that’s an advanced operation.
    
    
     Instead, you should focus on keeping the parameters list concise or introducing wrapper classes
    
    
     
      where necessary.
     
    
   </p>
   <p>
    
     Earlier in this chapter, we declared a specific render mode for a component when your Blazor application is set to expect interactivity at the page or component level.
    
    
     However, when you enable interactivity globally, you can still exclude certain pages from interactive routing.
    
    
     You’ll find it useful for pages that depend on standard request/response cycles or reading or writing
    
    
     
      HTTP cookies:
     
    
   </p>
   <pre class="source-code">
@attribute [ExcludeFromInteractiveRouting]</pre>
   <p>
    
     To enforce static server-side rendering on a page, you must add the
    
    <strong class="source-inline">
     
      ExcludeFromInteractiveRouting
     
    </strong>
    
     attribute, using the
    
    <strong class="source-inline">
     
      @attribute
     
    </strong>
    
     directive, at the top of the page.
    
    
     In this case, you no longer add the
    
    <strong class="source-inline">
     
      @rendermode
     
    </strong>
    
     directive as it’s dedicated to declaring interactive
    
    
     
      render modes.
     
    
   </p>
   <h1 id="_idParaDest-38">
    <a id="_idTextAnchor038">
    </a>
    
     Detecting render mode at runtime
    
   </h1>
   <p>
    
     Understanding where and how your component renders is crucial for optimizing performance and tailoring user experience.
    
    
     Blazor allows you to detect the render location, interactivity, and assigned render mode at runtime.
    
    
     You can query whether the component is
    
    <a id="_idIndexMarker026">
    </a>
    
     operating in an interactive state or just prerendering.
    
    
     These insights open up new possibilities for debugging, performance optimization, and building components that adapt dynamically to their
    
    
     
      rendering context.
     
    
   </p>
   <p>
    
     Let’s hide the area with tickets in the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     component to prevent user interactions, such as adding tickets to the cart, until the component is ready
    
    
     
      and interactive.
     
    
   </p>
   <h2 id="_idParaDest-39">
    <a id="_idTextAnchor039">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you explore render mode detection, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      components from the
     
     <em class="italic">
      
       Declaring parameters on a component
      
     </em>
     
      recipe or copy their implementations from the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory of this book’s
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-40">
    <a id="_idTextAnchor040">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component and update the path attached to the
     
     <strong class="source-inline">
      
       @page
      
     </strong>
     
      directive to avoid
     
     
      
       routing conflicts:
      
     
     <pre class="source-code">
@page "/ch01r04"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      Below the component directives, add some conditional markup to indicate that the component is getting ready based on the value of the
     
     
      <strong class="source-inline">
       
        RendererInfo.IsInteractive
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
@if (!RendererInfo.IsInteractive)
{
    &lt;p&gt;Getting ready...&lt;/p&gt;
    return;
}
@* existing markup is obscured, but still down here *@</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-41">
    <a id="_idTextAnchor041">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      s
     
    </em>
    <em class="italic">
     
      tep 1
     
    </em>
    
     , we navigated to the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     component and updated the path that was assigned to the
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directive.
    
    
     Blazor doesn’t allow duplicated routes, so we triggered a conflict since we copied the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     component with a route from the
    
    <em class="italic">
     
      Declaring parameters on a
     
    </em>
    
     <em class="italic">
      
       component
      
     </em>
    
    
     
      recipe.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we introduced a conditional markup block below the component directives.
    
    
     We leveraged the
    
    <strong class="source-inline">
     
      RendererInfo
     
    </strong>
    
     property that the
    
    <strong class="source-inline">
     
      ComponentBase
     
    </strong>
    
     class exposes, allowing us
    
    <a id="_idIndexMarker027">
    </a>
    
     to track the component rendering state.
    
    
     The
    
    <strong class="source-inline">
     
      RendererInfo
     
    </strong>
    
     property has
    
    
     
      two properties:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     <strong class="source-inline">
      
       RendererInfo.Name
      
     </strong>
     
      property
     
     <a id="_idIndexMarker028">
     </a>
     
      tells us where the component is currently
     
     <a id="_idIndexMarker029">
     </a>
     
      running and returns the
     
     
      
       following options:
      
     
     <ul>
      <li>
       <strong class="source-inline">
        
         Static
        
       </strong>
       
        : This
       
       <a id="_idIndexMarker030">
       </a>
       
        indicates that the component is running on the server without
       
       
        
         any interactivity
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         Server
        
       </strong>
       
        : This
       
       <a id="_idIndexMarker031">
       </a>
       
        indicates that the component is running on the server and will be interactive after it
       
       
        
         fully loads
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         WebAssembly
        
       </strong>
       
        : This
       
       <a id="_idIndexMarker032">
       </a>
       
        indicates that the component is running in the client’s browser and becomes interactive
       
       
        
         after loading
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         WebView
        
       </strong>
       
        : This
       
       <a id="_idIndexMarker033">
       </a>
       
        indicates that it’s dedicated to .NET MAUI and
       
       
        
         native devices
        
       
      </li>
     </ul>
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       RendererInfo.IsInteractive
      
     </strong>
     
      property shows whether the component
     
     <a id="_idIndexMarker034">
     </a>
     
      is in an interactive state or not (such as during prerendering or
     
     
      
       static SSR)
      
     
    </li>
   </ul>
   <p>
    
     We leveraged the
    
    <strong class="source-inline">
     
      RendererInfo.IsInteractive
     
    </strong>
    
     property to detect whether the interactivity is ready.
    
    
     If it isn’t, we display a
    
    <strong class="bold">
     
      Getting ready...
     
    </strong>
    
     message to inform users they
    
    
     
      should wait.
     
    
   </p>
   <h1 id="_idParaDest-42">
    <a id="_idTextAnchor042">
    </a>
    
     Ensuring that a parameter is required
    
   </h1>
   <p>
    
     The
    
    <strong class="source-inline">
     
      EditorRequired
     
    </strong>
    
     attribute indicates to your IDE that passing data to the component is functionally critical.
    
    
     This attribute triggers data validation at compile time, creating a
    
    <a id="_idIndexMarker035">
    </a>
    
     quick feedback loop and enhancing code quality.
    
    
     Utilizing the
    
    <strong class="source-inline">
     
      EditorRequired
     
    </strong>
    
     attribute ensures neither you nor anyone from your team will fall into errors due to missing parameters.
    
    
     You can simplify your code by skipping initial parameter value validation.
    
    
     Using the
    
    <strong class="source-inline">
     
      EditorRequired
     
    </strong>
    
     attribute leads to robust and predictable component behavior throughout
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Let’s enhance the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component parameters so that Blazor treats them as required.
    
    
     You’ll also learn how to configure your IDE so that you can flag any missing required parameters as
    
    
     
      compilation errors.
     
    
   </p>
   <h2 id="_idParaDest-43">
    <a id="_idTextAnchor043">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before setting up the required parameters, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      components from the previous recipe or copy their implementation from the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory of this book’s
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor044">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Ensure parameters are required in your component by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component and extend attribute collection on parameters with the
     
     
      <strong class="source-inline">
       
        EditorRequired
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public string Tariff { get; set; }
    [Parameter, EditorRequired]
    public decimal Price { get; set; }
    [Parameter]
    public EventCallback OnAdded { get; set; }
}</pre>
    </li>
    <li>
     
      Now, navigate
     
     <a id="_idIndexMarker036">
     </a>
     
      to the
     
     <strong class="source-inline">
      
       .csproj
      
     </strong>
     
      file of the project where you’re keeping
     
     
      
       your components.
      
     
    </li>
    <li>
     
      Add the
     
     <strong class="source-inline">
      
       RZ2012
      
     </strong>
     
      code to the
     
     
      <strong class="source-inline">
       
        WarningsAsErrors
       
      </strong>
     
     
      
       section:
      
     
     <pre class="source-code">
&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;WarningsAsErrors&gt;RZ2012&lt;/WarningsAsErrors&gt;
  &lt;/PropertyGroup&gt;
  &lt;!-- ... --&gt;
&lt;/Project&gt;</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      markup, modify the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      instances by removing the
     
     <strong class="source-inline">
      
       OnAdded
      
     </strong>
     
      parameter from both.
     
     
      Additionally, remove the
     
     <strong class="source-inline">
      
       Price
      
     </strong>
     
      parameter from the
     
     
      
       second instance:
      
     
     <pre class="source-code">
&lt;Ticket Tariff="Adult" Price="10.00m" /&gt;
&lt;Ticket Tariff="Child" /&gt;</pre>
    </li>
    <li>
     
      Compile your application so that you can see your IDE flagging the omitted but required
     
     
      <strong class="source-inline">
       
        Price
       
      </strong>
     
     
      
       parameter:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.7: IDE flags missing the Price parameter as a compilation error" src="img/B22020_01_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.7: IDE flags missing the Price parameter as a compilation error
    
   </p>
   <h2 id="_idParaDest-45">
    <a id="_idTextAnchor045">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      s
     
    </em>
    <em class="italic">
     
      tep 1
     
    </em>
    
     , we enhanced the
    
    <strong class="source-inline">
     
      Tariff
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Price
     
    </strong>
    
     parameters of the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component with the
    
    <strong class="source-inline">
     
      EditorRequired
     
    </strong>
    
     attribute.
    
    
     This prompts your IDE to expect these values during compilation and flag the missing ones as warnings by default.
    
    
     I suggest that
    
    <a id="_idIndexMarker037">
    </a>
    
     you raise that severity.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , you navigated to the
    
    <strong class="source-inline">
     
      .csproj
     
    </strong>
    
     file of your project.
    
    
     Here, as outlined in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , you either found or added the
    
    <strong class="source-inline">
     
      WarningsAsErrors
     
    </strong>
    
     section and included the
    
    <strong class="source-inline">
     
      RZ2012
     
    </strong>
    
     code within.
    
    
     In
    
    <em class="italic">
     
      s
     
    </em>
    <em class="italic">
     
      tep 4
     
    </em>
    
     , we broke the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     markup a little.
    
    
     We removed the
    
    <strong class="source-inline">
     
      OnAdded
     
    </strong>
    
     parameter from both
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     instances and the
    
    <strong class="source-inline">
     
      Price
     
    </strong>
    
     parameter from one of them.
    
    
     Now, any compilation attempt will end with an error, similar to the one shown in
    
    <em class="italic">
     
      step 5
     
    </em>
    
     .
    
    
     This makes it practically impossible to miss required assignments and encounter related rendering errors.
    
    
     Notice that as we didn’t mark the
    
    <strong class="source-inline">
     
      OnAdded
     
    </strong>
    
     parameter with the
    
    <strong class="source-inline">
     
      EditorRequired
     
    </strong>
    
     attribute, the compiler will treat it as optional and allow it to
    
    
     
      be skipped.
     
    
   </p>
   <h1 id="_idParaDest-46">
    <a id="_idTextAnchor046">
    </a>
    
     Passing values from the parent component with CascadingParameter
    
   </h1>
   <p>
    
     Sharing
    
    <a id="_idIndexMarker038">
    </a>
    
     parameters across
    
    <a id="_idIndexMarker039">
    </a>
    
     multiple components is a common scenario in web applications.
    
    
     It boosts performance as data can be shared rather than being requested from an external source by each component.
    
    
     It also simplifies the code, especially in parent-child scenarios.
    
    
     In Blazor, that’s where the concept of
    
    <strong class="source-inline">
     
      CascadingParameter
     
    </strong>
    
     comes into play.
    
    
     Its counterpart,
    
    <strong class="source-inline">
     
      CascadingValue
     
    </strong>
    
     , allows you to provide a value that cascades down the component tree.
    
    
     This pair enables child components to receive and use this shared data or state.
    
    
     This approach solves the challenge of passing information through component hierarchies without complex plumbing or tightly
    
    
     
      coupled communication.
     
    
   </p>
   <p>
    
     Let’s implement a
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     service and pass it downward in a cascading fashion so that we can intercept it within the offer area represented by
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     components.
    
    
     We’ll also render the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     summary – fully decoupled from the
    
    
     <strong class="source-inline">
      
       Ticket
      
     </strong>
    
    
     
      behavior.
     
    
   </p>
   <h2 id="_idParaDest-47">
    <a id="_idTextAnchor047">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before
    
    <a id="_idIndexMarker040">
    </a>
    
     we start exploring
    
    <a id="_idIndexMarker041">
    </a>
    
     how to pass the cascading value, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Ensuring that a parameter is required
      
     </em>
     
      recipe or copy its implementation from the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory of this book’s
     
     
      
       GitHub repository.
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-48">
    <a id="_idTextAnchor048">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Follow
    
    <a id="_idIndexMarker042">
    </a>
    
     these steps to implement
    
    <strong class="source-inline">
     
      CascadingParameter
     
    </strong>
    
     for
    
    
     
      value sharing:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      class and declare supporting
     
     <strong class="source-inline">
      
       Content
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Value
      
     </strong>
     
      properties.
     
     
      Extend
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      so that you can communicate state changes by requiring a fallback
     
     <strong class="source-inline">
      
       Action
      
     </strong>
     
      property with a primary constructor and implement the basic
     
     <strong class="source-inline">
      
       Add()
      
     </strong>
     
      method that triggers
     
     
      
       this notification:
      
     
     <pre class="source-code">
public class Cart(Action onStateHasChanged)
{
    public List&lt;string&gt; Content { get; init; } = [];
    public decimal Value { get; private set; }
    public int Volume =&gt; Content.Count;
    public void Add(string tariff, decimal price)
    {
        Content.Add(tariff);
        Value += price;
        onStateHasChanged.Invoke();
    }
}</pre>
    </li>
    <li>
     
      Create
     
     <a id="_idIndexMarker043">
     </a>
     
      a
     
     <strong class="source-inline">
      
       SellingTickets
      
     </strong>
     
      component so that our tickets can
     
     
      
       be sold:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.8: Adding a new SellingTickets component" src="img/B22020_01_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.8: Adding a new SellingTickets component
    
   </p>
   <ol>
    <li value="3">
     
      Use the
     
     <strong class="source-inline">
      
       @rendermode
      
     </strong>
     
      attribute to declare that
     
     <strong class="source-inline">
      
       SellingTickets
      
     </strong>
     
      operates in
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      mode and a
     
     <strong class="source-inline">
      
       @page
      
     </strong>
     
      directive to
     
     
      
       enable routing:
      
     
     <pre class="source-code">
@page "/ch01r06"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       SellingTickets
      
     </strong>
     
      , declare the
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      object and initialize it within the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      life
     
     
      
       cycle method:
      
     
     <pre class="source-code">
@code {
    protected Cart Cart;
    protected override void OnInitialized()
    {
        Cart = new(() =&gt;
            InvokeAsync(StateHasChanged));
    }
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       SellingTickets
      
     </strong>
     
      markup, add the
     
     <strong class="source-inline">
      
       CascadingValue
      
     </strong>
     
      wrapper with the
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      instance as its value.
     
     
      Declare two sellable tickets within the cart’s operational scope, leveraging the
     
     
      <strong class="source-inline">
       
        Ticket
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
&lt;CascadingValue Value="Cart"&gt;
    &lt;Ticket Tariff="Adult" Price="10.00m" /&gt;
    &lt;Ticket Tariff="Child" Price="5.00m" /&gt;
&lt;/CascadingValue&gt;</pre>
    </li>
    <li>
     
      Below
     
     <a id="_idIndexMarker044">
     </a>
     
      the
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      area of the
     
     <strong class="source-inline">
      
       SellingTickets
      
     </strong>
     
      markup, append additional markup to display the
     
     
      <strong class="source-inline">
       
        Cart
       
      </strong>
     
     
      
       summary:
      
     
     <pre class="source-code">
&lt;div class="cart-summary"&gt;
    &lt;div class="cart-content"&gt;
        Items: @Cart.Volume
    &lt;/div&gt;
    &lt;div class="cart-value"&gt;Price: @Cart.Value&lt;/div&gt;
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component.
     
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, declare
     
     <strong class="source-inline">
      
       CascadingParameter
      
     </strong>
     
      so that you can intercept the
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      instance and replace the
     
     <strong class="source-inline">
      
       OnAdded
      
     </strong>
     
      parameter with an
     
     
      <strong class="source-inline">
       
        Add()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
@code {
    [CascadingParameter]
    public Cart Cart { get; set; }
    public void Add() =&gt; Cart.Add(Tariff, Price);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      markup, replace the
     
     <strong class="source-inline">
      
       @onclick
      
     </strong>
     
      button action so that you can execute the new
     
     
      <strong class="source-inline">
       
        Add()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
&lt;div class="ticket-actions"&gt;
    &lt;button @onclick="@Add"&gt;Add to cart&lt;/button&gt;
&lt;/div&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-49">
    <a id="_idTextAnchor049">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we implemented the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     class.
    
    
     We declared a
    
    <strong class="source-inline">
     
      Value
     
    </strong>
    
     property to hold the current cart value and a
    
    <strong class="source-inline">
     
      Content
     
    </strong>
    
     collection to store added ticket tariffs.
    
    
     We also implemented a parameterless
    
    <strong class="source-inline">
     
      Volume
     
    </strong>
    
     method to calculate the amount of tickets currently
    
    <a id="_idIndexMarker045">
    </a>
    
     in the cart.
    
    
     Then, we implemented an
    
    <strong class="source-inline">
     
      Add()
     
    </strong>
    
     method that, in addition to the normal logic for adding to the cart, is responsible for communicating those changes to external objects by invoking the
    
    <strong class="source-inline">
     
      onStateHasChanged
     
    </strong>
    
     delegate, which
    
    <a id="_idIndexMarker046">
    </a>
    
     is passed using the
    
    <strong class="bold">
     
      primary constructor
     
    </strong>
    
     pattern.
    
    
     That way, we ensured
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     initialization requires us to provide an action to execute upon
    
    
     
      state changes.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we created a
    
    <strong class="source-inline">
     
      SellingTickets
     
    </strong>
    
     component.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we declared it to render in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode and leveraged the
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directive to enable routing.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , in the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      SellingTickets
     
    </strong>
    
     , we declared a
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     instance.
    
    
     We initialized
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     as part of the overridden
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     life cycle method and, as an invokable
    
    <strong class="source-inline">
     
      Action
     
    </strong>
    
     delegate responsible for applying state changes, we passed in the
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     life cycle method.
    
    
     With that in place, any change in the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     object will prompt Blazor to recalculate DOM changes at the level of the
    
    <strong class="source-inline">
     
      SellingTicket
     
    </strong>
    
     component.
    
    
     To avoid any threading or race condition issues, we wrapped the
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     method in the
    
    <strong class="source-inline">
     
      InvokeAsync()
     
    </strong>
    
     component base method.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we implemented the
    
    <strong class="source-inline">
     
      SellingTickets
     
    </strong>
    
     markup.
    
    
     We used a
    
    <strong class="source-inline">
     
      CascadingValue
     
    </strong>
    
     component and assigned
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     as its value.
    
    
     We also declared
    
    <strong class="source-inline">
     
      CascadingValue
     
    </strong>
    
     content by adding two
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     instances, representing tickets available for sale.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we extended the
    
    <strong class="source-inline">
     
      SellingTickets
     
    </strong>
    
     markup further by adding a section that contained the summary of the cart, showing its current size
    
    
     
      and value.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we navigated to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component and declared
    
    <strong class="source-inline">
     
      CascadingParameter
     
    </strong>
    
     there.
    
    
     Blazor will intercept this parameter’s value as it cascades from a parent component.
    
    
     Notably, we didn’t use
    
    <strong class="source-inline">
     
      EditorRequired
     
    </strong>
    
     here – as Blazor
    
    <a id="_idIndexMarker047">
    </a>
    
     resolves the cascading value just in time, it would have no impact on compilation.
    
    
     With
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     available in the scope of the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component, we replaced the existing
    
    <strong class="source-inline">
     
      OnAdded
     
    </strong>
    
     parameter with an
    
    <strong class="source-inline">
     
      Add()
     
    </strong>
    
     method that invokes
    
    <strong class="source-inline">
     
      Cart.Add()
     
    </strong>
    
     directly.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we updated the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     markup by replacing the outdated
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     assignment on the existing button with a reference to the newly implemented
    
    
     <strong class="source-inline">
      
       Add()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-50">
    <a id="_idTextAnchor050">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     So, why does the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     implementation require an
    
    <strong class="source-inline">
     
      Action
     
    </strong>
    
     delegate to work?
    
    
     Here,
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     is a component life cycle method, so it triggers DOM re-rendering scoped to that component and its nested children.
    
    
     Since adding to the cart happens at the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component level and invokes
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     , there’s no impact on the parent
    
    <strong class="source-inline">
     
      SellingTickets
     
    </strong>
    
     component, and the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     summary section remains unchanged!
    
    
     Having the
    
    <strong class="source-inline">
     
      Action
     
    </strong>
    
     delegate allows the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     object to persist a reference to the origin component and thus trigger a DOM update at any level of the
    
    
     
      component tree.
     
    
   </p>
   <h1 id="_idParaDest-51">
    <a id="_idTextAnchor051">
    </a>
    
     Creating components with customizable content
    
   </h1>
   <p>
    
     Creating components with customizable content in Blazor applications is another level in building
    
    <a id="_idIndexMarker048">
    </a>
    
     flexible and reusable UI elements.
    
    
     This approach allows you to design functional components that can be
    
    <a id="_idIndexMarker049">
    </a>
    
     adapted to various content needs and data types.
    
    
     We’ll utilize the
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     feature to address it.
    
    
     The
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     feature
    
    <a id="_idIndexMarker050">
    </a>
    
     represents a segment of UI content.
    
    
     It allows components to accept arbitrary HTML markup as a parameter.
    
    
     That’s how you can achieve higher flexibility.
    
    
     You can repurpose a single component structure with different content, enhancing the modularity and reusability of your
    
    
     
      code base.
     
    
   </p>
   <p>
    
     Let’s create a
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component with a customizable display of ticket details while keeping a fixed button so that you can add the ticket to
    
    
     
      a cart.
     
    
   </p>
   <h2 id="_idParaDest-52">
    <a id="_idTextAnchor052">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you start implementing a component with customizable content, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory, which contains the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TicketViewModel
      
     </strong>
     
      objects required for this recipe, next to the
     
     
      
       working directory
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-53">
    <a id="_idTextAnchor053">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Follow
    
    <a id="_idIndexMarker051">
    </a>
    
     these steps to build a component
    
    <a id="_idIndexMarker052">
    </a>
    
     with
    
    
     
      customizable content:
     
    
   </p>
   <ol>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component.
     
     
      We’ll use this to display individual
     
     
      
       ticket details.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      , add the
     
     <strong class="source-inline">
      
       Id
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       ChildContent
      
     </strong>
     
      parameters and an
     
     <strong class="source-inline">
      
       Add()
      
     </strong>
     
      placeholder method that simply writes a console message displaying the ID of the ticket that was added to
     
     
      
       the cart:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public Guid Id { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; }
    public void Add()
        =&gt; Console.WriteLine($"Ticket {Id} added!");
}</pre>
    </li>
    <li>
     
      As the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      markup, render the
     
     <strong class="source-inline">
      
       ChildContent
      
     </strong>
     
      value and a button to trigger the
     
     
      <strong class="source-inline">
       
        Add()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
&lt;div class="ticket"&gt;
    &lt;div class="ticket-info"&gt;@ChildContent&lt;/div&gt;
    &lt;div class="ticket-actions"&gt;
        &lt;button @onclick="@Add"&gt;Add to cart&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Create
     
     <a id="_idIndexMarker053">
     </a>
     
      a routable
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component
     
     <a id="_idIndexMarker054">
     </a>
     
      that renders in
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      mode.
     
     
      Add a
     
     <strong class="source-inline">
      
       @using
      
     </strong>
     
      directive so that the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      object can
     
     
      
       be referenced:
      
     
     <pre class="source-code">
@page "/ch01r07"
@using
    BlazorCookbook.App.Client.Chapters.Chapter01.Data
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      As markup of the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component, while leveraging the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      component, render a
     
     <strong class="source-inline">
      
       Samples.Adult
      
     </strong>
     
      ticket tariff and price and a
     
     <strong class="source-inline">
      
       Samples.FreeAdmission
      
     </strong>
     
      ticket with just a tariff name since it’s free to
     
     
      
       do so:
      
     
     <pre class="source-code">
&lt;Ticket Id="@Samples.Adult.Id"&gt;
    @Samples.Adult.Tariff (@Samples.Adult.Price)
&lt;/Ticket&gt;
&lt;Ticket Id="@Samples.FreeAdmission.Id"&gt;
    &lt;div class="free-ticket"&gt;
        @Samples.FreeAdmission.Tariff
    &lt;/div&gt;
&lt;/Ticket&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-54">
    <a id="_idTextAnchor054">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we created a new
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component and implemented its
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     .
    
    
     Then, we declared a set of required parameters –
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     to add a ticket to the cart and
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     , which is of the
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     type, to hold the custom markup for a
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     instance.
    
    
     We leveraged the
    
    <strong class="source-inline">
     
      EditorRequired
     
    </strong>
    
     attribute and made
    
    <a id="_idIndexMarker055">
    </a>
    
     both parameters required.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we implemented the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     markup.
    
    
     We embedded the
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     value to render ticket details by placing it the same as any other parameter.
    
    
     We
    
    <a id="_idIndexMarker056">
    </a>
    
     also added a button that allows the user to add a ticket to the cart by leveraging the
    
    
     <strong class="source-inline">
      
       Add()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we created an
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     component.
    
    
     We utilized the
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directive to make it routable and declared it so that it rendered in the
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode.
    
    
     On top of that, we added a
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive with the namespace of the
    
    <strong class="source-inline">
     
      Samples
     
    </strong>
    
     object so that we could reference it within the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     component (the namespace can vary depending on the structure and name of your solution).
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we implemented the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     markup and saw the
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     object in action.
    
    
     For an adult ticket with a price tag, we rendered both its tariff and price.
    
    
     For the free admission ticket, we chose to render only the tariff name.
    
    
     Blazor will inject the custom markup in place of the
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     parameter, within the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component, while retaining and reusing the interactive button implementation, regardless of the
    
    
     
      customized content.
     
    
   </p>
   <h2 id="_idParaDest-55">
    <a id="_idTextAnchor055">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     You can use a
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     object to encapsulate common parts of your components.
    
    
     The testing and maintainability of your code will skyrocket.
    
    
     Another reason to leverage them is that a static
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     instance positively
    
    
     
      impacts performance.
     
    
   </p>
   <p>
    
     You might have noticed that when a
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     parameter is named
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     , the compiler automatically recognizes and assigns its value.
    
    
     You can still opt to
    
    
     
      declare
     
    
    
     <strong class="source-inline">
      
       &lt;ChildContent&gt;
      
     </strong>
    
    <strong class="source-inline">
     
      &lt;/ChildContent&gt;
     
    </strong>
    
     explicitly but there’s no need to complicate
    
    
     
      your code.
     
    
   </p>
   <p>
    
     However, you might encounter scenarios where you need more than one customizable section
    
    <a id="_idIndexMarker057">
    </a>
    
     within a component.
    
    
     Fortunately, Blazor allows you to have multiple
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     parameters.
    
    
     To implement that, you must explicitly declare both
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     values
    
    <a id="_idIndexMarker058">
    </a>
    
     using markup element syntax within your component.
    
    
     This approach enables even higher modularity and adaptability of your UI.
    
    
     For instance, you could have
    
    <strong class="source-inline">
     
      Details
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Actions
     
    </strong>
    
     content to structure your component with multiple customizable areas.
    
    
     You can see that in the following
    
    
     
      code blocks.
     
    
   </p>
   <p>
    
     Here’s the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component, which allows us to customize the
    
    <strong class="source-inline">
     
      Details
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       Actions
      
     </strong>
    
    
     
      areas:
     
    
   </p>
   <pre class="source-code">
&lt;div class="ticket"&gt;
    &lt;div class="ticket-info"&gt;@Details&lt;/div&gt;
    &lt;div class="ticket-actions"&gt;@Actions&lt;/div&gt;
&lt;/div&gt;
@code {
    [Parameter, EditorRequired]
    public RenderFragment Details { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment Actions { get; set; }
}</pre>
   <p>
    
     Here’s the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     component in action, with customized
    
    <strong class="source-inline">
     
      Details
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       Actions
      
     </strong>
    
    
     
      areas:
     
    
   </p>
   <pre class="source-code">
&lt;Ticket&gt;
    &lt;Details&gt;
        @Samples.Adult.Tariff (@Samples.Adult.Price)
    &lt;/Details&gt;
    &lt;Actions&gt;
        &lt;button @onclick="@(() =&gt; Add(Samples.Adult.Id))"&gt;
            Add to cart
        &lt;/button&gt;
    &lt;/Actions&gt;
&lt;/Ticket&gt;</pre>
   <h1 id="_idParaDest-56">
    <a id="_idTextAnchor056">
    </a>
    
     Making components generic
    
   </h1>
   <p>
    
     A
    
    <strong class="bold">
     
      generic class
     
    </strong>
    
     in C# is a class that’s defined with a placeholder type, allowing it to operate with any data type.
    
    
     This flexibility enables the creation of a single class that can adapt its
    
    <a id="_idIndexMarker059">
    </a>
    
     behavior to a variety of data types, enhancing code reusability and efficiency.
    
    
     Generic components in Blazor applications are a similar concept.
    
    
     These components are highly reusable across different contexts and data types.
    
    
     They abstract
    
    <a id="_idIndexMarker060">
    </a>
    
     away specific details, allowing high adaptability to various data or functionalities with minimal changes.
    
    
     This approach significantly reduces code duplication.
    
    
     With that flexibility, you can achieve even higher delivery velocity.
    
    
     The most common scenario where you’ll see generic components shine is repetitive data display,
    
    
     
      especially grids.
     
    
   </p>
   <p>
    
     Let’s create a generic
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component that can render objects of any type by using the provided
    
    
     
      row template.
     
    
   </p>
   <h2 id="_idParaDest-57">
    <a id="_idTextAnchor057">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you start
    
    <a id="_idIndexMarker061">
    </a>
    
     implementing the generic grid, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe08
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory, which contains the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TicketViewModel
      
     </strong>
     
      objects required for this recipe, next to the
     
     
      
       working directory
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-58">
    <a id="_idTextAnchor058">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Follow these
    
    <a id="_idIndexMarker062">
    </a>
    
     steps to build and use your
    
    
     
      generic component:
     
    
   </p>
   <ol>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component.
     
     
      At the top of the file, declare it as generic with the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        typeparam
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
@typeparam T</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component, declare parameters for data source and table area customization.
     
     
      The source and row template must
     
     
      
       be generic:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public IList&lt;T&gt; Data { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment Header { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment&lt;T&gt; Row { get; set; }
}</pre>
    </li>
    <li>
     
      For the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      markup, add a standard HTML table with the
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      content rendered where the table header is.
     
     
      For the table body, iterate over
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      and render the
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      template for
     
     
      
       each element:
      
     
     <pre class="source-code">
&lt;table class="grid"&gt;
    &lt;thead&gt;
        @Header
    &lt;/thead&gt;
    &lt;tbody&gt;
        @foreach (var item in Data)
            @Row(item)
    &lt;/tbody&gt;
&lt;/table&gt;</pre>
    </li>
    <li>
     
      Create a
     
     <a id="_idIndexMarker063">
     </a>
     
      routable
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component that renders in
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      mode and uses the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      assembly so that
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      can be
     
     
      
       referenced later:
      
     
     <pre class="source-code">
@page "/ch01r08"
@using
    BlazorCookbook.App.Client.Chapters.Chapter01.Data
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      , implement an
     
     <strong class="source-inline">
      
       Add()
      
     </strong>
     
      placeholder method that writes a simple action confirmation
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        Console
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
public void Add(TicketViewModel ticket)
   =&gt; Console.WriteLine($"Ticket {ticket.Id} added!");</pre>
    </li>
    <li>
     
      In the markup of the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component, use the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component and pass in
     
     <strong class="source-inline">
      
       Samples.Tickets
      
     </strong>
     
      as the data source
     
     
      
       for
      
     
     
      <strong class="source-inline">
       
        Grid
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;Grid Data="@Samples.Tickets"&gt;
    @* you will add areas here *@
&lt;/Grid&gt;</pre>
    </li>
    <li>
     
      Implement the required
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      area inside the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      instance in the
     
     
      <strong class="source-inline">
       
        Offer
       
      </strong>
     
     
      
       markup:
      
     
     <pre class="source-code">
&lt;Header&gt;
    &lt;tr&gt;
        &lt;td&gt;Ticket code&lt;/td&gt;
        &lt;td&gt;Tariff&lt;/td&gt;
        &lt;td&gt;Price&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/Header&gt;</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      instance, in the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      markup, implement the required
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      template
     
     <a id="_idIndexMarker064">
     </a>
     
      so that elements of the
     
     <strong class="source-inline">
      
       TicketViewModel
      
     </strong>
     
      type can
     
     
      
       be rendered:
      
     
     <pre class="source-code">
&lt;Row&gt;
    &lt;tr&gt;
        &lt;td&gt;@context.Id&lt;/td&gt;
        &lt;td&gt;@context.Tariff&lt;/td&gt;
        &lt;td&gt;@context.Price&lt;/td&gt;
        &lt;td @onclick="() =&gt; Add(context)"&gt;
            Add to Cart
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/Row&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor059">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     We started
    
    <a id="_idIndexMarker065">
    </a>
    
     this recipe by implementing the foundation for creating a generic component.
    
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we created a
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component and added the
    
    <strong class="source-inline">
     
      @typeparam
     
    </strong>
    
     attribute at the top.
    
    
     We also specified the name for the parameter type placeholder – much like you would in backend development.
    
    
     We chose to call it
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     .
    
    
     Blazor recognized
    
    <strong class="source-inline">
     
      @typeparam
     
    </strong>
    
     and now allows us to operate on
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     inside the component.
    
    
     The IDE will also apply all validations that generic modules require.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we implemented the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component by adding a
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     parameter that will hold elements to render and two
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     parameters, enabling
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     customization.
    
    
     You can learn more about
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     in the
    
    <em class="italic">
     
      Creating components with customizable content
     
    </em>
    
     section.
    
    
     Notably, the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection isn’t the only generic object.
    
    
     The
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     parameter, which contains a row template, is also generic, which means it will expect a data object of type
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     for initialization.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we implemented the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup.
    
    
     We rendered the
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     value inside the
    
    <strong class="source-inline">
     
      &lt;thead&gt;
     
    </strong>
    
     tags, where the table header normally goes; for the table body, we used a
    
    <strong class="source-inline">
     
      foreach
     
    </strong>
    
     loop to iterate over the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection and rendered the
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     template for
    
    
     
      each element.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we created a routable
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     component to test our grid.
    
    
     As we expected interactivity, we declared that
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     rendered in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode.
    
    
     We also
    
    <a id="_idIndexMarker066">
    </a>
    
     leveraged the
    
    <strong class="source-inline">
     
      Samples
     
    </strong>
    
     object, so we exposed the required assembly with the
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we implemented an
    
    <strong class="source-inline">
     
      Add()
     
    </strong>
    
     placeholder method within the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     component to test the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component’s interactivity.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we started implementing the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     markup.
    
    
     We embedded the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component and passed the
    
    <strong class="source-inline">
     
      Samples.Tickets
     
    </strong>
    
     array as the value of the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     parameter.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we declared the content of
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     , which in our case is a set of columns representing
    
    <strong class="source-inline">
     
      TicketViewModel
     
    </strong>
    
     properties and an additional column where we placed action buttons.
    
    
     The real rendering magic happened in
    
    <em class="italic">
     
      step 8
     
    </em>
    
     .
    
    
     As the
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     template expects a
    
    <strong class="source-inline">
     
      TicketViewModel
     
    </strong>
    
     object, we can access
    
    <strong class="source-inline">
     
      TicketViewModel
     
    </strong>
    
     properties in the markup with a
    
    <strong class="source-inline">
     
      @context
     
    </strong>
    
     directive and place them in table columns matching the
    
    
     <strong class="source-inline">
      
       Header
      
     </strong>
    
    
     
      declaration.
     
    
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor060">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     The power of the generic component lies in its agnosticism to the data type you’ll use.
    
    
     It simply knows how to construct a template, and where to place customizable content.
    
    
     It’s up to you to define markup to present
    
    
     
      data properties.
     
    
   </p>
   <p>
    
     You might find yourself in need of nesting multiple generic components.
    
    
     To do so, you’ll have to define all required
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     parameters.
    
    
     However, a key challenge here is going to be distinguishing each generic context.
    
    
     In that case, you must assign custom names to the context of each generic component using the
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     parameter.
    
    
     This parameter is inherited automatically, streamlining the process and enhancing the readability of
    
    
     
      your code.
     
    
   </p>
   <p>
    
     Even though our example doesn’t require nesting, we can still leverage the
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     naming feature to enhance the
    
    
     
      code’s readability:
     
    
   </p>
   <pre class="source-code">
&lt;Grid Data="@Data.Tickets" Context="ticket"&gt;
    ...
    &lt;Row&gt;
        &lt;tr&gt;
            &lt;td&gt;@ticket.Id&lt;/td&gt;
            ... *
        &lt;/tr&gt;
    &lt;/Row&gt;
&lt;/Grid&gt;</pre>
   <p>
    
     Remember that the more intuitive your code is, the easier it is to navigate and update, especially when you’re working in team environments or returning to the code after
    
    
     
      some time.
     
    
   </p>
   <h1 id="_idParaDest-61">
    <a id="_idTextAnchor061">
    </a>
    
     Decoupling components with DynamicComponent
    
   </h1>
   <p>
    <strong class="bold">
     
      Decoupling
     
    </strong>
    
     is a design
    
    <a id="_idIndexMarker067">
    </a>
    
     principle that enhances the flexibility and maintainability
    
    <a id="_idIndexMarker068">
    </a>
    
     of your applications.
    
    
     It comes down to reducing direct dependencies between various parts of your code.
    
    
     Blazor offers an elegant solution for rendering components dynamically.
    
    
     In this recipe, we’ll explore the strategic use of
    
    <strong class="source-inline">
     
      DynamicComponent
     
    </strong>
    
     .
    
    
     It allows you to render components dynamically at runtime based on certain conditions or parameters.
    
    
     You’re not required to specify the component type in the markup at compile time explicitly.
    
    
     Heads up – most compilation validators won’t
    
    
     
      apply here.
     
    
   </p>
   <p>
    
     Let’s implement the fully decoupled and dynamic prompting of success and failure notifications when the user adds a ticket to the cart, based on that
    
    
     
      ticket’s availability.
     
    
   </p>
   <h2 id="_idParaDest-62">
    <a id="_idTextAnchor062">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before
    
    <a id="_idIndexMarker069">
    </a>
    
     you dive into implementing
    
    <strong class="source-inline">
     
      DynamicComponent
     
    </strong>
    
     , do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe09
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      components from the
     
     <em class="italic">
      
       Making components generic
      
     </em>
     
      recipe or copy their implementation from the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe08
      
     </strong>
     
      directory of this book’s
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Chapter01
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory, which contains the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TicketViewModel
      
     </strong>
     
      objects required in this recipe, next to the
     
     
      
       working directory
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor063">
    </a>
    
     How to do it...
    
   </h2>
   <p>
    
     Follow
    
    <a id="_idIndexMarker070">
    </a>
    
     these steps to learn how to create more modular and independent components
    
    <a id="_idIndexMarker071">
    </a>
    
     
      using
     
    
    
     <strong class="source-inline">
      
       DynamicComponent
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ol>
    <li>
     
      Add a new
     
     <strong class="source-inline">
      
       Alerts
      
     </strong>
     
      directory to
     
     
      
       your project.
      
     
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       Alerts
      
     </strong>
     
      directory, create the
     
     <strong class="source-inline">
      
       AddedToCart
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        SoldOut
       
      </strong>
     
     
      
       components:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 1.9: Project structure with newly added alert components and sample objects" src="img/B22020_01_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 1.9: Project structure with newly added alert components and sample objects
    
   </p>
   <ol>
    <li value="3">
     
      Navigate to the
     
     <strong class="source-inline">
      
       AddedToCart
      
     </strong>
     
      component and add a successful
     
     
      
       alert markup:
      
     
     <pre class="source-code">
&lt;div class="alert alert-success" role="alert"&gt;
    Added to cart successfully.
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       SoldOut
      
     </strong>
     
      component.
     
     
      Declare a
     
     <strong class="source-inline">
      
       Tariff
      
     </strong>
     
      parameter and add a danger alert markup by using the
     
     
      <strong class="source-inline">
       
        Tariff
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
&lt;div class="alert alert-danger" role="alert"&gt;
    Ticket @Tariff is sold out!
&lt;/div&gt;
@code {
    [Parameter] public string Tariff { get; set; }
}</pre>
    </li>
    <li>
     
      Navigate
     
     <a id="_idIndexMarker072">
     </a>
     
      to the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      component and, in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, declare additional
     
     <strong class="source-inline">
      
       AlertType
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        AlertParams
       
      </strong>
     
     
      
       variables:
      
     
     <pre class="source-code">
protected Type AlertType;
protected Dictionary&lt;string, object&gt; AlertParams;</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      , replace the
     
     <strong class="source-inline">
      
       Add()
      
     </strong>
     
      method’s implementation
     
     <a id="_idIndexMarker073">
     </a>
     
      to validate ticket availability and display a
     
     
      
       designated notification:
      
     
     <pre class="source-code">
public void Add(TicketViewModel ticket)
{
    AlertType = ticket.AvailableSeats == 0 ?
        typeof(Alerts.SoldOut) :
        typeof(Alerts.AddedToCart);
    AlertParams = new();
    if (ticket.AvailableSeats == 0)
    {
        AlertParams.Add(
            nameof(ticket.Tariff),
            ticket.Tariff
        );
    }
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Offer
      
     </strong>
     
      markup, below the existing
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      instance, add a conditional rendering of
     
     <strong class="source-inline">
      
       DynamicComponent
      
     </strong>
     
      while leveraging the resolved values of the
     
     <strong class="source-inline">
      
       AlertType
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        AlertParams
       
      </strong>
     
     
      
       variables:
      
     
     <pre class="source-code">
@if (AlertType is null) return;
&lt;DynamicComponent Type="@AlertType"
                  Parameters="@AlertParams" /&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor064">
    </a>
    
     How it works...
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we added an
    
    <strong class="source-inline">
     
      Alerts
     
    </strong>
    
     directory where we could place different alert components.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     ,  we created the
    
    <strong class="source-inline">
     
      AddedToCart
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      SoldOut
     
    </strong>
    
     components, representing
    
    <a id="_idIndexMarker074">
    </a>
    
     success and failure notifications when adding a ticket to the cart.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we focused on implementing the
    
    <strong class="source-inline">
     
      AddedToCart
     
    </strong>
    
     component, which renders an
    
    <strong class="source-inline">
     
      alert-success
     
    </strong>
    
     class with an
    
    <strong class="bold">
     
      Added to cart successfully
     
    </strong>
    
     message.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we implemented the
    
    <strong class="source-inline">
     
      SoldOut
     
    </strong>
    
     component, which renders an
    
    <strong class="source-inline">
     
      alert-danger
     
    </strong>
    
     class and renders the sold-out
    
    
     
      ticket tariff.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we added two critical variables that
    
    <strong class="source-inline">
     
      DynamicComponent
     
    </strong>
    
     leverages.
    
    
     The first is
    
    <strong class="source-inline">
     
      AlertType
     
    </strong>
    
     , of the
    
    <strong class="source-inline">
     
      Type
     
    </strong>
    
     type, which determines the type of component to render.
    
    
     The second is
    
    <strong class="source-inline">
     
      AlertParams
     
    </strong>
    
     , a dictionary that allows us to dynamically pass parameter values to the loaded component.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we resolved the state of the requested ticket.
    
    
     We checked seat availability and decided whether to use the
    
    <strong class="source-inline">
     
      SoldOut
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      AddedToCart
     
    </strong>
    
     component.
    
    
     When seats are unavailable, we conditionally add the
    
    <strong class="source-inline">
     
      Tariff
     
    </strong>
    
     parameter to our dynamic collection of parameters.
    
    
     Finally, in
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we embedded
    
    <a id="_idIndexMarker075">
    </a>
    
     the
    
    <strong class="source-inline">
     
      DynamicComponent
     
    </strong>
    
     component in the
    
    <strong class="source-inline">
     
      Offer
     
    </strong>
    
     markup.
    
    
     If the
    
    <strong class="source-inline">
     
      AlertType
     
    </strong>
    
     value is unset, we skip rendering it.
    
    
     Otherwise, we append the dynamically
    
    
     
      resolved markup.
     
    
   </p>
   <p>
    
     Notice that we utilized the built-in
    
    <strong class="source-inline">
     
      typeof()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      nameof()
     
    </strong>
    
     functions to declare the type and parameters of the current notification.
    
    
     If you want or need to take decoupling even further, you can initialize them
    
    <a id="_idIndexMarker076">
    </a>
    
     purely from
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     variables.
    
    
     That’s especially powerful when you’re working in architecture such
    
    
     
      as
     
    
    
     <strong class="bold">
      
       micro-frontends
      
     </strong>
    
    
     
      .
     
    
   </p>
  </div>
 </body></html>