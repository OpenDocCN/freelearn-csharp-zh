<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer233">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 class="chapterTitle" id="_idParaDest-243"><span class="koboSpan" id="kobo.2.1">Choosing Your Data Storage in the Cloud</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Azure, like other clouds, offers a wide range of storage services. </span><span class="koboSpan" id="kobo.3.2">The first approach that we may consider is defining a scalable set of virtual machines hosted in the cloud where we can implement our custom solutions. </span><span class="koboSpan" id="kobo.3.3">For instance, we can create a SQL Server cluster on our cloud-hosted virtual machines to increase reliability and computational power. </span><span class="koboSpan" id="kobo.3.4">However, usually, custom architectures are not the optimal solution and do not take full advantage of the opportunities offered by cloud infrastructure. </span><span class="koboSpan" id="kobo.3.5">Scalability, fast setup, focus on the business, and security are some of the criteria that you might consider while deciding on your data storage on Azure. </span><span class="koboSpan" id="kobo.3.6">To help you with this, many of the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">platform-as-a-service</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">PaaS</span></strong><span class="koboSpan" id="kobo.7.1">) options</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.8.1"> for storing data can be a great solution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">Therefore, this chapter will not discuss such custom architectures but will focus mainly on the various PaaS storage offerings that are available in the cloud and on Azure. </span><span class="koboSpan" id="kobo.9.2">These offerings include scalable solutions based on plain disk space, relational databases, NoSQL databases, and in-memory data stores such as Redis.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">Choosing a more adequate storage type is based not only on the application’s functional requirements but also on performance and scaling-out requirements. </span><span class="koboSpan" id="kobo.10.2">In fact, while scaling out when processing resources causes a linear increase in performance, scaling out storage resources does not necessarily imply an acceptable increase in performance. </span><span class="koboSpan" id="kobo.10.3">In short, no matter how much you duplicate your data storage devices, if several requests affect the same chunk of data, they will always queue for the same amount of time to access it!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">Scaling out data causes linear increases in read operation throughput since each copy can serve a different request, but it doesn’t imply the same increase in throughput for write operations since all copies of the same chunk of data must be updated! </span><span class="koboSpan" id="kobo.11.2">Accordingly, more sophisticated techniques are required to scale out storage devices, and not all storage engines scale equally well.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.12.1">Relational databases do not scale well in all scenarios. </span><span class="koboSpan" id="kobo.12.2">Therefore, scaling needs and the need to distribute data geographically play a fundamental role in the choice of a storage engine, as well as in the choice of SaaS offering.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.13.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Understanding the different repositories for different purposes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Choosing between SQL and NoSQL document-oriented databases</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Azure Cosmos DB – an opportunity to manage a multi-continental database</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Let us get started!</span></p>
<h1 class="heading-1" id="_idParaDest-244"><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.19.1">This chapter requires that you have the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Visual Studio 2022 free Community edition or better, with all the database tool components installed.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">A free Azure account. </span><span class="koboSpan" id="kobo.21.2">The </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Creating an Azure account</span></em><span class="koboSpan" id="kobo.23.1"> subsection in </span><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 1</span></em><span class="koboSpan" id="kobo.25.1">, </span><em class="italic"><span class="koboSpan" id="kobo.26.1">Understanding the Importance of Software Architecture</span></em><span class="koboSpan" id="kobo.27.1">, explains how to create one.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">For a better development experience, we advise that you also install the local emulator of Cosmos DB, which can be found at </span><a href="https://aka.ms/cosmosdb-emulator"><span class="url"><span class="koboSpan" id="kobo.29.1">https://aka.ms/cosmosdb-emulator</span></span></a><span class="koboSpan" id="kobo.30.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">You can find the sample code for the chapter at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.33.1">.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-245"><span class="koboSpan" id="kobo.34.1">Understanding the different repositories for different purposes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.35.1">This section describes the functionalities that are offered by the most popular data storage techniques. </span><span class="koboSpan" id="kobo.35.2">We will mainly focus on the functional requirements they are able to satisfy. </span><span class="koboSpan" id="kobo.35.3">Performance and scaling-out features will be analyzed in the next section, which is dedicated to comparing relational and NoSQL databases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.36.1">In Azure, the various offerings can be found by typing product names into the search bar at the top of all Azure portal pages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">The following subsections describe the various kinds of databases that we can use in our C# projects.</span></p>
<h2 class="heading-2" id="_idParaDest-246"><span class="koboSpan" id="kobo.38.1">Relational databases</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.39.1">These databases are</span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.40.1"> the most common and studied type of storage. </span><span class="koboSpan" id="kobo.40.2">They guarantee a high level of service and store an immeasurable amount of data. </span><span class="koboSpan" id="kobo.40.3">Dozens of applications have been designed to store data in this kind of database, and we can find them in banks, stores, industries, and so on. </span><span class="koboSpan" id="kobo.40.4">When you store data in a relational database, the basic principle is to define the entities and properties you will save in each of them, defining the correct relationship between these entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.41.1">For decades, relational databases were the only option imagined for designing great projects. </span><span class="koboSpan" id="kobo.41.2">Many big companies around the world have built their own database management system. </span><span class="koboSpan" id="kobo.41.3">Oracle, MySQL, and MS SQL Server would be listed by many as the ones you can trust to store your data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.42.1">Usually, clouds offer several database engines. </span><span class="koboSpan" id="kobo.42.2">Azure offers a variety of popular database engines, such as Oracle, MySQL, PostgreSQL, and SQL Server (Azure SQL).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.43.1">Regarding the Oracle database engine, Azure offers configurable virtual machines with various Oracle editions installed on them, which you can easily verify by the suggestions you get after typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.44.1">Oracle</span></code><span class="koboSpan" id="kobo.45.1"> into the Azure portal search bar. </span><span class="koboSpan" id="kobo.45.2">Azure fees do not include Oracle licenses; they just include computation time, so you must bring your own license to Azure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.46.1">With MySQL on Azure, you pay to use a private server instance. </span><span class="koboSpan" id="kobo.46.2">The fees you incur depend on the number of cores you have, how much memory must be allocated, and backup retention time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.47.1">MySQL instances are redundant, and you can choose between local or geographically distributed redundancy:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.48.1"><img alt="" role="presentation" src="../Images/B19820_12_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.49.1">Figure 12.1: Creating a MySQL server on Azure</span></p>
<p class="normal"><span class="koboSpan" id="kobo.50.1">Azure SQL Database</span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.51.1"> was one of the first PaaS options available on Azure, and for this reason, it has evolved a lot in recent years, which has made it one of the most flexible offers. </span><span class="koboSpan" id="kobo.51.2">Today, it also includes a serverless pricing model, where you are billed for the compute used per second. </span><span class="koboSpan" id="kobo.51.3">Here, you can configure resources that are used by every single database. </span><span class="koboSpan" id="kobo.51.4">When you create a database, you have the option to place it on an existing server instance or create a new instance. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.52.1">There are several pricing options that you may choose while defining your solution, and Azure keeps incrementing them to make sure you will be able to handle your data in the cloud. </span><span class="koboSpan" id="kobo.52.2">Basically, they vary due to the computing capacity you need.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.53.1">For instance, in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.54.1">Database Transaction Units</span></strong><span class="koboSpan" id="kobo.55.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.56.1">DTUs</span></strong><span class="koboSpan" id="kobo.57.1">) model, fees are based on the database storage</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.58.1"> capacity that has been reserved and a linear combination of I/O operations, CPU usage, and memory usage that is determined by a reference workload. </span><span class="koboSpan" id="kobo.58.2">Considering the difficulty of understanding exactly how DTUs are calculated, Azure also </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.59.1">offers </span><strong class="keyWord"><span class="koboSpan" id="kobo.60.1">vCore-based</span></strong><span class="koboSpan" id="kobo.61.1"> models, where you have flexibility, control, and transparency of individual resource consumption.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.62.1">Roughly, maximal </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.63.1">database performance increases linearly when you increase the DTUs.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.64.1">You can find detailed information about the options you have for purchasing Azure SQL</span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.65.1"> Database at </span><a href="https://learn.microsoft.com/en-us/azure/azure-sql/database/purchasing-models?view=azuresql"><span class="url"><span class="koboSpan" id="kobo.66.1">https://learn.microsoft.com/en-us/azure/azure-sql/database/purchasing-models?view=azuresql</span></span></a><span class="koboSpan" id="kobo.67.1">.</span></p>
</div>
<figure class="mediaobject"><span class="koboSpan" id="kobo.68.1"><img alt="" role="presentation" src="../Images/B19820_12_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.69.1">Figure 12.2: Creating an Azure SQL Database</span></p>
<p class="normal"><span class="koboSpan" id="kobo.70.1">You can also configure</span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.71.1"> data replication by enabling read scale-out. </span><span class="koboSpan" id="kobo.71.2">This way, you can improve the performance of read operations. </span><span class="koboSpan" id="kobo.71.3">Backup retention is fixed for each offering level (basic, standard, and premium).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.72.1">If you select </span><strong class="keyWord"><span class="koboSpan" id="kobo.73.1">Yes</span></strong><span class="koboSpan" id="kobo.74.1"> for </span><strong class="keyWord"><span class="koboSpan" id="kobo.75.1">Want to use SQL elastic pool?</span></strong><span class="koboSpan" id="kobo.76.1">, the database will be added to an elastic pool. </span><span class="koboSpan" id="kobo.76.2">Databases that are added to the same elastic pool will share their resources, so resources that are not used by a database can be used during the usage CPU peaks of other databases. </span><span class="koboSpan" id="kobo.76.3">It is worth mentioning that elastic pools can only contain databases hosted on the same server instance. </span><span class="koboSpan" id="kobo.76.4">Elastic pools are an efficient way to optimize resource</span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.77.1"> usage to reduce costs.</span></p>
<h2 class="heading-2" id="_idParaDest-247"><span class="koboSpan" id="kobo.78.1">NoSQL databases</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.79.1">One of the biggest </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.80.1">challenges that relational databases have caused software architects is related to how we deal with database structural schema changes. </span><span class="koboSpan" id="kobo.80.2">The agility of changes needed at the beginning of this century brought the opportunity to use a new database style called NoSQL. </span><span class="koboSpan" id="kobo.80.3">The next subtopics will present several types of NoSQL databases.</span></p>
<h3 class="heading-3" id="_idParaDest-248"><span class="koboSpan" id="kobo.81.1">Document-oriented database</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.82.1">The most common </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.83.1">type of database, where you have the key and complex data, is called a document.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.84.1">For instance, in NoSQL document-oriented databases, relational tables are replaced with more general collections that can contain heterogeneous JSON objects. </span><span class="koboSpan" id="kobo.84.2">That is, collections have no predefined structure and no predefined fields with length constraints (in the case of strings) but can contain any type of object. </span><span class="koboSpan" id="kobo.84.3">The only structural constraint associated with each collection is the name of the property that acts as a primary key.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">More specifically, each collection entry can contain nested objects and object collections nested in object properties, that is, related entities that, in relational databases, are contained in different tables and connected through external keys. </span><span class="koboSpan" id="kobo.85.2">In NoSQL, databases can be nested in their parent entities. </span><span class="koboSpan" id="kobo.85.3">Since collection entries contain complex nested objects instead of simple property/value pairs, as is the case with relational databases, entries are not called tuples or rows but </span><em class="italic"><span class="koboSpan" id="kobo.86.1">documents</span></em><span class="koboSpan" id="kobo.87.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.88.1">No relations and/or external key constraints can be defined between documents that belong to the same collection or to different collections. </span><span class="koboSpan" id="kobo.88.2">If a document contains the primary key of another document in one of its properties, it does so at its own risk. </span><span class="koboSpan" id="kobo.88.3">The developer is responsible for maintaining and keeping these coherent references. </span><span class="koboSpan" id="kobo.88.4">This is a tradeoff that you, as a software architect, must analyze. </span><span class="koboSpan" id="kobo.88.5">If you design a system that is generally dependent on relational databases, the gain of NoSQL will not be achieved, and you are at the same time sacrificing data integrity and redundancy. </span><span class="koboSpan" id="kobo.88.6">However, if you have a scenario where flexibility is needed, you must consider NoSQL as an option.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.89.1">Finally, NoSQL storage is quite cheap. </span><span class="koboSpan" id="kobo.89.2">You can store a great amount of data as Base64 string properties. </span><span class="koboSpan" id="kobo.89.3">The developer can define rules to decide what properties to index in a collection. </span><span class="koboSpan" id="kobo.89.4">Since documents are nested objects, properties are tree paths. </span><span class="koboSpan" id="kobo.89.5">It is worth saying that you can specify which collection of paths and subpaths are indexed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.90.1">Almost all NoSQL databases are queried either with a subset of SQL or with a JSON-based language where queries are JSON objects whose paths represent the properties to query and whose values represent the query constraints that have been applied to them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.91.1">The possibility of nesting children objects inside documents can be simulated in relational databases with the help of one-to-many relationships. </span><span class="koboSpan" id="kobo.91.2">However, with relational databases, we are forced to redefine the exact structure of all the related tables, while NoSQL collections do not impose any predefined structure on the objects they contain. </span><span class="koboSpan" id="kobo.91.3">The only constraint is that each document must provide a unique value for the primary key property.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">It is true that today, we have the possibility to define JSON columns in relational databases such as Azure SQL, so we can take a hybrid approach when defining our data model, having a schema for part of it but being flexible on other parts of it. </span><span class="koboSpan" id="kobo.92.2">However, NoSQL databases continue to be the best option when the structure of our objects is extremely variable, like social media and </span><strong class="keyWord"><span class="koboSpan" id="kobo.93.1">Internet of Things </span></strong><span class="koboSpan" id="kobo.94.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.95.1">IoT</span></strong><span class="koboSpan" id="kobo.96.1">) solutions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.97.1">However, often, they are chosen for the way they scale out read and write operations and, more generally, for their performance advantages in distributed environments. </span><span class="koboSpan" id="kobo.97.2">Their performance </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.98.1">features, which compare them to relational databases, will be discussed in the next section.</span></p>
<h3 class="heading-3" id="_idParaDest-249"><span class="koboSpan" id="kobo.99.1">Graph database</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.100.1">Social media </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.101.1">sites tend to use this kind of database since the data is stored as graphs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.102.1">The graph data model is an extreme case of a completely unstructured document. </span><span class="koboSpan" id="kobo.102.2">The whole database is a graph where queries can add, change, and delete graph documents.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.103.1">In this case, we have two kinds of documents: nodes and relationships. </span><span class="koboSpan" id="kobo.103.2">While relationships have a well-defined structure (the primary key of the nodes connected by the relationship, plus the relationship’s name), nodes have no structure at all since properties and their values are added together during node update operations.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.104.1">It is important to you, as a software architect, to decide if this kind of structure presented in graph databases is the best one for the use case for which you are designing the system, always remembering that such a decision can make the system more complicated than needed.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.105.1">Graph data models were conceived to represent the features of people and the objects they manipulate (media, posts, and so on), along with their relationships in </span><em class="italic"><span class="koboSpan" id="kobo.106.1">social applications</span></em><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">The Gremlin language was conceived specifically to query graph data models. </span><span class="koboSpan" id="kobo.107.3">We will not</span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.108.1"> discuss this in this chapter, but references are available in the </span><em class="italic"><span class="koboSpan" id="kobo.109.1">Further reading</span></em><span class="koboSpan" id="kobo.110.1"> section.</span></p>
<h3 class="heading-3" id="_idParaDest-250"><span class="koboSpan" id="kobo.111.1">Key-value database</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.112.1">This is a useful </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.113.1">database for implementing caches since you can store key-value pairs. </span><span class="koboSpan" id="kobo.113.2">Redis is a great example of it and it will be detailed soon in this chapter.</span></p>
<h3 class="heading-3" id="_idParaDest-251"><span class="koboSpan" id="kobo.114.1">Wide-column store database</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.115.1">This is a type of database </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.116.1">where the same column in each row can store different data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.117.1">NoSQL databases will be analyzed in detail in the remaining sections of this chapter, which are dedicated to describing Azure Cosmos DB and comparing it with relational databases.</span></p>
<h2 class="heading-2" id="_idParaDest-252"><span class="koboSpan" id="kobo.118.1">Redis</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.119.1">Redis is a distributed </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.120.1">in-memory storage based on key-value pairs and supports distributed queuing. </span><span class="koboSpan" id="kobo.120.2">It can be used as permanent in-memory storage and as a web application cache for database data. </span><span class="koboSpan" id="kobo.120.3">Alternatively, it can be used as a cache for pre-rendered content.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.121.1">Redis can also be used to store a web application’s user session data. </span><span class="koboSpan" id="kobo.121.2">This was done originally with Microsoft SQL Server, but due to the performance provided by memory databases, Redis is the best alternative today.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.122.1">In fact, ASP.NET Core supports session data to overcome the fact that the HTTP protocol is stateless. </span><span class="koboSpan" id="kobo.122.2">More specifically, user data that is kept between page changes is maintained in server-side stores such as Redis and indexed by a session key stored in cookies.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.123.1">Interaction with the Redis server in the cloud is typically based on a client implementation that offers an easy-to-use interface. </span><span class="koboSpan" id="kobo.123.2">The client for .NET is available through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.124.1">StackExchange.Redis</span></code><span class="koboSpan" id="kobo.125.1"> NuGet package. </span><span class="koboSpan" id="kobo.125.2">The basic operations of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">StackExchange.Redis</span></code><span class="koboSpan" id="kobo.127.1"> clients have been documented in </span><a href="https://stackexchange.github.io/StackExchange.Redis/Basics"><span class="url"><span class="koboSpan" id="kobo.128.1">https://stackexchange.github.io/StackExchange.Redis/Basics</span></span></a><span class="koboSpan" id="kobo.129.1">, while the full documentation can be found at </span><a href="https://stackexchange.github.io/StackExchange.Redis"><span class="url"><span class="koboSpan" id="kobo.130.1">https://stackexchange.github.io/StackExchange.Redis</span></span></a><span class="koboSpan" id="kobo.131.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.132.1">The user interface </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.133.1">for defining a Redis server on Azure is quite simple:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.134.1"><img alt="" role="presentation" src="../Images/B19820_12_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.135.1">Figure 12.3: Creating a Redis cache</span></p>
<p class="normal"><span class="koboSpan" id="kobo.136.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.137.1">Pricing tier</span></strong><span class="koboSpan" id="kobo.138.1"> dropdown</span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.139.1"> allows us to select one of the available memory/replication options. </span><span class="koboSpan" id="kobo.139.2">A quick-start guide that explains how to use Azure Redis credentials and the URI with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">StackExchange.Redis</span></code><span class="koboSpan" id="kobo.141.1"> .NET client </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.142.1">can be found at </span><a href="https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart"><span class="url"><span class="koboSpan" id="kobo.143.1">https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart</span></span></a><span class="koboSpan" id="kobo.144.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-253"><span class="koboSpan" id="kobo.145.1">Azure storage accounts</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.146.1">All clouds offer </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.147.1">scalable and redundant general-purpose disk memory that you can use as virtual disks in virtual machines and/or as external file storage. </span><span class="koboSpan" id="kobo.147.2">Azure </span><em class="italic"><span class="koboSpan" id="kobo.148.1">storage account</span></em><span class="koboSpan" id="kobo.149.1"> disk space can also be structured in </span><strong class="keyWord"><span class="koboSpan" id="kobo.150.1">tables</span></strong><span class="koboSpan" id="kobo.151.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.152.1">queues</span></strong><span class="koboSpan" id="kobo.153.1">. </span><span class="koboSpan" id="kobo.153.2">Consider using this option if you need cheap blob storage. </span><span class="koboSpan" id="kobo.153.3">However, there are more sophisticated options, as we have mentioned before. </span><span class="koboSpan" id="kobo.153.4">Depending on the scenario you have, Azure NoSQL databases are a better option than tables, and Azure Redis is a better option than Azure storage queues.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.154.1"><img alt="" role="presentation" src="../Images/B19820_12_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.155.1">Figure 12.4: Creating a storage account</span></p>
<p class="normal"><span class="koboSpan" id="kobo.156.1">In the rest of this </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.157.1">chapter, we will focus on NoSQL databases and how they differ from relational databases. </span><span class="koboSpan" id="kobo.157.2">Next, we will look at how to choose one over the other.</span></p>
<h1 class="heading-1" id="_idParaDest-254"><span class="koboSpan" id="kobo.158.1">Choosing between SQL and NoSQL document-oriented databases</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.159.1">As a software</span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.160.1"> architect, you may consider some aspects of SQL and NoSQL databases to decide the best storage option for you. </span><span class="koboSpan" id="kobo.160.2">In many cases, both will be needed. </span><span class="koboSpan" id="kobo.160.3">The key point here will surely be how organized your data is and how big the database will become.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.161.1">In the previous section, we stated that NoSQL document-oriented databases should be preferred by you, as a software architect, when data has almost no predefined structure. </span><span class="koboSpan" id="kobo.161.2">They not only keep variable attributes close to their owners, but they also keep some related objects close since they allow related objects to be nested inside properties and collections.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.162.1">Unstructured data can be represented in relational databases if variable properties of a tuple (</span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1">t</span></code><span class="koboSpan" id="kobo.164.1">) can be placed in a connected table containing the property name, property value, and the external key of </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">t</span></code><span class="koboSpan" id="kobo.166.1">. </span><span class="koboSpan" id="kobo.166.2">However, the problem in this scenario is performance. </span><span class="koboSpan" id="kobo.166.3">In fact, property values that belong to a single object would be spread all over the available memory space. </span><span class="koboSpan" id="kobo.166.4">In a small database, </span><em class="italic"><span class="koboSpan" id="kobo.167.1">all over the available memory space</span></em><span class="koboSpan" id="kobo.168.1"> means far away but on the same disk; in a bigger database, it means far away but in different disk units; in a distributed cloud environment, it means far away but in different – and possibly geographically distributed – servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.169.1">On the other hand, in the NoSQL document-oriented database design, we always try to put all related objects that are likely to be processed together into a single entry. </span><span class="koboSpan" id="kobo.169.2">Related objects that are accessed less frequently are placed in different entries. </span><span class="koboSpan" id="kobo.169.3">Since external key constraints are not enforced automatically, and NoSQL transactions are very flexible, the developer can choose the best compromise between performance and coherence.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.170.1">It is important to mention that today, we can store unstructured data as columns with JSON (or XML) types in relational databases. </span><span class="koboSpan" id="kobo.170.2">This approach allows the use of patterns typically implemented in document databases to also be achievable in relational databases, such as avoiding joins by inserting complete objects in a JSON column. </span><span class="koboSpan" id="kobo.170.3">However, the adoption of the NoSQL document-oriented database can be considered the best option since it was designed for this purpose.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.171.1">Therefore, we can conclude that relational databases perform well when tables that are usually accessed together can be stored close together. </span><span class="koboSpan" id="kobo.171.2">NoSQL document-oriented databases, on the other hand, automatically ensure that related data is kept close together since each entry keeps most of the data it is related to inside it as nested objects. </span><span class="koboSpan" id="kobo.171.3">Therefore, NoSQL document-oriented databases perform better when they are distributed to a different memory and to different geographically distributed servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.172.1">Unfortunately, the only way to scale out storage write operations is to split collection entries across several servers according to the values of </span><em class="italic"><span class="koboSpan" id="kobo.173.1">shard keys</span></em><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">For instance, we can place all the records containing usernames that start with </span><strong class="keyWord"><span class="koboSpan" id="kobo.175.1">A</span></strong><span class="koboSpan" id="kobo.176.1"> on a server, the records containing usernames that start with </span><strong class="keyWord"><span class="koboSpan" id="kobo.177.1">B</span></strong><span class="koboSpan" id="kobo.178.1"> on another server, and so on. </span><span class="koboSpan" id="kobo.178.2">This way, write operations for usernames with different start letters may be executed in parallel, ensuring that the write throughput increases linearly with the number of servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.179.1">However, if a </span><em class="italic"><span class="koboSpan" id="kobo.180.1">shard</span></em><span class="koboSpan" id="kobo.181.1"> collection is related to several other collections, there is no guarantee that related records will be placed on the same server. </span><span class="koboSpan" id="kobo.181.2">Also, putting different collections on different servers without using collection sharding increases write throughput linearly until we reach the limit of a single collection per server, but it doesn’t solve the issue of being forced to perform several operations on different servers to retrieve or update data that are usually processed together.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.182.1">This issue becomes </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.183.1">catastrophic for performance in relational databases if access to related distributed objects must be transactional and/or must ensure structural constraints (such as external key constraints) are not violated. </span><span class="koboSpan" id="kobo.183.2">In this case, all related objects must be blocked during the transaction, preventing other requests from accessing them during the whole lifetime of a time-consuming distributed operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.184.1">NoSQL document-oriented databases do not suffer from this problem and perform better with sharding and, consequently, with write-scaled output. </span><span class="koboSpan" id="kobo.184.2">This is because they do not distribute related data to different storage units and instead store them as nested objects of the same database entry. </span><span class="koboSpan" id="kobo.184.3">On the other hand, they suffer from different problems, like not supporting transactions by default.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.185.1">It is worth mentioning that there are situations where relational databases perform well with sharding. </span><span class="koboSpan" id="kobo.185.2">A typical instance is a multi-tenant application. </span><span class="koboSpan" id="kobo.185.3">In a multi-tenant application, all entry collections can be partitioned into non-overlapping sets called </span><strong class="keyWord"><span class="koboSpan" id="kobo.186.1">tenants</span></strong><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">Only </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.188.1">entries belonging to the same tenant can refer to each other, so if all the collections are sharded in the same way according to their object tenants, all related records end up in the same shard, that is, in the same server, and can be navigated efficiently.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.189.1">In this chapter, we did not talk about how to define sharding with Azure SQL. </span><span class="koboSpan" id="kobo.189.2">Here is the link to the official documentation if you want to find out more: </span><a href="https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction"><span class="url"><span class="koboSpan" id="kobo.190.1">https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction</span></span></a><span class="koboSpan" id="kobo.191.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.192.1">Multi-tenant applications are not rare in the cloud since all applications that offer the same services to several different users are often implemented as multi-tenant applications, where each tenant corresponds to a user subscription. </span><span class="koboSpan" id="kobo.192.2">Accordingly, relational databases, such as Azure SQL Server, are conceived to work in the cloud and usually offer sharding options for multi-tenant applications. </span><span class="koboSpan" id="kobo.192.3">Typically, sharding is not a cloud service and must be defined with database engine commands. </span><span class="koboSpan" id="kobo.192.4">Here, we will not describe how to define shards with Azure SQL Server, but the </span><em class="italic"><span class="koboSpan" id="kobo.193.1">Further reading</span></em><span class="koboSpan" id="kobo.194.1"> section contains a link to the official Microsoft documentation. </span><span class="koboSpan" id="kobo.194.2">The following table presents the pros and cons of</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.195.1"> each database approach:</span></p>
<table class="table-container" id="table001-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.196.1">Subject</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.197.1">SQL</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.198.1">NoSQL document-oriented DB</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.199.1">Schema</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.200.1">Easy to deal with in well-structured schemas. </span><span class="koboSpan" id="kobo.200.2">Today, it is possible to design hybrid solutions with JSON/XML columns to store unstructured data.</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.201.1">Preferred when data has almost no predefined structure.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.202.1">Performance</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.203.1">In general, bad performance in distributed environments.</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.204.1">In general, good performance for reading and writing distributed data.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.205.1">Language</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.206.1">Declarative to query and update data, standard.</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.207.1">Procedural to query and update operations.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.208.1">Consistency</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.209.1">Strong use of foreign keys.</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.210.1">Weak and left to the developer's decision. </span><span class="koboSpan" id="kobo.210.2">All related objects that are likely to be processed together into a single entry.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.211.1">Transactions</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.212.1">Supported.</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.213.1">By default, they are not supported.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.214.1">Scale</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.215.1">Vertically upgrading hardware.</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.216.1">Horizontally with data sharding.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.217.1">Table 12.1: Pros and cons for each database approach</span></p>
<p class="normal"><span class="koboSpan" id="kobo.218.1">In conclusion, relational databases offer a pure, logical view of data that is independent of the way they are stored and use declarative language to query and update them. </span><span class="koboSpan" id="kobo.218.2">This simplifies development and system maintenance, but it may cause performance issues in a distributed environment that requires write scale-out. </span><span class="koboSpan" id="kobo.218.3">It is also worth noting that tools like Entity Framework, presented in </span><em class="italic"><span class="koboSpan" id="kobo.219.1">Chapter 13</span></em><span class="koboSpan" id="kobo.220.1">, </span><em class="italic"><span class="koboSpan" id="kobo.221.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.222.1">, help in bridging the gap between objects and relational data, making development more intuitive for relational databases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.223.1">In NoSQL document-oriented databases, you must handle more details about how to store data, as well as some procedural details for all the update and query operations, manually, but this allows you to optimize performance in distributed environments that require both read and write scale-out. </span><span class="koboSpan" id="kobo.223.2">On the flip side, working with NoSQL data, especially when it involves deserializing formats like JSON or XML, can be tricky. </span><span class="koboSpan" id="kobo.223.3">It often requires careful </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.224.1">mapping to ensure data integrity, which can be both challenging and error-prone. </span><span class="koboSpan" id="kobo.224.2">In the next section, we will look at Azure Cosmos DB, the main Azure NoSQL offering, which, fortunately, can be integrated with Entity Framework for a more streamlined development experience.</span></p>
<h1 class="heading-1" id="_idParaDest-255"><span class="koboSpan" id="kobo.225.1">Azure Cosmos DB – an opportunity to manage a multi-continental database</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.226.1">Azure Cosmos DB is </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.227.1">Azure’s main NoSQL offering. </span><span class="koboSpan" id="kobo.227.2">Azure Cosmos DB has its own interface that is a subset of SQL, but it can be configured with a MongoDB interface, a Table API, or a Cassandra API. </span><span class="koboSpan" id="kobo.227.3">It can also be configured as a graph data model that can be queried with Gremlin.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.228.1">You can find further details about Cosmos DB in the official documentation: </span><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/"><span class="url"><span class="koboSpan" id="kobo.229.1">https://docs.microsoft.com/en-us/azure/cosmos-db/</span></span></a><span class="koboSpan" id="kobo.230.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.231.1">Cosmos DB allows replication for fault tolerance and read scale-out, and replicas can be distributed geographically to optimize communication performance. </span><span class="koboSpan" id="kobo.231.2">Moreover, you can specify which data center all the replicas are placed in. </span><span class="koboSpan" id="kobo.231.3">The user also has the option to write-enable all the replicas so that writes are immediately available in the geographical area where they are done. </span><span class="koboSpan" id="kobo.231.4">Write scale-up is achieved with sharding, which the user can configure by</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.232.1"> defining which properties to use as shard keys.</span></p>
<h2 class="heading-2" id="_idParaDest-256"><span class="koboSpan" id="kobo.233.1">Creating an Azure Cosmos DB account</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.234.1">You can define</span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.235.1"> a Cosmos DB account by typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">Cosmos DB</span></code><span class="koboSpan" id="kobo.237.1"> into the Azure portal search bar and clicking </span><strong class="keyWord"><span class="koboSpan" id="kobo.238.1">+ Create</span></strong><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">The following page will appear:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.240.1"><img alt="Interface gráfica do usuário, Aplicativo  Descrição gerada automaticamente" src="../Images/B19820_12_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.241.1">Figure 12.5: Creating an Azure Cosmos DB account</span></p>
<p class="normal"><span class="koboSpan" id="kobo.242.1">For instance, if you select the </span><strong class="keyWord"><span class="koboSpan" id="kobo.243.1">Core (SQL)</span></strong><span class="koboSpan" id="kobo.244.1"> option, the account name you choose is used in the resource URI as </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">{account_name}.documents.azure.com</span></code><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">Then, you can decide which location the main database will be placed in and the capacity mode. </span><span class="koboSpan" id="kobo.246.3">You can check more information about the capacity modes available at </span><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/throughput-serverless"><span class="url"><span class="koboSpan" id="kobo.247.1">https://docs.microsoft.com/en-us/azure/cosmos-db/throughput-serverless</span></span></a><span class="koboSpan" id="kobo.248.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.249.1">Microsoft keeps improving many of its Azure services. </span><span class="koboSpan" id="kobo.249.2">The best way to keep updated about new features of any Azure component is by checking its documentation from time to time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">On the </span><strong class="keyWord"><span class="koboSpan" id="kobo.251.1">Global Distribution</span></strong><span class="koboSpan" id="kobo.252.1"> tab, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.253.1">Multi-region Writes</span></strong><span class="koboSpan" id="kobo.254.1"> toggle lets you enable writes on geographically distributed replicas. </span><span class="koboSpan" id="kobo.254.2">If you do not do this, all write operations will be routed to the main location. </span><span class="koboSpan" id="kobo.254.3">Finally, you may also define network connectivity, backup policies, and encryption </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.255.1">during the creation process.</span></p>
<h2 class="heading-2" id="_idParaDest-257"><span class="koboSpan" id="kobo.256.1">Creating an Azure Cosmos DB container</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.257.1">Once you have </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.258.1">created your Azure Cosmos DB – Core SQL account, select </span><strong class="keyWord"><span class="koboSpan" id="kobo.259.1">Data Explorer</span></strong><span class="koboSpan" id="kobo.260.1"> to create your databases and containers inside of them. </span><span class="koboSpan" id="kobo.260.2">A container is the unit of scalability both for provisioned throughput and storage, available when you decide by provisioned throughput capacity mode.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.261.1">Since databases just have a name and no configuration, you can </span><strong class="keyWord"><span class="koboSpan" id="kobo.262.1">Add a container</span></strong><span class="koboSpan" id="kobo.263.1"> directly and then place the database where you wish:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.264.1"><img alt="Interface gráfica do usuário, Texto, Aplicativo, Email  Descrição gerada automaticamente" src="../Images/B19820_12_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.265.1">Figure 12.6: Adding a container in Azure Cosmos DB</span></p>
<p class="normal"><span class="koboSpan" id="kobo.266.1">Here, you can decide on database and container names and the property to use for sharding (the partition key). </span><span class="koboSpan" id="kobo.266.2">Since NoSQL entries are object trees, property names are specified as paths. </span><span class="koboSpan" id="kobo.266.3">You can also add properties whose values are required to be unique.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.267.1">However, the uniqueness of IDs is checked inside each partition, so this option is only useful in certain situations, such as multi-tenant applications (where each tenant is included in a single shard). </span><span class="koboSpan" id="kobo.267.2">The fees depend on the collection throughput that you choose.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.268.1">This is where you need to target all resource parameters to your needs. </span><span class="koboSpan" id="kobo.268.2">Throughput is expressed in request units per second, where request units per second are defined as the throughput we </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.269.1">have when performing a read of 1 KB per second. </span><span class="koboSpan" id="kobo.269.2">Hence, if you check the </span><strong class="keyWord"><span class="koboSpan" id="kobo.270.1">Provision database throughput</span></strong><span class="koboSpan" id="kobo.271.1"> option, the chosen throughput is shared with the whole database instead of being reserved as a single collection.</span></p>
<h2 class="heading-2" id="_idParaDest-258"><span class="koboSpan" id="kobo.272.1">Accessing Azure Cosmos DB</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.273.1">After creating the</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.274.1"> Azure Cosmos container, you will be able to access data. </span><span class="koboSpan" id="kobo.274.2">To get connection information, you can select the </span><strong class="keyWord"><span class="koboSpan" id="kobo.275.1">Keys</span></strong><span class="koboSpan" id="kobo.276.1"> menu. </span><span class="koboSpan" id="kobo.276.2">There, you will see all the information you need to connect with your Cosmos DB account from your application. </span><span class="koboSpan" id="kobo.276.3">The connection information page will provide you with the account URI and two connection keys, which can be used interchangeably to connect with the account.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.277.1"><img alt="Text  Description automatically generated with medium confidence" src="../Images/B19820_12_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.278.1">Figure 12.7: Connection information page</span></p>
<p class="normal"><span class="koboSpan" id="kobo.279.1">There are also keys with read-only privileges. </span><span class="koboSpan" id="kobo.279.2">Every key can be regenerated, and each account has two equivalent keys, like many other Azure components. </span><span class="koboSpan" id="kobo.279.3">This approach enables operations </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.280.1">to be handled efficiently; that is, when a key is changed, the other one is kept. </span><span class="koboSpan" id="kobo.280.2">Therefore, existing applications can continue using the other key before upgrading to the new key.</span></p>
<h2 class="heading-2" id="_idParaDest-259"><span class="koboSpan" id="kobo.281.1">Defining database consistency</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.282.1">Considering that you</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.283.1"> are in the context of a distributed database, Azure Cosmos DB enables you to define the default read consistency level you will have. </span><span class="koboSpan" id="kobo.283.2">By </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.284.1">selecting </span><strong class="keyWord"><span class="koboSpan" id="kobo.285.1">Default consistency</span></strong><span class="koboSpan" id="kobo.286.1"> in the main menu of your Cosmos DB account, you can choose the default replication consistency that you wish to apply to all your containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.287.1">This default can be overridden in each container, either from Data Explorer or programmatically. </span><span class="koboSpan" id="kobo.287.2">Consistency problems in read/write operations are a consequence of data replication. </span><span class="koboSpan" id="kobo.287.3">More specifically, the results of various read operations may be incoherent if the read operations are executed on different replicas that have received different partial updates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.288.1">The following are the available consistency levels. </span><span class="koboSpan" id="kobo.288.2">These have been ordered from the weakest to the strongest:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.289.1">Eventual</span></strong><span class="koboSpan" id="kobo.290.1">: After enough</span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.291.1"> time has passed, if no further write operations are done, all the reads converge and apply all the writes. </span><span class="koboSpan" id="kobo.291.2">The order of writes is also not guaranteed, so while writes are being processed, you could also end up reading an earlier version than the one you have previously read.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.292.1">Consistent prefix</span></strong><span class="koboSpan" id="kobo.293.1">: All the writes are executed in the same order on all the replicas. </span><span class="koboSpan" id="kobo.293.2">So, if there are </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">n</span></code><span class="koboSpan" id="kobo.295.1"> write operations, each read is consistent with the result of applying the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">m</span></code><span class="koboSpan" id="kobo.297.1"> writes for some </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">m</span></code><span class="koboSpan" id="kobo.299.1"> less than or equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">n</span></code><span class="koboSpan" id="kobo.301.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.302.1">Session</span></strong><span class="koboSpan" id="kobo.303.1">: This is the same as the consistency prefix but also guarantees that each writer sees the result of its own writes in all subsequent read operations and that subsequent reads of each reader are coherent (either the same database or a more updated version of it).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.304.1">Bounded staleness</span></strong><span class="koboSpan" id="kobo.305.1">: This is associated either with a delay time, </span><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">Delta</span></code><span class="koboSpan" id="kobo.307.1">, or with several operations, </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">N</span></code><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">Each read sees the results of all the write operations that were performed before a time </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">Delta</span></code><span class="koboSpan" id="kobo.311.1"> (or before the last </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">N</span></code><span class="koboSpan" id="kobo.313.1"> operations). </span><span class="koboSpan" id="kobo.313.2">That is, its reads converge with the result of all the writes with a maximum time delay of </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">Delta</span></code><span class="koboSpan" id="kobo.315.1"> (or a maximum operations delay of </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">N</span></code><span class="koboSpan" id="kobo.317.1">).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.318.1">Strong</span></strong><span class="koboSpan" id="kobo.319.1">: This is bounded staleness combined with </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">Delta = 0</span></code><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">Here, each read reflects the </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.322.1">result of all previous write operations.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.323.1">The strongest consistency can be obtained to the detriment of performance. </span><span class="koboSpan" id="kobo.323.2">By default, the consistency is set to </span><strong class="keyWord"><span class="koboSpan" id="kobo.324.1">Session</span></strong><span class="koboSpan" id="kobo.325.1">, which is a good compromise between coherence and performance. </span><span class="koboSpan" id="kobo.325.2">A lower level of consistency is difficult to handle in applications and is only usually acceptable if sessions are either read-only or write-only.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.326.1">If you select the </span><strong class="keyWord"><span class="koboSpan" id="kobo.327.1">Settings</span></strong><span class="koboSpan" id="kobo.328.1"> option in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.329.1">Data Explorer</span></strong><span class="koboSpan" id="kobo.330.1"> menu of the container of your database, you can configure which paths to index and which kind of indexing to apply to each data type of </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.331.1">each path. </span><span class="koboSpan" id="kobo.331.2">The configuration consists of a JSON object. </span><span class="koboSpan" id="kobo.331.3">Let us analyze its various properties:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation"><span class="koboSpan" id="kobo.332.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.333.1">"indexingMode"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.334.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.335.1">"consistent"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.336.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.337.1">"automatic"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.338.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.340.1">,</span></span><span class="koboSpan" id="kobo.341.1">
    ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.342.1">If you set </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">indexingMode</span></code><span class="koboSpan" id="kobo.344.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">none</span></code><span class="koboSpan" id="kobo.346.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">consistent</span></code><span class="koboSpan" id="kobo.348.1">, no index is generated, and the collection can be used as a key-value dictionary that is indexed by the collection’s primary key. </span><span class="koboSpan" id="kobo.348.2">In this scenario, no secondary indexes are generated, so the primary key cannot efficiently be searched.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.349.1">When </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">automatic</span></code><span class="koboSpan" id="kobo.351.1"> is set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">true</span></code><span class="koboSpan" id="kobo.353.1">, all document properties are automatically indexed:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation"><span class="koboSpan" id="kobo.354.1">{</span></span><span class="koboSpan" id="kobo.355.1">
    ...
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.356.1">"includedPaths"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.357.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.358.1">[</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.359.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.360.1">"path"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.361.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.362.1">"/*"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.363.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.364.1">"indexes"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.365.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.366.1">[</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.367.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.368.1">"kind"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.369.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.370.1">"Range"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.371.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.372.1">"dataType"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.373.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.374.1">"Number"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.375.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.376.1">"</span></span><span class="hljs-attr"><span class="koboSpan" id="kobo.377.1">precision"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.378.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.379.1">-1</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.380.1">},</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.381.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.382.1">"kind"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.383.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.384.1">"Range"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.385.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.386.1">"dataType"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.387.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.388.1">"String"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.389.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.390.1">"precision"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.391.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.392.1">-1</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.393.1">},</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.394.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.395.1">"kind"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.396.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.397.1">"Spatial"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.398.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.399.1">"dataType"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.400.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.401.1">"Point"</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.402.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.403.1">]</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.404.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.405.1">]</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.406.1">},</span></span><span class="koboSpan" id="kobo.407.1">
...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.408.1">Each entry in </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">includedPaths</span></code><span class="koboSpan" id="kobo.410.1"> specifies a path pattern such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">/subpath1/subpath2/?</span></code><span class="koboSpan" id="kobo.412.1"> (settings apply just to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">/subpath1/subpath2/property</span></code><span class="koboSpan" id="kobo.414.1">) or </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">/subpath1/subpath2/*</span></code><span class="koboSpan" id="kobo.416.1"> (settings apply to all the paths starting with </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">/subpath1/subpath2/</span></code><span class="koboSpan" id="kobo.418.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.419.1">Patterns contain the </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">[]</span></code><span class="koboSpan" id="kobo.421.1"> symbol when settings must be applied to child objects contained in collection properties; for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">/subpath1/subpath2/[]/?</span></code><span class="koboSpan" id="kobo.423.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">/subpath1/subpath2/[]/childpath1/?</span></code><span class="koboSpan" id="kobo.425.1">, and so on. </span><span class="koboSpan" id="kobo.425.2">Settings specify the index type to apply to each data type (string, number, geographic point, and so on). </span><span class="koboSpan" id="kobo.425.3">Range indexes are needed for comparison operations, while hash indices are more efficient if we need equality comparisons.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.426.1">It is possible to </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.427.1">specify a precision, that is, the maximum number of characters or digits to use in all the index keys. </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">-1</span></code><span class="koboSpan" id="kobo.429.1"> means the maximum precision and is always recommended:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.430.1">    ...
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.431.1">"excludedPaths"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.432.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.433.1">[</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.434.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.435.1">"path"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.436.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.437.1">"/\"_etag\"/?"</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.438.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.439.1">]</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.440.1">Paths contained in </span><code class="inlineCode"><span class="koboSpan" id="kobo.441.1">excludedPaths</span></code><span class="koboSpan" id="kobo.442.1"> are not indexed at all. </span><span class="koboSpan" id="kobo.442.2">Index settings can also be specified programmatically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.443.1">Here, you have two options to connect to Cosmos DB: use a version of its official client for your preferred programming language or use Cosmos DB’s Entity Framework Core provider. </span><span class="koboSpan" id="kobo.443.2">In the following subsections, we will have a look at both options. </span><span class="koboSpan" id="kobo.443.3">Then, we will describe how to use Cosmos DB’s Entity Framework Core provider with a practical example.</span></p>
<h2 class="heading-2" id="_idParaDest-260"><span class="koboSpan" id="kobo.444.1">The Cosmos DB client</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.445.1">The Cosmos DB client </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.446.1">for .NET 8 is available through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">Microsoft.Azure.Cosmos</span></code><span class="koboSpan" id="kobo.448.1"> NuGet package. </span><span class="koboSpan" id="kobo.448.2">It offers full control of all Cosmos DB features, while the Cosmos DB Entity Framework provider is easier to use but hides some Cosmos DB peculiarities. </span><span class="koboSpan" id="kobo.448.3">Follow these steps to interact with Cosmos DB through the official Cosmos DB client for .NET 8.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.449.1">The following code sample shows the creation of a database and a container using the client component. </span><span class="koboSpan" id="kobo.449.2">Any operation requires the creation of a client object. </span><span class="koboSpan" id="kobo.449.3">Do not forget that the client must be disposed of by calling its </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">Dispose</span></code><span class="koboSpan" id="kobo.451.1"> method (or by enclosing the code that references it in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">using</span></code><span class="koboSpan" id="kobo.453.1"> statement) when you do not need it anymore:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.454.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.455.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.456.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.457.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.458.1">CreateCosmosDB</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.459.1">()</span></span><span class="koboSpan" id="kobo.460.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.461.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.462.1">var</span></span><span class="koboSpan" id="kobo.463.1"> cosmosClient = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.464.1">new</span></span><span class="koboSpan" id="kobo.465.1"> CosmosClient(endpoint, key);
    Database database = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.466.1">await</span></span><span class="koboSpan" id="kobo.467.1">
        cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);
    ContainerProperties cp = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.468.1">new</span></span><span class="koboSpan" id="kobo.469.1"> ContainerProperties(containerId,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.470.1">"/DestinationName"</span></span><span class="koboSpan" id="kobo.471.1">);
    Container container = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.472.1">await</span></span><span class="koboSpan" id="kobo.473.1"> database.CreateContainerIfNotExistsAsync(cp);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">await</span></span><span class="koboSpan" id="kobo.475.1"> AddItemsToContainerAsync(container);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.476.1">During collection creation, you can pass a </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">ContainerProperties</span></code><span class="koboSpan" id="kobo.478.1"> object, where you can specify the consistency level, how to index properties, and all the other collection features.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.479.1">Then, you must define the .NET classes that correspond to the structure of the JSON document you need to manipulate in your collections. </span><span class="koboSpan" id="kobo.479.2">You can also use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">JsonProperty</span></code><span class="koboSpan" id="kobo.481.1"> attribute to map class property names to JSON names if they are not equal:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.483.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.484.1">Destination</span></span><span class="koboSpan" id="kobo.485.1">
{
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.486.1">JsonPropertyName(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.487.1">"id"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.488.1">)</span></span><span class="koboSpan" id="kobo.489.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.490.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.491.1">string</span></span><span class="koboSpan" id="kobo.492.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.493.1">get</span></span><span class="koboSpan" id="kobo.494.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.495.1">set</span></span><span class="koboSpan" id="kobo.496.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.497.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.498.1">string</span></span><span class="koboSpan" id="kobo.499.1"> DestinationName { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.500.1">get</span></span><span class="koboSpan" id="kobo.501.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.502.1">set</span></span><span class="koboSpan" id="kobo.503.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.504.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.505.1">string</span></span><span class="koboSpan" id="kobo.506.1"> Country { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.507.1">get</span></span><span class="koboSpan" id="kobo.508.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.509.1">set</span></span><span class="koboSpan" id="kobo.510.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.511.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.512.1">string</span></span><span class="koboSpan" id="kobo.513.1"> Description { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.514.1">get</span></span><span class="koboSpan" id="kobo.515.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.516.1">set</span></span><span class="koboSpan" id="kobo.517.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.518.1">public</span></span><span class="koboSpan" id="kobo.519.1"> Package[] Packages { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.520.1">get</span></span><span class="koboSpan" id="kobo.521.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.522.1">set</span></span><span class="koboSpan" id="kobo.523.1">; }
}
</span></code></pre>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.524.1">NoSQL means Not Only SQL, so it is also possible to map properties. </span><span class="koboSpan" id="kobo.524.2">The great thing about NoSQL is that you must map these properties without causing damage to other properties or information you have in the document you are connecting to.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.525.1">Once you have all the necessary classes, you can use client methods to </span><code class="inlineCode"><span class="koboSpan" id="kobo.526.1">ReadItemAsync</span></code><span class="koboSpan" id="kobo.527.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">CreateItemAsync</span></code><span class="koboSpan" id="kobo.529.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.530.1">DeleteItemAsync</span></code><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">You can also query data using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.532.1">QueryDefinition</span></code><span class="koboSpan" id="kobo.533.1"> object</span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.534.1"> that accepts SQL commands. </span><span class="koboSpan" id="kobo.534.2">You can find a complete introduction to this library at </span><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started"><span class="url"><span class="koboSpan" id="kobo.535.1">https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started</span></span></a><span class="koboSpan" id="kobo.536.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-261"><span class="koboSpan" id="kobo.537.1">The Cosmos DB Entity Framework Core provider</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.538.1">The Cosmos DB</span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.539.1"> provider for Entity Framework </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.540.1">Core is contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">Microsoft.EntityFrameworkCore.Cosmos</span></code><span class="koboSpan" id="kobo.542.1"> NuGet package. </span><span class="koboSpan" id="kobo.542.2">Once you’ve added this to your project, you can proceed in a similar way to when you used the SQL Server provider in </span><em class="italic"><span class="koboSpan" id="kobo.543.1">Chapter 13</span></em><span class="koboSpan" id="kobo.544.1">, </span><em class="italic"><span class="koboSpan" id="kobo.545.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.546.1">, but with a few differences. </span><span class="koboSpan" id="kobo.546.2">Let us take a look:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.547.1">There are no migrations since Cosmos DB databases have no structure to update. </span><span class="koboSpan" id="kobo.547.2">Instead, they have a method that ensures that the database, along with all the necessary collections, is created:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.548.1">context.Database.EnsureCreated();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.549.1">By default, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">DbSet&lt;T&gt;</span></code><span class="koboSpan" id="kobo.551.1"> properties from </span><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">DBContext</span></code><span class="koboSpan" id="kobo.553.1"> are mapped to a unique container since this is the cheapest option. </span><span class="koboSpan" id="kobo.553.2">You can override this default by explicitly specifying which container you want to map some entities to by using the following configuration instruction:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.554.1">builder.Entity&lt;MyEntity&gt;()
     .ToContainer(</span><span class="hljs-string"><span class="koboSpan" id="kobo.555.1">"collection-name"</span></span><span class="koboSpan" id="kobo.556.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.557.1">The only useful annotation on entity classes is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.558.1">Key</span></code><span class="koboSpan" id="kobo.559.1"> attribute, which becomes obligatory when the primary keys are not called </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">Id</span></code><span class="koboSpan" id="kobo.561.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.562.1">Primary keys must be strings and cannot be auto-incremented to avoid synchronization issues in a distributed environment. </span><span class="koboSpan" id="kobo.562.2">The uniqueness of primary keys can be ensured by generating GUIDs and transforming them into strings.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.563.1">When defining relationships between entities, you can specify that an entity or a collection of entities is owned by another entity, in which case it is stored together with the parent entity.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.564.1">We will look at the </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.565.1">usage of Cosmos DB’s Entity</span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.566.1"> Framework provider in the </span><em class="italic"><span class="koboSpan" id="kobo.567.1">How to choose your data storage in the cloud</span></em><span class="koboSpan" id="kobo.568.1"> section of </span><em class="chapterRef"><span class="koboSpan" id="kobo.569.1">Chapter 21</span></em><span class="koboSpan" id="kobo.570.1">, </span><em class="italic"><span class="koboSpan" id="kobo.571.1">Case Study</span></em><span class="koboSpan" id="kobo.572.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-262"><span class="koboSpan" id="kobo.573.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.574.1">In this chapter, we looked at the main storage options available in Azure and learned when to use them. </span><span class="koboSpan" id="kobo.574.2">Then, we compared relational and NoSQL databases. </span><span class="koboSpan" id="kobo.574.3">We pointed out that relational databases offer automatic consistency checking and transaction isolation, but NoSQL databases are cheaper and offer better performance, especially when distributed writes form a high percentage of the average workload.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.575.1">Then, we described Azure’s main NoSQL option, Cosmos DB, and explained how to configure it and how to connect with a client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.576.1">Finally, we learned how to interact with Cosmos DB with Entity Framework Core. </span><span class="koboSpan" id="kobo.576.2">Here, we learned how to decide whether to use relational or NoSQL databases for all families of data involved in an application. </span><span class="koboSpan" id="kobo.576.3">So, you can choose the kind of data storage that ensures the best compromise between data coherence, speed, and parallel access to data in each of your applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.577.1">In the next chapter, we will learn all about how to interact with data in C#–Entity Framework Core.</span></p>
<h1 class="heading-1" id="_idParaDest-263"><span class="koboSpan" id="kobo.578.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.579.1">Is Redis a valid alternative to relational databases?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.580.1">Are NoSQL databases a valid alternative to relational databases?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.581.1">What operation is more difficult to scale out in relational databases?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.582.1">What is the main weakness of NoSQL databases? </span><span class="koboSpan" id="kobo.582.2">What is their main advantage?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.583.1">Can you list all Cosmos DB consistency levels?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.584.1">Can we use auto-increment integer keys with Cosmos DB?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.585.1">Which Entity Framework configuration method is used to store an entity inside its related father document?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.586.1">Can nested collections be searched efficiently with Cosmos DB?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-264"><span class="koboSpan" id="kobo.587.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.588.1">The following is a reference to the Gremlin language, which is supported by Cosmos DB: </span><a href="http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps"><span class="url"><span class="koboSpan" id="kobo.589.1">http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps</span></span></a><span class="koboSpan" id="kobo.590.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.591.1">The following is a general description of the Cosmos DB graph data model: </span><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction"><span class="url"><span class="koboSpan" id="kobo.592.1">https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction</span></span></a><span class="koboSpan" id="kobo.593.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.594.1">Details on how to use Cosmos DB’s official .NET client can be found at </span><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started"><span class="url"><span class="koboSpan" id="kobo.595.1">https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started</span></span></a><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">A good introduction to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">MvcControlsToolkit.Business.DocumentDB</span></code><span class="koboSpan" id="kobo.598.1"> NuGet package that we mentioned in this chapter is the </span><em class="italic"><span class="koboSpan" id="kobo.599.1">Fast Azure Cosmos DB Development with the DocumentDB Package</span></em><span class="koboSpan" id="kobo.600.1"> article contained in Issue 34 of </span><em class="italic"><span class="koboSpan" id="kobo.601.1">DNCMagazine</span></em><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">This can be downloaded from </span><a href="https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb"><span class="url"><span class="koboSpan" id="kobo.603.1">https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb</span></span></a><span class="koboSpan" id="kobo.604.1">.</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.605.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.606.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.607.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.608.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>