<html><head></head><body>
		<div id="_idContainer172">
			<h1 id="_idParaDest-201" class="chapter-number"><a id="_idTextAnchor205"/>12</h1>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor206"/>Performance Optimization and Tuning</h1>
			<p>Performance separates applications that are used and loved from those that are uninstalled and <span class="No-Break">forever forgotten.</span></p>
			<p>It is not enough to have an application that responds to users’ needs. To be used frequently (and likely daily), an application needs to bootstrap and perform <span class="No-Break">tasks quickly.</span></p>
			<p>This speed and responsiveness directly impact user satisfaction, as people have increasingly high expectations for digital experiences. Studies have shown that even small delays in load times or task completion can significantly reduce user engagement and <span class="No-Break">overall satisfaction.</span></p>
			<p>In this chapter, we will discuss different areas where performance can be improved and what techniques we can use to achieve this. More specifically, we will cover <span class="No-Break">the following:</span></p>
			<ul>
				<li>The different areas to be considered to improve <span class="No-Break">application performance</span></li>
				<li>How to instrument an application to identify <span class="No-Break">performance problems</span></li>
				<li>How to improve your <span class="No-Break">application performance</span></li>
			</ul>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor207"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter12"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter12</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor208"/>Performance optimization areas</h1>
			<p>The <a id="_idIndexMarker452"/>performance of an application is not only a matter of code. It is a series of fine tuning, at different levels, that helps achieve <span class="No-Break">performance efficiency.</span></p>
			<p>Performance optimization therefore occurs in areas such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Application design and architecture</strong>: The longer the path you must walk, the longer<a id="_idIndexMarker453"/> it takes you to get to your destination. As I always tell my customers, you may run twice as fast as me, but if your path is twice as long as mine, we will arrive at our destination at the same time. The idea here is that using performant frameworks and libraries is of little use if your architecture is not efficient. Too often, I see architectures that are over-decoupled, with too many hops and context switching, leading to applications that are not performant and slow. The key is to build an architecture that balances performance with the optimal level of decoupling. From a design perspective, I often see designs that can be improved (leading to more efficient and performant applications) by finding a shorter path to achieve a goal. Of course, you won’t do that for every piece of code, but you will want to focus your attention on hot paths, namely paths that are often used by your users. There may be no point in optimizing the performance of a functionality that is used by one user once a year. You must find a balance between the cost of the optimization effort (it takes time, so it has a cost) and the benefit you are expecting <span class="No-Break">from it.</span></li>
				<li><strong class="bold">Infrastructure</strong>: If <a id="_idIndexMarker454"/>we host the application on an infrastructure, we must ensure that this infrastructure is efficient and has been optimized to maximize the throughput of the application while minimizing its latency. However, in the context of CLI applications, the application runs on the user’s computer, so we might be tempted to say that there is nothing to do here, but we would be wrong! There are tuning tasks we can perform that will positively impact performance. For example, we can reduce resource utilization so that running the application on the user’s computer will consume the least amount of resources and therefore will be executed efficiently, even if the computer is running other applications side by <a id="_idIndexMarker455"/>side or has <span class="No-Break">little horsepower.</span></li>
				<li><strong class="bold">Frameworks and libraries</strong>: Of <a id="_idIndexMarker456"/>course, using efficient and performant frameworks and libraries helps to improve the application’s performance. For example, every new release of .NET promises better performance. Hence, upgrading the .NET version can be an easy way to improve the performance of our application. The same goes for the libraries that we use: some are known to have better performance <span class="No-Break">than others.</span></li>
				<li><strong class="bold">Coding practices</strong>: The<a id="_idIndexMarker457"/> last piece of the puzzle is the coding practices. We have already mentioned hot spots and hot paths, but coding practices also include using the most appropriate <span class="No-Break">data structures.</span></li>
			</ul>
			<p>Before we start optimizing our application’s performance, we need to instrument it and identify its hot spots and <span class="No-Break">hot paths.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor209"/>Instrumenting .NET applications</h1>
			<p>Multiple tools <a id="_idIndexMarker458"/>exist to help us instrument.NET applications. The main difference between these tools is their scope <span class="No-Break">of action.</span></p>
			<p>Nevertheless, a key benefit of instrumentation is the ability to detect memory leaks and identify slow <span class="No-Break">code paths.</span></p>
			<p>Instrumentation can be achieved both during the development phase and continuously, while the application is running <span class="No-Break">in production.</span></p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Development-time profiling</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Visual Studio Diagnostic Tools, <strong class="source-inline">BenchmarkDotNet</strong>, <strong class="source-inline">dotTrace</strong>, <strong class="source-inline">dotMemory</strong>, and <strong class="source-inline">PerfView</strong> are great for profiling CPU, memory leaks and allocation, and <span class="No-Break">application performance.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Production-time monitoring</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Azure Application Insights, AppDynamics, and New Relic help monitor and diagnose performance issues in real time in <span class="No-Break">production environments.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – Some popular instrumentation tools</p>
			<p>You may <a id="_idIndexMarker459"/>have noticed the terms <em class="italic">“profiling”</em> and <em class="italic">“monitoring.”</em> There are some key differences <span class="No-Break">between them:</span></p>
			<ul>
				<li>Profiling provides a detailed, granular view of an application’s performance, often focusing on specific code sections or methods. This includes CPU usage per functionality or method, memory allocation, execution time, and method call frequency <span class="No-Break">and duration.</span></li>
				<li>Monitoring is usually done in production and provides an overview of the application’s health, looking at broader performance trends and operational data over time rather than focusing on individual code paths. This includes CPU and memory usage across the entire application, error rates (exceptions, failures), response times and throughput (e.g., how long requests take, how many requests per second), and the application’s resource usage (disk I/O, network <span class="No-Break">usage, etc.).</span></li>
			</ul>
			<p>Because a CLI application runs on the user’s computer, it may be harder to monitor it. It requires permission from the user to collect the necessary data, usually at frequent intervals. We may then expect the user to refuse to share telemetry data, and therefore monitoring may not <span class="No-Break">be possible.</span></p>
			<p>While it is important to know the tools that help us instrument our applications, it is equally important to understand where to use them, in other words, how to identify these areas that may be good candidates for performance optimization. In that regard, it is important to be able to identify hot spots and <span class="No-Break">hot paths.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor210"/>Hot spots versus hot paths</h2>
			<p>This is not the <a id="_idIndexMarker460"/>first time in this chapter that I have mentioned hot spots and hot paths. However, I haven’t taken the time to explain them. Let’s fix this <span class="No-Break">right away!</span></p>
			<p>A <strong class="bold">hot spot</strong> is an <a id="_idIndexMarker461"/>area of intense activity in the code, typically referring to frequently executed methods that consume a significant amount of execution time. Therefore, a hot spot represents<a id="_idIndexMarker462"/> a potential optimization target for improving the overall performance of <span class="No-Break">the application.</span></p>
			<p>A <strong class="bold">hot path</strong> refers<a id="_idIndexMarker463"/> to an execution path through the code that is frequently taken and therefore contributes <em class="italic">significantly</em> to the application’s runtime. Hot paths can help locate inefficiently used resources, such as memory usage <span class="No-Break">and allocation.</span></p>
			<p>The question that may arise here is <em class="italic">“what process can we follow to identify the application’s hot spots and </em><span class="No-Break"><em class="italic">hot paths?”</em></span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor211"/>Identifying the application’s hot spots and hot paths</h2>
			<p>Fortunately, identifying an <a id="_idIndexMarker464"/>application’s hot spots and hot paths does not have to be done by shots in the dark. Instead, we can follow a structured process that consists of three steps: profiling, analysis, and optimization. If monitoring is implemented, it will serve as an input for that process, since this process should be performed periodically to ensure optimal performance of <span class="No-Break">the application.</span></p>
			<p>The process is described in the <span class="No-Break">following table:</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Step</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">What </strong><span class="No-Break"><strong class="bold">to do</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<ol>
								<li>Profiling and <span class="No-Break">data collection</span></li>
							</ol>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Use performance profilers to gather data about your application’s execution. A library such as <strong class="source-inline">BenchmarkDotNet</strong> can collect detailed information about CPU usage, memory consumption, and <span class="No-Break">execution times.</span></li>
								<li>Collect metrics on method execution times, resource usage, and frequency of calls to identify <span class="No-Break">performance bottlenecks.</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<ol>
								<li value="2">Analysis and <span class="No-Break">identification</span></li>
							</ol>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Analyze the profiler output <span class="No-Break">and find:</span><ul><li>Methods with high <span class="No-Break">execution times</span></li><li>Frequently <span class="No-Break">called methods</span></li><li>Areas of high CPU or <span class="No-Break">memory usage</span></li><li>Long-running database queries or <span class="No-Break">I/O operations</span></li></ul></li>
								<li>Look for patterns in the data that indicate potential hot spots or <span class="No-Break">hot paths:</span><ul><li>Methods that consume a disproportionate amount <span class="No-Break">of resources</span></li><li>Execution paths that are frequently taken and contribute significantly to the <span class="No-Break">overall runtime</span></li></ul></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<ol>
								<li value="3"><span class="No-Break">Optimization</span></li>
							</ol>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Once hot spots and hot paths are identified, implement optimizations targeting <span class="No-Break">these areas.</span></li>
								<li>Use benchmarking tools such as <strong class="source-inline">BenchmarkDotNet</strong> to measure and compare the performance of the code before and after optimization to assess the gain in performance. You may also measure and compare different implementations to identify the most <span class="No-Break">optimal one.</span></li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.2 – Identifying hot spots and hot paths</p>
			<p>We mentioned that <strong class="source-inline">BenchmarkDotNet</strong> can help us profile our application. Then, it is time to<a id="_idIndexMarker465"/> learn how to <span class="No-Break">use it.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor212"/>Profiling Bookmarkr with BenchmarkDotNet</h2>
			<p>Although <strong class="source-inline">BenchmarkDotNet</strong> is considered to be a benchmarking library (that is, it is used<a id="_idIndexMarker466"/> to compare different implementation alternatives against a baseline to identify which one is the most performant), when used strategically, it can also<a id="_idIndexMarker467"/> identify hot spots and hot paths in <span class="No-Break">our code.</span></p>
			<p>Let’s see how we can leverage this library to profile our <span class="No-Break">CLI application.</span></p>
			<p>The first thing we <a id="_idIndexMarker468"/>need to do is to reference the <strong class="source-inline">BenchmarkDotNet</strong> library. This can be achieved by executing the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet add package BenchmarkDotNet</pre>			<p>The next step is to configure benchmark collection and reporting. For that matter, let’s add the following block of code at the very beginning of the <span class="No-Break"><strong class="source-inline">Main</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
if(args.Length &gt; 0 &amp;&amp; args[0].ToLower() == "benchmark")
{
    BenchmarkRunner.Run&lt;Benchmarks&gt;();
    return 0;
}</pre>			<p>This allows us to run the benchmarks if we execute the application and pass <strong class="source-inline">benchmark</strong> as <span class="No-Break">a parameter.</span></p>
			<p>What this block of code does is ask <strong class="source-inline">BenchmarkDotNet</strong> (via the <strong class="source-inline">BenchmarkRunner</strong> class) to run all the benchmarks that will be found in the <span class="No-Break"><strong class="source-inline">Benchmarks</strong></span><span class="No-Break"> class.</span></p>
			<p>Let’s create that <span class="No-Break"><strong class="source-inline">Benchmarks</strong></span><span class="No-Break"> class!</span></p>
			<p>Following the folder structure convention that we defined in previous chapters, we will create a <strong class="source-inline">Benchmarks</strong> folder within which we will create a <span class="No-Break"><strong class="source-inline">Benchmarks.cs</strong></span><span class="No-Break"> file.</span></p>
			<p>We can either have a single class where all benchmarks are located, or we can create one benchmark class for every command or service to be benchmarked. We will take the first approach in this chapter as we will only benchmark the <span class="No-Break"><strong class="source-inline">export</strong></span><span class="No-Break"> command.</span></p>
			<p>Let’s add our <a id="_idIndexMarker469"/>first benchmark method. Its code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public async Task ExportBookmarks()
{
    var exportCmd = new ExportCommand(_service!, "export", "Exports 
    all bookmarks to a file");
    var exportArgs = new string[] { "--file", "bookmarksbench.json" };
    await exportCmd.InvokeAsync(exportArgs);
}</pre>			<p>This <a id="_idIndexMarker470"/>method creates an instance of the <strong class="source-inline">ExportCommand</strong> class and executes it by calling its <strong class="source-inline">InvokeAsync</strong> method, passing in the required parameters for <span class="No-Break">the command.</span></p>
			<p>Right now, this method is not yet considered as a benchmark by the <strong class="source-inline">BenchmarkRunner</strong> class. The reason is that for a method to be considered as a benchmark, it needs to be decorated with the <strong class="source-inline">[Benchmark]</strong> attribute. Let’s <span class="No-Break">fix this!</span></p>
			<pre class="source-code">
[Benchmark]
public async Task ExportBookmarks()
{
    var exportCmd = new ExportCommand(_service!, "export", "Exports 
    all bookmarks to a file");
    var exportArgs = new string[] { "--file", "bookmarksbench.json" };
    await exportCmd.InvokeAsync(exportArgs);
}</pre>			<p>Awesome! But we are not ready to run <span class="No-Break">it yet…</span></p>
			<p>See <span class="No-Break">what’s missing?</span></p>
			<p>You got it! The <strong class="source-inline">ExportCommand</strong> class takes an instance of type <strong class="source-inline">IBookmarkService</strong> as a parameter, but we haven’t so far provided such an instance of <span class="No-Break">an object.</span></p>
			<p>Since we<a id="_idIndexMarker471"/> already have such an instance defined in the <strong class="source-inline">Program</strong> class, you may expect that we can pass it to the <strong class="source-inline">Benchmarks</strong> class through its constructor, and this would be a<a id="_idIndexMarker472"/> perfectly reasonable assumption. However, the <strong class="source-inline">BenchmarkRunner</strong> class does not allow us to do so (at least with the current version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">BenchmarkDotNet</strong></span><span class="No-Break">).</span></p>
			<p>What we will do instead is to instantiate this object in the <strong class="source-inline">Benchmarks</strong> class directly. The code will then look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
#region Properties
private IBookmarkService? _service;
#endregion
#region GlobalSetup
[GlobalSetup]
public void BenchmarksGlobalSetup()
{
    _service = new BookmarkService();
}
#endregion</pre>			<p>Notice that the instantiation of the service is not performed in the class constructor but rather in a method decorated with the <strong class="source-inline">[GlobalSetup]</strong> attribute. This special attribute instructs <strong class="source-inline">BenchmarkDotNet</strong> to call this method once before executing each benchmark method. This is to have a clean instance of the service for each benchmark method, hence preventing side effects from <span class="No-Break">previous benchmarks.</span></p>
			<p class="callout-heading">GlobalSetup versus class constructor</p>
			<p class="callout">The execution time of the <strong class="source-inline">[GlobalSetup]</strong> method is not taken into account in calculating the benchmarked method execution time, as opposed to the execution time of the constructor. While this might seem negligible, it will not be if the method is meant to be executed a significant number <span class="No-Break">of times.</span></p>
			<p>We are <a id="_idIndexMarker473"/>now ready to execute <span class="No-Break">our benchmark.</span></p>
			<p>To do this, we <a id="_idIndexMarker474"/>first need to build the application, but this time we need to build it in <strong class="source-inline">Release</strong> mode. Otherwise, <strong class="source-inline">BenchmarkDotNet</strong> will generate an error. The reason is that running a program in <strong class="source-inline">Debug</strong> mode is not optimal and has a significant performance cost compared to running the program in <strong class="source-inline">Release</strong> mode, which is the mode the application should be run on in production. Therefore, when benchmarking our application, we should do it in its optimal <span class="No-Break">performance mode.</span></p>
			<p class="callout-heading">Debug vs Release modes</p>
			<p class="callout">Building the code in <strong class="source-inline">Debug</strong> mode produces unoptimized code with full symbolic <strong class="source-inline">debug</strong> information, enabling easier debugging and breakpoint setting. In contrast, <strong class="source-inline">Release</strong> mode generates optimized code for better performance and smaller file sizes. <strong class="source-inline">Release</strong> builds typically omit <strong class="source-inline">debug</strong> symbols, inline methods, and apply various optimizations that can make debugging more challenging but result in faster execution. While <strong class="source-inline">Debug</strong> builds are ideal for development and troubleshooting, <strong class="source-inline">Release</strong> builds are used when deploying <span class="No-Break">to production.</span></p>
			<p>Building the application in <strong class="source-inline">Release</strong> mode can be achieved by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet build -c Release</pre>			<p>We then run the benchmarks by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet C:\code\Chap12\bookmarkr\bin\Release\net8.0\bookmarkr.dll benchmark</pre>			<p><strong class="source-inline">C:\code\Chap12\bookmarkr\bin\Release\net8.0</strong> is the location of the generated DLL of the <span class="No-Break">Bookmarkr application.</span></p>
			<p>The result is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B22400_12_01.jpg" alt="Figure 12.1 – Benchmarking the export command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Benchmarking the export command</p>
			<p>The<a id="_idIndexMarker475"/> benchmark method has run 98 times and, on average, it takes 6.356 milliseconds to run the <strong class="source-inline">export</strong> command, which is not bad at all, <span class="No-Break">is it?</span></p>
			<p>You can see <a id="_idIndexMarker476"/>the table in the middle of the screen. This table compiles the metrics per benchmark method. Let’s explain what each of its <span class="No-Break">columns represents:</span></p>
			<ul>
				<li><strong class="source-inline">Mean</strong>: This represents the average duration of the benchmarked method over all its executions (98 in <span class="No-Break">our example).</span></li>
				<li><strong class="source-inline">Error</strong>: Simply stated, this value represents the precision of the mean value’s measurement. The smaller the error, the more precise the measurement of the mean value. As an example, since our mean value is 6.356 ms and the error is 0.7840 ms, all measurements fall within the range of 6.356 ms ± 0.7840 ms, which means between 5.572 ms and <span class="No-Break">7.140 ms.</span></li>
				<li><strong class="source-inline">StdDev</strong>: This value represents the standard deviation of all measurements. It quantifies the amount of variation or dispersion in the execution times. In other words, a lower value of <strong class="source-inline">StdDev</strong> indicates that the execution times are clustered closely around <span class="No-Break">the mean.</span></li>
			</ul>
			<p class="callout-heading">Benchmarking is not only for commands!</p>
			<p class="callout">Although we are benchmarking a command here, it is important to note that benchmarking does not only apply to commands but rather to all code artifacts that may have an impact on the application’s performance, which also includes services. Therefore, by benchmarking commands <em class="italic">and</em> the services they use, we can determine the percentage of the execution time and memory consumption that is attributable to the service and <span class="No-Break">the command.</span></p>
			<p>Great! There is, however, one<a id="_idIndexMarker477"/> measurement that we haven’t seen here, which is the measurement of memory consumption. Let’s <span class="No-Break">fix that!</span></p>
			<p>To collect <a id="_idIndexMarker478"/>data about memory consumption, we simply need to add the <strong class="source-inline">[MemoryDiagnoser]</strong> tag on top of the <strong class="source-inline">Benchmarks</strong> class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[MemoryDiagnoser]
public class Benchmarks
{
    // …
}</pre>			<p>Now, if we run the code in exactly the same way as before, we get the <span class="No-Break">following results:</span></p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B22400_12_02.jpg" alt="Figure 12.2 – Benchmarking memory consumption"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Benchmarking memory consumption</p>
			<p>Notice that <a id="_idIndexMarker479"/>now we have a new column called <strong class="source-inline">Allocated</strong>, which represents the amount of allocated memory for every execution of the benchmarked method, in kilobytes. This <a id="_idIndexMarker480"/>column is interesting for <span class="No-Break">two reasons:</span></p>
			<ul>
				<li>It allows us to see if the benchmarked method is using way too much memory than it should (or way more than it is expected to use). This can indicate memory leaks in our code that require <span class="No-Break">deeper investigation.</span></li>
				<li>When we optimize our code, we can see if the new implementation has an impact on memory consumption. For example, we could come up with an implementation that speeds up the execution time at the expense of significant <span class="No-Break">memory consumption.</span></li>
			</ul>
			<p class="callout-heading">Execution time versus memory consumption optimization</p>
			<p class="callout">You may be wondering whether we should concentrate on optimizing memory consumption or execution time. The decision about where to focus our attention and energy depends on what we value the most, memory consumption or execution time. It is interesting to note that, in some situations, we may even be able to optimize both at the same time! To do that, we have to come up with a creative implementation that addresses both concerns by leveraging advanced features of the frameworks and libraries that we use, combined with advanced and <span class="No-Break">creative algorithms.</span></p>
			<p>While <strong class="source-inline">BenchmarkDotNet</strong> helps us <a id="_idIndexMarker481"/>identify optimization opportunities during the development phase, it is important to implement monitoring so that we can continuously check the application’s performance while it is being used <span class="No-Break">in production.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor213"/>Monitoring BookmarkrSyncr with Azure Application Insights</h2>
			<p>We <a id="_idIndexMarker482"/>mentioned earlier that a CLI application runs locally on the user’s computer and that the <a id="_idIndexMarker483"/>user may refuse to allow <a id="_idIndexMarker484"/>us to collect telemetry data that is absolutely essential for monitoring. That is why we won’t implement monitoring in Bookmarkr but rather in <strong class="bold">BookmarkrSyncr</strong>, the external web service invoked by Bookmarkr. Since this is a web service hosted and managed by us, we can implement monitoring and ensure that telemetry data will be collected, therefore ensuring that monitoring can <span class="No-Break">take place.</span></p>
			<p>Since this web service is deployed <a id="_idIndexMarker485"/>to the <strong class="bold">Microsoft Azure</strong> cloud platform, we will rely on Azure Application Insights, the <strong class="bold">application performance monitoring</strong> (<strong class="bold">APM</strong>) solution <a id="_idIndexMarker486"/>provided natively by the Microsoft Azure <span class="No-Break">cloud platform.</span></p>
			<p>When we deployed BookmarkrSyncr to Microsoft Azure, we created an infrastructure for hosting it. More specifically, we created <a id="_idIndexMarker487"/>an <strong class="bold">Azure App Service</strong> instance. As part of the process of creating this service, we are offered the opportunity to create an instance of the <strong class="bold">Azure Application Insights</strong> service. This service is a monitoring solution that is provided and managed for us <span class="No-Break">by Microsoft.</span></p>
			<p>Azure Application Insights<a id="_idIndexMarker488"/> is a fantastic service that allows us to monitor performance, availability, failed requests, exceptions, page views, traces, browser timings, usage (including <strong class="bold">user flows</strong>, which allow us to identify hot paths in the application), and even access live metrics so we can monitor in real time. Another great feature of <strong class="bold">Azure Application Insights</strong> is the ability to configure alerts to be triggered if a certain metric reaches a certain threshold, for example, if the server response time (which measures the duration between receiving the HTTP request and sending the response to the client) is above the maximum allowed value as defined by our organization’s standards. When an alert is raised, we can then trigger an automated processing or a notification (such as an email to a specific group <span class="No-Break">of people).</span></p>
			<p>To see<em class="italic"> </em><a id="_idIndexMarker489"/>what monitoring with <strong class="bold">Azure Application Insights</strong> may look like, check out (this article on Microsoft Learn, which can be found <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/azure/azure-monitor/app/overview-dashboard"><span class="No-Break">https://learn.microsoft.com/en-us/azure/azure-monitor/app/overview-dashboard</span></a><span class="No-Break">.</span></p>
			<p>Okay. Now <a id="_idIndexMarker490"/>that we know how to identify the areas of our application that require performance tuning (using profiling and monitoring), let’s discuss the most common techniques that<a id="_idIndexMarker491"/> we can use to enhance the performance of <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor214"/>Common performance optimization techniques</h1>
			<p>It is <a id="_idIndexMarker492"/>worth mentioning that the techniques we will be discussing here do not only apply to CLI applications but can rather be applied to any kind of application. Let’s break these techniques down according to the categories we presented earlier. For every category, I will give you a list of techniques commonly used <span class="No-Break">for it.</span></p>
			<p><strong class="bold">Application design </strong><span class="No-Break"><strong class="bold">and architecture</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Establish the shortest path to achieve a goal, removing all unnecessary intermediaries. </li>
				<li>This can be achieved by using efficient algorithms. </li>
				<li>Find the optimal balance between decoupling and low latency. </li>
				<li>Use lazy loading for resources that aren't immediately needed. </li>
				<li>Implement efficient error handling and logging mechanisms. </li>
				<li>Design for scalability from <span class="No-Break">the start.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Infrastructure</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>When packaging and distributing your application, compile it in <strong class="source-inline">Release</strong> mode. While <strong class="source-inline">Debug </strong>mode is great during the development phase, it may add a significant performance overhead. </li>
				<li>Also, when packaging and distributing your application, compile it as platform-specific if the target platform is known ahead of time or if the packaging and distribution mechanism is not cross-platform. For example, distributing our application as a <strong class="bold">Winget</strong> package means that it will exclusively be used on the Windows platform. The same goes with an apt-get package (where the application will run exclusively on <strong class="bold">Linux</strong>) and with <strong class="bold">Homebrew</strong> (where the application will run exclusively on <strong class="bold">macOS</strong>). It is therefore easy to know what platform-specific compilation should be used and will make .NET apply all the possible optimizations, which is something it wouldn’t do if the target platform is not known ahead of time (an example of that is file handling, which is different on Windows, Linux, and macOS). This will result in a version of the application that runs in the most efficient manner on that target platform. </li>
				<li>You might also choose to use <strong class="bold">AOT</strong> (<strong class="bold">Ahead-Of-Time</strong>) compilation to precompile your code to native code (instead of relying on <strong class="bold">JIT</strong>) for faster startup times or to reduce the dependency on runtime compilation. This could be particularly useful if you're targeting environments like mobile (iOS/Android) or WebAssembly, where JIT might not be feasible. Note that platform targeting and AOT can be combined for even better <span class="No-Break">performance optimization.</span></li>
			</ul>
			<p><strong class="bold">Frameworks </strong><span class="No-Break"><strong class="bold">and libraries:</strong></span></p>
			<ul>
				<li>Avoid using libraries that rely on reflection, unless absolutely necessary. </li>
				<li>Choose lightweight frameworks and libraries that align with your specific needs. Beware of libraries that pull off tenth of other libraries when you reference them. </li>
				<li>Keep dependencies up to date to benefit from <span class="No-Break">performance improvements.</span></li>
				<li>Consider using micro-frameworks for smaller, <span class="No-Break">focused tasks.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Coding practices:</strong></span></p>
			<ul>
				<li>Rely on asynchronous operations whenever possible. This will avoid blocking the main thread and increases the feeling of responsiveness of <span class="No-Break">the application.</span></li>
				<li>Choose the most optimized data types or data structures for the pursued purpose. This will ensure we have the minimal footprint on the <span class="No-Break">computer’s resources.</span></li>
				<li>Whenever possible, try to achieve a task with as little memory allocation as possible. For example, at the time of this writing, .NET 9 was released and introduces split operations with no memory allocation by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">AsSpan().Split(…)</strong></span><span class="No-Break">.</span></li>
				<li>Implement a caching mechanism to avoid unnecessary calls to external dependencies (such as web services <span class="No-Break">or databases).</span></li>
				<li> Optimize database queries and implement proper indexing. </li>
				<li>Speaking about databases, if you are using an <strong class="bold">ORM</strong> (<strong class="bold">Object/Relational Mapper</strong>) such as <strong class="bold">Entity Framework Core</strong>, you may want to call <strong class="source-inline">AsNoTracking()</strong> to significantly improve query performance and reduce memory usage, especially when dealing with large datasets or read-only operations. This method tells the ORM not to track changes to the retrieved entities, bypassing the change tracking mechanism and resulting in faster queries with lower memory overhead. </li>
				<li>Use connection pooling, which consists in reusing established database connections instead of creating a new one for every request. This is because it can be expensive to establish a connection to a database, therefore connection pooling reduces connection latency and enables high database throughput (transactions per second) on <span class="No-Break">the server.</span></li>
				<li>Implement proper memory management and dispose of <span class="No-Break">unused resources.</span></li>
			</ul>
			<p>We have seen<a id="_idIndexMarker493"/> a bunch of techniques that are commonly used for optimizing the performance of any kind of application that is built with any technology stacks, including CLI applications built <span class="No-Break">with .NET.</span></p>
			<p>Let’s now apply some of these techniques to enhance <span class="No-Break">Bookmarkr’s performance.</span></p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor215"/>Optimizing Bookmarkr’s performance</h1>
			<p>We<a id="_idIndexMarker494"/> cannot optimize what is already perfect, <span class="No-Break">can we?</span></p>
			<p>Just kidding. Of course we can! There is always room <span class="No-Break">for improvement.</span></p>
			<p>Let’s see some of the quick wins that we can apply to enhance the performance of our beloved <span class="No-Break">CLI application.</span></p>
			<p>Looking at the handler method of the <strong class="source-inline">ExportCommand</strong> class (namely, <strong class="source-inline">OnExportCommand</strong>), we can see that it already leverages async operations. This is a great start and is actually one of the techniques we <span class="No-Break">described </span><span class="No-Break">earlier.</span></p>
			<p>However, the handler method can be optimized. To illustrate this, let’s create a copy of the <strong class="source-inline">ExportCommand</strong> class and name it <strong class="source-inline">ExportCommandOptimized</strong>. Let’s copy the code from the <strong class="source-inline">ExportCommand</strong> as is, and we will optimize it in <span class="No-Break">a moment.</span></p>
			<p>The reason we are creating a copy of the original class rather than directly optimizing it is so that we can add a benchmark method for the optimized version and compare it with the <span class="No-Break">original one.</span></p>
			<p>In the handler method of the <strong class="source-inline">ExportCommandOptimized</strong> class, let’s change these two lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
string json = JsonSerializer.Serialize(bookmarks, new JsonSerializerOptions { WriteIndented = true });
await File.WriteAllTextAsync(outputfile.FullName, json, token);</pre>			<p>Replace them with the following <span class="No-Break">two lines:</span></p>
			<pre class="source-code">
using var fileStream = new FileStream(outputfile.FullName, FileMode.Create, FileAccess.Write, FileShare.None, 4096, true);
await JsonSerializer.SerializeAsync(fileStream, bookmarks, new JsonSerializerOptions { WriteIndented = true }, token);</pre>			<p>Let’s see<a id="_idIndexMarker495"/> what we <span class="No-Break">have done:</span></p>
			<ul>
				<li>Using <strong class="source-inline">JsonSerializer.SerializeAsync</strong> is more efficient for large datasets as it streams the JSON directly to the file without keeping the entire serialized string <span class="No-Break">in memory</span></li>
				<li>Using <strong class="source-inline">FileStream</strong> with async operations allows better control over file I/O operations and can improve performance, especially for <span class="No-Break">large files</span></li>
			</ul>
			<p>Okay. Let’s compare this new implementation with the <span class="No-Break">original one.</span></p>
			<p>To do this, let’s add the following benchmark method to the <span class="No-Break"><strong class="source-inline">Benchmarks</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
[Benchmark]
public async Task ExportBookmarksOptimized()
{
    var exportCmd = new ExportCommandOptimized(_service!, "export", 
    "Exports all bookmarks to a file");
    var exportArgs = new string[] { "--file", "bookmarksbench.json" };
    await exportCmd.InvokeAsync(exportArgs);
}</pre>			<p>This <strong class="source-inline">benchmark</strong> method is identical to the previous one. Well, almost identical… The only difference is that we are instantiating (and invoking) the <strong class="source-inline">ExportCommandOptimized</strong> class rather than the <span class="No-Break"><strong class="source-inline">ExportCommand</strong></span><span class="No-Break"> class.</span></p>
			<p>Since we want to compare the new, optimized, implementation against the original one, we will modify the <strong class="source-inline">[</strong><strong class="source-inline">Benchmark]</strong> attribute of the original method to look <span class="No-Break">like this.</span></p>
			<p>This <a id="_idIndexMarker496"/>instructs <strong class="source-inline">BenchmarkDotNet</strong> to use this method as a baseline for <span class="No-Break">the comparison:</span></p>
			<pre class="source-code">
[Benchmark(Baseline = true)]</pre>			<p>Let’s rebuild the application (in <strong class="source-inline">Release</strong> mode, of course) and execute <span class="No-Break">the benchmarks.</span></p>
			<p>The results are <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B22400_12_03.jpg" alt="Figure 12.3 – Benchmarking the new implementation against the original one"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Benchmarking the new implementation against the original one</p>
			<p>Notice the appearance of two <span class="No-Break">new columns:</span></p>
			<ul>
				<li><strong class="source-inline">Ratio</strong>: This indicates the average measure of the performance relative to the baseline <span class="No-Break">benchmark method</span></li>
				<li><strong class="source-inline">RatioSD</strong>: This indicates the average standard deviation relative to the standard deviation of the baseline <span class="No-Break">benchmark method</span></li>
			</ul>
			<p>The value of <strong class="source-inline">0.91</strong> in the <strong class="source-inline">Ratio</strong> column indicates that the optimized implementation (<strong class="source-inline">ExportCommandOptimized</strong>) is on average 9% faster than the baseline implementation (<strong class="source-inline">ExportCommand</strong>). We mentioned earlier that the implementation we made in <strong class="source-inline">ExportCommandOptimized</strong> is especially more performant when dealing with large files. Therefore, we can expect it to be even faster than the baseline implementation<a id="_idIndexMarker497"/> as the output file <span class="No-Break">becomes larger.</span></p>
			<p>Awesome! We now know how to improve the performance of our beloved CLI application and we have made our <span class="No-Break">users happy.</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor216"/>Summary</h1>
			<p>In this chapter, we explored the various areas of performance optimization, we learned techniques to identify performance hot spots and hot paths, and we saw how to improve their performance, with the ultimate goal of offering our users a great and efficient application that they will love <span class="No-Break">to use.</span></p>
			<p>Hopefully, you have understood that there is not one single area or action that leads to better performance, but rather a series of fine-tuning here and there that do <span class="No-Break">the trick.</span></p>
			<p>Awesome! So, we have an application that efficiently provides <span class="No-Break">great functionality.</span></p>
			<p>There is, however, one key area that we have not yet covered when it comes to building CLI applications (and, for that matter, any kind of application). That key area is <strong class="bold">security</strong>, and this is the topic of the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor217"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the Bookmarkr application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor218"/>Task #1 – Write more benchmarks</h2>
			<p>In this chapter, we have illustrated writing benchmark methods by only writing a benchmark for the <strong class="source-inline">export</strong> command. However, as we mentioned earlier, benchmarks do not only apply to commands, but they can also apply <span class="No-Break">to services.</span></p>
			<p>That’s why you are tasked with writing additional benchmark methods for each command and for the services used by the <span class="No-Break">Bookmarkr application.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor219"/>Task #2 – Fine-tune Bookmarkr for optimal performance</h2>
			<p>Throughout this chapter, we haven’t implemented every performance optimization opportunity, and we have probably missed some (was that intentional? *wink wink*). Therefore, you are tasked with identifying other potential performance optimizations in Bookmarkr and <span class="No-Break">implementing them.</span></p>
		</div>
	</body></html>