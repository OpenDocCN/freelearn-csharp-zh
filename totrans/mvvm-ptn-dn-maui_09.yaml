- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling User Input and Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User input forms the core of any interactive application. The way we manage
    this input, validate it, and respond to it directly influences the user experience
    of our application. While backend validation of user input is indispensable to
    maintaining data integrity, providing immediate and useful feedback on the frontend
    is equally important for a good user experience. In this chapter, we’re going
    to dig into the crucial topic of managing user input and validation within a .NET
    MAUI application utilizing the MVVM design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is organized into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing input validation on ViewModels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing validation errors with triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompts and alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirming or canceling navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the aim of making our application more dynamic and interactive, this chapter
    will focus on handling user input effectively – ensuring a smooth and seamless
    user experience. Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll further enrich the *Recipes!* app with more features.
    To stay in sync, all the resources and code snippets are available on GitHub:
    [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09).
    If you’re looking to actively code alongside the chapter, it’s best to kick off
    from the `Start` folder. The finalized version can be found in the `Finish` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing input validation on ViewModels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input validation can be implemented in various ways and at different points
    within the life cycle of user interaction. It could happen as soon as a user changes
    a property, providing immediate feedback on the validity of the data entered.
    On the other hand, it might be performed only when the user initiates a certain
    action, such as clicking a button, thereby offering a more cumulative validation
    experience. Deciding on when and how to implement validation often depends on
    the specific requirements of your project. It’s a balance between the need for
    immediate feedback and maintaining a smooth, uninterrupted user flow. There’s
    no one-size-fits-all solution, and the strategy can vary based on the complexity
    of the data, the form of user interaction, and the overall design of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing validation on the frontend offers several advantages: it provides
    users with immediate feedback, ensuring a more responsive and intuitive experience.
    Moreover, by catching and rectifying issues right at the source, we can reduce
    the risk of sending incorrect data to the backend. However, it''s essential to
    note that frontend validation should complement, not replace, backend validation.
    The ViewModel is the ideal location for frontend validation as it serves as our
    first line of defense against potential data inconsistencies or errors before
    they reach backend systems.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll be focusing on the implementation of input validation
    in ViewModels. We’ll specifically delve into the use of the `ObservableValidator`,
    a powerful tool that’s part of the MVVM Community Toolkit. This feature makes
    handling validation responses and displaying meaningful feedback to the user a
    breeze. Let’s move on to explore the `ObservableValidator` in detail, and how
    it can enhance our approach to input validation.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ObservableValidator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validating user input is a cornerstone of robust applications. While it’s entirely
    possible to write our own validation logic – checking properties as they update
    or when commands are invoked and then populating validation properties that can
    be bound to the UI – it often involves reinventing common patterns. Instead of
    starting from scratch, why not leverage existing tools designed for this exact
    purpose? One of the best practices for user input validation in the MVVM pattern
    is the use of the `ObservableValidator`. This class, a part of the MVVM Community
    Toolkit, inherits from the `ObservableObject` class and implements the `System.ComponentModel.INotifyDataErrorInfo`
    interface. This interface, which isn’t specific to .NET MAUI, provides a robust
    system for reporting and managing errors in objects. It includes an `ErrorsChanged`
    event that you can subscribe to in order to be notified of changes in validation
    status and a `GetErrors` method that retrieves validation errors for a specified
    property or the entire object.
  prefs: []
  type: TYPE_NORMAL
- en: When a property value is updated, the `ObservableValidator` has the ability
    to automatically validate it using its `SetProperty` method overloads. It also
    offers `TrySetProperty` overloads that update a property value only when validation
    is successful and can return any generated errors. For scenarios that require
    manual control over validation, the `ObservableValidator` provides `ValidateProperty`
    and `ValidateAllProperties` methods, which can be used to manually trigger validation
    for specific properties or all properties, respectively. Additionally, it offers
    a `ClearAllErrors` method, ideal for resetting a form for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility of `ObservableValidator` extends to compatibility with the wide
    range of validation attributes provided by the `System.ComponentModel.DataAnnotations`
    namespace. This means you can leverage a set of common validation rules that are
    essential in many scenarios, such as `[Required]`, `[StringLength]`, `[Range]`,
    `[Compare]`, `[RegularExpression]`, and many more. These attributes allow for
    an expressive way to define validation rules directly on your ViewModel’s properties,
    leading to a highly readable and maintainable code base. The `ObservableValidator`
    will pick up these attributes when validating a property, making the validation
    process seamless and straightforward. You can also define your own specific validation
    rules by encapsulating complex validation logic into dedicated validation methods
    or even in custom `ValidationAttribute` classes, which can be reused across your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and see how we can add validation to `AddRatingViewModel` using
    the `ObservableValidator`.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-configured validation rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As previously mentioned, the `ObservableValidator` class leverages the power
    of the validation attributes found within the `System.ComponentModel.DataAnnotations`
    namespace. These attributes can be easily applied to your properties and the `ObservableValidator`
    class will use them for validating the corresponding property values. This relationship
    between the `ObservableValidator` and the `DataAnnotations` namespace offers an
    array of pre-configured validation rules, simplifying the process of implementing
    input validation in your ViewModel. Let’s start by marking some properties as
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to `AddRatingViewModel` and instead of inheriting the `ObservableObject`
    class, make it inherit the `ObservableValidator` class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Required]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public string EmailAddress { … }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Required]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public string DisplayName { ... }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Required]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public string RatingInput { ... }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AddRatingViewModel` class contains a `SubmitCommand`, which calls the
    `OnSubmit` method. Let’s update this method so it validates all the properties
    and writes the validation messages to the debug window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `ValidateAllProperties` method, all properties of the current class
    are validated. After calling this method, we can check the `HasErrors` property
    to see if there are any violations. If so, the `GetErrors` method allows us to
    retrieve a list of `ValidationResult` objects. A `ValidationResult` object contains
    a list of member names affected by this result and an `ErrorMessage`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go ahead and debug the app! If you go to the `AddRatingPage`, leave everything
    empty and click the **Submit** button. You’ll see the error messages printed in
    the **Output** window in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and errors
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ValidateAllProperties` method validates all properties in the ViewModel.
    The `ValidateProperty` method, which accepts a value and property name will check
    whether the given value is valid for the given property. This is an easy way to
    validate a single property. The `HasErrors` property will be set according to
    the properties that have been validated. The same thing goes for the `GetErrors`
    method: it returns `ValidationResult` objects for the properties that have been
    validated. This method also has an overload where you can pass in a property name
    to get back the errors for that specific property. The `GetErrors` method won’t
    do any validation by itself, trying to get the errors of a property that hasn’t
    been validated will yield no results. The `ClearErrors` method allows for removing
    all errors or only those of a particular property when a property name is provided.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enhance our validation by adding more validation rules and disabling the
    **Submit** button until all input is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `EmailAddress` property, we should add an additional validation attribute.
    We can use the `RegularExpressionAttribute` to check whether a value matches a
    given regex expression:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows how we can add an extra validation attribute to
    the `EmailAddress` property using the `RegularExpressionAttribute` to ensure the
    value matches a specified regex pattern. This pattern will be used to validate
    whether the given value is an email address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure the `DisplayName` property has a minimum and maximum length, we can
    use the `MinLength` and `MaxLength` attributes. Let’s add them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To constrain the `RatingInput` property to a value between 0 and 4 with zero
    or one decimal point, we can use the `RangeAttribute` for the range constraint
    and `RegularExpressionAttribute` for the decimal limit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we want to validate each property when its value gets updated.
    The `ObservableValidator` class has an overloaded `SetProperty` method, which
    accepts a `bool` value indicating whether the provided value needs to be validated.
    This is how it looks for the `EmailAddress` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: SetProperty and TrySetProperty
  prefs: []
  type: TYPE_NORMAL
- en: Note that this overloaded `SetProperty` will set the value of the backing field
    and trigger the `PropertyChanged` event, no matter whether the provided value
    is valid or not. There is also a `TrySetProperty` on the `ObservableValidator`
    class, which will not set the value on the property when it is invalid. It returns
    a `bool` value indicating whether the value was set or not and has an `out` parameter,
    which returns a collection of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddRatingViewModel` class contains a command `SubmitCommand`. This command
    should only be executable when the provided values of the properties are considered
    valid. For that, we can point the `canExecute` function of the `SubmitCommand`
    to the `HasErrors` property, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public AddRatingViewModel(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: INavigationService navigationService)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ErrorsChanged += AddRatingViewModel_ErrorsChanged;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private void AddRatingViewModel_ErrorsChanged(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: object? sender, DataErrorsChangedEventArgs e)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SubmitCommand.NotifyCanExecuteChanged();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you run the app and navigate to `AddRatingPage`, you’ll find the `CanExecute`
    method of `SubmitCommand` being based on the absence of validation errors. *Figure
    9**.1* shows what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Enabled Submit button when there are no errors (right)](img/B20941_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Enabled Submit button when there are no errors (right)'
  prefs: []
  type: TYPE_NORMAL
- en: The pre-configured validation attributes we’ve discussed so far can simplify
    the process of adding validation to your ViewModels. However, there will be scenarios
    where these built-in rules don’t meet your specific requirements, and you’ll need
    to create your own custom validation logic. Let’s explore how to implement that
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom validation rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, the pre-configured validation rules just won’t cut it and you’ll need
    to add your own custom validation logic. When working with the `ObservableValidator`
    class, there are two options for implementing custom validation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The first approach involves creating a completely new validation attribute by
    extending the base `ValidationAttribute` class. This allows you to encapsulate
    your own validation logic in a reusable component, keeping your ViewModel cleaner
    and more focused on its primary responsibility. You can then apply this custom
    attribute to any property in the same way you’d apply the built-in attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option involves using the `CustomValidation` attribute, which enables
    you to specify a static method to handle the validation right at the point of
    declaration. This method allows for more localized, context-specific validation
    scenarios where creating a separate attribute class might be overkill.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s examine both methods in more detail to see how they can be used to address
    custom validation requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s add a validation rule that we want to use on the `Review` property. Although
    a review is optional, if provided, it must fall within a certain length range.
    Since such a rule could potentially be reused across different scenarios, it makes
    sense to put this validation logic in a custom attribute. Here’s how we can go
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Recipes.Client.Core` project in the `Validation` as the name
    of the new folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Validation` folder, select `EmptyOrWithinRangeAttribute` as
    the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make this class inherit the `ValidationAttribute` class like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add two properties, `MinLength` and `MaxLength`, of type `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These properties allow an even wider usage of this attribute. They allow developers
    to customize the length constraints each time they apply this attribute to a property.
    This way, the exact minimum and maximum lengths required for validation can be
    tailored to fit each individual property’s needs as the developer can declare
    the desired minimum and maximum length.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to override the `IsValid` method. This method gets invoked
    when the validation process begins for the property where the attribute is applied.
    Let’s see how we can implement it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value parameter, of type `object`, represents the property value that needs
    to be validated. The second parameter, of type `ValidationContext`, provides further
    context, including the instance of the object being validated and the property.
    Returning `ValidationResult.Success` indicates that the given value is valid,
    else we return a descriptive error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can use this attribute on the `Review` property of the `AddRatingViewModel`
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With our custom validation attribute in place, the `Review` property can be
    validated so that it is empty or falls within the given length range. This attribute
    can easily be reused across the entire app.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CustomValidation attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ValidationResult` object and take a parameter matching the type of the
    property being validated, along with a `ValidationContext` object. This is similar
    to the `IsValid` method we override when implementing our own `ValidationAttribute`.
    Let’s add an additional validation to the `Review` property so that it is required
    when the given rating is less than or equal to 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AddRatingViewModel`, add a new static method called `ValidateReview`
    with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method accepts a parameter of type `string`, matching the type of the property
    we want to validate. The second parameter is of type `ValidationContext`, which
    we can use to access the instance of the object the property is defined on. This
    allows us to access other properties on the object that is being validated, such
    as the `RatingInput` property in our case. When we can parse the `RatingInput`
    value to `double`, we can check whether it is less than or equal to 2\. If that
    is the case and the given review value is empty, we return a validation error.
    Otherwise, `Success` is returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to add a `CustomValidation` attribute to the `Review` property
    and point this to the static `ValidateReview` method that we just created. Let’s
    see how that’s done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first parameter the `CustomValidation` attribute requires is the type the
    static validation method is defined on. In our case, we defined it on `AddRatingViewModel`
    itself, so we pass that in as the type. This means it is possible to define your
    validation methods elsewhere, bundling them in separate classes, for example.
    The second parameter is the name of the validation method. We use the `nameof`
    keyword to avoid magic strings and add compile-time error checking.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As the validation of the `Review` property is also dependent on the entered
    `RatingInput` property, we must make sure the `Review` property is also validated
    when the `RatingInput` property changes. As the following snippet shows, we can
    easily do this by calling the `ValidateProperty` method for the `Review` property
    when the value on the `RatingInput` property is updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it! That is all that’s needed to add custom validation, leveraging the
    `CustomValidation` attribute. This approach typically is for validation checking
    that is to be reused on different objects less. In this particular case, we access
    the `ValidationContext` `ObjectInstance` and cast it to a certain type, which
    naturally makes it unusable on different types.
  prefs: []
  type: TYPE_NORMAL
- en: Run your application and notice how the **Submit** button gets disabled when
    a rating of less than 3 is given and the review is left empty. Our validation
    logic is operating as expected! However, the current implementation lacks user-friendliness
    because it does not provide any feedback regarding invalid entries. Let’s see
    how to display these validation errors to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Showing errors onscreen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are basically two approaches to show validation errors to the user. The
    first method usually provides an overview of all issues at once, typically at
    the top or bottom of a form. The second approach gives feedback right on the input
    field where the error occurred. This can often help users to correct the error
    more directly and quickly. Both methods have their uses and are often combined
    in applications for the best user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Showing all errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While `ObservableValidator` doesn’t provide a property that lists all validation
    errors directly, it does offer a `GetErrors` method to fetch them. Sadly, data
    binding to methods isn’t possible. To align better with MVVM practices and facilitate
    data binding, it would be beneficial to introduce an `Errors` property of type
    `ObservableCollection<ValidationResult>`. This way, we can bind to our validation
    errors in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a property called `Errors` of type `ObservableCollection<ValidationResult>`
    to `AddRatingViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AddRatingViewModel_ErrorsChanged` method on `AddRatingViewModel` is invoked
    when the `ErrorsChanged` event of `ObservableValidator` is triggered. Currently,
    this calls the `NotifyCanExecuteChanged` method on the `SubmitCommand`, but let’s
    update it so that it also (re-)populates the `Errors` collection that we just
    defined. The following code block shows how we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code first clears the `Errors` collection. Next, it calls the
    `GetErrors` method of `ObservableValidator` to get all the errors. With the `ForEach`
    method, we can loop over all the items and call the `Errors.Add` method to add
    the current item to the `Errors` collection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding code should add all the current validation errors to the `Errors`
    property. The only thing that is left to do is to bind this collection to our
    view, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, you should find the XAML code familiar and straightforward:
    the `Errors` collection is bound to the `BindableLayout` `ItemsSource` property
    on a `VerticalStackLayout`. The `ItemTemplate` stipulates that for each item we
    want to render a `Label` that shows its `ErrorMessage` property. The `DataType`
    of the `DataTemplate` is a `ValidationResult`. The `annotations` XML namespace
    is defined at the top of the page: **.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The preceding code will result in showing a list of all the validation errors
    onscreen. Run the application and you should see the validation errors appearing
    and disappearing as you enter values, as *Figure* *9**.2* demonstrates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Showing up-to-date validation errors](img/B20941_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Showing up-to-date validation errors'
  prefs: []
  type: TYPE_NORMAL
- en: Although this already should improve the user experience a lot, we can take
    this a step further. Let’s enhance the UX by showing error messages inline, directly
    adjacent to the relevant input fields.
  prefs: []
  type: TYPE_NORMAL
- en: Showing inline errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The main challenge when it comes to displaying individual errors is developing
    a mechanism that enables us to retrieve and display validation errors related
    to a single property, rather than all validation errors at once. There is a very
    simple approach to this: for each property, expose an additional property containing
    a collection of errors for that property. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This `EmailValidationErrors` property gives a list of only the validation errors
    related to the `EmailAddress` property. This `EmailValidationErrors` property
    can be bound to the UI so that we can display the errors only relevant to the
    `EmailAddress` property on the screen. In order to keep this bound list up-to-date,
    we need to make sure we trigger the `PropertyChanged` event of the `EmailValidationErrors`
    property each time the `EmailAddress` property is updated, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating a dedicated property for each input’s validation errors and ensuring
    it’s updated whenever the input value changes, we can effectively isolate and
    display validation errors for individual fields. However, it does come with a
    caveat: for forms with numerous input fields, this method can be somewhat labor-intensive
    and repetitive. Let me show you an alternative that automates this process and
    saves us some manual work. The end result will be that we are going to bind to
    a particular property called `ErrorExposer`. Then, using its **indexer**, we will
    specify which property’s validation errors we want to retrieve and display, something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see how we can implement this mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Validation` folder that we created earlier, select `ValidationErrorExposer`
    as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ValidationErrorExposer` class should implement two interfaces: `INotifyPropertyChanged`
    and `IDisposable`, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s introduce a `readonly` field `validator` of type `ObservableValidator`.
    The value for this field should be passed in through the class constructor, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The passed-in `observableValidator` is the instance that we want to automatically
    expose per-property validation errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It’s time to add the `ValidationErrorExposer` indexer. An indexer in .NET allows
    an instance of a class to be accessed using an index, similar to an array or dictionary.
    This index can be of any type, such as a string or an int, and it lets you retrieve
    or set values without explicitly calling a method or property. In this case, we
    set the index to be a string as it represents the name of the property we want
    to get the validation errors of. This is how we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor of the `ValidationErrorExposer` class, we should also subscribe
    to the `ErrorsChanged` event of the `ObservableValidator` that is being passed
    in, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While it might seem like there’s some magic happening, the concept is fairly
    straightforward. In .NET MAUI, if an object has an indexer, you can bind to that
    indexer property as demonstrated by `{Binding ErrorExposer[EmailAddress]}`, where
    `ErrorExposer` is an instance of a type that contains an indexer. To notify the
    UI of an updated value, we can invoke the `PropertyChanged` event from the `ErrorExposer`
    and pass `Item[EmailAddress]` as the property name. Doing so will prompt all bindings
    tied to `ErrorExposer[EmailAddress]` to re-evaluate. Alternatively, invoking the
    `PropertyChanged` event with `PropertyChangedEventArgs` having `Item` as the property
    name will trigger a re-evaluation of all bindings associated with the indexer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in `ValidationErrorExposer`, we should update the `Dispose` method
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we have subscribed to the `ObservableValidator` `ErrorsChanged` method,
    we need to provide a mechanism to unhook from this event, preventing any memory
    leaks. For that, we can use the `Dispose` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s head back to `AddRatingViewModel` and add a property of type `ValidationErrorExposer`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor of `AddRatingViewModel`, assign a new instance to this property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We pass in `this` to the constructor of the `ValidationErrorExposer` class because
    it is the instance of the `AddRatingViewModel` itself that inherits from `ObservableValidator`
    and thus holds all validation errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In XAML, we can now bind to a list of validation errors, specific to a particular
    property using the indexer on the `ValidationErrorExposer` class. This allows
    us to show these errors close to the relevant input fields themselves, as shown
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ValidationErrorExposer` allows us to easily get validation errors from a specific
    property, without needing to do any manual work: once this is in place, we can
    bind to the errors of any specific property using its indexer property.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying validation errors near user input further improves the user experience.
    Let’s explore how to visually indicate the validity of entered values, improving
    the experience even more.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing validation errors with triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Triggers** help us customize how UI elements work and look without building
    new controls from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: While there are different types of triggers, we’ll focus on **data triggers**.
    These kick in when a property (on the ViewModel) changes, allowing us to adjust
    elements of a UI control dynamically, based on what the user does.
  prefs: []
  type: TYPE_NORMAL
- en: Types of triggers
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of triggers in .NET MAUI: PropertyTrigger, DataTrigger,
    EventTrigger, and so on… They all allow you to change the appearance of a UI control
    declaratively in XAML based upon a trigger. They only differ in what triggers
    the change: a property value, a bound value, an event. You can learn more about
    them at [https://learn.microsoft.com/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/dotnet/maui/fundamentals/triggers).'
  prefs: []
  type: TYPE_NORMAL
- en: In essence, a DataTrigger provides a way to declaratively set up UI changes
    in response to data changes, directly within your XAML, without having to write
    procedural code in your code-behind, a custom ValueConverter, or ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'DataTriggers are a fairly easy-to-understand concept. So, let’s just dive in
    and add a visual indicator right next to the different `Entry` controls, indicating
    with a symbol and a particular color whether the entered value is valid or not,
    as *Figure* *9**.3* shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Indicating input is valid (right) or not (left)](img/B20941_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Indicating input is valid (right) or not (left)'
  prefs: []
  type: TYPE_NORMAL
- en: What about ValueConverters?
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Databinding in .NET MAUI*,
    we discussed the usage of value converters. The things that you can do with DataTriggers
    are also achievable with value converters and vice versa. But, with a DataTrigger,
    it is very easy to implement these visual effects declaratively, without a single
    line of C# code, also making the XAML more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at how we can implement these visual cues using DataTriggers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a `Grid` around the `Entry` for the `EmailAddress` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `Grid` has two columns, with the `Entry` in the first one, and we will
    be adding the validity indicator in the second one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside this `Grid`, below the `Entry`, add the following `Label`, which will
    serve as the validity indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, this `Label` shows the invalid state: red text and an exclamation
    mark icon.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can add the `DataTrigger` and define that the `Label` needs to show
    a blue checkmark when the provided email address is valid. The following snippet
    shows how we can do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `DataTrigger` has a `Binding` property that allows us to bind to a certain
    value. In this case, we bind to the `Count` property of the list of validation
    errors related to the `EmailAddress` property. With the `Value` property, we can
    set a condition for this bound property. We set the value to `"0"`, meaning that
    there are no validation errors associated with the `EmailAddress` property. When
    the value of the property meets this condition, the trigger activates. Once activated,
    the trigger can change one or more properties of the UI control. In this particular
    case, we’re updating the `Text` and `TextColor` properties by specifying a `Setter`
    for these properties and providing a certain `Value`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As said, this can also be achieved with custom `ValueConverter`s, but this declarative
    way of defining it in XAML is very readable, maintainable, and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors
  prefs: []
  type: TYPE_NORMAL
- en: Another way to give the user visual cues about the validity of entered values
    is by using **Behaviors**. Behaviors are like little plugins you can add to your
    UI elements, enhancing their default behavior without having to subclass them.
    They’re particularly useful because they encapsulate logic in reusable pieces,
    allowing developers to apply the same functionality across different controls.
    For example, a Behavior might allow a text input field to only accept numerical
    input or change its color when certain conditions are met. The .NET MAUI Community
    Toolkit comes with a set of ready-to-use Behaviors! You can learn more about them
    at [https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors](https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll have a look at how to display prompts and alerts,
    essential parts for providing user feedback and gathering input.
  prefs: []
  type: TYPE_NORMAL
- en: Prompts and alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Direct feedback and clear communication are paramount when it comes to a solid
    user experience. As users navigate your application and interact with various
    inputs, there are moments where a subtle notification or a direct prompt can make
    all the difference. Prompts and alerts serve as these essential tools, guiding
    users through their journey, ensuring they’re informed and make intentional decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Showing prompts and alerts is something that is platform-specific. Luckily .NET
    MAUI has got us covered as they provide simple and intuitive APIs for this. On
    the other hand, in an MVVM scenario, displaying a prompt or alert is mostly triggered
    from a ViewModel, which should be framework-independent. The solution, of course,
    is creating an interface for this functionality that a ViewModel can talk to.
    On the MAUI side of things, we can easily implement this interface and register
    it in our DI container so the implementation gets injected into the ViewModels.
    Let’s go ahead and set this up!
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, let’s add an interface that defines some methods for displaying
    prompts and alerts. Right-click the `Recipes.Client.Core` project in the `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new interface to this folder and call it `IDialogService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The methods defined in an `IDialogService` can defer from project to project.
    The following code block shows some method declarations that are often present
    in an `IDialogService` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As said, depending on your specific use case, this interface might be extended
    with some other concrete method definitions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we need to add an implementation for this interface. Add a new folder
    called `Services` to the `Recipes.Mobile` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click the new `Services` folder and select `DialogService` as the name
    of the new class and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In .NET MAUI, the `Page` class provides various methods for displaying alerts,
    prompts, and action sheets. Within the `DialogService` class, we can access these
    methods by referencing `MainPage` through the static `Current` property of the
    `Application` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next thing we need to do is register `DialogService` in our DI container.
    Move over to `MauiProgram.cs` and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can add the `IDialogService` as a dependency to our ViewModels.
    Let’s add it to `AddRatingViewModel` as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move over to the `OnSubmit` method and update it as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the updated `OnSubmit` method, we first ask for confirmation. If the user
    confirms, an alert will be shown saying the rating was sent (*Figure 9**.3*).
    After the user closes the alert, `GoBackCommand` is invoked, closing the `AddRatingPage`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.3: Showing alerts and prompts](img/B20941_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Showing alerts and prompts'
  prefs: []
  type: TYPE_NORMAL
- en: With the `IDialogService` and its `DialogService` implementation in place, we
    have laid the foundation for basic popup interactions in our application. Next,
    we’ll explore how to leverage this to prompt users for confirmation when they
    attempt to leave a specific page.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming or canceling navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As users interact with our application, there may be moments when they’re about
    to navigate away from a page containing unsaved changes or important input. To
    prevent potential data loss, it’s essential to prompt for confirmation before
    allowing such navigation. Let’s see how we could build this by leveraging the
    `NavigationService` that we built in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the following interface called `INavigatable` to the
    `Navigation` folder of the `Recipes.Client.Core` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ViewModels that want to control whether the user is able to navigate can implement
    this interface. This is analogous to the other interfaces we introduced in the
    context of navigation, such as the `INavigatedFrom`, `INavigatedTo`, and `INavigationParameterReceiver`
    interfaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extend the `INavigationInterceptor` interface with the following method definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `NavigationService` class, which implements the `INavigationInterceptor`
    interface, now needs to implement this method. Here’s what it looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method checks whether the given `bindingContext` parameter implements the
    `INavigatable` interface. If that’s the case, it returns the result from its `CanNavigateFrom`
    method, passing in the `NavigationType`. If the `bindingContext` doesn’t implement
    the `INavigatable` interface, `true` is returned, indicating the navigation can
    be executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `AppShell` class, we must now override the `OnNavigating` method. In
    this method, we can retrieve a `ShellNavigatingDeferral` from the passed-in `ShellNavigatingEventArgs`.
    This deferral token can be used to complete the navigation. Or, if the navigation
    should be canceled, the `Cancel` method on the `ShellNavigatingEventArgs` can
    be called. The next code block shows the overridden method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By calling the interceptor’s `CanNavigate` method, we can determine whether
    we must complete the navigation or not. Depending on the outcome, we can call
    the `Complete` method on the deferral token and complete the navigation or call
    the `Cancel` method on the passed-in `args` to cancel it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can go to `AddRatingViewModel`, make it implement the `INavigatable`
    interface, and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As a result, when navigating from the `AddRatingView`, the `OnNavigating` method
    on the `Shell` class will get called, which – via the `NavigationService` – will
    call the `CanNavigateFrom` method on the `AddRatingViewModel`. The ViewModel will
    present a dialog to the user and return the response. Depending on the response
    given by the user, the navigation will be completed or canceled. The `INavigatable`
    interface can be implemented by any ViewModel and can contain any business logic
    to determine whether navigation is allowed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we delved deep into enhancing user experience through effective
    validation, prompts, and alerts. We explored the power of `ObservableValidator`
    for validation logic and learned the nuances of showing errors both as a collective
    list and inline, right next to input fields. With triggers, we learned how to
    customize UI elements without reinventing the wheel. We also explored using an
    `IDialogService` leveraging alerts and prompts, which is essential in contexts
    where user feedback or confirmations, such as during critical actions or navigations,
    are required. As we move forward, we’ll pivot to a vital aspect of many modern
    apps: making remote API calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ObservableValidator`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Triggers: [https://learn.microsoft.com/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/dotnet/maui/fundamentals/triggers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Behaviors: [https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors](https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI Community Toolkit Behaviors: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI popups: [https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups](https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
