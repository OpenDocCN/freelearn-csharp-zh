<html><head></head><body>
        

                            
                    <h1 class="header-title">The Anti-Patterns</h1>
                
            
            
                
<p class="mce-root">Throughout this book, we have reviewed best practices in software architecture by implementing various types of patterns. But what you might be asking yourself is if those patterns are so beneficial, why doesn't everyone use them? Or why do we still regularly see bug-ridden games coming out?</p>
<p>If current-day programmers have easy access to a wealth of information about software development best practices, it's reasonable to assume that there should be no reasons why we still have issues delivering stable video games and applications within reasonable deadlines. But in this chapter, we are going to explore why, in the software development industry, even extraordinarily competent and talented teams end up producing messy code and are unable to deliver a stable product.</p>
<p>In the previous chapters, we explored patterns that are designed to be beneficial and bring about positive results. But now, we are going to study their evil twins, in the form of Anti-Patterns. These destructive patterns are subtle; they don't always lurk in your code, but instead hurt you by causing fear, uncertainty, and doubt at every level of your organization. And that's why they are so difficult to recognize, as we are going to see in the following section.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will be reviewing a list of common anti-patterns</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The anti-patterns</h1>
                
            
            
                
<p>There are probably over one hundred anti-patterns currently documented by experts in every field of software development. We won't be able to review them all in this chapter, but I have made a short list of those I found that are related to the misapplication of design patterns, either directly or indirectly. But I have also listed those that I've personally experienced in my career.</p>
<p class="mce-root"/>
<p>The academic research on the subject of anti-patterns is not thoroughly documented compared to established design patterns, so there are a lot of discrepancies in the naming of specific anti-patterns. As a result, a lot of the following material is my interpretation of prevalent anti-patterns and not official definitions. So, let's now dive into the subject matter and review some of the most relevant anti-patterns that I have experienced, and that I recommend to avoid.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">False mastery</h1>
                
            
            
                
<p>"If people knew how hard I worked to get my mastery, it wouldn't seem so wonderful at all."<br/>
<br/>
- Michelangelo</p>
<p><strong>What is it?<br/></strong>Programmers have access to a wealth of information, tools, and libraries that allow them to develop anything they want with ease. As a consequence, these advantages are making a lot of junior developers believe that they are masters of their craft when they are merely copying and pasting the work of others.</p>
<p><strong>Why is it wrong?<br/></strong>Nothing obstructs your ability to learn more than believing that you already know everything. This dangerous mindset blinds you to your deficiencies and makes you unable to process feedback. As a result, you will never progress, and you will end up being a mediocre programmer for the rest of your career, even if you hold titles such as senior or technical director.</p>
<p><strong>What is the root cause?<br/></strong>The leading cause of this premature disillusionment of mastery over your craft is that tools such as the Unity engine simplify the process of making games to the point that almost anyone can do it. But this means few understand what is happening under the hood of the engine in terms of the tools or programming language they are using.</p>
<p>So, by example, just because you can write a program in C# doesn't make you a C# expert, but knowing the intricacies of the language's libraries will make you into one.</p>
<p class="mce-root"/>
<p><strong>How to avoid this?<br/></strong></p>
<p>The following is a list of professional habits that will help you avoid falling into the trap of this Anti-Pattern:</p>
<ul>
<li>Learn, learn, and never stop learning.</li>
<li>Avoid hunting for titles such as senior, tech lead or CTO, and instead focus on gaining true mastery over your craft.</li>
<li>Every time you use a new tool, library, and language, research as much as possible about its origins, as well as its intricacies.</li>
<li>Humble yourself every day. Accept that you don't know everything and that it will take you several decades to become a true senior programmer.</li>
<li>Teach, write a blog, and answer technical questions on forums. In other words, transfer the knowledge you know as well as absorbing new information. This approach will help you validate and structure your learning. <strong><br/></strong></li>
</ul>
<p>Job titles given out in a start-up are not equivalent to those given in a large corporation. So don't be surprised when transitioning out from a small indie to a AAA studio that you end up back in a more junior role. The reason is simple: it's harder to gain seniority in a bigger team because you are competing with more programmers for better positions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fear of complexity</h1>
                
            
            
                
<p>"Have no fear of perfection – you'll never reach it."<br/>
<br/>
- Salvador Dali</p>
<p class="mce-root"><strong>What is it?</strong><br/>
I personally have been the victim of this anti-pattern for years. It's the result of an overzealous belief that simplicity is always the best approach to code and, hence, you should avoid any solution that might look slightly more complex as the path of least resistance.</p>
<p class="mce-root"><strong>Why is it bad?</strong><br/>
An irrational fear of complexity can prevent you from using sophisticated and advanced design patterns or algorithms to resolve issues. Thus, you reduce the potential for growth and limit your learning opportunities. Ultimately, it can prevent you from reaching maturity and seniority.</p>
<p class="mce-root"><strong>What is the root cause?</strong><br/>
An earnest belief that the simplest solution is the best path to resolve any technical problem. But usually, it is an excuse to avoid doing research and leaving your comfort zone.</p>
<p class="mce-root"><strong>How to avoid?<br/></strong></p>
<p class="mce-root">Here are some questions that you should ask yourself every time you have to decide between an easy or complex solution to a problem:</p>
<ul>
<li class="mce-root">Am I currently feeling engaged in resolving a technical challenge or am I just trying to get things done?</li>
<li>Am I afraid of looking stupid by suggesting a more advanced solution to a problem because I don't understand it?</li>
<li>Does the simple solution I'm implementing scale with the overall architecture of the current code base overtime or does it just patch the problem?</li>
</ul>
<p>So, in summary, always ask yourself this simple question when deciding between an easy or a complex solution to a problem: Are you choosing the most accessible approach because it's the right thing to do, or because you're just lazy and can't be bothered to adopt an advanced method that would require greater effort.</p>
<p>You often hear programmers say that complexity causes more bugs. This is true but, to be more precise, it is unmanaged and misunderstood complexity that results in more bugs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Too many managers</h1>
                
            
            
                
<p>"We don't have as many managers as we should, but we would rather have too few than too many."<br/>
<br/>
- Larry Page</p>
<p><strong>What is it?</strong><br/>
Managers are great; they offer a unique interface to a pool of complex sub-systems. Because video games are an extensive collection of systems that are constantly interacting with one another, having managers as interfaces can be very helpful in reducing dependencies.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><strong>Why is it wrong?</strong><br/>
If every class is a manager, you end up with managers being dependent on other managers. In other words, managers become sub-systems of other managers until you find yourself in the same situation that you were trying to avoid, a spaghetti of dependencies. Another negative point is that managers are often implemented as singletons, which means that you have global dependencies spread throughout your code base.</p>
<p>The following is a code example that showcases a possible software architecture that's too dependent on Manager classes. If you see something similar in your source code, you might need to refactor your architecture:</p>
<pre>using UnityEngine;<br/><br/>public class GameManager : MonoBehaviour<br/>{<br/>    private Player m_Player;<br/><br/>    void Start()<br/>    {<br/>        // Get the player ID<br/>        m_Player = PlayerManager.Instance.GetPlayer();<br/>        <br/>        // Sign-in to online services<br/>        OnlineManager.Instance.LoginPlayer(m_Player);<br/><br/>        // Load save game data of the player<br/>        SaveManager.Instance.LoadSaveGame(m_Player);<br/><br/>        // Load player preferred controller configuration<br/>        IInputConfiguration inputConfig = SaveManager.Instance.GetInputConfig(m_Player);<br/>        InputManager.Instance.LoadControllerConfig(inputConfig);<br/>    }<br/>}</pre>
<p><strong>What is the root cause?</strong><br/>
The root cause is usually inexperienced or lazy programmers who don't consider the overall architecture of their code base but instead focus on instant results.<br/>
<br/>
<strong>How to avoid this?</strong><br/>
Here's a list of good habits that might help you avoid this anti-pattern:</p>
<ul>
<li>Every time you are about to use a specific pattern, always consider using an alternative that might be more suitable. In other words, avoid defaulting to the easiest solution.</li>
<li>Keep track of your architecture and the patterns that you are using. Raise a flag if you see too many classes with Manager in their title.</li>
<li>If you are having issues implementing unit tests for your core systems, it's a good indication that there's something wrong in your architecture and it might be related to having too many singletons or classes that act like global Managers.</li>
</ul>
<p>New patterns, or permutations of established ones, are appearing regularly. It's good practice to keep an eye out for them by reading new books on the subject matter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ravioli code</h1>
                
            
            
                
<p>"Organic architecture seeks superior sense of use and a finer sense of comfort, expressed in organic simplicity."<br/>
<br/>
- Frank Lloyd Wright</p>
<p><strong>What is it?</strong><br/>
<strong>Ravioli code</strong> is the result of overzealous encapsulation and an architecture that's divided into too many individual classes.</p>
<p><strong>Why is it wrong?</strong><br/>
Most programmers have heard the term <em>Spaghetti code</em> during their career. It's often used to describe unstructured and messy code that's usually produced by junior programmers. But Ravioli code can be considered to be the opposite; it's often the result of overly designed code made by programmers who have a lot of experience but lack the desire to make their work readable to others.</p>
<p>In both cases, navigating and maintaining a code base suffering from those Anti-Patterns can become difficult.</p>
<p><strong>What is the root cause?</strong><br/>
A religious and dogmatic approach to programming and design patterns can make you write code that looks accurate but unreadable to others.</p>
<p><strong>How to avoid this?</strong><br/>
Here's some tips that might help you avoid this anti-pattern:</p>
<ul>
<li>Be willing to sacrifice accuracy for readability when necessary</li>
<li>Always consider that design patterns do give you structure, but often at the sacrifice of readability</li>
<li>Write code for an audience, and remember that those who might read it might not have the same skillset as you</li>
</ul>
<p>Most professional programmers don't consciously use design patterns, often because they don't understand them or don't know how to implement them correctly. So, to be a great programmer, you have to be more aware than others of all the patterns that are available and how to use them properly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Poltergeist</h1>
                
            
            
                
<p>"Indeed, it is better to postpone, lest either we complete too little by hurrying, or wander too long in completing it."<br/>
<br/>
- Tertullian</p>
<p><strong>What is it?</strong><br/>
<strong>Poltergeist</strong> objects are usually the result of code that was implemented to solve a temporary architecture issue, but that remained in the code base longer than it should have.</p>
<p><strong>Why is it wrong?</strong><br/>
The density of code that you have to maintain often relates to the frequency of bugs you might have to fix every time you make a change. Another side-effect of having ghost classes haunting your code base is that it can provoke fear of making changes because of what might happen from unknown objects that pop up at the wrong moment.</p>
<p><strong>What is the root cause?</strong><br/>
Poltergeist objects and classes, which can be called <strong>ghosts</strong>, are the result of good intentions going bad. Often, their classes were implemented to solve a temporary architectural issue, but the programmer never had the chance to complete their design, and thus you end up with objects in memory that are present, but their reason for being is not apparent.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><strong>How to avoid this?<br/></strong>Here are some tips that might help you avoid this anti-pattern:</p>
<ul>
<li>Don't use design patterns that you don't fully understand</li>
<li>Schedule weekly code-base reviews and remove deprecated code</li>
<li>Use source-control branching strategies to manage the refactoring of significant components</li>
<li>Add TODO comments in your code and ask your team to review them and take action regularly</li>
<li>Write the documentation before implementing a new architecture so that your team can review your plan and give you feedback before you make changes</li>
</ul>
<p>Being a minimalist is a good mindset for a programmer. Code can be complicated, but it should never be bloated with things that are useless. Focus always on what is essential and remove what is not.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Premature optimization</h1>
                
            
            
                
<p>"Perfection is attained by slow degrees; it requires the hand of time."<br/>
<br/>
- Voltaire</p>
<p><strong>What is it?</strong><br/>
<strong>Premature optimization</strong> is the act of optimizing and perfecting your code before it's needed and, as a result, wasting precious production time.<br/>
<br/>
<strong>Why is it wrong?</strong><br/>
Investing more time than needed on optimization is one of the worst ways to waste your time and that of your employer. Most devices are getting faster every year, and, thus, programmers are less required to optimize their code to run faster on limited hardware.<br/>
<br/>
<strong>What is the root cause?</strong><br/>
A lack of experience is usually the root cause.</p>
<p><strong>How to avoid this?</strong><br/>
Always profile your code before optimizing it. For those who might not know, <strong>profiling</strong> is the act of using diagnostic tools that help you analyze the performance of your system. Often, you will discover that the performance bottlenecks in your code are limited to specific areas in your source code, so by focusing on those, you can gain speed without having to refactor your entire code base.</p>
<p>Like a good mechanic, a programmer should have a toolbox filled with tools that can help them work faster and better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vendor lock-in</h1>
                
            
            
                
<p>"It's not a faith in technology. It's faith in people."<br/>
<br/>
- Steve Jobs</p>
<div><p><strong>What is it?</strong><br/>
<strong>Vendor lock-in</strong> happens when you start integrating third-party components, plugins, frameworks, or libraries in your code base, but become dependent on them to make your code function properly.</p>
<p><strong>Why is it wrong?</strong><br/>
In the context of a Unity project, being dependent on third-party libraries can limit your ability to upgrade to a new version of Unity because you might need to wait for patches from the vendor in order to avoid going backward.</p>
<p><strong>What is the root cause?<br/></strong>Buying Plug and Play components and libraries from third-party vendors saves a lot of production time, so it's very tempting to use them to a point where you become too dependent on them.<strong><br/></strong></p>
<p><strong>How to avoid this?<br/></strong>You should research a vendor before buying their products and integrating them into your code base. For example, if they are not updating their support forums, it might be an indication that they are not planning to release updates shortly, and this might limit your capacity to get immediate support if required.</p>
</div>
<p>As a Unity developer, you should always check the Unity Asset store before writing anything because there's probably someone who has already done what you want to do, but in a better way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Management by numbers</h1>
                
            
            
                
<p><strong>What is it?</strong><br/>
<strong>Managing by numbers</strong> is the tendency to take management decisions based heavily on statistics that are generated by tools, such as Excel spreadsheets or reports, rather than on an accurate analysis of what is going on in a project.</p>
<p><strong>Why is it wrong?</strong><br/>
Numbers expressed in productivity reports often don't mirror the quality or the potential of a team. They can hide issues that are provoked by dynamic human interactions, instead of exposing them. This focus on numbers can blind project managers during critical decision-making processes. In other words, can you define the level of productivity of a programmer by the amount of bugs they fix in a week? The answer is <em>no</em>, because the complexity of a particular bug is not a constant. You can't evaluate a programmer who fixes five simple bugs in a week the same way as another programmer who resolves a single but very complex one in the same period.</p>
<p><strong>What is the root cause?</strong><br/>
Numbers are easy to explain and justify, especially when communicating with higher management that doesn't have the technical expertise to evaluate a project beyond very general indicators. This approach can result in an organization that spends its time focusing on figures instead of actual results.</p>
<p><strong>How to avoid this?</strong><br/>
Senior programmers should challenge project managers who are using general statistics and numbers to evaluate the progress of a project by offering more concrete indicators of quality and improvement. Here is an example:</p>
<ul>
<li>Update versus downtime of services</li>
<li>The rate of bugs found and fixed over time</li>
</ul>
<p>Probably the most critical thing you can do to guarantee yourself a long career in the tech industry after you hit 40 is to go back to school and get a diploma or certification in management. This type of education will permit you to transition into a long-term leadership role, which companies will probably encourage you to consider after you have attained several decades of experience.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The technical interview</h1>
                
            
            
                
<p>"I choose a lazy person to do a hard job. Because a lazy person will find an easy way to do it."<br/>
<br/>
-Bill Gates</p>
<p><strong>What is it?</strong><br/>
The concept of a technical interview in the hiring process of a programmer might not sound like an anti-pattern in itself, but I'm proposing that it is, and one that has side-effects in the quality of source code produced by a team. For those who have never experienced a programmer technical interview, it involves a series of tests that are given to the candidate to validate their skills and knowledge. The exams may include writing answers about programming on a whiteboard, a piece of paper, or in an online test environment. I consider the technical interview an industry-wide anti-pattern.</p>
<p><strong>Why is it wrong?<br/></strong>The core issue of the technical interview process is that you can only test for what you already know. Thus, you will end up recruiting candidates who are mirror images of yourself. As a result, you will end up building a team that lacks a range of different skills. This approach is valid if your only goal is to have a very specialized team, but this is a rare case. Most companies need to have employees with varied skillsets to balance out any weaknesses in the organization.</p>
<p>For example, if your subject of focus of your technical interview revolves around data structures because this is your strength as the interviewer, then you might end up eliminating candidates who are weaker in that area but stronger in other areas, such as design patterns. But because you are evaluating only on what you consider to be important, based on your technical bias, you might miss out on hiring candidates who could bring new skills to your team.</p>
<p class="mce-root"/>
<p><strong>What is the root cause?<br/></strong>The main reason why the hiring process of programmers is so inconsistent throughout our industry is that few people understand what programmers do and how to evaluate them as candidates. So, hiring managers prefer to judge applicants by their final technical test scores, thereby reducing the value of a candidate to a single number.</p>
<p>There are also some types of interviewer behavior patterns or processes that may also be part of the root cause:</p>
<ul>
<li><strong>The Riddler</strong>: A riddler is an interviewer who wants to test the skills of a candidate by asking questions in the form of clever puzzles. This approach often ends up confusing most candidates and turning the interview process into a stressful game.</li>
<li><strong>The Hot Seat</strong>: The infamous hot seat interview type is similar to a police interrogation with the goal of isolating a candidate's weaknesses and strengths with a rapid succession of questions. Often, one interviewer will take the role of the <em>bad cop</em> by being more aggressive in their questioning, while another plays the <em>good cop</em> to assist the candidate if they take too long to answer some questions. This approach ends up burning out the candidate or forcing them to answer in a way that they think is what the interviewers want to hear. This is not a suitable method to learn about the potential of a candidate.</li>
<li><strong>The Whiteboard</strong>: The whiteboard interview consists of having the candidate answer technical questions by writing their answer on a whiteboard. There's a particular issue with this method of evaluating candidates; most programmers never write code on paper or whiteboards during their career, so when forced to do so during a stressful situation such as an interview will result in a lot of false negatives about their actual skill level.</li>
</ul>
<p><strong>How to avoid this?<br/></strong> Almost everyone agrees that hiring good programmers is a costly and challenging process, but this means that you need to be more creative in the way you approach technical interviews, so you don't end up rejecting excellent candidates for ones who are just clones of who you already have in your team.</p>
<p>Here are some tips that can help you avoid this anti-pattern:</p>
<ul>
<li>Try to see what is unique and valuable in a candidate. Get a candidate who can teach you and your team something new.</li>
<li>Don't probe for weaknesses. Instead, try to understand a candidate's strengths and see whether they balance with their potential weaknesses.</li>
<li>Always take into consideration the fact that there's a variety of skills that a programmer might have in the industry, depending on their specialization. For example, the average web developer might not be as strong at math as a 3D programmer, but they might be better at normalizing databases or designing client-server applications.</li>
<li>When a candidate fails to answer a technical question, ask yourself whether this is because they don't understand it, might not have the skills to do so, or might be too nervous because of the examination process. In other words, the context of the interview is important, not just the final score, when evaluating the actual skill level of an applicant.</li>
</ul>
<p>Even if you are a very experienced professional programmer, you should never underestimate the potential difficulty of a modern-day technical interview process. Your years of experience might be a disadvantage because interviewers usually want to evaluate whether you still know your computer science basics. In other words, you might have to answer questions about subjects that you might not have reviewed since university. So it's a good idea to dust off those old school books and study the basics before going into an interview.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">We have arrived at the end of our journey. Throughout this book, we explored various design patterns, each with their unique abilities. The most important takeaway from this book is that before you start writing a single line of code, you should always verify whether there's a pattern that matches the design intention of a system before building it. This approach avoids reinventing the wheel and offers you a consistent methodology to programming that will help you throughout your career.</p>
<p class="mce-root">But this chapter also exposes that what looks like a valid design or management decision can quickly go wrong without awareness of the motivations and potential consequences behind it. In other words, as programmers, we need to be mindful of the potential implications of our decisions, at every level, or we can fall victim to Anti-Patterns.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise</h1>
                
            
            
                
<p>For our final exercise, I'm making you a list of daily habits that will ensure a long and prosperous career as a programmer in the game industry. However, a failure to enhance your skills gradually will almost guarantee that you will end up getting stuck in mediocrity and possibly irrelevance. Trust me; it happened to me until, one day, I decided to change my habits and focus again on gaining true mastery over my craft.</p>
<p>Here are some good habits to form:</p>
<ul>
<li>Learn at least one new programming language per year.</li>
<li>Check your skills regularly by taking practice-interview programming exams.</li>
<li>Attain a new technical certification every year, such as the PMP, CCNA, and CEH.</li>
<li>Make a list of all your weaknesses as a programmer and work on them every day.</li>
<li>Try to attend at least one technology-related meet-up event or conference per week.</li>
<li>Join technical professional organizations, such as ACM and IEEE, and use the resources on offer.</li>
<li>Keep yourself up to date in terms of what's happening by reading tech and game industry news every day.</li>
<li>Take courses on subjects from other fields that might be related to yours, including management, UI design, and animation.</li>
<li>Make yourself a list of blogs and YouTube channels that are related to technology and programming. Read at least one blog post and watch a video per day.</li>
<li>Attend a coding bootcamp or subscribe to at least one training program per month. Don't forget to complete them.</li>
<li>Read at least two books about programming or related fields per year.</li>
<li>Open a GitHub account and contribute to at least one open source project, even if it's just a couple of lines of code. Get used to the process and the community.</li>
<li>Learn meditation; it's a stressful job; knowing how to stay calm under pressure will help you maintain your mental health and avoid burning out.</li>
</ul>
<p class="mce-root">For our final exercise, I would recommend that you make a list of your favorite patterns and ask yourself why you like them. Is it because they're easy to implement, or because they resolve actual architectural issues in your code? In other words, make sure that you don't use a specific pattern for the wrong reasons, never be lazy, and always be conscious with your choices when writing code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p><strong>Organizations</strong>:</p>
<ul>
<li><em>ACM</em><br/>
<a href="https://www.acm.org">https://www.acm.org</a></li>
<li><em>IEEE</em><br/>
<a href="https://www.ieee.org">https://www.ieee.org</a></li>
</ul>
<p><strong>Blogs</strong>:</p>
<ul>
<li><em>Coding Horror</em><br/>
<a href="https://blog.codinghorror.com">https://blog.codinghorror.com</a></li>
<li><em>Joel on Software</em><br/>
<a href="https://www.joelonsoftware.com">https://www.joelonsoftware.com</a></li>
<li><em>Scott Hanselman Blog</em><br/>
<a href="https://www.hanselman.com/blog/">https://www.hanselman.com/blog/</a></li>
<li><em>The Crazy Programmer</em><br/>
<a href="https://www.thecrazyprogrammer.com">https://www.thecrazyprogrammer.com</a></li>
</ul>
<p><strong>YouTube</strong>:</p>
<ul>
<li><em>Computerphile</em><br/>
<a href="https://www.youtube.com/user/Computerphile">https://www.youtube.com/user/Computerphile</a></li>
<li><em>Success in Tech</em><br/>
<a href="https://www.youtube.com/channel/UC-vYrOAmtrx9sBzJAf3x_xw">https://www.youtube.com/channel/UC-vYrOAmtrx9sBzJAf3x_xw</a></li>
<li><em>TED</em><br/>
<a href="https://www.youtube.com/user/TEDtalksDirector">https://www.youtube.com/user/TEDtalksDirector</a></li>
<li><em>TechLead</em><br/>
<a href="https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw">https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw</a></li>
</ul>
<p><strong>Tech news</strong>:<strong><br/></strong></p>
<ul>
<li><em>Slashdot</em><br/>
<a href="https://slashdot.org">https://slashdot.org</a></li>
<li><em>Wired</em><br/>
<a href="https://www.wired.com">https://www.wired.com</a></li>
<li><em>Gamasutra</em><br/>
<a href="http://www.gamasutra.com">http://www.gamasutra.com</a></li>
<li>GamesIndustry.biz<br/>
<a href="https://www.gamesindustry.biz">https://www.gamesindustry.biz</a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p><strong>Online courses</strong>:<strong><br/></strong></p>
<ul>
<li><em>Udemy</em><br/>
<a href="https://www.udemy.com">https://www.udemy.com</a></li>
<li><em>Lynda</em><br/>
<a href="https://www.lynda.com">https://www.lynda.com</a></li>
<li><em>Pluralsight</em><br/>
<a href="https://www.pluralsight.com">https://www.pluralsight.com</a></li>
<li>MasterClass<br/>
<a href="https://www.masterclass.com">https://www.masterclass.com</a></li>
</ul>
<p><strong>Books</strong>:</p>
<ul>
<li><em>Anti-patterns: Managing Software Organizations and People</em>, by Colin J. Neill, Philip A. Laplante, and Joanna F. DeFranco<a href="https://www.crcpress.com/Antipatterns-Managing-Software-Organizations-and-People-Second-Edition/Neill-Laplante-DeFranco/p/book/9781439861868"><br/>
https://www.crcpress.com/Antipatterns-Managing-Software-Organizations-and-People-Second-Edition/Neill-Laplante-DeFranco/p/book/9781439861868</a></li>
</ul>


            

            
        
    </body></html>