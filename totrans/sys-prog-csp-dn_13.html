<html><head></head><body>
		<div id="_idContainer081">
			<h1 class="chapter-number" id="_idParaDest-282"><a id="_idTextAnchor283"/>13</h1>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor284"/>The One with the Deployment Dramas</h1>
			<p><em class="italic">Deployment </em><span class="No-Break"><em class="italic">and Distribution</em></span></p>
			<p>Allow me to make a confession: I love writing code. The whole process that starts with a vague idea, followed by writing the first lines of code, then finding issues and debugging the code, gives me a thrill. There is something magical about creating something out of thin air and seeing it come to life before <span class="No-Break">my eyes.</span></p>
			<p>But there comes a moment when the software is “good enough” and it needs to move into production. After all, we write software with a purpose: it needs to be used. And that usually means moving it away from your development machine to a <span class="No-Break">production environment.</span></p>
			<p>There are many challenges in this process. But don’t worry: we will tackle all of them! We will discuss the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What does <span class="No-Break">deployment mean?</span></li>
				<li>How do you use the Publish wizard from <span class="No-Break">Visual Studio?</span></li>
				<li>What is CI/CD, and how do I use it in Azure DevOps <span class="No-Break">or GitHub?</span></li>
				<li>How do I build <span class="No-Break">an installer?</span></li>
				<li>How do I deploy <span class="No-Break">with Docker?</span></li>
			</ul>
			<p>So, if you are ready to let the world see the fruits of your labor but are unsure how to get that out there, this is the chapter <span class="No-Break">for you.</span></p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor285"/>Technical requirements</h1>
			<p>You will find all the code in this chapter in our repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter13</span></a><span class="No-Break">.</span></p>
			<p>If you want to follow along with the CI/CD samples in Azure, you’ll need an Azure subscription. You can sign up for a free trial for Azure <span class="No-Break">at </span><a href="https://azure.microsoft.com/en-us/free/"><span class="No-Break">https://azure.microsoft.com/en-us/free/</span></a><span class="No-Break">.</span></p>
			<p>To have a go with GitHub Actions, you’ll need to sign up for a GitHub account. You can get a free one <span class="No-Break">here: </span><a href="https://github.com/signup"><span class="No-Break">https://github.com/signup</span></a><span class="No-Break">.</span></p>
			<p>If you want to follow along when we talk about the setup projects, you must install <strong class="bold">Visual Studio Extension Microsoft Visual Studio Installer Projects 2022</strong>. You can find this by going to the <strong class="bold">Extensions</strong> menu item and choosing <strong class="bold">Manage extensions</strong>. From there, in the <strong class="bold">Online</strong> tab, search for <span class="No-Break">that extension.</span></p>
			<p>With this tool, you can follow along and build your <span class="No-Break">own installers.</span></p>
			<p>If you want to work with the Docker sample, install Docker Desktop. You can find it <span class="No-Break">here: </span><a href="https://www.docker.com/products/docker-desktop"><span class="No-Break">https://www.docker.com/products/docker-desktop</span></a><span class="No-Break">.</span></p>
			<p>All the software mentioned here is free or has a <span class="No-Break">free trial.</span></p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor286"/>From development to production</h1>
			<p>There will come a moment when you’re developing your application when you decide it is time for other people to try out the fruits of your labor. This means moving your application from your development machine to another environment. This could be another developer’s machine or a <span class="No-Break">production system.</span></p>
			<p>Depending on the complexity of your system, moving the bits away could involve anything from a simple file copy to building a complex installer application. You also have to think about ways to remove your application from their system and about ways to update or upgrade your application. All these tasks are gathered under the <span class="No-Break">term </span><span class="No-Break"><em class="italic">deployment</em></span><span class="No-Break">.</span></p>
			<p>Deployment should be as seamless as possible. The users should be able to take your application and prepare it for use effortlessly. This means all the hard work lies <span class="No-Break">with us.</span></p>
			<p>Creating a deployment scenario involves thinking about the <span class="No-Break">following aspects:</span></p>
			<ul>
				<li>Copying <span class="No-Break">your binaries</span></li>
				<li>Copying the binaries your system <span class="No-Break">depends on</span></li>
				<li>Copying <span class="No-Break">additional files</span></li>
				<li>Setting <span class="No-Break">user rights</span></li>
				<li>Copying settings and <span class="No-Break">altering them</span></li>
				<li>Creating and <span class="No-Break">copying secrets</span></li>
				<li>Altering system settings such <span class="No-Break">as paths</span></li>
				<li>Registering your application in the <span class="No-Break">host environment</span></li>
			</ul>
			<p>Uninstalling your applications means reversing this process: in an ideal world, an uninstall leaves no trace of your application and the associated files on the <span class="No-Break">host machine.</span></p>
			<p>Upgrading and updating is a mix of these scenarios: deploying new code, changing settings, and removing things you no longer need in the <span class="No-Break">latest version.</span></p>
			<p>If all you have is a simple, standalone console application, deployment is a breeze: just copy the files needed. Suppose you’re deploying a complex system, such as a background worker; this needs configuration settings to connect to external systems. In that case, you have a lot more work to do. But there is good news: for each of those and other scenarios, there are strategies to follow. And that is what the rest of this chapter is all about. So, do a final build of your app, do a quick local test, and let’s deploy <span class="No-Break">our work!</span></p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor287"/>Publishing and file copy</h1>
			<p>The<a id="_idIndexMarker1065"/> easiest way to deploy an application is to use Visual Studio’s Publish mechanism. Let’s assume I have a simple console application. I don’t have any configuration settings that I need to change when running on a production environment. So, I can just copy what <span class="No-Break">I have.</span></p>
			<p>Let’s assume we have a simple console application. You’ve tested it, and you’re ready to deliver. There are two options: use <strong class="bold">Visual Studio</strong> or use <span class="No-Break">the </span><span class="No-Break"><strong class="bold">CLI</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor288"/>Publish using Visual Studio</h2>
			<p>In <a id="_idIndexMarker1066"/>Visual Studio, in<a id="_idIndexMarker1067"/> the <strong class="bold">Solution Explorer</strong> area, right-click on your project and select <strong class="bold">Publish</strong>. You’ll see the <span class="No-Break">following dialog:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer066">
					<img alt="Figure 13.1: Publishing via Visual Studio" src="image/B20924_14_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: Publishing via Visual Studio</p>
			<p>There are a<a id="_idIndexMarker1068"/> couple of options to <span class="No-Break">choose from:</span></p>
			<ul>
				<li><strong class="bold">Azure</strong>: This <a id="_idIndexMarker1069"/>means deploying your system to Azure so that it <span class="No-Break">runs there.</span></li>
				<li><strong class="bold">ClickOnce</strong>: ClickOnce is a technique for building a simple installer. Updates and uninstallation are part of the mechanism. However, ClickOnce is meant for Windows applications that the users start. Therefore, this is not a solution for us system programmers. For that reason, I will not cover <span class="No-Break">ClickOnce here.</span></li>
				<li><strong class="bold">Docker Container Registry</strong>: This is a great way to package and deploy systems. We will discuss <span class="No-Break">this later.</span></li>
				<li><strong class="bold">Folder</strong>: This is the simplest way to publish as it just copies all files needed to <span class="No-Break">a folder.</span></li>
				<li><strong class="bold">Import Profile</strong>: If you’ve already defined deployment methods, you can use those settings here by <span class="No-Break">importing them.</span></li>
			</ul>
			<p>In this case, we’ll choose <strong class="bold">Folder</strong>. Upon doing so, you’ll get a new dialog asking if you want to use <strong class="bold">ClickOnce</strong> for the folder deployment or whether you wish to deploy to the filesystem. Choose <strong class="bold">Folder</strong> to pick the latter. At this point, you can enter the path to which you <a id="_idIndexMarker1070"/>want to publish. For now, leave it as the default setting. <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></p>
			<p>Although you <a id="_idIndexMarker1071"/>clicked <strong class="bold">Finish</strong>, it didn’t finish publishing. All Visual Studio did was create a publish profile. In this case, it is called <strong class="source-inline">FolderProfile.pubxml</strong>, and you can find it in the <strong class="bold">Solution Explorer</strong> area in your project under <strong class="bold">Properties</strong> &gt; <span class="No-Break"><strong class="bold">PublishProfiles</strong></span><span class="No-Break">.</span></p>
			<p>Visual Studio will open the profile and show you what it looks like. From here, we can click the big <strong class="bold">Publish</strong> button; however, we might want to tweak the profile before doing that. Click <strong class="bold">More Actions</strong> and choose <strong class="bold">Edit</strong>. This results in the <span class="No-Break">following dialog:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer067">
					<img alt="Figure 13.2: The Profile settings dialog" src="image/B20924_14_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: The Profile settings dialog</p>
			<p>You can tweak the profile a lot here. Let’s walk through <span class="No-Break">the options:</span></p>
			<ul>
				<li><strong class="bold">Configuration</strong>: You can choose any configuration you might have defined in your project. By default, these are the <strong class="bold">Debug</strong> and <strong class="bold">Release</strong> configurations. I suggest that you use <strong class="bold">Release</strong> <span class="No-Break">for deployments.</span></li>
				<li><strong class="bold">Target framework</strong>: Here, you can choose any compatible and installed framework you want for your application. Just leave this set to what you used when <a id="_idIndexMarker1072"/>you were building <span class="No-Break">your system.</span></li>
				<li><strong class="bold">Deployment mode</strong>: Here, you can choose between <strong class="bold">Framework-dependent</strong> and <strong class="bold">Self-contained</strong>. If you pick <strong class="bold">Framework-dependent</strong>, the application will assume the .NET runtime is installed on the target machine. However, if you select <strong class="bold">Self-contained</strong>, all needed assemblies will be part of the publication. Your package<a id="_idIndexMarker1073"/> will be much bigger since it contains everything you need from the .NET runtime. However, it does not rely on others to install the .<span class="No-Break">NET runtime.</span></li>
				<li><strong class="bold">Target runtime</strong>: This is where you decide on the architecture of the target. If you know what architecture that machine is, you can choose it from the drop-down menu. This results in more optimized code but restricts where you can use it. For instance, if you decide to use Win-X64, you cannot deploy your code to a Linux machine. If you do not want to make that decision, leave it set <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Portable</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Target location</strong>: This is the location where the files will <span class="No-Break">be copied.</span></li>
			</ul>
			<p>Suppose you decided to go with the <strong class="bold">Self-contained</strong> option. In that case, you get three additional choices: <strong class="bold">Produce Single file</strong>, <strong class="bold">Enable ReadyToRun compilation</strong>, and <strong class="bold">Trim </strong><span class="No-Break"><strong class="bold">unused code</strong></span><span class="No-Break">.</span></p>
			<p>The first option is self-explanatory: you get one big file instead of dozens of small files. <strong class="bold">ReadyToRun</strong> is a form<a id="_idIndexMarker1074"/> of <strong class="bold">ahead-of-time</strong> (<strong class="bold">AOT</strong>) compilation. This means the code is pre-compiled and thus starts faster. It is not a real AOT compilation: the resulting files contain both the compiled code and the IL. Still, it saves startup time. The <strong class="bold">Trim unused code</strong> option removes all code from the runtime you don’t need. Selecting this option makes the final package a <span class="No-Break">lot smaller.</span></p>
			<p>Make your changes and then click <strong class="bold">Save</strong>. After that, click <strong class="bold">Publish</strong>. When Visual Studio is finished, go to the folder you picked as the destination and inspect what has happened (<em class="italic">hint</em>: you can click on the <strong class="bold">Target location</strong> value in the <strong class="bold">Publish Profile</strong> dialog to open an <strong class="bold">Explorer</strong> window and go to the <span class="No-Break">location directly).</span></p>
			<p>All that’s left is to <a id="_idIndexMarker1075"/>copy the resulting files to the target machine. Then, you can run it on that machine to see if everything is working fine and you <span class="No-Break">are ready.</span></p>
			<p>Congratulations: you just deployed <span class="No-Break">your application!</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor289"/>Publishing using the CLI</h2>
			<p>The Visual Studio wizard<a id="_idIndexMarker1076"/> is very good at helping you build the profile. Still, if you already know what you’re doing or want to make publishing <a id="_idIndexMarker1077"/>part of a pipeline, you can use the CLI to do <span class="No-Break">the same.</span></p>
			<p>The base command is simple – in the directory where you have your <strong class="source-inline">.csproj</strong> file, just run the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet publish</pre>			<p>This command takes all the default settings in the dialog box and uses them to publish your application. Of course, you can change what <strong class="source-inline">publish</strong> does: all you have to do is supply the correct parameters. The following table shows the most common ones and their possible values. Most parameters have two variants – a full parameter name (often preceded by two dashes) and a shorthand (often preceded by <span class="No-Break">one dash):</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-12">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Parameter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Possible Values</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">o</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">--output</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The output directory to place the published <span class="No-Break">artifacts in</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The directory where you want to place the <span class="No-Break">published application</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">sc</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">--self-contained</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Includes the runtime with <span class="No-Break">your application</span></p>
						</td>
						<td class="No-Table-Style">
							<p>-</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">f</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">--framework</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The target framework you want to <span class="No-Break">deploy to</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">net6.0</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">net7.0</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">net8.0</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">r</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">--runtime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The target runtime to <span class="No-Break">publish for</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">win-x64</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">linux-x64</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">linux-arm</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">c</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">--configuration</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The <span class="No-Break">build configuration</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Release</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">Debug</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.1: dotnet publish options</p>
			<p>If you <a id="_idIndexMarker1078"/>decide to build a self-contained deployment, you can add three <span class="No-Break">more parameters:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-10">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Parameter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">p:PublishSingleFile=true</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates a <span class="No-Break">single file</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">p:PublishReadyToRun=true</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Compiles to Ready To Run <span class="No-Break">AOT binaries</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">p:PublishTrimmed=true</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Removes all unnecessary code from <span class="No-Break">the binaries</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.2: Self-Contained extra options</p>
			<p>You could <a id="_idIndexMarker1079"/>specify that you do not want these options by setting them to <strong class="source-inline">False</strong>, but I suggest that you omit <span class="No-Break">that parameter.</span></p>
			<p>So, to publish your console application to a specific folder, create a self-contained deployment in a single file that’s ready to run, and trim all unnecessary code for a <strong class="source-inline">win-x64</strong> architecture running on <strong class="source-inline">net.80</strong>. To do so, issue the following code (all on a <span class="No-Break">single line):</span></p>
			<pre class="console">
dotnet publish
  -o d:\temp\publish
  --self-contained
  -f net8.0
  -r win-x64
  -c Release
  -p:PublishSingleFile=true
  -p:PublishReadyToRun=true
  -p:PublishTrimmed=true</pre>			<p>Now, if you <a id="_idIndexMarker1080"/>go to the <strong class="source-inline">d:\temp\publish</strong> folder, you can <a id="_idIndexMarker1081"/>take the file there, copy that to your production machines, and run it. At this point, you can sit back, knowing your hard work is finally <span class="No-Break">being used.</span></p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor290"/>Using Azure DevOps and GitHub</h1>
			<p>If your code is meant to be used in the cloud, such as on Azure or AWS, you can use Azure DevOps and GitHub. Which one you pick depends on where you currently have your source code. Both DevOps <a id="_idIndexMarker1082"/>and GitHub allow for <strong class="bold">continuous integration and continuous deployment</strong> (<span class="No-Break"><strong class="bold">CI/CD</strong></span><span class="No-Break">) scenarios.</span></p>
			<p class="callout-heading">CI/CD</p>
			<p class="callout">The idea with CI/CD is that when you change your source code, the system notices this and builds your software. Then, it can run tests optionally (in my view, it is not optional, but mandatory). After, it automatically deploys the new binaries to the production environment. This way of working means that you can do a lot of minor, incremental updates to your system and get early feedback on what you did. If this fits your use case, it is a <span class="No-Break">great tool!</span></p>
			<p>Let’s look at Azure <span class="No-Break">DevOps first.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor291"/>Deploying to Azure</h2>
			<p>I assume <a id="_idIndexMarker1083"/>you have an Azure DevOps project set up, have defined the working process, and have a repo available to host <span class="No-Break">your code.</span></p>
			<p>You can connect Visual Studio to that project if you have done so. In my case, I have created a simple Function App. A Function App is a service that runs in Azure. In this case, I have decided to use a simple HTTP-based trigger. In other words, the function responds to a REST API call and returns a string with a pleasant greeting. This chapter is not about writing Azure Functions but about deploying code, so I won’t dive into the details of how the code works. For now, it’s a REST API that you call with a parameter called <strong class="source-inline">name</strong>; it returns a friendly greeting containing that name. <span class="No-Break">That’s it.</span></p>
			<p>But to make things more interesting, I have called my program <strong class="source-inline">MyFileConverterFunctionApp</strong>. Trust me: it doesn’t do <span class="No-Break">anything interesting.</span></p>
			<p>If you have the code up and running locally, it is time to prepare your system for deployment. There are two steps we need <span class="No-Break">to take.</span></p>
			<ul>
				<li>Create a <span class="No-Break">publish profile</span></li>
				<li>Publish the system <span class="No-Break">to Azure</span></li>
			</ul>
			<p>Let’s <span class="No-Break">get started.</span></p>
			<h3>Building the publish profile for Azure DevOps</h3>
			<p>Before <a id="_idIndexMarker1084"/>I show you how to deploy your application to Azure, let’s review the prerequisites if you want to follow along. First, you need a project<a id="_idIndexMarker1085"/> to deploy. But besides this obvious prerequisite, these are the things <span class="No-Break">you’ll need:</span></p>
			<ul>
				<li>An <span class="No-Break">Azure account.</span></li>
				<li>A resource group (mine is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">SystemsProgrammingRg</strong></span><span class="No-Break">).</span></li>
				<li>A Key Vault to <span class="No-Break">store secrets.</span></li>
				<li>A storage account. We’ll need this for <span class="No-Break">deployment later.</span></li>
			</ul>
			<p>Once you have these, you’re ready to start the <span class="No-Break">deployment process.</span></p>
			<p>In Visual Studio, right-click on your project’s name and select <strong class="bold">Publish</strong>. You’ll be taken to the <span class="No-Break">following screen:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 13.3: Default publishing dialog" src="image/B20924_14_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3: Default publishing dialog</p>
			<p>Yes, this is <a id="_idIndexMarker1086"/>the same dialog we saw previously. However, this time, select <strong class="bold">Azure</strong> as <span class="No-Break">your target.</span></p>
			<p>The<a id="_idIndexMarker1087"/> following dialog will ask you what kind of service you want to deploy. I chose <strong class="bold">Azure Function App (Windows)</strong>. You could go for a Linux deployment. Don’t worry about the container options for now; we will discuss Docker and containers later in <span class="No-Break">this chapter.</span></p>
			<p>Then, we need to tell Visual Studio about the final location of our application. Likely, you won’t have a Function App you can use (that wasn’t part of the prerequisites, after all), so you can create one now. You’ll be presented with a dialog asking you about your environment and preferences. Mine looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 13.4: Creating a new Function App in Visual Studio" src="image/B20924_14_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4: Creating a new Function App in Visual Studio</p>
			<p>I’ve blacked out my<a id="_idIndexMarker1088"/> Azure account details <a id="_idIndexMarker1089"/>since I want you to use yours. You need to choose the options that are best for you. This dialog is also where you must specify the storage account I told you to create (in my case, it is <strong class="source-inline">dvstorageaccountsp</strong>). I also decided to add <strong class="bold">Application Insights</strong>. Using <strong class="bold">Application Insights</strong> helps me monitor and troubleshoot my application <span class="No-Break">if needed.</span></p>
			<p>When you click <strong class="bold">Create</strong>, the system will build your environment. This takes a while, but we can move to the next screen when it is done. This next screen gives you an overview of all app services<a id="_idIndexMarker1090"/> in the given resource group and all <a id="_idIndexMarker1091"/>the deployment slots. Since we haven’t deployed yet, this list is empty. <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer070">
					<img alt="Figure 13.5: Choosing what to generate as a publishing mechanism" src="image/B20924_14_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5: Choosing what to generate as a publishing mechanism</p>
			<p>We can choose whether to use a publish profile or GitHub Actions here. We will look at GitHub Actions shortly, so let’s go with <strong class="bold">Publish</strong> for now. Visual Studio will generate the Publish profile <span class="No-Break">for us.</span></p>
			<p>When that is done, we’ll get an overview, including a nice, big, inviting <span class="No-Break"><strong class="bold">Publish</strong></span><span class="No-Break"> button:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="Figure 13.6: Overview of the Publish profile" src="image/B20924_14_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6: Overview of the Publish profile</p>
			<p>Let’s click that <span class="No-Break"><strong class="bold">Publish</strong></span><span class="No-Break"> button!</span></p>
			<p>Again, this<a id="_idIndexMarker1092"/> takes a little while, but when your code <a id="_idIndexMarker1093"/>has been published, you’ll get a hyperlink that allows you to go to the resource. You can click that, but it won’t be exciting. It’s just a web page saying your Function App is up <span class="No-Break">and running.</span></p>
			<p>To see what happened, go to the Azure portal, find your resource group, and locate the Function App we created. There, you can test the function right inside the Azure web portal. Or better yet, open Visual Studio Code (if you have that installed), create a new file called <strong class="source-inline">test.http</strong>, and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
GET https://myfileconverterfunctionapp.azurewebsites.net/api/Function1
Content-Type: application/json
{
     "name": "dennis"
}
###</pre>			<p>Replace my URL <a id="_idIndexMarker1094"/>with yours, and click the <strong class="bold">Send Request</strong> link at the top of the first line. This will call the <a id="_idIndexMarker1095"/>server. You’ll get some results that should look similar to <span class="No-Break">the following:</span></p>
			<pre class="console">
HTTP/1.1 200 OK
Connection: close
Content-Type: text/plain; charset=utf-8
Date: Mon, 17 Jun 2024 07:07:01 GMT
Content-Encoding: gzip
Transfer-Encoding: chunked
Vary: Accept-Encoding
This HTTP triggered function executed successfully.</pre>			<p>Your data will be different, but the important part is that we get the <strong class="source-inline">HTTP/1.1 200 OK</strong> result. This shows that our <span class="No-Break">app works!</span></p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor292"/>Enabling continuous integration in Azure DevOps</h2>
			<p>Pushing to <a id="_idIndexMarker1096"/>Azure directly from your <a id="_idIndexMarker1097"/>development environment is convenient. Once you’ve set up the publishing profile, right-click on your program and click <strong class="bold">Publish</strong> to move your changes <span class="No-Break">to Azure.</span></p>
			<p>There is a better way of doing this, though: you can enable CI/CD so that any change you make is <span class="No-Break">automatically deployed.</span></p>
			<p class="callout-heading">Branching and CI/CD</p>
			<p class="callout">In all my samples, I use a single branch: <strong class="source-inline">main</strong>. I push changes from <strong class="source-inline">main</strong> on my machine directly to the online source repositories and let the systems build from that. In a real-world scenario, that is a terrible idea. You should pick up a branching strategy that allows for a good separation between the daily work and the deployments. You need things such as pull requests and merging strategies to preserve the quality of the work. Please don’t do what I’ve done here and have only a <span class="No-Break">single branch.</span></p>
			<p>So, how do we achieve this magic? How do we get our changes “auto-magically” in our production environment? The answer is to <span class="No-Break">use pipelines.</span></p>
			<p>In your <a id="_idIndexMarker1098"/>Azure DevOps environment, go to the project. You’ll see a <strong class="bold">Pipelines</strong> tab in the left sidebar. Click that. You’ll greeted<a id="_idIndexMarker1099"/> with a page saying you haven’t got any pipelines yet. Let’s change that. Click the <strong class="bold">Create Pipeline</strong> button. You’ll be taken to the <span class="No-Break">following screen:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 13.7: Creating an Azure DevOps pipeline" src="image/B20924_14_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7: Creating an Azure DevOps pipeline</p>
			<p>In this case, select <strong class="bold">Azure Repos Git</strong>. When you click that, you’ll get a dialog asking for your project. Select the repository containing the code you want to <span class="No-Break">deploy automatically.</span></p>
			<p>Once you have done that, you’re done. Yes – it was <span class="No-Break">that easy.</span></p>
			<p>You can <a id="_idIndexMarker1100"/>now run the pipeline manually to see if<a id="_idIndexMarker1101"/> everything works. Building your solution will take a couple of minutes, but when it’s done, you’ll see something <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer073">
					<img alt="Figure 13.8: Successful pipeline run" src="image/B20924_14_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8: Successful pipeline run</p>
			<p>To test if your code has been published, rerun the test from Visual Studio Code (or whatever tool you use to test <span class="No-Break">REST calls).</span></p>
			<p>Now, it is time for the <span class="No-Break">cool stuff.</span></p>
			<p>In Visual Studio, make a change to the code. You could do something simple, such as change the text the <span class="No-Break">function returns.</span></p>
			<p>Save your <a id="_idIndexMarker1102"/>changes and push them to your repository. Once you’ve done that, go to Azure DevOps and find the pipeline – you’ll see that it’s already running! Just wait a few minutes until it is done and rerun your tests. You should see that your results have been propagated to the <span class="No-Break">production environment.</span></p>
			<p>That’s what I call <span class="No-Break">easy deployment!</span></p>
			<p>In case you<a id="_idIndexMarker1103"/> were wondering, the pipeline gets all the necessary information from your Publish profile. Remember when I said it was easier to do this if you publish manually first? Now you know why! You should look at the generated YAML files to see how things work. If you’re ready to take your deployment skills to the next level, I suggest that you search for this online. Dozens of books have been written on this topic, so I’m sure you can find what you’re <span class="No-Break">looking for.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor293"/>Enabling CI from GitHub</h2>
			<p>Azure DevOps<a id="_idIndexMarker1104"/> is a great way to collaborate with people in the same organization. However, if you want to work with people across organizations, GitHub might be a better choice. GitHub is more geared toward open collaboration, such as open source projects. But that doesn’t mean you can’t have the same continuous integration as you have with Azure DevOps: you can achieve the same thing with <span class="No-Break">GitHub Actions.</span></p>
			<p>Instead of having our source code in Azure DevOps, we host it in GitHub. Originally, GitHub was nothing more than a bunch of repositories, but they have expanded a lot since then. One of the more astonishing things they have added is <span class="No-Break">GitHub actions.</span></p>
			<p>Actions are the equivalent of the pipelines we just looked at. The syntax is different, and they support many more environments than the default pipelines in Azure, but the idea remains <span class="No-Break">the same.</span></p>
			<p>GitHub offers wizards to help you write your Actions, but there is a straightforward way to get our first Action up <span class="No-Break">and running.</span></p>
			<p>Create a new Azure Function project in Visual Studio, but this time store it in your GitHub account. Once you’ve done that, test it locally and publish it to Azure. I always do this to make sure <span class="No-Break">it works.</span></p>
			<p>Once the<a id="_idIndexMarker1105"/> publishing is done, create a test for your code using Visual Studio Code or your preferred <span class="No-Break">test tool.</span></p>
			<p>Now, let’s set up CI/CD <span class="No-Break">from GitHub!</span></p>
			<p>In the Azure portal, navigate to your function. Then, in the left sidebar, select <strong class="bold">Deployment Center</strong>. Then, under <strong class="bold">Source</strong>, select <strong class="bold">GitHub</strong>. After doing that, you can enter your details. You must log in to GitHub and select the correct organization, repository, and source branch you want <span class="No-Break">to publish.</span></p>
			<p>You’ll also need to specify how you wish to authenticate. The GitHub action needs to log in to Azure to deploy your code, so the wizard will create an account for you. Use a user-assigned identity to make this happen. The identity will be created automatically. Once this has happened, <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Save</strong></span><span class="No-Break">.</span></p>
			<p>And that is it – you’ve just set up your first GitHub Action! If you don’t believe me, go to your GitHub account, select your project, and go to <strong class="bold">Actions</strong>. You should see the action there, and it should show that it has already run <span class="No-Break">as well!</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer074">
					<img alt="Figure 13.9: First Action" src="image/B20924_14_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9: First Action</p>
			<p>To check that it works as intended, you can change your code, commit the changes to the repository, and see the Action come to life. You can click on the run to see the details. When<a id="_idIndexMarker1106"/> you’re done, it will have updated the code in your Azure environment. Test it and see <span class="No-Break">the changes!</span></p>
			<p>Of course, a lot of our code doesn’t run on Azure. As system programmers, we often have to deploy to local hardware. In that case, these techniques won’t work. We have to figure out a better way. And there is: <span class="No-Break">using installers!</span></p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor294"/>Building installers with Visual Studio</h1>
			<p>Installers <a id="_idIndexMarker1107"/>are nothing new – they were the only way to get an application on your system for a long time. Installers were primarily used to install Windows-based <a id="_idIndexMarker1108"/>applications on the users’ machines. They aren’t used that often anymore since this has become obsolete for most use cases. But installers are a great and simple way to get the job done if you wish to install a background worker process and need to do some <span class="No-Break">custom work.</span></p>
			<p class="callout-heading">Installers and Wix</p>
			<p class="callout">The standard Microsoft Installer project works just fine. Still, many developers have moved away in favor of using Wix. Wix is a third-party solution for building installers. It is incredibly versatile, and thus, it is pretty hard to start using. Many books, articles, and how-tos are available to help you get up and running. But in our case, we don’t need that complexity. The standard installer is enough for most system programmers. But if you want more control, I urge you to dive into Wix and see what it can do <span class="No-Break">for you.</span></p>
			<p>Suppose you installed the <strong class="bold">Microsoft Visual Studio Installer Projects 2022</strong> extension in Visual Studio. In that case, you can add an installer project to <span class="No-Break">your solution.</span></p>
			<p>Let’s <span class="No-Break">do that!</span></p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor295"/>Building a simple installer</h2>
			<p>In the <strong class="bold">New Project</strong> dialog, select <a id="_idIndexMarker1109"/>the <strong class="bold">Setup Wizard</strong> template. This will start a typical “next, next, finish” type wizard. There are five steps <span class="No-Break">to follow.</span></p>
			<p>The first one looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer075">
					<img alt="Figure 13.10: Setup Wizard (1 of 5)" src="image/B20924_14_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10: Setup Wizard (1 of 5)</p>
			<p>The rest of<a id="_idIndexMarker1110"/> the screens are self-explanatory. The first real question asks you whether you want to build a setup program for a Windows application, a setup program for a web application, or whether you want to create a redistributable package. We want the first option: a setup for a Windows application since that is what a background worker system <span class="No-Break">still is.</span></p>
			<p>Then, the wizard will want to know what you want to install. From the dropdown, select the <strong class="bold">Publish Items from…</strong> option. Those are all the executables and dependencies, so we <span class="No-Break">want those.</span></p>
			<p>After, you’ll be asked if there are any other files you want to include. There aren’t, so just click <strong class="bold">Next</strong>. The last step is a summary of the previous steps. Review this page and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></p>
			<p>And <span class="No-Break">that’s it!</span></p>
			<p>Before we can test it, we need to set some properties. Select your project in the <strong class="bold">Solution Explorer</strong> area and look at the <strong class="bold">Properties</strong> window. Here, you can fill in all the details you think <a id="_idIndexMarker1111"/>matter to you. Mine looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer076">
					<img alt="Figure 13.11: Setting up project properties" src="image/B20924_14_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11: Setting up project properties</p>
			<p>You should at least change the <strong class="bold">Manufacturer</strong> property: this will also be the name of the folder the installer creates when installing. By default, the installer assumes you’re installing an x86 application, which means your systems will be installed in a subfolder of the <strong class="source-inline">C:\Program Files (x86)</strong> folder. If that’s not what you want, change the <strong class="source-inline">TargetPlatform</strong> property from <strong class="bold">x86</strong> to <strong class="bold">x64</strong> to make <strong class="source-inline">C:\Program Files</strong> the default folder. Of course, you should only do that when your application is indeed 64-bit (the <strong class="bold">x64</strong> option) instead of the older 32-bit (<span class="No-Break"><strong class="bold">x86</strong></span><span class="No-Break">) format.</span></p>
			<p class="callout-heading">Why is 64-bit X64, but 32-bit X86?</p>
			<p class="callout">Sometimes, people get confused by these names. People seem to get that X64 means 64-bit, but why on earth is 32-bit called X86? The answer is rather simple: X64 indeed is just 64-bit, but the X86 refers to the original Intel 8086 processor from long ago, when machines ran 16-bit or at most 32-bit software. It’s just a weird thing that you now know and can brag about to <span class="No-Break">your friends!</span></p>
			<p>It’s time to test it <span class="No-Break">all out!</span></p>
			<p>Right-click<a id="_idIndexMarker1112"/> on your <strong class="bold">Setup</strong> project, select <strong class="bold">Build</strong>, and see if everything builds. If it does, you can right-click on the project again, but select <strong class="bold">Install</strong> this time. If all goes well, your system will be installed! You can navigate to the folder you chose during installation and see your <span class="No-Break">files there.</span></p>
			<p>To clean up, you only have to click <strong class="bold">uninstall</strong> in <span class="No-Break">Visual Studio.</span></p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor296"/>Writing a Custom Action</h2>
			<p>This is nice, but it’s not enough. Especially for us system programmers, several other things need to<a id="_idIndexMarker1113"/> be done during or after installation. For instance, a worker process must be registered as a Windows service to start automatically. Or let’s say we have a secret that must be encrypted before we can store it in a settings file. How would we do that? The answer is we write a <span class="No-Break">Custom Action.</span></p>
			<p><em class="italic">A Custom Action is some code in an external assembly that gets deployed with the Installer and called at the </em><span class="No-Break"><em class="italic">right time.</em></span></p>
			<p>It’s not hard to write them: it’s all done in C#. And we know <span class="No-Break">that language!</span></p>
			<p>First, let’s discuss what we want <span class="No-Break">to do.</span></p>
			<p>In the previous chapter, we discussed secrets. We discovered we can use the .NET system to generate keys to encrypt and decrypt data. That key would only work on that machine since it is tied to the installed version of Windows for that particular user. That means we must encrypt any secret in the <strong class="source-inline">appsettings</strong> file on the <span class="No-Break">target machine.</span></p>
			<p>So, suppose we deploy an unencrypted secret in a settings file. In that case, we must make sure that we encrypt the target machine <span class="No-Break">during installation.</span></p>
			<p>In my sample, I am just replacing a placeholder with a new <strong class="source-inline">GUID</strong> to show how it’s done. But the <span class="No-Break">principle stands.</span></p>
			<p>Add a new Class Library to the solution. However, there is one caveat: select the <strong class="bold">.NET Framework</strong> version of the Class Library. The MSI installer uses the “old” .NET framework, so <a id="_idIndexMarker1114"/>any add-ons must be built with <span class="No-Break">that technology.</span></p>
			<p>Add a reference to <strong class="bold">System.Configuration.Install</strong> to the class library project, as I <span class="No-Break">did here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer077">
					<img alt="Figure 13.12: Adding the System.Configuration.Install reference" src="image/B20924_14_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12: Adding the System.Configuration.Install reference</p>
			<p>Add a new item to the class library that’s of the <strong class="source-inline">Installer</strong> type. You can do that by right-clicking on the project and selecting <strong class="bold">Add new item</strong>. In the dialog, you can search for <strong class="source-inline">Installer</strong>.  Call it <strong class="source-inline">SecretsInstaller</strong>. This can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer078">
					<img alt="Figure 13.13: Adding an installer class" src="image/B20924_14_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13: Adding an installer class</p>
			<p>Change the<a id="_idIndexMarker1115"/> code so that it looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[RunInstaller(true)]
public partial class SecretsInstaller : Installer
{
     public override void Install(IDictionary stateSaver)
     {
           base.Install(stateSaver);
           var secret = Guid.NewGuid().ToString();
           var targetDir =
                 Context.Parameters["targetdir"];
           var appSettingsPath =
                 Path.Combine(targetDir, "appsettings.json");
           if (File.Exists(appSettingsPath))
           {
                 var appSettingsContent =
                       File.ReadAllText(appSettingsPath);
                 appSettingsContent =
                       appSettingsContent.Replace(
                             "SECRET_PLACEHOLDER",
                             secret);
                 File.WriteAllText(
                       appSettingsPath,
                       appSettingsContent);
           }
     }
}</pre>			<p>This code <a id="_idIndexMarker1116"/>gets called by <strong class="source-inline">Installer</strong>. Here, I found the <strong class="source-inline">appsettings.json</strong> file, loaded it in memory, found the <strong class="source-inline">SECRET_PLACEHOLDER</strong> string, and replaced it with a <strong class="source-inline">Guid</strong> value. Finally, I wrote it back to <span class="No-Break">the file.</span></p>
			<p>The interesting part is the line where I get the path to the file. I return to that one later, so keep that <span class="No-Break">in mind.</span></p>
			<p>We need to register this class with <strong class="source-inline">Installer</strong>. Add a new <strong class="source-inline">Installer</strong> class to our class library, <strong class="source-inline">ProjectInstaller</strong>, and change the constructor. This code is even simpler than the <span class="No-Break">last one:</span></p>
			<pre class="source-code">
[RunInstaller(true)]
public partial class ProjectInstaller : Installer
{
     public ProjectInstaller()
     {
           InitializeComponent();
           var secretsInstaller = new SecretsInstaller();
           Installers.Add(secretsInstaller);
     }
}</pre>			<p>In the <a id="_idIndexMarker1117"/>constructor, we create an instance of the <strong class="source-inline">SecretsInstaller</strong> class and add it to our <strong class="source-inline">Installer</strong>. This is a list of classes the install system looks at and then calls <span class="No-Break"><strong class="source-inline">Install</strong></span><span class="No-Break"> on.</span></p>
			<p>That is all the code we need to write. Let’s <span class="No-Break">use it!</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor297"/>Incorporating the custom action in the setup</h2>
			<p>Go back<a id="_idIndexMarker1118"/> to <strong class="bold">Setup program</strong>. Right-click on the project, select <strong class="bold">Add…</strong>,  then <strong class="bold">Project output</strong>. Select the primary output of the <strong class="bold">Custom Action</strong> project. This ensures our DLL is part of the files that are being installed on the <span class="No-Break">target machine.</span></p>
			<p>Right-click on <strong class="bold">Setup program</strong> again but select <strong class="bold">View</strong>, then <span class="No-Break"><strong class="bold">Custom Actions…</strong></span><span class="No-Break">.</span></p>
			<p>You should see a screen with four categories. This determines when the custom action should be called. These options are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Install</strong>: This is when all files <span class="No-Break">are installed</span></li>
				<li><strong class="bold">Commit</strong>: This is when the setup has <span class="No-Break">finalized everything</span></li>
				<li><strong class="bold">Rollback</strong>: When the setup fails, this <span class="No-Break">is called</span></li>
				<li><strong class="bold">Uninstall</strong>: When the user decides to install, these actions <span class="No-Break">are performed</span></li>
			</ul>
			<p>In our case, we need to use <strong class="bold">Install</strong>. Right-click on that and select <strong class="bold">Add Custom Action</strong>. Once again, you’ll be presented with a dialog showing the target machine’s file structure. These are all the locations where our files can end up. Since we added our project output of the custom action to the regular installation, we can find it in the <strong class="bold">Application Folder</strong> area. Select the primary output from your Custom Action and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer079">
					<img alt="Figure 13.14: Adding the Custom Action assembly" src="image/B20924_14_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14: Adding the Custom Action assembly</p>
			<p>Don’t leave the <a id="_idIndexMarker1119"/>Custom Action view yet. Click on the new item in the <strong class="bold">Install</strong> section, and look at the <strong class="bold">Properties</strong> area. Here, you can add all sorts of items, but the most important <span class="No-Break">is </span><span class="No-Break"><strong class="bold">CustomActionData</strong></span><span class="No-Break">.</span></p>
			<p>This is data from outside that gets passed as parameters to our custom action. Remember when I said I would get back to how I would get the path to the target directory? This is where I do that. Add the following line to <span class="No-Break">that property:</span></p>
			<pre class="source-code">
/targetdir="[TARGETDIR]\ "</pre>			<p>Yes. A “backslash, space, closing quote” is at the end of that line. Don’t leave those out. Trust me: I spent hours determining why my actions didn’t work. The reason: I forgot that extra slash and space. It just doesn’t work <span class="No-Break">without it.</span></p>
			<p>And that’s all there is <span class="No-Break">to it!</span></p>
			<p>You can now build and then <span class="No-Break">run </span><span class="No-Break"><strong class="bold">Install</strong></span><span class="No-Break">.</span></p>
			<p>Look up the folder where the installation took place and marvel at the changes in the <span class="No-Break">JSON file!</span></p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor298"/>Using Docker</h1>
			<p>The most <a id="_idIndexMarker1120"/>used excuse developers use when someone complains the system doesn’t work as expected is “But it works on my machine!” Of course, the only suitable response is, “We do not ship your machine; we <span class="No-Break">ship software.”</span></p>
			<p>Docker aims to be a solution to <span class="No-Break">that problem.</span></p>
			<p>Docker is a highly complex topic. If you’re unaware of what it can do, please skip this part of this chapter until you’re more familiar with it. In short, Docker can act like a complete virtual machine. This principle means you can develop on that virtual machine, test on that virtual machine, and then deploy that virtual machine. In other words, if it works on that machine, it will work everywhere. The reason it will work everywhere is that with Docker, we ship your machine. Well, the virtual one, <span class="No-Break">at least.</span></p>
			<p>Visual Studio has completely embraced Docker. The IDE comes packed with handy add-ons and wizards to help you <span class="No-Break">use Docker.</span></p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor299"/>Adding Docker support to your background worker</h2>
			<p>If you<a id="_idIndexMarker1121"/> create a new project, such as a background worker, you can choose to add Docker support. But if you already have a project, you must add support later. It’s not hard to do: just right-click on the project, select <strong class="bold">Add</strong>, and then click <strong class="bold">Docker support</strong>. You can choose between <strong class="bold">Windows</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Linux</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer080">
					<img alt="Figure 13.15: Adding Docker to an existing project" src="image/B20924_14_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15: Adding Docker to an existing project</p>
			<p class="callout-heading">Docker – using Windows or Linux?</p>
			<p class="callout">If you’ve been working with Visual Studio for some time, you will likely choose Windows over Linux. After all, you probably know that platform very well. Why should you move to Linux? However, containerization comes from the Linux world: it is baked into the core of the operating system. Linux is a far better platform for containers than Windows. If you don’t need Windows features, I suggest that you take Linux as the base container. Your apps will benefit from that if you decide to <span class="No-Break">use Docker.</span></p>
			<p>When you do this, a lot of <span class="No-Break">things happen:</span></p>
			<ul>
				<li>A new file called <strong class="source-inline">Dockerfile</strong> is added to <span class="No-Break">the project</span></li>
				<li>The <strong class="source-inline">launchSettings.json</strong> file is changed to <span class="No-Break">add Docker</span></li>
				<li>In the background, all the necessary support images <span class="No-Break">are installed</span></li>
				<li>The default start action is set to <span class="No-Break"><strong class="bold">Container</strong></span><span class="No-Break"> (Dockerfile)</span></li>
			</ul>
			<p>If you <a id="_idIndexMarker1122"/>start debugging, Visual Studio will build the Docker image with your binaries and start a container. You can add breakpoints to your code, and Visual Studio will also ensure the debugger is deployed in the container. Hence, it knows how to tunnel the debug information back and forth. The whole process is streamlined: you hardly notice you’re running on a Docker image instead of your <span class="No-Break">host machine.</span></p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor300"/>Deploying your Docker images</h2>
			<p>Once <a id="_idIndexMarker1123"/>you’ve finished working on your code base and are ready to deploy it, you must figure out where to deploy it. There are <span class="No-Break">three options:</span></p>
			<ul>
				<li>Use Docker Hub. This is the standard repository where you can store <span class="No-Break">your images.</span></li>
				<li>Use Azure/AWS/Google Cloud to store your images. These are much more secure since you control these environments. For instance, you can create a container registry in Azure and then upload your images. Everybody in your organization can then pull that image and run <span class="No-Break">it locally.</span></li>
				<li>Use your own repository. Suppose you don’t want to depend on a cloud provider but want complete control over where your images are. In that case, you can build your <span class="No-Break">own repository.</span></li>
			</ul>
			<p>The third option is the most used one for our scenarios. Of course, you can use Docker Hub or Azure. Nothing is getting in your way. It’s just that for the things we build, the third option is probably <span class="No-Break">the best.</span></p>
			<p>Building an actual<a id="_idIndexMarker1124"/> repository is hard. But the good news is that someone else has already done it. And they have put it in a Docker image. So, all we have to do is download that image and start <span class="No-Break">it up.</span></p>
			<p>But before we do that, we need to think about security. There are many ways to secure the repository, but the easiest (and least secure) way is to assign a username/password. You need some code to generate those, but don’t worry: there’s a Docker image <span class="No-Break">for that.</span></p>
			<p>First, create a folder named <strong class="source-inline">C:\Auth</strong>. Then, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker run --rm --entrypoint htpasswd httpd:2 -Bbn yourusername yourpassword &gt; C:\auth\htpasswd</pre>			<p>This command downloads the <strong class="source-inline">http:2</strong> image and runs it, gives it a username of <strong class="source-inline">yourusername</strong> and a password of <strong class="source-inline">yourpassword</strong> (I suggest that you use other values for those parameters), and stores the result in the <strong class="source-inline">htpasswd</strong> file in the <span class="No-Break"><strong class="source-inline">c:\auth</strong></span><span class="No-Break"> folder.</span></p>
			<p>Now, we can start the repository. Run the following command, all on <span class="No-Break">one line:</span></p>
			<pre class="console">
docker run -d -p 5000:5000
  --name registry
  -v c:\auth:/auth
  -e "REGISTRY_AUTH=htpasswd"
  -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"
  -e "REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd"               registry:2</pre>			<p>This command pulls the <strong class="source-inline">registry:2</strong> image from Docker Hub and starts it. It connects the internal folder, <strong class="source-inline">/auth</strong>, to our <strong class="source-inline">c:\auth</strong> directory and gives it <span class="No-Break">some parameters.</span></p>
			<p>And that’s all there is <span class="No-Break">to it.</span></p>
			<p>To use the repo, you must <span class="No-Break">log in:</span></p>
			<pre class="console">
docker login localhost:5000</pre>			<p>Now, you <a id="_idIndexMarker1125"/>can tag and push your images there. In my case, my C# worker process image from Visual Studio is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">image13workerfordocker</strong></span><span class="No-Break">.</span></p>
			<p>You can tag it by running the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker tag image13workerfordocker:dev localhost:5000/image13workerfordocker:dev</pre>			<p>Again, this is all one line. Now, I can push it to my local repository, <span class="No-Break">like this:</span></p>
			<pre class="console">
docker push localhost:5000/image13workerfordocker:dev</pre>			<p>If I want to reuse my image, I can <span class="No-Break">pull it:</span></p>
			<pre class="console">
docker pull localhost:5000/imagework13fordocker:dev</pre>			<p>I can use this repository just like I can with the ones at Docker Hub, Azure, AWS, <span class="No-Break">or Google.</span></p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor301"/>Production-ready Docker repository</h2>
			<p>What I’ve <a id="_idIndexMarker1126"/>shown you here is just to show you the uttermost beginnings. The repository isn’t secure or stable and doesn’t even survive <span class="No-Break">a reboot.</span></p>
			<p>There are several things you need to do if you want to use this in a real <span class="No-Break">production environment:</span></p>
			<ul>
				<li>Harden the security by <span class="No-Break">using TLS</span></li>
				<li>Install a volume so that you can store the images instead of using a container (hint: map a volume <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/var/lib/registry</strong></span><span class="No-Break">)</span></li>
				<li>Use actual authentication instead of the single username/password I have just <span class="No-Break">shown you</span></li>
				<li>Deploy the repository in a fail-safe environment such <span class="No-Break">as Kubernetes</span></li>
			</ul>
			<p>But even with this setup, you can have your own repository. This will ensure that if the code works on your machine, it <span class="No-Break">works everywhere!</span></p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor302"/>Next steps</h1>
			<p>In this chapter, we discussed many ways you can get your software from your machine to other machines. Some were easy, others were hard. To be honest, this chapter was more about helping you start thinking about deployment. Each topic could fill hundreds of pages. For instance, I mentioned Wix. Well, dozens of books have been written on Wix alone. We discussed CI/CD in Azure in a couple of pages. It turns out people make a complete career out of that topic. We also looked at Docker: people spend weeks, if not months, getting up to speed on <span class="No-Break">that topic.</span></p>
			<p>There are many ways you can get your code out there, and this chapter only scratched <span class="No-Break">the surface.</span></p>
			<p>I wanted to show you the most common ones that fit scenarios we will most likely run into. It is up to you to determine which is the best for your use case and then dive deeper <span class="No-Break">into it.</span></p>
			<p>But before I let you go, I need to say something about the dialog regarding Docker. The dialog asked if you wanted to use Linux or Windows. I suggest that you choose Linux as often as you can. If you think, “But I know very little about Linux,” don’t worry. The next chapter will tell you all you need to know about that operating system. So, let’s have a look, <span class="No-Break">shall we?</span></p>
		</div>
	</body></html>