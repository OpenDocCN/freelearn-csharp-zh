<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>7. Profiling and Debugging</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;7.&#160;Profiling and Debugging">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07"></a>Chapter&#160;7.&#160;Profiling and Debugging</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will cover the following recipes:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Using the Threads and Call Stack windows</li>
            <li class="listitem" style="list-style-type: disc">Using the Parallel Stacks window</li>
            <li class="listitem" style="list-style-type: disc">Watching values in a thread with Parallel Watch window</li>
            <li class="listitem" style="list-style-type: disc">Detecting deadlocks with the parallel tasks window</li>
            <li class="listitem" style="list-style-type: disc">Measuring CPU utilization with Concurrency Visualizer</li>
            <li class="listitem" style="list-style-type: disc">Using Concurrency Visualizer Threads view</li>
            <li class="listitem" style="list-style-type: disc">Using Concurrency Visualizer Cores view </li>
          </ul>
        </div>
        <div class="section" title="Introduction">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title" id="sigil_toc_id_9"><a id="ch07lvl1sec71"></a>Introduction</h1>
              </div>
            </div>
          </div>
          <p>Parallel programming can create complex problems. Maybe you didn't get the performance gain you expected from parallelizing your application. It could even be running slower that a sequential version of the same algorithm. Maybe you are getting consistently or occasionally incorrect results.</p>
          <p>The problems that can occur in a parallel program are numerous and can be hard to detect. Perhaps oversubscription is causing poor performance because of the high number of context switches. Maybe you have inadvertently created a lock convoy, which is a condition that occurs when multiple threads of equal priority contend repeatedly for the same lock, and can lead to significant lock contention and serialization of the program even though multiple threads are in use.</p>
          <p>In this chapter, we are going to take a look at the Visual Studio 2012 debugging features for multi-threaded applications, and how to use those features to solve concurrency related issues.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using the Threads and Call Stack windows">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec72"></a>Using the Threads and Call Stack windows</h1>
            </div>
          </div>
        </div>
        <p>When we want a thread-centric view of our application, the Threads window is the place to start. We can use the <a id="id512" class="indexterm"></a>Threads window to see the location of all of our threads, see the thread call stack, and more. We can use the Call Stack window to view<a id="id513" class="indexterm"></a> the stack frames of our application, or the function, or procedure calls that are currently on the stack.</p>
        <p>In this recipe, we are going to see how to use the Threads and Call Stack windows in Visual Studio 2012 to view the call stack information for the threads in our application.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec131"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>Before we<a id="id514" class="indexterm"></a> start looking at the debugging features of Visual Studio 2012, we need an application to debug. Let's create a <code class="literal">Console</code> application that spins up a few tasks so we <a id="id515" class="indexterm"></a>can take a look at their call stack information.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">LockExample</code> as the <span class="strong"><strong>Solution name.</strong></span></li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">Let's start by creating a few <code class="literal">static</code> methods on the <code class="literal">Program</code> class. Add a method named <code class="literal">Method1</code> that loops three times, creating tasks. The tasks just need to call <code class="literal">Method2</code> with an <code class="literal">integer</code> parameter.<div class="informalexample"><pre class="programlisting">static void Method1()
{
  Console.WriteLine("In Method1.");
  for (int i = 0; i &lt; 3; i++)
  {
    Task.Factory.StartNew(index =&gt; Method2((int)index), i);               
  }
}</pre>
</div></li>
              <li class="listitem">Now create a method named <code class="literal">Method2</code>. <code class="literal">Method2</code> just adds a random number to the parameter, writes the parameter to <code class="literal">Console</code>, and calls <code class="literal">Method4</code>.<div class="informalexample"><pre class="programlisting">static void Method2(int number)
{
  Random rnd = new Random();
  var sum = number + rnd.Next(1,10);
  Console.WriteLine("In Method2. Value:{0}", sum);
  Method4(sum);            
}</pre>
</div></li>
              <li class="listitem">Next create <code class="literal">Method3</code>, which just starts a third task that calls <code class="literal">Method2</code>.<div class="informalexample"><pre class="programlisting">static void Method3()
{
  Console.WriteLine("In Method3.");
  for (int i = 0; i &lt; 3; i++)
  {
    Task.Factory.StartNew(() =&gt;
    {
      Task.Factory.StartNew(index =&gt; Method2((int)index), i);
    });
    Thread.Sleep(10);
  }
  
}</pre>
</div></li>
              <li class="listitem">Lastly, <a id="id516" class="indexterm"></a>create <code class="literal">Method4</code> which contains our breakpoint.<div class="informalexample"><pre class="programlisting">static void Method4(int number)
{
  Console.WriteLine("In Method4.", number);
  Debugger.Break();
}</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method,<a id="id517" class="indexterm"></a> create a task that calls <code class="literal">Method1</code> and <code class="literal">Task</code> that calls <code class="literal">Method3</code>. Wait for the user input before exiting.<div class="informalexample"><pre class="programlisting">static void Main()
{
  var task1 = Task.Factory.StartNew(() =&gt; Method1());
  var task2 = Task.Factory.StartNew(() =&gt; Method3());
  Console.ReadLine();
}</pre>
</div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec132"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's start a debugging<a id="id518" class="indexterm"></a> session and take a look at the window.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</li>
              <li class="listitem">When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu of Visual Studio 2012, and click on <span class="strong"><strong>Windows</strong></span>, and click on <span class="strong"><strong>Call Stack</strong></span> to view the <span class="strong"><strong>Threads</strong></span> window.</li>
              <li class="listitem">The active thread is the thread that is currently selected in the <span class="strong"><strong>Threads</strong></span> window, indicated by the arrow icon. By default, the active thread is the one that hits the <a id="id519" class="indexterm"></a>breakpoint. Switch the active thread via the <span class="strong"><strong>Threads</strong></span> window by double-clicking on a different thread in the view.<div class="mediaobject"><img src="graphics/0225OT_07_07.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Go back to the <span class="strong"><strong>Debug</strong></span> menu, click on <span class="strong"><strong>Windows,</strong></span> and click on <span class="strong"><strong>Threads</strong></span> to show the <span class="strong"><strong>Call</strong></span> <span class="strong"><strong>Stack</strong></span> window.</li>
              <li class="listitem">The <span class="strong"><strong>Call Stack</strong></span> window indicates the top of stack of the active thread with a arrow icon. This is known as the active stack frame. When switching threads, the active stack frame changes. When execution resumes, the execution continues from the active stack frame onwards.<div class="mediaobject"><img src="graphics/0225OT_07_08.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">The current stack frame is the stack frame that drives the rest of the debugger tools and windows. Change the current stack frame by double-clicking on a different entry in the <span class="strong"><strong>Call Stack</strong></span> window. When changing the current stack frame to be something other than the active stack frame, it shows a tapered arrow.<div class="mediaobject"><img src="graphics/0225OT_07_09.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">You can <a id="id520" class="indexterm"></a>navigate to the source code for any entry in stack frame. In the <span class="strong"><strong>Call Stack</strong></span> window, right-click on the function whose source code you want to see and click on <span class="strong"><strong>Go To Source Code</strong></span> from the shortcut menu.<div class="mediaobject"><img src="graphics/0225OT_07_10.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using the Parallel Stacks window">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec73"></a>Using the Parallel Stacks window</h1>
            </div>
          </div>
        </div>
        <p>As the degree of parallelism in our applications continues to grow, we need the ability to view and navigate multiple threads<a id="id521" class="indexterm"></a> call stacks from a single view. A developer debugging a multi-threaded application needs the ability to view call stacks of multiple threads at the same time, in order to see an overall picture of the application's status.</p>
        <p>In this recipe, we will see how to use the Parallel Stacks window in Visual Studio 2012 to get a graphical view of the call stacks of all tasks in our application.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec133"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's go back to Visual Studio 2012 and take a look at the Parallel Stacks window.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">In Visual Studio<a id="id522" class="indexterm"></a> 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</li>
              <li class="listitem">When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu, click on <span class="strong"><strong>Windows</strong></span>, and click on <span class="strong"><strong>Parallel Stacks</strong></span> to display the <span class="strong"><strong>Parallel Stacks</strong></span> window.<div class="mediaobject"><img src="graphics/0225OT_07_01.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Your <span class="strong"><strong>Parallel Stacks</strong></span> view may differ slightly from the image, but you can see the call stacks of all of our tasks in a single graph view. The Parallel Stacks window in the preceding screenshot shows that we have one thread that went from an anonymous method in <code class="literal">Main</code> to <code class="literal">Method3</code>, as was called out to <span class="strong"><strong>External Code</strong></span>. One thread is in <code class="literal">Main</code>, and had gone out to the <span class="strong"><strong>External Code</strong></span>. Two other threads started, have gone through an anonymous method in <code class="literal">Method1</code>, through <code class="literal">Method2</code>, to <code class="literal">Method4</code>. This is also the active stack frame and this is the current thread, as indicated by the flag on the active thread. Visual Studio 2012 groups threads that have the same call stack information together into the same box.</li>
              <li class="listitem">Hover your mouse over the boxes and notice the tool tips that show the stack frame information, including method name and parameter values for each thread grouped into the box.<div class="mediaobject"><img src="graphics/0225OT_07_02.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">You can <a id="id523" class="indexterm"></a>double-click on any item in the stack frame of the thread to navigate to the code.<div class="mediaobject"><img src="graphics/0225OT_07_03.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">To switch to another thread, right-click on the stack frame of the desired thread and click on <span class="strong"><strong>Switch To Frame</strong></span>. Notice that highlight has changed to the selected stack frame, and there is a green arrow in the box indicating that this is the current stack frame that the debugger is focusing on, as opposed to the active stack frame which is indicated by an arrow.<div class="mediaobject"><img src="graphics/0225OT_07_04.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">You can switch back<a id="id524" class="indexterm"></a> to the active stack frame by double-clicking on it in the <span class="strong"><strong>Parallel Stacks</strong></span> windows. Notice that it has a thread icon rather than an arrow while the different stack frame has the focus of the debugger. Once you double-click on it, the arrow returns, indicating that this is the active and current thread.<div class="mediaobject"><img src="graphics/0225OT_07_05.jpg" alt="How to do it…"/></div></li>
              <li class="listitem"> You can see the <span class="strong"><strong>Threads</strong></span> that have called a method by clicking on the current stack frame, and then click on the <span class="strong"><strong>Method View</strong></span> button on the <span class="strong"><strong>Parallel Stacks</strong></span> window menu. After clicking on the button, the view will change to show which<a id="id525" class="indexterm"></a> methods the threads are calling.<div class="mediaobject"><img src="graphics/0225OT_07_06.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Watching values in a thread with Parallel Watch window">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec74"></a>Watching values in a thread with Parallel Watch window</h1>
            </div>
          </div>
        </div>
        <p>Traditionally, debuggers have been designed to work in the context of a single thread at a time. In order to work with<a id="id526" class="indexterm"></a> a different thread, you needed to first switch the thread context. Visual Studio 2012 has a feature known as Parallel Watch window that allows you to display the values of a variable or expression on multiple threads.</p>
        <p>In this recipe, we are going to see how to view the value of a variable across multiple threads using the Parallel Watch window.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec134"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's see how the Parallel <a id="id527" class="indexterm"></a>Watch window can help us view variable values across multiple threads.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</li>
              <li class="listitem">When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu of Visual Studio 2012, and click on <span class="strong"><strong>Windows</strong></span>. Then click on <span class="strong"><strong>Parallel Watch</strong></span> and <span class="strong"><strong>Parallel Watch 1</strong></span> to view the window.</li>
              <li class="listitem">By default, the <span class="strong"><strong>Parallel Watch</strong></span> window brings up all the threads currently executing in the process.<a id="id528" class="indexterm"></a> In order to add new watches, we need to click on <span class="strong"><strong>&lt;Add Watch&gt;</strong></span> column which allows us to enter an expression. Click on <span class="strong"><strong>&lt;Add Watch&gt;</strong></span> and enter numbers as the expression to watch. As soon as the watch is added we can now see the expression evaluated across all the different threads in the <span class="strong"><strong>Watch</strong></span> window.<div class="mediaobject"><img src="graphics/0225OT_07_11.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Enter a Boolean expression in the <span class="strong"><strong>Filter by Boolean Expression</strong></span> box<a id="id529" class="indexterm"></a>. The debugger evaluates the expression for each thread context. Only rows where the value is true are displayed.<div class="mediaobject"><img src="graphics/0225OT_07_12.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Detecting deadlocks with the Parallel Tasks window">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec75"></a>Detecting deadlocks with the Parallel Tasks window</h1>
            </div>
          </div>
        </div>
        <p>A very useful feature of the<a id="id530" class="indexterm"></a> Visual Studio 2012 debugger is the ability to detect deadlocks in your tasks. A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock, or by waiting for each other to finish.</p>
        <p>The easiest way<a id="id531" class="indexterm"></a> to find a deadlock in your application is to use the Parallel Tasks window of Visual Studio 2012. The Parallel Tasks window is very similar to the Threads window, except that it shows information about each <code class="literal">Task</code> or <code class="literal">task_handle</code> object instead of each thread, along with the status of the task.</p>
        <p>In this recipe, we are going to create a <code class="literal">Console</code> application that will create several tasks in a loop. The tasks will deadlock because each task will be waiting for the next task to finish.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec135"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>Before we use the Parallel Task window to see the deadlocks in our code, we need to create an application that has some deadlocks for us to see.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">DetectDeadlock</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's start by creating a variable for the number of tasks to create <code class="literal">CountDownEvent</code>, and an array of <code class="literal">tasks</code>.<div class="informalexample"><pre class="programlisting">static void Main()
{
  int taskCount = 5;
  var countdownEvent = new CountdownEvent(taskCount);
  var tasks = new Task[taskCount];
}</pre>
</div></li>
              <li class="listitem">Now, just below the previous code, let's create the blocked <code class="literal">tasks</code> in a <code class="literal">for</code> loop. Each task should wait for the next task to finish.<div class="informalexample"><pre class="programlisting">for(int i = 0; i &lt; taskCount; i++)
{
   tasks[i] = Task.Factory.StartNew((state) =&gt;
     {
       countdownEvent.Signal();
       tasks[(((int)state)+1)taskCount].Wait();
     },i);
}</pre>
</div></li>
              <li class="listitem">Next, let's create and start a couple of tasks that won't block.<div class="informalexample"><pre class="programlisting">var task1 = new Task(() =&gt;
{
  Thread.Sleep(500);                
});

var task2 = new Task(() =&gt;
{
  Thread.Sleep(500);
});

task1.Start();
task2.Start();</pre>
</div></li>
              <li class="listitem">Finish up the <code class="literal">Main</code> method by waiting for <code class="literal">CountDownEvent</code><a id="id532" class="indexterm"></a> and setting a breakpoint for <code class="literal">Debugger</code>.<div class="informalexample"><pre class="programlisting">countdownEvent.Wait();
Debugger.Break();</pre>
</div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec136"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">In Visual<a id="id533" class="indexterm"></a> Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</li>
              <li class="listitem">When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu of Visual Studio 2012 and click on <span class="strong"><strong>Windows</strong></span>. Then click on <span class="strong"><strong>Parallel Tasks</strong></span> to view the window.<div class="mediaobject"><img src="graphics/0225OT_07_13.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">In the <span class="strong"><strong>Parallel Tasks</strong></span> window<a id="id534" class="indexterm"></a> you can see all of the tasks that have been identified to be deadlocked. Hover your mouse over any of the blocked tasks to see what the task is waiting for.<div class="mediaobject"><img src="graphics/0225OT_07_14.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">For<a id="id535" class="indexterm"></a> applications with a lot of tasks, it can be useful to group the tasks by their status. Right-click anywhere in the <span class="strong"><strong>Parallel Tasks</strong></span> window, click on <span class="strong"><strong>Group By</strong></span> and then click on <span class="strong"><strong>Status</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_07_15.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Measure CPU utilization with Concurrency Visualizer">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec76"></a>Measure CPU utilization with Concurrency Visualizer</h1>
            </div>
          </div>
        </div>
        <p>Parallel applications are not only prone to common sources of inefficiency that are found in sequential applications,<a id="id536" class="indexterm"></a> but they can <a id="id537" class="indexterm"></a>also suffer from uniquely parallel performance issues such as load imbalance, excessive synchronization overhead, or thread migration.</p>
        <p>Understanding such performance issues can be a difficult and time-consuming process. However, Visual Studio 2012 includes a profiling tool, the Concurrency Visualizer, which can significantly reduce the burden of parallel performance analysis.</p>
        <p>In this recipe we will be looking at the CPU Utilization view of the Concurrency Visualizer.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec137"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>Before we look <a id="id538" class="indexterm"></a>at the Concurrency Visualizer, we need to create a <code class="literal">Console</code> application that is going to exercise the <a id="id539" class="indexterm"></a>processor on your development machine a bit. This <code class="literal">Console</code> application will be a slight variation of the <code class="literal">MultipleProducerConsumer</code> application we created in <a class="link" href="ch05.html" title="Chapter&#160;5.&#160;Concurrent Collections">Chapter 5</a>, <span class="emphasis"><em>Concurrent Collections</em></span>. The application will use a <code class="literal">for</code> loop to create some producer <code class="literal">tasks</code> that the producers use to perform a mathematic operation on some numbers, and add the results to <code class="literal">BlockingCollection</code>. <code class="literal">BlockingCollection</code>, which is a class that provides blocking and bounding capabilities for thread safe collections that implement <code class="literal">IProducerConsumerCollection&lt;T&gt;</code>. There will also be four consumer <code class="literal">tasks</code> that retrieve the results from <code class="literal">BlockingCollection</code> and write them to <code class="literal">Console</code>.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">MultipleProducerConsumer</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">Let's add a <code class="literal">static</code> method to the <code class="literal">Program</code> class which the producer tasks will call to perform the calculation.<div class="informalexample"><pre class="programlisting">private static double CalcSumRoot(int root)
{
  double result = 0;
  for (int i = 1; i &lt; 10000000; i++)
  {
    result += Math.Exp(Math.Log(i) / root);
  }
  return result;
}</pre>
</div></li>
              <li class="listitem">Now, just below the previous method, let's create another <code class="literal">static</code> method that consumer <code class="literal">tasks</code> will use to write the results to <code class="literal">Console</code>.<div class="informalexample"><pre class="programlisting">private static void DisplayResults(BlockingCollection&lt;double&gt; results)
{
  foreach (var item in results.GetConsumingEnumerable())
  {
    Console.Write("\nConsuming item: {0}", item);
  }
}</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method, let's start by creating <code class="literal">BlockingCollection</code>, to be the buffer between<a id="id540" class="indexterm"></a> the producers and consumers, list of tasks, and the definition for four consumer <code class="literal">tasks</code>.<div class="informalexample"><pre class="programlisting">var results = new BlockingCollection&lt;double&gt;();
var tasks = new List&lt;Task&gt;();
var consume1 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume2 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume3 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume4 = Task.Factory.StartNew(() =&gt; DisplayResults(results));</pre>
</div></li>
              <li class="listitem">Now let's<a id="id541" class="indexterm"></a> create a <code class="literal">for</code> loop that spins up some producer <code class="literal">tasks</code>, performs the calculations, and adds the results to <code class="literal">BlockingCollection</code>.<div class="informalexample"><pre class="programlisting">for (int item = 1; item &lt; 100; item++)
{
  var value = item;
  var compute = Task.Factory.StartNew(() =&gt;
  {
    var calcResult = CalcSumRoot(value);
    Console.Write("\nProducing item: {0}", calcResult);
    results.TryAdd(calcResult);
  });
  tasks.Add(compute);
}</pre>
</div></li>
              <li class="listitem">Finally, let's create a continuation that calls <code class="literal">CompleteAdding</code> on <code class="literal">BlockingCollection</code> when all producer <code class="literal">tasks</code> finish. Wait for the user input before exiting.<div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(), result =&gt;
{
 results.CompleteAdding();
 Console.Write("\nCompleted adding.");
});

Console.ReadLine();</pre>
</div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec138"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how we<a id="id542" class="indexterm"></a> can use Concurrency<a id="id543" class="indexterm"></a> Visualizer to report on the performance and efficiency of parallel code.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">On Visual Studio 2012 menu, click on <span class="strong"><strong>Analyze</strong></span>, and then click on <span class="strong"><strong>Concurrency Visualizer</strong></span>, and <span class="strong"><strong>Start with Current Project</strong></span>. You will see the application running while Visual Studio 2012 collects data and builds a report in the background.</li>
              <li class="listitem">When the application finishes running, close the application. Visual Studio 2012 will then finalize and open the performance report.<div class="mediaobject"><img src="graphics/0225OT_07_16.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Once the report is completed and loaded, you will see the <span class="strong"><strong>Utilization</strong></span> view of the Concurrency Visualizer. The X axis shows the <span class="strong"><strong>Elapsed Time</strong></span> since the trace started. The Y axis shows the number of logical processor cores in your system. The green area shows the <span class="strong"><strong>Number of Logical Cores</strong></span> that the application is using at any given point in the analysis run. The rest of the cores are either idle, or are being used by <span class="strong"><strong>Other Processes</strong></span> which are shown by the gray lines coming from the top of the graph. There is a <span class="strong"><strong>Zoom</strong></span> slider<a id="id544" class="indexterm"></a> at the top which can be used to narrow the time scale of the graph.<div class="mediaobject"><img src="graphics/0225OT_07_17.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">When tuning your parallel application, this view allows you to confirm the degree of parallelism. You can get hints of common parallel performance problems<a id="id545" class="indexterm"></a> by reviewing the graph. Load imbalances among the processor's cores appear as stair-step <a id="id546" class="indexterm"></a>patterns in the graph. Contention for synchronization objects appear on the graph, such as serial execution when parallel is expected.</li>
            </ol>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using Concurrency Visualizer Threads view">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec77"></a>Using Concurrency Visualizer Threads view</h1>
            </div>
          </div>
        </div>
        <p>Threads view is probably<a id="id547" class="indexterm"></a> the most useful and<a id="id548" class="indexterm"></a> frequently used view in the Concurrency Visualizer. By using this view, you can identify whether the threads are executing or blocking because of synchronization or some other reason. Threads view assigns a category to each context switch when a thread has stopped executing.</p>
        <p>In this recipe, we are going to use the Concurrency Visualizer to show all of the context switch events for each application thread.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec139"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>For this recipe, we <a id="id549" class="indexterm"></a>will use the same sample application as in the previous recipe. If you have closed the <code class="literal">MultipleProducerConsumer</code> solution, please reopen it, and go to the Concurrency Visualizer through the Visual Studio 2012 menu, and click on <span class="strong"><strong>Analyze</strong></span>. Then, click on <span class="strong"><strong>Concurrency Visualizer</strong></span>, and <span class="strong"><strong>Open Trace. </strong></span>Alternately, you can rerun the Concurrency Visualizers as in the previous recipe.</p>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec140"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's take a look at what<a id="id550" class="indexterm"></a> we can do with the Concurrency Visualizer Threads view.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Open the <span class="strong"><strong>Concurrency Visualizer</strong></span> for the <span class="strong"><strong>MultipleProducerConsumer</strong></span> solution and click on the <span class="strong"><strong>Threads</strong></span> view.<div class="mediaobject"><img src="graphics/0225OT_07_18.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">When the <span class="strong"><strong>Threads</strong></span> view opens, you will notice that the X axis is again a <span class="strong"><strong>Timeline</strong></span>. However, the Y axis is divided into horizontal channels. If the physical disks on your machine have any activity during the running of the application (which in this case they don't), the top channels will depict your physical disks. In our case, the channels are all threads in our application. You will see the <code class="literal">Main</code> thread, a debugger helper thread, and all of your worker threads. Below the list of <span class="strong"><strong>Threads</strong></span>, you will see the <span class="strong"><strong>Execution Categories</strong></span> that are assigned by Concurrency Visualizer. In the following screenshot, you can see that the application spent <span class="strong"><strong>16%</strong></span> of the <span class="strong"><strong>Timeline</strong></span> in <span class="strong"><strong>Execution</strong></span> and <span class="strong"><strong>71%</strong></span> of the <span class="strong"><strong>Timeline</strong></span> in <span class="strong"><strong>Synchronization</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_07_19.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Click on one of the CLR worker threads in the top channel. The <span class="strong"><strong>Timeline</strong></span> next to the channel <a id="id551" class="indexterm"></a>for the <span class="strong"><strong>CLR Worker Thread</strong></span> will be divided into the <span class="strong"><strong>Time slices</strong></span> for the thread. Click on the <span class="strong"><strong>Current</strong></span> tab in the <span class="strong"><strong>Profile Report</strong></span> tab. You will see the call stack for the thread at the time of the context switch, the reason for the context switch, and <span class="strong"><strong>Category</strong></span> assigned by the report. You can see on the <span class="strong"><strong>Current</strong></span> tab that this thread was context switched because it arrived at a <span class="strong"><strong>Monitor.Wait</strong></span> call.<div class="mediaobject"><img src="graphics/0225OT_07_20.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">One of the most valuable features of the <span class="strong"><strong>Threads</strong></span> view is the ability to determine thread<a id="id552" class="indexterm"></a> dependencies. Select a synchronization segment for a worker thread (a pink segment). On the <span class="strong"><strong>Current</strong></span> tab you will see the thread that unblocked the current thread. Click on the <span class="strong"><strong>Unblocking Stack</strong></span> tab<a id="id553" class="indexterm"></a> and you will see the call stack of the thread that unblocked the current thread.<div class="mediaobject"><img src="graphics/0225OT_07_21.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using Concurrency Visualizer Cores view">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec78"></a>Using Concurrency Visualizer Cores view </h1>
            </div>
          </div>
        </div>
        <p>Frequent context switching can seriously degrade application performance, especially when threads migrate across cores when they resume execution. The reason for this performance impact is that running threads load instructions and data they need into the cache hierarchy, and when<a id="id554" class="indexterm"></a> a thread resumes execution on a different core, there can be latency while working data is reloaded from memory or other caches.</p>
        <p>The Cores view<a id="id555" class="indexterm"></a> of the Concurrency Visualizer is a tool that aids in identifying excessive context switches. In this recipe, we will return to the <code class="literal">MultipleProducerConsumer</code> solution to see how we can examine the context switching that occurs in the application.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec141"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>For this recipe, we will<a id="id556" class="indexterm"></a> use the same sample application as in the previous recipe. If you have closed the <code class="literal">MultipleProducerConsumer</code> solution, please reopen it and go to the Concurrency Visualizer through the Visual Studio 2012 menu. Click on <span class="strong"><strong>Analyze</strong></span>, and then click on <span class="strong"><strong>Concurrency Visualizer</strong></span>, and <span class="strong"><strong>Open Trace</strong></span>. Alternately, you can rerun the Concurrency Visualizers as in the previous recipe.</p>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch07lvl2sec142"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Open the Concurrency Visualizer for the <code class="literal">MultipleProducerConsumer</code> solution and click on the <span class="strong"><strong>Cores</strong></span> view.<div class="mediaobject"><img src="graphics/0225OT_07_22.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Like the other views, the <span class="strong"><strong>Cores</strong></span> view<a id="id557" class="indexterm"></a> displays the timeline on the X axis. The logical cores of the system are shown on the Y axis. Each thread in the application is shown in a different color, and thread execution segments are displayed on the core channels.<div class="mediaobject"><img src="graphics/0225OT_07_23.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">The statistics shown in the <span class="strong"><strong>Cores</strong></span> view help the developer to identify <span class="strong"><strong>Threads</strong></span> that have excessive context switches and incur core migrations. The list of threads<a id="id558" class="indexterm"></a> at the bottom of the <span class="strong"><strong>Cores</strong></span> view is sorted by the number of <span class="strong"><strong>Cross-Core Context Switches</strong></span>. Click on the thread with the highest number of core switches (the top thread in the list). Notice how the thread execution is spread across the available <span class="strong"><strong>Cores</strong></span> in your system.<div class="mediaobject"><img src="graphics/0225OT_07_24.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
      </div>
    </div>
</body>
</html>