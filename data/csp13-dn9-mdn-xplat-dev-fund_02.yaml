- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Speaking C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C#
- en: This chapter is all about the basics of the C# programming language. Over the
    course of this chapter, you’ll learn how to write statements using the grammar
    of C#, as well as be introduced to some of the common vocabulary words that you
    will use every day. In addition to this, by the end of the chapter, you’ll feel
    confident in knowing how to temporarily store and work with information in your
    computer’s memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍 C# 编程语言的基础知识。在本章中，您将学习如何使用 C# 的语法编写语句，以及介绍一些您将每天使用的常用词汇。此外，到本章结束时，您将自信地了解如何在计算机内存中临时存储和处理信息。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introducing the C# language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 C# 语言
- en: Discovering your C# compiler version
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找你的 C# 编译器版本
- en: Understanding C# grammar and vocabulary
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 C# 语法和词汇
- en: Working with variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Exploring more about console apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索更多关于控制台应用程序的内容
- en: Introducing the C# language
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 C# 语言
- en: This part of the book is about the C# language—the grammar and vocabulary that
    you will use every day to write the source code for your applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本部分是关于 C# 语言——您将每天使用它来编写应用程序源代码的语法和词汇。
- en: Programming languages have many similarities to human languages, except that
    in programming languages, you can make up your own words, just like Dr. Seuss!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言与人类语言有许多相似之处，只是在编程语言中，您可以自己创造词汇，就像苏斯博士一样！
- en: 'In a book written by Dr. Seuss in 1950, *If I Ran the Zoo*, he states this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在苏斯博士于 1950 年所著的《如果我管理动物园》一书中，他这样说道：
- en: “And then, just to show them, I’ll sail to Ka-Troo And Bring Back an It-Kutch,
    a Preep, and a Proo, A Nerkle, a Nerd, and a Seersucker, too!”
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “然后，为了向他们展示，我将航行到 Ka-Troo 并带回一个 It-Kutch，一个 Preep，一个 Proo，一个 Nerkle，一个 Nerd，还有一个
    Seersucker！”
- en: C# language versions and features
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 语言版本和特性
- en: This part of the book covers the C# programming language and is written primarily
    for beginners, so it covers the fundamental topics that all developers need to
    know, including declaring variables, storing data, and how to define your own
    custom data types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本部分涵盖了 C# 编程语言，主要面向初学者，因此涵盖了所有开发者都需要了解的基本主题，包括声明变量、存储数据和如何定义您自己的自定义数据类型。
- en: 'This book covers features of the C# language from version 1 up to the latest
    version, C# 13\. You can read a summary of what’s new in C# 13 at the following
    link:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了从版本 1 到最新版本 C# 13 的 C# 语言特性。您可以在以下链接中阅读 C# 13 的新特性总结：
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13)'
- en: If you already have some familiarity with older versions of C# and are excited
    to find out about the new features in the most recent versions of C#, I have made
    it easier for you to jump around by listing language versions and their important
    new features below, along with the chapter number and topic title where you can
    learn about them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经对较老的 C# 版本有所了解，并且对最新版本的新特性感到兴奋，我为您列出以下语言版本及其重要新特性，包括您可以在其中了解它们的章节编号和主题标题，以便更容易地跳转：
- en: 'You can read this information in the GitHub repository at the following link:
    [https://github.com/markjprice/cs13net9/blob/main/docs/ch02-features.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch02-features.md).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接的 GitHub 仓库中阅读此信息：[https://github.com/markjprice/cs13net9/blob/main/docs/ch02-features.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch02-features.md)。
- en: Understanding C# standards
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 C# 标准
- en: 'Over the years, Microsoft has submitted a few versions of C# to ECMA standards
    bodies. Microsoft made C# open source in 2014\. You can read the latest C# standard
    document at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/specification/](https://learn.microsoft.com/en-us/dotnet/csharp/specification/).
    More practically useful than the ECMA standards are the public GitHub repositories
    for making the work on C# and related technologies as open as possible, as shown
    in *Table 2.1*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，微软向 ECMA 标准机构提交了几种 C# 版本。微软在 2014 年将 C# 开源。您可以在以下链接中阅读最新的 C# 标准文档：[https://learn.microsoft.com/en-us/dotnet/csharp/specification/](https://learn.microsoft.com/en-us/dotnet/csharp/specification/)。比
    ECMA 标准更有实用价值的是公开的 GitHub 仓库，它使 C# 和相关技术的开发尽可能开放，如*表 2.1*所示：
- en: '| **Description** | **Link** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **链接** |'
- en: '| C# language design | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| C# 语言设计 | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
- en: '| Compiler implementation | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 编译器实现 | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
- en: '| Standard to describe the language | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 标准来描述语言 | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
- en: 'Table 2.1: Public GitHub repositories for C#'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：C# 的公共 GitHub 仓库
- en: Discovering your C# compiler version
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现您的 C# 编译器版本
- en: 'The .NET language compiler for C# and Visual Basic, also known as **Roslyn**,
    along with a separate compiler for F#, is distributed as part of the .NET SDK.
    To use a specific version of C#, you must have at least that version of the .NET
    SDK installed, as shown in *Table 2.2*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 语言编译器用于 C# 和 Visual Basic，也称为 **Roslyn**，以及用于 F# 的单独编译器，作为 .NET SDK 的一部分进行分发。要使用特定的
    C# 版本，您必须至少安装该版本的 .NET SDK，如表 2.2 所示：
- en: '| **.NET SDK** | **Roslyn compiler** | **Default C# language** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **.NET SDK** | **Roslyn 编译器** | **默认 C# 语言** |'
- en: '| 1.0.4 | 2.0–2.2 | 7.0 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1.0.4 | 2.0–2.2 | 7.0 |'
- en: '| 1.1.4 | 2.3–2.4 | 7.1 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 1.1.4 | 2.3–2.4 | 7.1 |'
- en: '| 2.1.2 | 2.6–2.7 | 7.2 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 2.1.2 | 2.6–2.7 | 7.2 |'
- en: '| 2.1.200 | 2.8–2.10 | 7.3 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 2.1.200 | 2.8–2.10 | 7.3 |'
- en: '| 3.0 | 3.0–3.4 | 8.0 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 3.0 | 3.0–3.4 | 8.0 |'
- en: '| 5.0 | 3.8 | 9.0 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | 3.8 | 9.0 |'
- en: '| 6.0 | 4.0 | 10.0 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | 4.0 | 10.0 |'
- en: '| 7.0 | 4.4 | 11.0 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 7.0 | 4.4 | 11.0 |'
- en: '| 8.0 | 4.8 | 12.0 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 8.0 | 4.8 | 12.0 |'
- en: '| 9.0 | 4.12 | 13.0 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 9.0 | 4.12 | 13.0 |'
- en: 'Table 2.2: .NET SDK versions and their C# compiler versions'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2：.NET SDK 版本及其 C# 编译器版本
- en: 'When you create class libraries, you can choose to target .NET Standard as
    well as versions of modern .NET. They have default C# language versions, as shown
    in *Table 2.3*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建类库时，可以选择针对 .NET 标准以及现代 .NET 的版本。它们具有默认的 C# 语言版本，如表 2.3 所示：
- en: '| **.NET Standard** | **C#** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **.NET Standard** | **C#** |'
- en: '| 2.0 | 7.3 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 | 7.3 |'
- en: '| 2.1 | 8.0 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 | 8.0 |'
- en: 'Table 2.3: .NET Standard versions and their default C# compiler versions'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3：.NET 标准版本及其默认 C# 编译器版本
- en: Although you must have a minimum version of the .NET SDK installed to have access
    to a specific compiler version, the projects that you create can target older
    versions of .NET and still use a modern compiler version. For example, if you
    have the .NET 9 SDK or later installed, then you can use C# 13 language features
    in a console app that targets .NET 8.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您必须安装 .NET SDK 的最低版本才能访问特定的编译器版本，但您创建的项目可以针对较旧的 .NET 版本，同时仍然使用现代编译器版本。例如，如果您安装了
    .NET 9 SDK 或更高版本，那么您可以在针对 .NET 8 的控制台应用程序中使用 C# 13 语言功能。
- en: How to output the SDK version
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何输出 SDK 版本
- en: 'Let’s see what .NET SDK and C# language compiler versions you have available:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您可用的 .NET SDK 和 C# 语言编译器版本：
- en: On Windows, start **Windows Terminal** or **Command Prompt**. On macOS, start
    **Terminal**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上，启动 **Windows Terminal** 或 **命令提示符**。在 macOS 上，启动 **终端**。
- en: 'To determine which version of the .NET SDK you have available, enter the following
    command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定您可用的 .NET SDK 版本，请输入以下命令：
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that the version at the time of publishing is 9.0.100, indicating that
    it is the initial version of the SDK without any bug fixes or new features yet,
    as shown in the following output:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，发布时的版本是 9.0.100，这表明它是 SDK 的初始版本，尚未修复任何错误或添加新功能，如下面的输出所示：
- en: '[PRE1]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Enabling a specific language version compiler
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用特定语言的版本编译器
- en: Developer tools like Visual Studio and the `dotnet` command-line interface assume
    that you want to use the latest major version of a C# language compiler by default.
    Before C# 8 was released, C# 7 was the latest major version and was used by default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 开发工具如 Visual Studio 和 `dotnet` 命令行界面默认假设您想要使用 C# 语言编译器的最新主要版本。在 C# 8 发布之前，C#
    7 是最新的主要版本，并且默认使用。
- en: 'To use the improvements in a C# point release like 7.1, 7.2, or 7.3, you had
    to add a `<LangVersion>` configuration element to the project file, as shown in
    the following markup:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 C# 点发布版（如 7.1、7.2 或 7.3）的改进，您必须在项目文件中添加 `<LangVersion>` 配置元素，如下面的标记所示：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the release of C# 13 with .NET 9, if Microsoft releases a C# 13.1 compiler
    and you want to use its new language features, then you will have to add a configuration
    element to your project file, as shown in the following markup:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 13 与 .NET 9 一起发布后，如果微软发布了 C# 13.1 编译器，并且您想使用其新的语言功能，那么您将不得不在项目文件中添加一个配置元素，如下面的标记所示：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Potential values for the `<LangVersion>` are shown in *Table 2.4*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`<LangVersion>` 的潜在值如表 2.4 所示：'
- en: '| **<LangVersion>** | **Description** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **<LangVersion>** | **描述** |'
- en: '| `7`, `7.1`, `7.2`, `7.3`, `8`, `9`, `10`, `11`, `12`, `13` | Entering a specific
    version number will use that compiler if it has been installed. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `7`, `7.1`, `7.2`, `7.3`, `8`, `9`, `10`, `11`, `12`, `13` | 输入特定版本号将使用已安装的该编译器。
    |'
- en: '| `latestmajor` | Uses the highest major number, for example, 7.0 in August
    2019, 8 in October 2019, 9 in November 2020, 10 in November 2021, 11 in November
    2022, 12 in November 2023, and 13 in November 2024. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `latestmajor` | 使用最高主版本号，例如，2019年8月是7.0，2019年10月是8，2020年11月是9，2021年11月是10，2022年11月是11，2023年11月是12，2024年11月是13。
    |'
- en: '| `latest` | Uses the highest major and highest minor number, for example,
    7.2 in 2017, 7.3 in 2018, 8 in 2019, and perhaps 13.1 in the first half of 2025.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `latest` | 使用最高主版本和最高次版本号，例如，2017年是7.2，2018年是7.3，2019年是8，也许2025年上半年是13.1。
    |'
- en: '| `preview` | Uses the highest available preview version, for example, 14 in
    mid-July 2025 with .NET 10 Preview 6 installed. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `preview` | 使用可用的最高预览版本，例如，在2025年7月中旬，当安装.NET 10预览版6时，版本号为14。 |'
- en: 'Table 2.4: LangVersion settings for a project file'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4：项目文件中的LangVersion设置
- en: Using preview C# compiler versions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预览版C#编译器版本
- en: 'In February 2025, Microsoft is likely to release the first public preview of
    .NET 10 with the C# 14 compiler. You will be able to install its SDK from the
    following link:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 2025年2月，微软可能会发布带有C# 14编译器的.NET 10的第一个公共预览版。您可以从以下链接安装其SDK：
- en: '[https://dotnet.microsoft.com/en-us/download/dotnet/10.0](https://dotnet.microsoft.com/en-us/download/dotnet/10.0)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dotnet.microsoft.com/en-us/download/dotnet/10.0](https://dotnet.microsoft.com/en-us/download/dotnet/10.0)'
- en: '**Warning!** The link will give a `404 Missing resource` error until February
    2025, so do not bother using it until then!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 该链接将直到2025年2月出现`404 缺少资源`错误，所以在此期间请不要使用它！'
- en: After you’ve installed a .NET 10 SDK preview, you will be able to use it to
    create new projects and explore the new language features in C# 14.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装.NET 10 SDK预览版后，您将能够使用它来创建新项目并探索C# 14中的新语言功能。
- en: 'After creating a new project, you must edit the `.csproj` file and add the
    `<LangVersion>` element set to `preview` to use the preview C# 14 compiler, as
    shown highlighted in the following markup:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新项目后，您必须编辑`.csproj`文件并添加一个设置为`preview`的`<LangVersion>`元素，以使用预览版C# 14编译器，如下所示：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Good Practice**: You should only set `<LangVersion>` to `preview` for exploration,
    not production projects, because it is not supported by Microsoft and it is more
    likely to have bugs. Microsoft makes previews available because they want to hear
    feedback from developers like you. In this way, you can be a part of C#’s development
    and improvement.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您应该只为探索而将`<LangVersion>`设置为`preview`，而不是用于生产项目，因为它不受微软支持，并且可能存在更多错误。微软提供预览版本是因为他们想听取像您这样的开发者的反馈。这样，您就可以成为C#开发和改进的一部分。'
- en: Switching the C# compiler for .NET 9 to a future version
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将.NET 9的C#编译器切换到未来版本
- en: .NET 9 comes with the C# 13 compiler but that does not mean that you are stuck
    with the C# 13 compiler. Once the .NET 10 SDK is made generally available in November
    2025, you will be able to get the best of both worlds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9附带C# 13编译器，但这并不意味着您必须使用C# 13编译器。一旦.NET 10 SDK在2025年11月普遍可用，您将能够获得两者的最佳结合。
- en: 'You can use the .NET 10 SDK and its C# 14 compiler while your projects continue
    to target .NET 9\. To do so, set the target framework to `net9.0` and add a `<LangVersion>`
    element set to `14`, as shown highlighted in the following markup:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目继续针对.NET 9的情况下使用.NET 10 SDK及其C# 14编译器。为此，将目标框架设置为`net9.0`并添加一个设置为`14`的`<LangVersion>`元素，如下所示：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding project targets `net9.0`, so it is supported until May 2026 when
    run on a monthly patched version of the .NET 9 runtime. If the preceding project
    is built using .NET 10 SDK, then it can have the `<LangVersion>` set to `14`,
    meaning C# 14.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个项目针对`net9.0`，因此在运行在.NET 9运行时每月修补版本上时，它将得到支持，直到2026年5月。如果前一个项目使用.NET 10 SDK构建，则可以将`<LangVersion>`设置为`14`，这意味着C#
    14。
- en: If you target `net10.0`, which new projects will by default if you have installed
    the .NET 10 SDK, then the default language will be C# 14 so it would not need
    to be explicitly set.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您针对`net10.0`，并且已安装.NET 10 SDK，那么新项目将默认使用C# 14，因此不需要显式设置。  '
- en: 'In February 2026, Microsoft is likely to release the first preview of .NET
    11, and in November 2026, it will likely release .NET 11 for general availability
    in production. You will be able to install its SDK from the following link and
    explore C# 15 in the same way as described above for C# 14 with .NET 10:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在2026年2月，微软可能会发布.NET 11的第一个预览版，并在2026年11月，它可能会发布.NET 11以供生产环境通用。您可以从以下链接安装其SDK，并像上面描述的C#
    14和.NET 10一样探索C# 15：
- en: '[https://dotnet.microsoft.com/en-us/download/dotnet/11.0](https://dotnet.microsoft.com/en-us/download/dotnet/11.0)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dotnet.microsoft.com/en-us/download/dotnet/11.0](https://dotnet.microsoft.com/en-us/download/dotnet/11.0)'
- en: Again, the preceding link is for future use! It will give a `404 Missing resource`
    error until February 2026, so do not bother using the preceding link until then.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，前面的链接是供将来使用的！它将直到2026年2月才会显示`404资源未找到`错误，所以在此期间请不要使用前面的链接。
- en: '**Warning!** Some C# language features depend on changes in the underlying
    .NET libraries. Even if you use the latest SDK with the latest compiler, you might
    not be able to use all the new language features while targeting an older version
    of .NET. For example, C# 11 introduced the `required` keyword, but it cannot be
    used in a project that targets .NET 6 because that language feature requires new
    attributes that are only available in .NET 7\. Luckily, the compiler will warn
    you if you try to use a C# feature that is not supported. Just be prepared for
    that eventuality.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 一些C#语言特性依赖于底层.NET库的变化。即使您使用最新的SDK和最新的编译器，在针对较老的.NET版本时，您可能无法使用所有的新语言特性。例如，C#
    11引入了`required`关键字，但在针对.NET 6的项目中无法使用，因为该语言特性需要仅在.NET 7中可用的新属性。幸运的是，如果您尝试使用不支持的功能，编译器会发出警告。只需为此做好准备即可。'
- en: Showing the compiler version
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示编译器版本
- en: 'We will start by writing code that shows the compiler version:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写显示编译器版本的代码：
- en: If you’ve completed *Chapter 1*, *Hello, C#! Welcome, .NET!*, then you will
    already have a `cs13net9` folder. If not, then you’ll need to create it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经完成了*第一章*，*你好，C#! 欢迎使用.NET!*，那么您将已经有一个`cs13net9`文件夹。如果没有，那么您需要创建它。
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新项目，如下列所示：
- en: 'Project template: **Console App [C#]** / `console`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序 [C#]** / `console`
- en: 'Project file and folder: `Vocabulary`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Vocabulary`
- en: 'Solution file and folder: `Chapter02`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter02`
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除'
- en: '**Enable native AOT publish**: Cleared'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生AOT发布**：已清除'
- en: '**Good Practice**: If you have forgotten how, or did not complete the previous
    chapter, then step-by-step instructions for creating a solution with multiple
    projects are given in *Chapter 1*, *Hello, C#! Welcome, .NET!*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您忘记了如何操作，或者没有完成上一章，那么在*第一章*，*你好，C#! 欢迎使用.NET!*中提供了创建具有多个项目的解决方案的逐步说明。'
- en: 'In the `Vocabulary` project, in `Program.cs`, after the comment, add a statement
    to show the C# version as an error, as shown in the following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Vocabulary`项目中，在`Program.cs`中，在注释之后添加一个语句来显示C#版本作为错误，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the console app:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序：
- en: If you are using Visual Studio, then navigate to **Debug** | **Start Without
    Debugging**. When prompted to continue and run the last successful build, click
    **No**.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用Visual Studio，那么导航到**调试** | **不调试启动**。当提示继续并运行最后一个成功的构建时，点击**否**。
- en: If you are using VS Code, then in a terminal for the `Vocabulary` folder, enter
    the `dotnet run` command. Note that we are expecting a compiler error, so do not
    panic when you see it!
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用VS Code，那么在`Vocabulary`文件夹的终端中，输入`dotnet run`命令。请注意，我们预期会出现编译器错误，所以当您看到它时不要慌张！
- en: 'Note that the compiler version and the language version appear as compiler
    error message number `CS8304`, as shown in *Figure 2.1*:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，编译器版本和语言版本作为编译器错误消息编号`CS8304`出现，如图*2.1*所示：
- en: '![](img/B22322_02_01.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_01.png)'
- en: 'Figure 2.1: A compiler error that shows the C# language version'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：显示C#语言版本的编译器错误
- en: 'The error message in the VS Code **PROBLEMS** window or Visual Studio **Error
    List** window says `Compiler version: ''4.12.0...''` with language version `default
    (13.0)`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code的**问题**窗口或Visual Studio的**错误列表**窗口中的错误信息显示为`编译器版本：'4.12.0...'`，语言版本为`默认（13.0）`。
- en: 'Comment out the statement that causes the error, as shown in the following
    code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉导致错误的语句，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the compiler error messages disappear.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，编译器错误信息消失了。
- en: Understanding C# grammar and vocabulary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 C# 语法和词汇
- en: Let’s start by looking at the basics of the grammar and vocabulary of C#. Throughout
    this chapter, you will create multiple console apps, with each one showing related
    features of the C# language.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 C# 语法和词汇的基础开始。在本章中，你将创建多个控制台应用程序，每个应用程序都展示了 C# 语言的相应功能。
- en: Understanding C# grammar
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 C# 语法
- en: The grammar of C# includes statements and blocks. To document your code, you
    can use comments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的语法包括语句和代码块。要记录代码，你可以使用注释。
- en: '**Good Practice**: Comments should not be the only way that you document your
    code. Choosing sensible names for variables and functions, writing unit tests,
    and creating actual documents are other ways to document your code.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：注释不应该是记录代码的唯一方式。为变量和函数选择合理的名称、编写单元测试以及创建实际文档都是记录代码的其他方法。'
- en: Statements
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: In English, we indicate the end of a sentence with a period. A sentence can
    be composed of multiple words and phrases, with the order of words being part
    of the grammar. For example, in English, we say “the black cat.”
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们用句号 `.` 来表示句子的结束。一个句子可以由多个单词和短语组成，单词的顺序是语法的一部分。例如，在英语中，我们说“the black
    cat。”
- en: 'The adjective, *black*, comes before the noun, *cat*. However, French grammar
    has a different order; the adjective comes after the noun: “le chat noir.” What’s
    important to take away from this is that the order matters.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 形容词，*黑色*，在名词，*猫*之前。然而，法语语法有不同的顺序；形容词在名词之后：“le chat noir。”重要的是要记住，顺序很重要。
- en: C# indicates the end of a **statement** with a semicolon. A statement can be
    composed of multiple **types**, **variables**, and **expressions** made up of
    **tokens**. Each token is separated by white space or some other recognizably
    different token, like an operator, for example, `=` or `+`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C# 使用分号 `;` 来表示语句的结束。一个语句可以由多个 **类型**、**变量** 和由 **标记** 组成的 **表达式** 组成。每个标记由空白或某些其他可识别的不同标记（例如运算符）分隔，例如
    `=` 或 `+`。
- en: 'For example, in the following statement, `decimal` is a type, `totalPrice`
    is a variable, and `subtotal + salesTax` is an expression:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下语句中，`decimal` 是一种类型，`totalPrice` 是一个变量，而 `subtotal + salesTax` 是一个表达式：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The expression is made up of an operand named `subtotal`, an operator `+`, and
    another operand named `salesTax`. The order of operands and operators matters
    because the order affects the meaning and result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式由名为 `subtotal` 的操作数、运算符 `+` 和另一个名为 `salesTax` 的操作数组成。操作数和运算符的顺序很重要，因为顺序会影响意义和结果。
- en: Comments
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Comments are the primary method of documenting your code to enhance the understanding
    of how it works, for other developers to read, or for you to read even when you
    come back to it months later.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是记录你的代码以增强其他开发者或你自己在几个月后阅读时对其工作理解的主要方法。
- en: In *Chapter 4,* *Writing, Debugging, and Testing Functions*, you will learn
    about XML comments that start with three slashes, `///`, and work with a tool
    to generate web pages to document your code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章*，*编写、调试和测试函数* 中，你将学习关于以三个斜杠 `///` 开头的 XML 注释，并使用工具生成网页来记录代码。
- en: 'You can add comments to explain your code using a double slash, `//`. The compiler
    will ignore everything after the `//` until the end of the line, as shown in the
    following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用双斜杠 `//` 添加注释来解释你的代码。编译器将忽略 `//` 之后直到行尾的所有内容，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To write a multiline comment, use `/*` at the beginning and `*/` at the end
    of the comment, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要写多行注释，请在注释开头使用 `/*`，并在注释结尾使用 `*/`，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although `/* */` is mostly used for multiline comments, it is also useful for
    commenting in the middle of a statement, as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `/* */` 主要用于多行注释，但它也可以用于在语句中间注释，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Good Practice**: Well-designed code, including function signatures with well-named
    parameters and class encapsulation, can be somewhat self-documenting. When you
    find yourself putting too many comments and explanations in your code, ask yourself:
    can I rewrite, aka refactor, this code to make it more understandable without
    long comments?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：设计良好的代码，包括具有良好命名的参数的函数签名和类封装，可以具有一定的自文档性。当你发现自己需要在代码中添加太多注释和解释时，问问自己：我能否重写，即重构，这段代码，使其在没有长注释的情况下更容易理解？'
- en: 'Your code editor has commands to make it easier to add and remove comment characters,
    as shown in the following list:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码编辑器有命令可以让你更容易地添加和删除注释字符，如下面的列表所示：
- en: 'Visual Studio: Navigate to **Edit** | **Advanced** | **Comment Selection**
    or **Uncomment Selection**.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio：导航到**编辑** | **高级** | **注释选择**或**取消注释选择**。
- en: 'VS Code: Navigate to **Edit** | **Toggle Line Comment** or **Toggle Block Comment**.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code：导航到**编辑** | **切换行注释**或**切换块注释**。
- en: 'Rider: Navigate to **Code** | **Comment with Line Comment** or **Comment with
    Block Comment**.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rider：导航到**代码** | **使用行注释注释**或**使用块注释注释**。
- en: '**Good Practice**: You **comment** code by adding descriptive text above or
    after code statements. You **comment out** code by adding comment characters before
    or around statements to make them inactive. **Uncommenting** means removing the
    comment characters.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您通过在代码语句上方或之后添加描述性文本来**注释**代码。通过在语句之前或周围添加注释字符来**取消注释**代码，使其失效。**取消注释**意味着移除注释字符。'
- en: Blocks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块
- en: In English, we indicate a new paragraph by starting a new line. C# indicates
    a **block** of code with the use of curly brackets, `{ }`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们通过开始新行来表示新段落。C#使用大括号`{ }`来表示**区块**代码。
- en: Blocks start with a declaration to indicate what is being defined. For example,
    a block can define the start and end of many language constructs, including namespaces,
    classes, methods, or statements like `foreach`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 区块以声明开始，以指示正在定义的内容。例如，一个区块可以定义许多语言结构的开始和结束，包括命名空间、类、方法或如`foreach`之类的语句。
- en: 'You will learn more about namespaces, classes, and methods later in this chapter
    and subsequent chapters, but to briefly introduce some of those concepts now:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章和随后的章节中了解更多关于命名空间、类和方法的内容，但现在简要介绍一些这些概念：
- en: A **namespace** contains types like classes to group them together.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**包含类等类型，以将它们分组在一起。'
- en: A **class** contains the members of an object, including methods.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**包含对象的成员，包括方法。'
- en: A **method** contains statements that implement an action that an object can
    take.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**包含实现对象可以执行的动作的语句。'
- en: 'Code editors like Visual Studio, Rider, and VS Code provide a handy feature
    to collapse and expand blocks by toggling the arrow symbol pointing down or right
    when you move your mouse cursor over the left margin of the code, as shown in
    *Figure 2.2*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Visual Studio、Rider和VS Code这样的代码编辑器提供了一个方便的功能，通过在代码左侧边缘移动鼠标光标时切换指向下或向右的箭头符号来折叠和展开区块，如图*2.2*所示：
- en: '![](img/B22322_02_02.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_02.png)'
- en: 'Figure 2.2: Code editors with expanded and collapsed blocks'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：展开和折叠的代码编辑器
- en: Regions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区域
- en: 'You can define your own labeled regions around any statements you want and
    then most code editors will allow you to collapse and expand them in the same
    way as blocks, as shown in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何您想要的语句周围定义自己的标记区域，然后大多数代码编辑器将允许您以与区块相同的方式折叠和展开它们，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this way, regions can be treated as commented blocks that can be collapsed
    to show a summary of what the block does.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，区域可以被当作注释块处理，可以折叠以显示区块所执行的操作摘要。
- en: I will use `#region` blocks throughout the solution code in the GitHub repository,
    especially for the early chapters before we start defining functions that act
    as natural collapsible regions, but I won’t show them in the print book to save
    space. Use your own judgment to decide if you want to use regions in your own
    code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在GitHub仓库的解决方案代码中始终使用`#region`区块，尤其是在我们开始定义作为自然折叠区域的函数之前，但我不会在印刷书中展示它们以节省空间。请根据自己的判断来决定是否想在您的代码中使用区域。
- en: Examples of statements and blocks
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句和区块的示例
- en: 'In a simple console app that does not use the top-level program feature, I’ve
    added some comments to the statements and blocks, as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个不使用顶级程序功能的简单控制台应用程序中，我在语句和区块中添加了一些注释，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that C# uses a brace style where both the open and close braces are on
    their own line and are at the same indentation level, as shown in the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C#使用一种大括号样式，其中开括号和闭括号都位于自己的行上，并且处于相同的缩进级别，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Other languages like JavaScript use curly braces but format them differently.
    They put the open curly brace at the end of the declaration statement, as shown
    in the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言如JavaScript使用花括号，但格式不同。它们将开括号放在声明语句的末尾，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can use whatever style you prefer because the compiler does not care.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您喜欢的任何样式，因为编译器并不关心。
- en: Sometimes, to save vertical space in a print book, I use the JavaScript brace
    style, but mostly I stick with the C# brace style. I use two spaces instead of
    the more common four spaces for indenting because my code will be printed in a
    book and therefore has a narrow width available.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了在印刷书籍中节省垂直空间，我会使用JavaScript花括号风格，但大多数情况下我坚持使用C#花括号风格。我使用两个空格而不是更常见的四个空格进行缩进，因为我的代码将被打印在书中，因此有较窄的宽度可用。
- en: '**More Information**: The official coding style conventions can be found at
    the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：官方编码风格规范可以在以下链接中找到：[https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions).'
- en: Regardless of any official guidelines, I recommend that you conform to whatever
    standards have been adopted by your development team, unless you are a solo developer,
    in which case as long as your code compiles, you can use any conventions you like.
    Be kind to your future self, though, by being consistent one way or the other!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不论任何官方指南，我建议您遵守您开发团队已采纳的标准，除非您是独立开发者，在这种情况下，只要您的代码可以编译，您可以使用任何您喜欢的约定。但请考虑您未来的自己，保持一致性，无论哪种方式都可以！
- en: '**Good Practice**: The brace style used in the Microsoft official documentation
    is the most commonly used for C#. For example, see the `for` statement, as found
    at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在Microsoft官方文档中使用的花括号风格是C#中最常用的。例如，查看以下链接中的`for`语句：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements).'
- en: Formatting code using white space
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用空白格格式化代码
- en: White space includes the space, tab, and newline characters. You can use white
    space to format your code however you like because extra white space has no effect
    on the compiler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 空白格包括空格、制表符和换行符。您可以使用空白格以您喜欢的任何方式格式化代码，因为额外的空白格对编译器没有影响。
- en: '**Warning!** Unless a step-by-step instruction tells the reader to enter code,
    code examples are written to be read and understood, not typed into a code editor.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**除非有逐步指导读者输入代码的说明，否则代码示例是编写来阅读和理解的，而不是直接输入到代码编辑器中。'
- en: 'The following four statements are all equivalent. Since all four statements
    are equivalent, they all have the same variable name, and therefore cannot be
    all declared in the same code block, so please do not try to type this code unless
    you also change the three `sum` variable names:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四个语句都是等效的。由于所有四个语句都是等效的，它们都使用相同的变量名，因此不能在同一个代码块中声明所有这些，所以请不要尝试输入此代码，除非您也更改了三个`sum`变量名：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only white space character required in the preceding statements is one between
    `int` and `sum` to tell the compiler they are separate tokens. Any single white
    space character (for example, a space, tab, or newline) would be acceptable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，唯一必需的空白字符是在`int`和`sum`之间，以告诉编译器它们是不同的标记。任何单个空白字符（例如，空格、制表符或换行符）都是可接受的。
- en: '**More Information**: You can read the formal definition of C# white space
    at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中阅读C#空白格的正式定义：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space).'
- en: Understanding C# vocabulary
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C#词汇
- en: The C# vocabulary is made up of **keywords**, **symbol characters**, and **types**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: C#词汇由**关键字**、**符号字符**和**类型**组成。
- en: Some of the predefined, reserved keywords that you will see in this book and
    use frequently include `using`, `namespace`, `class`, `static`, `int`, `string`,
    `double`, `bool`, `if`, `switch`, `break`, `while`, `do`, `for`, `foreach`, `this`,
    and `true`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中您将看到并频繁使用的预定义保留关键字包括 `using`、`namespace`、`class`、`static`、`int`、`string`、`double`、`bool`、`if`、`switch`、`break`、`while`、`do`、`for`、`foreach`、`this`
    和 `true`。
- en: '**Warning!** The `this` keyword can be used in multiple ways, including to
    refer to the current instance of an object, to call a constructor on the current
    object instance, and to define an indexer. Examples of all three will be covered
    in *Chapter 5, Building Your Own Types with Object-Oriented Programming*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** `this` 关键字可以以多种方式使用，包括引用对象的当前实例、在当前对象实例上调用构造函数以及定义索引器。这三个示例将在 *第 5
    章，使用面向对象编程构建自己的类型* 中介绍。'
- en: Some of the symbol characters that you will see are `"`, `'`, `+`, `-`, `*`,
    `/`, `%`, `@`, and `$`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的某些符号字符包括 `"`, `'`, `+`, `-`, `*`, `/`, `%`, `@`, 和 `$`。
- en: '“Bracket” symbols include the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: “括号”符号包括以下内容：
- en: '`()` are called **parentheses**. They are used to call a function, define an
    expression or condition, and cast between types.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()` 被称为 **括号**。它们用于调用函数、定义表达式或条件，以及在不同类型之间进行转换。'
- en: '`{}` are called **braces** (aka curly brackets). They are used to define blocks
    and perform object and collection initialization.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}` 被称为 **花括号**（也称为大括号）。它们用于定义代码块和执行对象和集合的初始化。'
- en: '`[]` are called **brackets** (aka square brackets). They are used to access
    items in an array or collection, and around attributes decorating elements of
    code.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]` 被称为 **方括号**（也称为中括号）。它们用于访问数组或集合中的项目，以及围绕装饰代码元素的属性。'
- en: '`<>` are called **angle brackets**. They are used for generic types, in XML
    and HTML files, and individually as *less than* or *greater than* tokens in an
    expression.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<>` 被称为 **尖括号**。它们用于泛型类型、XML 和 HTML 文件，以及作为表达式中的 *小于* 或 *大于* 符号。'
- en: There are other contextual keywords that only have a special meaning in a specific
    context, like `and`, `or`, `not`, `record`, and `init`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他仅在特定上下文中具有特殊意义的上下文关键字，如 `and`、`or`、`not`、`record` 和 `init`。
- en: However, that still means that there are only about 100 actual C# keywords in
    the language.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然意味着语言中只有大约 100 个实际的 C# 关键字。
- en: '**Good Practice**: C# keywords use all lowercase. Although you can use all
    lowercase for your own type names, you should not. With C# 11 and later, the compiler
    will give a warning if you do, as shown in the following output: `Warning CS8981
    The type name ''person'' only contains lower-cased ascii characters. Such names
    may become reserved for the language.`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：C# 关键字使用全部小写。尽管你可以使用全部小写为自己的类型命名，但你不应这样做。从 C# 11 及以后的版本开始，编译器会发出警告，如下所示：`警告
    CS8981 类型名 ''person'' 只包含小写 ascii 字符。此类名称可能被保留为语言的一部分。`'
- en: 'If you want to use a C# keyword to name a variable, then you can do so by prefixing
    it with the `@` symbol, as shown in the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用 C# 关键字来命名一个变量，那么你可以通过在前面加上 `@` 符号来实现，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Good Practice**: Although you can use C# keywords for variable names, you
    should avoid doing this because it is poor practice. For multiple C# versions,
    Microsoft has wanted to add a new keyword, `field`, to the language, but they
    are reluctant to do so because some developers are likely to have variables named
    `field` and this would cause a breaking change to those projects.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：尽管你可以使用 C# 关键字作为变量名，但你应该避免这样做，因为这是一种不好的做法。对于多个 C# 版本，微软一直想向语言中添加一个新的关键字
    `field`，但他们不愿意这样做，因为一些开发者可能已经使用了名为 `field` 的变量，这可能会对那些项目造成破坏性更改。'
- en: Comparing programming languages to human languages
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将编程语言与人类语言进行比较
- en: The English language has more than 250,000 distinct words, so how does C# get
    away with only having about 100 keywords? Moreover, why is C# so difficult to
    learn if it has only 0.0416% of the number of words in the English language?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 英语语言有超过 250,000 个不同的单词，那么 C# 如何只拥有大约 100 个关键字就能应付自如？此外，如果 C# 只有英语单词数量的 0.0416%，那么它为什么如此难以学习？
- en: One of the key differences between a human language and a programming language
    is that developers need to be able to define the new “words” with new meanings.
    Apart from the (approximately) 100 keywords in the C# language, this book will
    teach you about some of the hundreds of thousands of “words” that other developers
    have defined, but you will also learn how to define your own “words.”
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 人类语言和编程语言之间的一个关键区别是，开发者需要能够用新的含义定义新的“单词”。除了 C# 语言中的（大约）100 个关键字之外，这本书还将教你关于其他开发者定义的数十万个“单词”，但你还将学习如何定义你自己的“单词”。
- en: 'Programmers all over the world must learn English because most programming
    languages use English words such as “if” and “break.” There are programming languages
    that use other human languages, such as Arabic, but they are rare. If you are
    interested in learning more, this YouTube video shows a demonstration of an Arabic
    programming language: [https://www.youtube.com/watch?v=EwYIZBL4sAU](https://www.youtube.com/watch?v=EwYIZBL4sAU).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 全世界的程序员都必须学习英语，因为大多数编程语言使用英语单词，例如“if”和“break”。也有一些编程语言使用其他人类语言，例如阿拉伯语，但它们很少见。如果你对了解更多感兴趣，这个
    YouTube 视频展示了阿拉伯语编程语言的演示：[https://www.youtube.com/watch?v=EwYIZBL4sAU](https://www.youtube.com/watch?v=EwYIZBL4sAU)。
- en: Changing the color scheme for C# syntax
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改 C# 语法颜色方案
- en: By default, Visual Studio and VS Code show C# keywords in blue to make them
    easier to differentiate from other code, which defaults to black. Both tools allow
    you to customize the color scheme.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Visual Studio 和 VS Code 用蓝色显示 C# 关键字，以便更容易地将它们与其他代码区分开来，其他代码默认为黑色。这两个工具都允许你自定义颜色方案。
- en: 'In Visual Studio:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中：
- en: Navigate to **Tools** | **Options**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **工具** | **选项**。
- en: In the **Options** dialog box, in the **Environment** section, select **Fonts
    and Colors**, and then select the display items that you would like to customize.
    You can also search for the section instead of browsing for it.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选项** 对话框中，在 **环境** 部分中选择 **字体和颜色**，然后选择你想要定制的显示项。你也可以通过搜索而不是浏览来查找该部分。
- en: 'In VS Code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中：
- en: Navigate to **File** | **Preferences** | **Theme** | **Color Theme**. It is
    in the **Code** menu on macOS.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **文件** | **首选项** | **主题** | **颜色主题**。在 macOS 上，它在 **代码** 菜单中。
- en: Select a color theme. For reference, I’ll use the **Light+ (default light)**
    color theme so that the screenshots look better in a printed book.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个颜色主题。为了参考，我将使用 **Light+（默认浅色）** 颜色主题，这样截图在打印的书中看起来会更好。
- en: In Rider, navigate to **File** | **Settings** | **Editor** | **Color Scheme**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rider 中，导航到 **文件** | **设置** | **编辑器** | **颜色方案**。
- en: Help for writing correct code
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写正确代码的帮助
- en: Plain text editors such as Notepad don’t help you write correct English. Likewise,
    Notepad won’t help you write the correct C# either.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本编辑器，如记事本，不能帮助你写正确的英语。同样，记事本也不能帮助你写正确的 C#。
- en: Microsoft Word can help you write English by highlighting spelling mistakes
    with red squiggles, with Word saying that “icecream” should be ice-cream or ice
    cream, and grammatical errors with blue squiggles, such as a sentence should have
    an uppercase first letter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Word 可以通过用红色波浪线突出显示拼写错误来帮助你写英语，Word 会说“icecream”应该是 ice-cream 或 ice
    cream，以及用蓝色波浪线突出显示语法错误，例如句子应该以大写字母开头。
- en: Similarly, Visual Studio and VS Code’s C# extension helps you write C# code
    by highlighting spelling mistakes, such as the method name needing to be `WriteLine`
    with an uppercase `L`, and grammatical errors, such as statements that must end
    with a semicolon.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Visual Studio 和 VS Code 的 C# 扩展程序通过突出显示拼写错误（例如方法名需要是大写的 `WriteLine`）和语法错误（例如必须以分号结束的语句）来帮助你编写
    C# 代码。
- en: The C# extension constantly watches what you type and gives you feedback by
    highlighting problems with colored squiggly lines, like that of Microsoft Word.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: C# 扩展程序会持续监视你输入的内容，并通过用彩色波浪线突出显示问题来给你反馈，就像 Microsoft Word 一样。
- en: 'Let’s see it in action:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际效果：
- en: In `Program.cs`, change the `L` in the `WriteLine` method to lowercase.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，将 `WriteLine` 方法中的 `L` 改为小写。
- en: Delete the semicolon at the end of the statement.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除语句末尾的分号。
- en: 'In VS Code, navigate to **View** | **Problems**; in Visual Studio, navigate
    to **View** | **Error List**; or in Rider, navigate to **View** | **Tool Windows**
    | **Problems**, and note that a red squiggle appears under the code mistakes and
    details are shown, as you can see in *Figure 2.3*:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，导航到 **视图** | **问题**；在 Visual Studio 中，导航到 **视图** | **错误列表**；或在 Rider
    中，导航到 **视图** | **工具窗口** | **问题**，注意代码错误下方会出现红色波浪线，并显示详细信息，如 *图 2.3* 所示：
- en: '![](img/B22322_02_03.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_03.png)'
- en: 'Figure 2.3: The Error List window showing two compile errors'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：错误列表窗口显示两个编译错误
- en: Fix the two coding errors.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复两个编码错误。
- en: Importing namespaces
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命名空间
- en: '`System` is a namespace, which is like an address for a type. To refer to someone’s
    location exactly, you might use `Oxford.HighStreet.BobSmith`, which tells us to
    look for a person named Bob Smith on the High Street in the city of Oxford.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`System` 是一个命名空间，它类似于类型的地址。为了精确地找到某人的位置，你可能使用 `Oxford.HighStreet.BobSmith`，这告诉我们去牛津市的高街寻找名叫
    Bob Smith 的人。'
- en: '`System.Console.WriteLine` tells the compiler to look for a method named `WriteLine`
    in a type named `Console` in a namespace named `System`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Console.WriteLine` 告诉编译器在名为 `Console` 的 `System` 命名空间中查找名为 `WriteLine`
    的方法。'
- en: 'To simplify our code, the **Console App** project template for every version
    of .NET before 6.0 added a statement at the top of the code file to tell the compiler
    to always look in the `System` namespace for types that haven’t been prefixed
    with their namespace, as shown in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的代码，.NET 6.0 之前每个版本的 **Console App** 项目模板在代码文件顶部添加了一个语句，告诉编译器始终在 `System`
    命名空间中查找未带命名空间前缀的类型，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We call this *importing the namespace*. The effect of importing a namespace
    is that all available types in that namespace will be available to your program
    without needing to enter the namespace prefix. All available types in that namespace
    will be seen in IntelliSense while you write code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种操作为 *导入命名空间*。导入命名空间的效果是，该命名空间中所有可用的类型都将对程序可用，而无需输入命名空间前缀。当你编写代码时，该命名空间中所有可用的类型都将显示在
    IntelliSense 中。
- en: Implicitly and globally importing namespaces
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和全局导入命名空间
- en: 'Traditionally, every `.cs` file that needs to import namespaces would have
    to start with `using` statements to import those namespaces. Namespaces like `System`
    and `System.Linq` are needed in almost all `.cs` files, so the first few lines
    of every `.cs` file often had at least a few `using` statements, as shown in the
    following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，每个需要导入命名空间的需要导入命名空间的 `.cs` 文件都必须以 `using` 语句开始，以导入这些命名空间。例如，`System` 和 `System.Linq`
    命名空间几乎在所有 `.cs` 文件中都需要，因此每个 `.cs` 文件的最初几行通常至少包含几个 `using` 语句，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When creating websites and services using ASP.NET Core, there are often dozens
    of namespaces that each file would have to import.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ASP.NET Core 创建网站和服务时，每个文件通常都需要导入数十个命名空间。
- en: C# 10 introduced a new keyword combination and .NET SDK 6 introduced a new project
    setting that work together to simplify importing common namespaces.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10 引入了一个新的关键字组合，.NET SDK 6 引入了一个新的项目设置，这两个设置协同工作以简化导入常用命名空间。
- en: 'The `global using` keyword combination means you only need to import a namespace
    in one `.cs` file and it will be available throughout all `.cs` files instead
    of having to import the namespace at the top of every file that needs it. You
    could put `global using` statements in the `Program.cs` file, but I recommend
    creating a separate file for those statements named something like `GlobalUsings.cs`
    with the contents being all your `global using` statements, as shown in the following
    code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`global using` 关键字组合意味着你只需在一个 `.cs` 文件中导入一个命名空间，它将在所有 `.cs` 文件中可用，而无需在每个需要该命名空间的文件顶部导入该命名空间。你可以在
    `Program.cs` 文件中放置 `global using` 语句，但我建议创建一个名为 `GlobalUsings.cs` 的单独文件，其中包含所有
    `global using` 语句，如下面的代码所示：'
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Good Practice**: As developers get used to this new C# feature, I expect
    one naming convention for this file to become the de facto standard. As you are
    about to see, the related .NET SDK feature uses a similar naming convention.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：随着开发人员习惯于这种新的 C# 功能，我预计这个文件的命名约定将成为事实上的标准。正如你即将看到的，相关的 .NET SDK 功能使用类似的命名约定。'
- en: 'Any projects that target .NET 6 or later, and therefore use the C# 10 or later
    compiler, generate a `<ProjectName>.GlobalUsings.g.cs` file in the `obj\Debug\net9.0`
    folder to implicitly globally import some common namespaces like `System`. The
    specific list of implicitly imported namespaces depends on which SDK you target,
    as shown in *Table 2.5*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 任何目标 .NET 6 或更高版本的项目，因此使用 C# 10 或更高版本编译器，将在 `obj\Debug\net9.0` 文件夹中生成一个 `<ProjectName>.GlobalUsings.g.cs`
    文件，以隐式全局导入一些常用命名空间，如 `System`。隐式导入的命名空间的具体列表取决于你针对哪个 SDK，如 *表 2.5* 所示：
- en: '| **SDK** | **Implicitly imported namespaces** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **SDK** | **隐式导入的命名空间** |'
- en: '| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks`
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk` | `System` `System.Collections.Generic` `System.IO` `System.Linq`
    `System.Net.Http` `System.Threading` `System.Threading.Tasks` |'
- en: '| `Microsoft.NET.Sdk.Web` | Same as `Microsoft.NET.Sdk`, plus:`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk.Web` | 同 `Microsoft.NET.Sdk`，並增加：`System.Net.Http.Json`、`Microsoft.AspNetCore.Builder`、`Microsoft.AspNetCore.Hosting`、`Microsoft.AspNetCore.Http`、`Microsoft.AspNetCore.Routing`、`Microsoft.Extensions.Configuration`、`Microsoft.Extensions.DependencyInjection`、`Microsoft.Extensions.Hosting`、`Microsoft.Extensions.Logging`
    |'
- en: '| `Microsoft.NET.Sdk.Worker` | Same as `Microsoft.NET.Sdk`, plus:`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk.Worker` | 同 `Microsoft.NET.Sdk`，並增加：`Microsoft.Extensions.Configuration`、`Microsoft.Extensions.DependencyInjection`、`Microsoft.Extensions.Hosting`、`Microsoft.Extensions.Logging`
    |'
- en: 'Table 2.5: .NET SDKs and their implicitly imported namespaces'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.5：.NET SDKs 及其隱式導入的命名空間
- en: 'Let’s see the current autogenerated implicit imports file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 讓我們看看當前的自動生成的隱式導入文件：
- en: In **Solution Explorer**, toggle on the **Show All Files** button, and note
    the compiler-generated `bin` and `obj` folders are now visible.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解決方案探索器** 中，啟用 **顯示所有文件** 按鈕，並注意編譯器生成的 `bin` 和 `obj` 文件夾現在是可見的。
- en: In the `Vocabulary` project, expand the `obj` folder, expand the `Debug` folder,
    expand the `net9.0` folder, and then open the file named `Vocabulary.GlobalUsings.g.cs`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Vocabulary` 專案中，展開 `obj` 文件夾，展開 `Debug` 文件夾，展開 `net9.0` 文件夾，然後打開名為 `Vocabulary.GlobalUsings.g.cs`
    的文件。
- en: The naming convention for this file is `<ProjectName>.GlobalUsings.g.cs`. Note
    the **g** for **generated** to differentiate it from developer-written code files.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的命名規範為 `<ProjectName>.GlobalUsings.g.cs`。注意 **g** 代表 **generated**，以與開發者編寫的代碼文件區分。
- en: 'Remember that this file is automatically created by the compiler for projects
    that target .NET 6 and later and that it imports some commonly used namespaces,
    including `System.Threading`, as shown in the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 請記住，此文件是編譯器為目標為 .NET 6 及更高版本的專案自動創建的，並導入了一些常用命名空間，包括 `System.Threading`，如下面的代碼所示：
- en: '[PRE21]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `Vocabulary.GlobalUsings.g.cs` 文件。
- en: 'In **Solution Explorer**, open the `Vocabulary.csproj` project file, and then
    add additional entries to the project file to control which namespaces are implicitly
    imported, as shown highlighted in the following markup:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解決方案探索器** 中，打開 `Vocabulary.csproj` 專案文件，然後向專案文件添加更多條目以控制哪些命名空間被隱式導入，如下面的標記中突出顯示：
- en: '[PRE22]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that `<ItemGroup>` is different from `<ImportGroup>`. Be sure to use the
    correct one! Also, note that the order of elements in a project group or item
    group does not matter. For example, `<Nullable>` can be before or after `<ImplicitUsings>`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `<ItemGroup>` 和 `<ImportGroup>` 的不同。請確保使用正確的一個！還要注意，項目組或項目組中元素的順序不重要。例如，`<Nullable>`
    可以在 `<ImplicitUsings>` 之前或之後。
- en: Save the changes to the project file.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 將更改保存到專案文件。
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net9.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展開 `obj` 文件夾，展開 `Debug` 文件夾，展開 `net9.0` 文件夾，然後打開名為 `Vocabulary.GlobalUsings.g.cs`
    的文件。
- en: 'Note that this file now imports `System.Numerics` instead of `System.Threading`,
    the `Environment` class has been imported and aliased to `Env`, and we have statically
    imported the `Console` class, as shown highlighted in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，此文件現在導入 `System.Numerics` 而不是 `System.Threading`，已導入 `Environment` 類並將其別名為
    `Env`，並靜態導入了 `Console` 類，如下面的代碼中突出顯示：
- en: '[PRE23]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Program.cs`, add a statement to output a message from the computer and
    note that because we statically imported the `Console` class, we can call its
    methods like `WriteLine` without prefixing them with `Console`, and we can reference
    the `Environment` class using its alias, `Env`, as shown in the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加一條輸出計算機信息的語句，並注意由於我們靜態導入了 `Console` 類，我們可以無預先添加 `Console`
    前綴來調用其方法，例如 `WriteLine`，並可以使用其別名 `Env` 引用 `Environment` 類，如下面的代碼所示：
- en: '[PRE24]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the project and note the message, as shown in the following output:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行專案，并注意信息，如下面的輸出所示：
- en: '[PRE25]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Your computer name will be different unless you name your computers after characters
    from Doctor Who like I do.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您的计算机名称将不同，除非您像我一樣將您的計算機命名為《神秘博士》中的角色名稱。
- en: 'You can disable the implicitly imported namespaces feature for all SDKs by
    removing the `<ImplicitUsings>` element completely from the project file, or changing
    its value to `disable`, as shown in the following markup:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从项目文件中完全删除`<ImplicitUsings>`元素或将它的值更改为`disable`来为所有SDK禁用隐式导入命名空间的功能，如下面的标记所示：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Good Practice**: You might choose to do this if you want to manually create
    a single file with all the `global using` statements instead of potentially having
    one generated automatically and others created manually. But my recommendation
    is to leave the feature enabled and modify the project file to change what is
    included in the auto-generated class file in the `obj` folder hierarchy.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果你想要手动创建一个包含所有`global using`语句的单个文件，而不是可能自动生成一个并手动创建其他文件，你可以选择这样做。但我的建议是保持该功能启用，并修改项目文件以更改`obj`文件夹层次结构中自动生成的类文件中包含的内容。'
- en: Verbs are methods
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动词是方法
- en: In English, verbs are doing or action words, like “run” and “jump.” In C#, doing
    or action words are called **methods**. There are hundreds of thousands of methods
    available to C#. In English, verbs change how they are written based on when in
    time the action happens. For example, Amir *was jumping* in the past, Beth *jumps*
    in the present, they *jumped* in the past, and Charlie *will jump* in the future.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，动词是进行或动作词，如“跑”和“跳”。在C#中，进行或动作词被称为**方法**。C#有数十万个方法可用。在英语中，动词根据动作发生的时间改变它们的书写方式。例如，Amir过去**正在跳**，Beth现在**跳**，他们过去**跳过**，Charlie将来**将跳**。
- en: 'In C#, methods such as `WriteLine` change how they are called or executed based
    on the specifics of the action. This is called overloading, which we’ll cover
    in more detail in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*.
    But for now, consider the following example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，例如`WriteLine`这样的方法会根据动作的具体情况改变它们的调用或执行方式。这被称为重载，我们将在第5章“使用面向对象编程构建自己的类型”中更详细地介绍。但就目前而言，请考虑以下示例：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When I show code snippets without numbered step-by-step instructions, I do not
    expect you to enter them as code, so they won’t execute out of context.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我展示没有编号的逐步说明的代码片段时，我不期望你将其作为代码输入，因此它们不会在没有上下文的情况下执行。
- en: A different and not quite exact analogy is that some verbs are spelled the same
    but have different meanings depending on the context, for example, you can lose
    a game, lose your place in a book, or lose your keys.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不同但并不完全精确的类比是，有些动词拼写相同，但根据上下文有不同的含义，例如，你可以输掉一场游戏，失去书中的位置，或者丢失钥匙。
- en: Nouns are types, variables, fields, and properties
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名词是类型、变量、字段和属性
- en: In English, nouns are names that refer to things. For example, Fido is the name
    of a dog. The word “dog” tells us the type of thing that Fido is, and so to order
    Fido to fetch a ball, we would use his name.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，名词是指出事物的名称。例如，Fido是一只狗的名字。“狗”这个词告诉我们Fido是什么类型的事物，因此要命令Fido去捡球，我们会使用他的名字。
- en: 'In C#, their equivalents are **types**, **variables**, **fields**, and **properties**.
    For example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，它们的对应物是**类型**、**变量**、**字段**和**属性**。例如：
- en: '`Animal` and `Car` are types; they are nouns for categorizing things.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animal`和`Car`是类型；它们是用于分类事物的名词。'
- en: '`Head` and `Engine` might be fields or properties; they are nouns that belong
    to `Animal` and `Car`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Head`和`Engine`可能是字段或属性；它们是属于`Animal`和`Car`的名词。'
- en: '`Fido` and `Bob` are variables; they are nouns for referring to a specific
    object.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fido`和`Bob`是变量；它们是用于指代特定对象的名词。'
- en: There are tens of thousands of types available to C#, though have you noticed
    how I didn’t say, “There are tens of thousands of types *in* C#”? The difference
    is subtle but important. The language of C# only has a few keywords for types,
    such as `string` and `int`, and strictly speaking, C# doesn’t define any types.
    Keywords such as `string` that look like types are **aliases**, which represent
    types provided by the platform on which C# runs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: C#有数万个类型可用，尽管你有没有注意到我没有说“在C#中有数万个类型”？这种区别很微妙但很重要。C#语言只有几个关键字用于类型，如`string`和`int`，严格来说，C#并没有定义任何类型。看起来像类型的关键字，如`string`，是**别名**，它们代表C#运行的平台提供的类型。
- en: It’s important to know that C# cannot exist alone; after all, it’s a language
    that runs on variants of .NET. In theory, someone could write a compiler for C#
    that uses a different platform, with different underlying types. In practice,
    the platform for C# is .NET, which provides tens of thousands of types to C#,
    including `System.Int32`, which is the C# keyword alias that `int` maps to, as
    well as many more complex types, such as `System.Xml.Linq.XDocument`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道C#不能独立存在；毕竟，它是一种运行在.NET变体上的语言。理论上，有人可以为C#编写一个编译器，使用不同的平台，具有不同的底层类型。在实践中，C#的平台是.NET，它为C#提供了数万个类型，包括`System.Int32`，这是`int`映射到的C#关键字别名，以及许多更复杂的类型，如`System.Xml.Linq.XDocument`。
- en: It’s worth taking note that the term **type** is often confused with **class**.
    Have you ever played the parlor game *Twenty Questions*, also known as *Animal,
    Vegetable, or Mineral*? In the game, everything can be categorized as an animal,
    vegetable, or mineral. In C#, every **type** can be categorized as a `class`,
    `struct`, `enum`, `interface`, or `delegate`. You will learn what these mean in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. As an example,
    the C# keyword `string` is a `class`, but `int` is a `struct`. So, it is best
    to use the term **type** to refer to both.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，术语**类型**经常与**类**混淆。你有没有玩过聚会游戏“二十个问题”，也称为“动物、植物或矿物”？在这个游戏中，一切都可以归类为动物、植物或矿物。在C#中，每个**类型**都可以归类为`class`、`struct`、`enum`、`interface`或`delegate`。你将在第6章“实现接口和继承类”中了解这些的含义。例如，C#关键字`string`是一个`class`，但`int`是一个`struct`。因此，最好使用术语**类型**来指代两者。
- en: Revealing the extent of the C# vocabulary
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示C#词汇的广度
- en: We know that there are more than 100 keywords in C#, but how many types are
    there? Let’s write some code to find out how many types (and their methods) are
    available to C# in our simple console app.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道C#有超过100个关键字，但有多少个类型呢？让我们编写一些代码来找出在简单的控制台应用程序中C#可以访问多少个类型（及其方法）。
- en: 'Don’t worry about exactly how this code works for now, but know that it uses
    a technique called **reflection**:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心代码的具体工作原理，但要知道它使用了一种称为**反射**的技术：
- en: Comment out all the existing statements in `Program.cs`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中注释掉所有现有的语句。
- en: 'We’ll start by importing the `System.Reflection` namespace at the top of the
    `Program.cs` file so that we can use some of the types in that namespace like
    `Assembly` and `TypeName`, as shown in the following code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在`Program.cs`文件的顶部导入`System.Reflection`命名空间，这样我们就可以使用该命名空间中的某些类型，如`Assembly`和`TypeName`，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Good Practice**: We could use the implicit imports and `global using` features
    to import this namespace for all `.cs` files in this project, but since there
    is only one file, it is better to import the namespace in the one file in which
    it is needed.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：我们可以使用隐式导入和`global using`功能将此命名空间导入到项目中所有`.cs`文件中，但由于只有一个文件，最好在需要此命名空间的文件中导入该命名空间。'
- en: 'Write statements to get the compiled console app and loop through all the types
    that it has access to, outputting the names and number of methods each has, as
    shown in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句以获取编译后的控制台应用程序，并遍历它可访问的所有类型，输出每个类型的名称和方法数量，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`N0` is uppercase `N` followed by the digit zero. It is not uppercase `N` followed
    by uppercase `O`. It means “format a number (`N`) with zero (`0`) decimal places.”'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`N0`是大写字母`N`后面跟着数字零。它不是大写字母`N`后面跟着大写字母`O`。它的意思是“用零（`0`）位小数格式化数字（`N`）。”'
- en: 'Run the project. You will see the actual number of types and methods that are
    available to you in the simplest application when running on your **operating
    system** (**OS**). The number of types and methods displayed will be different
    depending on the OS that you are using, as shown in the following output on Windows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目。当你在**操作系统**（**OS**）上运行时，你会看到最简单应用中可用的类型和方法的实际数量。显示的类型和方法数量将根据你使用的操作系统而有所不同，如下面的Windows输出所示：
- en: '[PRE30]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Why does the `System.Runtime` assembly contain zero types? This assembly is
    special because it contains only **type-forwarders** rather than actual types.
    A type-forwarder represents a type that has been implemented outside of .NET or
    for some other advanced reason.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`System.Runtime`程序集包含零个类型？这个程序集是特殊的，因为它只包含**类型前向器**而不是实际类型。类型前向器代表一个在.NET之外或由于某些其他高级原因实现的类型。
- en: 'Add statements to the top of the file (after importing the `System.Reflection`
    namespace) to declare some variables, as shown in the following code:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部（在导入 `System.Reflection` 命名空间之后）添加语句以声明一些变量，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the console app again and view the results, which should look like the
    following output:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序并查看结果，结果应该如下所示：
- en: '[PRE32]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, you have a better sense of why learning C# is a challenge – because there
    are so many types and methods to learn. Methods are only one category of a member
    that a type can have, and you and other programmers are constantly defining new
    types and members!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你更有理由理解为什么学习 C# 是一项挑战——因为有很多类型和方法需要学习。方法只是类型可以拥有的成员类别之一，你和其他程序员不断定义新的类型和成员！
- en: Example of asking ChatGPT to explain code
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：请求 ChatGPT 解释代码
- en: 'The code we wrote in the `Vocabulary` project is a good example of when you
    might want to ask ChatGPT to explain something. If you enter a prompt of “Explain
    the following code:” followed by the code, here’s what it responded with:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Vocabulary` 项目中编写的代码是当你可能想要请求 ChatGPT 解释某些内容时的一个很好的例子。如果你输入提示“解释以下代码：”然后是代码，这是它的响应：
- en: “This C# code performs an analysis of the assemblies (essentially libraries
    or modules) referenced by the current application. It tallies up the total number
    of types and methods in each referenced assembly.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: “这段 C# 代码对当前应用程序引用的程序集（本质上相当于库或模块）进行分析。它统计了每个引用程序集中的类型和方法的总数。”
- en: 'Let’s break down the code in more detail:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分解代码：
- en: '`System.Reflection` namespace is used to work with assemblies, modules, types,
    methods, and so on, at runtime.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `System.Reflection` 命名空间在运行时处理程序集、模块、类型、方法等。
- en: The `System.Data.DataSet` and `HttpClient` instances are declared but not used.
    The comment implies that these are declared to ensure their respective assemblies
    are loaded for the subsequent analysis. Creating instances of classes from certain
    assemblies can cause those assemblies to be loaded into memory.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明了 `System.Data.DataSet` 和 `HttpClient` 实例，但未使用。注释暗示这些实例是为了确保它们各自的程序集在后续分析中已加载。从某些程序集创建类的实例可能会导致这些程序集被加载到内存中。
- en: '`Assembly.GetEntryAssembly()` gets the assembly that is the entry point of
    the application.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assembly.GetEntryAssembly()` 获取应用程序的入口点程序集。'
- en: If `myApp` is null (meaning there’s no entry assembly, which should be impossible
    in a normally running .NET app), the application exits.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `myApp` 为空（表示没有入口程序集，这在正常运行的 .NET 应用程序中应该是不可行的），则应用程序退出。
- en: The `foreach` loop iterates over each assembly name in the referenced assemblies
    of the entry point assembly.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`foreach` 循环遍历入口程序集引用的程序集中的每个程序集名称。'
- en: '`Assembly.Load(name)` loads an assembly given the assembly name. This allows
    you to interact with the assembly programmatically.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assembly.Load(name)` 根据指定的程序集名称加载程序集。这允许您以编程方式与程序集交互。'
- en: A counter variable, `methodCount`, is declared and initialized to `0`. This
    is used to count the total number of methods in the assembly.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化了一个计数变量 `methodCount` 为 `0`。这用于计算程序集中方法的总数。
- en: Another nested `foreach` loop then iterates over each type in the assembly.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个嵌套的 `foreach` 循环遍历程序集中的每个类型。
- en: For each type, it gets the number of methods `(t.GetMethods().Length)` and adds
    it to the `methodCount`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每种类型，它获取方法的数量 `(t.GetMethods().Length)` 并将其添加到 `methodCount`。
- en: Finally, the number of types and their methods in the assembly are output to
    the console using `WriteLine()`. The `{0:N0}` format specifier in the string is
    a placeholder for a number (`0` refers to the argument index, `N` is for number
    format, and 0 after N specifies the number of decimal places).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `WriteLine()` 将程序集中的类型及其方法数量输出到控制台。字符串中的 `{0:N0}` 格式说明符是一个用于数字的占位符（`0`
    指的是参数索引，`N` 表示数字格式，N 后面的 0 指定小数位数）。
- en: So, in essence, this script counts how many types and methods exist in each
    assembly referenced by the application. This might be useful to understand the
    complexity or size of the dependencies the application has.”
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，这个脚本统计了应用程序引用的每个程序集中存在多少类型和方法。这可能有助于了解应用程序的依赖项的复杂度或大小。”
- en: And now back to the flesh and blood, Mark. That’s a pretty good explanation
    with no mistakes or hallucinations!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到现实世界，马克。这是一个相当不错的解释，没有错误或幻觉！
- en: '**Good Practice**: Tools like GitHub Copilot and ChatGPT are especially useful
    for programmers when they are learning new things. And a good programmer is always
    learning new things! These tools are not just for writing code for you. They can
    explain existing code written by others and even suggest improvements.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：GitHub Copilot和ChatGPT等工具对于程序员在学习新事物时特别有用。一个优秀的程序员总是在学习新事物！这些工具不仅可以帮助您编写代码，还可以解释他人编写的代码，甚至提出改进建议。'
- en: Working with variables
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与变量一起工作
- en: All applications process data. Data comes in, data is processed, and then data
    goes out.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序都处理数据。数据进来，数据处理，然后数据出去。
- en: Data usually comes into our program from files, databases, or user input, and
    it can be put temporarily into variables, which will be stored in the memory of
    the running program. When the program ends, the data in memory is lost. Data is
    usually output to files and databases, or to the screen or a printer. When using
    variables, you should think about, firstly, how much space the variable takes
    up in the memory, and, secondly, how fast it can be processed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常来自文件、数据库或用户输入，可以暂时存储在变量中，这些变量将存储在运行程序的内存中。当程序结束时，内存中的数据就会丢失。数据通常输出到文件、数据库、屏幕或打印机。使用变量时，您应该首先考虑变量在内存中占用的空间大小，其次考虑其处理速度的快慢。
- en: We control this by picking an appropriate type. You can think of simple common
    types such as `int` and `double` as being different-sized storage boxes, where
    a smaller box would take less memory but may not be as fast at being processed;
    for example, adding 16-bit numbers might not be processed as quickly as adding
    64-bit numbers on a 64-bit operating system. Some of these boxes may be stacked
    close by, and some may be thrown into a big heap further away.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择合适的数据类型来控制这个过程。您可以将简单的常见类型，如 `int` 和 `double`，视为不同大小的存储盒，较小的盒子占用较少的内存，但可能处理速度不快；例如，在64位操作系统上，添加16位数字可能不如添加64位数字处理得快。这些盒子中的一些可能堆叠得很近，而另一些可能被扔到更远的大堆里。
- en: Naming things and assigning values
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名事物和赋值
- en: 'There are naming conventions for things, and it is a good practice to follow
    them, as shown in *Table 2.6*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事物有命名约定，遵循它们是一个好习惯，如*表2.6*所示：
- en: '| **Naming convention** | **Examples** | **Used for** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **命名约定** | **示例** | **用于** |'
- en: '| Camel case | `cost`, `orderDetail`, and `dateOfBirth` | Local variables and
    private fields |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 驼峰命名法 | `cost`, `orderDetail`, 和 `dateOfBirth` | 本地变量和私有字段 |'
- en: '| Title case, aka Pascal case | `String`, `Int32`, `Cost`, `DateOfBirth`, and
    `Run` | Types, non-private fields, and other members like methods |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 标题大小写，也称为帕斯卡大小写 | `String`, `Int32`, `Cost`, `DateOfBirth`, 和 `Run` | 类型、非私有字段和其他成员，如方法
    |'
- en: 'Table 2.6: Naming conventions and what they should be used for'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.6：命名约定及其应用
- en: Some C# programmers like to prefix the names of private fields with an underscore,
    for example, `_dateOfBirth` instead of `dateOfBirth`. The naming of private members
    of all kinds is not formally defined because they will not be visible outside
    the class, so writing them either with or without an underscore prefix is valid.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C#程序员喜欢在私有字段名称前加下划线，例如，`_dateOfBirth` 而不是 `dateOfBirth`。所有类型的私有成员的命名没有正式定义，因为它们在类外是不可见的，所以无论是带下划线前缀还是不带都是有效的。
- en: '**Good Practice**: Following a consistent set of naming conventions will enable
    your code to be easily understood by other developers (and yourself in the future!).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：遵循一致的命名约定将使您的代码容易被其他开发者（以及未来的您！）理解。'
- en: 'The following code block shows an example of declaring a named local variable
    and assigning a value to it with the `=` symbol. You should note that you can
    output the name of a variable using a keyword introduced in C# 6, `nameof`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块展示了使用 `=` 符号声明一个命名本地变量并将其赋值的示例。请注意，您可以使用C# 6中引入的关键字 `nameof` 输出变量的名称：
- en: '[PRE33]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Warning!** The message in double quotes in the preceding code wraps onto
    a second line because the width of a printed page is too narrow. When entering
    a statement like this in your code editor, type it all in a single line.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**！前述代码中双引号内的消息换行是因为打印页面的宽度太窄。当在代码编辑器中输入此类语句时，请将其全部输入一行。'
- en: In C# 12 and later, `nameof` can now access instance data from a static context.
    You will learn the difference between instance and static data in *Chapter 5*,
    *Building Your Own Types with Object-Oriented Programming*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 12 及更高版本中，`nameof` 现在可以从静态上下文访问实例数据。您将在 *第五章*，*使用面向对象编程创建自己的类型* 中学习实例和静态数据之间的区别。
- en: Literal values
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面值
- en: When you assign to a variable, you often, but not always, assign a **literal**
    value. But what is a literal value? A literal is a notation that represents a
    fixed value. Data types have different notations for their literal values, and
    over the next few sections, you will see examples of using literal notation to
    assign values to variables.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向变量赋值时，您通常会，但不总是，分配一个 **字面值**。但什么是字面值？字面值是一种表示固定值的符号。数据类型有不同的符号来表示它们的字面值，在接下来的几节中，您将看到使用字面值符号将值赋给变量的示例。
- en: '**More Information**: You can read the formal definition of literals in the
    C# language specification: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#645-literals](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#645-literals).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在 C# 语言规范中阅读字面值的正式定义：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#645-literals](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#645-literals)。'
- en: Storing text
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储文本
- en: For text, a single letter, such as an `A`, is stored as a `char` type.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本，单个字母，如 `A`，存储为 `char` 类型。
- en: '**Good Practice**: Actually, it can be more complicated than that. Egyptian
    Hieroglyph A002 (U+13001) needs two `System.Char` values (known as surrogate pairs)
    to represent it: `\uD80C` and `\uDC01`. Do not always assume one `char` equals
    one letter or you could introduce hard-to-notice bugs into your code.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：实际上，这可能会更复杂。埃及象形文字 A002 (U+13001) 需要两个 `System.Char` 值（称为代理对）来表示它：`\uD80C`
    和 `\uDC01`。不要总是假设一个 `char` 等于一个字母，否则您可能会在代码中引入难以察觉的错误。'
- en: 'A `char` is assigned using single quotes around the literal value, or assigning
    the return value of a function call, as shown in the following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 的赋值使用单引号包围字面值，或分配函数调用的返回值，如下面的代码所示：'
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For text, multiple letters, such as `Bob`, are stored as a `string` type and
    are assigned using double quotes around the literal value, or by assigning the
    return value of a function call or constructor, as shown in the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本，多个字母，如 `Bob`，存储为 `string` 类型，并使用双引号包围字面值或通过分配函数调用或构造函数的返回值来赋值，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Outputting emojis
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出表情符号
- en: 'To output emojis at a command prompt on Windows, you must use Windows Terminal
    because Command Prompt does not support emojis, and set the output encoding of
    the console to use UTF-8, as shown in the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 的命令提示符中输出表情符号，您必须使用 Windows Terminal，因为命令提示符不支持表情符号，并将控制台输出编码设置为使用
    UTF-8，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Verbatim strings
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本字面值
- en: An escape character is a special character in programming and text processing
    that is used to introduce an **escape sequence**. Escape sequences allow the representation
    of characters that are difficult or impossible to include directly in a string.
    These sequences often start with a backslash, `\`, followed by one or more characters.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符是编程和文本处理中的一种特殊字符，用于引入 **转义序列**。转义序列允许表示难以或无法直接在字符串中包含的字符。这些序列通常以反斜杠 `\`
    开头，后跟一个或多个字符。
- en: 'When storing text in a `string` variable, you can include escape sequences,
    which represent special characters like tabs and newlines using a backslash, as
    shown in the following code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `string` 变量中存储文本时，您可以包含转义序列，这些序列使用反斜杠表示特殊字符，如制表符和换行符，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But what if you are storing the path to a file on Windows, and one of the folder
    names starts with a `T`, as shown in the following code?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您在 Windows 上存储文件的路径，并且其中一个文件夹名称以 `T` 开头，如下面的代码所示？
- en: '[PRE38]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The compiler will convert the `\t` into a tab character and you will get errors!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会将 `\t` 转换为制表符，你将得到错误！
- en: 'You must prefix it with the `@` symbol to use a verbatim literal `string`,
    as shown in the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用 `@` 符号作为前缀来使用文本字面值 `string`，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With C# 13 and later, you can represent the ESC character (Unicode U+001B)
    using the character literal escape sequence `\e`, as shown in the following code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 13 及更高版本中，您可以使用字符字面值转义序列 `\e` 来表示 ESC 字符（Unicode U+001B），如下面的代码所示：
- en: '[PRE40]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the past, you might have used `\u001b` or `\x1b`. However, using `\x1b` was
    not recommended because any valid hexadecimal digits following `1b` would be incorrectly
    interpreted as part of the escape sequence.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，你可能使用过 `\u001b` 或 `\x1b`。然而，使用 `\x1b` 并不推荐，因为任何在 `1b` 后面的有效十六进制数字都会被错误地解释为转义序列的一部分。
- en: Raw string literals
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串字面量
- en: Introduced in C# 11, raw string literals are convenient for entering any arbitrary
    text without needing to escape the contents. They make it easy to define literals
    containing other languages like XML, HTML, or JSON.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 11 开始引入的原始字符串字面量，方便输入任何任意文本，而无需对内容进行转义。它们使得定义包含其他语言（如 XML、HTML 或 JSON）的字面量变得容易。
- en: 'Raw string literals start and end with three or more double-quote characters,
    as shown in the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量以三个或更多双引号字符开始和结束，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Why three *or more* double-quote characters? This is for scenarios where the
    content itself needs to have three double-quote characters; you can then use four
    double-quote characters to indicate the beginning and end of the content. Where
    the content needs to have four double-quote characters, you can then use five
    double-quote characters to indicate the beginning and end of the content. And
    so on.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要三个或更多双引号字符？这是因为在内容本身需要包含三个双引号字符的情况下；这时你可以使用四个双引号字符来表示内容的开始和结束。如果内容需要包含四个双引号字符，那么你可以使用五个双引号字符来表示内容的开始和结束。依此类推。
- en: 'In the previous code, the XML is indented by 13 spaces. The compiler looks
    at the indentation of the last three or more double-quote characters, and then
    automatically removes that level of indentation from all the content inside the
    raw string literal. The results of the previous code would therefore not be indented
    as in the defining code but, instead, will be aligned with the left margin, as
    shown in the following markup:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，XML 被缩进 13 个空格。编译器查看最后三个或更多双引号字符的缩进，然后自动从原始字符串字面量内的所有内容中移除该级别的缩进。因此，之前代码的结果将不会像定义代码那样缩进，而是与左边界对齐，如下面的标记所示：
- en: '[PRE42]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the end three double-quote characters are aligned with the left margin,
    as shown in the following code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后的三个双引号字符与左边界对齐，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'then the 13-space indentation would not be removed, as shown in the following
    markup:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在下面的标记中，13个空格的缩进将不会被移除：
- en: '[PRE44]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Raw interpolated string literals
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始插值字符串字面量
- en: You can mix interpolated strings that use curly braces `{` `}` with raw string
    literals. You specify the number of braces that indicate a replaced expression
    by adding that number of dollar signs to the start of the literal. Any fewer braces
    than that are treated as raw content.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将使用花括号 `{}` 的插值字符串与原始字符串字面量混合使用。你通过在字面量开头添加相应数量的美元符号来指定表示替换表达式的花括号数量。任何少于该数量的花括号都被视为原始内容。
- en: 'For example, if we want to define some JSON, single braces will be treated
    as normal braces, but the two dollar symbols tell the compiler that any two curly
    braces indicate a replaced expression value, as shown in the following code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想定义一些 JSON，单花括号将被视为普通花括号，但两个美元符号告诉编译器任何两个花括号都表示一个替换表达式值，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The previous code would generate the following JSON document:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将生成以下 JSON 文档：
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The number of dollar symbols tells the compiler how many curly braces are needed
    to become recognized as an interpolated expression.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 美元符号的数量告诉编译器需要多少个花括号才能被识别为插值表达式。
- en: 'Note the braces `{}` around the `3`. This is intentional. In this example,
    the JSON document must generate a calculation that contains braces. To show this,
    the code uses three braces: the first open brace will output as a literal character.
    The next two braces will be interpreted as the beginning of an expression. The
    first two close braces will be interpreted as the end of an expression. The last
    close brace will be a literal character.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意围绕 `3` 的花括号 `{}`。这是故意的。在这个例子中，JSON 文档必须生成一个包含花括号的计算。为了展示这一点，代码使用了三个花括号：第一个开括号将输出为一个字面字符。接下来的两个花括号将被解释为表达式的开始。前两个闭括号将被解释为表达式的结束。最后一个闭括号将是一个字面字符。
- en: 'If the code only used two braces, then those are treated as a delimiter for
    the expression `1 + 2` and do not appear in the output:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码只使用了两个花括号，那么这些花括号被视为表达式 `1 + 2` 的分隔符，并且不会出现在输出中：
- en: '[PRE47]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now it produces the following output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它生成了以下输出：
- en: '[PRE48]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summarizing options for storing text
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结存储文本的选项
- en: 'To summarize:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：
- en: '**Literal string**: Characters enclosed in double-quote characters. They can
    use escape characters like `\t` for tab. To represent a backslash, use two: `\\`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字面字符串**：用双引号括起来的字符。它们可以使用像 `\t` 这样的转义字符。要表示反斜杠，使用两个：`\\`。'
- en: '**Raw string literal**: Characters enclosed in three or more double-quote characters.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始字符串字面量**：用三个或更多双引号括起来的字符。'
- en: '**Verbatim string**: A literal string prefixed with `@` to disable escape characters
    so that a backslash is a backslash. It also allows the `string` value to span
    multiple lines because the whitespace characters are treated as themselves instead
    of instructions to the compiler.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字面字符串**：以 `@` 为前缀的字符串，用于禁用转义字符，因此反斜杠 `\` 就是字面意义上的反斜杠。它还允许 `string` 值跨越多行，因为空白字符被视为自身，而不是传递给编译器的指令。'
- en: '**Interpolated string**: A literal string prefixed with `$` to enable embedded
    formatted variables. You will learn more about this later in this chapter.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插值字符串**：以 `$` 为前缀的字面字符串，用于启用嵌入的格式化变量。你将在本章后面了解更多关于此内容。'
- en: Storing numbers
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储数字
- en: Numbers are data that we want to perform an arithmetic calculation on, for example,
    multiplying. A telephone number is not a quantifiable number. To decide whether
    a variable should be stored as a number or not, ask yourself whether you need
    to perform arithmetic operations on the number or whether the number includes
    non-digit characters such as parentheses or hyphens to format the number, such
    as (414) 555-1234\. In this case, the “number” is a sequence of characters, so
    it should be stored as a `string`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是我们想要进行算术运算的数据，例如乘法。电话号码不是一个可量化的数字。要决定一个变量是否应该存储为数字，问问自己你是否需要对数字执行算术运算，或者数字是否包含非数字字符，如括号或破折号，用于格式化数字，例如
    (414) 555-1234。在这种情况下，“数字”是一系列字符，因此应该将其存储为 `string`。
- en: Numbers can be natural numbers, such as 42, used for counting (also called whole
    numbers); they can also be negative numbers, such as -42 (called integers); or
    they can be real numbers, such as 3.9 (with a fractional part), which are called
    single- or double-precision floating-point numbers in computing.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以是自然数，例如 42，用于计数（也称为整数）；它们也可以是负数，例如 -42（称为整数）；或者它们可以是实数，例如 3.9（有分数部分），在计算机中称为单精度或双精度浮点数。
- en: 'Let’s explore numbers:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索数字：
- en: 'Use your preferred code editor to add a new **Console App** / `console` project
    named `Numbers` to the `Chapter02` solution:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器将一个新的 **Console App** / `console` 项目命名为 `Numbers` 并添加到 `Chapter02`
    解决方案中：
- en: For Visual Studio, configure the startup project to the current selection.
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Visual Studio，将启动项目配置为当前选择。
- en: 'In `Program.cs`, delete the existing code, and then type statements to declare
    some number variables using various data types, as shown in the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有代码，然后输入语句来声明一些使用各种数据类型的数字变量，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Storing whole numbers
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储整数
- en: You might know that computers store everything as bits. The value of a bit is
    either `0` or `1`. This is called a **binary number system**. Humans use a **decimal
    number system**.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道计算机将所有内容存储为位。位的值是 `0` 或 `1`。这被称为**二进制数制**。人类使用**十进制数制**。
- en: The decimal number system, also known as Base 10, has 10 as its **base**, meaning
    there are 10 digits, from 0 to 9\. Although it is the number base most used by
    human civilizations, other number base systems are popular in science, engineering,
    and computing. The binary number system, also known as Base 2, has 2 as its base,
    meaning there are two digits, 0 and 1.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数制，也称为十进制，以 10 为其**基数**，这意味着有 10 个数字，从 0 到 9。尽管它是人类文明中最常用的数制，但在科学、工程和计算机科学中，其他数制系统也很流行。二进制数制，也称为二进制，以
    2 为其基数，这意味着有两个数字，0 和 1。
- en: 'The following image shows how computers store the decimal number 10\. Take
    note of the bits with the value 1 in the 8 and 2 columns: 8 + 2 = 10.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了计算机如何存储十进制数字 10。注意 8 和 2 列中值为 1 的位：8 + 2 = 10。
- en: '![](img/B22322_02_04.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_04.png)'
- en: 'Figure 2.4: How computers store the decimal number 10'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：计算机如何存储十进制数字 10
- en: So, `10` in decimal is `00001010` in a binary byte (8 bits).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制中的 `10` 在二进制字节（8位）中是 `00001010`。
- en: Improving legibility by using digit separators
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用数字分隔符提高可读性
- en: Two of the improvements seen in C# 7 and later are the use of the underscore
    character `_` as a digit separator and support for binary literals.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 及以后的版本中看到的两项改进是使用下划线字符 `_` 作为数字分隔符以及支持二进制字面量。
- en: You can insert underscores anywhere into the digits of a number literal, including
    decimal, binary, or hexadecimal notation, to improve legibility.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在数字字面量的数字中插入下划线，包括十进制、二进制或十六进制表示法，以提高可读性。
- en: For example, you could write the value for 1 million in decimal notation, that
    is, Base 10, as `1_000_000`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将一百万的十进制表示法，即基10，写成 `1_000_000`。
- en: 'You can even use the 2/3 grouping common in India: `10_00_000`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用印度常见的2/3分组：`10_00_000`。
- en: Using binary or hexadecimal notation
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用二进制或十六进制表示法
- en: To use binary notation, that is, Base 2, using only 1s and 0s, start the number
    literal with `0b`. To use hexadecimal notation, that is, Base 16, using 0 to 9
    and A to F, start the number literal with `0x`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用二进制表示法，即基2，仅使用1和0，在数字字面量前加上 `0b`。要使用十六进制表示法，即基16，使用0到9和A到F，在数字字面量前加上 `0x`。
- en: Exploring whole numbers
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索整数
- en: 'Let’s enter some code to see some examples:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入一些代码来查看一些示例：
- en: 'In the `Numbers` project, in `Program.cs`, type statements to declare some
    number variables using underscore separators, as shown in the following code:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Numbers` 项目中的 `Program.cs` 文件中，输入语句以使用下划线分隔符声明一些数字变量，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the project and note the result is that all three numbers are the same,
    as shown in the following output:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并注意结果显示三个数字都是相同的，如下面的输出所示：
- en: '[PRE51]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Computers can always exactly represent integers using the `int` type or one
    of its sibling types, such as `long` and `short`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以使用 `int` 类型或其兄弟类型（如 `long` 和 `short`）精确地表示整数。
- en: Storing real numbers
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储实数
- en: Computers cannot always represent real, aka decimal or non-integer, numbers
    precisely. The `float` and `double` types store real numbers using single- and
    double-precision floating points.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不能总是精确地表示实数，即十进制或非整数数。`float` 和 `double` 类型使用单精度和双精度浮点数来存储实数。
- en: Most programming languages implement the **Institute of Electrical and Electronics
    Engineers** (**IEEE**) Standard for Floating-Point Arithmetic. IEEE 754 is a technical
    standard for floating-point arithmetic established in 1985 by the IEEE.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言实现了电气和电子工程师协会（**IEEE**）的浮点算术标准。IEEE 754是IEEE于1985年建立的一个关于浮点算术的技术标准。
- en: 'The following image shows a simplification of how a computer represents the
    number `12.75` in binary notation. Note the bits with the value `1` in the 8,
    4, ½, and ¼ columns:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了计算机如何简化表示数字 `12.75` 的二进制表示法。注意8、4、½和¼列中的值为 `1` 的位：
- en: 8 + 4 + ½ + ¼ = 12¾ = 12.75
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 8 + 4 + ½ + ¼ = 12¾ = 12.75
- en: '![](img/B22322_02_05.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_05.png)'
- en: 'Figure 2.5: Computer representing the number 12.75 in binary notation'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：计算机以二进制表示法表示数字12.75
- en: So, `12.75` in decimal notation is `00001100.1100` in binary notation. As you
    can see, the number `12.75` can be exactly represented using bits. However, most
    numbers can’t, which is something that we’ll be exploring shortly.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制表示法中的 `12.75` 在二进制表示法中是 `00001100.1100`。正如你所见，数字 `12.75` 可以使用位精确表示。然而，大多数数字不能，这是我们很快将要探讨的。
- en: Writing code to explore number sizes
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写代码以探索数字大小
- en: 'C# has an operator named `sizeof()` that returns the number of bytes that a
    type uses in memory. Some types have members named `MinValue` and `MaxValue`,
    which return the minimum and maximum values that can be stored in a variable of
    that type. We are now going to use these features to create a console app to explore
    number types:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有一个名为 `sizeof()` 的运算符，它返回类型在内存中使用的字节数。某些类型有名为 `MinValue` 和 `MaxValue` 的成员，它们返回可以存储在该类型变量中的最小和最大值。我们现在将使用这些功能来创建一个控制台应用程序以探索数字类型：
- en: 'In `Program.cs`, at the bottom of the file, type statements to show the size
    of three number data types, as shown in the following code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件底部，输入语句以显示三种数字数据类型的大小，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Warning!** The width of the printed pages in this book makes the `string`
    values (in double quotes) wrap over multiple lines. You must type them on a single
    line, or you will get compile errors.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**本书中打印页面的宽度使得字符串值（双引号内）会换行。你必须将它们输入在同一行上，否则你会得到编译错误。'
- en: 'Run the code and view the output, as shown in *Figure 2.6*:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看输出，如图 *2.6* 所示：
- en: '![](img/B22322_02_06.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_06.png)'
- en: 'Figure 2.6: Size and range information for common number data types'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：常见数字数据类型的尺寸和范围信息
- en: An `int` variable uses 4 bytes of memory and can store positive or negative
    numbers up to about 2 billion. A `double` variable uses 8 bytes of memory and
    can store much bigger values! A `decimal` variable uses 16 bytes of memory and
    can store big numbers, but not as big as a `double` type.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 变量使用 4 个字节的内存，可以存储高达约 20 亿的正负数。`double` 变量使用 8 个字节的内存，可以存储更大的值！`decimal`
    变量使用 16 个字节的内存，可以存储大数字，但不如 `double` 类型大。'
- en: But you may be asking yourself, why might a `double` variable be able to store
    bigger numbers than a `decimal` variable, yet it’s only using half the space in
    memory? Well, let’s now find out!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能想知道，为什么 `double` 变量能够存储比 `decimal` 变量更大的数字，而它只使用了内存空间的一半？好吧，现在我们就来找出答案！
- en: Comparing double and decimal types
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较 `double` 和 `decimal` 类型
- en: 'You will now write some code to compare `double` and `decimal` values. Although
    it isn’t hard to follow, don’t worry about understanding the syntax right now:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将编写一些代码来比较 `double` 和 `decimal` 值。虽然不难理解，但现在不必担心理解语法：
- en: 'Type statements to declare two `double` variables, add them together, and compare
    them to the expected result. Then, write the result to the console, as shown in
    the following code:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入类型声明来声明两个 `double` 变量，将它们相加，并将它们与预期结果进行比较。然后，将结果写入控制台，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE54]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In cultures that use a comma for the decimal separator, the result will look
    slightly different, as shown in the following output: `0,1 + 0,2 does NOT equal
    0,3`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用逗号作为小数分隔符的文化中，结果将略有不同，如下面的输出所示：`0,1 + 0,2 does NOT equal 0,3`。
- en: The `double` type is not guaranteed to be accurate because most numbers like
    `0.1`, `0.2`, and `0.3` literally cannot be exactly represented as floating-point
    values.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 类型不能保证准确性，因为大多数数字，如 `0.1`、`0.2` 和 `0.3`，实际上不能精确地表示为浮点值。'
- en: If you were to try different values, like `0.1 + 0.3 == 0.4`, it would happen
    to return `true` because, with `double` values, some imprecise values happen to
    be exactly equal in their current representation even though they might not actually
    be equal mathematically. So, some numbers can be directly compared but some cannot.
    I deliberately picked `0.1` and `0.2` to compare to `0.3` because they cannot
    be compared, as proven by the result.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试不同的值，比如 `0.1 + 0.3 == 0.4`，它可能会返回 `true`，因为对于 `double` 类型的值，一些不精确的值在当前表示中恰好相等，尽管它们在数学上可能并不相等。所以，有些数字可以直接比较，但有些则不能。我特意选择了
    `0.1` 和 `0.2` 来与 `0.3` 比较，因为它们不能进行比较，正如结果所证明的。
- en: You could compare real numbers stored in the `float` type, which is less accurate
    than the `double` type, but the comparison would actually appear to be `true`
    because of that lower accuracy!
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以比较存储在 `float` 类型的实数，它比 `double` 类型更不精确，但由于这种较低的精度，比较实际上会显示为 `true`！
- en: '[PRE55]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As a rule of thumb, you should only use `double` when accuracy, especially when
    comparing the equality of two numbers, is not important. An example of this might
    be when you’re measuring a person’s height; you will only compare values using
    greater than or less than, but never equals.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该只在精度，尤其是比较两个数字的相等性不重要时使用 `double`。一个例子可能是当你测量一个人的身高时；你将只使用大于或小于来比较值，但永远不会使用等于。
- en: The problem with the preceding code is illustrated by how the computer stores
    the number `0.1`, or multiples of it. To represent `0.1` in binary notation, the
    computer stores 1 in the 1/16 column, 1 in the 1/32 column, 1 in the 1/256 column,
    1 in the 1/512 column, and so on.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的问题可以通过计算机存储数字 `0.1` 或其倍数的方式来说明。为了在二进制表示法中表示 `0.1`，计算机在 1/16 列存储 1，在 1/32
    列存储 1，在 1/256 列存储 1，在 1/512 列存储 1，依此类推。
- en: 'The number `0.1` in decimal notation is `0.00011001100110011`… in binary notation,
    repeating forever, as shown in *Figure 2.7*:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制表示法中的数字 `0.1` 在二进制表示法中是 `0.00011001100110011`…，无限循环，如 *图 2.7* 所示：
- en: '![](img/B22322_02_07.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_07.png)'
- en: 'Figure 2.7: Number 0.1 in decimal notation repeating forever in binary notation'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：十进制表示法中数字 0.1 在二进制表示法中无限循环
- en: '**Good Practice**: Never compare `double` values using `==`. During the Gulf
    War of 1990-1991, an American Patriot missile battery used `double` values in
    its calculations. The inaccuracy caused it to fail to track and intercept an incoming
    Iraqi Scud missile, and 28 soldiers were killed; you can read about this at [https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html).
    The Patriot missile system has improved since then. *“Forty years after it was
    brought into service, the Patriot air-defense system is finally doing what it
    was designed for.” “No one was 100% sure that the Patriot was capable of destroying
    a Kh-47 hypersonic missile,” said Col. Serhiy Yaremenko, commander of the 96th
    Anti-Aircraft Missile Brigade, which defends Kyiv. “Ukrainians proved it.”*: [https://archive.ph/2023.06.11-132200/https://www.wsj.com/amp/articles/u-s-patriot-missile-is-an-unsung-hero-of-ukraine-war-db6053a0](https://archive.ph/2023.06.11-132200/https://www.wsj.com/amp/articles/u-s-patriot-missile-is-an-unsung-hero-of-ukraine-war-db6053a0).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：永远不要使用 `==` 比较双精度值。在1990-1991年的海湾战争中，一个美国爱国者导弹营在其计算中使用了双精度值。这种不精确导致它未能追踪和拦截一枚来袭的伊拉克飞毛腿导弹，造成28名士兵死亡；您可以在[https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html)上了解更多信息。自那时起，爱国者导弹系统已经得到了改进。“在服役40年后，爱国者防空系统终于做到了它被设计要做的。”
    “没有人100%确信爱国者能够摧毁一枚Kh-47高超音速导弹，”基辅第96防空导弹旅指挥官谢尔盖·亚列缅科上校说。“乌克兰人证明了这一点。”：[https://archive.ph/2023.06.11-132200/https://www.wsj.com/amp/articles/u-s-patriot-missile-is-an-unsung-hero-of-ukraine-war-db6053a0](https://archive.ph/2023.06.11-132200/https://www.wsj.com/amp/articles/u-s-patriot-missile-is-an-unsung-hero-of-ukraine-war-db6053a0)。'
- en: 'Now let’s see the same code using the `decimal` number type:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用 `decimal` 数字类型的相同代码：
- en: Copy and paste the statements that you wrote before (which used the `double`
    variables).
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴您之前编写的语句（使用了 `double` 变量）。
- en: 'Modify the statements to use `decimal` and rename the variables to `c` and
    `d`, as shown in the following code:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改语句以使用 `decimal` 并将变量重命名为 `c` 和 `d`，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE57]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `decimal` type is accurate because it stores the number as a large integer
    and shifts the decimal point. For example, `0.1` is stored as `1`, with a note
    to shift the decimal point one place to the left. `12.75` is stored as `1275`,
    with a note to shift the decimal point two places to the left.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal` 类型是准确的，因为它将数字存储为一个大整数，并移动小数点。例如，`0.1` 被存储为 `1`，并标记为将小数点向左移动一位。`12.75`
    被存储为 `1275`，并标记为将小数点向左移动两位。'
- en: '**Good Practice**: Use `int` for whole numbers. Use `double` for real numbers
    that will not be compared for equality to other values; it is okay to compare
    `double` values being less than or greater than, and so on. Use `decimal` for
    money, CAD drawings, general engineering, and wherever the accuracy of a real
    number is important.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：对于整数使用 `int`。对于不会与其他值进行比较的实数使用 `double`；比较 `double` 值是否小于或大于等是可以的。对于金钱、CAD图纸、通用工程以及任何需要实数精度的场合使用
    `decimal`。'
- en: Special real number values
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊实数值
- en: 'The `float` and `double` types have some useful special values: `NaN` represents
    not-a-number (for example, the result of dividing zero by zero), `Epsilon` represents
    the smallest positive number that can be stored in a `float` or `double`, and
    `PositiveInfinity` and `NegativeInfinity` represent infinitely large positive
    and negative values. They also have methods for checking for these special values
    like `IsInfinity` and `IsNaN`.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 和 `double` 类型有一些有用的特殊值：`NaN` 表示“不是一个数字”（例如，零除以零的结果），`Epsilon` 表示可以存储在
    `float` 或 `double` 中的最小正数，`PositiveInfinity` 和 `NegativeInfinity` 表示无限大的正数和负数。它们还有用于检查这些特殊值的方法，如
    `IsInfinity` 和 `IsNaN`。'
- en: 'Let’s write some code statements to see what some of these special values look
    like:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码语句来查看这些特殊值的外观：
- en: 'Add statements to output some special `double` values, as shown in the following
    code:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向输出中添加语句以输出一些特殊的 `double` 值，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE59]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note the following:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: '`NaN` outputs as `NaN`. (`NaN` means “not a number”.) It can be generated from
    an expression of zero divided by zero.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN` 输出为 `NaN`。(`NaN` 表示“不是一个数字”。) 它可以由零除以零的表达式生成。'
- en: The `PositiveInfinity` value outputs as an `8`, which looks like an infinity
    symbol on its side. It can be generated from an expression of any positive real
    number divided by zero.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PositiveInfinity`值输出为一个`8`，看起来像其侧面的无穷符号。它可以由任何正实数除以零的表达式生成。'
- en: The `NegativeInfinity` value outputs as `-8`, which looks like an infinity symbol
    on its side with a negative sign before it. It can be generated from an expression
    of any negative real number divided by zero.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NegativeInfinity`值输出为`-8`，看起来像其侧面的无穷符号，前面有一个负号。它可以由任何负实数除以零的表达式生成。'
- en: Zero divided by any positive real number is zero.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零除以任何正实数是零。
- en: Zero divided by any negative real number is negative zero.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零除以任何负实数是负零。
- en: '`Epsilon` is slightly less than `5E-324` represented using scientific notation:
    [https://en.wikipedia.org/wiki/Scientific_notation](https://en.wikipedia.org/wiki/Scientific_notation).'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Epsilon`略小于使用科学记数法表示的`5E-324`：[https://en.wikipedia.org/wiki/Scientific_notation](https://en.wikipedia.org/wiki/Scientific_notation)。'
- en: New number types and unsafe code
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新数字类型和不安全代码
- en: The `System.Half` type was introduced in .NET 5\. Like `float` and `double`,
    it can store real numbers. It normally uses two bytes of memory. The `System.Int128`
    and `System.UInt128` types were introduced in .NET 7\. Like `int` and `uint`,
    they can store signed (positive and negative) and unsigned (only zero and positive)
    integer values. They normally use 16 bytes of memory.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Half`类型是在.NET 5中引入的。像`float`和`double`一样，它可以存储实数。它通常使用两个字节的内存。`System.Int128`和`System.UInt128`类型是在.NET
    7中引入的。像`int`和`uint`一样，它们可以存储有符号（正负）和无符号（只有零和正）的整数值。它们通常使用16字节的内存。'
- en: 'For these new number types, the `sizeof` operator only works in an unsafe code
    block, and you must compile the project using an option to enable unsafe code.
    Let’s explore how this works:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些新数字类型，`sizeof`运算符仅在非安全代码块中有效，你必须使用启用非安全代码的选项编译项目。让我们探索它是如何工作的：
- en: 'In `Program.cs`, at the bottom of the file, type statements to show the size
    of the `Half` and `Int128` number data types, as shown in the following code:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件底部，输入语句以显示`Half`和`Int128`数字数据类型的大小，如下所示代码：
- en: '[PRE60]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `Numbers.csproj`, add an element to enable unsafe code, as shown highlighted
    in the following markup:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Numbers.csproj`中，添加一个元素以启用不安全代码，如下所示突出显示的标记：
- en: '[PRE61]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the `Numbers` project and note the sizes of the two new number types, as
    shown in the following output:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`Numbers`项目，并注意两种新数字类型的大小，如下所示输出：
- en: '[PRE62]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**More Information**: The `sizeof` operator requires an unsafe code block,
    except for the commonly used types like `int` and `byte`. You can learn more about
    `sizeof` at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/sizeof](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/sizeof).
    Unsafe code cannot have its safety verified. You can learn more about unsafe code
    blocks at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code).'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更多信息**：`sizeof`运算符需要非安全代码块，除了常用的类型如`int`和`byte`之外。你可以在以下链接了解更多关于`sizeof`的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/sizeof](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/sizeof)。不安全代码无法验证其安全性。你可以在以下链接了解更多关于不安全代码块的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code)。'
- en: Storing Booleans
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储布尔值
- en: 'Booleans can only contain one of the two literal values `true` or `false`,
    as shown in the following code:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值只能包含两个文字值之一`true`或`false`，如下所示代码：
- en: '[PRE63]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: They are most used to branch and loop. You don’t need to fully understand them
    yet, as they are covered more in *Chapter 3*, *Controlling Flow, Converting Types,
    and Handling Exceptions*.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 他们最常用于分支和循环。你目前不需要完全理解它们，因为它们在*第3章*，*控制流程、转换类型和处理异常*中介绍得更为详细。
- en: Storing any type of object
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储任何类型的对象
- en: 'There is a special type named `object` that can store any type of data, but
    its flexibility comes at the cost of messier code and possibly poor performance.
    For those two reasons, you should avoid it whenever possible. The following steps
    show you how to use object types if you need to use them because you must use
    a Microsoft or third-party library that uses them:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊类型名为`object`，可以存储任何类型的数据，但它的灵活性是以代码更混乱和可能性能较差为代价的。出于这两个原因，你应该尽可能避免使用它。以下步骤展示了如果你需要使用对象类型时如何使用它们，因为你必须使用使用它们的Microsoft或第三方库：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Variables` to the `Chapter02` solution.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器，将名为 `Variables` 的新 **控制台应用程序** / `console` 项目添加到 `Chapter02` 解决方案中。
- en: 'In `Program.cs`, delete the existing statements and then type statements to
    declare and use some variables using the `object` type, as shown in the following
    code:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后输入语句来声明和使用一些使用 `object` 类型的变量，如下所示：
- en: '[PRE64]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run the code and note that the fourth statement cannot compile because the
    data type of the `name` variable is not known by the compiler, as shown in *Figure
    2.8*:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意第四个语句无法编译，因为编译器不知道 `name` 变量的数据类型，如下 *图 2.8* 所示：
- en: '![](img/B22322_02_08.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_08.png)'
- en: 'Figure 2.8: The object type does not have a Length property'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：`object` 类型没有 `Length` 属性
- en: Add double slashes to the beginning of the statement that cannot compile to
    comment out the statement, making it inactive.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无法编译的语句开头添加双斜杠来注释掉该语句，使其失效。
- en: 'Run the code again and note that the compiler can access the `length` of a
    `string` if the programmer explicitly tells the compiler that the `object` variable
    contains a `string` by prefixing the `name` variable with a cast expression like
    `(string)name`. The results can then successfully be written to the console, as
    shown in the following output:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，并注意编译器可以访问 `string` 的 `length` 属性，前提是程序员明确告诉编译器 `object` 变量包含一个 `string`，通过在
    `name` 变量前加上类型转换表达式如 `(string)name`。结果可以成功写入控制台，如下所示：
- en: '[PRE65]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You will learn about cast expressions in *Chapter 3*, *Controlling Flow, Converting
    Types, and Handling Exceptions*.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *第 3 章*，*控制流程、类型转换和异常处理* 中学习关于类型转换表达式的内容。
- en: The `object` type has been available since the first version of C#, but C# 2
    and later have a better alternative called **generics**, which we will cover in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. This will provide
    us with the flexibility we want but without the performance overhead.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`object` 类型自 C# 的第一个版本以来就可用，但 C# 2 及以后的版本有一个更好的替代品，称为 **泛型**，我们将在 *第 6 章*，*实现接口和继承类*
    中介绍。这将为我们提供所需的灵活性，但不会带来性能开销。'
- en: '**Good Practice**: Avoid declaring variables as a `System.Object`, aka `object`
    type. There are usually better alternatives that you can use instead, like generics.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免将变量声明为 `System.Object`，即 `object` 类型。通常有更好的替代方案可以使用，比如泛型。'
- en: Storing dynamic types
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储动态类型
- en: 'There is another special type named `dynamic` that can also store any type
    of data, but even more than `object`, its flexibility comes at the cost of performance.
    The `dynamic` keyword was introduced in C# 4\. However, unlike `object`, the value
    stored in the variable can have its members invoked without an explicit cast.
    Let’s make use of a `dynamic` type:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `dynamic` 的特殊类型，也可以存储任何类型的数据，但比 `object` 更灵活，其灵活性是以性能为代价的。`dynamic` 关键字是在
    C# 4 中引入的。然而，与 `object` 不同，存储在变量中的值可以调用其成员，而无需显式转换。让我们使用一个 `dynamic` 类型：
- en: 'Add statements to declare a `dynamic` variable. Assign a `string` literal value,
    and then an integer value, and then an array of integer values. Finally, add a
    statement to output the length of the `dynamic` variable, as shown in the following
    code:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句来声明一个 `dynamic` 变量。分配一个 `string` 文字值，然后是一个整数值，然后是一个整数值数组。最后，添加一个语句来输出 `dynamic`
    变量的长度，如下所示：
- en: '[PRE66]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You will learn about arrays in *Chapter 3*, *Controlling Flow, Converting Types,
    and Handling Exceptions*.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *第 3 章*，*控制流程、类型转换和异常处理* 中学习关于数组的内容。
- en: 'Run the code and note that it works because the last value assigned to something
    was a `string` value that does have a `Length` property, as shown in the following
    output:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它之所以能正常工作，是因为最后分配给 `something` 的值是一个具有 `Length` 属性的 `string` 值，如下所示：
- en: '[PRE67]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Comment out the statement that assigns a `string` value to the `something` variable
    by prefixing the statement with two slashes, `//`.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在语句前加上两个斜杠 `//` 来注释掉将 `string` 值赋给 `something` 变量的语句。
- en: 'Run the code and note the runtime error because the last value assigned to
    `something` is an `int` that does not have a `Length` property, as shown in the
    following output:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意运行时错误，因为分配给 `something` 的最后一个值是一个没有 `Length` 属性的 `int`，如下所示：
- en: '[PRE68]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Comment out the statement that assigns an `int` to the `something` variable.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉将 `int` 赋给 `something` 变量的语句。
- en: 'Run the code and note the output because an array of three `int` values does
    have a `Length` property, as shown in the following output:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意输出，因为包含三个 `int` 值的数组确实有一个 `Length` 属性，如下面的输出所示：
- en: '[PRE69]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: One limitation of `dynamic` is that code editors cannot show IntelliSense to
    help you write the code. This is because the compiler cannot check what the type
    is during build time. Instead, the **CLR (Common Language Runtime)** checks for
    the member at runtime and throws an exception if it is missing.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` 的一个限制是代码编辑器无法显示 IntelliSense 来帮助你编写代码。这是因为编译器在构建时无法检查类型。相反，**CLR
    (公共语言运行时)** 在运行时检查成员，如果成员缺失则抛出异常。'
- en: Exceptions are a way to indicate that something has gone wrong at runtime. You
    will learn more about them and how to handle them in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是表示在运行时出现错误的一种方式。你将在第 3 章，*控制流程、转换类型和处理异常*中了解更多关于它们以及如何处理它们的信息。
- en: Dynamic types are most useful when interoperating with non-.NET systems. For
    example, you might need to work with a class library written in F#, Python, or
    some JavaScript. You might also need to interop with technologies like the **Component
    Object Model** (**COM**), for example, when automating Excel or Word.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型在与非 .NET 系统交互时最有用。例如，你可能需要与用 F#、Python 或某些 JavaScript 编写的类库一起工作。你也可能需要与像
    **组件对象模型** (**COM**) 这样的技术进行交互，例如在自动化 Excel 或 Word 时。
- en: Declaring local variables
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明局部变量
- en: Local variables are declared inside methods, and they only exist during the
    execution of that method. Once the method returns, the memory allocated to any
    local variables is released.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量是在方法内部声明的，并且它们只在该方法的执行期间存在。一旦方法返回，分配给任何局部变量的内存就会被释放。
- en: Strictly speaking, value types are released while reference types must wait
    for garbage collection. You will learn about the difference between value types
    and reference types and how to make sure that only one garbage collection is needed
    rather than two when releasing unmanaged resources in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，值类型在释放时会被释放，而引用类型必须等待垃圾回收。你将在第 6 章，*实现接口和继承类*中学习值类型和引用类型之间的区别以及如何确保在释放非托管资源时只需要一次垃圾回收而不是两次。
- en: Specifying the type of a local variable
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定局部变量的类型
- en: Let’s explore local variables declared with specific types and using type inference.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用特定类型声明的局部变量和使用类型推断的情况。
- en: 'Type statements to declare and assign values to some local variables using
    specific types, as shown in the following code:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定类型声明并分配值给一些局部变量的类型语句，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Depending on your code editor and color scheme, it will show green squiggles
    under each of the variable names and lighten their text color to warn you that
    the variable is assigned but its value is never used.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的代码编辑器和配色方案，它将在每个变量名下方显示绿色波浪线，并淡化它们的文本颜色以警告你该变量已被分配但其值从未被使用。
- en: Inferring the type of a local variable
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断局部变量的类型
- en: You can use the `var` keyword to declare local variables with C# 3 and later.
    The compiler will infer the type from the value that you assign after the assignment
    operator, `=`. This happens at compile time so using `var` has no effect on runtime
    performance.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `var` 关键字从 C# 3 及以后的版本声明局部变量。编译器将从赋值运算符 `=` 后分配的值推断类型。这发生在编译时，因此使用 `var`
    对运行时性能没有影响。
- en: 'A literal number without a decimal point is inferred as an `int` variable,
    that is, unless you add a suffix, as described in the following list:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 没有小数点的文字数字被推断为 `int` 变量，即除非你添加了后缀，如下面的列表中所述：
- en: '`L`: Compiler infers `long`'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L`: 编译器推断为 `long`'
- en: '`UL`: Compiler infers `ulong`'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UL`: 编译器推断为 `ulong`'
- en: '`M`: Compiler infers `decimal`'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`: 编译器推断为 `decimal`'
- en: '`D`: Compiler infers `double`'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`: 编译器推断为 `double`'
- en: '`F`: Compiler infers `float`'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`: 编译器推断为 `float`'
- en: A literal number with a decimal point is inferred as `double` unless you add
    the `M` suffix (in which case the compiler infers a `decimal` variable), or the
    `F` suffix, in which case it infers a `float` variable.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 带有小数点的文字数字被推断为 `double` 类型，除非你添加了 `M` 后缀（在这种情况下编译器推断为 `decimal` 变量），或者 `F` 后缀，在这种情况下它推断为
    `float` 变量。
- en: 'Double quotes indicate a `string` variable, single quotes indicate a `char`
    variable, and the `true` and `false` values infer a `bool` type:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号表示 `string` 变量，单引号表示 `char` 变量，而 `true` 和 `false` 值推断为 `bool` 类型：
- en: 'Modify the previous statements to use `var`, as shown in the following code:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的语句修改为使用 `var`，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Hover your mouse over each of the `var` keywords and note that your code editor
    shows a tooltip with information about the type that has been inferred.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在每个 `var` 关键字上，并注意你的代码编辑器会显示一个包含推断出的类型信息的工具提示。
- en: 'At the top of `Program.cs`, import the namespace for working with XML to enable
    us to declare some variables using types in that namespace, as shown in the following
    code:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的顶部，导入用于处理 XML 的命名空间，以便我们能够使用该命名空间中的类型声明一些变量，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'At the bottom of `Program.cs`, add statements to create some new objects, as
    shown in the following code:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的底部，添加创建一些新对象的语句，如下面的代码所示：
- en: '[PRE73]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**Good Practice**: Although using `var` is convenient, some developers avoid
    using it to make it easier for a code reader to understand the types in use. Personally,
    I use it only when the type is obvious. For example, in the preceding code statements,
    the first statement is just as clear as the second in stating what the types of
    the `xml` variables are, but it is shorter. However, the third statement isn’t
    clear in showing the type of the `file` variable, so the fourth is better because
    it shows that the type is `StreamWriter`. If in doubt, spell it out!'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：虽然使用 `var` 很方便，但一些开发者为了避免使代码读者更难理解正在使用的类型，会避免使用它。我个人只在类型明显时才使用它。例如，在先前的代码语句中，第一条语句在说明
    `xml` 变量的类型方面与第二条语句一样清晰，但更简洁。然而，第三条语句在显示 `file` 变量的类型方面并不清晰，所以第四条更好，因为它显示了类型是
    `StreamWriter`。如果有疑问，就明确写出！'
- en: Note that `var` is converted to the actual type by the compiler when you build
    a project. A variable declared using `var` has a specific, known, fixed data type.
    This is different from `dynamic`, which the compiler does not change. It remains
    a `System.Dynamic` type that can reference any object of any data type. The actual
    type is only checked at runtime, so that’s when an exception might be thrown if
    you access a member on it that does not exist.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你构建项目时，编译器会将 `var` 转换为实际类型。使用 `var` 声明的变量具有特定、已知、固定的数据类型。这与 `dynamic` 不同，编译器不会改变它。它保持为
    `System.Dynamic` 类型，可以引用任何数据类型的任何对象。实际类型仅在运行时检查，因此，如果你访问它不存在成员时可能会抛出异常。
- en: 'You can use a Visual Studio refactoring feature to automatically convert uses
    of `var` into the specific type, as documented at the following link: [https://learn.microsoft.com/en-us/visualstudio/ide/reference/convert-var-to-explicit-type](https://learn.microsoft.com/en-us/visualstudio/ide/reference/convert-var-to-explicit-type).'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Visual Studio 的重构功能自动将 `var` 的使用转换为特定类型，具体请参阅以下链接：[https://learn.microsoft.com/en-us/visualstudio/ide/reference/convert-var-to-explicit-type](https://learn.microsoft.com/en-us/visualstudio/ide/reference/convert-var-to-explicit-type)。
- en: What does new do?
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`new` 是做什么的？'
- en: There have been a few examples of using the C# `new` keyword before this section,
    but so far, I haven’t explicitly explained what it does. The C# `new` keyword
    is used to allocate and/or initialize memory. To understand when you need to use
    `new`, you need to know a bit more about types.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之前，已经有一些使用 C# `new` 关键字的例子，但到目前为止，我还没有明确解释它做什么。C# 的 `new` 关键字用于分配和/或初始化内存。要了解何时需要使用
    `new`，你需要对类型了解更多。
- en: Value and reference types and their relationship to memory are explained in
    more detail in *Chapter 6, Implementing Interfaces and Inheriting Classes*, so
    I will only introduce the minimum explanation for now.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型及其与内存的关系在 *第6章，实现接口和继承类* 中有更详细的解释，所以现在我只介绍最基本的内容。
- en: 'There are two categories of types: **value types** and **reference types**.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 类型分为两类：**值类型**和**引用类型**。
- en: Value types are simple and do not need to use the `new` keyword to explicitly
    allocate memory. But value types can use the `new` keyword to initialize their
    value. This is useful when there is no way to use a literal to set the value.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型很简单，不需要使用 `new` 关键字来显式分配内存。但值类型可以使用 `new` 关键字来初始化它们的值。这在无法使用字面量设置值时很有用。
- en: Reference types are more complex and need to use the `new` keyword to explicitly
    allocate memory. At the same time, they can use the `new` keyword to initialize
    their state.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型更复杂，需要使用 `new` 关键字来显式分配内存。同时，它们可以使用 `new` 关键字来初始化它们的状态。
- en: For example, when you declare variables, space is only allocated in memory for
    value types like `int` and `DateTime` but not for reference types like `Person`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你声明变量时，只有值类型如 `int` 和 `DateTime` 在内存中分配空间，而引用类型如 `Person` 则不会。
- en: 'Consider the following code that declares some local variables:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下声明一些局部变量的代码：
- en: '[PRE74]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note the following about the preceding code:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于前面代码的说明：
- en: '`age` has a value of `0` and 2 bytes of memory have been allocated in stack
    memory.'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age` 的值为 `0`，并且在栈内存中已分配了 2 个字节的内存。'
- en: '`population` has a value of `0` and 8 bytes of memory have been allocated in
    stack memory.'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`population` 的值为 `0`，并且在栈内存中已分配了 8 个字节的内存。'
- en: '`birthdate` has a value of `0001-01-01` and 8 bytes of memory have been allocated
    in stack memory.'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`birthdate` 的值为 `0001-01-01`，并且在栈内存中已分配了 8 个字节的内存。'
- en: '`location` has a value of `0, 0` and 8 bytes of memory have been allocated
    in stack memory.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location` 的值为 `0, 0`，并且在栈内存中已分配了 8 个字节的内存。'
- en: '`bob` has a value of `null` and 4 bytes of memory have been allocated in stack
    memory. No heap memory has been allocated for the object.'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bob` 的值为 `null`，并且在栈内存中已分配了 4 个字节的内存。没有为该对象分配堆内存。'
- en: 'Now let’s see when we might choose to use `new`:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看何时可能选择使用 `new`：
- en: '[PRE75]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Note the following about the preceding code:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于前面代码的说明：
- en: '`age`, `population`, `birthdate`, and `location` have already had memory allocated
    for them on the stack. We only need to use `new` to initialize their values if
    we want them to be different from their defaults.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`、`population`、`birthdate` 和 `location` 已经在栈上为它们分配了内存。如果我们想要它们的值与默认值不同，我们只需要使用
    `new` 来初始化它们的值。'
- en: '`bob` must use `new` to allocate heap memory for the object. The `=` assignment
    stores the memory address of that allocated memory on the stack. Reference types
    like `Person` often have multiple constructors that are called by `new`. A default
    constructor assigns default values to any state in the object. A constructor with
    arguments can assign other values to any state in the object.'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bob` 必须使用 `new` 来为对象分配堆内存。`=` 赋值操作将分配的内存地址存储在栈上。引用类型如 `Person` 通常有多个构造函数，它们通过
    `new` 被调用。默认构造函数将默认值分配给对象中的任何状态。带有参数的构造函数可以将其他值分配给对象中的任何状态。'
- en: Constructors are covered in more detail in *Chapter 5, Building Your Own Types
    with Object-Oriented Programming*, so I have only introduced the minimum explanation
    for now.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在 *第 5 章，使用面向对象编程构建自己的类型* 中有更详细的介绍，所以我现在只介绍了最基本的概念。
- en: Using target-typed new to instantiate objects
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用目标类型 `new` 实例化对象
- en: 'With C# 9, Microsoft introduced another syntax for instantiating objects, known
    as **target-typed new**. When instantiating an object, you can specify the type
    first and then use `new` without repeating the type, as shown in the following
    code:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 9，Microsoft 引入了一种新的实例化对象的语法，称为 **目标类型 `new`**。在实例化对象时，你可以首先指定类型，然后使用 `new`
    而不必重复类型，如下面的代码所示：
- en: '[PRE76]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you have a type with a field or property that needs to be set, then the
    type can be inferred, as shown in the following code:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要设置字段或属性的类型，那么类型可以被推断，如下面的代码所示：
- en: '[PRE77]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This way of instantiating objects is especially useful with arrays and collections
    because they have multiple objects, often of the same type, as shown in the following
    code:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实例化对象的方式在数组集合中特别有用，因为它们有多个对象，通常是同一类型，如下面的代码所示：
- en: '[PRE78]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You will learn about arrays in *Chapter 3*, *Controlling Flow, Converting Types,
    and Handling Exceptions*, and collections in *Chapter 8*,*Working with Common
    .NET Types*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *第 3 章*，*控制流程、转换类型和处理异常* 中学习数组，以及在 *第 8 章*，*使用常见的 .NET 类型* 中学习集合。
- en: '**Good Practice**: Use target-typed new to instantiate objects because it requires
    fewer characters; when reading a statement from left to right, as in English,
    you immediately know the type of the variable, and it is not limited to local
    variables like `var` is, in my opinion, the only reason not to use target-typed
    new is if you must use a pre-version 9 C# compiler. I do acknowledge that my opinion
    is not accepted by the whole C# community. I have used target-typed new throughout
    the remainder of this book. Please let me know if you spot any cases that I missed!
    There is a Visual Studio refactoring feature to use target-typed new, as documented
    at the following link: [https://learn.microsoft.com/en-us/visualstudio/ide/reference/use-new](https://learn.microsoft.com/en-us/visualstudio/ide/reference/use-new).'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用目标类型的新实例化对象，因为它需要的字符更少；当从左到右阅读一个语句，就像英语一样，你立即就知道变量的类型，而且它不仅限于像 `var`
    这样的局部变量，在我看来，不使用目标类型的新实例化的唯一原因是你必须使用版本 9 之前的 C# 编译器。我承认我的观点并不被整个 C# 社区接受。我在本书的其余部分都使用了目标类型的新实例化。如果您发现我遗漏了任何情况，请告诉我！Visual
    Studio 有一个重构功能，可以用来使用目标类型的新实例化，具体请参阅以下链接：[https://learn.microsoft.com/en-us/visualstudio/ide/reference/use-new](https://learn.microsoft.com/en-us/visualstudio/ide/reference/use-new)。'
- en: Getting and setting the default values for types
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和设置类型的默认值
- en: Most of the primitive types except `string` are **value types**, which means
    that they must have a value. You can determine the default value of a type by
    using the `default()` operator and passing the type as a parameter. You can assign
    the default value of a type by using the `default` keyword.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `string` 之外的大多数原始类型都是 **值类型**，这意味着它们必须有一个值。你可以通过使用 `default()` 运算符并将类型作为参数传递来确定类型的默认值。你可以使用
    `default` 关键字来分配类型的默认值。
- en: The `string` type is a **reference type**. This means that `string` variables
    contain the memory address of a value, not the value itself. A reference type
    variable can have a `null` value, which is a literal that indicates that the variable
    does not reference anything (yet). `null` is the default for all reference types.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类型是一个 **引用类型**。这意味着 `string` 变量包含一个值的内存地址，而不是值本身。引用类型变量可以有一个 `null`
    值，这是一个表示变量尚未引用任何内容的字面量。`null` 是所有引用类型的默认值。'
- en: You’ll learn more about value types and reference types in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *第 6 章*，*实现接口和继承类* 中了解更多关于值类型和引用类型的内容。
- en: 'Let’s explore default values:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索默认值：
- en: 'Add statements to show the default values of an `int`, a `bool`, a `DateTime`,
    and a `string`, as shown in the following code:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以显示 `int`、`bool`、`DateTime` 和 `string` 的默认值，如下所示代码：
- en: '[PRE79]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `??` operator means, if `null`, then return the following instead. So if
    `default(string)` is `null`, then the text, `<NULL>` will be returned.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`??` 运算符的意思是，如果为 `null`，则返回以下值。所以如果 `default(string)` 是 `null`，则返回的文本将是 `<NULL>`。'
- en: 'Run the code and view the result. Note that your output for the date and time
    might be formatted differently if you are not running it in the UK because date
    and time values are formatted using the current culture of your computer, as shown
    in the following output:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果。请注意，如果你的输出日期和时间格式不同，那是因为日期和时间值是使用你电脑的当前文化格式化的，如下所示输出：
- en: '[PRE80]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add statements to declare a number, assign a value, and then reset it to its
    default value, as shown in the following code:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以声明一个数字，分配一个值，然后将其重置为其默认值，如下所示代码：
- en: '[PRE81]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE82]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Exploring more about console apps
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索更多关于控制台应用程序的内容
- en: We have already created and used basic console apps, but we’re now at a stage
    where we should delve into them more deeply.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建并使用了一些基本的控制台应用程序，但现在我们应该更深入地研究它们。
- en: Console apps are text-based and are run at the command prompt. They typically
    perform simple tasks that need to be scripted, such as compiling a file or encrypting
    a section of a configuration file.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序是基于文本的，在命令提示符下运行。它们通常执行需要脚本的简单任务，例如编译文件或加密配置文件的一部分。
- en: Equally, they can also have arguments passed to them to control their behavior.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，它们也可以传递参数来控制其行为。
- en: 'An example of this would be to create a new console app using the F# language
    with a specified name instead of using the name of the current folder, as shown
    in the following command:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以创建一个新的控制台应用程序，使用 F# 语言并指定名称，而不是使用当前文件夹的名称，如下所示命令：
- en: '[PRE83]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Displaying output to the user
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向用户显示输出
- en: The two most common tasks that a console app performs are writing and reading
    data. We have already used the `WriteLine` method to output, but if we didn’t
    want a carriage return at the end of a line, for example, if we later wanted to
    continue to write more text at the end of that line, we could have used the `Write`
    method.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序执行的最常见的两个任务是写入和读取数据。我们已经使用了 `WriteLine` 方法来输出，但如果我们不想在行尾添加换行符，例如，如果我们稍后想在行尾继续写入更多文本，我们可以使用
    `Write` 方法。
- en: 'If you want to write three letters to the console without carriage returns
    after them, then call the `Write` method, as shown in the following code:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在控制台写入三个字母而不在其后添加换行符，那么请调用 `Write` 方法，如下面的代码所示：
- en: '[PRE84]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This will write the three characters on a single line and leave the cursor
    at the end of the line, as shown in the following output:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在单行上写入三个字符，并将光标留在行尾，如下面的输出所示：
- en: '[PRE85]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If you want to write three letters to the console with carriage returns after
    them, then call the `WriteLine` method, as shown in the following code:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在控制台写入三个字母并在其后添加换行符，那么请调用 `WriteLine` 方法，如下面的代码所示：
- en: '[PRE86]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This will write three lines and leave the cursor on the fourth line:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这将写入三行，并将光标留在第四行：
- en: '[PRE87]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Formatting using numbered positional arguments
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用编号位置参数进行格式化
- en: One way of generating formatted strings is to use numbered positional arguments.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 生成格式化字符串的一种方法是通过使用编号位置参数。
- en: This feature is supported by methods like `Write` and `WriteLine`. For methods
    that do not support the feature, the `string` parameter can be formatted using
    the `Format` method of `string`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能由 `Write` 和 `WriteLine` 等方法支持。对于不支持该功能的方法，可以使用 `string` 参数的 `Format` 方法进行格式化。
- en: 'Let’s begin formatting:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始格式化：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Formatting` to the `Chapter02` solution.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器向 `Chapter02` 解决方案添加一个名为 `Formatting` 的新 **Console App** / `console`
    项目。
- en: 'In `Program.cs`, delete the existing statements and then type statements to
    declare some number variables and write them to the console, as shown in the following
    code:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句，然后输入语句来声明一些数字变量并将它们写入控制台，如下面的代码所示：
- en: '[PRE88]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Warning!** We used the `CultureInfo` class to force the culture to US English
    so that the currency will be US dollars for all readers. In *Chapter 4, Writing,
    Debugging, and Testing Functions*, you will learn how to write a function to control
    the culture so that they can see US English by default, or override that to show
    your local computer culture or a specified culture.'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告！** 我们使用了 `CultureInfo` 类来强制文化设置为美国英语，以便对所有读者来说货币将是美元。在 *第4章，编写、调试和测试函数*
    中，你将学习如何编写一个函数来控制文化，以便他们可以默认看到美国英语，或者覆盖它以显示你本地计算机的文化或指定的文化。'
- en: The `Write`, `WriteLine`, and `Format` methods can have up to three numbered
    arguments, named `arg0`, `arg1`, and `arg2`. If you need to pass more than three
    values, then you cannot name them. The `WriteToFile` method is a nonexistent method
    used to illustrate the idea.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write`、`WriteLine` 和 `Format` 方法最多可以有三个编号参数，分别命名为 `arg0`、`arg1` 和 `arg2`。如果你需要传递超过三个值，那么你无法命名它们。`WriteToFile`
    方法是一个不存在的用于说明该想法的方法。'
- en: 'In `Program.cs`, type statements to write three and then five arguments to
    the console, as shown in the following code:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，输入语句来写入三个和五个参数到控制台，如下面的代码所示：
- en: '[PRE89]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Good Practice**: Once you become more comfortable with formatting strings,
    you should stop naming the parameters, for example, stop using `format:`, `arg0:`,
    and `arg1:`. The preceding code uses a non-canonical style to show where the `0`
    and `1` came from while you are learning.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：一旦你更熟悉格式化字符串，你应该停止命名参数，例如，停止使用 `format:`, `arg0:`, 和 `arg1:`。前面的代码使用非规范化的风格来展示在学习过程中
    `0` 和 `1` 的来源。'
- en: Rider and its warnings about boxing
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rider 及其关于装箱的警告
- en: 'If you use Rider and you have installed the Unity Support plugin, then it will
    complain a lot about boxing. A common scenario when boxing happens is when value
    types like `int` and `DateTime` are passed as positional arguments to `string`
    formats. This is a problem for Unity projects because they use a different memory
    garbage collector than the normal .NET runtime. For non-Unity projects, like all
    the projects in this book, you can ignore these boxing warnings because they are
    not relevant. You can read more about this Unity-specific issue at the following
    link: [https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing](https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing).'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Rider并且已经安装了Unity支持插件，那么它会对装箱问题抱怨很多。装箱发生的一个常见场景是将`int`和`DateTime`等值类型作为位置参数传递给`字符串`格式。这对于Unity项目来说是一个问题，因为它们使用与正常.NET运行时不同的内存垃圾回收器。对于非Unity项目，如本书中的所有项目，你可以忽略这些装箱警告，因为它们不相关。你可以在以下链接中了解更多关于此Unity特定问题的信息：[https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing](https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing)。
- en: Formatting using interpolated strings
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用插值字符串进行格式化
- en: 'C# 6 and later have a handy feature named **interpolated strings**. A `string`
    prefixed with `$` can use curly braces around the name of a variable or expression
    to output the current value of that variable or expression at that position in
    the `string`, as the following shows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6及以后版本有一个方便的功能，称为**插值字符串**。以`$`为前缀的`字符串`可以使用大括号包围变量或表达式的名称来输出该变量或表达式在该位置在`字符串`中的当前值，如下所示：
- en: 'Enter a statement at the bottom of the `Program.cs` file, as shown in the following
    code:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件的底部输入一条语句，如下面的代码所示：
- en: '[PRE90]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run the code and view the result, as shown in the following partial output:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的部分输出所示：
- en: '[PRE91]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: For short, formatted `string` values, an interpolated `string` can be easier
    for people to read. But for code examples in a book, where statements need to
    wrap over multiple lines, this can be tricky. For many of the code examples in
    this book, I will use numbered positional arguments. Another reason to avoid interpolated
    strings is that they can’t be read from resource files to be localized.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对于短且格式化的`字符串`值，插值`字符串`可能更容易阅读。但对于书中需要跨多行包裹的代码示例，这可能会变得复杂。在这本书的许多代码示例中，我将使用编号的位置参数。避免插值字符串的另一个原因是它们不能从资源文件中读取以进行本地化。
- en: The next code example is not meant to be entered in your project.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例不打算在您的项目中输入。
- en: 'Before C# 10, `string` constants could only be combined by using concatenation
    with the `+` operator, as shown in the following code:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10之前，`字符串`常量只能通过使用`+`运算符进行连接来组合，如下面的代码所示：
- en: '[PRE92]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'With C# 10, interpolated strings (prefixed with `$`) can now be used, as shown
    in the following code:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10中，插值字符串（以`$`为前缀）现在可以使用了，如下面的代码所示：
- en: '[PRE93]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This only works for combining `string` constant values. It cannot work with
    other types like numbers, which would require runtime data type conversions. You
    cannot enter `private const` declarations in a top-level program like `Program.cs`.
    You will see how to use them in *Chapter 5*, *Building Your Own Types with Object-Oriented
    Programming*.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅适用于组合`字符串`常量值。它不能与其他类型（如数字）一起使用，这需要运行时数据类型转换。你无法在顶级程序（如`Program.cs`）中输入`private
    const`声明。你将在*第5章*，*使用面向对象编程构建自己的类型*中看到如何使用它们。
- en: '**Good Practice**: If you are writing code that will be part of a Unity project,
    then interpolated string formats are an easy way to avoid boxing.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果你正在编写的代码将成为Unity项目的一部分，那么插值字符串格式是一种避免装箱的简单方法。'
- en: Understanding format strings
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解格式字符串
- en: A variable or expression can be formatted using a format string after a comma
    or colon.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 变量或表达式可以使用格式字符串在逗号或冒号之后进行格式化。
- en: An `N0` format string means a number with thousands separators and no decimal
    places, while a `C` format string means currency. The currency format will be
    determined by the current thread.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`N0`格式字符串表示带有千位分隔符且没有小数位的数字，而`C`格式字符串表示货币。货币格式将由当前线程决定。'
- en: For instance, if you run code that uses the number or currency format on a PC
    in the UK, you’ll get pounds sterling with commas as the thousands separators,
    but if you run it on a PC in Germany, you will get euros with dots as the thousands
    separators.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在英国的PC上运行使用数字或货币格式的代码，你会得到带有逗号作为千位分隔符的英镑，但如果你在德国的PC上运行它，你会得到带有点作为千位分隔符的欧元。
- en: 'The full syntax of a format item is:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 格式项的完整语法是：
- en: '[PRE94]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Each format item can have an alignment, which is useful when outputting tables
    of values, some of which might need to be left- or right-aligned within a width
    of characters. Alignment values are integers. Positive integers mean right-aligned
    and negative integers mean left-aligned.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 每个格式项都可以有一个对齐方式，这在输出值表时很有用，其中一些值可能需要在字符宽度内左对齐或右对齐。对齐值是整数。正整数表示右对齐，负整数表示左对齐。
- en: 'For example, to output a table of fruit and how many of each there are, we
    might want to left-align the names within a column of 10 characters and right-align
    the counts formatted as numbers with zero decimal places within a column of six
    characters:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要输出一个水果及其数量的表格，我们可能希望将名称左对齐在 10 个字符宽的列中，并将计数格式化为没有小数位的数字，右对齐在 6 个字符宽的列中：
- en: 'At the bottom of `Program.cs`, enter the following statements:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的底部输入以下语句：
- en: '[PRE95]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Run the code and note the effect of the alignment and number format, as shown
    in the following output:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意对齐和数字格式的影响，如下面的输出所示：
- en: '[PRE96]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Custom number formatting
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义数字格式
- en: 'You can take complete control of number formatting using custom format codes,
    as shown in *Table 2.7*:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自定义格式代码完全控制数字格式，如 *表 2.7* 所示：
- en: '| **Format code** | **Description** |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| **格式代码** | **描述** |'
- en: '| `0` | Zero placeholder. Replaces the zero with the corresponding digit if
    present; otherwise, it uses zero. For example, `0000.00` formatting the value
    `123.4` would give `0123.40`. |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 零占位符。如果存在，则用相应的数字替换零；否则，使用零。例如，`0000.00` 格式化值 `123.4` 将给出 `0123.40`。|'
- en: '| `#` | Digit placeholder. Replaces the hash with the corresponding digit if
    present; otherwise, it uses nothing. For example, `####.##` formatting the value
    `123.4` would give `123.4`. |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| `#` | 数字占位符。如果存在，则用相应的数字替换井号；否则，不使用任何内容。例如，`####.##` 格式化值 `123.4` 将给出 `123.4`。|'
- en: '| `.` | Decimal point. Sets the location of the decimal point in the number.
    Respects culture formatting, so it is a `.` (dot) in US English but a `,` (comma)
    in French. |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 小数点。设置数字中小数点的位置。尊重文化格式，因此在美式英语中是 `.`（点），在法语中是 `,`（逗号）。|'
- en: '| `,` | Group separator. Inserts a localized group separator between each group.
    For example, `0,000` formatting the value `1234567` would give `1,234,567`. Also
    used to scale a number by dividing by multiples of 1,000 for each comma. For example,
    `0.00,,` formatting the value `1234567` would give `1.23` because the two commas
    mean divide by 1,000 twice. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 分组分隔符。在每个组之间插入本地化的分组分隔符。例如，`0,000` 格式化值 `1234567` 将给出 `1,234,567`。还用于通过每个逗号除以
    1,000 的倍数来缩放数字。例如，`0.00,,` 格式化值 `1234567` 将给出 `1.23`，因为两个逗号意味着除以 1,000 两次。|'
- en: '| `%` | Percentage placeholder. Multiplies the value by 100 and adds a percentage
    character. |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 百分比占位符。将值乘以 100 并添加一个百分比符号。|'
- en: '| `\` | Escape character. Makes the next character a literal instead of a format
    code. For example, `\##,###\#` formatting the value `1234` would give `#1,234#`.
    |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 转义字符。使下一个字符成为字面值而不是格式代码。例如，`\##,###\#` 格式化值 `1234` 将给出 `#1,234#`。|'
- en: '| `;` | Section separator. Defines different format strings for positive, negative,
    and zero numbers. For example, `[0];(0);Zero` formatting: `13` would give `[13]`,
    `-13` would give `(13)`, and `0` would give `Zero`. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| `;` | 部分分隔符。为正数、负数和零定义不同的格式字符串。例如，`[0];(0);Zero` 格式化：`13` 将给出 `[13]`，`-13`
    将给出 `(13)`，而 `0` 将给出 `Zero`。|'
- en: '| Others | All other characters are shown in the output as is. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| 其他 | 所有其他字符在输出中按原样显示。|'
- en: 'Table 2.7: Custom numeric format codes'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.7：自定义数字格式代码
- en: '**More Information**: A full list of custom number format codes can be found
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings).'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：完整的自定义数字格式代码列表可以在以下链接中找到：[https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings).'
- en: 'You can apply standard number formatting using simpler format codes, like `C`
    and `N`. They support a precision number to indicate how many digits of precision
    you want. The default is two. The most common are shown in *Table 2.8*:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用更简单的格式代码应用标准数字格式，例如 `C` 和 `N`。它们支持一个精度数字来指示您想要多少位精度。默认值为两位。最常见的一些格式代码在
    *表 2.8* 中展示：
- en: '| **Format code** | **Description** |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| **格式代码** | **描述** |'
- en: '| `C` or `c` | Currency. For example, in US culture, `C` formatting the value
    `123.4` gives `$123.40`, and `C0` formatting the value `123.4` gives `$123`. |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| `C` 或 `c` | 货币。例如，在美国文化中，`C` 格式化值 `123.4` 给出 `$123.40`，而 `C0` 格式化值 `123.4`
    给出 `$123`。 |'
- en: '| `N` or `n` | Number. Integer digits with an optional negative sign and grouping
    characters. |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| `N` 或 `n` | 数字。整数数字，可选带负号和分组字符。 |'
- en: '| `D` or `d` | Decimal. Integer digits with an optional negative sign but no
    grouping characters. |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| `D` 或 `d` | 小数。整数数字，可选带负号但没有分组字符。 |'
- en: '| `B` or `b` | Binary. For example, `B` formatting the value `13` gives `1101`,
    and `B8` formatting the value `13` gives `00001101`. |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| `B` 或 `b` | 二进制。例如，`B` 格式化值 `13` 给出 `1101`，而 `B8` 格式化值 `13` 给出 `00001101`。
    |'
- en: '| `X` or `x` | Hexadecimal. For example, `X` formatting the value `255` gives
    `FF`, and `X4` formatting the value `255` gives `00FF`. |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| `X` 或 `x` | 十六进制。例如，`X` 格式化值 `255` 给出 `FF`，而 `X4` 格式化值 `255` 给出 `00FF`。 |'
- en: '| `E` or `e` | Exponential notation. For example, `E` formatting the value
    `1234.567` would give `1.234567000E+003`, and `E2` formatting the value `1234.567`
    would give `1.23E+003`. |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| `E` 或 `e` | 指数表示法。例如，`E` 格式化值 `1234.567` 将给出 `1.234567000E+003`，而 `E2` 格式化值
    `1234.567` 将给出 `1.23E+003`。 |'
- en: 'Table 2.8: Standard numeric format codes'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.8：标准数字格式代码
- en: '**More Information**: A full list of standard number format codes can be found
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings).'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：标准数字格式代码的完整列表可以在以下链接中找到：[https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings).'
- en: 'You can take complete control of date and time formatting using custom format
    codes, as shown in *Table 2.9*:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用自定义格式代码完全控制日期和时间格式化，如下表 2.9 所示：
- en: '| **Format code** | **Description** |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| **格式代码** | **描述** |'
- en: '| `/` | Date part separator. Varies by culture; for example, `en-US` uses `/`
    but `fr-FR` uses `-` (dash). |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 日期部分分隔符。因文化而异；例如，`en-US` 使用 `/`，而 `fr-FR` 使用 `-`（破折号）。 |'
- en: '| `\` | Escape character. Useful if you want to use a special format code as
    a literal character; for example, `h \h m \m` would format a time of 9:30 AM as
    `9 h 30 m`. |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 转义字符。如果你想在特殊格式代码中用作字面字符，则很有用；例如，`h \h m \m` 将格式化为上午 9:30，显示为 `9 h 30
    m`。 |'
- en: '| `:` | Time part separator. Varies by culture; for example, `en-US` uses `:`
    but `fr-FR` uses `.` (dot). |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| `:` | 时间部分分隔符。因文化而异；例如，`en-US` 使用 `:`，而 `fr-FR` 使用 `.`（点）。 |'
- en: '| `d`, `dd` | The day of the month, from `1` to `31`, or with a leading zero
    from `01` through `31`. |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| `d`, `dd` | 月份中的日期，从 `1` 到 `31`，或从 `01` 到 `31` 带前导零。 |'
- en: '| `ddd`, `dddd` | The abbreviated or full name of the day of the week, for
    example, `Mon` or `Monday`, localized for the current culture. |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| `ddd`, `dddd` | 星期几的缩写或全称，例如，`Mon` 或 `Monday`，针对当前文化本地化。 |'
- en: '| `f`, `ff`, `fff` | The tenths of a second, hundredths of a second, or milliseconds.
    |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| `f`, `ff`, `fff` | 十分之一秒、百分之一秒或毫秒。 |'
- en: '| `g` | The period or era, for example, `A.D.` |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 时期或纪元，例如，`A.D.` |'
- en: '| `h`, `hh` | The hour, using a 12-hour clock from `1` to `12`, or from `01`
    to `12`. |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| `h`, `hh` | 使用从 `1` 到 `12` 的 12 小时制的小时，或从 `01` 到 `12`。 |'
- en: '| `H`, `HH` | The hour, using a 24-hour clock from `0` to `23`, or from `01`
    to `23`. |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| `H`, `HH` | 小时，使用从 `0` 到 `23` 的 24 小时制，或从 `01` 到 `23`。 |'
- en: '| `K` | Time zone information. `null` for an unspecified time zone, `Z` for
    UTC, and a value like `-8:00` for local time adjusted from UTC. |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| `K` | 时区信息。`null` 表示未指定时区，`Z` 表示 UTC，以及从 UTC 调整的本地时间，例如 `-8:00`。 |'
- en: '| `m`, `mm` | The minute, from `0` through `59`, or with a leading zero from
    `00` through `59`. |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| `m`, `mm` | 分钟，从 `0` 到 `59`，或从 `00` 到 `59` 带前导零。 |'
- en: '| `M`, `MM` | The month, from `1` through `12`, or with a leading zero from
    `01` through `12`. |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| `M`, `MM` | 月份，从 `1` 到 `12`，或从 `01` 到 `12` 带前导零。 |'
- en: '| `MMM`, `MMMM` | The abbreviated or full name of the month, for example, `Jan`
    or `January`, localized for the current culture. |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| `MMM`, `MMMM` | 月份的缩写或全称，例如，`Jan` 或 `January`，针对当前文化本地化。 |'
- en: '| `s`, `ss` | The second, from `0` through `59`, or with a leading zero from
    `00` through `59`. |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| `s`, `ss` | 秒，从 `0` 到 `59`，或从 `00` 到 `59` 带前导零。 |'
- en: '| `t`, `tt` | The first or both characters of the AM/PM designator. |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| `t`, `tt` | AM/PM 标识符的第一个或前两个字符。 |'
- en: '| `y`, `yy` | The year of the current century, from `0` through `99`, or with
    a leading zero from `00` through `99`. |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| `y`, `yy` | 当前世纪的年份，从 `0` 到 `99`，或从 `00` 到 `99` 带前导零。 |'
- en: '| `yyy` | The year with a minimum of three digits, and as many as needed. For
    example, 1 A.D. is `001`. The first sacking of Rome was in `410`. The year the
    first edition of this book was published in `2016`. |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| `yyy` | 年份，至少三位数字，所需位数。例如，公元 1 年是 `001`。罗马城第一次被攻陷是在 `410` 年。本书第一版出版于 `2016`
    年。|'
- en: '| `yyyy`, `yyyyy` | The year as a four- or five-digit number. |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| `yyyy`, `yyyyy` | 四位或五位数的年份。|'
- en: '| `z`, `zz` | Hours offset from UTC, with no leading zeros, or with leading
    zeros. |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| `z`, `zz` | UTC 偏移的小时，无前导零，或带前导零。|'
- en: '| `zzz` | Hours and minutes offset from UTC, with a leading zero, for example,
    `+04:30`. |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| `zzz` | UTC 偏移的小时和分钟，带前导零，例如，`+04:30`。|'
- en: 'Table 2.9: Custom format codes for date and time values'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.9：日期和时间值的自定义格式代码
- en: '**More Information**: A full list of custom format codes can be found at the
    following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings).'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：完整的自定义格式代码列表可以在以下链接中找到：[https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings)。'
- en: 'You can apply standard date and time formatting using simpler format codes,
    like the `d` and `D` we used in the code example, as shown in *Table 2.10*:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用更简单的格式代码来应用标准的日期和时间格式，例如我们在代码示例中使用的 `d` 和 `D`，如下表 2.10 所示：
- en: '| **Format code** | **Description** |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| **格式代码** | **描述** |'
- en: '| `d` | Short date pattern. Varies by culture; for example, `en-US` uses `M/d/yyyy`
    and `fr-FR` uses `dd/MM/yyyy`. |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 短日期模式。因文化而异；例如，`en-US` 使用 `M/d/yyyy`，而 `fr-FR` 使用 `dd/MM/yyyy`。|'
- en: '| `D` | Long date pattern. Varies by culture; for example, `en-US` uses `mmmm,
    MMMM d, yyyy` and `fr-FR` uses `mmmm, dd MMMM yyyy`. |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 长日期模式。因文化而异；例如，`en-US` 使用 `mmmm, MMMM d, yyyy`，而 `fr-FR` 使用 `mmmm,
    dd MMMM yyyy`。|'
- en: '| `f` | Full date/time pattern (short time – hours and minutes). Varies by
    culture. |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 完整的日期/时间模式（短时间 - 小时和分钟）。因文化而异。|'
- en: '| `F` | Full date/time pattern (long time – hours, minutes, seconds, and AM/PM).
    Varies by culture. |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 完整的日期/时间模式（长时间 – 小时、分钟、秒和 AM/PM）。因文化而异。|'
- en: '| `m`, `M` | Month/day pattern. Varies by culture. |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| `m`, `M` | 月份/日期模式。因文化而异。|'
- en: '| `o,` `O` | A standardized pattern, suitable to serialize date/time values
    for roundtrips, for example, `2023-05-30T13:45:30.0000000-08:00`. |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| `o,` `O` | 标准化模式，适合序列化日期/时间值进行往返，例如，`2023-05-30T13:45:30.0000000-08:00`。|'
- en: '| `r`, `R` | RFC1123 pattern. |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| `r`, `R` | RFC1123 模式。|'
- en: '| `t` | Short time pattern. Varies by culture; for example, `en-US` uses `h:mm
    tt` and `fr-FR` uses `HH:mm`. |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 短时间模式。因文化而异；例如，`en-US` 使用 `h:mm tt`，而 `fr-FR` 使用 `HH:mm`。|'
- en: '| `T` | Long time pattern. Varies by culture; for example, `en-US` uses `h:mm:ss
    tt` and `fr-FR` uses `HH:mm:ss`. |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| `T` | 长时间模式。因文化而异；例如，`en-US` 使用 `h:mm:ss tt`，而 `fr-FR` 使用 `HH:mm:ss`。|'
- en: '| `u` | Universal sortable date/time pattern, for example, `2009-06-15 13:45:30Z`.
    |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| `u` | 通用可排序日期/时间模式，例如，`2009-06-15 13:45:30Z`。|'
- en: '| `U` | Universal full date/time pattern. Varies by culture; for example, `en-US`
    might be `Monday, June 15, 2009 8:45:30 PM`. |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| `U` | 通用完整日期/时间模式。因文化而异；例如，`en-US` 可能是 `Monday, June 15, 2009 8:45:30 PM`。|'
- en: 'Table 2.10: Standard format codes for date and time values'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.10：日期和时间值的标准格式代码
- en: '**More Information**: A full list of format codes can be found at the following
    link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings).'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：完整的格式代码列表可以在以下链接中找到：[https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings)。'
- en: '**Warning!** Note the difference between `"m"` (a shorthand for the month/day
    format, like July 4 in USA or 4 July in UK, which omits the year and presents
    the month and day in a culture-specific manner) and `"d m"` (a custom format string
    that displays the day number and then the month number with a space in between,
    like 4 7 in any country for 4^(th) July).'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**！注意 `"m"`（月份/日期格式的缩写，如美国的 7 月 4 日或英国的 4 July，省略年份并以文化特定方式呈现月份和日期）与 `"d
    m"`（自定义格式字符串，显示日期编号，然后是月份编号，中间有空格，如任何国家的 4 7 表示 7 月 4 日）之间的区别。'
- en: 'Let’s see how to output a value using multiple formats:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用多种格式输出值：
- en: 'Type statements to output a `decimal` value twice, first as currency using
    the current culture, and then as a percentage, as shown in the following code:'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以输出两次`十进制`值，首先使用当前文化作为货币，然后作为百分比，如下面的代码所示：
- en: '[PRE97]'
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE98]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Getting text input from the user
  id: totrans-697
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户获取文本输入
- en: We can get text input from the user using the `ReadLine` method. This method
    waits for the user to type some text. Then, as soon as the user presses *Enter*,
    whatever the user has typed is returned as a `string` value.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ReadLine`方法从用户获取文本输入。此方法等待用户输入一些文本。然后，当用户按下*Enter*时，用户输入的内容将作为`string`值返回。
- en: 'Let’s get input from the user:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取用户的输入：
- en: 'Type statements to ask the user for their name and age and then output what
    they entered, as shown in the following code:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以询问用户他们的姓名和年龄，然后输出他们输入的内容，如下面的代码所示：
- en: '[PRE99]'
  id: totrans-701
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: By default, with .NET 6 and later, nullability checks are enabled, so the C#
    compiler gives two warnings because the `ReadLine` method could return a `null`
    value instead of a `string` value. But there is no practical scenario where this
    method would actually return `null`, so instead, we will see how to switch off
    these specific warnings in this scenario.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在.NET 6及更高版本中，启用空值检查，因此C#编译器会给出两个警告，因为`ReadLine`方法可能会返回一个`null`值而不是`string`值。但实际上，这种方法返回`null`的场景并不实用，所以我们将在这个场景中了解如何关闭这些特定的警告。
- en: 'For the `firstName` variable, append a `?` after `string`, as shown highlighted
    in the following code:'
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`firstName`变量，在`string`后面添加一个`?`，如下面的代码所示：
- en: '[PRE100]'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This tells the compiler that we are expecting a possible `null` value, so it
    does not need to warn us. If the variable is `null`, then when it is later output
    with `WriteLine`, it will just be blank, so that works fine in this case. If we
    were going to access any of the members of the `firstName` variable, then we would
    need to handle the case where it is `null`.
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉编译器我们期望一个可能的`null`值，因此它不需要警告我们。如果变量是`null`，那么当它稍后通过`WriteLine`输出时，它将只是一个空白，所以在这种情况下是可行的。如果我们打算访问`firstName`变量的任何成员，那么我们就需要处理它可能是`null`的情况。
- en: 'For the `age` variable, append a `!` before the semicolon at the end of the
    statement, as shown highlighted in the following code:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`age`变量，在语句末尾的分号前添加一个`!`，如下面的代码所示：
- en: '[PRE101]'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This is called the **null-forgiving operator** because it tells the compiler
    that, in this case, `ReadLine` will not return `null`, so it can stop showing
    the warning. It is now our responsibility to ensure this is the case. Luckily,
    the `Console` type’s implementation of `ReadLine` always returns a `string` even
    if it is just an empty `string` value.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**null-forgiving operator**，因为它告诉编译器在这种情况下`ReadLine`不会返回`null`，因此它可以停止显示警告。现在，我们负责确保这一点。幸运的是，`Console`类型的`ReadLine`实现总是返回一个`string`，即使它只是一个空的`string`值。
- en: 'Run the code, and then enter a name and age, as shown in the following output:'
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，然后输入一个姓名和年龄，如下面的输出所示：
- en: '[PRE102]'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You have now seen two common ways to handle nullability warnings from the compiler.
    We will cover nullability and how to handle it in more detail in *Chapter 6*,
    *Implementing Interfaces and Inheriting Classes*.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了处理编译器空值警告的两种常见方法。我们将在*第6章*，*实现接口和继承类*中更详细地介绍空值和如何处理它。
- en: When does ReadLine return null?
  id: totrans-712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ReadLine`何时返回`null`？'
- en: The `ReadLine` method reads the next line of input from the standard input stream.
    If the user presses *Enter* without typing anything, `ReadLine` will return an
    empty string, not `null`.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadLine`方法从标准输入流中读取下一行输入。如果用户按下*Enter*而没有输入任何内容，`ReadLine`将返回一个空字符串，而不是`null`。'
- en: In typical console apps, `ReadLine` returns `null` only if the **end of stream**
    (**EOF**) is reached. This is not something that can usually be achieved by user
    input in a standard console environment since EOF is typically signaled by the
    console being closed or redirected input being fully consumed.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的控制台应用程序中，`ReadLine`仅在达到**流末尾**（**EOF**）时返回`null`。这通常不是在标准控制台环境中通过用户输入实现的，因为EOF通常由控制台关闭或重定向输入被完全消耗来表示。
- en: 'In the context of the following code:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码的上下文中：
- en: '[PRE103]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here are the conditions under which `name` might be `null`:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`name`可能为`null`的条件：
- en: If the standard input stream is redirected and reaches EOF
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果标准输入流被重定向并达到EOF
- en: If you are testing in an environment where you can simulate EOF, like some development
    environments or automated testing setups
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在一个可以模拟 EOF 的环境中进行测试，例如某些开发环境或自动化测试设置
- en: However, under normal user input conditions, `null` will “never” be returned
    by the `ReadLine` method.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在正常用户输入条件下，`ReadLine` 方法“永远不会”返回 `null`。
- en: Simplifying the usage of the console
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化控制台的使用
- en: In C# 6 and later, the `using` statement can be used not only to import a namespace
    but also to further simplify our code by importing a static class. Then, we won’t
    need to enter the `Console` type name throughout our code.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 及更高版本中，`using` 语句不仅可以用于导入命名空间，还可以通过导入静态类进一步简化我们的代码。然后，我们就不需要在代码中输入 `Console`
    类型名称。
- en: Importing a static type for a single file
  id: totrans-723
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为单个文件导入静态类型
- en: 'You can use your code editor’s **Find and Replace** feature to remove the times
    we have previously written `Console`:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用代码编辑器的 **查找和替换** 功能来删除我们之前写过的 `Console`：
- en: 'At the top of the `Program.cs` file, add a statement to **statically import**
    the `System.Console` class, as shown in the following code:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件顶部添加一个语句以 **静态导入** `System.Console` 类，如下面的代码所示：
- en: '[PRE104]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Select the first `Console.` in your code, ensuring that you select the dot after
    the word `Console` too.
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码中选择第一个 `Console.`，确保您也选择了 `Console` 单词后面的点。
- en: 'In Visual Studio, navigate to **Edit** | **Find and Replace** | **Quick Replace**;
    in VS Code, navigate to **Edit** | **Replace**; or in Rider, navigate to **Edit**
    | **Find** | **Replace**, and note that an overlay dialog appears ready for you
    to enter what you would like to replace `Console.` with, as shown in *Figure 2.9*:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，导航到 **编辑** | **查找和替换** | **快速替换**；在 VS Code 中，导航到 **编辑** |
    **替换**；或者在 Rider 中，导航到 **编辑** | **查找** | **替换**，并注意会出现一个覆盖对话框，供您输入要替换 `Console.`
    的内容，如图 2.9 所示：
- en: '![](img/B22322_02_09.png)'
  id: totrans-729
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_09.png)'
- en: 'Figure 2.9: Using the Replace feature in Visual Studio to simplify your code'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：使用 Visual Studio 中的替换功能简化代码
- en: Leave the **Replace** box empty, click on the **Replace all** button (the second
    of the two buttons to the right of the **Replace** box), and then close the **Replace**
    box by clicking on the cross in its top-right corner.
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持 **替换** 框为空，点击 **替换所有** 按钮（位于 **替换** 框右侧的两个按钮中的第二个），然后通过点击右上角的叉号关闭 **替换**
    框。
- en: Run the console app and note the behavior is the same as before.
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意行为与之前相同。
- en: Importing a static type for all code files in a project
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为项目中的所有代码文件导入静态类型
- en: 'Instead of statically importing the `Console` class just for one code file,
    it would probably be better to import it globally for all code files in the project:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是只为单个代码文件静态导入 `Console` 类，可能更好的做法是为项目中的所有代码文件全局导入：
- en: Delete the statement to statically import `System.Console`.
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除静态导入 `System.Console` 的语句。
- en: 'Open `Formatting.csproj`, and after the `<PropertyGroup>` section, add a new
    `<ItemGroup>` section to globally and statically import `System.Console` using
    the implicit `using` .NET SDK feature, as shown in the following markup:'
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Formatting.csproj` 文件，在 `<PropertyGroup>` 部分之后，添加一个新的 `<ItemGroup>` 部分以全局和静态地导入
    `System.Console`，使用隐式的 .NET SDK 功能，如下面的标记所示：
- en: '[PRE105]'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**Good Practice**: The `Label` attribute within an `<ItemGroup>` in .NET projects
    is optional but useful for several reasons, primarily revolving around organization,
    customization, and clarity in the build process. When multiple `<ItemGroup>` sections
    are used, labels provide a clear indication of what each group contains. Using
    labels, you can conditionally include or exclude certain items based on build
    configurations or other conditions. In this case, we are just using it for documentation.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在 .NET 项目中的 `<ItemGroup>` 内部的 `Label` 属性是可选的但非常有用，主要原因围绕组织、定制和构建过程中的清晰度。当使用多个
    `<ItemGroup>` 部分时，标签提供了对每个组包含内容的明确指示。使用标签，您可以根据构建配置或其他条件有条件地包含或排除某些项目。在这种情况下，我们只是用它来编写文档。'
- en: Run the console app and note that the behavior is the same as before.
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意行为与之前相同。
- en: '**Good Practice**: In the future, for all console app projects you create for
    this book, add the section above to simplify the code you need to write in all
    C# files to work with the `Console` class.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：将来，对于您为本书创建的所有控制台应用程序项目，添加上述部分以简化所有 C# 文件中与 `Console` 类一起工作所需编写的代码。'
- en: Getting key input from the user
  id: totrans-741
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户获取键输入
- en: We can get key input from the user using the `ReadKey` method. This method waits
    for the user to press a key or key combination, which is then returned as a `ConsoleKeyInfo`
    value.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ReadKey`方法从用户那里获取键输入。此方法等待用户按下键或键组合，然后将其作为`ConsoleKeyInfo`值返回。
- en: 'Let’s explore reading key presses:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索如何读取按键：
- en: 'Type statements to ask the user to press any key combination and then output
    information about it, as shown in the following code:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以提示用户按下任何键组合，然后输出有关该组合的信息，如下面的代码所示：
- en: '[PRE106]'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Run the code, press the *K* key, and note the result, as shown in the following
    output:'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按下*K*键，注意结果，如下面的输出所示：
- en: '[PRE107]'
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Run the code, hold down *Shift* and press the *K* key, and note the result,
    as shown in the following output:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按住*Shift*键并按下*K*键，注意结果，如下面的输出所示：
- en: '[PRE108]'
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Run the code, press the *F12* key, and note the result, as shown in the following
    output:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按下*F12*键，注意结果，如下面的输出所示：
- en: '[PRE109]'
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '**Warning!** When running a console app in a terminal within VS Code, some
    keyboard combinations will be captured by the code editor before they can be processed
    by your console app. For example, *Ctrl* + *Shift* + *X* in VS Code activates
    the **Extensions** view in the sidebar. To fully test this console app, open a
    command prompt or terminal in the project folder and run the console app from
    there.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 当在VS Code中的终端内运行控制台应用程序时，一些键盘组合会在它们被你的控制台应用程序处理之前被代码编辑器捕获。例如，在VS Code中*Ctrl*
    + *Shift* + *X*组合会激活侧边栏中的**扩展**视图。要完全测试此控制台应用程序，请在项目文件夹中打开命令提示符或终端，并从那里运行控制台应用程序。'
- en: Passing arguments to a console app
  id: totrans-753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将参数传递给控制台应用程序
- en: 'When you run a console app, you often want to change its behavior by passing
    arguments. For example, with the `dotnet` command-line tool, you can pass the
    name of a new project template, as shown in the following commands:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行控制台应用程序时，你通常希望通过传递参数来改变其行为。例如，使用`dotnet`命令行工具，你可以传递新项目模板的名称，如下面的命令所示：
- en: '[PRE110]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You might have been wondering how to get any arguments that might be passed
    to a console app.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何获取传递给控制台应用程序的任何参数。
- en: 'In every version of .NET prior to version 6, the console app project template
    made it obvious, as shown in the following code:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6之前的每个版本中，控制台应用程序项目模板都使其非常明显，如下面的代码所示：
- en: '[PRE111]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `string[] args` arguments are declared and passed in the `Main` method of
    the `Program` class. They’re an array used to pass arguments into a console app.
    But in top-level programs, as used by the console app project template in .NET
    6 and later, the `Program` class and its `Main` method are hidden, along with
    the declaration of the `args` array. The trick is that you must know it still
    exists.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '`string[] args`参数在`Program`类的`Main`方法中声明并传递。它们是一个用于将参数传递到控制台应用程序的数组。但在顶级程序中，如.NET
    6及以后的.NET控制台应用程序项目模板所使用的，`Program`类及其`Main`方法以及`args`数组的声明都是隐藏的。诀窍是您必须知道它仍然存在。'
- en: Command-line arguments are separated by spaces. Other characters like hyphens
    and colons are treated as part of an argument value.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数由空格分隔。其他字符，如连字符和冒号，被视为参数值的一部分。
- en: To include spaces in an argument value, enclose the argument value in single
    or double quotes.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 要在参数值中包含空格，请将参数值用单引号或双引号括起来。
- en: 'Imagine that we want to be able to enter the names of some colors for the foreground
    and background and the dimensions of the terminal window at the command line.
    We would be able to read the colors and numbers by reading them from the `args`
    array, which is always passed into the `Main` method, aka the entry point of a
    console app:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在命令行中输入一些颜色的名称，用于前景和背景，以及终端窗口的尺寸。我们可以通过从`args`数组中读取它们来读取颜色和数字，该数组总是传递给`Main`方法，也就是控制台应用程序的入口点：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Arguments` to the `Chapter02` solution.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，向`Chapter02`解决方案中添加一个名为`Arguments`的新**Console App** / `console`项目。
- en: 'Open `Arguments.csproj`, and after the `<PropertyGroup>` section, add a new
    `<ItemGroup>` section to statically import `System.Console` for all C# files using
    the implicit usings .NET SDK feature, as shown in the following markup:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Arguments.csproj`，在`<PropertyGroup>`部分之后，添加一个新的`<ItemGroup>`部分，使用.NET SDK的隐式使用功能静态导入所有C#文件中的`System.Console`，如下面的标记所示：
- en: '[PRE112]'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '**Good Practice**: Remember to use the implicit using .NET SDK feature to statically
    import the `System.Console` type in all future console app projects to simplify
    your code, as these instructions will not be repeated every time.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：请记住使用隐式使用 .NET SDK 功能，在所有未来的控制台应用程序项目中静态导入 `System.Console` 类型，以简化你的代码，因为这些说明不会每次都重复。'
- en: 'In `Program.cs`, delete the existing statements and then add a statement to
    output the number of arguments passed to the application, as shown in the following
    code:'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句，然后添加一个语句来输出传递给应用程序的参数数量，如下面的代码所示：
- en: '[PRE113]'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Run the console app and view the result, as shown in the following output:'
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看结果，如下面的输出所示：
- en: '[PRE114]'
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If you are using Visual Studio:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio：
- en: Navigate to **Project** | **Arguments** **Properties**.
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **项目** | **参数** **属性**。
- en: 'Select the **Debug** tab, click **Open debug launch profiles UI**, and in the
    **Command line arguments** box, enter the following arguments: `firstarg second-arg
    third:arg "fourth arg"`, as shown in *Figure 2.10*:'
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **调试** 选项卡，点击 **打开调试启动配置文件UI**，在 **命令行参数** 框中，输入以下参数：`firstarg second-arg
    third:arg "fourth arg"`，如图 *2.10* 所示：
- en: '![](img/B22322_02_10.png)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_02_10.png)'
- en: 'Figure 2.10: Entering command line arguments in the Visual Studio project properties'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：在Visual Studio项目属性中输入命令行参数
- en: Close the **Launch Profiles** window.
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 **启动配置文件** 窗口。
- en: 'In **Solution Explorer**, in the `Properties` folder, open the `launchSettings.json`
    file and note it defines the command-line arguments when you run the project,
    as shown highlighted in the following configuration:'
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中，在 `Properties` 文件夹中，打开 `launchSettings.json` 文件并注意它定义了当你运行项目时的命令行参数，如图中高亮显示的以下配置所示：
- en: '[PRE115]'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `launchSettings.json` file can also be used by Rider. The equivalent for
    VS Code is the `.vscode/launch.json` file.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '`launchSettings.json` 文件也可以被 Rider 使用。VS Code 的等效文件是 `.vscode/launch.json`
    文件。'
- en: Run the console app project.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序项目。
- en: 'If you are using VS Code, then in **Terminal**, enter some arguments after
    the `dotnet run` command, as shown in the following command:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 VS Code，那么在 **终端** 中，在 `dotnet run` 命令之后输入一些参数，如下面的命令所示：
- en: '[PRE116]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'For all code editors:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有代码编辑器：
- en: 'Note that the result indicates four arguments, as shown in the following output:'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到结果指示有四个参数，如下面的输出所示：
- en: '[PRE117]'
  id: totrans-785
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'In `Program.cs`, to enumerate or iterate (that is, loop through) the values
    of those four arguments, add the following statements after outputting the length
    of the array:'
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，为了枚举或迭代（即，遍历）这四个参数的值，在输出数组长度之后添加以下语句：
- en: '[PRE118]'
  id: totrans-787
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Run the code again and note that the result shows the details of the four arguments,
    as shown in the following output:'
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码并注意结果显示了四个参数的详细信息，如下面的输出所示：
- en: '[PRE119]'
  id: totrans-789
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Setting options with arguments
  id: totrans-790
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用参数设置选项
- en: We will now use these arguments to allow the user to pick a color for the background,
    foreground, and cursor size of the output window. The cursor size can be an integer
    value from 1, meaning a line at the bottom of the cursor cell, up to 100, meaning
    a percentage of the height of the cursor cell.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用这些参数来允许用户选择输出窗口的背景、前景和光标大小。光标大小可以是1到100的整数，其中1表示光标单元格底部的线条，100表示光标单元格高度的百分比。
- en: We have statically imported the `System.Console` class. It has properties like
    `ForegroundColor`, `BackgroundColor`, and `CursorSize` that we can now set just
    by using their names without needing to prefix them with `Console`.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经静态导入了 `System.Console` 类。它具有 `ForegroundColor`、`BackgroundColor` 和 `CursorSize`
    等属性，我们现在可以通过使用它们的名称来设置，而不需要用 `Console` 前缀。
- en: 'The `System` namespace is already imported so that the compiler knows about
    the `ConsoleColor` and `Enum` types:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '`System` 命名空间已经导入，以便编译器了解 `ConsoleColor` 和 `Enum` 类型：'
- en: 'Add statements to warn the user if they do not enter three arguments, and then
    parse those arguments and use them to set the color and dimensions of the console
    window, as shown in the following code:'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加语句以警告用户如果没有输入三个参数，然后解析这些参数并使用它们来设置控制台窗口的颜色和尺寸，如下面的代码所示：
- en: '[PRE120]'
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note the compiler warning that setting the `CursorSize` is only supported on
    Windows. For now, do not worry about most of this code like `(ConsoleColor)`,
    `Enum.Parse`, or `typeof`, as it will all be explained in the next few chapters.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到编译器警告，设置 `CursorSize` 只在 Windows 上受支持。目前，不要担心大多数此代码，如 `(ConsoleColor)`、`Enum.Parse`
    或 `typeof`，因为所有这些将在接下来的几章中解释。
- en: 'If you are using Visual Studio, change the arguments to `red yellow 50`. Run
    the console app and note that the cursor is half the size and the colors have
    changed in the window, as shown in *Figure 2.11*:'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio，将参数更改为`red yellow 50`。运行控制台应用程序并注意光标大小减半，窗口中的颜色已更改，如*图2.11*所示：
- en: '![](img/B22322_02_11.png)'
  id: totrans-798
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_11.png)'
- en: 'Figure 2.11: Setting colors and cursor size on Windows'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：在Windows上设置颜色和光标大小
- en: 'If you are using VS Code, then run the code with arguments to set the foreground
    color to red, the background color to yellow, and the cursor size to 50%, as shown
    in the following command:'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用VS Code，则使用以下命令运行代码，将前景色设置为红色，背景色设置为黄色，光标大小设置为50%：
- en: '[PRE121]'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'On macOS or Linux, you’ll see an unhandled exception, as shown in *Figure 2.12*:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux上，你会看到一个未处理的异常，如*图2.12*所示：
- en: '![](img/B22322_02_12.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_02_12.png)'
- en: 'Figure 2.12: An unhandled exception on unsupported macOS'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：在不受支持的macOS上未处理的异常
- en: Although the compiler did not give an error or warning, at runtime, some API
    calls may fail on some platforms. Although a console app running on Windows can
    change its cursor size, on macOS, it cannot, and it complains if you try.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器没有给出错误或警告，但在运行时，某些API调用可能在某些平台上失败。尽管在Windows上运行的控制台应用程序可以更改其光标大小，但在macOS上则不行，如果尝试这样做，它会报错。
- en: Handling platforms that do not support an API
  id: totrans-806
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不支持API的平台
- en: 'So how do we solve this problem? We can solve this by using an exception handler.
    You will learn more details about the `try`-`catch` statement in *Chapter 3*,
    *Controlling Flow, Converting Types, and Handling Exceptions*, so for now, just
    enter the code:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们如何解决这个问题呢？我们可以通过使用异常处理程序来解决。你将在*第3章*，*控制流程、转换类型和处理异常*中了解更多关于`try`-`catch`语句的详细信息，所以现在只需输入代码：
- en: 'Modify the code to wrap the lines that change the cursor size in a `try` statement,
    as shown in the following code:'
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码，将改变光标大小的行包裹在`try`语句中，如下所示：
- en: '[PRE122]'
  id: totrans-809
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If you were to run the code on macOS, then you would see the exception is caught,
    and a friendlier message is shown to the user.
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在macOS上运行此代码，你会看到异常被捕获，并向用户显示一个更友好的消息。
- en: 'Another way to handle differences in operating systems is to use the `OperatingSystem`
    class in the `System` namespace, as shown in the following code:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 处理操作系统差异的另一种方法是使用`System`命名空间中的`OperatingSystem`类，如下所示：
- en: '[PRE123]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `OperatingSystem` class has equivalent methods for other common operating
    systems, like Android, iOS, Linux, macOS, and even the browser, which is useful
    for Blazor web components.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperatingSystem`类为其他常见操作系统提供了等效方法，如Android、iOS、Linux、macOS，甚至浏览器，这对于Blazor
    Web组件非常有用。'
- en: A third way to handle different platforms is to use conditional compilation
    statements.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不同平台的第三种方法是使用条件编译语句。
- en: 'There are four preprocessor directives that control conditional compilation:
    `#if`, `#elif`, `#else`, and `#endif`.'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个预处理器指令控制条件编译：`#if`、`#elif`、`#else`和`#endif`。
- en: 'You define symbols using `#define`, as shown in the following code:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`#define`定义符号，如下所示：
- en: '[PRE124]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Many symbols are automatically defined for you, as shown in *Table 2.11*:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为你自动定义了许多符号，如下所示*表2.11*：
- en: '| **Target Framework** | **Symbols** |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '| **目标框架** | **符号** |'
- en: '| .NET Standard | `NETSTANDARD2_0`, `NETSTANDARD2_1`, and so on |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '| .NET标准 | `NETSTANDARD2_0`, `NETSTANDARD2_1`等 |'
- en: '| Modern .NET | `NET7_0`, `NET7_0_ANDROID`, `NET7_0_IOS`, `NET7_0_WINDOWS`,
    and so on |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '| 现代NET | `NET7_0`, `NET7_0_ANDROID`, `NET7_0_IOS`, `NET7_0_WINDOWS`等 |'
- en: 'Table 2.11: Predefined compiler symbols'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.11：预定义编译器符号
- en: 'You can then write statements that will compile only for the specified platforms,
    as shown in the following code:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写仅针对指定平台编译的语句，如下所示：
- en: '[PRE125]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Practicing and exploring
  id: totrans-825
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring the topics covered in this chapter with deeper
    research.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作，以及更深入地研究本章涵盖的主题来测试你的知识和理解。
- en: Exercise 2.1 – Online material
  id: totrans-827
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.1 – 在线材料
- en: Online materials can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是为我这本书编写的额外内容，也可以是引用由Microsoft或第三方创建的内容。
- en: Understanding async and await
  id: totrans-829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解async和await
- en: 'C# 5 introduced two C# keywords when working with the `Task` type that enable
    easy multithreading. You can read about them and see a code example at the following
    link:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5在处理`Task`类型时引入了两个C#关键字，使得多线程变得容易。你可以在以下链接中阅读有关内容并查看代码示例：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch02-async-await.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch02-async-await.md)'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch02-async-await.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch02-async-await.md)'
- en: Explore Spectre
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索Spectre
- en: 'No, not the villainous organization from the James Bond films! **Spectre**
    is a package that enhances console apps. You can read about it at the following
    link: `https://spectreconsole.net/`.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 不，不是来自詹姆斯·邦德电影的邪恶组织！**Spectre**是一个增强控制台应用程序的包。你可以在以下链接中了解它：`https://spectreconsole.net/`。
- en: Exercise 2.2 – Practice exercises
  id: totrans-834
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.2 – 练习
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题深入探讨了本章的主题。
- en: Explore number sizes and ranges
  id: totrans-836
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索数字的大小和范围
- en: 'In the `Chapter02` solution, create a console app project named `Exercise_Numbers`
    that outputs the number of bytes in memory that each of the following number types
    uses and the minimum and maximum values they can have: `sbyte`, `byte`, `short`,
    `ushort`, `int`, `uint`, `long`, `ulong`, `Int128`, `UInt128`, `Half`, `float`,
    `double`, and `decimal`.'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter02`解决方案中，创建一个名为`Exercise_Numbers`的控制台应用程序项目，该程序输出以下数字类型在内存中使用的字节数以及它们可以有的最小和最大值：`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`Int128`、`UInt128`、`Half`、`float`、`double`和`decimal`。
- en: 'The result of running your console app should look something like *Figure 2.13*:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的控制台应用程序的结果应该类似于*图2.13*：
- en: '![A screenshot of a computer  Description automatically generated](img/B22322_02_13.png)'
  id: totrans-839
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B22322_02_13.png)'
- en: 'Figure 2.13: The result of outputting number type sizes'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：输出数字类型大小的结果
- en: 'Code solutions for all exercises are available to download or clone from the
    GitHub repository at the following link: [https://github.com/markjprice/cs13net9/tree/main/code](https://github.com/markjprice/cs13net9/tree/main/code).'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 所有练习的代码解决方案都可以从以下链接的GitHub仓库下载或克隆：[https://github.com/markjprice/cs13net9/tree/main/code](https://github.com/markjprice/cs13net9/tree/main/code)。
- en: Exercise 2.3 – Test your knowledge
  id: totrans-842
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.3 – 测试你的知识
- en: To get the best answer to some of these questions, you will need to do your
    own research. I want you to “think outside the book,” so I have deliberately not
    provided all the answers in the book.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一些问题的最佳答案，你需要自己进行研究。我希望你“跳出书本的思维”，所以我故意没有在书中提供所有答案。
- en: I want to encourage you to get into the good habit of looking for help elsewhere,
    following the principle of “teach a person to fish.”
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望鼓励你养成寻找其他帮助的好习惯，遵循“授人以鱼不如授人以渔”的原则。
- en: What statement can you type in a C# file to discover the compiler and language
    version?
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在C#文件中输入什么语句来发现编译器和语言版本？
- en: What are the two types of comments in C#?
  id: totrans-846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中有哪两种类型的注释？
- en: What is the difference between a verbatim string and an interpolated string?
  id: totrans-847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是字面字符串和插值字符串的区别？
- en: Why should you be careful when using `float` and `double` values?
  id: totrans-848
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在使用`float`和`double`值时要小心？
- en: How can you determine how many bytes a type like `double` uses in memory?
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确定像`double`这样的类型在内存中占用多少字节？
- en: When should you use the `var` keyword?
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`var`关键字？
- en: What is the newest syntax to create an instance of a class like `XmlDocument`?
  id: totrans-851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建像`XmlDocument`这样的类的实例的最新语法是什么？
- en: Why should you be careful when using the `dynamic` type?
  id: totrans-852
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在使用`dynamic`类型时要小心？
- en: How do you right-align a format string?
  id: totrans-853
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何右对齐格式字符串？
- en: What character separates arguments for a console app?
  id: totrans-854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个字符分隔控制台应用程序的参数？
- en: '*Appendix*, *Answers to the Test Your Knowledge Questions*, is available to
    download from a link in the README in the GitHub repository: [https://github.com/markjprice/cs13net9](https://github.com/markjprice/cs13net9).'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '*附录*，*测试你的知识问题的答案*，可以从GitHub仓库中的README链接下载：[https://github.com/markjprice/cs13net9](https://github.com/markjprice/cs13net9)。'
- en: Test your knowledge of number types
  id: totrans-856
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你对数字类型的知识
- en: What type would you choose for the following “numbers”?
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 你会选择哪种类型来表示以下“数字”？
- en: A person’s telephone number
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人的电话号码
- en: A person’s height
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人的身高
- en: A person’s age
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人的年龄
- en: A person’s salary
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人的薪水
- en: A book’s ISBN
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本书的ISBN
- en: A book’s price
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本书的价格
- en: A book’s shipping weight
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本书的运输重量
- en: A country’s population
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个国家的人口
- en: The number of stars in the universe
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宇宙中的星星数量
- en: The number of employees in each of the small or medium businesses in the UK
    (up to about 50,000 employees per business)
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英国每个小型或中型企业的员工人数（每个企业最多约50,000名员工）
- en: Exercise 2.4 – Explore topics
  id: totrans-868
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.4 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一页上的链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-2---speaking-c](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-2---speaking-c)'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-2---speaking-c](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-2---speaking-c)'
- en: Summary
  id: totrans-871
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何：
- en: Declare variables with a specified or inferred type.
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明具有指定或推断类型的变量。
- en: Use some of the built-in types for numbers, text, and Booleans.
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些内置的数字、文本和布尔类型。
- en: Choose between number types.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择数字类型。
- en: Control output formatting in console apps.
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中控制输出格式。
- en: In the next chapter, you will learn about operators, branching, looping, converting
    between types, and how to handle exceptions.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于运算符、分支、循环、类型转换以及如何处理异常。
