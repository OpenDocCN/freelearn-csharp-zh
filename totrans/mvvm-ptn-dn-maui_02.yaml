- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is .NET MAUI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing mobile applications for different platforms is hard, especially when
    it comes to creating cross-platform apps that run smoothly on different devices
    and operating systems. **.NET MAUI** (**Multi-platform App UI**) is a framework
    that aims to simplify this process by allowing developers to build native and
    performant cross-platform desktop and mobile apps for iOS, macOS, Android, and
    Windows – all from a single code base.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll take a look at the .NET MAUI framework. In order to thoroughly
    understand what this framework is and what it does, we’ll discuss its core concept,
    how it works, its features, and its benefits. We will also look at what is needed
    to start building a .NET MAUI app, installing the necessary bits, and creating
    a new app.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will have a solid understanding of what the
    .NET MAUI framework is and how it works. You will also know how to install the
    necessary tools to start building a .NET MAUI app and be able to create a new
    app from scratch. With this knowledge, you’ll be well equipped to start developing
    cross-platform apps using the .NET MAUI framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first .NET MAUI app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start applying MVVM to .NET MAUI, it is essential to know the framework
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final section of this chapter, *Creating your first .NET MAUI app*, guides
    you through everything you need to set up in order to create a .NET MAUI app.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code can be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter02](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**.NET MAUI** is a framework from Microsoft for building native and performant
    cross-platform desktop and mobile apps for iOS, macOS, Android, and Windows, all
    from a single code base. Moreover, .NET MAUI’s reach extends beyond these primary
    platforms, thanks to Samsung’s efforts in adding support for Tizen OS. This additional
    support opens up possibilities for developers to target a wider variety of devices,
    such as smart TVs, wearables, and IoT devices that run on Tizen. However, for
    the purposes of this book, we’ll focus on building apps for iOS, macOS, Android,
    and Windows. Using .NET MAUI, developers can create native cross-platform user
    interfaces using XAML or C#. The key idea is to share your code, both business
    logic and UI, across all the supported platforms (*Figure 2**.1*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: .NET MAUI high-level overview](img/Image_B20941_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: .NET MAUI high-level overview'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to notice that having this shared code base in .NET MAUI doesn’t
    restrict you from accessing native platform-specific APIs using C#. In fact, .NET
    MAUI is designed to allow developers to access native features while maintaining
    a consolidated code base. .NET MAUI’s rich library of cross-platform APIs forms
    an abstraction layer for common tasks that are typically platform-specific. Yet,
    when a certain feature requires a native platform API that is not available in
    .NET MAUI’s cross-platform API, you still have the ability to directly use native
    platform APIs via C#. Through mechanisms such as partial classes, compiler directives,
    or dependency injection, .NET MAUI ensures that developers can achieve the optimal
    level of customization and functionality for their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Reminiscent of Xamarin.Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This might sound familiar to developers who previously have heard of or have
    worked with **Xamarin.Forms**.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, .NET MAUI is an evolution of Xamarin.Forms with many obvious and subtle
    differences. One of the significant differences is its integration into .NET starting
    with .NET 6\. This integration means that developers no longer need to install
    additional NuGet packages or extensions for .NET MAUI, simplifying the setup process.
    Once the required **.NET workloads** for MAUI are installed, developers can start
    building applications right away.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as a first-class citizen of .NET, MAUI benefits from improved tooling
    and developer experience in Visual Studio, making it more convenient and efficient
    to create mobile apps using the framework. This seamless integration and enhanced
    tooling help developers build cross-platform applications more easily and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the main core idea remains the same: enabling developers to build native
    and performant cross-platform applications using .NET, with a single shared code
    base for both business logic and UI code. This approach simplifies the development
    process and promotes code reusability across different platforms, while providing
    the flexibility to access platform-specific APIs when needed, ensuring that developers
    can leverage native features and customize their applications as required.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI is built upon the same foundational principles as Xamarin.Forms, but
    additionally incorporates all the learnings from almost a decade of developer
    experience from its predecessor. By improving various aspects such as performance,
    project structure, and tooling, .NET MAUI aims to simplify the process of creating
    cross-platform applications while maintaining the core ideas of sharing business
    logic and UI code, and allowing easy access to platform-specific APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform UI and more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the things .NET MAUI does is, of course, allowing us to create a shared
    UI for mobile and desktop apps. The framework offers us concepts such as `Grid`,
    `VerticalStackLayout`, `AbsoluteLayout`, and so on, which gives us the ability
    to carry out layout controls in many different ways. As a developer, you get the
    choice of whether you want to define your layouts in XAML or in code. Whatever
    approach you choose, the same thing can be achieved with both. On top of that,
    we also get data binding, an essential concept for effectively doing MVVM, as
    we learned in the previous chapter. With built-in page types such as `FlyoutPage`,
    `TabbedPage`, `NavigationPage`, and others, we can create applications with advanced
    navigation patterns. And remember, all of this eventually gets transformed into
    a native app running a native UI!
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But let’s not forget that there is more to .NET MAUI than just the UI stuff.
    .NET MAUI provides cross-platform APIs that abstract away the platform-specific
    implementations for common tasks, enabling developers to access native device
    features using a single, unified API – accessing the device’s compass, geolocation,
    filesystem, and so on – just to name a few. This allows us to write platform-agnostic
    code for such tasks, further simplifying the development process and promoting
    code reusability across different platforms. Some of the cross-platform APIs offered
    by .NET MAUI include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Device Information**: Retrieve device-specific information, such as model,
    manufacturer, platform, and OS version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geolocation**: Access the device’s location services to obtain GPS coordinates,
    perform geocoding and reverse geocoding, and track the device’s movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connectivity**: Determine the device’s network connectivity status and monitor
    for changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissions**: Request and manage various runtime permissions required by
    your application, such as location, camera, and storage access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensors**: Utilize device sensors such as the accelerometer, gyroscope, magnetometer,
    and barometer to gather data about the device’s orientation, movement, and environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preferences**: Store and retrieve simple key-value data for app settings
    and user preferences. Use the **Secure Storage** API to do this for sensitive
    data that needs to be secured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launcher**: Launch another app using that application’s URI scheme. There
    is also the **Browser** API if you want to open a website using the OS default
    browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there are many, many more!
  prefs: []
  type: TYPE_NORMAL
- en: What about Xamarin.Essentials?
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Essentials is an open source library that was created to assemble cross-platform
    APIs for mobile applications, serving as an abstraction on top of common platform-specific
    tasks. With the evolution of Xamarin.Forms into .NET MAUI, these APIs are now
    more seamlessly integrated into the framework itself. This means the Xamarin.Essentials
    NuGet package is not needed in .NET MAUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform life cycle events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET MAUI introduces a **uniform app life cycle**, which simplifies the management
    of application state across different platforms. In traditional Xamarin.Forms
    development, each platform had its own life cycle events and patterns, which sometimes
    led to inconsistencies and increased complexity when dealing with cross-platform
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Through the `Window` class, we can now react to the life cycle of our applications
    using a single set of events, regardless of the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to subscribe to these events is by getting a reference to the
    application window via the `CreateMethod` in your `App` class and then subscribing
    to the events relevant to you.
  prefs: []
  type: TYPE_NORMAL
- en: These events allow us to handle a couple of life cycle events in a consistent
    manner across all supported platforms. Depending on our needs or our scenario,
    we can use these event handlers, for example, to stop long-running processes (in
    the `Stopped` event handler) or refresh the data on the current page (on the `Resumed`
    event). A pattern I often see in banking apps is that the app’s UI gets obfuscated
    or blurred when it’s put in the background or when it hasn’t got focus. This could
    typically be handled in a cross-platform way with the help of the `Deactivated`
    and `Activated` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always with .NET MAUI, abstractions such as these should not prevent you
    from accessing platform APIs or doing platform-specific things. If you need to
    react to a certain platform-specific life cycle event, you can still do that.
    Through the `ConfigureLifecycleEvents` extension method of `MauiAppBuilder`, we
    can define delegates that should be invoked on the life cycle events of the underlying
    platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want our app to be activated through a custom URI scheme,
    we might want to intercept the URL that triggered the app to open and react to
    that. Getting a hold on that URL can only be done on specific life cycle events
    on each platform: the `OnCreate` method on Android and `OpenUrl` on iOS. We can
    override these methods in `MainActivity` or `AppDelegate`, respectively, as we
    used to do with Xamarin.Forms. Alternatively, we can hook into these platform
    events with the earlier-mentioned `ConfigureLifecycleEvents`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of having this kind of code scattered throughout your solution in platform-specific
    classes and files, I think the preceding solution is a lot more elegant as everything
    is in one place. I think this improves the readability and maintainability of
    your code a lot!
  prefs: []
  type: TYPE_NORMAL
- en: Single project structure (multi-targeting)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET MAUI also introduces a brand-new single project structure. Instead of having
    different projects per targeted platform and one project for the shared code,
    with .NET MAUI, we can build apps for different platforms from just one project.
    Not only the shared code, but also the platform-specific implementations, and
    resources, such as images, fonts, and app icons, are included directly within
    this one single project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible thanks to the `MSBuild`, the build system used by .NET and
    .NET MAUI. With multi-targeting, we can basically put all our code in one project
    and define for what platforms the project should be built. These target platforms
    are defined in the project’s `csproj` file. By default, in .NET MAUI, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, for a standard .NET MAUI project, this means we are targeting Android, iOS,
    Mac Catalyst, and Windows – the latter only when running on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiling, `MSBuild` will build for all the configured platforms, only
    taking the source files that are relevant to the platform it is compiling for
    and handling dependencies based on the specified target framework. In other words:
    one project results in multiple compiled libraries or apps, which on their own
    only contain the source code that is relevant for the platform it is compiled
    for. But how does `MSBuild` know which platform-specific files to take? There
    are a few ways of informing the build system which sources to take:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#if`, `#elif`, `#else`, and `#endif`) in your code to conditionally compile
    platform-specific code blocks. These directives enable you to include platform-specific
    code within a single source file, making it easier to share code across platforms
    and reducing the need for multiple files. For example, code surrounded by `#if
    ANDROID` and `#endif` will only be included and compiled when explicitly compiling
    for Android. The previous code sample about handling platform-specific life cycle
    events also contains these directives as the code they surround is only relevant
    to a particular platform and uses APIs specific to that platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSBuild` will only include the contents of `Platforms/Android`, `Platforms/iOS`,
    `Platforms/Windows`, or `Platforms/MacCatalyst` when compiling for the corresponding
    platform. This allows us, without using preprocessor directives, to write platform-specific
    code in these folders that accesses native APIs. Proof of this is when looking
    at the default `Program` class in `Platforms/iOS`, there is a `UIKit.UIApplication`
    object being used, which is an object specific to iOS. To give an analogy, the
    `MainActivity` class in `Platforms/Android` uses `Android.App.ActivityAttribute`,
    something specifically for Android.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only do these platform-specific folders contain platform-specific code,
    but they also contain resources that are unique to the specific platform –`Package.appxmanifest`
    in `Platforms/Windows` or `Info.plist` in `Platforms/MacCatalyst`, for example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`csproj` file for this. This can be combined with platform-specific folders
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at [https://learn.microsoft.com/dotnet/maui/platform-integration/configure-multi-targeting](https://learn.microsoft.com/dotnet/maui/platform-integration/configure-multi-targeting)
    to get a detailed approach on how to configure filename-based multi-targeting
    and how to combine it with platform-specific folders. Whatever approach you want
    to use is mostly personal preference and is completely up to you and your team
    to decide.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Visual Studio, when inside a .NET MAUI project, there is an additional dropdown
    available, called the **Platform Selector**, which allows you to select one of
    the target platforms. By default, this dropdown can be found in the top left of
    your code editor when inside a C# code file (*Figure 2**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Platform Selector](img/Image_B20941_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Platform Selector'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an entry in this dropdown doesn’t affect the compilation. The selected
    platform’s purpose is to configure the development environment for that specific
    platform. That means, when working with preprocessor directives, it displays platform-specific
    code and makes sure IntelliSense and code navigation features are adjusted to
    work on the platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.3* shows how the IDE grays out code that doesn’t get compiled in
    the selected target platform (Android).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Android as the selected target platform](img/Image_B20941_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Android as the selected target platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the selected configuration, the code surrounded with `#if ANDROID` will
    get compiled; the iOS-specific code, however, will be ignored. Moreover, we don’t
    get red squiggles in the IDE even though the iOS part has an error: the `OpenUrls`
    method doesn’t exist, as `OpenUrl` is the correct name. This error only becomes
    visible when selecting iOS as the target platform in the **Platform Selector**
    dropdown (*Figure 2**.4*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: iOS as the selected target platform](img/Image_B20941_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: iOS as the selected target platform'
  prefs: []
  type: TYPE_NORMAL
- en: By selecting iOS as the build target, all the iOS-specific code lights up, while
    code specific to other platforms gets grayed out.
  prefs: []
  type: TYPE_NORMAL
- en: This dropdown helps tremendously when writing platform-specific code!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, .NET MAUI is *a modern framework for building cross-platform native
    applications for mobile and desktop devices*. It supports Android, iOS, macOS,
    and Windows. It offers a shared UI layer with a rich set of controls, cross-platform
    APIs for common tasks, unified app life cycle events across different platforms,
    and a single project structure that simplifies development and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now that we have a good understanding of .NET MAUI, you might wonder how
    this actually works. How does this .NET code eventually end up as a native app
    with a native UI on different platforms? It’s not magic, but to understand how
    it works, we need to take a look under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Native apps with .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At compile time, native apps for each selected platform are being created. The
    necessary parts of the .NET **Base Class Library** (**BCL**), which contains the
    .NET datatypes, interfaces, and libraries, are embedded in the native app and
    tailored to the target platform. The BCL relies on the **.NET runtime** to create
    an execution environment for your application code. For Android, iOS, and macOS
    platforms, the **Mono runtime** serves as the .NET runtime implementation that
    powers the execution environment. Meanwhile, on Windows, **.NET CoreCLR** is responsible
    for providing the runtime environment for your application.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism isn’t specific to .NET MAUI. This is actually the foundation
    for **.NET for Android**, **.NET for iOS**, **.NET for Mac**, and **WinUI**. These
    things might sound like something new, but in fact, these are the new names for
    the things that we previously might have known as **Xamarin.Android**, **Xamarin.iOS**,
    and **Xamarin.Mac**.
  prefs: []
  type: TYPE_NORMAL
- en: .NET for Android, .NET for iOS, and .NET for Mac provide bindings to platform-specific
    APIs, enabling developers to access specific features and controls using familiar
    .NET constructs. On Android, when the application is compiled, the .NET code is
    packaged with the Mono runtime, and the app is executed using **Just-in-Time**
    (**JIT**) compilation on Android devices. Due to Apple’s restrictions on JIT compilation,
    .NET for iOS applications is compiled using **Ahead-of-Time** (**AOT**) compilation,
    which translates the .NET code into native ARM code that runs directly on iOS
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: WinUI is a modern, native UI framework for building Windows applications using
    C# and XAML, using .NET. It is the latest version of **Windows UI Library**, which
    provides a set of UI controls, styles, and features for building fluent and high-performance
    Windows applications. Instead of the Mono runtime, it uses .NET CoreCLR as an
    execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these frameworks can be used to create native applications with .NET,
    utilizing the UI patterns and paradigms specific to each platform to build the
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Even though .NET for Android and .NET for iOS offer a way to share a significant
    amount of code, creating and maintaining apps with a native UI for each platform
    can still be very challenging. Developers need to be proficient in the specifics
    of each platform and have a deep understanding of the differences between them.
    This can lead to higher development costs, longer time-to-market, and increased
    maintenance efforts.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI, another abstraction layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where .NET MAUI comes in. It provides a convenient and efficient way
    to create truly native mobile apps for multiple platforms using a single code
    base. .NET MAUI adds an abstraction layer on top of the previously mentioned .NET
    platforms, allowing us to build a shared UI for all of them (*Figure 2**.5*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: .NET MAUI architecture](img/Image_B20941_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: .NET MAUI architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The code in your .NET MAUI app primarily interacts with the .NET MAUI API, which
    in turn communicates with native platform APIs. Additionally, your .NET MAUI code
    can directly access platform-specific APIs to leverage unique platform features
    or customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the process of transforming a cross-platform-defined UI into a
    native UI specific to each platform.
  prefs: []
  type: TYPE_NORMAL
- en: From virtual to native view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining a UI in .NET MAUI, the platform-agnostic **controls** or **virtual
    views** are mapped to native UI elements or **native views** on each platform
    at runtime. The definition of .NET MAUI controls is often the most common denominator
    of the native controls it represents on all supported platforms. In some cases,
    platform-specific functionality is made available through platform-specific extensions.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we go from a virtual view to a native view?
  prefs: []
  type: TYPE_NORMAL
- en: The **handlers** architecture, introduced in .NET MAUI, manages the mapping
    of the virtual views to the native UI elements for each supported platform. Handlers
    are lightweight and performant components that replace the traditional renderers
    used in Xamarin.Forms. Each MAUI control has corresponding handlers that are responsible
    for creating, updating, and managing the native UI element on a specific platform.
    Handlers handle property changes, events, and platform-specific customizations,
    translating the shared MAUI control code into platform-specific native controls
    and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.6* shows how an instance of `Microsoft.Maui.Controls.Button` (Virtual
    View) gets mapped to a specific Native View:'
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, a handler maps the button to `UIKit.UIButton`. As .NET MAUI leverages
    Mac Catalyst to create native macOS applications, the same `UIKit.UIButton` is
    used for macOS. Mac Catalyst is a technology developed by Apple that allows developers
    to leverage the same project and source code to create native apps across iOS,
    iPadOS, and macOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Android, the button is being mapped by a handler to an instance of `AndroidX.AppCompat.Widget.AppCompatButton`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of `Microsoft.UI.Xaml.Controls.Button` is created by a handler on
    Windows when mapping a .NET MAUI button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in *Figure 2**.6*, `ButtonHandlers` don’t have a direct reference
    to the `Button` implementation; neither does the `Button` implementation have
    a reference to `ButtonHandlers`. Instead, every control implements an interface
    that abstracts the control. The handlers are accessed through the control-specific
    interface, such as `IButton` for `Button`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: .NET MAUI’s handlers architecture](img/Image_B20941_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: .NET MAUI’s handlers architecture'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve talked a lot about *mapping* but that is, in essence, really what is happening
    in these handlers. It is not a coincidence that a handler has one or more `PropertyMapper`
    but allows for an extra parameter to be passed. Handling cross-platform events
    such as `ScrollTo` on `ScrollView` is such an example. In order to make the native
    view scroll to the requested position, the position itself needs to be passed
    to the handler as an argument. This way, the handler can use this argument value
    to invoke the necessary action on the native view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to Xamarin.Forms’ renderers implementation, the handlers’ architecture
    offers several benefits: improved performance, easier customization, and better
    maintainability, making it a significant improvement point in transitioning from
    Xamarin.Forms to .NET MAUI.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered a substantial amount of theory and you understand how
    things work under the hood, it’s time to roll up our sleeves and start creating
    something tangible. I know you’re keen to dive in, so let’s embark on building
    our very first .NET MAUI application!
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first .NET MAUI app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s create our first .NET MAUI app! Before we can start writing any code,
    we need to set up our machine by installing some bits. So, let’s walk through
    these initial setup steps together and see what options we have. Once we’re set
    up, we’ll move on to the exciting part: creating a .NET MAUI app from scratch,
    step by step.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting started with .NET MAUI development is pretty simple, especially if you
    are using Visual Studio as your IDE. But even if you don’t want to use Visual
    Studio, the installation should be quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: About .NET SDK versions and workloads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '.NET MAUI is available from .NET 6, and at the time of writing the book, **.NET
    8** is the most recent version. It is important to note that every version of
    .NET comes with a specific support policy: there are **Long-Term Support** (**LTS**)
    releases, which provide 3 years of free support and patches, and there are **Standard-Term
    Support** (**STS**) releases, which are good for 18 months of free support and
    patches. However, for .NET MAUI, this doesn’t apply. Microsoft needs to make sure
    .NET MAUI supports the latest and greatest APIs on all of the supported platforms.
    New features and improvements will be mainly developed for the next version of
    .NET, and some may be backported to the current version. So, when it comes to
    .NET MAUI, the support policy is different than the general .NET support policy.
    It’s best to use the latest available version of .NET so you have access to the
    newest platform APIs and the best-performing version of .NET MAUI, regardless
    of whether it’s an LTS or STS release.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET 6 introduced the concept of **workloads**. A workload is a set of tools,
    templates, and libraries for a particular development scenario or target platform.
    When installing the .NET MAUI workload, we are installing everything that is needed
    to build cross-platform native apps with .NET. It will install the .NET MAUI class
    libraries, build and runtime components, platform-specific SDKs and tools, project
    templates, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET MAUI workload can be installed and managed in two ways: using the
    Visual Studio Installer or via the command line if you choose not to work with
    Visual Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for your .NET MAUI workload to remain in a stable state, it is important
    to stick with one and only one of the following options: you either install it
    with Visual Studio and manage it from there, or you do it from the command line.
    Don’t mix the two!'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio and the .NET MAUI workload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with Visual Studio (2022 17.3 or greater), we can use the Visual
    Studio Installer to install the .NET MAUI workload. This is by far the easiest
    way to install and manage your workloads. .NET MAUI development is supported on
    all versions of Visual Studio: from the free Community edition to the paid Enterprise
    edition.'
  prefs: []
  type: TYPE_NORMAL
- en: If Visual Studio is not yet installed on your machine, you first need to download
    the Visual Studio Installer by going to [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
    Once the installer is downloaded, launch it, and choose **Install** (*Figure 2**.7*)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Installing Visual Studio](img/Image_B20941_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Installing Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Or, if you already have Visual Studio installed, you can launch the Visual Studio
    Installer and select **Modify** (*Figure 2**.8*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Modifying Visual Studio](img/Image_B20941_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Modifying Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Whether you are installing Visual Studio or modifying it, in the next dialog,
    you can choose the workloads you want to install. As shown in *Figure 2**.9*,
    this is where we need to check **.NET Multi-platform App** **UI development**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Installing the .NET MAUI workload](img/Image_B20941_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Installing the .NET MAUI workload'
  prefs: []
  type: TYPE_NORMAL
- en: This will install all the bits and pieces in order for you to be able to build
    .NET MAUI apps.
  prefs: []
  type: TYPE_NORMAL
- en: Having Visual Studio freshly installed, launch it, and select **Continue without
    code** (*Figure 2**.10*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Starting Visual Studio without code](img/Image_B20941_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Starting Visual Studio without code'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to debug on an Android emulator or an iOS simulator, we
    need to install or configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Tools** | **Android** | **Android Device Manager**. From there, you
    can add Android emulators that you can use to deploy your .NET MAUI app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From **Tools** | **iOS** | **Pair to Mac**, you can follow the steps in order
    to connect to a Mac in your network. When connected to a Mac, you can debug your
    app on an iOS simulator or on a physical device plugged into your Mac.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot Restart
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can also debug on a physical device, plugged into your PC. This
    is possible even on an iOS device! With Visual Studio **Hot Restart**, you can
    debug right onto your iPhone without having a Mac connected to your Windows machine.
    The only caveat is that you need an **Apple Developer Account**, an active **Apple
    Developer Program** enrollment (which is paid), and iTunes installed on your PC.
    As soon as you connect your iOS device to your computer and select it in Visual
    Studio as your debug target, Visual Studio will guide you through setting up Hot
    Restart, which will require you to enter your Apple Developer Account details.
    I would recommend heading over to [https://learn.microsoft.com/dotnet/maui/ios/hot-restart](https://learn.microsoft.com/dotnet/maui/ios/hot-restart)
    to get step-by-step guidance on how to set up Hot Restart on iOS. While this is
    great for debugging, in order to release an iOS or macOS app, you still need a
    Mac to build and sign your app!
  prefs: []
  type: TYPE_NORMAL
- en: Installing the .NET MAUI workload with the command line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, if you are choosing an IDE other than Visual Studio, you need
    to install the .NET MAUI workload manually through the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before installing .NET MAUI, you need to make sure .NET is installed on
    your machine. You can do this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It should give you an overview of all .NET SDKs installed. As said earlier,
    .NET 6 is the minimum required .NET SDK needed to do .NET MAUI development. If
    the preceding command fails, as shown in *Figure 2**.11*, it means .NET is not
    yet installed on your machine. You should go to [https://dotnet.microsoft.com/download/dotnet](https://dotnet.microsoft.com/download/dotnet),
    select the latest version of .NET, and download the appropriate installer or binaries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: ‘dotnet’ is not recognized](img/Image_B20941_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: ‘dotnet’ is not recognized'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a recent version of .NET is installed on your machine, you can install
    the .NET MAUI workload via the command line by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will install everything that is needed to be able to build cross-platform
    apps with .NET MAUI using your favorite IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that this doesn’t install any additional tools for managing Android
    emulators, for example, nor does it give you out-of-the-box tools that allow you
    to easily connect to a Mac or deploy to an iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio Code and the .NET MAUI extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you prefer working with **Visual Studio Code**, whether it is on Windows,
    macOS, or even Linux, there’s some good news. The **.NET MAUI extension**, together
    with the **C# Dev Kit extension**, gives you everything you need to start creating
    MAUI apps with Visual Studio Code. The supported target platforms depend on the
    OS you are running. On Windows, you can create Windows and Android apps; on macOS,
    you are able to develop all but Windows apps; and on Linux, you can only create
    Android apps. Let’s see how we can get Visual Studio Code up and running for creating
    .NET MAUI apps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Visual Studio Code from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    Install the .NET MAUI extension from the `maui`, as shown in *Figure 2**.12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12: .NET MAUI extension](img/Image_B20941_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: .NET MAUI extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the extension is installed, the **Welcome** page pops up in Visual Studio
    Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13: .NET MAUI extension Welcome page](img/Image_B20941_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: .NET MAUI extension Welcome page'
  prefs: []
  type: TYPE_NORMAL
- en: This **Welcome** page guides you through every additional step you need to take
    to get your environment up and running. It covers everything from the installation
    of the .NET MAUI workload to downloading and installing Microsoft OpenJDK, which
    is essential for building and debugging Android apps. Additionally, it tells you
    to install Xcode and Xcode Command Line Tools on a Mac, which are needed for building
    and debugging iOS and macOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have got our preferred development environment all set up, let’s
    create a .NET MAUI app! Note that throughout this book, the walk-throughs describe
    the workflow as in Visual Studio. However, it shouldn’t be an issue to follow
    along in your IDE of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Hello “Recipes!” app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we will be working on the *Recipes!* app. With this app,
    users add their favorite recipes and share them with the world, allowing other
    users to rate and review them.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s go ahead and create a .NET MAUI app that will serve as a starting
    point for our *Recipes!* app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the excitement building, we’re about to take our first steps toward developing
    our *Recipes!* app. To kick things off, we’ll start by creating a new project
    in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fire up Visual Studio and select **Create a new project**, as shown in *Figure
    2**.14*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14: Create a new project](img/Image_B20941_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Create a new project'
  prefs: []
  type: TYPE_NORMAL
- en: Next, select `maui` in the search bar at the top to query the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15: Choosing the .NET MAUI App template](img/Image_B20941_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Choosing the .NET MAUI App template'
  prefs: []
  type: TYPE_NORMAL
- en: Next, enter the relevant details for **Project name**, **Location,** and **Solution
    name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16: Configure your new project](img/Image_B20941_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Configure your new project'
  prefs: []
  type: TYPE_NORMAL
- en: On the final screen, select **.NET 8 (Long Term Support)** or any other .NET
    framework you want to target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This creates a solution containing a .NET MAUI project with the provided names
    at the given location, as shown in *Figure 2**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17: Recipes! .NET MAUI project](img/Image_B20941_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Recipes! .NET MAUI project'
  prefs: []
  type: TYPE_NORMAL
- en: Running your app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Right off the bat, you can run your brand-new cross-platform application on
    Windows by pressing *F5* or by clicking the **run** button in Visual Studio. The
    **run** button should have **Windows Machine** next to it, indicating you are
    going to run your app natively on Windows. If the button doesn’t show **Windows
    Machine**, you can click the downward-pointing arrow for additional options, as
    shown in *Figure 2**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18: Choosing a Debug target](img/Image_B20941_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Choosing a Debug target'
  prefs: []
  type: TYPE_NORMAL
- en: When debugging a Windows app for the first time, Visual Studio might prompt
    you to enable **Developer Mode** in Windows. After that, your shiny new app should
    be deployed and running on Windows!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also debug right away on Android: click the arrow next to **Windows
    Machine** that points downward, select **Android Emulators**, and select an emulator
    from the list. If this is your first time running an Android app, you will get
    an error message inside **Error List** in Visual Studio, prompting you to accept
    the Android SDK licenses. Double-clicking the message should open **Android SDK
    – License Agreement**, which you should accept in order to continue. Hit *F5*
    again, or click the **run** button – which should contain the name of your emulator
    – in Visual Studio. Starting the emulator for the first time and deploying it
    might take a while, but after some time, you will see an emulator popping up with
    your native Android app running on it.'
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, if you are connected to a Mac, you can select an iOS simulator
    as well and see your native iOS running on an iOS simulator! If you have an Android
    or iOS device connected to your PC, it should appear in the list as well. Selecting
    it and running the application should deploy your app onto your physical device.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Hot Reload and XAML Hot Reload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With **.NET Hot Reload**, developers can make changes to their source code while
    the application is running, without the need to pause or rebuild the app. It enables
    faster iteration and real-time feedback on code modifications. Why don’t we go
    ahead and make some changes to our code while the app is running?
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainPage.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `OnCounterClicked` method, change `count++` to `count +=` `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes or manually hit **Hot Reload** (*Alt* + *F10*) in Visual Studio.
    In the drop-down menu of this button, you can also find a **Hot Reload on File
    Save** setting that you might want to check. Having this checked should automatically
    trigger **Hot Reload** when you save your changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.19: Hot Reload](img/Image_B20941_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Hot Reload'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the running app and click the button in the app and you should see
    that the counter is incremented by two every time you click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Additionally, with **XAML Hot Reload**, we can even update the XAML code while
    the app is running and immediately see the updated UI. So, while our app is running,
    let’s update some things on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Run your app on your platform of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the app is running, go to Visual Studio and open `MainPage.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `Text` property of the first `Label` from `"Hello, World"` to `"Recipes!"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <Label
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FontSize="18"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: HorizontalOptions="Center"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'BackgroundColor property to Button and give it the value of "#FCB64A", and
    set the TextColor property to "white":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the changes you have made, and you should see the UI changes immediately
    being reflected in your running app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .NET Hot Reload and XAML Hot Reload are fantastic tools as they avoid needing
    to stop, rebuild, and redeploy your app for small, incremental changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a splash screen and app icons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With .NET MAUI’s single-project approach comes the ability to manage all of
    the app’s resources (such as images, icons, fonts, and so on) in that single project.
    During compilation, all the resources inside the relevant `Platforms` folder are
    picked up together with everything inside the `Resources` folder. All of this
    is embedded in the resulting native app.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you want, you can add a `Platforms` subfolder. The same goes for `Platforms`
    subfolders. But, in MAUI, there is a much easier way: .NET MAUI can generate splash
    screens and app icons for us. Let’s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `splash.svg` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Splash` folder, select `Chapter 02``/Assets/recipes-logo.svg`
    file, which can be found in the code repository shared at the start of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the file to `splash.svg` and set **Build Action** to **MauiSplashScreen**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the project’s `csproj` file by clicking on your MAUI project in the `csproj`
    file, find the `MauiSplashScreen` tag. You can add a `Color` property to define
    the background color that needs to be used for the splash screen. The given `svg`
    will be centered on the splash screen with the defined background color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean and rebuild your solution and run your app again. You should now see
    the updated splash screen, as shown in *Figure 2**.20*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.20: The Recipes! app splash screen on iOS and Android](img/Image_B20941_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: The Recipes! app splash screen on iOS and Android'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When deploying on a physical iOS device from your Windows PC by using Hot Restart,
    your splash screen will not get updated and the standard .NET splash screen will
    remain. This is a limitation of Hot Restart, even though you have correctly configured
    your custom splash screen. In order to verify your splash screen, it’s best to
    deploy it on a physical device that is connected to a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only is .NET MAUI capable of generating a splash screen for us, but .NET
    MAUI can also generate app icons for our app as well! Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `appicon.svg` and `appiconfg.svg` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Resources` folder, select `Chapter` `02``/Assets/recipes-appicon.svg`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the file to `appicon.svg` and set **Build Action** to **MauiIcon**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look into the project’s `csproj` file and look for the `MauiIcon` tag. Add
    a `Color` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean and rebuild your solution to make sure your app icon gets shown on your
    device. You might want to delete the app from your device as well prior to deploying
    it. Once you have deployed your app, you should see your updated app icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21: The Recipes! app’s icon on Android, Windows, and iOS](img/Image_B20941_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: The Recipes! app’s icon on Android, Windows, and iOS'
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it! With very little effort, we’ve created a cross-platform
    app, complete with a splash screen and app icons.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we provided an overview of .NET MAUI: what it is, how it works,
    and how to get started with creating a cross-platform app using .NET MAUI. We
    walked through the process of creating an app, complete with a splash screen and
    app icons. Additionally, we examined .NET Hot Reload and XAML Hot Reload, features
    that enable us to update code while the app is running, dramatically increasing
    our efficiency. Now that you have a holistic understanding of .NET MAUI and the
    MVVM design pattern, we can continue our journey by exploring how to effectively
    apply this pattern within the .NET MAUI framework.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051), *Data Binding Building Blocks
    in .NET MAUI*, we’ll explore the components available in .NET MAUI that enable
    us to build cross-platform apps using the MVVM pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a splash screen in .NET* *MAUI*: [https://learn.microsoft.com/dotnet/maui/user-interface/images/splashscreen](https://learn.microsoft.com/dotnet/maui/user-interface/images/splashscreen)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with app icons in .NET* *MAUI*: [https://learn.microsoft.com/dotnet/maui/user-interface/images/app-icons](https://learn.microsoft.com/dotnet/maui/user-interface/images/app-icons)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configure* *multi-targeting*: [https://learn.microsoft.com/dotnet/maui/platform-integration/configure-multi-targeting](https://learn.microsoft.com/dotnet/maui/platform-integration/configure-multi-targeting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET MAUI app* *lifecycle*: [https://learn.microsoft.com/dotnet/maui/fundamentals/app-lifecycle](https://learn.microsoft.com/dotnet/maui/fundamentals/app-lifecycle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET MAUI* *installation*: [https://learn.microsoft.com/dotnet/maui/get-started/installation](https://learn.microsoft.com/dotnet/maui/get-started/installation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pair to* *Mac*: [https://learn.microsoft.com/dotnet/maui/ios/pair-to-mac](https://learn.microsoft.com/dotnet/maui/ios/pair-to-mac)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Android* *emulator*: [https://learn.microsoft.com/dotnet/maui/android/emulator/device-manager](https://learn.microsoft.com/dotnet/maui/android/emulator/device-manager)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting up an Android device for* *debugging*: [https://learn.microsoft.com/dotnet/maui/android/device/setup](https://learn.microsoft.com/dotnet/maui/android/device/setup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET MAUI Support* *Policy*: [https://dotnet.microsoft.com/platform/support/policy/maui](https://dotnet.microsoft.com/platform/support/policy/maui)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
