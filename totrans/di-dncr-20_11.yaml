- en: Best Practices and Other Related Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter was a very interesting one as we explored Dependency Injection
    in different frameworks such as TypeScript, ES2015, and Angular 2\. This is the
    last chapter and we are going to discuss the coding and architectural practices
    proved to be the best while implementing Dependency Injection in the project.
  prefs: []
  type: TYPE_NORMAL
- en: It's obvious that, when you learn something new and try to implement it in your
    application, excitement might lead you to create a bad architecture. That would
    eventually lead to a bad practice because, after you code it for a few times unknowingly,
    it becomes a habit. Suppose, you get a requirement to save user details to the
    database. You will definitely send the details to the `Service Layer` method which
    in turn would connect to the `Data Access Layer` method, to save the details.
    Quickly (if you are new to the application and don't know about the architecture
    implemented), the first thing you would do is to use the `new` keyword to instantiate
    the dependencies and directly call the methods. In that way, we can't achieve
    loosely coupled modules. However, we could have designed the app and the layers
    in such a way that the consumers won't be able to generate coupling by any means.
    We will explore these techniques in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, exploring how to deliver your best with the concept you just learned is
    important for you and your app. For that reason, there are best practices which
    you should be aware of. Dependency Injection deals with Object Composition, Object
    Lifetime, and Interception as a whole, which should be ideally managed by DI Containers.
    If we try to deal with these building blocks ourselves instead of using a container
    to manage the dependencies, we might end up with a bad design.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can choose one DI Container, designing and refactoring our code
    accordingly to help the container to work with our classes might be an erroneous
    task.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will touch upon these points in detail to understand the
    real-time problems faced during the induction of DI into the projects. We will
    learn techniques to avoid bad habits in DI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and recommendations in Dependency Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some recommended techniques to remove tight coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring and implementation of DI in legacy layered applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tightly coupled systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have discussed *DI in .NET Core 2.0, Pillars of DI, DI Patterns,
    Anti-Patterns, DI in other frameworks*. Someone who is new to the DI concept might
    do make mistakes and it's normal. We will see more of such scenarios in upcoming
    sections. Before that, let's analyze something which you might find more often
    in ASP.NET MVC projects. If you don't, ask your colleagues and friends. You will
    definitely see such instances.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see one simple controller without DI implemented and learn how to refactor
    that so that it will respect the principles of *Inversion of Control*.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of Control states *Do not call us we will call you*. When a class
    tries to instantiate another class inside it, it basically creates a coupling
    with the second class. Now the first class creation depends on the second class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the second class fails, for any reason, we won''t be able to get the instance
    of the first class, as the constructor will break:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62615398-6b59-4eb3-8657-451926cf6fe7.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Someone** in the picture can be an IoC Container.
  prefs: []
  type: TYPE_NORMAL
- en: I would strongly recommend Mr. Shivprasad Koirala's article, if you want to
    grasp this concept in depth. Here is the link--[https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency](https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency).
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram depicts what we are going to do now. We will have a **Controller**
    depending on a **Service**, which in turn depends on a **Repository** for data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6cbf62-357a-46b5-9785-14b3fb11853a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First of all, let''s think of a simple controller and how that is generally
    implemented in projects. The following is a simple `UsersController` which has
    an action method `Edit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the conclusions (more accurately the problems), which can
    be made from the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UsersController` instantiates `UsersService` using the `new` keyword (creates
    an instance of a concrete class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsersController` is tightly coupled with `UsersService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As far as our knowledge from other chapters is concerned, we should definitely
    avoid both of the preceding points. This makes Unit Testing difficult. DI principles
    encourage us to utilize the area of the Composition Root to register all required
    classes/dependencies (such as `UsersService`) and then use a DI container to resolve
    the instances instead of using the `new` keyword whenever required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is `UsersService`, which might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Yet another concrete dependency with `UsersRepository`. `UsersService` now does
    the same kind of stuff as we saw in the case of the controller. In this example,
    the service is trying to pass the data returned from the repository. But in reality,
    it might do a lot of things. The important aspect here is how we are managing
    our dependencies inside a class which might get uglier as we build a complex system
    in the future. The exercise we are doing now is just to point out the problem,
    so don't go by the simplicity of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram explains what has been done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e7fe9d-fda2-48ee-989f-a17cc250d795.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything stops here. This is the last in the queue. It gets the data from
    the `Users` table and sends it back to the client. This architecture works, but
    there are shortcomings which might get worse as you progress:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is not easy as the classes are tightly coupled with each other.
    For instance, `UsersController` depends on `UsersService`, which in turn depends
    upon `UsersRepository`, and then, at last, it deals with the database, while unit
    testing might fail due to database interactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this architecture grows and becomes a fully fledged application, then maintenance
    becomes difficult as the classes are wound up with dependencies all over which
    will be difficult to identify and manage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no technique/method by which we can easily modify the dependencies.
    Suppose we want to implement another class for a service named `UsersNewService`
    and we want to use that instead of `UsersService`. It will be a tedious task as
    we have to identify all dependencies of `UsersService` and then change them everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, the concrete service reference might fail in certain circumstances
    where the method signatures may vary across different classes. For example, the `GetUser`
    method in both of these service classes may vary in the signature, making the
    developer's life difficult as you have to modify the `GetUser` caller methods
    as well, including service reference changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These flaws not only describe a poorly architected project but also become a
    developer's nightmare to refactor and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The solution - refactoring with DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we all know, the Dependency Inversion Principle states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules. Both should depend
    on **abstractions**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details. Details should depend on abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, let's design the interfaces to abstract out the concrete classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start from the last one in the hierarchy, which is the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7487ff3b-e86b-480e-a7ac-5520ffbc3fd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The abstraction for the repository would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `UsersRepository` would implement `IUsersRepository` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Interface extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you know how easy it is to extract an interface out of a class? It''s very
    easy and effective with Visual Studio. Let''s see the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Hover on the concrete class; you will see a bulb at the left side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on that to open a drop-down menu. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a1663e5-99b6-41d1-9af6-3d7527067b01.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the `Extract` Interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A modal pops up which also lists the public members of the class. See the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ee3d902-fa21-4d9c-919a-7eda2914b586.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit OK. It will create the interface for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is another way to extract an interface. You can write the interface name
    and then do a *Ctrl* + *.* (dot) so that the option bubble appears. You need to
    select either of the top two options to generate the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fc8f6e0-c1f6-4ecc-b9a3-6ae91d585fa9.png)'
  prefs: []
  type: TYPE_IMG
- en: However, there is a difference in comparison to the first approach; its marked
    with the red block. If you select either of the `Generate` options shown in the
    screenshot, it will create a block for interface with a blank block without any
    code inside it (indicated inside the red block). However, in the first case, we
    had the opportunity to select the public members to include them in the interface.
    Imagine a huge class with lots of public members. Undoubtedly, the first approach
    wins for obvious reasons as previously described.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright. Now we can modify the `UsersService` to inject the repository as a
    dependency instead of instantiating using the `new` keyword inside the constructor.
    The `IUsersService` interface can be designed as we did for the repository in
    order to use it inside the controller, which we will see in a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05c82b32-7b0b-461c-907c-2ba6bdfe3bf9.png)'
  prefs: []
  type: TYPE_IMG
- en: '`IUsersService` is just a simple interface with `GetUser` as a public member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`UsersService` can be modified now to implement `IUsersService`. Injection
    can be done using the Constructor Injection pattern to inject the `IUserRepository`
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This change will trigger a modification to the controller; otherwise the compiler
    would complain. Let''s make the compiler happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can now inject/insert the repository instance to the service inside the controller
    action `Edit`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have eliminated one concrete reference from the architecture that
    is from the `UsersService` class. It's very important to understand our goal.
    We are actually trying to get every dependency in one place so that the design
    gets simplified. Thus, with minimal change, we can easily inject different types
    of dependency into the system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, our `UsersService` is now taking responsibility for managing the
    `UsersRepository` dependency instead of the service managing it internally with
    a tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are still not done. We have another clearly visible dependency in
    the controller instantiated using the `new` keyword inside the action `Edit` and
    that is none other than the `UsersService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactored injectible `UsersController` would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Simple, isn't it? Constructor Injection again comes to our rescue and allows
    us to inject the service so that we can use it for further operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome, now we removed all dependencies. Go ahead and run the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57020285-5416-42e4-b3e2-57a2503a9318.png)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, it threw an exception. It isn't a surprise. The framework would
    expect one parameter less constructor inside the controller which we don't have
    anymore and then it found one parameterized constructor accepting the `IUsersService`
    implementation instance which was never provided anywhere in the app. Thus, the
    exception was formulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, I know what you are thinking. Adding one parameter less or default constructor
    won''t change the scene. Rather it will show the following in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fc28848-c597-42cc-9482-e8261406f8d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Moreover, DI does not recommend using multiple constructors, so that is not
    an option anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go ahead with the solution, let me summarise what we have done so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: We created abstractions for concrete classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We replaced new keywords with constructors injected with abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the process, we also modified the default constructor of `UsersController`
    to inject the `IUsersService` dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we received exceptions. That is because we have neither instantiated
    any implementation of the `IUsersService` interface nor provided it to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do two more things to make the app run. That is to let the compiler
    know what the implementations of the following are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IUsersService` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IUsersRepository` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That can be done with an IoC Container. As we are on .NET Core 2.0, let''s
    use the built-in container and see what happens. The `ConfigureServices` method
    of the `Startup` class would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the app now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b96498fe-fcd1-4546-9f01-953678456324.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, it runs. Everything is perfect and we got the output in the browser,
    thanks to the DI engine of .NET Core and yes, of course, to the progress you have
    made so far with the book.
  prefs: []
  type: TYPE_NORMAL
- en: We did a fabulous job in refactoring the classes to inject dependencies instead
    of referring concrete classes which were inefficient and not maintainable. Still,
    the tight coupling is not totally eliminated. The service is still returning a
    database model class `User` instance to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a three-layered architecture, where the layers can be the `ASP.NET MVC
    Web App Layer`, `Service/Business Layer`, and `Data Access Layer`. If a developer
    uses the model classes directly in the presentation layer (`ASP.NET MVC Web App
    Layer`), that means it is tightly coupled and can't live without a reference to
    the `Data Access Layer` in the project. In the next section, we will see such
    a problem and try to refactor it to DI.
  prefs: []
  type: TYPE_NORMAL
- en: Layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a typical modern ASP.NET MVC web app, you will find a three-layered architecture
    with isolated components depending on each other as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/877c5277-733d-409e-8e5e-ef8fffdb14ff.png)'
  prefs: []
  type: TYPE_IMG
- en: When we say some layer depends on another, that means the layer that depends,
    needs instances of the dependency objects to perform certain operations. As we
    saw in the previous section, to get a user from the database, the controller was
    asking the service to provide it from the repository. Thus, we can easily separate
    the classes and package them as components or a class library, speaking technically.
  prefs: []
  type: TYPE_NORMAL
- en: That means my controller remains in `UI Layer` or `Presentation Layer`, `Service
    Class` make another layer who talks to the database through `Data Access Layer`
    classes. Now, as we chose Dependency Injection Technique to manage the dependencies,
    it's the responsibility of the IoC Container to provide the dependent `Data Access
    Layer` objects to the `Service Layer`, and `Service Layer` objects to the UI Layer.
    Most importantly, it takes the control from each layer for object creation.
  prefs: []
  type: TYPE_NORMAL
- en: The problem - The concrete class reference again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think you may not have noticed one thing in the last section. We tried to
    decouple the system as far as we could. But we have not totally achieved a loosely
    coupled architecture. Let me explain in the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composition Root is the place where we register all the dependencies to be
    used by the application. The `ConfigureServices` method in the `Startup` class
    was the location of this dependency registration as we saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are saying, take the `UsersService` instance when `IUserService`
    dependency is required and the `UsersRepository` instance when `IUsersRepository`
    is required. So, basically, we now have to get the assembly references of both
    `Service Layer` and `Data Access Layer` in order to run this code without compilation
    issues. Check out the following screenshot, which proves what I just said:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d51c44e6-078c-46d8-95ee-81e4513f18c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Whatever classes we have designed so far are just separated out in these three
    layers. The repository is in the `Data Access Layer` and the service is inside
    the `Business Layer`.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, you can see there is a `Business Layer` assembly reference in the UI
    Layer. As the `Business Layer` has a reference to the `Data Access Layer`, so
    automatically it is carried over to the UI Layer.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, the `Presentation Layer` now has access to various implementations
    of the `Service Layer` and `Data Access Layer`. This is a very bad coding practice
    as we are trying to violate the layered architecture concept altogether. There
    is no separation existing between the layers. Moreover, developers can misuse
    the concrete class implementations, as they have direct access due to the assembly
    reference. This is not acceptable at all.
  prefs: []
  type: TYPE_NORMAL
- en: Misuse of business and Data Access Layer assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will discuss how we, as developers, could misuse the layers in the
    code by direct reference to the layers. Let''s try to understand a few scenarios
    where these assemblies can be misused in the `UI Layer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct Business Layer Service Access**: As we have a reference of `Business
    Layer`, so we can instantiate it and then call the `GetUser()` method. We needed
    a `Repository` instance for the `Service` constructor, which we can also easily
    provide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we can easily instantiate the `UsersService` class by passing the `Repository`
    instance to its constructor. That means we still love the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct Data Access Repository Access**: Why go through `Service` when we
    have the `Data Access` reference? Why not directly deal with the Repository to
    get the data? Cool isn''t it!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Yet another `new` keyword usage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct Data Layer Context Access**: Even better is the following approach
    where we don''t even need these intermediate `Service` or `Repository` instances.
    We can directly get data from contexts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`DataContext` can provide the data directly inside the Controller Action as
    shown in the preceding code.'
  prefs: []
  type: TYPE_NORMAL
- en: We destroyed the layered architecture and the modules are not independent anymore.
    Rather the `Business Layer` and `Data Access Layer` are now tightly coupled with
    the `UI Layer`. This happened just because we had to register concrete implementations
    for the interfaces with the Service Collections inside the `ConfigureServices`
    method. For DI injection to take place, we need this registration step so that
    we can ask the container for dependencies whenever required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to find a way. Let's discover a best practice for this kind of
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice for layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, you can do a ton of things to improve the architecture and optimize
    the performance whilst using DI techniques; however, you can't remove the assemblies
    from inside the `bin` folder of the ASP.NET MVP web application. You need to understand
    that the problem lies with access to different concrete implementations of the `Business
    Layer` and `Data Access Layer` inside the `Presentation Layer`; as we saw how devastating
    it can be when developers try to play with the layers instead of properly using
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to figure out a way to overcome this situation and not allow
    the `Presentation Layer` to access the concrete classes of other layers while
    being benefited by Dependency Injection. The solution is MEF. Let's explore more
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Managed Extensibility Framework (MEF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before exploring MEF, let me summarize the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tight coupling:** Concrete classes are referenced inside the `UI Layer` by
    DI during the `Startup` inside `ConfigureServices` method.'
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, we need to do some automation which enables us not to depend
    upon concrete classes of other layers. That is where MEF comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: MEF is a library for creating lightweight extensible applications. With the help
    of MEF, developers can easily build the an app to automatically bind extensions
    together without any configurations. There is more on MEF at [https://docs.microsoft.com/en-us/dotnet/framework/mef/index](https://docs.microsoft.com/en-us/dotnet/framework/mef/index)[.](https://docs.microsoft.com/en-us/dotnet/framework/mef/index)
  prefs: []
  type: TYPE_NORMAL
- en: We are not going deeply into the MEF; you can do that from the preceding link
    I shared. We just need to understand how we can solve our issue with MEF. For
    example, we have a `Service` class and a `Repository` class which we don't want
    to expose to UI for direct consumption as we saw in our preceding code snippets.
    MEF would do that for us by pulling the classes required to register the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the role MEF is going to play in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84fe4a37-b067-4153-bc63-a5eed43e85ad.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see we have `ModuleInit` classes in every layer with one `Init()` method
    and these classes implement a common interface called `IModule`. It's obvious
    that the DLLs of all the layers will be there in the `bin` folder of the ASP.NET
    MVC Web Project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the interesting scene. MEF gets all assemblies from the `bin` folder of
    the App, then it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for the implementations of `IModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fires the `Init()` method of each found module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will see the codes in different layers and how MEF can
    bring back loosely coupled modules to optimise the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Layers and MEF implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going into the code in some depth, let's first analyze the layers. So,
    there are three layers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web App Layer:** Contains `Controller`, `View`, and so on. Most importantly,
    it has the entry point `Startup.cs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Business/Service Layer:** Contains the `Services` where we can include our
    business logic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data Access Layer:** Contains `Contexts`, `DbSets`, and `Repository` for
    data retrieval from the database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at the `Visual Studio Solution` window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b265d83-5dbe-47be-acc9-6cc7b21a2e61.png)'
  prefs: []
  type: TYPE_IMG
- en: We have organized our classes into different layers. Interestingly, we have
    introduced another layer named as `Common Layer`, where we have placed all common
    code related to `Business Layer` and `Data Access Layer`. A common project is
    referenced both by `Business Layer` and `Data Access Layer`.
  prefs: []
  type: TYPE_NORMAL
- en: This common code will help us fetch the dependencies from assemblies related
    to different layers and package them into one (called `ModuleLoader`) so that
    the web app can call just one method to initiate everything. Let's understand
    each part one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction of IUser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal is to remove the concrete class access from the UI layer. We started
    to move all common items into one central layer called `Common`. As we moved `IUsersService`
    to `Common`, we identified a `GetUser` method, which is actually returning a concrete
    `User` instance. Moreover, `UserService` inside the `Business Layer` also has
    the same method as it implements `IUsersService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how the return type of `GetUser` can be updated to
    `IUser` type instead of `User` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We need to get rid of this `User` class dependency, otherwise, `Common Layer`
    has to again refer to the `Data Access Layer` because the `User` resides in that,
    which is the same case for `Business Layer` to refer `Data Access`. Moreover,
    `Common` is designed to be referred by other layers and not to get other layers
    references inside itself. It should be free from project dependencies. This is
    important.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is very easy. One `IUser` interface can be added inside the `Common/Entities/Users` directory,
    which will be used as a return type for the `GetUser` method. So, `GetUser` inside `UsersService`
    and `UsersRepository` can return the `IUser` type instead of the `User` instance.
    Now we can easily remove the coupling of `Data Access` with the `Common Layer`.
    Also `Data Access` coupling with the `Business Layer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram tells us what was wrong when we used `User` class. We
    had references to the `Common Layer` and `Data Access Layer` in the `Business
    Layer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb81c646-ecdf-482b-86ca-6c67be4f09f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the approach which is correct with an interface `IUser`, which
    allows us to reduce the coupling of layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f327c048-c7b6-4e4d-a3c2-f3097482ab56.png)'
  prefs: []
  type: TYPE_IMG
- en: Now there is no need for a reference to the `Data Layer` inside the `Common
    Layer`. On the contrary, the `Business Layer` and `Data Layer` are dependent on
    `Common`, which is our intention.
  prefs: []
  type: TYPE_NORMAL
- en: The IModuleRegistrar interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `IModuleRegistrar` interface is responsible for adding the dependency into
    the service collection. Basically, the implementer of this interface will have
    an `Add()` method with the signature mentioned, which does the job of the `Add***` (`AddTransient`/`AddScoped`/`AddSingleton`)
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is present inside the `Common Layer`.
  prefs: []
  type: TYPE_NORMAL
- en: The ModuleRegistrar class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ModuleRegistrar`, which implements the previously mentioned interface, will
    look something like the following. This basically behaves as a wrapper for the
    built-in IoC Container to register dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the two important aspects of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IServiceCollection` is injected into the constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injected `IServiceCollection` used to add dependencies into the container using
    `ServiceDescriptor` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class is a part of the Common Library.
  prefs: []
  type: TYPE_NORMAL
- en: '**Service Descriptor:** `IServiceCollection` is the collection of the service
    descriptors. A Service Descriptor instance when created can provide full information
    about a service or dependency. We have different methods for different lifestyles
    such as `AddTransient`, `AddScoped`, and `AddSingleton` to register dependencies.
    However, we can''t write all three methods to manage the dependencies at a commonplace.
    That is where a Service Descriptor can help takes lifetime as a parameter and
    can be added directly to the `ServiceCollection` using the `Add` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The IModule interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IModule` is the main hero of the architecture because this is the first thing
    which will be used by a Loader to recognize what modules are required to be fetched
    from all the assemblies that are targeted. This interface exposes one method, `Initialize()` which
    is invoked by the Loader to add dependencies into the container. Consider the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This interface lies inside Common Library as well.
  prefs: []
  type: TYPE_NORMAL
- en: The ModuleInit class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how the preceding `IModule` interface can be implemented inside
    the `Business Layer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`ModuleInit` is present inside both the `Business Layer` and `Data Access Layer`.
    This class helps us to add different dependencies in each layer such as `UsersService`
    in `Business` and `UsersRepository` in `Data Access`. You can see how `UserService`
    is added to the registrar inside `Business Layer`. I am skipping `ModuleInit`
    of the `DataAccess Layer`. It''s just a change of one line inside `Initialize`.
    The following line of code can be added for `UserRepository` dependency registration
    inside `ModuleInit` of `Data Access Layer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Just make a note of the bold part `([Export(typeof(IModule))])` in the last-but-one
    code block, which is very important. This is the attribute, which helps MEF to
    grab the `ModuleInit` classes in the specified assemblies, with the interface
    `IModule`. It can then easily call `Initialize` to start the process of registering
    dependencies. We will very soon see the code, that does this task for us.
  prefs: []
  type: TYPE_NORMAL
- en: Wait! We have a Constructor Injection here. And what is that used for? Actually,
    the code for registering the dependency lies inside the registrar, so we definitely
    need the `IModuleRegistrar` dependency in order to call `Add()` of `Registrar`,
    which registers the required dependency, for example, `UsersService` here inside
    `Business Layer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the flow of controls during the process of dependency registrations.
    Typically the flow is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ModuleLoader` | `ModuleInit(IRegistrar)` | `ModuleRegistrar` | `Add()` (adds
    the dependency to collection):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visualizes the work of **Module Loader** through the
    available layers as discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64d3c9f2-a4db-427e-bc1b-a9bd16890fb0.png)'
  prefs: []
  type: TYPE_IMG
- en: The ModuleLoader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with MEF, we need a Nuget package known as </span>`Microsoft.Composition.`
    This will install `System.Composition` into the project. You need to add the package
    inside the `Common Layer`. `ContainerConfiguration` is the class present inside
    the `System.Composition.Hosting` namespace, which composes all assemblies and
    can provide us with a Container, from which we can easilyextract the required
    concrete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the `NuGet` Package preview shown in the NuGet
    Package Manager window when you search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b5c02b-44b6-42f5-9f65-79fe3ef5a5f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally the last, but not the least,  `ModuleLoader`. All that we have learned
    till now is managed by the Loader which is a static class with one method `LoadContainer`.
    This method is invoked by our MVC Web App `Startup` to initialize the dependency
    registration process. Let''s have a sneak peek at the codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I have added comments over each step so that it will be easy for you to analyze
    the steps. The steps can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `Web App Assembly Location`. As we are going to call this method from
    Web App and every other assembly is placed there, we need that location to find
    others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find out, what other assemblies present in that particular location. However,
    we need to have DLLs of the layers we have in our app. For that reason, a pattern
    is necessary to recognize the assemblies of the layers. According to our layers,
    we only need to find all assembly names starting with PacktDIExamples and ending
    with `.dll`, because the Layer names are like `PacktDIExamples.Business.dll` and `PacktDIExamples.DataAccess.dll`.
    So, the pattern will be `PacktDIExamples.*.dll`. We will see the code sends this
    pattern to the `LoadContainer` in a moment. You can see the extracted modules
    shown in the Visual Studio tooltip while debugging, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/118fd71a-eb45-4c62-a0c7-ab68c473a375.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a container to hold all the assemblies using the `ContainerConfiguration`
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now `container.GetExports<IModule>()` is used to extract the `IModule` implementation
    from these assemblies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `Initialize` method for each `IModule` implementations with a registrar
    instance as a dependency because the `Registrar` has the actual `Add` method for
    dependency registration with the `ServiceCollection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I would advise you to put `try...catch` blocks in this method to handle the
    exceptions. Due to the space restrictions, I have not posted the `try...catch`
    block. I just want to show the core logic of a `ModuleLoader`. I have also removed
    the `usings`, which were taking up a lot of space. You can figure out the `usings`,
    anyway; if not, use Visual Studio. Hover on the red lines and then follow the
    steps which will include the required libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the ModuleLoader.LoaderContainer() method from Web App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the final step and the simplest one. See how we can call this Loader
    from the Web App inside the `Startup` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned, we need to send a pattern to fetch the Assembly names from `bin/debug/netcoreapp2.0`;
    otherwise, it will fetch all assemblies, which is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are sending the services to the `LoadContainer`. Now the previous
    code for registering the dependencies is commented, which got optimized by the `ModuleLoader.LoadContainer`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: What have we achieved with MEF?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not yet realized the benefits of refactoring the layered architecture
    with MEF, have a close look at the following screenshot with explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Layers are separated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layers were tightly coupled as the UI was referencing the `Business Layer`
    and the `Data Access Layer`. Now after MEF, the UI is not tied to the `Data Access
    Layer` anymore. However, the UI has one `Business Layer` assembly reference as
    shown in the following screenshot. But that is not used anywhere inside the project.
    It is there because the assembly should be inside the `bin` folder so that the
    MEF Module is able to read it while initializing to export the `IModule` implementations.
    The following is a quick comparison of Project Dependencies before and after MEF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a29dad10-90ff-43ba-b7a0-fd385789141e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you try to remove the Business reference from the UI and run the app, it
    will throw an exception, as follows. And this is for obvious reasons. Unless you
    have the reference, MEF won't be able to extract the `IUsersService` implementation
    and register to the DI Container, simple!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the issue happens as soon as you hit the controller, as nothing has been
    registered to the `IServiceCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3c845fb-67be-48ee-917b-ad6b5b5fc745.png)'
  prefs: []
  type: TYPE_IMG
- en: All classes inside layers are now internal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of having `public` as the access specifiers for the classes, we can
    make them `internal` so that they are only accessible inside the assembly (this
    means only internally inside the Layer):'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/ffb885fe-c0ca-4295-8741-62720a46541f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: No concrete class instantiation inside the UI Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before MEF implementation, we saw how, inside the `Edit` action method, we could
    directly reference the `Data Access Layer` and `Business Layer` classes. Now we
    won't be able to do this because the classes are not accessible anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is proved from the compiler errors inside `UsersController` as shown in
    the following screenshot. Notice the tooltip preview, which indicates the unavailability
    of the UsersService. So, misusing classes of other layers is restricted even if
    you add the references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bf50224-e455-4124-bc5d-b38f56c0f499.png)'
  prefs: []
  type: TYPE_IMG
- en: More layers can be added to the architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When, in the future, you add more layers for optimisation or any other business-related
    requirements, that assembly can be simply referred to by the UI; then every dependency
    will automatically get registered to the IoC Container. Remember, you need have
    to a `ModuleInit` class implementing the interface `IModule` to automate the process.
    The application is totally flexible now, allowing new modules to be attached easily
    with no hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern applications follow a layered architecture. Having a Dependency
    Injection technique to manage the dependencies required inside the layers is something
    we should be following. Having said that, we need to be careful with layer designs.
    That is because we applied DI, thinking that it would resolve issues of tight
    coupling with the dependencies of a class. However, we did not realize that the
    layers are getting connected with each other through concrete dependencies (such
    as the `User` instance return type).
  prefs: []
  type: TYPE_NORMAL
- en: '*Managed Extensibility Framework* provided us with a few easy steps to dynamically
    bind the dependencies from different layers, package them into one, and then register
    it to the container for further use by the controllers in the `UI Layer`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning DI Techniques, Patterns, Anti-Patterns and so on, we still needed
    some pointers to deal with practical scenarios where DI comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: We explored a few real-time application instances where DI can help eliminate
    coupling and introduce a cleaner dependency structure.
  prefs: []
  type: TYPE_NORMAL
- en: Tightly coupled systems are often seen when a developer tries to be lazy and
    instantiates the required dependencies directly inside the class using the `new` operator.
    Keep in mind that new is glue. This not only instills a bad practice in you as
    a coder but also makes your code untestable. Unit testing becomes difficult. We
    learned the technique to deal with the problem of tight coupling by following
    DI techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Then we realized that layering in an application is a common approach with applications.
    Having DI is definitely going to help us in the long run for layered systems.
    However, there might be loose ends in the layered approach which should be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: MEF is the technique which we adopted to solve a couple of problems with layered
    architecture. By implementing MEF, the business or data layer implementations
    can be marked as internal so that they are not exposed to other layers. Also,
    layer architectural rules for the separation of concerns can remain intact with
    a DI container. Thus, the layers can breathe independently without any interference
    and decorate the architecture in such a way that the introduction of new modules
    into it becomes very smooth.
  prefs: []
  type: TYPE_NORMAL
