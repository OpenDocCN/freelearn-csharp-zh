- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: CI/CD – Building Quality Software Automatically
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD – 自动构建高质量软件
- en: In my career, someone once said to me, “*CI/CD is dead, long live CI/CD*.” Of
    course, this phrase doesn’t mean it’s completely dead. It simply means CI/CD is
    now becoming the standard for software development, a common practice developers
    should adopt and learn during a software development life cycle. It is now considered
    part of your development process as opposed to being a shiny, new process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，有人曾经对我说，“*CI/CD 已死，长命 CI/CD*。”当然，这句话并不意味着它已经完全死亡。它只是意味着 CI/CD 现在已经成为软件开发的标准，是开发者在软件开发生命周期中应该采用和学习的常见做法。现在，它被视为你开发过程的一部分，而不是一个光鲜的新流程。
- en: In this chapter, we’ll review what **Continuous Integration**/**Continuous Deployment**
    (**CI**/**CD**) means and how to prepare your code for a pipeline. Once we’ve
    covered the necessary changes to include in your code, we’ll discuss what a common
    pipeline looks like for building software. Once we understand the pipeline process,
    we’ll look at two ways to recover from an unsuccessful deployment and how to deploy
    databases. We’ll also cover the three different types of cloud services available
    to you (on and off-premises and hybrid) and review a list of the top CI/CD providers
    on the internet. Finally, we’ll walk you through the process of creating a build
    for a sample application, along with other types of projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾 **持续集成**/**持续部署**（**CI**/**CD**）的含义以及如何为管道准备你的代码。一旦我们涵盖了需要包含在代码中的必要更改，我们将讨论构建软件的常见管道是什么样的。一旦我们理解了管道过程，我们将探讨两种从失败的部署中恢复的方法以及如何通过管道部署数据库。我们还将涵盖你可用的三种不同类型的云服务（本地和远程以及混合型）并回顾互联网上顶级
    CI/CD 提供商的列表。最后，我们将带你了解为示例应用程序创建构建的过程，以及其他类型的项目。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is CI/CD?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 CI/CD？
- en: Preparing your Code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备你的代码
- en: Understanding the Pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解管道
- en: The Two “Falling” Approaches
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种“坠落”方法
- en: Deploying Databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署数据库
- en: The three Types of Build Providers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种构建提供者类型
- en: CI/CD Providers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD 提供商
- en: Walkthrough of Azure Pipelines
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Pipelines 演示
- en: After you’ve completed this chapter, you’ll be able to identify flaws in software
    when you’re preparing code for software deployment, understand what a common pipeline
    includes in producing quality software, identify two ways of recovering from an
    unsuccessful deployment, know how to deploy databases through a pipeline, understand
    the different types of CI/CD providers, and know some key players in the CI/CD
    provider space.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够在准备软件部署代码时识别软件中的缺陷，了解常见管道在产生高质量软件时包含的内容，识别两种从失败的部署中恢复的方法，知道如何通过管道部署数据库，了解不同类型的
    CI/CD 提供商，以及了解 CI/CD 提供商空间中的关键参与者。
- en: Finally, we’ll walk through a common pipeline in Azure Pipelines to encompass
    everything we’ve learned in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过 Azure Pipelines 中的一个常见管道来回顾本章所学的一切。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, the only technical requirements include having access to a
    laptop and an account for one of the cloud providers mentioned in the *CI/CD providers*
    section (preferably Microsoft’s Azure Pipelines – don’t worry, it’s free).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，唯一的技术要求是能够访问一台笔记本电脑，以及 *CI/CD 提供商* 部分中提到的云服务提供商的账户（最好是微软的 Azure Pipelines
    – 不要担心，它是免费的）。
- en: Once you have reviewed how pipelines are created, you’ll be able to apply the
    same concepts to other cloud providers and their pipeline strategies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了如何创建管道，你将能够将相同的概念应用到其他云服务提供商及其管道策略上。
- en: What is CI/CD?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 CI/CD？
- en: In this section, we’ll learn about what continuous integration and continuous
    deployment mean to developers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解持续集成和持续部署对开发者意味着什么。
- en: '**Continuous Integration** (**CI**) is the process of merging all developers’
    code into a mainline to trigger an automatic build process so that you can quickly
    identify issues with a code base using unit tests and code analysis.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是将所有开发者的代码合并到主线中，以触发自动构建过程，这样你可以快速使用单元测试和代码分析来识别代码库中的问题。'
- en: When a developer checks their code into a branch, it’s reviewed by peer developers.
    Once accepted, it’s merged into a mainline and automatically starts a build process.
    This build process will be covered shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者将他们的代码检入分支时，它会被同行开发者审查。一旦被接受，它就会被合并到主线中，并自动开始构建过程。这个构建过程将在稍后介绍。
- en: '**Continuous Deployment** (**CD**) is the process of consistently creating
    software to deploy it at any time.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续部署**（**CD**）是持续创建软件以便在任何时候都可以部署的过程。'
- en: Once everything has been built through the automated process, the build prepares
    the compiled code and creates artifacts. These artifacts are used for consistent
    deployments across various environments, such as development, staging, and production.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有内容都通过自动化过程构建完成，构建过程会准备编译后的代码并创建工件。这些工件用于在各种环境中的一致部署，例如开发、测试和生产环境。
- en: 'The benefits of implementing a CI/CD pipeline outweigh not having one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实施CI/CD管道的好处超过了没有它的情况：
- en: '**Automated Testing**: When a commit is triggered, your tests are automatically
    executed along with your build. Think of this as someone always checking your
    code on commit.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试**：当提交被触发时，你的测试会自动与构建一起执行。想象一下，有人在每次提交时都会检查你的代码。'
- en: '**Faster Feedback Loops**: As a developer, it’s always great to receive immediate
    feedback to find out whether something works or not. If you receive an email where
    the build broke, you’re on your own.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的反馈循环**：作为开发者，总是收到即时的反馈以了解某件事是否工作是非常好的。如果你收到一封构建失败的邮件，那么你只能自己处理。'
- en: '**Consistent Builds**: Once you have a project being built on a build server,
    you can create builds on-demand – and consistently – with tests.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的构建**：一旦你的项目在构建服务器上构建，你就可以创建带有测试的按需构建——并且是一致的。'
- en: '**Collaboration Between Teams**: We’re all in this together and CI/CD includes
    developers, system administrators, project managers/SCRUM masters, and QA testers,
    to name a few, to accomplish the goal of creating great software.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队协作**：我们都在同一个战壕里，CI/CD包括开发者、系统管理员、项目经理/敏捷大师以及QA测试员等，以实现创建优秀软件的目标。'
- en: In this section, we reviewed the definition of what continuous integration and
    continuous deployment mean when developing software in an automated fashion and
    the benefits of implementing a CI/CD pipeline.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了在自动化方式开发软件时，持续集成和持续部署的定义以及实施CI/CD管道的好处。
- en: In the next section, we’ll learn about certain code practices to avoid when
    automating software builds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解在自动化软件构建时应避免的某些代码实践。
- en: Preparing your Code
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的代码
- en: In this section, we’ll cover certain aspects of your code and how they could
    impact the deployment of your software. Such software issues could include code
    not compiling (broken builds), avoiding relative path names, and making sure you
    wrote proper unit tests. These are a couple of the common errors I’ve experienced
    over the years; in this section, I’ll also provide solutions on how to fix them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论你的代码的某些方面以及它们如何可能影响你软件的部署。这些软件问题可能包括代码无法编译（构建失败）、避免使用相对路径名称，以及确保你编写了适当的单元测试。这些是我多年来遇到的一些常见错误；在本节中，我还会提供如何修复它们的解决方案。
- en: Before we review a CI pipeline, there are a few caveats we should address beforehand.
    Even though we covered a lot in the previous chapter regarding version control,
    your code needs to be in a certain state to achieve “one-button” builds.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们审查CI管道之前，有一些注意事项我们需要事先解决。尽管我们在上一章中已经涵盖了版本控制的大部分内容，但你的代码需要处于某种状态才能实现“一键”构建。
- en: In the following sections, you’ll learn how to prepare your code so that it’s
    “CI/CD-ready” and examine the problems you could experience when deploying your
    software and how to avoid them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将了解如何准备你的代码以便它“CI/CD就绪”，并检查你在部署软件时可能遇到的问题以及如何避免这些问题。
- en: Building Flawlessly
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无缝构建
- en: If a new person is hired and starts immediately, you want them to hit the ground
    running and begin developing software without delay. This means being able to
    point them to a repository and pull the code so that you can *immediately* run
    the code *with* *minimal setup*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新员工被雇佣并立即开始工作，你希望他们能够迅速上手，开始开发软件而无需延迟。这意味着能够将他们指向一个仓库并拉取代码，这样你就可以*立即*运行代码，并且*最小化*设置。
- en: I say “minimal setup” because there may be permissions involved to gain access
    to certain resources in the company so that they can be run locally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“最小化设置”，因为可能涉及权限问题，以便访问公司中某些资源，以便它们可以在本地运行。
- en: Nevertheless, the code should be in a runnable state, send you to a simple screen
    of some kind, and notify the user to follow up on a permissions issue or provide
    some notification to resolve the problem.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，代码应该处于可运行状态，引导你到一个简单的屏幕，并通知用户跟进权限问题或提供一些通知以解决问题。
- en: 'In the previous chapter, we mentioned how the code should compile at all times.
    This means the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了代码应该始终编译。这意味着以下内容：
- en: The code should always compile after a clone or checkout
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码应该在克隆或检出后始终编译
- en: Unit tests should be included with the build, not in separate projects
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该包含在构建中，而不是在单独的项目中
- en: Your commit messages to version control should be meaningful (they may be used
    for Release Notes)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的版本控制提交信息应该是有意义的（它们可能用于发布说明）
- en: These standards allow your pipeline to fall into the pit of success. They help
    you create a build even faster and easier when your code is in a clean state.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标准允许你的管道落入成功的陷阱。当你的代码处于干净状态时，它们帮助你更快、更轻松地创建构建。
- en: Avoiding Relative Path Names with File-based Operations
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用基于文件的操作的相对路径名称
- en: One of the troublesome issues I’ve seen over the years when it comes to web
    applications is how files are accessed in a web application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，我在处理Web应用程序时遇到的一个棘手问题是文件如何在Web应用程序中被访问。
- en: I’ve also seen file-based operations through a web page, where files were moved
    using relative paths and it went wrong. It involved deleting directories and it
    didn’t end well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我也见过通过网页进行基于文件的操作，其中文件使用相对路径移动，结果出了问题。这涉及到删除目录，结果并不好。
- en: 'For example, let’s say you had a relative path to an image, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个指向图像的相对路径，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let’s say you’re sitting on a web page, such as `https://localhost/kitchen/chairs`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你坐在一个网页上，比如`https://localhost/kitchen/chairs`。
- en: If you went back one directory, you’d be in the kitchen with a missing image,
    not at the root of the website. According to your relative path, you’re looking
    for an image directory at `https://localhost/kitchen/images/myimage.jpg`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你退回到一个目录，你会在厨房里找到一个缺失的图像，而不是在网站的根目录。根据你的相对路径，你正在寻找`https://localhost/kitchen/images/myimage.jpg`中的图像目录。
- en: To make matters worse, if you’re using custom routing, this may not even be
    the normal path, and who knows where it’s looking for the image.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，如果你使用自定义路由，这甚至可能不是正常的路径，谁知道它在哪里寻找图像。
- en: The best approach when preparing your code is to use a single slash (`/`) at
    the beginning of your URL since it’s considered “absolute:”
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备你的代码时，最佳做法是在你的URL开头使用单个斜杠（`/`），因为它被认为是“绝对”的：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This makes it easier to navigate to the root when you’re locating files on a
    website, regardless of what environment you’re in. It doesn’t matter if you are
    on [https://www.myfakewebsite.com/](https://www.myfakewebsite.com/) or [http://localhost/](http://localhost/),
    the root is the root, and you’ll always find your files when using a single slash
    at the beginning of your sources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在网站上定位文件时更容易导航到根目录，无论你处于什么环境。无论你是位于[https://www.myfakewebsite.com/](https://www.myfakewebsite.com/)还是[http://localhost/](http://localhost/)，根目录就是根目录，你将始终使用源开头的一个斜杠找到你的文件。
- en: Confirming that your Unit Tests are Unit Tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认你的单元测试是单元测试
- en: Tests in your code are created to provide checks and balances so that your code
    works as expected. Each test needs to be examined carefully to confirm it isn’t
    doing anything out of the ordinary.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的测试是为了提供检查和平衡，以确保代码按预期工作。每个测试都需要仔细检查，以确认它没有做任何不寻常的事情。
- en: 'Unit tests are considered tests against code in memory, whereas integration
    tests are tests that require *ANY* external resources:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试被认为是针对内存中代码的测试，而集成测试是需要*任何*外部资源的测试：
- en: Do your tests access any files? Integration test.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试访问任何文件吗？集成测试。
- en: Do you connect to a database to test something? Integration test.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否连接到数据库来测试某些内容？集成测试。
- en: Are you testing business logic? Unit test.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在测试业务逻辑吗？单元测试。
- en: As you’re beginning to surmise, when you build your application on another machine,
    cloud services do not have access to your database server and also may not have
    the additional files you need for each test to pass.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你开始推测的那样，当你在一个其他机器上构建你的应用程序时，云服务无法访问你的数据库服务器，也可能没有每个测试通过所需的附加文件。
- en: If you are accessing external resources, it may be a better approach to refactor
    your tests into something a little more memory-driven. I’ll explain why in [*Chapter
    7*](B19493_07.xhtml#_idTextAnchor163), when we’ll cover **unit testing**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在访问外部资源，将你的测试重构为更内存驱动的方法可能是一个更好的选择。我将在[*第7章*](B19493_07.xhtml#_idTextAnchor163)中解释原因，届时我们将涵盖**单元测试**。
- en: Creating Environment Settings
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建环境设置
- en: Whether you are in the middle of a project or are clicking **Create New Project…**
    for the first time, you need a way to create environment settings for your web
    application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在项目中间，还是第一次点击 **创建新项目…**，你都需要一种方法来为你的Web应用程序创建环境设置。
- en: In ASP.NET Core applications, we are given `appsettings.json` and `appsettings.Development.json`
    configuration files out of the box. The `appsettings.json` file is meant to be
    a base configuration file and, depending on the environment, each `appsettings`
    file is applied and only existing properties are overwritten to the `appsettings.json`
    file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core应用程序中，我们默认提供了`appsettings.json`和`appsettings.Development.json`配置文件。`appsettings.json`文件旨在作为一个基本配置文件，并且根据环境的不同，每个`appsettings`文件都会应用，并且只覆盖现有的属性到`appsettings.json`文件。
- en: One common example of this is connection strings and application paths. Depending
    on the environment, each file will have its own settings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个常见例子是连接字符串和应用程序路径。根据环境的不同，每个文件都会有自己的设置。
- en: The environments need to be defined upfront as well. There will always be a
    development and release environment. There may be an option to create another
    environment called QA on another machine somewhere, so an `appsettings.qa.json`
    file would be required with its own environment-specific settings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 环境也需要提前定义。总会有开发和发布环境。可能有一个选项在另一台机器上创建另一个名为QA的环境，因此需要一个`appsettings.qa.json`文件，其中包含其自己的特定环境设置。
- en: Confirm that these settings have been saved for each relevant environment since
    they are important in a CI/CD pipeline. *These environment settings should always
    be checked into version control with your solution/project* to assist the pipeline
    in deploying the right settings to the right environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 确认这些设置已为每个相关环境保存，因为它们在CI/CD流水线中很重要。*这些环境设置应始终与你的解决方案/项目一起提交到版本控制中，以帮助流水线将正确的设置部署到正确的环境中*。
- en: In this section, we covered ways to prepare your code for a CI/CD pipeline by
    making sure we can build immediately after cloning or pulling the repository down
    locally, why we should avoid relative-based file paths, and confirmed we were
    using environment-specific application settings, making it easy to build and deploy
    our application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何通过确保我们可以在克隆或本地拉取存储库后立即构建来准备代码以供CI/CD流水线使用，为什么我们应该避免基于相对路径的文件路径，并确认我们正在使用特定环境的应用程序设置，这使得构建和部署我们的应用程序变得容易。
- en: With your code checked in, we can now move forward and describe all of the stages
    of a common pipeline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码已提交后，我们现在可以继续前进，描述常见流水线的所有阶段。
- en: Understanding the Pipeline
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解流水线
- en: In this section, we’ll cover the steps of what a common pipeline includes for
    building software when using a CI/CD service. When you reach the end of this section,
    you’ll understand every step of the process in a common pipeline so that you can
    produce quality software.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在CI/CD服务中构建软件时，常见流水线包括的步骤。当你到达本节的结尾时，你将理解常见流水线中的每个步骤，以便你可以生产出高质量的软件。
- en: A CI pipeline is a collection of steps required to code, build, test, and deploy
    software. Each step is not owned by a particular person but by a team working
    together and focusing on the goal to produce exceptional software. The good news
    is that if you followed the previous chapter’s recommendations, you’re already
    ahead of the game.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: CI流水线是一系列必要的步骤，用于编码、构建、测试和部署软件。每个步骤不是由特定个人拥有，而是由一个共同协作并专注于生产卓越软件目标的团队拥有。好消息是，如果你遵循了上一章的建议，你已经领先一步了。
- en: Each company’s pipeline can vary from product to product, but there will always
    be a common set of steps for a CI process. It depends on how detailed your pipeline
    becomes based on your needs. The stages in the pipelines can be influenced by
    each stakeholder involved in the process. Of course, pulling code and building
    and testing are required for the developers, but a QA team requires the finished
    product (artifact) to be sent to another server for test purposes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个公司的流水线可能因产品而异，但CI过程总会有一个共同的步骤集。这取决于你的需求，流水线的阶段可能会受到参与过程中的每个利益相关者的影响。当然，对于开发者来说，需要拉取代码、构建和测试是必需的，但QA团队需要将最终产品（工件）发送到另一台服务器进行测试。
- en: '*Figure 2**.1* shows one common pipeline:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1* 展示了一个常见的流水线：'
- en: '![Figure 2.1 – One example of a build pipeline](img/Figure_2.01_B19493.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 构建流水线的一个示例](img/Figure_2.01_B19493.jpg)'
- en: Figure 2.1 – One example of a build pipeline
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 构建流水线的一个示例
- en: 'As shown in *Figure 2**.1*, the process is sequential when creating a software
    deployment. Here’s a summary of the steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 2**.1*所示，在创建软件部署时，过程是顺序的。以下是步骤的总结：
- en: Pull code from a single repository.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从单个存储库拉取代码。
- en: Build the application.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序。
- en: Run unit tests/code analysis against the code that was built in *step 2*.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤 2*中构建的代码上运行单元测试/代码分析。
- en: Create the artifacts.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建工件。
- en: Create a container (optional).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建容器（可选）。
- en: Deploy the artifact(s) to a server (development/QA/staging/production).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工件部署到服务器（开发/测试/预发布/生产）。
- en: Now that we’ve defined a common pipeline, let’s dig deeper into each step to
    learn what each process includes when you’re building your software.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个通用管道，让我们深入了解每个步骤，了解在构建您的软件时每个过程包含什么。
- en: In the following subsections, we’ll examine each process in detail based on
    the steps defined here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将根据这里定义的步骤详细检查每个过程。
- en: Pulling Code
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取代码
- en: Before we build the application, we need to identify the project we’re building
    in our pipeline. The pipeline service requires a repository location. Once you’ve
    provided the repository URL, the service can prepare the repository for compilation
    on their server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建应用程序之前，我们需要在我们的管道中确定我们要构建的项目。管道服务需要一个存储库位置。一旦您提供了存储库 URL，该服务就可以在他们的服务器上为编译准备存储库。
- en: In the previous section, we mentioned why your code needs to compile flawlessly
    after cloning. The code is cloned and built on a completely different machine
    from yours. If the application only works on your computer and no one else’s,
    as the saying goes, “We’ll have to ship your computer to all of our users.” While
    this is a humorous saying in the industry, it’s generally frowned upon when writing
    and deploying software in the real world.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到了为什么在克隆后您的代码需要完美编译。代码是在与您的完全不同的机器上克隆和构建的。如果应用程序只在您的计算机上工作，而其他人则不行，就像行业中的一句俗语所说，“我们得把您的电脑运给所有我们的用户。”虽然这是一句行业中的幽默说法，但在现实世界中编写和部署软件时通常是不受欢迎的。
- en: Each of the DevOps services has its benefits. For example, Azure Pipelines can
    examine your repository and make assumptions based on the structure of your project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个DevOps服务都有其优点。例如，Azure Pipelines 可以检查您的存储库，并根据您项目的结构做出假设。
- en: After analyzing the project, it uses a file format called YAML (pronounced Ya-mel)
    to define how the project should be built. While YAML is now considered a standard
    in the industry, we won’t deep-dive into everything YAML encompasses. YAML functionality
    could be a book on its own.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 分析项目后，它使用一种称为 YAML（发音为 Ya-mel）的文件格式来定义项目应该如何构建。虽然 YAML 现在被认为是行业标准，但我们不会深入探讨
    YAML 所包含的所有内容。YAML 功能可能是一本单独的书。
- en: Azure takes your project’s assumptions and creates a YAML template on how it
    should build your application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 会根据如何构建您的应用程序创建一个 YAML 模板。
- en: It knows how to compile the application, identify whether a container is included
    in the project, and also retrieve NuGet packages before performing the build.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它知道如何编译应用程序，确定容器是否包含在项目中，并在构建之前检索 NuGet 包。
- en: 'One last thing to mention is that most DevOp services allow one repository
    per project. The benefits of this approach include the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的是，大多数 DevOps 服务允许每个项目一个存储库。这种方法的优点包括以下内容：
- en: '**Simplicity**: It’s simpler to manage and build one application as opposed
    to orchestrating hundreds of applications in a project.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：管理并构建一个应用程序比在一个项目中编排数百个应用程序要简单得多。'
- en: '**Collaboration**: Instead of multiple teams focusing on one large project,
    it’s easier to have one or two smaller teams working on a single, more manageable
    project.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：与其让多个团队专注于一个大项目，不如让一个或两个较小的团队在一个更易于管理的单一项目上工作。'
- en: '**Faster builds**: CI/CD pipelines are meant to provide fast feedback and even
    faster improvement. The smaller the project, the faster a build, test, and deployment
    will occur.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快地构建**：CI/CD 管道旨在提供快速的反馈和更快的改进。项目越小，构建、测试和部署就会越快。'
- en: With that said, we are now ready to build the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们现在已经准备好构建应用程序。
- en: Building the application
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: As mentioned previously, YAML files define how the service proceeds with building
    your application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，YAML 文件定义了服务如何构建您的应用程序。
- en: It’s always a good practice to confirm the YAML file contains everything you
    need before building. If you have a simple project, the boilerplate included in
    the wizard may be all you need, but it allows you to make updates in case additional
    files are required, or other application checks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总是确认在构建之前 YAML 文件包含你所需的一切是一个好习惯。如果你有一个简单的项目，向导中包含的样板文件可能就足够了，但它允许你在需要时进行更新，或者进行其他应用程序检查。
- en: It may take a couple of attempts to massage the YAML file, but once you get
    the file in a stable state, it’s great to see everything work as expected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要尝试几次来调整 YAML 文件，但一旦文件处于稳定状态，看到一切按预期工作是非常令人欣慰的。
- en: Make sure you have retrieved all your code before building the application.
    If this step fails, the process kicks out of the pipeline.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在构建应用程序之前已经检索了所有代码。如果这一步失败，流程将退出管道。
- en: If you checked in bad code and the build fails, the proper authorities (developers
    or administrators) will be notified based on the alert level and you’ll be given
    the dunce hat or the stuffed monkey for breaking the build until someone else
    breaks it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提交了糟糕的代码并且构建失败，根据警报级别，适当的权威机构（开发者或管理员）将被通知，并且你将因为破坏构建而得到一个傻瓜帽或填充的猴子，直到有人打破它。
- en: Next, we’ll focus on running unit tests and other tests against the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于对应用程序运行单元测试和其他测试。
- en: Running Unit Tests/Code Analysis
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行单元测试/代码分析
- en: Once the build is done, we can move forward with the unit tests and/or code
    analysis.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以继续进行单元测试和/或代码分析。
- en: Unit tests should run against the compiled application. This includes unit tests
    and integration tests, but as we mentioned previously, be wary of integration
    tests. The pipeline services may not have access to certain resources, causing
    your tests to fail.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该针对编译后的应用程序运行。这包括单元测试和集成测试，但如我们之前提到的，要小心集成测试。管道服务可能无法访问某些资源，这可能导致你的测试失败。
- en: Unit tests, by nature, should be extremely fast. Why? Because you don’t want
    to wait for 30 minutes for unit tests to run (which is painful). If you have unit
    tests taking that long, identify the longest-running unit tests and refactor them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试，按其本质，应该非常快。为什么？因为你不希望等待 30 分钟来运行单元测试（这是痛苦的）。如果你有单元测试需要那么长时间，请识别运行时间最长的单元测试并进行重构。
- en: Once the code has been compiled and loaded, unit tests should be running every
    10-30 seconds as a general guideline since they are memory-based.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码编译并加载，单元测试应该每 10-30 秒运行一次，这是一个一般性指南，因为它们是基于内存的。
- en: While unit and integration tests are common in most testing scenarios, there
    are additional checks you can add to your pipeline, which include identifying
    security issues and code metrics to generate reports at the end of your build.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试和集成测试在大多数测试场景中很常见，但你可以在你的管道中添加额外的检查，包括识别安全问题和代码度量，以便在构建结束时生成报告。
- en: Next, our build creates artifacts to be used for deployments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的构建会创建用于部署的工件。
- en: Creating Artifacts
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工件
- en: Once the build succeeds and all of the tests pass, the next step is to create
    an artifact of our build and store it in a central location.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建成功并且所有测试通过，下一步就是创建我们的构建工件并将其存储在中央位置。
- en: As a general rule, it’s best to only create your binaries once. Once they’ve
    been built, they’re available at a moment’s notice. These artifacts can deploy
    a version to a server on a whim without going through the entire build process
    again.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，最好只创建一次二进制文件。一旦它们被构建，它们可以随时使用。这些工件可以随意将版本部署到服务器，而无需再次通过整个构建过程。
- en: The artifacts should be tamper-proof and never be modified by anyone. If there
    is an issue with the artifact, the pipeline should start from the beginning and
    create a new artifact.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 工件应该是防篡改的，并且任何人都不应该修改它们。如果工件存在问题，管道应该从头开始并创建一个新的工件。
- en: Let’s move on to containers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论容器。
- en: Creating a Container
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建容器
- en: Once you have created the self-contained artifact, an *optional* step is to
    build a container around it or install the artifact in the container. While most
    enterprises use various platforms and environments, such as Linux or Windows,
    “containerizing” an application with a tool such as Docker allows it to run on
    any platform while isolating the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了自包含的工件，一个可选的步骤是围绕它构建容器或将其安装到容器中。虽然大多数企业使用各种平台和环境，如 Linux 或 Windows，但使用
    Docker 等工具“容器化”应用程序允许它在任何平台上运行，同时隔离应用程序。
- en: With containers considered a standard in the industry, it makes sense to create
    a container so that it can easily be deployed to any platform, such as Azure,
    **Amazon Web Services** (**AWS**), or Google Cloud Provider. Again, this is an
    optional step, but it’s becoming an inevitable one in the industry.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到容器已成为行业标准，因此创建一个容器以便它可以轻松地部署到任何平台，如Azure、**亚马逊网络服务**（**AWS**）或Google Cloud
    Provider是有意义的。再次强调，这是一个可选步骤，但在行业中它正变得不可避免。
- en: When creating a new project with Visual Studio, you automatically get a container
    wrapper through a generated Docker file. This Dockerfile defines how the container
    will allow access to your application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Visual Studio创建新项目时，你将自动通过生成的Docker文件获得一个容器包装器。这个Docker文件定义了容器将如何允许访问你的应用程序。
- en: Once you’ve added the Dockerfile to your project, Azure identifies this as a
    container project and creates the container with the included project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将Docker文件添加到你的项目中，Azure就会将其识别为容器项目，并使用包含的项目创建容器。
- en: Lastly, we’ll examine deploying the software.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将检查软件的部署。
- en: Deploying the software
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署软件
- en: Once everything has been generated, all we need to do is deploy the software.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一切生成完毕后，我们所需做的就是部署软件。
- en: Remember the environment settings in your `appsettings.json` file? This is where
    they come in handy for deployments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你`appsettings.json`文件中的环境设置吗？这对于部署非常有用。
- en: Based on your environment, you can assign a task to merge the appropriate environment
    JSON file into the `appsettings.json` file on deployment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的环境，你可以在部署时将适当的JSON文件合并到`appsettings.json`文件中。
- en: Once you have your environment settings in order, you can define the destinations
    of your deployments any way you like.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的环境设置就绪，你可以以任何你喜欢的任何方式定义你的部署目的地。
- en: Deployments can range from FTP-ing or WebDeploy-ing the artifact or pushing
    the container to a server somewhere. All of these options are available out of
    the box.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可能包括将工件FTP或WebDeploy到服务器，或将容器推送到某个服务器。所有这些选项都是现成的。
- en: However, you must deploy the same way to every environment. The only thing that
    changes is the `appsettings` file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你必须以相同的方式部署到每个环境。唯一改变的是`appsettings`文件。
- en: After a successful (or unsuccessful) deployment, a report or notification should
    be sent to everyone involved in the deployment’s outcome.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功（或失败）部署后，应向所有参与部署结果的人员发送报告或通知。
- en: In this section, we learned what a common pipeline includes and how each step
    relies on a successful previous step. If one step fails throughout the pipeline,
    the process immediately stops. This “conveyor belt” approach to software development
    provides repeatable steps, quality-driven software, and deployable software.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了常见的管道包括什么以及每个步骤如何依赖于成功的上一个步骤。如果在管道中的任何步骤失败，过程将立即停止。这种“传送带”方法为软件开发提供了可重复的步骤、以质量驱动的软件和可部署的软件。
- en: The Two “Falling” Approaches
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两种“回退”方法
- en: In this section, we’ll learn about two ways to recover from a failed software
    deployment. After finishing this section, you’ll know how to use these two approaches
    to make a justified decision on recovering from a bad deployment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解两种从失败的软件部署中恢复的方法。完成本节后，你将知道如何使用这两种方法对不良部署的恢复做出合理的决定。
- en: In a standard pipeline, companies sometimes experience software glitches when
    deploying to a web server. Users may see an error message when they perform an
    action on the website.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准管道中，公司有时在部署到Web服务器时会遇到软件故障。当用户在网站上执行操作时，他们可能会看到错误消息。
- en: What do you do when the software doesn’t work as expected? How does this work
    in the DevOps pipeline?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件不符合预期时，你会怎么做？这在DevOps管道中是如何工作的？
- en: Every time you build software, there’s always a chance something could go wrong.
    You always need a backup plan *before* the software is deployed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每次构建软件时，总有可能出错。在软件部署之前，你总是需要一个备份计划。
- en: Let’s cover the two types of recovery methods we can use when software deployments
    don’t succeed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看当软件部署失败时我们可以使用的两种恢复方法。
- en: Falling Backward (or fallback)
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回退（或回退）
- en: If various bugs were introduced into the product and the previous version doesn’t
    appear to have these errors, it makes sense to revert the software or fall back
    to the previous version.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果产品中引入了各种错误，而前一个版本似乎没有这些错误，那么回滚软件或回退到前一个版本是有意义的。
- en: In a pipeline, the process at the end creates artifacts, which are self-contained,
    deployable versions of your product.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道中，末尾的过程创建工件，这是您产品的自包含、可部署版本。
- en: 'Here is an example of falling backward:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个向后跌倒的例子：
- en: Your software deployment was a success last week and was marked as version 1.1
    (v1.1).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您上周的软件部署成功，并被标记为版本 1.1（v1.1）。
- en: Over 2 weeks, development created two new features for the software and wanted
    to release them as soon as possible.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两周内，开发人员为软件创建了两个新功能，并希望尽快发布它们。
- en: A new build was created and released called version 1.3 (v1.3).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并发布了一个新版本，称为版本 1.3（v1.3）。
- en: While users were using the latest version (v1.3), they experienced issues with
    one of the new features, causing the website to show errors.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在使用最新版本（v1.3）时，他们遇到了一个新功能的问题，导致网站显示错误。
- en: Since the previous version (v1.1) doesn’t have this issue and the impact is
    not severe, developers can redeploy v1.1 to the server so that users can continue
    to be productive again.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于上一个版本（v1.1）没有这个问题，且影响不严重，开发人员可以将 v1.1 部署到服务器上，以便用户可以继续保持生产力。
- en: This type of release is called **falling backward**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的发布被称为**向后跌倒**。
- en: If you have to replace a current version (v1.3) with a previous version (v1.1)
    (except for databases, which I’ll cover in a bit), you can easily identify and
    deploy the last-known artifact.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须用旧版本（v1.1）替换当前版本（v1.3）（数据库除外，我稍后会讨论），您可以轻松地识别并部署最后一个已知的工件。
- en: Falling Forward
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向前跌倒
- en: If the fallback approach isn’t a viable recovery strategy, the alternative is
    to fall forward.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回退方法不是一个可行的恢复策略，那么替代方案就是向前跌倒。
- en: When falling forward, the product team accepts the deployment with errors (warts
    and all) and continues to move forward with newer releases while placing a high
    priority on these errors and *acknowledging the errors will be fixed in the next
    or* *future release*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当向前跌倒时，产品团队接受带有错误的部署（包括所有瑕疵），并继续推出新的版本，同时将这些错误置于高度优先级，并承认这些错误将在下一个或未来的版本中得到修复。
- en: 'Here is a similar example of falling forward:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个向前跌倒的类似例子：
- en: Again, a software deployment was successful last week and was marked as version
    1.5 (v1.5).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，上周的软件部署成功，并被标记为版本 1.5（v1.5）。
- en: Over another 2 weeks, development created another new large feature for the
    software.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的两周内，开发人员为软件创建了另一个新的大型功能。
- en: A new build was created and released called version 1.6 (v1.6).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并发布了一个新版本，称为版本 1.6（v1.6）。
- en: While users were using the latest version (v1.6), they experienced issues with
    one of the new features, causing the website to show errors.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在使用最新版本（v1.6）时，他们遇到了一个新功能的问题，导致网站显示错误。
- en: After analysis, the developers realized this was a “quick fix,” created the
    proper unit tests to show it was fixed, pushed a new release through the pipeline,
    and immediately deployed the fixed code in a new release (v1.7).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过分析，开发人员意识到这是一个“快速修复”，创建了适当的单元测试以证明问题已修复，通过管道推送了新的发布，并立即在新版本（v1.7）中部署了修复后的代码。
- en: This type of release is called **falling forward**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的发布被称为**向前跌倒**。
- en: The product team may have to examine each error and make a decision as to which
    recovery method is the best approach for the product’s reputation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 产品团队可能必须检查每个错误，并决定哪种恢复方法最适合产品的声誉。
- en: For example, if product features such as business logic or user interface updates
    are the issue, the best recovery method may be to fall forward since the impact
    on the system is minimal and a user’s workflow is not interrupted and productive.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果产品功能（如业务逻辑或用户界面更新）是问题所在，那么最好的恢复方法可能是向前跌倒，因为对系统的影响最小，用户的流程不会被打断，且保持生产力。
- en: However, if code *and* database updates are involved, the better approach would
    be to fall back – that is, restore the database and use a previous version of
    the artifact.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果涉及代码和数据库更新，更好的方法是将回退——即恢复数据库并使用工件的前一个版本。
- en: If it’s a critical feature and reverting is not an option, a “hotfix” approach
    (as mentioned in the previous chapter) may be required to patch the software.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个关键功能，且无法回滚，那么可能需要采用“热修复”方法（如前一章所述）来修复软件。
- en: Again, it depends on the impact each issue has left on the system as to which
    recovery strategy is the best approach.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这取决于每个问题对系统造成的影响，以确定哪种恢复策略是最好的方法。
- en: 'In this section, we learned about two ways to recover from unsuccessful software
    deployments: falling backward and falling forward. While neither option is a mandatory
    choice, each approach should be weighed heavily based on the error type, the recovery
    time of the fix, and the software’s deployment schedule.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了两种从失败的软件部署中恢复的方法：向后回退和向前跌倒。虽然这两个选项都不是强制性的选择，但每种方法都应根据错误类型、修复的恢复时间和软件的部署计划进行慎重考虑。
- en: Deploying Databases
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署数据库
- en: 'Deploying application code is one thing but deploying databases can be a daunting
    task if not done properly. There are two pain points when deploying databases:
    structure and records.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序代码是一回事，但如果操作不当，部署数据库可能是一项令人畏惧的任务。在部署数据库时有两个痛点：结构和记录。
- en: With a database’s structure, you have the issue of adding, updating, and removing
    columns/fields from tables, along with updating the corresponding stored procedures,
    views, and other table-related functions to reflect the table updates.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库结构方面，您会遇到向表中添加、更新和删除列/字段的问题，以及更新相应的存储过程、视图和其他与表相关的功能，以反映表更新。
- en: With records, the process isn’t as tricky as changing a table’s structure. The
    frequency of updating records is not as regular, but when it does, happen that’s
    when you either want to seed a database with default records or update those seed
    records with new values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录方面，这个过程并不像更改表结构那样复杂。更新记录的频率并不规律，但一旦发生，您可能希望用默认记录填充数据库，或者用新值更新这些种子记录。
- en: The following sections will cover some common practices when deploying databases
    in a CI/CD pipeline.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将介绍在 CI/CD 管道中部署数据库的一些常见做法。
- en: Backing up Before Deploying
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署前备份
- en: Since company data is essential to a business, it’s mandatory to back it up
    before making any modifications or updates to the database.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于公司数据对业务至关重要，在修改或更新数据库之前必须对其进行备份。
- en: 'One recommendation is to make the entire database deploy a two-step process:
    back up the database, then apply the database updates.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一项建议是将整个数据库部署过程分为两步：首先备份数据库，然后应用数据库更新。
- en: The DevOps team can include a pre-deployment script to *automatically* back
    up the database before applying the database updates. If the backup was successful,
    you can continue deploying your changes to the database. If not, you can immediately
    stop the deployment and determine the cause of failure.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 团队可以在应用数据库更新之前包含一个预部署脚本，以**自动**备份数据库。如果备份成功，您可以继续部署您的更改到数据库中。如果不成功，您可以立即停止部署并确定失败的原因。
- en: As discussed in the previous section, this is necessary for a “fallback” approach
    instead of a “fall forward” strategy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，这是为了采用“回退”方法而不是“向前跌倒”策略。
- en: Creating a Strategy for Table Structures
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定表结构策略
- en: 'One strategy for updating a table is to take a non-destructive approach:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 更新表的一种策略是采取一种非破坏性的方法：
- en: '**Adding a column**: When adding columns, place a default value on the column
    for when a record is created. This will prevent the application from erroring
    out when you add a record, notifying the user that a field didn’t have a value
    or is required.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加列**：在添加列时，为创建记录时该列放置一个默认值。这将防止在添加记录时应用程序出错，通知用户该字段没有值或为必填项。'
- en: '**Updating/renaming a column**: Updating a column is a little different because
    you may be changing a data type or value in the database. If you’re changing the
    column name and/or type to something else, add a new column with the new column
    type, make sure you default the value, and proceed to use it in your application
    code. Once the code is solid and is performing as expected, remove the old column
    from the table and then from your code.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新/重命名列**：更新列略有不同，因为您可能正在更改数据库中的数据类型或值。如果您正在将列名和/或类型更改为其他内容，请添加一个具有新列类型的新列，确保设置默认值，然后继续在应用程序代码中使用它。一旦代码稳定并且按预期运行，从表中删除旧列，然后从代码中删除。'
- en: '**Removing a column**: There are several different ways to handle this process.
    If the field was created with a default value, make the appropriate changes in
    your application code to stop using the column. When records are added to the
    table, the default value won’t create an error. Once the application code has
    been updated, *rename* the column in the table instead of deleting it. If your
    code is still using it, you’ll be able to identify the code issue and fix it.
    Once your code is running without error, it’ll be safe to remove the column from
    your table.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除列**：处理此过程有几种不同的方法。如果字段是用默认值创建的，请在你的应用程序代码中做出相应的更改以停止使用该列。当记录添加到表中时，默认值不会创建错误。一旦应用程序代码已更新，*重命名*表中的列而不是删除它。如果你的代码仍在使用它，你将能够识别代码问题并修复它。一旦你的代码运行无误，就可以安全地从表中删除该列。'
- en: While making the appropriate changes to table structures, don’t forget about
    updating the additional database code to reflect the table changes, including
    stored procedures, views, and functions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在对表结构进行适当的更改时，不要忘记更新额外的数据库代码以反映表更改，包括存储过程、视图和函数。
- en: Creating a Database Project
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库项目
- en: If your Visual Studio solution connects to a database, there’s another project
    type you need to add to your solution called the Database Project type. When you
    add this project to your solution, it takes a snapshot of your database and adds
    it to your project as code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Visual Studio解决方案连接到数据库，你需要将另一种项目类型添加到你的解决方案中，称为数据库项目类型。当你将此项目添加到解决方案中时，它会对你的数据库进行快照，并将其作为代码添加到项目中。
- en: 'Why include this in your solution? There are three reasons to include it in
    your solution:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在你的解决方案中包含它？包含它的有三个原因：
- en: It provides a database schema as T-SQL when you create a database from scratch.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你从头创建数据库时，它提供了一个数据库模式作为T-SQL。
- en: It allows you to version your database, in keeping with the **Infrastructure
    as Code** (**IaC**) paradigm.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许你根据**基础设施即代码**（**IaC**）范式对数据库进行版本控制。
- en: When you’re building your solution in Visual Studio, it automatically generates
    a DAC file from your Database Project for deployment with the option to attach
    a custom script. With the DAC included in your solution, the pipeline can deploy
    and update the database with the DAC file first. Once the database deployment
    (and backup) is finished, the pipeline can deploy the artifact.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在Visual Studio中构建解决方案时，它会自动从数据库项目生成DAC文件，以便与自定义脚本一起部署。将DAC包含在解决方案中，管道可以首先使用DAC文件部署和更新数据库。一旦数据库部署（和备份）完成，管道可以部署工件。
- en: As you can see, it’s pretty handy to include with your solution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将其包含在解决方案中非常方便。
- en: Using Entity Framework Core’s Migrations
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Entity Framework Core的迁移
- en: Entity Framework has come a long way since its early days. Migrations are another
    way to include database changes through C# as opposed to T-SQL.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework自从早期以来已经取得了长足的进步。迁移是另一种通过C#而不是T-SQL来包含数据库更改的方法。
- en: Upon creating a migration, Entity Framework Core takes a snapshot of the database
    and `DbContext` and creates the delta between the database schema and `DbContext`
    using C#.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建迁移时，Entity Framework Core会对数据库和`DbContext`进行快照，并使用C#创建数据库模式和`DbContext`之间的差异。
- en: With the initial migration, the entire C# code is generated with an `Up()` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始迁移中，整个C#代码都通过`Up()`方法生成。
- en: Any subsequent migrations will contain an `Up()` method and a `Down()` method
    for upgrading and downgrading the database, respectively. This allows developers
    to save their database delta changes, along with their code changes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续的迁移都将包含一个`Up()`方法和一个`Down()`方法，分别用于升级和降级数据库。这允许开发者保存他们的数据库增量更改，以及他们的代码更改。
- en: Entity Framework Core’s migrations are an alternative to using DACs and custom
    scripts. These migrations can perform database changes based on the C# code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core的迁移是使用DAC和自定义脚本的替代方案。这些迁移可以根据C#代码执行数据库更改。
- en: If you require seed records, then you can use Entity Framework Core’s `.HasData()`
    method for easily creating seed records for tables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要种子记录，则可以使用Entity Framework Core的`.HasData()`方法轻松为表创建种子记录。
- en: In this section, we learned how to prepare our database deployment by always
    creating a backup, looked at a common strategy for adding, updating, and deleting
    table fields, and learned how to deploy databases in a CI/CD pipeline using either
    a DAC or Entity Framework Core’s migrations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过始终创建备份来准备我们的数据库部署，查看添加、更新和删除表字段的一种常见策略，并学习了如何使用DAC或Entity Framework
    Core的迁移在CI/CD管道中部署数据库。
- en: The three Types of Build Providers
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三种构建提供商类型
- en: Now that we’ve learned how a standard pipeline works, in this section, we’ll
    look at the different types of pipeline providers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了标准管道的工作原理，在本节中，我们将探讨不同类型的管道提供商。
- en: The three types of providers are on-premises, off-premises, and hybrid.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 三种提供商类型是本地、离场和混合。
- en: '**On-premises** (meaning on-site or on-premises) relates to the software you
    own, which you can use to build your product at your company’s location. An advantage
    of on-premises build services is that once you purchase the software, you own
    it; there isn’t a subscription fee. So, if there’s a problem with the build server,
    you can easily look at the software locally to identify and fix the problem.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地**（意味着现场或本地）与您拥有的软件相关，您可以在公司的地点使用它来构建您的产品。本地构建服务的优势是，一旦您购买了软件，就拥有它；没有订阅费。因此，如果构建服务器出现问题，您可以轻松地在本地上查看软件以识别和解决问题。'
- en: '**Off-premises** (or cloud) providers are the more common services used nowadays.
    Since everyone wants everything yesterday, it’s quicker to set up and is usually
    an immediate way to create a software pipeline.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**离场**（或云）提供商是现在更常见的服务。由于每个人都希望立即得到一切，因此设置起来更快，通常也是创建软件管道的即时方式。'
- en: As you can guess, **hybrid services** are a mix of on-premises and off-premises
    services. Some companies like to keep control of certain aspects of software development
    and send the artifacts to a remote server for deployment purposes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，**混合服务**是本地和离场服务的混合。一些公司喜欢控制软件开发的一些方面，并将工件发送到远程服务器进行部署。
- en: While hybrid services are an option, it makes more sense to use off-premises
    services for automated software builds.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然混合服务是一个选项，但使用离场服务进行自动化的软件构建更有意义。
- en: 'In this section, we learned about three types of providers: on-premises, off-premises,
    and hybrid services. While these services are used in various companies, the majority
    of companies lean toward off-premises (or cloud) services to automate their software
    builds.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了三种提供商类型：本地、离场和混合服务。虽然这些服务在各种公司中使用，但大多数公司倾向于使用离场（或云）服务来自动化他们的软件构建。
- en: CI/CD Providers
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD提供商
- en: In this section, we’ll review a current list of providers on the internet to
    help you automate your builds. While there are other providers available, these
    are considered what developers use in the industry as a standard.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾互联网上的一些当前提供商列表，以帮助您自动化构建。虽然还有其他提供商可用，但这些被认为是行业中开发者使用的标准。
- en: Since we are targeting ASP.NET Core, rest assured, each of these providers supports
    ASP.NET Core in its build processes and deployments.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们针对ASP.NET Core，请放心，这些提供商在其构建过程和部署中都支持ASP.NET Core。
- en: Microsoft Azure Pipelines
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微软Azure管道
- en: Since Microsoft created ASP.NET Core, it only makes sense to mention its off-premises
    cloud offerings. It does offer on-premises and hybrid support as well. Azure Pipelines
    provides the most automated support for ASP.NET Core applications and deployment
    mechanisms to date.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微软创建了ASP.NET Core，因此提及其离场云服务是合理的。它也提供本地和混合支持。Azure管道为ASP.NET Core应用程序和部署机制提供了迄今为止最自动化的支持。
- en: While Azure is considered one of the biggest cloud providers in the world, I
    consider Azure Pipelines a small component under the Azure moniker.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Azure被认为是世界上最大的云服务提供商之一，但我认为Azure管道是Azure品牌下的一个较小组件。
- en: Important note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can learn more about Azure Pipelines here: [https://azure.microsoft.com/en-us/products/devops/pipelines/](https://azure.microsoft.com/en-us/products/devops/pipelines/).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于Azure管道的信息：[https://azure.microsoft.com/en-us/products/devops/pipelines/](https://azure.microsoft.com/en-us/products/devops/pipelines/)。
- en: GitHub Actions
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: When Microsoft purchased GitHub back in June of 2018, GitHub came out with an
    automation pipeline with GitHub Actions in October of the same year.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软在2018年6月收购GitHub后，GitHub在同年的10月推出了带有GitHub Actions的自动化管道。
- en: Since GitHub is a provider of all things source code-related, GitHub Actions
    was considered an inevitable step toward making code deployable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GitHub是所有与源代码相关事物的提供者，GitHub Actions被认为是将代码部署为可部署的必然步骤。
- en: After signing up to Actions, you’ll notice the screens are very “Azure-ish”
    and provide a very similar interface when you’re building software pipelines.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册Actions之后，您会注意到屏幕非常“Azure风格”，在构建软件管道时提供非常相似的界面。
- en: Important note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can learn more about GitHub Actions here: [https://github.com/features/actions](https://github.com/features/actions).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于GitHub Actions的信息：[https://github.com/features/actions](https://github.com/features/actions)。
- en: Amazon CodePipeline
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Amazon CodePipeline
- en: With Amazon commanding a large lead in the e-commerce landscape and with its
    Amazon Web Services (AWS offering), it also provides automated pipelines for developers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Amazon在电子商务领域的领先地位以及其Amazon Web Services (AWS)提供的服务，它还为开发者提供了自动化的管道。
- en: 'Its pipelines are broken down into categories:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它的管道被分为几个类别：
- en: '`CodeCommit`: For identifying source code repositories'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CodeCommit`：用于识别源代码存储库'
- en: '`CodeArtifact`: A centralized location for build artifacts'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CodeArtifact`：构建工件的中心位置'
- en: '`CodeBuild`: A dedicated service for building your product based on updates
    in your repository, which are defined in `CodeCommit`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CodeBuild`：一个基于存储库更新的产品构建服务，这些更新在`CodeCommit`中定义。'
- en: '`CodeDeploy`: For managing environments for deploying software'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CodeDeploy`：用于管理软件部署的环境'
- en: '`CodePipelne`: The glue that holds it all together'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CodePipeline`：将所有内容粘合在一起'
- en: You can pick and choose the services you need based on your requirements. Amazon
    CodePipeline is similar to most cloud services, where you can use one service
    or all of them.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需求选择所需的服务。Amazon CodePipeline与大多数云服务类似，您可以使用一个服务或所有服务。
- en: Important note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can learn more about Amazon CodePipeline here: [https://aws.amazon.com/codepipeline/](https://aws.amazon.com/codepipeline/).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于Amazon CodePipeline的信息：[https://aws.amazon.com/codepipeline/](https://aws.amazon.com/codepipeline/)。
- en: Google CI
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google CI
- en: The final cloud provider is none other than Google CI. Google CI also provides
    the tools required to perform automated builds and deployments.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个云提供商非Google CI莫属。Google CI也提供了执行自动化构建和部署所需的工具。
- en: Google CI provides similar tools, such as Artifact Registry, source repositories,
    Cloud Build, and even private container registries.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Google CI提供类似工具，如工件注册库、源存储库、Cloud Build以及甚至私有容器注册库。
- en: As mentioned previously, once you understand how one cloud provider works, you’ll
    start to see similar offerings in other cloud providers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦您了解了一个云提供商的工作方式，您就会开始在其他云提供商中看到类似的提供。
- en: Important note
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can learn more about Google CI here: [https://cloud.google.com/solutions/continuous-integration](https://cloud.google.com/solutions/continuous-integration).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于Google CI的信息：[https://cloud.google.com/solutions/continuous-integration](https://cloud.google.com/solutions/continuous-integration)。
- en: 'In this section, we examined four CI/CD cloud providers: Microsoft’s Azure
    Pipelines, GitHub Actions, Amazon’s CodePipeline, and Google’s CI. Any one of
    these providers is a suitable candidate for creating an ASP.NET Core pipeline.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了四个CI/CD云提供商：Microsoft的Azure Pipelines、GitHub Actions、Amazon的CodePipeline和Google的CI。这些提供商中的任何一个都适合创建ASP.NET
    Core管道。
- en: Walkthrough of Azure Pipelines
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure管道的概述
- en: 'With everything we’ve discussed so far, this section will take us through a
    standard pipeline with a web application every developer should be familiar with:
    the ASP.NET Core web application.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论了所有这些之后，本节将带我们了解每个开发者都应该熟悉的：ASP.NET Core Web应用程序的标准管道。
- en: If you have a web application of your own, you’ll be able to follow along and
    make the modifications to your web application as well.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有自己的Web应用程序，您将能够跟随并修改您的Web应用程序。
- en: In this section, we’ll demonstrate what a pipeline consists of by considering
    a sample application and walking through all of the components that will make
    it a successful build.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过考虑一个示例应用程序并遍历所有将使其成为成功构建的组件来展示管道由什么组成。
- en: Preparing the Application
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备应用程序
- en: 'Before we move forward, we need to confirm whether the application in our version
    control is ready for a pipeline:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我们需要确认我们版本控制中的应用程序是否已准备好进行管道：
- en: Does the application compile and clone without errors?
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否编译和克隆时没有错误？
- en: Do *all* the unit tests that accompany the application pass?
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伴随应用程序的所有单元测试都通过了吗？
- en: Do you have the correct environment settings in your application? (For example,
    `appsettings.json`, `appsettings.qa.json`, and so on.)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序中是否有正确的环境设置？（例如，`appsettings.json`、`appsettings.qa.json` 等。）
- en: Will you deploy this application to a Docker container? If so, confirm you have
    a Dockerfile in the root of your application.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是否要将此应用程序部署到 Docker 容器中？如果是这样，请确认您在应用程序的根目录中有一个 Dockerfile。
- en: Again, the Dockerfile is optional, but most companies include one since they
    have numerous environments running on different operating systems. We’ll include
    the Dockerfile in our web application to complete the walkthrough.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Dockerfile 是可选的，但大多数公司都包含一个，因为它们在多种操作系统上运行着多个环境。我们将把 Dockerfile 包含在我们的
    Web 应用程序中，以完成此演练。
- en: Once everything has been confirmed in our checklist, we can move forward and
    create our pipeline.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在我们的清单中确认了一切，我们就可以继续前进并创建我们的管道。
- en: Introducing Azure Pipelines
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Azure Pipelines
- en: Azure Pipelines is a free service for developers to use to automate, test, and
    deploy their software to any platform.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Pipelines 是一个免费服务，供开发者使用来自动化、测试和将他们的软件部署到任何平台。
- en: 'Since Azure is user-specific, you’ll have to log in to your Azure Pipelines
    account or create a new one at [https://azure.microsoft.com/en-us/products/devops/pipelines/](https://azure.microsoft.com/en-us/products/devops/pipelines/).
    Don’t worry – it’s free to sign up and create pipelines:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Azure 是针对特定用户的，您必须登录到您的 Azure Pipelines 账户或在新 [https://azure.microsoft.com/en-us/products/devops/pipelines/](https://azure.microsoft.com/en-us/products/devops/pipelines/)
    上创建一个新账户。别担心——注册和创建管道是免费的：
- en: 'To continue with this walkthrough, click on the **Start free with GitHub**
    button, as shown in *Figure 2**.2*:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要继续此演练，请点击如图 *图 2.2* 所示的 **免费使用 GitHub 开始** 按钮：
- en: '![Figure 2.2 – The Azure Pipelines web page](img/Figure_2.02_B19493.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Azure Pipelines 网页](img/Figure_2.02_B19493.jpg)'
- en: Figure 2.2 – The Azure Pipelines web page
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Azure Pipelines 网页
- en: Once you’ve logged in to Azure Pipelines, you are ready to create a project.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录到 Azure Pipelines，您就可以创建一个项目了。
- en: Click **New Project** in the top right-hand corner. Enter details for **Project
    Name** and **Description** and determine whether it’s **Private** or **Public**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角点击 **新建项目**。输入 **项目名称** 和 **描述** 的详细信息，并确定它是 **私有** 还是 **公共**。
- en: Upon clicking **Create**, we need to define which repository to use in our pipeline.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 后，我们需要定义在管道中使用哪个存储库。
- en: Identifying the Repository
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别存储库
- en: 'We haven’t designated a repository for Azure Pipelines to use yet. So, we need
    to import an existing repository:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有为 Azure Pipelines 指定一个存储库来使用。因此，我们需要导入一个现有的存储库：
- en: If you click on any option under **Files**, you’ll notice a message saying **<YourProjectNameHere>
    is empty. Add some code!**. Sounds like solid advice.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击 **文件** 下的任何选项，您会注意到一条消息说 **<在此处输入您的项目名称> 是空的。添加一些代码！**。听起来像是一条很好的建议。
- en: 'Click on the **Import** button under the **Import a repository** section, as
    shown in *Figure 2**.3*:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **导入存储库** 部分下的 **导入** 按钮，如图 *图 2.3* 所示：
- en: '![Figure 2.3 – Importing a repository](img/Figure_2.03_B19493.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 导入存储库](img/Figure_2.03_B19493.jpg)'
- en: Figure 2.3 – Importing a repository
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 导入存储库
- en: Clicking on the **Import** button will result in a side panel popping out, asking
    where your source code is located. Currently, there is only Git and **Team Foundation
    Version** **Control** (**TFVC**).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **导入** 按钮将弹出一个侧面板，询问您的源代码位于何处。目前，只有 Git 和 **团队基础版本控制**（**TFVC**）。
- en: 'Since the code for `DefaultWebApp` is in Git, I copied the clone URL and pasted
    it into the text box, and then clicked the **Import** button at the bottom of
    the side panel, as shown in *Figure 2**.4*:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `DefaultWebApp` 的代码在 Git 中，我复制了克隆 URL 并将其粘贴到文本框中，然后点击侧面板底部的 **导入** 按钮，如图
    *图 2.4* 所示：
- en: '![Figure 2.4 – Identifying the repository Azure Pipelines will use](img/Figure_2.04_B19493.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 识别 Azure Pipelines 将使用的存储库](img/Figure_2.04_B19493.jpg)'
- en: Figure 2.4 – Identifying the repository Azure Pipelines will use
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 识别 Azure Pipelines 将使用的存储库
- en: Azure Pipelines will proceed to import the repository. The next screen will
    be the standard **Explorer** view everyone is used to seeing, with a tree view
    on the left of your repository and a detailed list of files from the current directory
    on the right-hand side.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Pipelines 将继续导入存储库。下一个屏幕将是大家熟悉的标准 **资源管理器** 视图，您的存储库左侧有树状视图，右侧是当前目录的详细文件列表。
- en: With that, we have finished importing the repository into Azure Pipelines.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就已经将存储库导入到 Azure Pipelines 中了。
- en: Creating the Build
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建
- en: 'Now that we’ve imported our repository, Azure Pipelines makes this process
    extremely easy for us by adding a button called **Set up build**, as shown in
    *Figure 2**.5*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了我们的存储库，Azure Pipelines 通过添加一个名为**设置构建**的按钮，使这个过程对我们来说变得极其简单，如图 *2.5*
    所示：
- en: '![Figure 2.5 – Imported repository with a “Set up build” button as the next
    step](img/Figure_2.05_B19493.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 导入的存储库，下一步是“设置构建”按钮](img/Figure_2.05_B19493.jpg)'
- en: Figure 2.5 – Imported repository with a “Set up build” button as the next step
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 导入的存储库，下一步是“设置构建”按钮
- en: 'As vast as Azure Pipelines’ features can be, there are several preset templates
    to use for your builds. Each template pertains to a particular project in the
    .NET ecosystem, along with not-so-common projects as well:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Azure Pipelines的功能可能非常丰富，但仍有几个预设模板可用于构建。每个模板都针对.NET生态系统中的特定项目，以及一些不太常见的项目：
- en: For our purposes, we’ll select the **ASP.NET Core (.NET** **Framework)** option.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将选择**ASP.NET Core (.NET 框架**)选项。
- en: After the **Configure** step in our wizard (see the top?), we will come to the
    **Review** step, where we can examine the YAML file.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的向导中的**配置**步骤之后（见顶部？），我们将进入**审查**步骤，在那里我们可以检查 YAML 文件。
- en: With that said, you aren’t excluded from adding tasks at any time. There is
    **Show Assistant** to help you with adding new tasks to your existing YAML file.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 话虽如此，你任何时候都可以添加任务。有**显示助手**可以帮助你将新任务添加到现有的 YAML 文件中。
- en: 'For the DefaultWebApp example, we don’t need to update our YAML file because
    we don’t have any changes; this is because we want something very simple to create
    our build. The default YAML file looks like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DefaultWebApp 示例，我们不需要更新我们的 YAML 文件，因为我们没有进行任何更改；这是因为我们想要创建一个非常简单的构建。默认的
    YAML 文件看起来像这样：
- en: '[PRE2]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This new file that Azure Pipelines created is called `azure-pipelines.yml`.
    So, where does this new `azure-pipelines.yml` file reside when it’s created? It’s
    committed to the root of your repository. Once we’ve confirmed everything looks
    good in the YAML file, we can click the **Save and** **run** button.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Pipelines创建的新文件被称为`azure-pipelines.yml`。那么，当它创建时，这个新的`azure-pipelines.yml`文件在哪里？它被提交到存储库的根目录。一旦我们确认
    YAML 文件中的所有内容看起来都很好，我们就可以点击**保存并运行**按钮。
- en: Once you’ve done this, a side panel will appear, asking you for a commit message
    and optional description, as well as to specify options on whether to commit directly
    to the master branch or create a new branch for this commit. Once you’ve clicked
    the **Save and run** button at the bottom of the side panel, it will commit your
    new YAML file to your repository and execute the pipeline immediately.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，将出现一个侧面板，要求你输入提交消息和可选的描述，以及指定是否直接提交到主分支或为这次提交创建新分支的选项。一旦你在侧面板底部点击**保存并运行**按钮，它将立即将新的
    YAML 文件提交到你的存储库并执行管道。
- en: Creating the Artifacts
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工件
- en: 'Once the build is running, you’ll see something similar to *Figure 2**.6*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建开始运行，你会看到类似于 *图 2.6* 的内容：
- en: '![Figure 2.6 – Queueing up our DefaultWebApp build process](img/Figure_2.06_B19493.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 排队我们的 DefaultWebApp 构建过程](img/Figure_2.06_B19493.jpg)'
- en: Figure 2.6 – Queueing up our DefaultWebApp build process
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 排队我们的 DefaultWebApp 构建过程
- en: As shown at the bottom of the preceding screenshot, my job’s status is **Queued**.
    Once it’s out of the queue and executing, you can watch the builds progress by
    clicking on **Job** next to the blue clock at the bottom.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图底部所示，我的作业状态是**排队**。一旦它离开队列并开始执行，你可以通过点击底部蓝色时钟旁边的**作业**来监视构建进度。
- en: 'In terms of **DefaultWebApp**, this is what the build process looks as seen
    in *Figure 2**.7*:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **DefaultWebApp** 方面，构建过程看起来就像 *图 2.7* 中所示：
- en: '![Figure 2.7 – The build progress of DefaultWebApp](img/Figure_2.07_B19493.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – DefaultWebApp 的构建进度](img/Figure_2.07_B19493.jpg)'
- en: Figure 2.7 – The build progress of DefaultWebApp
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – DefaultWebApp 的构建进度
- en: Congratulations! You have created a successful pipeline and artifact.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功创建了一个管道和工件。
- en: For the sake of not writing an entire book on Azure Pipelines, next, we will
    move on to creating releases.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不写一本关于 Azure Pipelines 的整本书，接下来，我们将继续创建发布。
- en: Creating a Release
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建发布
- en: 'With a completed and successful build, we can now focus on releasing our software.
    Follow these steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 完成并成功构建后，我们现在可以专注于发布我们的软件。请按照以下步骤操作：
- en: If you click on **Releases**, you’ll see we need to create a new release pipeline.
    Click the **New** **Pipeline** button.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击**发布**，你会看到我们需要创建一个新的发布管道。点击**新建** **管道**按钮。
- en: 'Immediately, you’ll see a side panel appear with a list of templates you can
    choose from. Select **Empty job** at the top of the side panel, as shown in *Figure
    2**.8*:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即，您将看到一个侧边面板出现，其中列出了您可以从中选择的模板。在侧边面板的顶部选择**空作业**，如图*图 2.8*所示：
- en: '![Figure 2.8 – Selecting an empty job template](img/Figure_2.08_B19493.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 选择空作业模板](img/Figure_2.08_B19493.jpg)'
- en: Figure 2.8 – Selecting an empty job template
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 选择空作业模板
- en: There is a term in **Releases** called **Stages** where your software can go
    through several stages before it’s sent to the final stage. These stages can also
    be synonymous with environments. These stages include development, QA, staging,
    and production. Once one stage has been approved (development), it moves to the
    next stage (QA) until the final one, which is usually production. However, these
    stages can get extremely complicated.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在**发布**中有一个术语称为**阶段**，您的软件可以在发送到最终阶段之前经过几个阶段。这些阶段也可以与环境同义。这些阶段包括开发、质量保证、预发布和生产。一旦一个阶段获得批准（开发），它将移动到下一个阶段（质量保证），直到最终的阶段，通常是生产。然而，这些阶段可能会变得极其复杂。
- en: After you click the **Apply** button, you will see another side panel where
    you can define your stage. Since we are simply deploying the website, we’ll call
    this the **Push to** **Site** stage.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**按钮后，您将看到一个侧边面板，您可以在其中定义您的阶段。由于我们只是部署网站，我们将称之为**推送到网站**阶段。
- en: After entering your **Stage** name (that just doesn’t sound right), click the
    **X** button to close the side panel and examine the pipeline.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的**阶段**名称（听起来并不正确）后，点击**X**按钮关闭侧边面板并检查管道。
- en: 'As shown in *Figure 2**.9*, we need to add an artifact:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 2.9*所示，我们需要添加一个工件：
- en: "![Figure 2.9 – The Push \uFEFFto Site stage is defined, but there’s no artifact](img/Figure_2.09_B19493.jpg)"
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 推送到网站阶段已定义，但没有工件](img/Figure_2.09_B19493.jpg)'
- en: Figure 2.9 – The Push to Site stage is defined, but there’s no artifact
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 推送到网站阶段已定义，但没有工件
- en: 'When you click **Add an Artifact**, another side panel will slide open and
    ask you to add the artifact. Since we created an artifact in the previous subsection,
    we can populate all of our inputs with the **DefaultWebApp** project and source,
    as shown in *Figure 2**.10*:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击**添加工件**时，另一个侧边面板将滑出并要求您添加工件。由于我们在前面的子节中创建了一个工件，我们可以使用**DefaultWebApp**项目和源填充所有输入，如图*图
    2.10*所示：
- en: '![Figure 2.10 – Adding the DefaultWebApp artifact to our release pipeline](img/Figure_2.10_B19493.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 将 DefaultWebApp 工件添加到我们的发布管道中](img/Figure_2.10_B19493.jpg)'
- en: Figure 2.10 – Adding the DefaultWebApp artifact to our release pipeline
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 将 DefaultWebApp 工件添加到我们的发布管道中
- en: Click **Add** to add your artifact to the pipeline.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**将您的工件添加到管道中。
- en: Deploying the Build
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署构建
- en: Once we have defined our stages, we can attach certain deployment conditions,
    both before and after, to each stage. The ability to define post-deployment approvals,
    gates, and auto-redeploy triggers is possible but disabled by default for each
    stage.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的阶段，我们可以在每个阶段之前和之后附加某些部署条件。定义部署后批准、门控和自动重新部署触发器的功能是可能的，但默认情况下对每个阶段都是禁用的。
- en: 'In any stage, you can add, edit, or remove any task you want by clicking on
    the “x job, x tasks” link under each stage’s name, as shown in *Figure 2**.11*:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何阶段，您都可以通过点击每个阶段名称下的“x 作业，x 任务”链接来添加、编辑或删除任何您想要的任务，如图*图 2.11*所示：
- en: '![Figure 2.11 – Stages allow you to add any number of tasks](img/Figure_2.11_B19493.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 阶段允许您添加任意数量的任务](img/Figure_2.11_B19493.jpg)'
- en: Figure 2.11 – Stages allow you to add any number of tasks
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 阶段允许您添加任意数量的任务
- en: Each stage has an agent job, which can perform any number of tasks. The list
    of tasks to choose from is mind-numbing. If you can think of it, there is a task
    for it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都有一个代理作业，可以执行任何数量的任务。可供选择的任务列表令人眼花缭乱。如果您能想到的，就有相应的任务。
- en: For example, we can deploy a website using Azure, IIS Web Deploy, or even simply
    a file that’s been copied from one directory to another. Want to FTP the files
    over to a server? Click on the **Utility** tab and find **FTP Upload**.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 Azure、IIS Web Deploy 或甚至简单地复制一个目录到另一个目录的文件来部署网站。想要通过 FTP 将文件传输到服务器？点击**实用工具**选项卡并找到**FTP
    上传**。
- en: Each task you add has parameters per topic and can easily be modified to suit
    a developer’s requirements.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您添加的每个任务都有每个主题的参数，并且可以轻松修改以满足开发者的需求。
- en: In this section, we covered how to create a pipeline by preparing the application
    to meet certain requirements. We did this by introducing Azure Pipelines by logging
    in and adding our sample project, identifying the repository we’ll be using in
    our pipeline, and creating the build. Once we’d done this, we found our artifacts,
    created a release, and found a way to deploy the build.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何通过准备应用程序以满足某些要求来创建管道。我们通过登录并添加我们的示例项目、确定我们将在管道中使用的存储库，并创建构建来实现这一点。一旦完成这些，我们就找到了我们的工件，创建了发布，并找到了部署构建的方法。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we identified ways to prepare our code for a CI/CD pipeline
    so that we can build flawlessly, avoid relative path names with file-based operations,
    confirm our unit tests *are* unit tests, and create environment settings for our
    application. Once our code was ready, we examined what’s included in a common
    CI/CD pipeline, including a way to pull the code, build it, run unit tests with
    optional code analysis, create artifacts, wrap our code in a container, and deploy
    an artifact.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们确定了为我们的代码准备CI/CD管道的方法，以便我们可以完美构建，避免在基于文件的操作中使用相对路径名称，确认我们的单元测试*确实是*单元测试，并为我们的应用程序创建环境设置。一旦我们的代码准备就绪，我们就检查了常见CI/CD管道中包含的内容，包括拉取代码、构建它、运行可选的代码分析单元测试、创建工件、将我们的代码封装在容器中，以及部署工件。
- en: We also covered two ways to recover from a failed deployment using a fall-back
    or fall-forward approach. Then, we discussed common ways to prepare for deploying
    a database, which includes backing up your data, creating a strategy for modifying
    tables, adding a database project to your Visual Studio solution, and using Entity
    Framework Core’s migrations so that you can use C# to modify your tables.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了两种使用回退或前向方法从失败的部署中恢复的方法。然后，我们讨论了为部署数据库做准备的一些常见方式，这包括备份您的数据、制定修改表的战略、将数据库项目添加到您的Visual
    Studio解决方案中，以及使用Entity Framework Core的迁移，以便您可以使用C#修改您的表。
- en: 'We also reviewed the three types of CI/CD providers: on-premises, off-premises,
    and hybrid providers, with each one specific to a company’s needs, and then examined
    four cloud providers who offer full pipeline services: Microsoft’s DevOps Pipelines,
    GitHub Actions, Amazon’s CodePipeline, and Google’s CI.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还回顾了三种CI/CD提供者类型：本地、远程和混合提供者，每种提供者都针对公司的特定需求，然后检查了提供完整管道服务的四个云提供者：微软的DevOps管道、GitHub
    Actions、亚马逊的CodePipeline和谷歌的CI。
- en: Finally, we learned how to create a sample pipeline by preparing the application
    so that it meets certain requirements, logging in to Azure Pipelines and defining
    our sample project, identifying the repository we’ll be using in our pipeline,
    and creating the build. Once the build was complete, it generated our artifacts,
    and we learned how to create a release and find a way to deploy the build.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何通过准备应用程序以满足某些要求来创建一个示例管道，登录到Azure Pipelines并定义我们的示例项目，确定我们将在管道中使用的存储库，并创建构建。一旦构建完成，它就生成了我们的工件，我们学习了如何创建发布并找到部署构建的方法。
- en: In the next chapter, we’ll learn about some of the best approaches for using
    middleware in ASP.NET Core.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解一些在ASP.NET Core中使用中间件的最佳方法。
