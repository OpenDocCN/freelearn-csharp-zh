- en: Chapter 4.  Basic Pattern Matching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter continues the study of functional programming foundations that
    the previous chapter opened. It covers basic data pattern matching. Pattern matching
    is an essential feature-rich mechanism of powerful data processing that is embedded
    into the F# language's core.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: A good grasp of the F# pattern matching features is an absolute must for an
    enterprise developer because most of the time, enterprise business is revolving
    around sophisticated data transformations in **Line Of Business** ( **LOB** )
    **applications** ([https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/](https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/)
    ) and along ****E** xtract Transform Load** ( **ETL** ) ([https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load)
    ) cycles in data warehousing and business analytics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: I intentionally narrowed down the subject of this chapter to basic pattern matching
    for a merely didactic reason. Usually, F# beginners first grasp pattern matching
    as an imperative switch on steroids or just a semantically equivalent way of coding
    lengthy `if...then...elif...elif... ...else...` expressions. Then, they begin
    to recognize the role of pattern matching in data structures decomposition. And
    finally, the pattern matching knowledge acquisition gets completed with embracing
    **active patterns** .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to provide you with a thorough grasp of the pattern
    matching features associated with the F# `match` construction:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The overall composition of this rather complicated language construction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tacit assumptions behind the parts of match (the ordering of matching rules
    and completeness of pattern cases, to name a few)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific kinds of pattern cases and how to build composite cases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decomposition abilities consideration is postponed until the coverage of
    the data structures in the upcoming chapters. Similarly, I will cope with **active
    patterns** when covering the advanced programming techniques of F#.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: An explicit form of pattern matching with match construction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Explicit `match` construction in F# belongs to control flow elements, along
    with `if-then-else` , or `while-do` . Of other F# bits and pieces, a `match` is
    a relatively complicated combination of the following parts and governing rules:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It works in this manner, that is, `comparison-expression` is juxtaposed with
    each `pattern-expression` beginning with `pattern-expression1` and goes down the
    list until either the first match occurs, or passing `pattern-expressionN` still
    non-matched. If a match is found for `pattern-expressionX` , then the result of
    the entire construction is the result of `result-expressionX` . If no matches
    are found, then `MatchFailureException` is thrown, indicating that the match cases
    were incomplete.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points of pattern matching that are often missing by F# beginners on
    the first read are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The `match` construction represents an expression, like any other F# construction
    excluding value binding. This means that the value of one and only one of `result-expressions`
    will be taken for the value of the entire construction (given that a certain matching
    has indeed taken place).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every `pattern-expression1` through `pattern-expressionN` must share the same
    type, which is also the same with the type of `comparison-expression` in order
    for the `match` construction to compile.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every `result-expression1` through `result-expressionN` must share the same
    type in order for the match construction to compile.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listed pattern to result cases are tried at run-time one after another in the
    top-down order. This arrangement prescribes a certain ordering of the cases from
    the standpoint of pattern commonality. More specific patterns must precede less
    specific ones; otherwise, more specific patterns will not have chances to be matched
    ever.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of alternatives represented by all patterns must be exhaustive; otherwise,
    matching `comparison-expression` not covered by any of the patterns will cause
    `MatchFailureException` .
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More atomic pattern terms can be composed into broader pattern expressions using
    Boolean logic operators OR (`|` ), AND (`&` ), and a special `when` guard.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, I will walk you through the multiplicity of pattern kinds so that you get
    used to their broad repertoire and become comfortable with getting around `match`
    expressions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Matching literals
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the simplest cases of matching patterns is a pattern represented by a
    literal and assuming a simple `comparison-expression` value equality. Literals
    can be of any numeric, character, or string types. They can also be cases of a
    .NET enumeration (each such case is inherently a symbolic name alias of the integer
    value) or a value decorated with the `[<Literal>]` attribute.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following script, I can easily match `int` literals and the `int` value
    aliased as `THREE` , decorated with the `[<Literal>]` attribute (`Ch4_1.fsx` ):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This yields string `"3"` , as expected. However, it wouldn''t be possible to
    mix `int` literals with named `int` constant values from the following script
    (`Ch4_1.fsx` ):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This yields string `"5"` , although being literals, `Multiples.Zero` and `Multiples.Five`
    are typed as members of the `Multiples` enumeration.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: (Besides, if you did not grok this yet, placing almost any text between the
    doubled backticks, such as [PRE3] above, makes this text a valid F# name and,
    when used in moderation, may add to improved code readability).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Wildcard matching
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If I put the preceding scripts into Visual Studio, the F# source code editor
    will draw a blue warning squiggle line under the [PRE4] comparison expression,
    indicating that the set of rules in this `match` construction is not exhaustive,
    as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Wildcard matching](img/Image00018.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: An example of an incomplete pattern matching
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler even gives a sample value of [PRE5] , which is not going to match.
    Although this value is not present within the definition of type `Multiples` ,
    if I synthetically create this value as `enum<Multiples>(1)` and feed it as an
    argument into `transformB` , the result would be the run-time exception of type
    `Microsoft.FSharp.Core.MatchFailureException` . This situation should raise the
    following question: how would it be possible to put a *match all* rule into the
    `match` , which means anything that was not specified in preceding rules?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, F# offers the special **wildcard pattern ** `_` that matches
    anything that was not matched in the preceding rules. With its help and turning
    to the idiomatic F# way of processing undefined values by presenting the result
    as a value of type `option` , the function processing only legitimate `Multiples`
    values may be defined as shown in the following code (`Ch4_1.fsx` ):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, the match within the `transformB'` definition carries the exhaustive set
    of match cases. Any legitimate value of `Multiples` given as `m` will be transformed
    into a correspondent `Somestring option` value, and any non-legitimate value of
    the `m` argument will be transformed into a `None` result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Arranging matching rules
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wildcard pattern demonstrates the importance of arranging the match cases from
    more specific to less specific. For example, if I put the *match all* third rule
    with the wildcard pattern before the first two rules in the preceding script,
    then the F# compiler will put the blue squiggle line under explicit `Multiples`
    values, indicating that these rules will never be matched (check out `transformB''`
    definition in `Ch4_1.fsx` ).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Named patterns
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The F# compiler performs a certain analysis when a name (identifier) occurs
    in the position of a pattern case. Strictly speaking, there are some opportunities
    for the name to be as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: A named literal (such as THREE in the earlier script)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A case value of a discriminated union (such as `None` if matching an F# `option`
    )
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type of an exception (such as `System.ArgumentException` if matching an exception
    type)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom name of an active pattern (which will be covered in the upcoming chapters)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the name occurrence does not fit any of the previously listed alternatives,
    the name is considered a **variable pattern** ([https://msdn.microsoft.com/en-us/library/dd547125.aspx](https://msdn.microsoft.com/en-us/library/dd547125.aspx)
    ). It is treated similarly to the wildcard pattern, getting the value of `comparison-expression`
    parameter, which can be used in the corresponding `result-expression` . Sounds
    confusing, right? Then let's turn to a sample in order to make this matter clear.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'I just took the definition of the `transformA` function from the matching literals
    section, changed the name of the function to `transformA''` , and removed the
    definition of the `THREE` literal from the context (`Ch4_2.fsx` ):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The results of experimenting with this function version are shown in the following
    screenshot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Named patterns](img/Image00019.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: Turning of a literal pattern into a variable pattern
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, the omission of the literal didn't blow up the script, producing
    just a benign warning that `THREE` might be a misspelled pattern name. Applying
    the function to the argument `50` that is completely off produces the same result
    as before for the legitimate argument value `3` . What gives?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: No magic here; in accordance with the description identifier, `THREE` was not
    recognized as a named literal, discriminated union case, exception type, or active
    pattern. This finding turned it into a variable pattern playing the role of a
    match-all pattern case, which `result-expression` just blindly outputs as string
    `"3".`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In my experience as an F# developer, I faced at least one occasion when this
    seemingly innocuous pattern type transformation typo turned into a nasty bug.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The moral: handle with care, and do not disregard F# compiler warnings!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The as pattern
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interestingly, a pattern case may have the `as` clause appended to it. This
    clause binds the matched value to a name that may be used within the corresponding
    `result-expression` of the `match` construction or elsewhere within a local context
    of an outer `let` binding. The following script demonstrates how flexible the
    `as` pattern can be (`Ch4_3.fsx` ):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the first case, `r` is bound using `as` to the result of `TryParse` , which
    is the tuple, so the expression `snd r` yields the parsed GUID value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, `as` bounds `r` to any tuple; however, it must be obvious
    from the match cases sequencing that this case matches the failed GUID parsing
    and the value of argument is a garbage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot reflects firing each of these using `as` binding match
    cases in FSI:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![The as pattern](img/Image00020.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Pattern matching with as binding
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Grouping patterns
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern match cases I've covered until this point can be composed together in
    a manner that resembles the terms of a Boolean expression with OR (`|` ) and AND
    (`&` ) operators. Let me demonstrate this technique by implementing a function
    that accepts two string arguments that represent keys and validates that both
    the given values are non-empty, providing a detailed diagnostics.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be able to grasp at this point why I should begin the matching with
    the most specific case when both the keys are empty. The next less specific match
    is represented by two symmetric cases when either the first or the second key
    is empty. Here, in order to demonstrate the flexibility provided by F# patterns
    grouping, I combine these two patterns with Boolean OR and at the same time capture
    key values into the local context with a variable pattern represented by the tuple
    `(x,y)` . For the most generic leftover case, I know that both keys are not empty,
    so just a variable pattern is sufficient here. The sought function definition
    is as follows (`Ch4_4.fsx` ):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although the boolean OR pattern combinator helps reach F# code succinctness
    by combining some cases that require the same transformation expression, boolean
    AND is not used that frequently for combining the pattern cases in regular pattern
    matching practice. However, it gets very relevant when grouping *active patterns*
    , which I will be covering in later chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Guards
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, I believe you would agree that pattern matching is a powerful
    data transformation feature. Just to further amplify the facilities considered
    so far, F# offers enhancing `pattern-expressions` with additional matching logic.
    *Guard* is represented by an arbitrary boolean expression that is attached to
    `pattern-expression` using the `when` keyword. The guard kicks in only if its
    `pattern-expression` host has matched. Then, the guard expression is computed,
    and if `true` , it springs the transformation performed by the corresponding `result-expression`
    to the right. Otherwise, the entire rule is considered non matched, and the matching
    continues in an usual manner. The `when` guards can be mixed and matched within
    a `match` construction in a completely arbitrary manner.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate `when` guards in action, let me slightly modify the previous
    example. In the case where both keys are not empty, there are two subcases: when
    the keys are equal to each other and when they are not. Furthermore, our function
    would be required to format the result for each of these cases differently.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is required for this modification is just one extra line of code preceding
    the last one (remember that I want to add a more specific match case, and then
    it must go in front of a more generic one). The code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's it for this modification. I encourage you to play with both scripts `Ch4_4.fsx`
    and `Ch4_5.fsx` in FSI by entering different arguments provided in the scripts
    and observing the changing function behavior.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The alternative syntax for anonymous function performing matching
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# offers a special syntax to define anonymous functions that perform matching,
    or **pattern matching functions** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions)
    ).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: This syntax assumes that the anonymous function has a single parameter that
    is placed at the beginning of the function body in the invisible `match` construction.
    Having this alternative way of defining pattern matching anonymous functions just
    adds to the language succinctness and also better reflects the intent behind defining
    such kind of functions within the code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法假设匿名函数有一个参数，该参数放置在函数体开始的不可见 `match` 构造中。仅仅有这种定义模式匹配匿名函数的替代方式，就增加了语言的简洁性，并且更好地反映了在代码中定义此类函数的意图。
- en: 'Continuing with coding exercises, in the latest F# script I will rewrite the
    `validate` function using the alternative syntax. However, to achieve this, it
    is required that you address the following problem. The alternative syntax assumes
    that the pattern matching function has a single argument, while validate has a
    pair of arguments. The way out would be to apply skills acquired after reading
    the previous chapter and performing the currying. The following is the code (`Ch4_6.fsx`
    ):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '继续进行编码练习，在最新的 F# 脚本中，我将使用替代语法重写 `validate` 函数。然而，为了实现这一点，你需要解决以下问题。替代语法假设模式匹配函数只有一个参数，而
    `validate` 函数有一对参数。解决方案将是应用在阅读上一章并执行柯里化后获得的技能。以下是对应的代码 (`Ch4_6.fsx`):'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope that this chapter did not leave stones unturned in the matter of plain
    vanilla pattern matching. You should now be well prepared to overcome typical
    pattern matching challenges that F# beginner programmers experience. I remind
    you that further pattern matching features, namely data decomposition and active
    patterns, will be covered in later chapters in order to preserve the logical flow
    of the material.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章在纯模式匹配方面没有遗漏任何细节。你现在应该已经做好了准备，去克服 F# 初学者程序员通常会遇到的典型模式匹配挑战。我提醒你，数据分解和主动模式匹配等进一步的模式匹配特性将在后面的章节中介绍，以保持材料的逻辑流程。
- en: In the next chapter, I will turn to the exciting subject of *Algebraic Data
    Types* . We will explore how data may be composed too and what are the benefits
    behind the data composition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将转向令人兴奋的主题——*代数数据类型*。我们将探讨数据是如何组合的，以及数据组合背后的好处。
