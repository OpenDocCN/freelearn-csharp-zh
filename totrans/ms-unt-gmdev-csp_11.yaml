- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contributing to Existing Code Bases in Unity with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 7*](B22017_07.xhtml#_idTextAnchor112). This chapter will
    equip you with essential collaboration skills for working in development teams
    using C#. We will explore **version control systems** (**VCSs**), code merging,
    and conflict resolution for seamless teamwork. We will also cover mastering version
    control, collaborating with shared repositories, and resolving conflicts using
    C#. Finally, we will get an understanding of existing code bases to navigate structures,
    review documentation, and communicate effectively. Mastering all these skills
    will promote effective team contribution and maintain code quality in Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing VCSs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborating and resolving conflicts with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding existing code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to follow this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary IDE - Visual Studio 2022**: The tutorials and code samples are crafted
    using Visual Studio 2022\. Ensure it’s installed to follow along seamlessly. Feel
    free to explore Rider or other IDEs if you prefer, though instructions are tailored
    for Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Desktop**: Ensure it’s installed to follow along seamlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing VCSs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A VCS is a tool used in software development to manage changes to files. It
    acts like a detailed record keeper, documenting every alteration made to project
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s why it matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracking changes**: In a collaborative project, multiple people may work
    on the same files. A VCS records all modifications, ensuring transparency and
    accountability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facilitating collaboration**: With a VCS, team members can see who made specific
    changes and when. This transparency fosters smooth collaboration and prevents
    conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverting changes**: Mistakes happen, but a VCS allows us to revert to earlier
    versions of files if needed. It acts as a safety net, providing a way to undo
    errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintaining organization**: A VCS helps maintain orderliness by categorizing
    changes and providing a structured approach to managing project files. It enables
    teams to work efficiently and stay organized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, a VCS is a crucial tool for software development teams. It helps
    keep track of changes, encourages teamwork, allows for fixing mistakes, and ensures
    that projects stay organized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming section, we will delve into understanding VCSs, exploring the
    two main types: distributed and centralized systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding VCSs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a new repository in your VCS, you open up the main branch. This
    is also known as the trunk master. The trunk master serves as the starting point
    for the main code base, which then goes through compilation and deployment to
    reach the end user.
  prefs: []
  type: TYPE_NORMAL
- en: But what about branches? Branching occurs when code is extracted from the master
    branch to create separate paths. This allows us to modify the code without impacting
    the main version directly. By using branches, we avoid the need to consolidate
    all changes in one place; instead, we can track modifications to our code over
    time. The VCS can then integrate these separate branches back into the main one.
    If we’re not prepared to merge other changes into the main branch, we can store
    them in a separate branch and merge them later.
  prefs: []
  type: TYPE_NORMAL
- en: Having a good branching strategy is important to prevent conflicts and errors
    in the code. Luckily, robust VCSs make it easy for teams to sync with the main
    branch and resolve any potential conflicts – even after changes have been made
    to the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve grasped the fundamental workings of VCSs, let’s explore the
    two primary types that play a pivotal role in shaping collaborative development
    processes: distributed and centralized systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed VCSs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **distributed VCS**, or **DVCS**, is a type of VCS where every user has a
    complete copy of the project’s repository on their local computer. This means
    that you can work on the project even when they’re offline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the structure of a DVCS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – DVCS structure](img/B22017_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – DVCS structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local copies**: With a DVCS, each user has their own local copy of the entire
    project’s history, including all files and changes made over time. This allows
    you to work independently and make changes without relying on a central server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible collaboration**: Since each user has their own copy of the repository,
    they can work on different features or fixes without interfering with each other’s
    work. They can commit changes to their local repository and share them with others
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced security**: Because the entire project history is stored locally,
    a DVCS provides redundancy and security. Even if the central server goes down,
    you can continue working on your local copies and later sync changes with the
    central repository once it’s back online.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient branching and merging**: DVCS systems such as **Git** offer powerful
    branching and merging capabilities. You can create branches to work on new features
    or experiment with changes without affecting the main project. You can later merge
    your changes back into the main branch when ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is an example of a DVCS. It allows users to maintain their own complete
    copy of the project’s repository on their local computer. This means that you
    have access to the entire project history and can work on it even when you’re
    offline.
  prefs: []
  type: TYPE_NORMAL
- en: With Git, you can create branches to work on new features or fixes without affecting
    the main code base. These branches can later be merged back into the main branch
    once your changes are complete.
  prefs: []
  type: TYPE_NORMAL
- en: Git also facilitates collaboration among team members by allowing you to share
    your changes with others through a shared remote repository. Other team members
    can then pull your changes from the remote repository to their local copies.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Git’s distributed nature and powerful branching capabilities make it
    a preferred choice for many development teams. It provides flexibility, efficiency,
    and seamless collaboration for managing and tracking changes in software projects.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a DVCS allows us to work independently, collaborate effectively,
    and maintain project history and integrity, even in decentralized environments.
    It provides flexibility, security, and powerful features for managing and tracking
    changes in software projects.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized VCSs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **centralized VCS** (**CVCS**) is a type of VCS where there is a single central
    repository that stores all files and their respective versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the structure of a CVCS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – CVCS structure](img/B22017_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – CVCS structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single repository**: In a CVCS, all users access and work on the same central
    repository. This means that there is only one copy of the project’s history, stored
    on a central server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited offline access**: Since the repository is centralized, users typically
    need to be connected to the central server to access files and make changes. This
    can limit the ability to work offline or in environments with limited connectivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborative workflow**: Users commit their changes directly to the central
    repository, where they are visible to all team members. This facilitates collaboration
    and ensures that everyone is working with the latest version of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential bottlenecks**: In a CVCS, the central server can become a bottleneck,
    especially in large teams or projects with heavy usage. If the server goes down,
    developers may be unable to access or commit changes until it is restored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited branching**: CVCS systems typically offer limited branching capabilities
    compared to distributed systems such as Git. Users may need to coordinate closely
    to avoid conflicts when working on different features or changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SVN**, or **Subversion**, is an example of a CVCS. In SVN, there is a single
    central repository that stores all project files and their respective versions.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike DVCSs such as Git, SVN does not provide users with their own local copies
    of the entire project’s history. Instead, users interact directly with the central
    repository to access files and make changes.
  prefs: []
  type: TYPE_NORMAL
- en: SVN facilitates a collaborative workflow by allowing developers to commit their
    changes directly to the central repository. This ensures that everyone is working
    with the latest version of the code and helps maintain project integrity.
  prefs: []
  type: TYPE_NORMAL
- en: While SVN lacks some of the flexibility and offline capabilities of DVCSs, it
    remains a popular choice for many development teams, especially in centralized
    environments where strict control over the code base is desired.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a CVCS relies on a single central repository for storing and managing
    project files and versions. While it facilitates collaboration and provides a
    centralized **source of truth** (**SoT**), it may pose challenges in terms of
    offline access, potential bottlenecks, and limited branching capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s delve into essential Git commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, you’ll find essential Git commands. Make sure you have
    Git installed on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **git init** | Initializes a new Git repository in the current directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| **git clone [url]** | Clones an existing Git repository from a remote server
    to your local machine |'
  prefs: []
  type: TYPE_TB
- en: '| **git add [file]** | Adds a file or changes to the staging area to be included
    in the next commit |'
  prefs: []
  type: TYPE_TB
- en: '| **git commit -m "[message]"** | Commits changes to the local repository with
    a descriptive message |'
  prefs: []
  type: TYPE_TB
- en: '| **git push** | Uploads local repository content to a remote repository |'
  prefs: []
  type: TYPE_TB
- en: '| **git pull** | Downloads changes from a remote repository and merges them
    into the local repository |'
  prefs: []
  type: TYPE_TB
- en: '| **git status** | Displays the status of the working directory and the staging
    area |'
  prefs: []
  type: TYPE_TB
- en: '| **git log** | Shows a list of commits in the repository, along with details
    such as author, date, and commit message |'
  prefs: []
  type: TYPE_TB
- en: '| **git branch** | Lists all branches in the local repository |'
  prefs: []
  type: TYPE_TB
- en: '| **git checkout [branch]** | Switches to the specified branch |'
  prefs: []
  type: TYPE_TB
- en: '| **git merge [branch]** | Merges changes from the specified branch into the
    current branch |'
  prefs: []
  type: TYPE_TB
- en: '| `git` `remote -v` | Lists all remote repositories associated with the local
    repository |'
  prefs: []
  type: TYPE_TB
- en: Many commands may be overwhelming, especially considering our book’s context.
    Instead, we’ll rely on **graphical user interface** (**GUI**) tools such as the
    GitHub Desktop app for version control, where most actions can be performed through
    the **user interface** (**UI**). Feel free to depend on the GUI for all processes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore best practices for collaborating on code
    and resolving conflicts efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborating and resolving conflicts with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating collaborative environments and maintaining code quality are vital
    aspects of software development. Let’s explore effective collaboration, conflict
    resolution, and code quality maintenance in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for collaborating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Effective collaboration is essential for successful project development, and
    adopting best practices ensures smooth teamwork and code management throughout
    the process. The following are some best practices to follow when working with
    VCSs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frequent and incremental commits for a streamlined workflow**: Making small,
    frequent commits is an uncomplicated yet highly effective enhancement for your
    workflow, even though it poses a challenge for some developers. In the context
    of other project management tools, where tasks are typically broken down into
    manageable parts, the same approach should be applied to commits. Each commit
    should specifically correspond to one task or ticket unless a single line of code
    miraculously addresses multiple issues. For more extensive features, it’s beneficial
    to break them down into smaller tasks and create commits for each one. The primary
    advantage of opting for smaller commits is the increased ease of detecting and
    reverting undesired changes in case something goes wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prioritize getting the latest changes**: Make it a habit to fetch the latest
    changes from the repository into your working copy whenever it’s feasible. It’s
    not advisable to work in isolation as this raises the risk of encountering merge
    conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mindful committing for a smooth workflow**: Refrain from making hasty commits.
    The **commit -a** command, or its equivalents, should only be employed during
    the initial commit of a project, typically when the project consists solely of
    **README.md** files. A commit should exclusively encompass files pertinent to
    the specific change being committed to the repository. Exercise caution, especially
    when dealing with Unity projects, as certain modifications may inadvertently affect
    multiple files, such as scenes, Prefabs, or Sprite Atlases, even if not intended.
    Accidentally committing changes to a scene that another team member is concurrently
    editing can lead to complications for them during their own commit process, necessitating
    the merging of your changes beforehand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crafting clear commit messages**: Maintain clarity in your commit messages
    as they narrate the evolution of your project. It’s more convenient to trace the
    addition of new gameplay mechanics in your game when the commit message explicitly
    states, “**implemented new enemy behavior for level 3" rather than opting for
    a more casual expression such as, "added some cool stuff to level 3**.” When utilizing
    a task ticketing system such as Jira or GitLab, it’s advantageous to include a
    ticket number in your commit message. Many systems can be configured to integrate
    with smart commits, enabling you to reference tickets and update their status
    directly from your commit message. For instance, a commit message such as “**JRA-123
    #close #comment task completed**” would close the JRA-123 Jira ticket and append
    the comment “task completed” to the ticket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the realm of collaborative coding, mastering these best practices not only
    fosters seamless teamwork but also streamlines code management throughout project
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering branching and merging in collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding branching and merging strategies for collaborative development
    is crucial for effective teamwork in software projects. Next are some ideas and
    guidelines to assist you with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some crafting branching and merging strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature branches**: Work on new features or fixes in separate branches. This
    practice maintains the cleanliness of the main branch while enabling us to work
    independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release branches**: Create branches specifically for release candidates to
    stabilize the code base before deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hotfix branches**: Establish branches to address critical issues or bugs
    in production without disrupting ongoing development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-lived branches**: Some projects may require long-lived branches for
    ongoing development efforts or specific feature sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exploring branches, forks, and pull requests offers valuable insights into
    the intricacies of collaborative coding and VCSs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Branches**: Create feature branches for each new task or feature you work
    on. This keeps changes isolated and makes it easier to review and merge code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forks**: In open source projects, contributors often fork the main repository
    to work on changes independently. Forks allow for experimentation without affecting
    the original code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull requests**: Pull requests (or merge requests) are a key mechanism for
    proposing changes and initiating code review. They provide a structured way to
    discuss and approve modifications before merging them into the main branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code reviews**: Emphasize the importance of thorough code reviews in the
    pull request process. Reviewing code helps maintain code quality, identify potential
    issues, and share knowledge among team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encouraging a clear branching and merging strategy, along with effective use
    of branches, forks, and pull requests, promotes collaboration, code quality, and
    project stability in software development teams.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering code conflict management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding the nature of code conflicts and how to resolve them is essential
    for seamless collaboration and project success. Let’s delve into common types
    of conflicts and learn practical techniques for resolving them in Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring code conflict origins and navigating conflict resolution in Unity
    projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Understanding the origins of code conflicts is crucial for maintaining a harmonious
    development environment and ensuring smooth collaboration among team members,
    Let’s delve into specific points that contribute to these conflicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merge conflicts**: When multiple contributors modify the same file or code
    block, conflicting changes can arise during merging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural changes**: Renaming files, relocating directories, or altering
    project structures can introduce conflicts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency dilemmas**: Incompatible dependencies or divergent library versions
    across project components can lead to conflicts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch divergence**: Significant deviations from the main branch make merging
    changes back into the main code base challenging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we’ll explore two methods to resolve conflicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual conflict resolution**: Learn to review conflicting changes in code
    files and decide which modifications to retain, modify, or discard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control integration**: Explore how Git and other VCSs integrate with
    Unity, offering built-in merge tools and third-party plugins for conflict resolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s engage in practical conflict resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Practical conflict solving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After understanding the causes of conflicts, it’s essential to learn how to
    resolve them. I’ll share an example of a conflict from one of my current projects
    and how I successfully resolved it. While the conflict wasn’t significant, the
    approach used for resolving code conflicts applies universally. Let’s proceed
    with resolving code conflicts using GitHub Desktop and Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your local changes conflict with modifications made to the same file on
    the remote server, the following panel will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Resolve conflict panel in GitHub Desktop](img/B22017_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Resolve conflict panel in GitHub Desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'When this panel appears, it signals the need to compare and decide between
    conflicting versions of the same file from different sources. In GitHub Desktop,
    this panel represents the conflict resolution interface. By clicking the drop-down
    button, you can select your preferred editing program, such as Visual Studio or
    Visual Studio Code. For this example, when you select Visual Studio as the default
    program, the editor will open. You can choose to click on the **Open Merge Editor**
    option, as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Conflict mode in Visual Studio](img/B22017_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Conflict mode in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Merge Editor, you’ll notice there are three sections: the incoming or
    remote version, the current or local version, and the resulting file after merging.
    Here, you need to review the changes and decide whether to combine them or keep
    one version based on the flow of the feature or task requirements. Once you or
    the responsible senior has finished editing, click on **Accept Merge**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Merge Editor in Visual Studio](img/B22017_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Merge Editor in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'After closing the Merge Editor, you’ll notice that the sidebar now includes
    an option to commit the changes. Then, you can click on **Commit Staged** in the
    side panel to push the changes after the merge, as you can see in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – File after editing the conflict](img/B22017_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – File after editing the conflict
  prefs: []
  type: TYPE_NORMAL
- en: Remember
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to focus, especially when the same file is involved in two different
    tasks, ensuring that the logic of both tasks continues to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the **command-line interface** (**CLI**) to resolve merge conflicts
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring code conflict origins and navigating conflict resolution using the
    CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLI remains a fundamental and widely used method for resolving Git conflicts.
    While GUIs are available and can provide visual aids for conflict resolution,
    many developers, particularly those comfortable with terminal-based workflows,
    prefer the command line as their default approach. The CLI offers granular control,
    precise navigation through code changes, and efficient merging capabilities, making
    it a robust tool for managing Git conflicts effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, ensure you have another branch in your project. We will then
    modify the same file in the two branches to create a conflict and resolve it.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to your project directory and open the terminal there, or use the **cd**
    command in the terminal to navigate to your project directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, ensure that you are currently in one of your other branches.
    In my case, I have a branch called **feature/branch-name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the **git checkout branch-name** command to switch to the desired branch,
    as demonstrated in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Checkout feature branch](img/B22017_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Checkout feature branch
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make a modification to a file. In my case, I’ll comment out a line
    in a script, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Commenting out a line in a function](img/B22017_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Commenting out a line in a function
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add and commit that file using **git add filename** followed by
    **git commit -m "commit message"**, as you can see in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Committing changes](img/B22017_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Committing changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Push your changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Pushing changes](img/B22017_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Pushing changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can go to another branch; in my case, I will return to the main branch
    using the **git** **checkout** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Returning to the main branch](img/B22017_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Returning to the main branch
  prefs: []
  type: TYPE_NORMAL
- en: Modify the same file to make a conflict, then we need to add, commit, and push
    changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, return to the feature branch again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, execute the **merge** command from the main branch, as illustrated in
    the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Merging from the main branch](img/B22017_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Merging from the main branch
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `git status` command to identify the file or files that
    require conflict resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Checking conflict files](img/B22017_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Checking conflict files
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file in the editor to resolve the conflict, as illustrated in the
    following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Conflict code](img/B22017_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Conflict code
  prefs: []
  type: TYPE_NORMAL
- en: 'After making the necessary edits, add and commit the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Commit after solving the conflict](img/B22017_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Commit after solving the conflict
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **git status** to ensure everything is clear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Checking status](img/B22017_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Checking status
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, push the branch after resolving the conflict:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Pushing the feature branch](img/B22017_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Pushing the feature branch
  prefs: []
  type: TYPE_NORMAL
- en: By using the CLI, we can efficiently resolve conflicts in Git repositories by
    navigating to the project directory, switching to the branch containing the conflict,
    modifying the conflicting file, adding and committing the changes, pushing the
    branch, and finally merging the changes with the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, mastering code conflict management involves understanding conflict
    origins and resolution techniques. In this section, we explored common conflict
    types such as merge conflicts and structural changes, and we delved into practical
    conflict resolution methods using tools such as GitHub Desktop, Visual Studio,
    and the CLI. By learning to navigate conflicts effectively, we ensure smooth collaboration
    and project success in Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will explore how to effectively work with existing
    projects, providing instructions and a practical example for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding existing code bases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When delving into an existing code base, there are key steps to take to familiarize
    yourself with its structure and functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project structure and organization**: Begin by exploring the project’s directory
    structure and organization. Understand how files and folders are arranged and
    grouped according to functionality or modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review documentation**: Look for any available documentation, including README
    files, wiki pages, or inline comments within the code. Documentation can provide
    valuable insights into the project’s purpose, architecture, and design decisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify key components and relationships**: Identify key components, modules,
    and their relationships within the code base. Determine how different parts of
    the code interact with each other and understand the overall architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize code analysis tools and integrated development environment (IDE)
    features**: Make use of code analysis tools and features provided by your IDE
    to explore code dependencies, inheritance hierarchies, and function calls. Tools
    such as static code analyzers can help identify potential issues or areas for
    improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understand coding standards and conventions**: Familiarize yourself with
    coding standards and conventions used in the project. Pay attention to naming
    conventions, code formatting, and documentation practices to ensure consistency
    across the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communicate with team members**: Engage with team members or project leads
    to gain insights into the code base and its design decisions. Discuss any questions
    or uncertainties you have and leverage their expertise to deepen your understanding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning work on an existing project demands time and dedication to grasp its
    complexities. Yet, this initial exploration establishes a base for fruitful contributions,
    ensuring the project’s durability and ease of maintenance. As you familiarize
    yourself with the code base, you’ll gain the ability to suggest improvements,
    tackle problems, and engage in effective collaboration with the project team.
  prefs: []
  type: TYPE_NORMAL
- en: Practical exploration for the existing code base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll illustrate the code review process with an example, either after following
    the preceding steps or by considering these steps beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re assigned a task in a new project, you can either proceed independently
    following these steps, seek guidance from your senior or leader if needed, or
    check if there’s a similar approach already implemented in the game.
  prefs: []
  type: TYPE_NORMAL
- en: My preferred method is to begin at the end and work backward to the source.
    For example, if you’re dealing with UI logic, start by examining the button’s
    onclick action to determine which function it calls. Then, navigate to that script
    to review the function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can examine the logic and check for additional calls to other scripts.
    Continue this process until you reach the core of the logic. Sometimes, a function
    may involve numerous calls to other scripts, so review them one by one to comprehend
    how they interact. This process enhances your understanding of the project. If
    the logic involves managers, you’ll grasp their responsibilities. Consequently,
    when you tackle tasks related to these managers in the future, you’ll be better
    equipped to understand and connect the logic effectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re assigned a new task and realize the manager, such as one handling
    player or game data, lacks a necessary function, you can simply append a new function
    to that manager. This approach allows you to expand the manager’s capabilities
    to accommodate your requirements seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: When collaborating with a third party, it’s beneficial to examine example scenes
    or scripts to grasp their functionality. By experimenting with and modifying these
    examples, you can gain insights into their usage and adapt them for your own features,
    focusing only on the essential logic needed for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see an example we will follow to see how we can understand the existing
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m currently examining the sound toggle function in the `SettingsView` script,
    which handles muting or unmuting the sound effects in another project I’m involved
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: I begin by navigating to the **SettingsView** script in the hierarchy and locating
    the toggle button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, I examine the action triggered when the value changes and identify the
    associated function or functions. Additionally, it’s important to verify if the
    toggle is referenced in the view script and if the function is attached through
    code. As illustrated in the following figure, the function can be found in the
    **Inspector**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.18 – SoundToggle component](img/B22017_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – SoundToggle component
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should navigate to the **SettingsView** script to examine the logic
    of **OnSoundClicked**, as illustrated in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.19 – OnSoundClicked function in the SettingsView script](img/B22017_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – OnSoundClicked function in the SettingsView script
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SetSFXVolume` function, as shown in the next figure, you can observe
    its associated logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.20 – SetSFXVolume function in the AudioManager script](img/B22017_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – SetSFXVolume function in the AudioManager script
  prefs: []
  type: TYPE_NORMAL
- en: In the **SetSFXVolume** function, we adjust the sound effects volume in the
    audio mixer, enabling us to control all audio sources linked to this mixer, muting
    or unmuting their sound. Additionally, the second line manages the sound state
    data, facilitating its persistence and storage locally or in the cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now examine the function responsible for setting the sound state in
    the **GameData** script, which manages the game’s data, as you can see in the
    following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.21 – SetSoundState function in the GameData script](img/B22017_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – SetSoundState function in the GameData script
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the advantage we gain is the presence of a script dedicated to audio
    control within the game, equipped with functions that can be utilized in future
    tasks related to audio management. Additionally, there exists a script named `GameData`,
    tasked with managing the game’s data. This allows us to reference it later for
    any data-related requirements, such as retrieving saved data or storing new data
    states.
  prefs: []
  type: TYPE_NORMAL
- en: This example is straightforward to follow, but the steps are comprehensive.
    Feel free to apply these steps to your projects or when you’re dealing with new
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about working with existing code in Unity using
    C#. We explored how to use VCSs, merge code, and fix conflicts when collaborating
    on projects. By understanding these concepts, we can work better with other developers
    and maintain code quality. The chapter also covered how to understand project
    structures, review documentation, and communicate effectively with team members.
    By taking the time to understand existing projects, we can contribute more effectively
    and make better decisions.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B22017_08.xhtml#_idTextAnchor127), we’ll look at adding outside
    assets and features to Unity games using C#. We’ll learn how to use pre-made assets
    to improve game visuals and add new features such as analytics and monetization.
    Get ready for new ways to enhance your games in the upcoming chapter!
  prefs: []
  type: TYPE_NORMAL
