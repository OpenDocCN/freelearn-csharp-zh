- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating UI Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already discussed how to create animation transitions for buttons,
    in this chapter, we’ll take a look at animation transitions more thoroughly and
    discuss how to create animations for UI elements in a more general sense.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you have a basic understanding of Unity’s Animation
    System and will not go into detail describing the names of the various menus and
    layout of the Animation Window and Animator Window. Animation Clips and Animators
    will be described briefly, with a focus on how they relate to UI and their implementation,
    which will be discussed in the examples at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying animations to the various UI elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pop-up window that fades in and out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a complex Animation System with a State Machine and Animation Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though I am assuming that you have a basic understanding of Unity’s Animation
    System, I do want to emphasize the difference between an Animation Clip and the
    Animator.
  prefs: []
  type: TYPE_NORMAL
- en: When creating animations for items in Unity, you start with **Animation Clips**.
    An Animation Clip should represent a single distinct action or motion. So, for
    example, if you had a menu that performed two separate actions, bouncing and zooming,
    you’d make each of those actions a separate Animation Clip. Although you can have
    multiple things happen in a single Animation Clip, it is very important not to
    put multiple actions in a single clip unless they are always going to happen at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Every GameObject can have multiple Animation Clips. The **Animator** determines
    how all of these Animations link together. So, a GameObject’s Animator will have
    all of its Animation Clips within it.
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to make this distinction because in the past, I have seen projects
    with epic Animation Clips containing multiple actions that should have been broken
    down into more simple motions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As with previous chapters, all of the examples shown in this section can be
    found within the Unity project provided in the code bundle. They can be found
    within the scene labeled **Chapter14**.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2014](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2014)'
  prefs: []
  type: TYPE_NORMAL
- en: Animation Clips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The great thing about the Unity Animation System is that you can animate nearly
    any property of the UI. To create an Animation Clip, simply open the Animation
    Window (**Window** | **Animation** or *Ctrl* + *6*), and with the UI element you
    want to animate selected, select **Create**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: The Animation Window](img/Figure_14.01_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: The Animation Window'
  prefs: []
  type: TYPE_NORMAL
- en: Once you do so, you’ll be prompted to save the Animation Clip.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the Animation Clip, you can then add any property to the clip’s
    timeline by clicking on **Add Property**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2: The SliderExampleAnimation timeline](img/Figure_14.02_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: The SliderExampleAnimation timeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing so will bring up every component of the object, as well as a list of
    all of its children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: Adding an Animation property](img/Figure_14.03_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Adding an Animation property'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also view the components and children of each child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: Expanding Animation components](img/Figure_14.04_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Expanding Animation components'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can view the components and children of those children. You can continue
    in this manner until you have exhausted the list of GameObjects that are nested
    under the selected GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you expand a component of a GameObject or one of its children, you will
    then note a list of all properties of that component that can be animated. As
    you will notice in the following screenshot, almost every property on the **Slider**
    component can be animated in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: The Slider component and its Animatable properties](img/Figure_14.05_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: The Slider component and its Animatable properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only properties that have the following data types can be animated with the
    Animation System:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vector2`, `Vector3`, and `Vector4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Quaternion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the plus sign will add the property to the Animation timeline along
    with two keyframes. You can then change the values of each property at the various
    keyframes.
  prefs: []
  type: TYPE_NORMAL
- en: A **keyframe** is an important or *key* (hence the name) frame within an animation.
    It represents the start or end point of a transition within an animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: SliderExampleAnimation first keyframe](img/Figure_14.06_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: SliderExampleAnimation first keyframe'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the values encased in the red boxes represent the
    value of the property at the particular frame. Boolean values are represented
    by checkboxes, and float values are represented by numbers. Each type can be edited
    directly by selecting them.
  prefs: []
  type: TYPE_NORMAL
- en: Unity will fill in the values between the keyframes so that they change (or
    interpolate) on a curve. You can view the interpolation curve by selecting the
    **Curves** tab.
  prefs: []
  type: TYPE_NORMAL
- en: You can watch the changes occur throughout all frames by playing the animation
    or scrubbing the playhead.
  prefs: []
  type: TYPE_NORMAL
- en: The **playhead** is the marker that indicates what frame is currently being
    displayed. “Scrubbing the playhead” means dragging the playhead across the timeline
    to view changes over individual frames.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7: The Curves version of the timeline](img/Figure_14.07_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: The Curves version of the timeline'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean properties are interpolated on a linear curve. All other properties
    (since they are a combination of floats) are interpolated along an ease-in-out
    curve. You can adjust these by adjusting the handles of the tangents at the keyframes
    by right-clicking on the keyframe.
  prefs: []
  type: TYPE_NORMAL
- en: Often, these ease-in-out curves will cause your UI to appear *bouncy*, and adjusting
    the interpolation curve can remove that bounce. For example, animating an object
    between two points may make the object go past the destination point momentarily
    due to the ease-in-out nature of the default interpolation curve.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of my favorite things about Animation Clips is the ability to add Animation
    Events to frames on the timeline. Animation Events allow you to call functions
    that exist on the GameObject at specified frames. They are represented by white
    *flags* above the timeline, and hovering over them will show the name of the function
    called by the Animation Event.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Animation Event can only call a function that exists somewhere on the GameObject
    the Animation Clip is attached to. The function can be public or private and can
    also have a parameter. The parameter can be of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `AnimationEvent` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add an Animation Event to the Animation Clip’s timeline by right-clicking
    on the area above the frame in which you wish to place the Animation Event and
    clicking on **Add Animation Event**, or you can click the **Add Event** button.
    Selecting the **Add Event** button will add the Animation Event wherever the playhead
    currently rests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8: Animation Events](img/Figure_14.08_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Animation Events'
  prefs: []
  type: TYPE_NORMAL
- en: You can delete the Animation Event by selecting the white flag and clicking
    on **Delete**, and you can move it by clicking on it and dragging it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The appearance of the Animation Event’s Inspector depends on whether the Animation
    Clip is attached to a GameObject and whether the GameObject is currently selected.
    The two appearances are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9: The Inspector of the Animation Event](img/Figure_14.09_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: The Inspector of the Animation Event'
  prefs: []
  type: TYPE_NORMAL
- en: If the Animation Clip is attached to a GameObject and the GameObject is selected,
    a dropdown menu will appear with a list of all available functions. If the selected
    function has a parameter, then options concerning the parameter will be made available
    (take a look at the preceding screenshot). Otherwise, the name of the function
    and the parameters to pass will have to be entered manually.
  prefs: []
  type: TYPE_NORMAL
- en: If you play the `Chapter14` scene with the `Slider Animation Example` GameObject
    enabled, you will see an animation with events playing out.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at Animation Clips, let’s look at Animation Controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Animator Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever an Animation Clip is created for an object, an `SliderExampleAnimation`
    Animation Clip on the `Slider` GameObject in the preceding section, an Animator
    named `Slider` was created and the Animator component was attached to the `Slider`
    GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10: The Slider Animator’s Inspector](img/Figure_14.10_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: The Slider Animator’s Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: An Animator is needed to play Animation Clips because it determines when Animation
    Clips are played.
  prefs: []
  type: TYPE_NORMAL
- en: An Animator is a type of decision tree known as a *state machine*. It holds
    a collection of *states*. States are essentially *statuses at a moment in time*.
    The *current state* of a state machine would be a representation of what is happening
    at this moment. So, for example, if there were a state machine describing my actions
    and behaviors, my *current state* would be *typing on the keyboard*. My state
    machine would have other states that I could eventually transition to, such as
    *sleeping* or *crying about approaching deadlines* if certain conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'States in the Animator are represented by rectangles called *nodes*. States
    are connected by transitions that are represented by arrow lines. These transitions
    occur after either a predetermined time or a set of conditions have been met.
    The current state will have a blue, animated status bar on it telling you the
    percentage of the state that has been completed. If the current state is waiting
    for a transition to occur, this status bar may loop or stop in the full position
    until the conditions of the transition are met:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11: The Slider Animator](img/Figure_14.11_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: The Slider Animator'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom-right corner of the Animator Window displays the name of the current
    Animator controller as well as its folder location. This can be very helpful when
    you have many different Animators, as it tells you which Animator you are working
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'States can be empty or represent Animation Clips. If a state represents an
    Animation Clip, it will have an Animation Clip set to its **Motion** property
    in its **Inspector**, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12: The Motion property of an Animation State](img/Figure_14.12_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: The Motion property of an Animation State'
  prefs: []
  type: TYPE_NORMAL
- en: Most states will be colored gray, but those colored otherwise will represent
    special states. Every Animator will have an **Entry** node (green), an **Exit**
    node (red), and an **Any State** node (blue) within it. The first state you add
    to an Animator will be assigned the Default Layer State node (orange). You can
    change the state of the Default Layer State at any time. Note that Animator Layers
    are discussed in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: The **Entry** and **Exit** nodes essentially work as *gates* between state machines.
    You can have state machines within state machines, and these *gates* decide what
    happens after the state machine is entered and exited, respectively. So, the **Entry**
    node represents the instance the state machine starts, and the **Exit** node represents
    the instance it stops.
  prefs: []
  type: TYPE_NORMAL
- en: The **Entry** node always transitions to the Default Layer State, and you cannot
    define the conditions of the transition, so the transition will always happen
    automatically and instantly. Therefore, you can think of the Default Layer State
    as the *first* state that will occur when the state machine begins.
  prefs: []
  type: TYPE_NORMAL
- en: The **Any State** node is an *all-encompassing* state. You use this state when
    you want a transition to happen, regardless of the current state. You can only
    transition away from the **Any State** node. Continuing with the example of a
    state machine that describes my behavior, I would have a transition from **Any
    State** to the state of *crying about approaching deadlines*, because no matter
    what I am currently doing, I could burst into tears if the condition “deadline
    is within 24 hours” is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated before, the Animator will stay in the current state until a specified
    amount of time has passed or a set of conditions have been met. Selecting a transition
    arrow will display the conditions of transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13: Expanded properties of an Animation](img/Figure_14.13_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: Expanded properties of an Animation'
  prefs: []
  type: TYPE_NORMAL
- en: The transition from the preceding screenshot requires both a specified amount
    of time and a condition. The transition also isn’t instantaneous and takes `0.25`
    s to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Conditions** that must be met for a transition to occur are set by the
    Animator’s **Parameters**, which can be found and created in the top-left corner
    of the Animator Window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14: Adding an Animator Parameter](img/Figure_14.14_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Adding an Animator Parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of these parameters can be set from scripts. There are four types
    of Parameters: `False` after it is used by a transition. Trigger Parameters are
    helpful for creating flood-gate-type actions where the animation has to stop and
    wait before it can proceed to the next state. These are preferred over Bool Parameters
    in instances where the states and transitions form a loop, because a Bool Parameter
    would have to be manually reset before the state looped back around.'
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the list of **Parameters**, you can tell which type they are
    by the value on the right. Float Parameters have decimal numbers, Int Parameters
    have integers, Bool Parameters have square checkboxes, and Trigger Parameters
    have circular radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Since Animators are state machines, they can be used to accomplish much more
    than animations. Animators can be used to keep track of complex game logic. For
    example, I created the following state machine for a match-three RPG to keep track
    of what was currently happening in the game. Using it to keep track of the current
    state of the game allowed me to restrict what the player could do based on what
    was happening in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the enemy character was attacking, the player would not interact
    with the pieces on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15: Example of a Animation State Machine used for logic](img/Figure_14.15_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: Example of a Animation State Machine used for logic'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the properties of the Animator Controller, let’s look
    at some of its uses.
  prefs: []
  type: TYPE_NORMAL
- en: The Animator of Transition Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 9*](B18327_09.xhtml#_idTextAnchor213), we took a look at Button
    Animation transitions and created a simple animation for a Button. We let the
    Button component automatically generate the Animator for us, but never looked
    at the Animator or did anything with it. Now that we’ve discussed Animators, let’s
    look at the Animator of the `Play Button` saved in `Assets/Animations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.16: The Animator of a Button](img/Figure_14.16_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.16: The Animator of a Button'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding screenshot, the Animator that was automatically
    generated for us isn’t particularly complicated and its setup is self-explanatory.
    It contains states to hold the following five Animation Clips: `Normal`, `Highlighted`,
    `Pressed`, `Selected`, and `Disabled`. All of the Animation Clips transition from
    `Any State`. Also, there are five Trigger Parameters: `Normal`, `Highlighted`,
    `Pressed`, `Selected`, and `Disabled`.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically generating an Animator for any of the UI elements that allow for
    transition animations will result in the exact same setup. Even though this Animator
    is preset for you, you are free to adjust it however you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Animator layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the Animator, if you have a state with transitions to multiple nodes,
    only one transition can occur. For example, in the following screenshot, the `ChooseAState`
    state can only transition to one of the other states at once, even if the transition
    conditions for all are met; this is true regardless of the type of Parameter that
    you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.17: A forking animation example in the Chapter14 scene](img/Figure_14.17_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.17: A forking animation example in the Chapter14 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want multiple animations to trigger at once, you can use Animation Layers.
    The following layer setup will have all three states running simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18: An Animation Layers Example in the Chapter14 scene](img/Figure_14.18_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.18: An Animation Layers Example in the Chapter14 scene'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve found that the most common need for something like this is when you have
    an object made of multiple sprite sheets and you want multiple sprite sheet animations
    to trigger at the same time and putting them all on the same Animation Clip doesn’t
    make sense. For example, I’ve worked on a game where a 2D character had multiple
    interchangeable parts, and each part had its own sprite sheet animation. It was
    necessary to have the idle animation for each part start all at the same time.
    Since the parts could be swapped out, there were multiple combinations of parts
    that could be achieved, and it would not have made sense to make all the different
    possible idle animation combinations. It also wouldn’t have made sense to give
    each possible part its own Animator. So, I made a layer for each body part and
    was able to have the individual sprite animations all play at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Animation Parameters in scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can set the values of the Animator Parameters via scripts using the `SetFloat()`,
    `SetInteger()`, `SetBool()`, `SetTrigger()`, and `ResetTrigger()` functions of
    the `Animator` class. You reference the Animator Parameter variables by the string
    names assigned to them within the Animator.
  prefs: []
  type: TYPE_NORMAL
- en: To set the Animation Parameters, you first get the Animator on which the Parameters
    were defined; you can do this with either a public Animator variable or using
    `GetComponent<Animator>()`. Then, you call the necessary function on the Animator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example that would set the following **Parameters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.19: Different types of Animation Parameters](img/Figure_14.19_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.19: Different types of Animation Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script would set the Animator Parameters defined in the previous
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of using a Trigger is that you usually don’t have to reset it as
    it instantly resets the moment a transition uses it. However, if you set a Trigger
    and the transition is never reached, you will need to reset it using `ResetTrigger()`.
  prefs: []
  type: TYPE_NORMAL
- en: Animator Behaviours
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to write code that fires at specific points within a state, you
    can use a unique class of scripts known as State Machine Behaviours. State Machine
    Behaviours can be added to any state node you create within the Animator. I specify
    *you create* because you cannot add them to the **Entry** node, **Exit** node,
    or **Any** **State** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new State Machine Behaviour by selecting a state and clicking
    on **Add Behaviour**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.20: How to add a Behaviour to an Animation State](img/Figure_14.20_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.20: How to add a Behaviour to an Animation State'
  prefs: []
  type: TYPE_NORMAL
- en: All new State Machine Behaviours created in this way are saved in the `Assets`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the script, it will be automatically populated with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that this class is derived from `StateMachineBehaviour` rather than `MonoBehaviour`,
    like the scripts we attach to GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few functions prewritten in the script for you, along with descriptions
    of how to use them. Just as `Awake()`, `Start()`, and `Update()` are predefined
    functions for MonoBehaviour, `OnStateEnter()`, `OnStateUpdate()`, `OnStateExit()`,
    `OnStateIK()`, and `OnStateMove()` are predefined functions that call at specific
    times. You can delete whichever functions you don’t want to use. You can also
    write other functions within this script, and they are not restricted to these
    predefined ones.
  prefs: []
  type: TYPE_NORMAL
- en: These functions can do whatever you want them to do, even set the Animator Parameters
    of your Animator.
  prefs: []
  type: TYPE_NORMAL
- en: I find State Machine Behaviours to be incredibly helpful because I use state
    machines extensively to control the logic of my games. Earlier, in this section,
    I showed you a state machine I created for a match-three RPG. I used multiple
    State Machine Behaviours to let my other scripts know when the states had changed,
    call functions from other scripts at specified times, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed using Animation clips and Animator Controllers, let’s
    look at some examples of how to implement them in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: The main focus of this chapter is to provide examples of how to create common
    UI animations and effects, so let’s get to it. In these examples, I will show
    you a basic re-usable animation for fading UI Panels in and out, as well as a
    more complex animation of a loot box dependent on player interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Animating pop-up windows to fade in and out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our first example, we will continue to work on our main scene.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have a `Pause Panel` and `Inventory Panel` that instantly appear
    when the *P* or *I* key is pressed. That’s not terribly interesting, so let’s
    add some animations to have the Panels *pop* in and out with fade and scale animations.
  prefs: []
  type: TYPE_NORMAL
- en: It can get rather tedious having to expand all of the parents to see their children
    every time you go to a new scene. A shortcut to open all parents is to select
    everything in the Hierarchy and then press the right arrow key on the keyboard.
    You can do this multiple times if you have multiple nestings. The left arrow key
    will collapse the parents.
  prefs: []
  type: TYPE_NORMAL
- en: Our workflow to set up these animations and their functionality will be to create
    Animation Clips, set up our Animator, and then write code that sets the Animator’s
    parameters at the appropriate times. To make the steps easier to digest, I’ve
    broken them into sections. The first section covers all of the steps involved
    with setting up the Animation Clips and Animator and the second section covers
    the sets involved with writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a pop in and out animation on `Pause Panel` and `Inventory Panel`,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by adding an Animation Clip to `Pause Panel` that will cause it
    to scale and fade in. Open the Animation Window and select `Pause Panel` from
    the Hierarchy. Select `Assets/Animation` folder and name it `FadeAndScale`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to control four properties of this Panel: its scale, its alpha value,
    its ability to be interacted with, and its raycast blocking. Let’s start with
    scale. We can adjust this property from the Rect Transform component. Select **Add
    Property** and click on the plus sign next to **Scale** under **Rect Transform**,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.21: Adding the Scale property](img/Figure_14.21_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.21: Adding the Scale property'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two keyframes are initialized for the **Scale** property at **0:00** and **1:00**.
    This means that the animation will last one second, which is a bit long for a
    pop-in animation. Select the keyframe at **1:00** and drag it to **0:30** to make
    the animation half a second long:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.22: Adjusting the length of the animation](img/Figure_14.22_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.22: Adjusting the length of the animation'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the Panel to start off small and then get big. To achieve this, we
    will need to adjust the *x* and *y* scales. Expand the `1` at both keyframes.
    Since we want the scale to start small and then enlarge to its normal size, we
    want it to scale from `0` to `1`. We only need to adjust the *x* and *y* scales
    since the *z* scale doesn’t really affect a 2D object. So, at keyframe `0` by
    typing `0` in their property boxes, as follows:![Figure 14.23: Adjusting the Scale
    properties](img/Figure_14.23_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.23: Adjusting the Scale properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you play the animation, you’ll note that `Pause Panel` is quickly scaling
    in. Since parent/child relationships scale children with their parents, we don’t
    have to animate the scale of all the `Pause Panel` children separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s control the alpha of the Panel to fade it in. We don’t want to animate
    the alpha on the `Pause Panel`. Doing so would only affect the alpha of the Panel’s
    background Image and would not affect the children. Instead, we want to animate
    the alpha value on the `Pause Panel` and all its children work in unison. Remember
    that this was the whole reason we used a Canvas Group component to begin with.
    Let’s select **Add Property** | **Canvas Group** | **Alpha**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.24: Adding the Alpha property](img/Figure_14.24_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.24: Adding the Alpha property'
  prefs: []
  type: TYPE_NORMAL
- en: To fade in, the Panel should start completely transparent and end completely
    opaque. Both keyframes already have the `1`, so change the `0` at the first keyframe.
    Playing the animation (or scrubbing the playhead) will show the Panel and all
    of its children fading in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to animate whether or not the Panel can be interacted with. We
    don’t want the player to be able to interact with the dropdown menu or mute buttons
    when the Panel is still popping in. This too is controlled by the Canvas Group
    component—select **Add Property** | **Canvas Group** | **Interactable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Pause Panel` and its children should be interactable only after it has
    fully popped into the scene. So, deselect the checkbox next to **CanvasGroup.Interactable**
    at the first keyframe to make the Canvas Group animate from interactable to not
    interactable. When you scrub the playhead, you’ll see that the property does not
    turn back on until the very last frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last item we will need to animate is its raycast blocking. Select `false`
    to `true` as you did with the `FadeAndScale` Animation Clip’s timeline should
    now appear, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.25: The Timeline of the FadeAndScale Animation Clip](img/Figure_14.25_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.25: The Timeline of the FadeAndScale Animation Clip'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our Animation Clip set up, we can start working inside the
    Animator. When we created the `FadeAndScale` Animation Clip, an Animator named
    `Pause Panel` was automatically created. An Animator component was also added
    to the `Pause Panel` GameObject, with the `Pause Panel` Animator assigned to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `Pause Panel` selected, open the Animator Window. You should see something
    similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.26: The Animator of Pause Panel](img/Figure_14.26_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 14.26: The Animator of Pause Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will see a state named `FadeAndScale`. This state uses the `FadeAndScale`
    Animation Clip as its **Motion**, which you can view in its Inspector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Currently, since the `FadeAndScale` state is connected to the `FadeAndScale`
    animation will play instantly. It will also play on a loop. That’s not at all
    what we want, obviously. Let’s stop it from playing when the game starts by creating
    an empty state as the Layer Default State. Right-click anywhere within the Animator
    and select **Create State** | **Empty**:![Figure 14.27: Creating an Empty State](img/Figure_14.27_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.27: Creating an Empty State'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will add a gray-colored state named `New State` to the Animator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rename `New State` to `Empty State` by changing its name in its Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `Empty State` to the Layer Default State by right-clicking on it and selecting
    **Set as Layer** **Default State**:![Figure 14.28: Setting a state as the Layer
    Default](img/Figure_14.28_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.28: Setting a state as the Layer Default'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It will now be connected to `FadeAndScale` will also now no longer be the Layer
    Default State and will not have any transitions connected to it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.29: Empty State set as the Layer Default](img/Figure_14.29_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 14.29: Empty State set as the Layer Default'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We used an empty state as our Layer Default State because we want the Panel
    to do nothing, while it waits for us to tell it to start animating.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rearrange the items to a more viewable layout. I personally like the following
    layout for this Animator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.30: Rearranging the States](img/Figure_14.30_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.30: Rearranging the States'
  prefs: []
  type: TYPE_NORMAL
- en: The `FadeAndScale` Animation Clip now no longer instantly plays when the game
    starts. It is still set to have its animation loop, however. To fix this, select
    the `FadeAndScale` Animation Clip from your **Project** folder view. This will
    bring up its Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deselect the **Loop Time** property to disable looping on the animation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.31: Deselecting Loop Time](img/Figure_14.31_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.31: Deselecting Loop Time'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the `Pause Panel` to be able to fade in and out on command, but we
    don’t have an Animation Clip for fading out, only one for fading in. We actually
    don’t need to create a whole Animation Clip to achieve this motion. We can simply
    play the `FadeAndScale` Animation Clip backward. Duplicate the `FadeAndScale`
    state by selecting it and pressing *Ctrl* + *D*. This will give you a new state
    named `FadeAndScale 0` that has the `FadeAndScale` Animation Clip set as its **Motion**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.32: Duplicating a State](img/Figure_14.32_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.32: Duplicating a State'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the `FadeAndScale` state to `FadeAndScaleIn` and the `FadeAndScale 0`
    state to `FadeAndScaleOut`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To set the `FadeAndScaleOut` state to play the `FadeAndScale` Animation Clip
    backward, we simply have to change its `-1` in its Inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.33: Setting an animation to play in reverse](img/Figure_14.33_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.33: Setting an animation to play in reverse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all of our states set up properly, we can create the transitions
    between them. Start by creating two Trigger Parameters named `FadeIn` and `FadeOut`:![Figure
    14.34: The Animator Parameters](img/Figure_14.34_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.34: The Animator Parameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are using Trigger Parameters here because we want these values to instantly
    reset after we’ve used them. That way, we can create an animation cycle without
    having to write code that resets the parameter values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You create transitions between states by right-clicking on the first state,
    selecting **Make Transition**, and then clicking on the second state:![Figure
    14.35: Making transitions](img/Figure_14.35_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.35: Making transitions'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create transitions between the states in the following manner:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.36: The final state transition layout](img/Figure_14.36_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 14.36: The final state transition layout'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This transition flow will allow the Panel to transition from no animation to
    the `FadeAndScale` Animation Clip, then to the reversed `FadeAndScale` Animation
    Clip, and back and forth between the two.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you play the game, `Pause Panel` will instantly go from the `Empty State`
    to the `FadeAndScaleIn` state and then to the `FadeAndScaleOut` state, and back
    and forth between the two indefinitely. This is because transitions are automatically
    set to occur after an animation is complete. To stop this, you have to tell the
    transitions to only occur after a parameter has been set. Select the transition
    between the `Empty State` and the `FadeAndScaleIn` state. Select the plus sign
    in the `FadeIn` Trigger. Since we don’t want timing to be a factor in our transition,
    deselect **Has** **Exit Time**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.37: The transition properties](img/Figure_14.37_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.37: The transition properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the same steps for the transitions between the `FadeAndScaleIn` and
    `FadeAndScaleOut` States. Set the `FadeAndScaleIn` State to the `FadeAndScaleOut`
    State to the `FadeAndScaleOut` state to `FadeAndScaleIn` State to the `0` to ensure
    an instant transition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.38: How to set up the transitions of the Pause Panel](img/Figure_14.38_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.38: How to set up the transitions of the Pause Panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play the game now, you’ll note that the `Pause Panel` is visible when
    the game starts. This is because our animation states supersede the code we wrote
    in `ShowHidePanels.cs` that made the `Pause Panel` invisible at the start of the
    scene. We’ll deal with our broken code later, but for now, make the `Pause Panel`
    invisible at start by setting its **Canvas Group** component to have the following
    values:![Figure 14.39: The properties of the Canvas Group](img/Figure_14.39_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.39: The properties of the Canvas Group'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now when you play the game, the `Pause Panel` will not appear at the start.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ve completed setting up the animations for the `Pause Panel`, but before
    you proceed to the `Inventory Panel`, check whether the animations are working
    correctly. To do so, arrange your windows so that your Game view and Animator
    Window are both visible:![Figure 14.40: Playing the Empty State](img/Figure_14.40_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.40: Playing the Empty State'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You’ll see the progress bar on the current state of `Pause Panel` running. To
    force the transitions, click on the circles next to the appropriate Trigger parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If your animations are working the way they should, you can now set up the animations
    on the `Inventory Panel`. You may be thinking, “Ugh, now I have to do all of this
    again for the `Inventory Panel`?!” However, worry not, you don’t have to do it
    again, because you can reuse the Animator for the `Pause Panel` on the `Inventory
    Panel`. All of the properties we changed on the `Pause Panel` in the `FadeAndScale`
    Animation Clip also exist on the `Inventory Panel`. So, to give the same set of
    animations and controls to the `Inventory Panel`, we can simply attach the Animator
    we created to `Inventory Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we will be using the Animator we created on two different objects, it
    is a good idea to rename it. Change the name from `Pause Panel` to `PopUpPanels`.
    Now, drag it onto the `Inventory Panel`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just as we had to change the properties of the Canvas Group on `Pause Panel`
    to stop it from appearing when the scene starts, we also have to change the properties
    on the `Inventory Panel`. Set the properties as they appear in *Figure 14**.39*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we are done setting up our animations for our two Panels, we can begin
    writing code that will trigger the animations when the *P* and *I* keys are hit
    to bring up the Panels.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Animator’s Parameters with code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have a script named `ShowHidePanels.cs` attached to the `Main Camera` that
    would bring the `Pause Panel` and `Inventory Panel` up when the *P* and *I* keys,
    respectively, are pressed. Sadly, it no longer functions, since the animations
    now supersede the properties of the Canvas Groups we set within it. We can reuse
    the logic but will have to do a bit of work to get our Panels popping up again.
  prefs: []
  type: TYPE_NORMAL
- en: The changes that we will make to `ShowHidePanels.cs` will cause the Panels in
    preceding chapter scenes to stop appearing. If you plan on accessing the previous
    chapter scenes, save a secondary copy of this script as it is now so that you
    can access it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trigger the animations on the `Pause Panel` and `Inventory Panel` with code,
    complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ShowHidePanels.cs` script. Comment out all the code in the `Start()`
    and `Update()` methods that use `TogglePanel()`. After you comment out those lines,
    you should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of referencing the `Pause Panel` and `Inventory Panel` with their Canvas
    Group components, we’ll now reference them with their Animator components. Create
    the following two variable declarations at the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s create a new method called `FadePanel()` that accepts `Animator`
    and `bool` parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `Update()` method to now call the new `FadePanel()` method where
    the `TogglePanel()` method was once called. The bolded text in the following code
    signifies the added code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all we have to do to the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Drag the `Inventory Panel` and the `Pause Panel` into their appropriate slots
    on the **Show Hide** **Panels** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.41: The properties of the Show Hide Panels component](img/Figure_14.41_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.41: The properties of the Show Hide Panels component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Play the game and watch it kind of work. `Inventory Panel` should appear and
    disappear as necessary, but the `Pause Panel` won’t fade out the way it is supposed
    to. This is because the following line of code stops all animations from happening
    that depend on time scale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That line of code was used to effectively pause the game. However, that means
    it’s pausing our `Pause Panel` pop-up animation. Don’t worry, you can still use
    this simple pause code and run animations when the game is paused. All you have
    to do is tell the Animator on the `Pause Panel` that it can still function when
    the time scale is set to `0`. You do this by changing the **Update Mode** on the
    Animator component from **Normal** to **Unscaled Time**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.42: Setting Update Mode to Unscaled Time](img/Figure_14.42_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.42: Setting Update Mode to Unscaled Time'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Inventory Panel`’s Animator component as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game, and you should have smoothly animating Pause and Inventory Panels.
    We can now move on to a more complex animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a complex loot box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we’ll work with a new scene. The animation we will create
    is a bit complicated—a chest will fly into the scene and then wait for the player
    to open it. Once the player opens it, the chest will animate open with a particle
    system that pops in front of it. Then, three collectibles will fly out in sequence.
    Each collectible will have its own *shiny* animation that begins to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure is a storyboard of sorts that shows a few keyframes of
    the animation playing out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.43: The final version of the animation from this example](img/Figure_14.43_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.43: The final version of the animation from this example'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover all items except for the Particle System, which
    we will cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The chest sprite sheet was obtained from [https://bayat.itch.io/platform-game-assets](https://bayat.itch.io/platform-game-assets)
    and the item sprite sheets were obtained from [https://opengameart.org/content/shining-coin-shining-health-shining-power-up-sprite-sheets](https://opengameart.org/content/shining-coin-shining-health-shining-power-up-sprite-sheets).
  prefs: []
  type: TYPE_NORMAL
- en: This example has a lot going on with it. It is not particularly complicated
    to build out, but providing the steps to build it entirely from scratch would
    require too many steps. That would go beyond the scope of this book; but at this
    point in the book, you can hopefully look at a scene that’s already been built
    out and understand how it was achieved. Therefore, we will start this example
    with a package file that has all the items placed in the scene, some of the animations
    already created, and all the new sprite sheets included.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, import the `Chapter 14` `- Examples - LootBox - Start.unitypackage`
    asset package.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to view the completed example, view the package labeled `Chapter
    14` `- Examples - LootBox -` `End.unitypackage`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unity Layers do not save in Unity asset packages. The example will describe
    creating a Layer named **UI Particles** and having the cameras ignore or include
    the Layer, but this is not displayed in the provided package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the example easier to absorb, I have broken the steps into three distinct
    sections. To complete this example, we will perform the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the various animation clips for the individual items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tie all the animations together and make sure that they are timed appropriately
    using a state machine, aka Animator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Particle System that displays when the chest opens and make sure
    that it displays properly within the UI (which will be completed in the following
    chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up the animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start this section by creating the animations for each of the objects
    within the scene. To create all the animations for this scene, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not done so already, import `Chapter 14` `- Examples - LootBox
    - Start.unitypackage`. You should see a scene that has two Canvases—one with a
    button and a background image and another with a chest, items, and a button, as
    shown in the following screenshot:![Figure 14.44: The scene layout of the package](img/Figure_14.44_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.44: The scene layout of the package'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After importing the package, you will also note that there are a few animation
    clips and controllers provided in the `Assets` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Chest` object needs two animations, one of it *flying in from the side
    of the screen* and one of its *sprite sheet opening*. Let’s make the flying in
    animation first. Select the `Chest` object in the Hierarchy and then select `ChestFlyingIn.anim`
    and save it in the `Assets/Animations/LootBox/Clips` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new Animation Controller named `Chest.controller` was automatically created
    in the `Assets/Animations/LootBox/Clips` folder. Move it to the `Assets/Animations/LootBox/Controllers`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the Animation window, select `Chest` within the Canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.45: The ChestFlyingIn animation](img/Figure_14.45_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.45: The ChestFlyingIn animation'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the animation is one second long, which is a bit longer than we want.
    Move the second keyframe to the `0:30` mark so that it will be half a second long.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be moving objects in the scene at various keyframes and will want them
    to be saved in the animation. So, to have the animation record any of the changes
    you make in the scene, select the record button in the Animation window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The position of the chest in the scene right now is where we want it to be
    at the end of the fly-in animation, so we will not affect the position at the
    second keyframe. However, we want it to start off screen, so with the animation
    playhead on the first frame, use the `Chest`’s position at the first frame. This
    is indicated by the red tint on the Rect Transform.![Figure 14.46: Moving the
    chest and recording the properties](img/Figure_14.46_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.46: Moving the chest and recording the properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you scrub the playhead, you will see the chest move from left to right.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s make the chest fly in at an arc instead of a straight line. We’ll
    do this with Animation Curves. Select the **Curves** tab, as follows:![Figure
    14.47: Selecting the Curves menu](img/Figure_14.47_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.47: Selecting the Curves menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The green line represents the *y* property of the anchored position. Select
    the **Anchored Postion.y** property to focus on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select the first and second key frame anchors to affect their handles. Move
    their handles until the green curve looks more like an arc:![Figure 14.48: Adjusting
    the anchors of the curve](img/Figure_14.48_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.48: Adjusting the anchors of the curve'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, when you play the animation, you will see the chest move in an arcing path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s have the chest fade in as it flies by adding a `color` property to the
    animation. Return to the `0` to make the chest invisible on the first frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.49: The properties of the first frame of the ChestFlyingIn animation](img/Figure_14.49_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.49: The properties of the first frame of the ChestFlyingIn animation'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a new animation is created, it is automatically set to loop. We don’t
    want this animation to play on a loop, so select the `ChestFlyingIn` Animation
    Clip from the **Project** view to see its **Inspector** properties. Deselect the
    **Loop** **Time** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don’t want the `ChestFlyingIn` Animation Clip to automatically play when
    the scene starts. Since this was the first Animation Clip created for the `Chest`,
    it will be set to the Animator default state. With the `Chest` selected, open
    the Animator Window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new default state by right-clicking within the Animator Window and
    selecting `Empty State` and set it as the default state by right-clicking on it
    and selecting **Set as Layer Default State**. We will do more with the Chest’s
    Animator later, but for now, this is all we are going to do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.50: The Animator of the Chest](img/Figure_14.50_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.50: The Animator of the Chest'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s set up the chest opening animation. With `Chest` still selected,
    in the Animation window, select **Create New Clip…** from the Animation Clip dropdown
    list:![Figure 14.51: Creating a new clip](img/Figure_14.51_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.51: Creating a new clip'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Name the new Animation Clip `ChestOpening.anim` and save it in the `Assets/Animations/LootBox/Clips`
    folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This Animation Clip will contain all the sprites from the sprite sheet. From
    the Project view, drag and drop all the sub-sprites into the Animation timeline.
    A new property for **Image.Sprite** will automatically be added, and all the sub-sprites
    will be added to the timeline in a sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.52: The Chest sprite sheet animation](img/Figure_14.52_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.52: The Chest sprite sheet animation'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the animation is way too fast. It is running at 60 frames per second,
    and there are only 6 frames. We need to change the frame rate. First, we must
    enable the Sample Rate option in the Animation Window. Select the three dots on
    the timeline and then select **Show** **Sample Rate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.53: Enabling the Sample Rate menu item](img/Figure_14.53_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.53: Enabling the Sample Rate menu item'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `12`; this will change the animation’s frame rate to `12` fps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.54: Changing the Sample Rate](img/Figure_14.54_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.54: Changing the Sample Rate'
  prefs: []
  type: TYPE_NORMAL
- en: Since `Chest` has an animation that will affect its alpha value, let’s ensure
    that this animation has full alpha whenever it plays. Select `1` on both the first
    and last frames.¶Technically, we only need the alpha set to `1` on the first frame,
    but I like to add a start and end frame here so that I am very sure about what
    the animation is doing with that value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don’t want this animation to play on a loop, so select the `ChestOpening`
    Animation Clip from the **Project** view to take a look at its **Inspector** properties.
    Deselect the **Loop** **Time** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the other animations needed for this example have already been set up.
    They are very similar to this one in setup or the ones created in the preceding
    example. However, they are not hooked up to the correct GameObjects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s give the other objects in `Chest Open Canvas` their animations. Drag the
    `Coin` Animator to the Inspector of the `Coin` GameObject, the `Heart` Animator
    to the Inspector of the `Heart` GameObject, and the `PowerUp` Animator to the
    `PowerUp` GameObject’s Inspector. Each of these Animators can be found in the
    `Assets/Animations/Loot Box/Controllers` folder. You can now preview the animations
    of all the items popping out of the chests and shining by selecting the GameObjects
    and pressing play in the Animation window (Play in the Game view will not yet
    show the animations playing).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s initialize the `Chest` and all of the objects as invisible. Select the
    `Chest`, `Coin`, `Heart`, and `PowerUp` GameObjects from the Hierarchy. In their
    Image component, change the alpha values of their `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Chest Open Canvas` and the `Button` on that Canvas both have animations
    as well. These animations will affect a Canvas Group component on the objects.
    Right now, they don’t have Canvas Group components, though. So, add a Canvas Group
    component to `Chest Open Canvas` and its child `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the two new Canvas Group components to have `0` and their `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now only see the Start Button in the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, add the `CanvasGroupFadeInOut` Animator to `Chest Open Canvas` and its
    child `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animations are now completely set up for each of the objects. We still need
    to finish working on the Animator Controller for the `Chest` and add some more
    logic for the various Animators, but we are done with the Animation Clips for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Building a State Machine and timing the animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing to do is set up our state machine and write the code that will
    make the various animations play.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hook up the various animations and have them play at the correct time, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating the state machine that will work as the logic for our
    animation sequences. Create a new Animator Controller named `ChestOpeningStateMachine.controller`
    in `Assets/Animations/Loot Box/Controllers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `ChestOpeningStateMachine` Animator Controller and create 12 new Empty
    States. Arrange, name, and transition the States, as shown in the following screenshot:![Figure
    14.55: The State Machine for the Animation](img/Figure_14.55_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.55: The State Machine for the Animation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The state machine shown in the preceding screenshot demonstrates the sequence
    of events for the animations and interactions of the chest opening. The states
    labeled **Waiting On Player** will *play* when the game is waiting for the player
    to press a button to proceed with the animation. The other animations will automatically
    play based on timed events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The state machine created in the previous steps will not actually contain any
    animations. It is simply a flow chart describing what is currently happening in
    the game. We will also use it to send information to the various objects in the
    scene to let them know what they should or should not be doing. Since we just
    want this to control the logic of this sequence, and not actually animate anything
    in the scene, we can add it on an Animator component to any object in the scene.
    Therefore, let’s add it to the `Main Camera`. Drag the `ChestOpeningStateMachine`
    Animator from the project view to the Inspector of the `Main Camera`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will need to set the conditions of transition for the various states
    within the state machine. Create four animation Trigger Parameters, named `ShowChest`,
    `OpenChest`, `CloseChest`, and `AnimationComplete`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, set Trigger Conditions for each transition, as shown in the following
    screenshot; with each transition, make sure that you deselect **Has Exit Time**
    and **Fixed Duration**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.56: The triggers for the various transitions](img/Figure_14.56_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.56: The triggers for the various transitions'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend that you bookmark this image or print out a screenshot of
    your **ChestOpeningStateMachine** Animator while working through this example.
    Having this as a flow chart that you can easily reference while working on this
    example will make the steps being completed a lot easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write code, let’s set up the Animator for the `Chest`. Currently,
    the Animator of the `Chest` should look something as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.57: The Chest Animator](img/Figure_14.57_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.57: The Chest Animator'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Animator only contains the animation states but does not yet indicate how
    they are all connected. We will need to create transitions and set up the Animation
    Parameters. Rearrange the states and add transitions to the Animator so it appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.58: The Chest Animator updated](img/Figure_14.58_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.58: The Chest Animator updated'
  prefs: []
  type: TYPE_NORMAL
- en: Create three animation Trigger Parameters, named `ShowChest`, `OpenChest`, and
    `Reset`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, set Trigger Conditions for each transition, as shown in the following
    screenshot; with each transition, make sure that you deselect **Has Exit Time**
    and **Fixed Duration**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.59: The Triggers of the Chest Animator](img/Figure_14.59_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.59: The Triggers of the Chest Animator'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our Animators are all appropriately set, we can begin coding. We will
    use the `ChestOpeningStateMachine` Animator to make each appropriate animation
    play when the player clicks on the specified button during the specified state.
    The `ChestOpeningStateMachine` Animator will then automatically set the appropriate
    triggers on the Animators on the various objects that appear in the full animated
    sequence. We need a way to keep track of which items in the scene have Animators
    that will be controlled by the `ChestOpeningStateMachine` Animator, what their
    various parameters are, and what conditions need to be met to have those parameters
    set. We’ll keep track of all of this information in a single script. Create a
    new script called `ChestAnimControls` and save it in `Assets/Scripts/LootBox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To give us a nice, clean way of keeping track of all of the necessary information,
    we’ll use classes and an enumerated list (I’ll explain what these are and why
    we are using them momentarily). Delete the `Start()` and `Update()` functions
    from the `ChestAnimControls` class, and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll note that the preceding code has the following three parts: the `TypesOfParameters`
    enumerated, the `ParameterProperties` class, and the `AnimatorProperties` class.
    First, let’s look at the `TypesOfParameters` enumerated. This is a list of the
    types of Animator Parameters that can be used within an Animator. An enumerated
    list is a custom type that contains a set of constants that are represented with
    names. A benefit of using an enumerated list is that the list appears as a dropdown
    menu within the Inspector. Now, let’s look at the `ParameterProperties` class.
    Each object that is animated within the scene has a set of properties related
    to its Animator Parameters that we need to keep track of. A class can be an effective
    tool for grouping sets of data together. Therefore, I used a class to group the
    name of the parameter, which state the parameter will be set in, what type of
    parameter it is, and its value if it is a `float`, `integer`, or `Boolean` parameter.
    Note that the type of parameter is defined using the enumerated list, `TypesOfParameters`.
    This was done because there is a finite and specific set of parameters available
    for each animator parameter. Now, let’s look at the `AnimatorProperties` subclass.
    For each object in the scene, we will need to keep track of its name, its animator,
    and all of its parameters along with the conditions in which they are set. Note
    that the list of parameters and their properties is defined by the `ParameterProperties`
    class. A big benefit of working with Unity is the ability to assign and view public
    variables in the Inspector. However, when you create a class within a class, the
    public variables are not visible within the Inspector unless you place `[System.Serializable]`
    above the class. This gives the subclass the `Serializable` attribute and allows
    its public variables to be visible in the Inspector.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I would like to point out that this code allows for the Animators to have **Float**,
    **Int**, and **Bool** parameters, even though the only parameters we use in any
    of our Animators are Triggers. I wrote it in this way to make it work more universally
    so that you can reuse this code for other animations in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find the code we wrote in the preceding step overwhelming, don’t worry—seeing
    it all listed out in the Inspector will clear it up a bit. All we have done so
    far is set up a few different groups of data. Now, we will need to create a variable
    that will use the information. We need a list of all animated items, so add the
    following code to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Attach the `ChestAnimControls` script to the `Main Camera` by dragging it into
    its Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Inspector of the `Main Camera`, click on the arrow next to **Animated
    Items** to expand the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.60: The Chest Anim Controls component](img/Figure_14.60_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.60: The Chest Anim Controls component'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a total of six items that need to have their Animators controlled by
    this script and the State Machine we created. So, change the List’s size to `6`.
    Expand **Animator Items** | **Element 0** and its **Animator Parameters**:![Figure
    14.61: The AnimatorProperties of the Chest Anim Controls](img/Figure_14.61_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.61: The AnimatorProperties of the Chest Anim Controls'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that the `animatedItems` variable was a list of `AnimatorProperties`.
    So, `AnimatorProperties` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first item we will need to list data for is the `Chest Open Canvas` GameObject.
    Type `Chest Open Canvas` in the `Chest Open Canvas` from the Hierarchy into the
    `Chest Open Canvas` in the **Name** slot, you’ll see that the **Element 0** label
    is replaced with **Chest Open Canvas**. Whenever you have a list of objects in
    Unity’s Inspector, if the first item in the object is a string, the string will
    replace the **Element** **x** label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.62: The Chest Open Canvas properties](img/Figure_14.62_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.62: The Chest Open Canvas properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to list out all the parameters that are used within `Chest
    Open Canvas`’s Animator and the conditions under which it is set. It has two parameters
    that we need to list data for, so change the size of `2`. Expand the two resulting
    **Elements**, as follows:![Figure 14.63: The ParameterProperties and TypesOfParameters](img/Figure_14.63_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.63: The ParameterProperties and TypesOfParameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that the `animatorParameters` variable was a list of `ParameterProperties`.
    So, the two `ParameterProperties` class. Additionally, within the `ParameterProperties`
    class, `parameterType` was a `TypesOfParameters` variable. `TypesOfParameters`
    was an enumerated list, so any variable of that type will appear as a dropdown
    menu with the options that appeared within the defined list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now need to list out each Parameter of the `Chest Open Canvas`, `ChestOpeningStateMachine`
    will cause the Parameter to be set, and specify its **Parameter Type**:![Figure
    14.64: The Chest Open Canvas properties](img/Figure_14.64_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14.64: The Chest Open Canvas properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since each is a Trigger Animator Parameter, we do not have to worry about the
    values for **Float Value**, **Int Value**, or **Bool Value**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can fill in the Animator information for the other five animated objects
    in the same way we filled out the information for the `Chest Open Canvas`. Fill
    in the information for the animator of `Chest` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.65: The Chest properties](img/Figure_14.65_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.65: The Chest properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the information for the Animator of `Coin` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.66: The Coin properties](img/Figure_14.66_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.66: The Coin properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the information for the Animator of `Heart` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.67: The Heart properties](img/Figure_14.67_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.67: The Heart properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the information for the Animator of `PowerUp` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.68: The PowerUp properties](img/Figure_14.68_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.68: The PowerUp properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the information for the Animator of `Button` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.69: The Button properties](img/Figure_14.69_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.69: The Button properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the appropriate data values for the State Machine initialized
    and defined, let’s actually have the State Machine perform its appropriate logic.
    First, we will need to create a variable for the Animator. Add the following variable
    initialization to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, initialize the State Machine’s Animator in an `Awake()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To have the State Machine automatically set the various parameters of the individual
    Animators at the appropriate state, we will need to loop through all of the animated
    items we have listed and each of their listed parameters. If the animated item
    has a parameter, which is to be set at the current state of the State Machine,
    we will set it based on the conditions listed. Create the following function to
    perform that functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CheckForParameterSet` function will determine whether a specified Animator
    needs a parameter set at the current state of the State Machine. However, this
    function is not currently called anywhere. We want this function to be called
    whenever a state in the State machine starts. We can accomplish this with a State
    Machine Behaviour. Open the `ChestOpeningStateMachine` Animator and select the
    `ChestStateMachineBehaviour`, and click on the `ChestStateMachineBehaviour` will
    be added to the `Assets` folder. Move it to the `Assets/Scripts/LootBox` folder
    and open it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A lot of stuff is included within this State Machine Behaviour. We only need
    the `OnStateEnter` function. Adjust the code within the `ChestStateMachineBehaviour`
    class to include the following to call the `CheckForParameterSet` function on
    the `ChestAnimControls` script when it starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will need this script on every state that does not say `ChestStateMachineBehaviour`
    to each of the states in the right-hand column (the ones that do not say `ChestStateMachineBehaviour`
    in their Inspector. The State Machine will now appropriately call each of the
    individual items’ animations when the appropriate states are entered, but we don’t
    have anything that actually controls the flow of the state machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right now, it is going to just stay in the `Button` that is on the `Button
    Canvas` that says `ChestAnimControls.cs` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will trigger the State Machine’s trigger parameter specified by
    the string sent as an argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will need to call that function from the `Button` on the `Button Canvas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.70: The On Click() event of the Button](img/Figure_14.70_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.70: The On Click() event of the Button'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will need to create some logic that will have the `Button` on `Chest
    Open Canvas` transition from the other two `OpenCloseButton.cs` in the `Assets/Scripts/LootBox`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UnityEngine.UI` namespace to the `OpenCloseButton` script with the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code to the `OpenCloseButton` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `OpenOrClose()` function will be called by the button›s `Button` on the
    `Chest Open Canvas` will be used to open and close the chest. It will set the
    appropriate trigger based on the current text written on the button and will change
    its text to `"Open"` or `"Close"` with the `SetText()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the `OpenCloseButton` script as a component to the `Button` on `Chest` `Open
    Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following `Button` on `Chest` `Open Canvas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.71: The On Click() property of the Button](img/Figure_14.71_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.71: The On Click() property of the Button'
  prefs: []
  type: TYPE_NORMAL
- en: If you play the game now and click on the `AnimationComplete` trigger in the
    `ChestOpeningStateMachine` Animator. We will need another script to set this trigger.
    Create a new script called `AnimationControls` in the `Assets/Scripts/LootBox`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the code within the `AnimationControls` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code simply sets the `AnimationComplete` trigger with the `ProceedStateMachine()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This trigger is used to allow each of the individual animations to fully play
    before the next state is started. To make sure that the animation trigger isn’t
    set until the entire animation has played, we’ll use Animation Events to call
    the `ProceedStateMachine()` function at the appropriate time within the necessary
    animations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you use an Animation Event, the function you want to call must be on a
    script attached to the same object as the animation. We want the function to be
    called at the end of animations on `Chest Open Canvas`, `Chest`, `Coin`, `Heart`,
    `PowerUp`, and the `Button` on `Chest Open Canvas`. Therefore, add the `AnimationControls`
    script as a component to each of them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will need to add the `ProceedStateMachine()` function as an Animation
    Event to the various animations. Select `Chest Open Canvas` and view its `CanvasGroupFadeIn`
    animation. On its last animation frame, right-click on the top dark gray area
    of the timeline and select `ProceedStateMachine()` from the dropdown menu. It
    will be the very last function in the list. You should now have a white flag above
    the last keyframe that says **ProceedStateMachine** when you hover over it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.72: Adding the ProceedStateMachine Event to the animation](img/Figure_14.72_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.72: Adding the ProceedStateMachine Event to the animation'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play the game now and click on the `ChestFlyingIn` animation. To have
    the animation sequence finish out, add the `ProceedStateMachine()` function as
    an Animation Event to each of the following animations: `ChestFlyingIn`, `ChestOpening`,
    `CoinPopping`, `HeartPopping`, and `PowerUpPop`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Playing the game now almost works the way it should. There’s a bit of an issue
    with the timing of the items popping out of the chest when you replay the animation
    sequence. Currently, there is a bit of a problem with the `AnimationComplete`
    trigger. We need that trigger to definitely be unset whenever any of the `true`
    when the State Machine restarts, causing some timing issues. To fix this, we need
    one more State Machine Behaviour. Select the `ResetTriggers` in its Inspector.
    Remember that whenever you create a new State Machine Behaviour, it is added to
    the `Asset` folder, so move it to the `Asset/Scripts/LootBox` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want the `AnimationComplete` Trigger Parameter to reset whenever a `ResetTriggers`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, add the `ResetTriggers` State Machine Behaviour to all three of the **Waiting
    on** **Player** states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Playing the game now should have the animation sequence firing correctly, with
    everything but the particle system, which will be covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating UI elements is not significantly different from animating any other
    2D object in Unity. Therefore, this chapter offered a brief overview of animation.
    This chapter also offered an example of the workflow for creating complex animations
    utilizing a State Machine and Animation Events. There’s a lot we can do with animations,
    and the examples in this chapter showed you many of the techniques you can use
    while animating UI. Hopefully, these examples will provide you with enough variation
    of technique that you can determine how to make your own animations in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to render particle effects in front
    of the UI.
  prefs: []
  type: TYPE_NORMAL
