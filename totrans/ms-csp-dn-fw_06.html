<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;SQL Database Programming" id="aid-10DJ41"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. SQL Database Programming</h1></div></div></div><p>This chapter deals with access to databases built according to the principles of the relational model, which—generally speaking—we refer to as SQL databases due to the language used to manipulate their data. In the next chapter, we will take a look at the emerging noSQL database model.</p><div class="note" title="Note"><h3 class="title"><a id="note19"/>Note</h3><p>Note that we will not go in depth about data access here. This will just be a quick review of the most common possibilities you have in order to access database systems build according to the relational model.</p></div><p>Here, we will quickly review the<a id="id484" class="indexterm"/> rules and foundations of the relational model (schemas, Normal Form Rules, and so on) before getting into SQL Server 2014, the <span class="strong"><strong>database management system</strong></span> (<span class="strong"><strong>DBMS</strong></span>) that I'll use in this chapter. Additionally, we'll go through the process of installing SQL Server 2014 Express Edition (totally free) along with some sample databases that will help us with the demos.</p><p>In this section, we will also cover a not-so-common type of project that Visual Studio offers to deal with databases, the SQL Server Project Template, and explore how we can configure many aspects of the target database that our application uses straight from Visual Studio. We will even be able to save all this configuration in a <code class="literal">.dacpac</code> file, which can be later replicated in any other machine.</p><p>Then, we'll cover the basic .NET Framework database engines recommended for data management. We'll start with a reminder of the initial engine that appeared with version 1.0 (ADO.NET), passing from there to the Entity Framework model (the most common and the one recommended by Microsoft), which is already in its version 6.1 (although the new version aligns with the .NET Core wave, and it has been published under the name Entity Framework 1.1 recently).</p><p>We'll discover how to build an ORM data schema from one of the demo databases and how to query and manipulate data with EF and some of the new possibilities that these versions offer to the programmer.</p><p>Overall, we'll cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A refresher view of the Database Relational Model</li><li class="listitem">The SQL Server 2014 Database system, installation, and features</li><li class="listitem">The SQL Server Project template in Visual Studio</li><li class="listitem">Basic data access from ADO.NET</li><li class="listitem">Basic data access with Entity Framework 6.0 using the Database-first <span class="emphasis"><em>flavor</em></span> as used with an ASP.NET MVC application</li></ul></div><div class="section" title="The relational model"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>The relational model</h1></div></div></div><p>Up until 1970, data access<a id="id485" class="indexterm"/> was diverse in nature and management. No standard or common approaches were available, and the term used to refer to what we now understand as databases was data banks, but their structures were quite different.</p><p>Of course, there were other models, such as the hierarchical model and the network model, but their specifications were somewhat informal.</p><p>In 1969 and the following years, an engineer at IBM (E.F. Codd) started publishing a series of papers in which he established the foundations of what we now understand as the relational model; especially, his paper, <span class="emphasis"><em>The relational model for database management</em></span>, is now considered the RM manifesto. In this model, all data is represented in terms of tuples, and these tuples are grouped into relations. As a result, a database organized in terms of the relational model is called a relational database.</p><div class="section" title="Properties of relational tables"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec65"/>Properties of relational tables</h2></div></div></div><p>The following <a id="id486" class="indexterm"/>are the properties of relational tables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">All data is offered in terms of collections of relations.</li><li class="listitem">Each relation is described as a table. A table is composed of columns and rows.</li><li class="listitem">Columns are attributes of the entity, modeled by the table's definition (in a customer table, you could have <code class="literal">customerID</code>, <code class="literal">e-mail</code>, <code class="literal">account</code>, and so on).</li><li class="listitem">Each row (or tuple) represents a single entity (that is, in a customer table, <code class="literal">1234</code>, <code class="literal">thecustomer@site.com</code>, <code class="literal">1234</code>, <code class="literal">5678</code>, and so on, would denote a row with a single customer).</li><li class="listitem">Every table has a set of attributes (one or more) that can be taken as a key, which uniquely identifies each entity (in the customer table, customer ID would specify only one customer, and this value should be unique in the table).</li></ul></div><p>Many types of keys offer several possibilities, but the two most important are the primary key and the foreign key. While the former identifies tuples uniquely, the latter sits at another table, allowing the establishment of relations between tables. It is in this way that we can query data that relates to two or more tables based on a common field (this field does not have to be named as the other with which we will match; it only has to be of the same data type).</p><p>The relational model is based on Relational Algebra (also described by E.F. Codd, who proposed this algebra as a basis for database query languages, and thus the relation with set theory). This<a id="id487" class="indexterm"/> algebra uses a set union, set difference, and Cartesian product from a set theory and adds additional constraints to these operators, such as <code class="literal">select</code>, <code class="literal">project</code>, and <code class="literal">join</code>.</p><p>These operations have a direct correspondence in the SQL Language, which is used to manipulate data, and basically, we find the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Select</strong></span>: It recovers values<a id="id488" class="indexterm"/> for rows in a table (optionally, with a given criteria)</li><li class="listitem"><span class="strong"><strong>Project</strong></span>: It reads values <a id="id489" class="indexterm"/>for select attributes</li><li class="listitem"><span class="strong"><strong>Join</strong></span>: It combines<a id="id490" class="indexterm"/> information from two or more tables (or only one, taken as a second table)</li><li class="listitem"><span class="strong"><strong>Intersect</strong></span>: It shows<a id="id491" class="indexterm"/> rows present in two tables</li><li class="listitem"><span class="strong"><strong>Union</strong></span>: It shows rows<a id="id492" class="indexterm"/> from multiple tables and removes the duplicate rows</li><li class="listitem"><span class="strong"><strong>Difference</strong></span>: It recovers<a id="id493" class="indexterm"/> rows in one table that are not found in another table</li><li class="listitem"><span class="strong"><strong>Product</strong></span>: The cartesian<a id="id494" class="indexterm"/> product combines all rows from two or more tables and is normally used with filter clauses and foreign key relations</li></ul></div><p>Another important aspect of the relational model is that ensures data integrity by means of a set of rules. Mainly, there are five rules that have to be considered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The order of tuples and/or attributes doesn't matter: If you have the ID before e-mail, it is the same as the e-mail before the ID).</li><li class="listitem">Every tuple is unique. For every tuple in a table, there is a combination of values that uniquely identifies it.</li><li class="listitem">Every field contains only single values. Or, if you want, each of the table's cells should only hold one value. This is derived from the First Normal Form; we'll come to that later.</li><li class="listitem">All values within an attribute (think of it as a column) are from the same domain. That is, only values allowed by the attribute's definition are allowed, either number, characters, dates, and so on. Their practical implementation will depend on the type definitions permitted by the database engine.</li><li class="listitem">Identifiers of tables must be unique in a single database, and the same goes for columns in tables.</li></ul></div><p>The principles and rules mentioned hereby are formalized by the Normal Form Rules (generally called <span class="strong"><strong>Normalization</strong></span>). They<a id="id495" class="indexterm"/> establish a number of rules to reinforce data integrity. However, in practice, only the three first rules (1NF, 2NF, and 3NF) are applied in everyday business and even the third one admits a <span class="emphasis"><em>de-normalization</em></span> process in order to avoid unnecessary complexities in design on some occasions.</p><p>In a very succinct<a id="id496" class="indexterm"/> way, these are the requirements of the three normative Normal Forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>1NF</strong></span>: It eliminates <a id="id497" class="indexterm"/>duplicative columns from the same table. That is, create separate tables for each group of related data and identify each row with a primary key.</li><li class="listitem"><span class="strong"><strong>2NF</strong></span>: It eliminates subsets<a id="id498" class="indexterm"/> of data that apply to more than one row of a table, and creates a new table with them. Later, you can create foreign keys to maintain relationships between the tables.</li><li class="listitem"><span class="strong"><strong>3NF</strong></span>: It deletes all columns that are<a id="id499" class="indexterm"/> not dependent upon the primary key.</li></ul></div><p>With these normal forms, our data integrity is guaranteed in 99% of the cases, and we can exploit our bank of data using SQL in a very efficient way. Keep in mind that those keys that uniquely identify each table's rows allow the creation of indexes, which are additional files intended to speed up and ease data recovery.</p><p>In the case of SQL Server (and other DBMS), two types of indexes are allowed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Clustered indexes</strong></span>: They can be only one per table. They are extremely fast data structures that should be <a id="id500" class="indexterm"/>based on a short-length field(s) and preferably over a field(s) that don't change, such as customer ID in the example we mentioned earlier.</li><li class="listitem"><span class="strong"><strong>Non-clustered indexes</strong></span>: We can define<a id="id501" class="indexterm"/> several per table and allow improvements in speed, especially in reading, joining, and filtering operations. It is recommended that the candidate fields be those that appear in <code class="literal">WHERE</code> and <code class="literal">JOIN</code> clauses, preferably.</li></ul></div></div></div></div>
<div class="section" title="The tools &#x2013; SQL Server 2014"><div class="titlepage" id="aid-11C3M2"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>The tools – SQL Server 2014</h1></div></div></div><p>In this chapter, I'm using SQL Server 2014 Express Edition, which is free to install and includes an optional installation of <a id="id502" class="indexterm"/>
<span class="strong"><strong>SQL Server Management Studio</strong></span> (<span class="strong"><strong>SSMS</strong></span>), the visual tool that allows the user to manage<a id="id503" class="indexterm"/> all objects inside the DBMS, but you can also use the 2016 version, which holds identical (an extended) features.</p><p>You can find them at <a class="ulink" href="https://www.microsoft.com/en-us/download/details.aspx?id=42299">https://www.microsoft.com/en-us/download/details.aspx?id=42299</a>, and once they're installed, you'll see a new entry in your system's menu, including<a id="id504" class="indexterm"/> several tools related to this product. With SSMS ready, you should download and install some sample databases. I recommend Adventure Works 2014, which includes enough data to go ahead with the majority of typical situations you need to test in everyday programming.</p><p>There's a version<a id="id505" class="indexterm"/> available at <a class="ulink" href="http://msftdbprodsamples.codeplex.com/Releases">http://msftdbprodsamples.codeplex.com/Releases</a>. Once it's installed, simply open SQL Server Management Studio, and you should end up with an available copy <a id="id506" class="indexterm"/>of this database, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00535.jpeg" alt="The tools – SQL Server 2014"/></div><p style="clear:both; height: 1em;"> </p><p>You will find a bunch of tables organized in schemas (prefixes that denote a common area of data management, such as <span class="strong"><strong>HumanResources</strong></span>, <span class="strong"><strong>Person</strong></span>, or <span class="strong"><strong>Production</strong></span>). If you're not new to SQL Server or you already know other DBMSes, you won't find the usual utilities to create and edit queries or other SQL-related commands strange. They are available via contextual menus when selecting any member of the list presented in SQL Server Explorer. Refer to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00536.jpeg" alt="The tools – SQL Server 2014"/></div><p style="clear:both; height: 1em;"> </p><p>All actions required for standard database management are available from SSMS, so we can always check for results, SQL commands, test execution plans, creating and designing existing or<a id="id507" class="indexterm"/> new databases, establishing security requirements, and creating any other object that your backend business logic needs, with the ability to test it immediately, as you can infer from the previous screenshot.</p><p>Other helpful possibilities are also found in the editors, since—just like happens with Visual Studio—they offer Intellisense on the objects available at any time, editing SQL Server commands, code hints, syntax error suggestions, and much more.</p><p>The programmer's experience is also enhanced with advanced debugging capabilities, which enable debugging within SSMS or even from Visual Studio itself, so you are allowed to enable the <span class="strong"><strong>Remote Debugging</strong></span> options and use breakpoints and all the usual artifacts, as if you were in a C# code debugging session:</p><div class="mediaobject"><img src="../Images/image00537.jpeg" alt="The tools – SQL Server 2014"/></div><p style="clear:both; height: 1em;"> </p><p>Furthermore, you can switch on the <span class="strong"><strong>Activity Monitor</strong></span> window, which will show you a dashboard with <a id="id508" class="indexterm"/>different usage-related statistics for any SQL command launched from the SSMS:</p><div class="mediaobject"><img src="../Images/image00538.jpeg" alt="The tools – SQL Server 2014"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="The SQL language"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>The SQL language</h2></div></div></div><p>Fortunately, the well-established <a id="id509" class="indexterm"/>foundations of the Relational Model converged on the creation of a standard, first published by <span class="strong"><strong>American National Standards</strong></span><a id="id510" class="indexterm"/>
<span class="strong"><strong> Institute</strong></span> (<span class="strong"><strong>ANSI</strong></span>) in 1986, and followed by <span class="strong"><strong>International Organization for Standardization</strong></span> (<span class="strong"><strong>ISO</strong></span>) in<a id="id511" class="indexterm"/> 1987.</p><p>Since then, the standard has been revised periodically to enhance the language with new features. Thus, a revision in 2003 included the XML data types and auto generated values (including identity columns), and this XML support was extended in 2006 in order to cover the import/export of XML data and XQuery features.</p><p>However, as Wikipedia reminds us:</p><div class="blockquote"><blockquote class="blockquote"><p>Despite the existence of such standards, most SQL code is not completely portable among different database systems without adjustments.</p></blockquote></div><p>At least we have a common background that allows us—via these adjustments—to write portable code that executes in diverse RDBMS.</p><p>The version of SQL implemented in <a id="id512" class="indexterm"/>SQL Server is named <span class="strong"><strong>T-SQL</strong></span> (<span class="strong"><strong>Transact-SQL</strong></span>). As Wikipedia reminds:</p><div class="blockquote"><blockquote class="blockquote"><p>T-SQL expands on the SQL standard to include procedural programming, local variables, various support functions for string processing, date processing, mathematics, and so on.</p></blockquote></div><p>Moreover, you <a id="id513" class="indexterm"/>can find changes in the <code class="literal">DELETE</code> and <code class="literal">UPDATE</code> statements.</p><p>With all these additional features Transact-SQL becomes a <span class="emphasis"><em>Turing complete</em></span> language.</p><div class="note" title="Note"><h3 class="title"><a id="tip11"/>Tip</h3><p>Note that in computability theory, a system of data-manipulation rules (such as a computer's instruction set, a programming language, or a cellular automaton) is said to be Turing complete or computationally universal if it can be used to simulate any single-taped Turing machine. Most of the widely accepted programming languages today, such as .NET languages, Java, C, among others, are said to be <a id="id514" class="indexterm"/>Turing complete. (Wikipedia: <a class="ulink" href="https://en.wikipedia.org/wiki/Turing_completeness">https://en.wikipedia.org/wiki/Turing_completeness</a>).</p></div><p>As we said, T-SQL is a very powerful language, allowing variable declarations, flow control, improvements to <code class="literal">DELETE</code> and <code class="literal">UPDATE</code> statements and <code class="literal">TRY/CATCH</code> exception handling, among many others. For a complete<a id="id515" class="indexterm"/> reference of the T-SQL language, go to <span class="emphasis"><em>Transact-SQL Reference (Database Engine)</em></span> at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/bb510741.aspx">https://msdn.microsoft.com/en-us/library/bb510741.aspx</a>, since the details of this languages deserve a book of its own.</p></div><div class="section" title="SQL Server from Visual Studio"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>SQL Server from Visual Studio</h2></div></div></div><p>SQL Server is available in <a id="id516" class="indexterm"/>different forms for a Visual Studio programmer. First, we have a type of project, named <code class="literal">SQL Server Database Project</code>, which you can choose as if it were another common programmable template.</p><p>Just select <span class="strong"><strong>New Project</strong></span> and scroll down to SQL Server. Usually (it might depend on other templates already installed on your machine), you'll find this type of project, and once it's selected, a solution structure will be created.</p><p>Initially, you will find the Solution Explorer pretty empty, and a look at the <span class="strong"><strong>Add New</strong></span> menu will show you the large amount of options that this type of project offers for database manipulation (refer to the following screenshot):</p><div class="mediaobject"><img src="../Images/image00539.jpeg" alt="SQL Server from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, a large amount of different database objects are available in this manner, including most of the internal objects managed by SQL Server, external files, security aspects, CLR integration, and much more.</p><p>The first step would be to select the <span class="strong"><strong>Tools/Connect to Database</strong></span> option in the menu in order to link our project to our already installed <code class="literal">AdventureWorks</code> database. You'll be offered the usual <span class="strong"><strong>Add Connection</strong></span> dialog box, where you can select a database. At this point, a look at the Server Explorer will allow you to query data and other options.</p><p>Note that although<a id="id517" class="indexterm"/> Visual Studio doesn't offer as many options as if you were inside SSMS, the most useful selections for data management appear, including data visualization, so we don't have to open SSMS in many usual scenarios of development.</p><p>You should find a user interface like the one shown in the next capture, when you open AdventureWorks2014 database in this manner (observe that the most important functionality for programmers is provided):</p><div class="mediaobject"><img src="../Images/image00540.jpeg" alt="SQL Server from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>If you enable <span class="strong"><strong>Show all files</strong></span> in the Solution Explorer, you'll discover that after compiling the applications, a number of files appear in the <code class="literal">bin</code> and <code class="literal">obj</code> directories, one of them with the <code class="literal">.dacpac</code> extension.</p><p>These files allow us a bunch of possibilities, as Jamie Thomson points out in the article <span class="emphasis"><em>Dacpac braindump - What is a dacpac?</em></span>, available <a id="id518" class="indexterm"/>at the official SQL Blog (<a class="ulink" href="http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx">http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx</a>):</p><div class="blockquote"><blockquote class="blockquote"><p>In that single file are a collection of definitions of objects that one could find in a SQL Server database such as tables, stored procedures, views plus some instance level objects such as logins too (the complete list of supported objects for SQL Server 2012 can be found at DAC Support For SQL Server Objects and Versions). The fact that a dacpac is a file means you can do anything you could do with any other file, store it, email it, share it on a file server etc… and this means that they are a great way of distributing the definition of many objects (perhaps even an entire database) in a single file. Or, as Microsoft puts it, a self-contained unit of SQL Server database deployment that enables data-tier developers and database administrators to package SQL Server objects into a portable artifact called a DAC package, also known as a DACPAC.</p></blockquote></div><p>Another interesting<a id="id519" class="indexterm"/> feature of these projects can be discovered by navigating to <span class="strong"><strong>Import</strong></span> | <span class="strong"><strong>Database</strong></span> in the project's menu. If you choose this, you'll be offered a dialog box in which you can select three different types of data origins: local, network, and Azure.</p><p>In our case, if we select the local option, we'll be shown a list of all the database instances available (it will depend on our machine's configuration):</p><div class="mediaobject"><img src="../Images/image00541.jpeg" alt="SQL Server from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>Once you're finished with this option, the process of importing data will take place—it might take some time depending on the size, the network speed (for network connections), or the Internet bandwidth (for Azure connections).</p><p>When the process<a id="id520" class="indexterm"/> ends, you'll find a whole set of elements in your project, each of them representing the objects available in the database you connected with: tables, schemas, functions, stored procedures, users, logins, and so on.</p><p>In other words, you'll have a representation, element by element, of the whole database in your project. A look at the files shows you that their content depends on its nature: for stored procedure, you'll be shown the SQL statements required to create and define it, but for a table, you'll be shown the design editor and other editing options to change it from Visual Studio, as shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00542.jpeg" alt="SQL Server from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>Any modification you might make in the design or the definitions of any object in this project will be stored <a id="id521" class="indexterm"/>when compiling the project into the <code class="literal">.dacpac</code> file and can be easily restored or created in a destination DBMS of your choice.</p><p>Note that a <code class="literal">.dacpac</code> file is just a ZIP file, so you can add that extension to the file and inspect its contents, expressed in the XML syntax, which are nothing but the contents of the project you have created. They're only packaged in a special manner: they convey the Open Packaging Convention, a standard format created by Microsoft, to rally these files together in a much lighter fashion.</p><p>This format is now used by a number of applications inside and outside the Microsoft world: AutoDesk, AutoCad, Siemens PLM, MathWorks, and so on.</p><p>So, these types of projects are the perfect complement to a solution that manages databases, and you can include them as part of your deployment process. If you're done with your modifications, you can build the project like you would with any executable.</p><p>Once you have your <a id="id522" class="indexterm"/>project built, you can publish the results in an existing DBMS. To do this, you'll select the <span class="strong"><strong>Publish</strong></span> option, and you'll be required to get the initial data from the <span class="strong"><strong>Publish Configuration</strong></span> dialog box, such as the connection string, database name, and so on.</p><p>Also, this publishing configuration can be saved and stored for later use. The three buttons related to profiles allow you to load already existing profiles, creating a profile from the current configuration and saving the profile with a different name.</p><p>Other interesting options appear, such as editing the database connection string (for example, to replicate it in a different SQL Server instance), and even more detailed information can be established with the <span class="strong"><strong>Advanced</strong></span> button:</p><div class="mediaobject"><img src="../Images/image00543.jpeg" alt="SQL Server from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>The <span class="strong"><strong>Advanced</strong></span> button deserves a look, since every aspect of the final creation in the target will be covered in there. Many of the options relate to the way we want to convert our data in the target DBMS.</p><p>Observe that you have three tabs, allowing the configuration of general aspects of the process, and this includes elements you would like to delete (<span class="strong"><strong>Drop</strong></span>) and that you would like to disregard (<span class="strong"><strong>Ignore</strong></span>). The next screenshot shows this dialog box:</p><div class="mediaobject"><img src="../Images/image00544.jpeg" alt="SQL Server from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>When everything is<a id="id523" class="indexterm"/> fine, the process will start and you'll be able to see the destination of the objects created right from Visual Studio; or, you can open SSMS as usual and inspect the result directly.</p></div></div>
<div class="section" title="Data access in Visual Studio" id="aid-12AK81"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Data access in Visual Studio</h1></div></div></div><p>Using Visual Studio, you can create applications that connect to any kind of data, covering practically any database product or service in any format and anywhere: either from a local machine, LAN server, or located in the cloud.</p><p>The IDE enables<a id="id524" class="indexterm"/> you to explore data sources or create object models to store and manipulate data in the memory, and—of course—establish data-binding techniques in the user interface, no matter what type of UI you want: Console, Windows Forms, Windows Presentation Foundation, websites created with ASP.NET, and so on.</p><p>Besides, Microsoft Azure provides SDKs for .NET, Java, Node.js, PHP, Python, Ruby, mobile apps, and tools in Visual Studio in order to connect to Azure Storage.</p><p>The following table shows you the variety of database connections available in recent versions of the IDE:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th colspan="3" valign="bottom" style="text-align: center">
<p>Microsoft Azure (SQL and NoSQL)</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>SQL Database (Azure)</p>
</td><td valign="top">
<p>Azure Storage (Blobs, Tables, Queues, Files)</p>
</td><td valign="top">
<p>SQL Data Warehouse (Azure)</p>
</td></tr><tr><td valign="top">
<p>SQL Server Stretch Database (Azure)</p>
</td><td valign="top">
<p>StorSimple (Azure)</p>
</td><td valign="top">
<p>DocumentDB (Azure)</p>
</td></tr><tr><td valign="top">
<p>Azure Redis Cache</p>
</td><td valign="top"> </td><td valign="top"> </td></tr><tr><td colspan="3" valign="top" style="text-align: center">
<p>SQL</p>
</td></tr><tr><td valign="top">
<p>SQL Server 2005* - 2016</p>
</td><td valign="top">
<p>MySQL</p>
</td><td valign="top">
<p>Oracle</p>
</td></tr><tr><td valign="top">
<p>Firebird</p>
</td><td valign="top">
<p>PostgreSQL</p>
</td><td valign="top">
<p>SQLite</p>
</td></tr><tr><td colspan="3" valign="top" style="text-align: center">
<p>NoSQL</p>
</td></tr><tr><td valign="top">
<p>MongoDB</p>
</td><td valign="top">
<p>Apache Cassandra</p>
</td><td valign="top">
<p>NDatabase</p>
</td></tr><tr><td valign="top">
<p>OrientDB</p>
</td><td valign="top">
<p>RavenDB</p>
</td><td valign="top">
<p>VelocityDB</p>
</td></tr></tbody></table></div><p>You have more information<a id="id525" class="indexterm"/> about this topic at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx">https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx</a>.</p><p>Apart from these <a id="id526" class="indexterm"/>direct possibilities, there are many other vendors that allow Visual Studio integration via NuGet packages. Some other options are at your disposal as well, when using the <span class="strong"><strong>Extensions and Updates</strong></span>" option of the main <span class="strong"><strong>Tools</strong></span> menu.</p><div class="section" title=".NET data access"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>.NET data access</h2></div></div></div><p>.NET data access—and that includes the<a id="id527" class="indexterm"/> new <span class="strong"><strong>.NET Core</strong></span>—is based on <span class="strong"><strong>ADO.NET</strong></span>, which is <a id="id528" class="indexterm"/>composed of a set of classes that define interfaces to access any kind of data source, both relational and non-relational. The IDE includes a customary number of tools in order to help connect to<a id="id529" class="indexterm"/> databases and create <span class="strong"><strong>ORMs</strong></span> (<span class="strong"><strong>Object Relational Models</strong></span>) that map the objects in the<a id="id530" class="indexterm"/> database to objects in a .NET language world.</p><p>The IDE's options include data manipulation in the memory and presenting data to the user in several user interfaces and dialog boxes, both at development time and runtime.</p><div class="note" title="Note"><h3 class="title"><a id="tip12"/>Tip</h3><p>Note that in order to be consumable in ADO.NET, a database must have either a custom ADO.NET data provider, or it must expose an available ODBC or OLE DB interface. ADO.NET data providers for SQL Server as well as ODBC and OLE DB are offered<a id="id531" class="indexterm"/> by default. However, you can find an exhaustive list of providers at <a class="ulink" href="https://msdn.microsoft.com/en-us/data/dd363565">https://msdn.microsoft.com/en-us/data/dd363565</a>, which includes—but is not limited to—Oracle, MySQL, Sybase, IBM, SQLLite, and others.</p></div><p>Visual Studio has several tools and designers that work with ADO.NET to help you connect to databases, manipulate the data in the memory, and present the data to the user. The official schema of the ADO.NET architecture is exposed in this image of MSDN:</p><div class="mediaobject"><img src="../Images/image00545.jpeg" alt=".NET data access"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, we have two sets of classes in this diagram: those of the .NET Framework data provider we use and those related to the DataSet object, which is an in-memory representation of part (or all) of the data tables, relations, and constraints included in the original database.</p><p>Both sets of classes include data maintenance, although the dataset offers some extra functionalities, useful in many cases, such as batch updates and provider-agnostic data storage. With this functionality, some impossible things are available, such as linking two tables via relationships, independently of the possible diverse origin of those tables (say, an Oracle table, a SQL server table, and a Excel Spreadsheet). Reinforce these relations at execution time, establishing business logic that is quite complex to code otherwise.</p></div><div class="section" title="Using ADO.NET basic objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Using ADO.NET basic objects</h2></div></div></div><p>Let's create a new <a id="id532" class="indexterm"/>WPF project, which we will use to read some data from our database and present it in a data grid inside a WPF window.</p><p>Once we've created the<a id="id533" class="indexterm"/> basic project, let's add a new dataset. To do this, just select <span class="strong"><strong>Add New</strong></span> in project's options, and you'll be presented with a blank design surface, in which you can drag and drop any table of the list of tables you'll see in the Solution Explorer pointing to the <code class="literal">AdventureWorks</code> database. After choosing the <span class="strong"><strong>Person</strong></span> table, you can add <span class="strong"><strong>Code Map</strong></span>, selecting that option in the Solution Explorer's top icons. You'll have two windows as a result: one showing the data structure and another with the code schema, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00546.jpeg" alt="Using ADO.NET basic objects"/></div><p style="clear:both; height: 1em;"> </p><p>You can see that<a id="id534" class="indexterm"/> a new set of nested<a id="id535" class="indexterm"/> files has been created in your solution, showing several files that hold the class definitions related to the connection and the relational mapping I mentioned earlier:</p><div class="mediaobject"><img src="../Images/image00547.jpeg" alt="Using ADO.NET basic objects"/></div><p style="clear:both; height: 1em;"> </p><p>A look at the contents of the C# files generated will show a large number of functionalities that provide the majority of resources we need for CRUD operations, Stored Procedures calls, connection<a id="id536" class="indexterm"/> management, searches, and much more.</p><div class="section" title="Configuring the user interface"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec45"/>Configuring the user interface</h3></div></div></div><p>We can add a<a id="id537" class="indexterm"/> new <code class="literal">DataGrid</code> object to our empty window, to be later populated with the data we read.</p><p>The first step to get the data directly when the window shows up is adding a <code class="literal">Loaded</code> event declared in the XAML editor at the end of the <code class="literal">&lt;window&gt;</code> declaration:</p><div class="informalexample"><pre class="programlisting">&lt;Window 
  
  
  
  
   x:Class="WpfData1.MainWindow" mc:Ignorable="d" Loaded="Window_Loaded" Title="MainWindow" Height="350" Width="622"&gt;</pre></div><p>This declaration, in the C# code, has created a <code class="literal">window_load</code> event handler. Next, we can use the <code class="literal">PersonTableAdapter</code> object created when defining our model in very simple way to load and bind data to our DataGrid object:</p><div class="informalexample"><pre class="programlisting">private void Window_Loaded(object sender, RoutedEventArgs e)
{
  var pta = new PersonTableAdapter();
  dataGrid.ItemsSource = pta.GetData().DefaultView;
}</pre></div><p>Here, the <code class="literal">PersonTableAdapter</code> code takes care of establishing a connection to the database, loading the data previously defined in its internal <code class="literal">SQLCommand</code> object and returning a <code class="literal">DataView</code> object suitable to be assigned to DataGrid for the automatic creation of columns (as many as the table has), as shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00548.jpeg" alt="Configuring the user interface"/></div><p style="clear:both; height: 1em;"> </p><p>By the way, the black toolbar on top of the data grid's header is a debugging option offered by Visual Studio that shows/hides layout adorners, enables/disables selection, and—optionally—takes you to a new window, Visual Tree, where you can inspect all elements in the XAML user interface and check their dependencies and values at runtime, as indicated in the arrow pointing to <span class="strong"><strong>LastName</strong></span> <code class="literal">Miller</code> in the list.</p><p>If you take a look <a id="id538" class="indexterm"/>at the properties of the TableAdapter and DataSet objects, you'll discover a very rich set of objects prepared for all sorts of data manipulation.</p><p>This was just a simple demo to check how easy it is to read data using ADO.NET if you use the ORM objects created for us by Visual Studio. However, ADO.NET is not the technology most commonly used these days, since other options are preferred when accessing relational databases, especially Entity Framework.</p></div></div></div>
<div class="section" title="The Entity Framework data model"><div class="titlepage" id="aid-1394Q2"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>The Entity Framework data model</h1></div></div></div><p>Entity Framework, in the words of Microsoft, is as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Entity Framework</strong></span> (<span class="strong"><strong>EF</strong></span>) is an object-relational mapping technology that enables .NET developers to <a id="id539" class="indexterm"/>work with relational data using domain-specific objects. It eliminates the need for most of the data-access code that developers usually need to write. Entity Framework is the Microsoft's recommended ORM modeling technology for new .NET applications.</p></blockquote></div><div class="note" title="Note"><h3 class="title"><a id="note20"/>Note</h3><p>You can find a nice, although basic, introductory video about Entity Framework at <a class="ulink" href="https://msdn.microsoft.com/en-us/data/ef.aspx">https://msdn.microsoft.com/en-us/data/ef.aspx</a>.</p></div><p>As mentioned earlier, <a id="id540" class="indexterm"/>the latest version is .NET Core 1.1, and it's still in the adoption phase by the community, so we're using version 6.0 here, which is totally stable and widely tested. In this version, you have three initial choices: starting with an existing database, starting with an empty model, or starting with already existing code.</p><p>In the first case, called Database First, a connection is established to the DBMS to read metadata from the server <a id="id541" class="indexterm"/>and create a visual model of the selected objects. From that model, a set of classes is generated, which includes a wide range of CRUD and search operations by default.</p><p>Similar to this is the behavior of the <span class="strong"><strong>Model First</strong></span> option, in which you start from scratch, design a model in the graphical editor, and the classes' generations process follows. Optionally, you can generate the real database in the RDBMS depending on the connection string. In either case, you can automatically update your model when the underlying database changes, and the related code will be automatically generated as well. Both database generation and object-layer code generation are highly customizable.</p><p>In the third option, <span class="strong"><strong>Code First</strong></span>, you start from some existing code and a heuristic process takes place in order to infer the corresponding model from that code, the rest of the options being similar to the other two scenarios.</p><p>For a deeper<a id="id542" class="indexterm"/> approach at Entity Framework, I recommend <span class="emphasis"><em>Mastering Entity Framework</em></span>, <span class="emphasis"><em>Rahul Rajat Singh</em></span>, Packt Publishing (<a class="ulink" href="https://www.packtpub.com/application-development/mastering-entity-framework">https://www.packtpub.com/application-development/mastering-entity-framework</a>).</p><p>For the purpose of the next demo, I'm using the Database First approach in order to show the most common operations with Entity Framework but changing the project type to be an ASP.NET MVC application this time, where the code used for data access should be totally independent from the IU that consumes the data.</p><p>So, let's create a new ASP.NET application by selecting that option in the available projects. We will be offered several types of project variations depending on the version and project architecture:</p><div class="mediaobject"><img src="../Images/image00549.jpeg" alt="The Entity Framework data model"/></div><p style="clear:both; height: 1em;"> </p><p>I selected the <span class="strong"><strong>No Authentication</strong></span> feature in <span class="strong"><strong>Change Authentication</strong></span> in order to avoid the automatic creation of a database. When clicking on <span class="strong"><strong>OK</strong></span>, a new project will be generated (using the techniques we saw in previous chapter), and we'll end up with a basic, but functional, project with no data access.</p><p>At this point, the <code class="literal">Models</code> folder should be empty. So, right-click on that folder, select <span class="strong"><strong>Add New</strong></span>, and in the <span class="strong"><strong>Data</strong></span> menu, choose <span class="strong"><strong>ADO.NET Entity Data Model</strong></span>. I'll name mine <code class="literal">AWModel</code> and proceed. At this point, you have to select the type of designer to use, which determines the model's contents. I've selected <span class="strong"><strong>EF Designer from Database</strong></span>.</p><p>Now, it's time to <a id="id543" class="indexterm"/>select the connection. The last one used will be presented by default, and the dialog box will generate a connection string in RichTextBox at the bottom. In case AdventureWorks doesn't show up, manually select the connection to be used.</p><p>Then, it's time to pick up which tables you want to work with, along with other objects, such as views and stored procedures. All of them will be used to generate the model.</p><p>For this demo, I selected one table with a few columns to facilitate code reading, so I opted for <code class="literal">HumanResources.Department</code> with just four fields:</p><div class="mediaobject"><img src="../Images/image00550.jpeg" alt="The Entity Framework data model"/></div><p style="clear:both; height: 1em;"> </p><p>A simple schema should appear in the <span class="strong"><strong>Design</strong></span> window and its properties, detailed in a bottom window called <span class="strong"><strong>Mapping Details</strong></span>, which specifies how the original data types and restrictions defined in the database are modeled into the C# language, to be managed by Entity Framework classes.</p><p>This is important, since it <a id="id544" class="indexterm"/>allows you to specify exactly how you want EF Generators to behave when creating the actual code.</p><p>There's another important feature to remember here. More often that not, changes happen in the original database, and that includes column reformatting or changing datatypes, adding (or deleting) tables, changing relations, and so on.</p><p>In these cases, the contextual <span class="strong"><strong>Update Model from Database</strong></span> option comes in handy. The entire model will be reread, and the corresponding changes will be updated, both in the <span class="strong"><strong>Mapping Details</strong></span> section and the generated code, which will be regenerated:</p><div class="mediaobject"><img src="../Images/image00551.jpeg" alt="The Entity Framework data model"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we need to understand how to modify code generation. This is done by means of the T4 templates, which are text files with the <code class="literal">.tt</code> extension, which you'll find within the files generated in the process, linked to the model's files.</p><p>The reason to include these files is double: they allow the user to decide the way the code is generated, and they facilitate the creation itself (remember that Visual Studio uses CodeDOM internally among other techniques to generate code).</p><p>Take a look at the <a id="id545" class="indexterm"/>classes generated and you'll learn how the <code class="literal">Department</code> class has been created, along with an <code class="literal">AdventureWorks2014Entities</code> class, which will be the starting point for data manipulation.</p><p>Well, now we need controllers and views to present the user with the typical CRUD options for data manipulation. Once again, the IDE comes to help. Select <span class="strong"><strong>Add Controller</strong></span>, and a dialog box will appear to select the type of controllers available.</p><div class="note" title="Note"><h3 class="title"><a id="note21"/>Note</h3><p>Note that you'll need to compile the project first, since actual assemblies might be required for code generation.</p></div><p>Additionally, keep in mind that due to the natural integration with Entity Framework, an option covering all required controllers and views will be offered. So, in the <span class="strong"><strong>Add Scalffold</strong></span> dialog box, select the <span class="strong"><strong>MVC 5 Controller with Views, using Entity Framework</strong></span> option. This will generate all the required code to test the basic CRUD data options:</p><div class="mediaobject"><img src="../Images/image00552.jpeg" alt="The Entity Framework data model"/></div><p style="clear:both; height: 1em;"> </p><p>You will still be asked<a id="id546" class="indexterm"/> about the model to use (<span class="strong"><strong>Department</strong></span>, in my case), and about the <code class="literal">DataContext</code> class (<code class="literal">AdventureWorks2014Entities</code>). When the assistant finishes, several new files will have been generated.</p><p>First, we'll have a new <code class="literal">DepartmentsController</code> controller, which includes the CRUD operations I mentioned earlier. In addition, a new <code class="literal">Departments</code> folder appears, showing five new views, corresponding to <span class="strong"><strong>Create</strong></span>, <span class="strong"><strong>Delete</strong></span>, <span class="strong"><strong>Details</strong></span> (to view only one department), <span class="strong"><strong>Edit</strong></span>, and <span class="strong"><strong>Index</strong></span>, which shows the whole list of departments, along with some links that will allow you to access the rest of options.</p><p>The first lines of that controller class indicates the suggested way to operate:</p><div class="informalexample"><pre class="programlisting">private AdventureWorks2014Entities db = new AdventureWorks2014Entities();

// GET: Departments
public ActionResult Index()
{
  return View(db.Departments.ToList());
}</pre></div><p>The <code class="literal">DBContext</code> object will recover all the departments and convert them into <code class="literal">List&lt;Department&gt;</code>, which is the model the view expects (take a look at the <code class="literal">Index.cshtml</code> file in the <span class="strong"><strong>Views/Departments</strong></span> area). When launching it, you'll need to reference the controller in the URL, since by default, the application is configured to present the Home controller<a id="id547" class="indexterm"/> and the <code class="literal">Index</code> action method.</p><p>If you type <code class="literal">http://localhost:[portNumber]/Departments</code>, the routing pattern will take you to the <code class="literal">Index</code> method in the <code class="literal">Departments</code> controller, and the following list will show up (it doesn't matter which browser you use, of course):</p><p> </p><div class="mediaobject"><img src="../Images/image00553.jpeg" alt="The Entity Framework data model"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>If everything goes fine, you'll be able to change data using the <span class="strong"><strong>Edit</strong></span> and <span class="strong"><strong>Delete</strong></span> links that the view presents automatically, and a selection of the <span class="strong"><strong>Details</strong></span> option will take you to a different view, showing just the selected element.</p></div>
<div class="section" title="Summary" id="aid-147LC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we reviewed the basics of data access in relational models. First, we examined the concepts behind the relational model itself, including its basic and fundamental principles, its architecture, and the properties of relational tables.</p><p>Then, we went through the Microsoft tools offered to work with these models, such as SQL Server 2014 Express Edition, and <span class="strong"><strong>SQL Server Management Studio</strong></span> (<span class="strong"><strong>SSMS</strong></span>), revising their programmatic and operational offers in editing, debugging, analyzing execution, and so on.</p><p>After a brief note on the T-SQL language, we covered a not-well-known type of project that Visual Studio proposed, SQL Server Projects, and saw how we can create and manage packages (<code class="literal">.dacpac</code> files) that help us manage and administer any database and reproduce its structure in another RDBMS.</p><p>Finally, we reviewed some data access options from within Visual Studio, demonstrating how to access data using two technologies that are widely known and accepted, ADO.NET (using a Windows Presentation Foundation application) and Entity Framework, inside a ASP.NET MVC application.</p><p>In the next chapter, we will switch from the relational to the noSQL model, and we'll study its advantages and disadvantages and work with the MongoDB noSQL database in both ways: from the tools offered by the product and also from Visual Studio.</p></div></body></html>