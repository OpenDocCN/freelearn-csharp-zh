<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>4. Parallel LINQ</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;4.&#160;Parallel LINQ">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04"></a>Chapter&#160;4.&#160;Parallel LINQ</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we are going to cover the following recipes:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Creating a basic parallel query</li>
            <li class="listitem" style="list-style-type: disc">Preserving order in parallel LINQ</li>
            <li class="listitem" style="list-style-type: disc">Forcing parallel execution</li>
            <li class="listitem" style="list-style-type: disc">Limiting parallelism in a query</li>
            <li class="listitem" style="list-style-type: disc">Processing query results</li>
            <li class="listitem" style="list-style-type: disc">Specifying merge options</li>
            <li class="listitem" style="list-style-type: disc">Range projection with parallel LINQ</li>
            <li class="listitem" style="list-style-type: disc">Handling exceptions in parallel LINQ</li>
            <li class="listitem" style="list-style-type: disc">Cancelling a parallel LINQ query</li>
            <li class="listitem" style="list-style-type: disc">Performing reduction operations</li>
            <li class="listitem" style="list-style-type: disc">Creating a custom partitioner</li>
          </ul>
        </div>
        <div class="section" title="Introduction">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title" id="sigil_toc_id_6"><a id="ch04lvl1sec38"></a>Introduction</h1>
              </div>
            </div>
          </div>
          <p>
<span class="strong"><strong>Language Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>) offers<a id="id241" class="indexterm"></a> developers syntax for performing queries on collection of data. Using LINQ you can traverse, filter, sort, and return projected sets of items. When you use LINQ to objects, all of the items in your data collection are processed sequentially by a single thread.</p>
          <p>Parallel LINQ is a <a id="id242" class="indexterm"></a>parallel implementation of LINQ to objects, which can turn your sequential queries into parallel queries, potentially improving performance.</p>
          <p>Internally, parallel LINQ uses tasks queued to default <code class="literal">TaskScheduler</code> to extend the processing of the source collection's items across available processors, so that multiple items are processed concurrently.</p>
          <p>In this chapter, we are going to see how parallel LINQ can potentially improve query performance<a id="id243" class="indexterm"></a> for large collections of items, or for long compute-bound processing of items.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Creating a basic parallel query">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec39"></a>Creating a basic parallel query</h1>
            </div>
          </div>
        </div>
        <p>In this recipe, we will take a look at creating a basic parallel query by using the <code class="literal">AsParallel</code> method<a id="id244" class="indexterm"></a> of the <code class="literal">System.Linq.ParallelEnumerable</code> class.</p>
        <p>We are going to create a <a id="id245" class="indexterm"></a>
<code class="literal">Console</code> application that initializes a collection of employees, and then queries the employee collection looking for a specific job title.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec68"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's go to Visual<a id="id246" class="indexterm"></a> Studio and start creating some parallel LINQ queries.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">SimplePLINQ</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre>
</div></li>
              <li class="listitem">First, we need to create an <code class="literal">Employee</code> class just below the <code class="literal">Program</code> Class. Create an <code class="literal">Employee</code> class definition with <code class="literal">Id</code>, <code class="literal">Title</code>, <code class="literal">FirstName</code>, and <code class="literal">LastName</code> properties.<div class="informalexample"><pre class="programlisting">public class Employee
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}</pre>
</div></li>
              <li class="listitem">Now, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create and initialize an array of <code class="literal">employees</code>.<div class="informalexample"><pre class="programlisting">var employees = newList&lt;Employee&gt;
{
  new Employee{Id=1, Title="Developer", FirstName="Mark", LastName="Smith"},
  new Employee{Id=2, Title="Director", FirstName="Kate", LastName="Williams"},
  new Employee{Id=3, Title="Manager", FirstName="Karen", LastName="Davis"},
  new Employee{Id=4, Title="Developer", FirstName="Maria", LastName="Santos"},
  new Employee{Id=5, Title="Developer", FirstName="Thomas", LastName="Arnold"},
  new Employee{Id=6, Title="Tester", FirstName="Marcus", LastName="Gomez"},
  new Employee{I =7, Title="IT Engineer", FirstName="Simon", LastName="Clark"},
  new Employee{Id=8, Title="Tester", FirstName="Karmen", LastName="Wright"},
  new Employee{Id=9, Title="Manager", FirstName="William", LastName="Jacobs"},
  new Employee{Id=10, Title="IT Engineer", FirstName="Sam", LastName="Orwell"},
  new Employee{Id=11, Title="Developer", FirstName="Tony", LastName="Meyers"},
  new Employee{Id=12, Title="Developer", FirstName="Karen", LastName="Smith"},
  new Employee{Id=13, Title="Tester", FirstName="Juan", LastName="Rodriguez"},
  new Employee{Id=14, Title="Developer", FirstName="Sanjay", LastName="Bhat"},
  new Employee{Id=15, Title="Manager", FirstName="Abid", LastName="Naseem"}
};</pre>
</div></li>
              <li class="listitem">Next, we will <a id="id247" class="indexterm"></a>create a parallel LINQ query that selects all employees where their title is <code class="literal">Developer</code>.<div class="informalexample"><pre class="programlisting">var results = from e in employees.AsParallel()
                where e.Title.Equals("Developer")
                select e;</pre>
</div><div class="informalexample"><pre class="programlisting">Finally, let's loop through the results and display them to the <code class="literal">Console</code>, then wait for user input to exit.
foreach (var employee in results)
{
    Console.WriteLine("Id:{0}  Title:{1}  First Name:{2}  Last Name:{3}",
        employee.Id, employee.Title, employee.FirstName, employee.LastName);
}
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_01.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec69"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The small collection<a id="id248" class="indexterm"></a> of employees we created for this example is too small to benefit from parallelizing the query, but the key thing to notice in the example is the use of the <code class="literal">AsParallel extension</code> method<a id="id249" class="indexterm"></a> which binds the query to parallel LINQ, and specifies that the rest of the query should be parallelized if possible.</p>
          <div class="informalexample">
            <pre class="programlisting">var results = from e in employees.AsParallel()
                where e.Title.Equals("Developer")
                select e;</pre>
          </div>
          <p>The <code class="literal">System.Linq.ParallelEnumerable</code> class<a id="id250" class="indexterm"></a> implements all of the parallel LINQ functionality, and exposes parallel versions of <code class="literal">Select</code>, <code class="literal">Single</code>, <code class="literal">Skip</code>, <code class="literal">OrderBy</code>, and so on. All of these methods are extension methods that extend <code class="literal">ParallelQuery&lt;TSource&gt;</code>. The <code class="literal">AsParallel</code> extension method converts your sequential query based on <code class="literal">IEnumerable&lt;T&gt;</code> to a parallel query based on <code class="literal">ParallelQuery&lt;T&gt;</code>.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Preserving order in parallel LINQ">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec40"></a>Preserving order in parallel LINQ</h1>
            </div>
          </div>
        </div>
        <p>By default, PLINQ <a id="id251" class="indexterm"></a>does not preserve the order out of a source collection. Because PLINQ processes items in a data collection concurrently using multiple threads, the items are returned unordered. This is by design, because maintaining the original ordering of a sequence adds overhead, and in most cases, that overhead may not be necessary.</p>
        <p>However, when you need to preserve order, PLINQ provides a simple way to accomplish it. In this recipe, we are going to create a <code class="literal">Console</code> application that creates two collections of numbers, performs <a id="id252" class="indexterm"></a>an ordered query on one collection, and the default unordered query on the other collection, and looks at the results.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec70"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's open up Visual Studio and see how to preserve order on parallel LINQ queries.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">PreserveOrder</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;</pre>
</div></li>
              <li class="listitem">Let's start off by creating a <code class="literal">UnorderedQuery</code> method<a id="id253" class="indexterm"></a> just below the <code class="literal">Main</code> method of the <code class="literal">Program</code> class. This method will query a large range of integers for numbers that are evenly divisible by 5, and will take the first 10 of those numbers as the result.<div class="informalexample"><pre class="programlisting">private static void UnorderedQuery(IEnumerable&lt;int&gt; source)
{
    Console.WriteLine("Unordered results");
    var query = (from numbers in source.AsParallel()
        where numbers%5 == 0
        select numbers).Take(10);

    foreach (var number in query)
        Console.WriteLine(number);
}</pre>
</div></li>
              <li class="listitem">Next we need to create our <code class="literal">OrderedQuery</code> method<a id="id254" class="indexterm"></a> which will perform the same query as the previous step, except it will use the <code class="literal">AsOrdered</code> extension method to preserve the original order.<div class="informalexample"><pre class="programlisting">private static void OrderedQuery(IEnumerable&lt;int&gt; source)
{
    Console.WriteLine("Ordered results");
    var query = (from numbers in source.AsParallel().AsOrdered()
        where numbers % 5 == 0
        select numbers).Take(10);

    foreach (var number in query)
        Console.WriteLine(number);
}</pre>
</div></li>
              <li class="listitem">Now let's add some code to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class to create your source lists of numbers and to call each of the methods.<div class="informalexample"><pre class="programlisting">var source1 = Enumerable.Range(1, 100000);
UnorderedQuery(source1);

Console.WriteLine();

var source2 = Enumerable.Range(1, 100000);
OrderedQuery(source2);

Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual <a id="id255" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_02.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec71"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>If you need to have parallel LINQ, preserve the order of items as they are processed, then you can call the <code class="literal">AsOrdered</code> method of the <code class="literal">ParallelEnumerable</code> class.</p>
          <div class="informalexample">
            <pre class="programlisting">var query = (from numbers in source.AsParallel().AsOrdered()
        where numbers % 5 == 0
        select numbers).Take(10);</pre>
          </div>
          <p>When you call this method, the threads spawned for the query will process the items of a collection in groups,<a id="id256" class="indexterm"></a> then the groups are merged back together preserving order but hurting performance.</p>
          <p>The operators <code class="literal">Distinct</code>, <code class="literal">Intersect</code>, <code class="literal">Union</code>, <code class="literal">Join</code>, <code class="literal">Except</code>, <code class="literal">GroupBy</code>, <code class="literal">GroupJoin</code>, and <code class="literal">ToLookup</code> produce unordered operations. If you need to enforce ordering after one of these operations, you just need to call the <code class="literal">AsOrdered</code> method.</p>
          <p>Conversely, the operators <code class="literal">OrderBy</code>, <code class="literal">OrderByDescending</code>, <code class="literal">ThenBy</code>, and <code class="literal">ThenByDescending</code> produce ordered operations. If you need to go back to unordered processing and improve performance, PLINQ provides a <code class="literal">AsUnordered</code> method<a id="id257" class="indexterm"></a> you can call.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Forcing parallel execution">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec41"></a>Forcing parallel execution</h1>
            </div>
          </div>
        </div>
        <p>Parallel LINQ looks for opportunities to parallelize a query, but not all queries run faster in parallel. For example, a <a id="id258" class="indexterm"></a>query that contains a single delegate that does only a little bit of work will usually run faster sequentially, because the overhead of parallelizing outweighs the benefits gained from parallelizing it.</p>
        <p>For the most part, parallel LINQ does a really good job of determining what should be parallelized and what should run sequentially, based on its examination of the shape of the query. However, the algorithm it uses is not perfect, and you might need to instruct PLINQ to run your query in parallel.</p>
        <p>In this recipe, we will build a <code class="literal">Console</code> application that creates a query which PLINQ will determine whether it needs to be executed sequentially. We will then force the query to run in parallel using the <code class="literal">WithExecutionMode</code> method<a id="id259" class="indexterm"></a>. Finally, we will capture the time it takes for both queries to run and compare the results.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec72"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how to force a PLINQ query to execute in parallel.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">ForceParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;</pre>
</div></li>
              <li class="listitem">First, let's create a method in your <code class="literal">Program</code> class called <code class="literal">NoForcedParallelism</code> that creates a PLINQ query with a small delegate of work that PLINQ will evaluate and determine what needs to be executed sequentially.<div class="informalexample"><pre class="programlisting">private static void NoForcedParallelism()
{
    Enumerable.Range(0, 1000).AsParallel()
                .Where(x =&gt;
                {
                    Thread.SpinWait(1000000);
                    return true;
                })
                .Select((x, i) =&gt; i)
                .ToArray();
}</pre>
</div></li>
              <li class="listitem">Next, let's create a method in the <code class="literal">Program</code> class called <code class="literal">ForcedParallism</code> which runs <a id="id260" class="indexterm"></a>the same query, but forces PLINQ to execute it in parallel by calling the <code class="literal">WithExecutionMode</code> method<a id="id261" class="indexterm"></a> and passing it a <code class="literal">ParallelExecutionMode.ForceParallelism</code> enumeration.<div class="informalexample"><pre class="programlisting">private static void ForcedParallelism()
{
    Enumerable.Range(0, 1000).AsParallel()
            .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
            .Where(x =&gt;
            {
                Thread.SpinWait(1000000);
                return true;
            })
            .Select((x, i) =&gt; i)
            .ToArray();
}</pre>
</div></li>
              <li class="listitem">We will finish up by adding some code to the <code class="literal">Main</code> method to create <code class="literal">stopWatch</code> to capture the timing of the two methods, then run the methods and compare the results.<div class="informalexample"><pre class="programlisting">private static void Main()
{
   var stopWatch = new Stopwatch();
   stopWatch.Start();
   NoForcedParallelism();
   stopWatch.Stop();
   Console.WriteLine("Query with no forced parallelism ran in {0} ms.",
		stopWatch.ElapsedMilliseconds);
   stopWatch.Reset();
   stopWatch.Start();
   ForcedParallelism();
   stopWatch.Stop();
   Console.WriteLine("Query with forced parallelism ran in {0} ms.", 
		stopWatch.ElapsedMilliseconds);
   Console.ReadLine();
}</pre>
</div></li>
              <li class="listitem">In Visual Studio<a id="id262" class="indexterm"></a> 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_03.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec73"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, we can see that PLINQ wrongly decided that the query would run faster sequentially. When we forced the query to run in parallel, the performance improvement was significant.</p>
          <p>We instructed PLINQ not to fall back to sequential execution when it detects certain query shapes by calling the <code class="literal">WithExecutionMode</code> method<a id="id263" class="indexterm"></a> of <code class="literal">System.Linq.ParallelQuery</code>, and passing it <code class="literal">ParallelExecutionMode.ForceParallelism</code> enumeration value.</p>
          <div class="informalexample">
            <pre class="programlisting">Enumerable.Range(0, 1000).AsParallel()
    <span class="strong"><strong>.WithExecutionMode(ParallelExecutionMode.ForceParallelism)</strong></span>
    .Where(x =&gt;
    {
        Thread.SpinWait(1000000);
        return true;
    })
    .Select((x, i) =&gt; i)
    .ToArray();</pre>
          </div>
          <p>Why did PLINQ determine that the query should be executed sequentially in the first place? It is mainly a <a id="id264" class="indexterm"></a>factor to determine the shape of the query which has a single delegate of work. It also has to do with this query using the <code class="literal">positional Select</code> operator. Positional-related operators may require <code class="literal">ForceParallelism</code> in PLINQ that includes <code class="literal">positional Select</code>, <code class="literal">positional Where</code>, <code class="literal">positional SelectMany</code>, <code class="literal">Take</code>, <code class="literal">Skip</code>, <code class="literal">TakeWhile</code>, and <code class="literal">SkipWhile</code>.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Limiting parallelism in a query">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec42"></a>Limiting parallelism in a query</h1>
            </div>
          </div>
        </div>
        <p>By default, parallel LINQ<a id="id265" class="indexterm"></a> will try to take advantage of all of the processor cores offered by your CPU. Usually, this is what you want. However, there could be situations where you want to limit the number of threads used to run queries<a id="id266" class="indexterm"></a> and keep some cores available for other work.</p>
        <p>In this recipe, we are going to create a query that uses the <code class="literal">WithDegreeOfParallelism</code> method<a id="id267" class="indexterm"></a> to explicitly set the number of threads that a parallel query uses.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec74"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how to limit the degree of parallelism of a query.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">LimitParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading;</pre>
</div></li>
              <li class="listitem">Let's add a PLINQ query to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class that works the processors. For now, we will use the <code class="literal">WithExecutionMode</code> method to force the query to run in parallel, but will not set a limit on the parallelization.<div class="informalexample"><pre class="programlisting">private static void Main()
{
       
    var result = Enumerable.Range(0, 10000).AsParallel()
        .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
        .Where(x =&gt;
      {
                Thread.SpinWait(1000000);
                return true;
            })
        .Select((x, i) =&gt; i)
        .ToArray();

        foreach (var number in result)
            Console.WriteLine("Result: {0}",number);

        Console.ReadLine();
}</pre>
</div></li>
              <li class="listitem">If you have a multi-core <a id="id268" class="indexterm"></a>processor on your machine, start up the <span class="strong"><strong>Task Manager</strong></span>, click on the <span class="strong"><strong>Performance</strong></span> tab, and watch CPU <a id="id269" class="indexterm"></a>usage. In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see processor usage as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_04.png.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Now let's edit the PLINQ query to call the <a id="id270" class="indexterm"></a><code class="literal">WithDegreeOfParallelism</code> method to limit the number of processor cores used. You might want to change the value you pass into the method to be a number<a id="id271" class="indexterm"></a> that is relevant to the number of processor cores available to you. You can specify a number greater than the number <a id="id272" class="indexterm"></a>of processor cores available on your machine, but this will likely lead to more context switching.<div class="informalexample"><pre class="programlisting">var result = Enumerable.Range(0, 10000).AsParallel()
        .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
        .WithDegreeOfParallelism(2)
        .Where(x =&gt;
            {
                Thread.SpinWait(1000000);
                return true;
            })
        .Select((x, i) =&gt; i)
        .ToArray();                       </pre>
</div></li>
              <li class="listitem">Now start up the <span class="strong"><strong>Task Manager</strong></span> again, click on the <span class="strong"><strong>Performance</strong></span> tab, and watch CPU usage. In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see<a id="id273" class="indexterm"></a> reduced processor usage. Note that the threads <a id="id274" class="indexterm"></a>created will not necessarily spend all of their time on a single core, but the overall usage will go down.<div class="mediaobject"><img src="graphics/0225OT_04_05.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec75"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The <code class="literal">WithDegreeOfParallelism</code> method<a id="id275" class="indexterm"></a> probably isn't something that you will use very often. You might want to use it in situations where you need to leave some CPU time available to perform other tasks. You could also pass a number that is greater than the number of cores on your machine, in cases where the query will be performing synchronous I/O, because the threads will be blocking.</p>
          <p>Setting the degree of parallelism is simply a matter of calling the method and passing in the number<a id="id276" class="indexterm"></a> of threads <a id="id277" class="indexterm"></a> you want PLINQ to use.</p>
          <div class="informalexample">
            <pre class="programlisting">var result = Enumerable.Range(0, 10000).AsParallel()
        .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
<span class="strong"><strong>        .WithDegreeOfParallelism(2)</strong></span>
        …
        .Select((x, i) =&gt; i)
        .ToArray();                       </pre>
          </div>
          <p>The default value of the <code class="literal">WithDegreeOfParallism</code> method is the processor count of your machine.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Processing query results">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec43"></a>Processing query results</h1>
            </div>
          </div>
        </div>
        <p>One of the nice features of parallel LINQ is that it collates the results from a parallelized query into a single output sequence.<a id="id278" class="indexterm"></a> Often though, all your program does with the query's output data is run a function over each element using a <code class="literal">foreach</code> loop or similar. In such cases, particularly in cases where you don't care about the order in which elements are processed, you can improve performance by using the ParallelEnumerable's <code class="literal">ForAll</code> method to process the results in parallel.</p>
        <p>In this recipe, we will perform a query on a range of numbers, and then use <code class="literal">ParallelForAll</code> to iterate over the results in parallel, calculating the square of each number.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec76"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's open up Visual Studio and see how to process the results of a parallel query.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">ProcessResults</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create a concurrent collection of integers to hold the result of our calculation, and generate a range of numbers for the query.<div class="informalexample"><pre class="programlisting">var result = new ConcurrentBag&lt;Int32&gt;();
var source = Enumerable.Range(1, 100000);</pre>
</div></li>
              <li class="listitem">Next, just below the previous lines, create a PLINQ query that queries the first 100 numbers that are evenly divisible by 5 out of the source range.<div class="informalexample"><pre class="programlisting">var query = (from numbers in source.AsParallel()
        where numbers % 5 == 0
        select numbers).Take(100);</pre>
</div></li>
              <li class="listitem">Now let's <a id="id279" class="indexterm"></a>call the <code class="literal">ParallelEnumerable.ForAll</code> method<a id="id280" class="indexterm"></a> to process our query results in parallel. We are just going to calculate the square of each number and add the result to our collection.<div class="informalexample"><pre class="programlisting">query.ForAll(r =&gt; 
    {
        result.Add(r * r);
    });</pre>
</div></li>
              <li class="listitem">Finally, let's loop through the collection and print the results to <code class="literal">Console</code>.<div class="informalexample"><pre class="programlisting">foreach (var value in result)
{
     Console.WriteLine("Result squared: {0}", value );
}
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_06.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec77"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, we are using <code class="literal">ParallelEnumerable.ForAll&lt;TSource&gt;</code> to iterate through and process the results of our query in parallel. The <code class="literal">ForAll</code> method runs a delegate over every output<a id="id281" class="indexterm"></a> element of a <code class="literal">ParallelQuery</code>.</p>
          <div class="informalexample">
            <pre class="programlisting">query.ForAll(r =&gt; 
    {
        result.Add(r * r);
    });</pre>
          </div>
          <p>The <code class="literal">ForAll</code> method<a id="id282" class="indexterm"></a> hooks right into parallel LINQ's internals, bypassing the steps of collating, and enumerating the results which can save considerable processing time.</p>
          <p>You might wonder why we used the <code class="literal">ForAll</code> method to calculate the square of our results and add them to the collection; just to use a sequential <code class="literal">foreach</code> loop to write the results to <code class="literal">Console</code>. Besides the obvious answer that this is just a simple example, you wouldn't want to write to <code class="literal">Console</code> inside a <code class="literal">ForAll</code> method<a id="id283" class="indexterm"></a> because .NET serializes all access to <code class="literal">Console</code>, and would force the whole thing to run sequentially.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Specifying merge options">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec44"></a>Specifying merge options</h1>
            </div>
          </div>
        </div>
        <p>When parallel LINQ executes a query, it partitions the source data and assigns each partition to a separate thread. If the results are consumed by a single thread, such as a <code class="literal">foreach</code> loop, then the results from each partition must be merged back into one result set. The kind<a id="id284" class="indexterm"></a> of merge that is performed depends on the operators used in the query. For operators that produce ordered results, the results from all the threads are completely buffered before being merged back together. Your application's consuming thread might have to wait for a while before seeing the final result. If you don't care about order, or want to use a different buffering scheme to improve results, your query can use the <code class="literal">WithMergeOptions</code> extension method to provide a hint to PLINQ about how you would like the results to be buffered.</p>
        <p>In this recipe, we will query some numbers out of a range, and loop through the results using a couple of different buffering options, and observe the effects.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec78"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's take a look<a id="id285" class="indexterm"></a> at how to specify the merge option of a PLINQ query.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">MergeOptions</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading;</pre>
</div></li>
              <li class="listitem">Let's start by creating our source number range in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class.<div class="informalexample"><pre class="programlisting">var numbers = ParallelEnumerable.Range(0, 1000);</pre>
</div></li>
              <li class="listitem">Now let's create a PLINQ query to select the numbers in the range that are evenly divisible <a id="id286" class="indexterm"></a>by 5, and use the <code class="literal">WithMergeOption</code> method to specify fully buffered merging of the results.<div class="informalexample"><pre class="programlisting">var result = numbers.AsParallel()
        .WithMergeOptions(ParallelMergeOptions.FullyBuffered)
        .Where(number =&gt; number % 5 == 0);</pre>
</div></li>
              <li class="listitem">Next, let's use a <code class="literal">foreach</code> loop to iterate through the results and print them to <code class="literal">Console</code>.<div class="informalexample"><pre class="programlisting">foreach (var number in result)
{
    Console.WriteLine("Result: {0}",number);
}
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Notice the <span class="strong"><strong>Ordered Results</strong></span> shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_07.png.jpg" alt="How to do it…"/></div></li>
              <li class="listitem">Now let's use the <code class="literal">WithMergeOption</code> method<a id="id287" class="indexterm"></a> to specify no buffering for the results.<div class="informalexample"><pre class="programlisting">var result = numbers.AsParallel()
        .WithMergeOptions(ParallelMergeOptions.NotBuffered)
        .Where(number =&gt; number % 5 == 0);</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Notice the unordered results in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_08.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec79"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The <code class="literal">WithMergeOptions</code> method<a id="id288" class="indexterm"></a> takes the <code class="literal">ParallelMergeOptions</code> enumeration as a parameter. You can specify one of the following options for how the query output is yielded and when the <a id="id289" class="indexterm"></a>results can be consumed:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Not Buffered</strong></span>: Each <a id="id290" class="indexterm"></a>processed element of the query is returned from each thread as soon as it is produced. If the <code class="literal">AsOrdered</code> operator is present, ordering is preserved, but if <code class="literal">AsOrdered</code> is not present, then the results are yielded as soon as they are available. This option yields the fastest results.</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Auto Buffered</strong></span>: The elements<a id="id291" class="indexterm"></a> are collected into a buffer and periodically yielded to the consuming thread. This is a middle ground approach to buffering.</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fully Buffered</strong></span>: All of the elements<a id="id292" class="indexterm"></a> are collected in a buffer before any elements are yielded to the consuming thread.</li>
            </ul>
          </div>
          <p>When you use <code class="literal">WithMergeOptions</code>, you are giving PLINQ a hint about the buffering scheme you want it to use. If a particular query cannot support the requested option, your request will be ignored.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Range projection with parallel LINQ">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec45"></a>Range projection with parallel LINQ</h1>
            </div>
          </div>
        </div>
        <p>While using sequential LINQ, it is very common to use range projection to obtain a range of values. Parallel LINQ <a id="id293" class="indexterm"></a>provides us with a way to do this too. If you need to generate a very large range of numbers which do not necessarily need to be in sequence, you can use the <code class="literal">Range</code> method of <code class="literal">ParallelEnumerable</code> to create the sequence.</p>
        <p>In this short recipe, we will use <code class="literal">ParallelEnumerable.Range</code> to generate some numbers over a very large range.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec80"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's go to Visual Studio and see how to use parallel LINQ to generate a range of numbers.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">RangeProjection</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre>
</div></li>
              <li class="listitem">First, in the <code class="literal">Main</code> method, let's use <code class="literal">ParallelEnumerable.Range</code> to create a range of numbers between 1 and 1000 that are divisible by 5.<div class="informalexample"><pre class="programlisting">var numbers = ParallelEnumerable.Range(1, 1000)
        .Where(x =&gt; x % 5 != 0)
        .Select(i =&gt; i);</pre>
</div></li>
              <li class="listitem">Now let's just loop through the results to display them to the <code class="literal">Console</code> and wait for user input before exiting.<div class="informalexample"><pre class="programlisting">foreach (var number in numbers)
{
    Console.WriteLine("Result: {0}",number);
}
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_09.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec81"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The code for this <a id="id294" class="indexterm"></a>recipe is fairly easy to understand. One important point to note is that the implicit cast to <code class="literal">ParallelQuery&lt;int&gt;</code> creates a parallel execution instead of a sequential one, and there is no particular ordering of the numbers in the result.</p>
          <p>Of course, order can be preserved by calling <code class="literal">AsOrdered</code> on the query, but if ordering is important to you, just generate the range using sequential LINQ projection, and avoid the overhead of parallel execution.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Handling exceptions in parallel LINQ">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec46"></a>Handling exceptions in parallel LINQ</h1>
            </div>
          </div>
        </div>
        <p>Handling exceptions<a id="id295" class="indexterm"></a> in parallel LINQ is not much different from handling exceptions in tasks, continuation, or anywhere else in your parallel code. You need to use <code class="literal">try</code>/<code class="literal">catch</code> and make sure to catch <code class="literal">AggregateException</code>. With parallel LINQ, the really important part is to use the try/catch around where you enumerate or use your results.</p>
        <p>In this recipe, we are going to create a simple parallel LINQ query that returns a list of employees and throws <code class="literal">InvalidOperationException</code>, which we will handle when we iterate through the results.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec82"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears <a id="id296" class="indexterm"></a>whenever a runtime <code class="literal">Exception</code> is thrown, and intercepts the <code class="literal">Exception</code> before it gets to our handler.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and click on <span class="strong"><strong>Exception</strong></span>.</li>
              <li class="listitem">Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_04_10.png.jpg" alt="Getting ready…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec83"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's take a look at how to handle exceptions in a parallel LINQ query.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">HandleExceptions</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre>
</div></li>
              <li class="listitem">First, let's create an <code class="literal">Employee</code> class. Add the following class definition to your <code class="literal">Program.cs</code> file, just below the <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">public class Employee
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}</pre>
</div></li>
              <li class="listitem">Now, in the <code class="literal">Main</code> method <a id="id297" class="indexterm"></a>of the <code class="literal">Program</code> class, let's create and initialize an array of <code class="literal">employees</code>.<div class="informalexample"><pre class="programlisting">var employees = new[]
{
  new Employee{Id=1, Title="Developer", FirstName="Mark", LastName="Smith"},
  new Employee{Id=2, Title="Director", FirstName="Kate", LastName="Williams"},
  new Employee{Id=3, Title="Manager", FirstName="Karen", LastName="Davis"},
  new Employee{Id=4, Title="Developer", FirstName="Maria", LastName="Santos"},
  new Employee{Id=5, Title="Developer", FirstName="Thomas", LastName="Arnold"},
  new Employee{Id=6, Title="Tester", FirstName="Marcus", LastName="Gomez"},
  new Employee{I =7, Title="IT Engineer", FirstName="Simon", LastName="Clark"},
  new Employee{Id=8, Title="Tester", FirstName="Karmen", LastName="Wright"},
  new Employee{Id=9, Title="Manager", FirstName="William", LastName="Jacobs"},
  new Employee{Id=10, Title="IT Engineer", FirstName="Sam", LastName="Orwell"},
  new Employee{Id=11, Title="Developer", FirstName="Tony", LastName="Meyers"},
  new Employee{Id=12, Title="Developer", FirstName="Karen", LastName="Smith"},
  new Employee{Id=13, Title="Tester", FirstName="Juan", LastName="Rodriguez"},
  new Employee{Id=14, Title="Developer", FirstName="Sanjay", LastName="Bhat"},
  new Employee{Id=15, Title="Manager", FirstName="Abid", LastName="Naseem"}
  new Employee{Id=16, Title="Developer",FirstName="Kevin", LastName="Strong"}
};</pre>
</div></li>
              <li class="listitem">Next, create a PLINQ query that selects all employees and throws <code class="literal">InvalidOperationException</code> when it encounters an <code class="literal">employee Id</code> that is greater than <code class="literal">15</code>.<div class="informalexample"><pre class="programlisting">var results = employees.AsParallel()
    .Select(employee =&gt;
    {
    if (employee.Id &gt; 15)
    throw new InvalidOperationException("Invalid employee. Id &gt; 15.");
    return employee;
    });</pre>
</div></li>
              <li class="listitem">Finally, let's create a <code class="literal">try</code>/<code class="literal">catch</code> block. In the <code class="literal">try</code> block, create a <code class="literal">foreach</code> loop to iterate <a id="id298" class="indexterm"></a>through the results. In the <code class="literal">catch</code> block, you need to handle <code class="literal">AggregateException</code> and display the <code class="literal">Exception</code> to <code class="literal">Console</code>. Finish up by waiting for user input before exiting the program.<div class="informalexample"><pre class="programlisting">try
{
    foreach (var employee in results)
    {
        Console.WriteLine("Id:{0}  Title:{1}  First Name:{2}  Last Name:{3}",
            employee.Id, employee.Title, employee.FirstName, employee.LastName);
    }
}
catch (AggregateException aggregateException)
{
    foreach (var exception in aggregateException.InnerExceptions)
    {
        Console.WriteLine("The query threw an exception: {0}", exception.Message);
    }
}
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_11.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec84"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>As you can see, the steps for handling exceptions that occur in a parallel LINQ query are very consistent with <a id="id299" class="indexterm"></a>handling exceptions that occur in other parts of our parallel code. Any <code class="literal">Exception</code> that occurs will be added to the <code class="literal">InnerExceptions</code> collection of an <code class="literal">AggregateException</code>. So, we need to be ready to catch <code class="literal">AggregateException</code> and examine the individual <code class="literal">Exception</code> items in the <code class="literal">InnerExceptions</code> collection.</p>
          <p>In this recipe, we just placed a <code class="literal">try</code>/<code class="literal">catch</code> block around the loop that iterates through our results, and handled <code class="literal">AggregateException</code> in the <code class="literal">catch</code> block.</p>
          <div class="informalexample">
            <pre class="programlisting">try
{
    foreach (var employee in results)
    {
        ...
    }
}
catch (AggregateException aggregateException)
{
    foreach (var exception in aggregateException.InnerExceptions)
    {
        Console.WriteLine("The query threw an exception: {0}", exception.Message);
    }
}</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Cancelling a parallel LINQ query">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec47"></a>Cancelling a parallel LINQ query</h1>
            </div>
          </div>
        </div>
        <p>Like tasks and continuations, parallel LINQ queries are cancelled by using <code class="literal">CancellationToken</code> which <a id="id300" class="indexterm"></a>you obtain from <code class="literal">CancellationTokenSource</code>. A minor difference in cancelling a parallel LINQ query is in how you register a <code class="literal">CancellationToken</code> with the <code class="literal">WithCancellation(tokenSource.Token)</code> extension method.</p>
        <p>In this recipe, we are going to create a cancellable parallel query that selects the square of numbers from a large range of random numbers. We are then going to create a separate task to cancel the query from.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec85"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime <code class="literal">Exception</code> is thrown and intercepts the <code class="literal">Exception</code> before it gets to our handler. </p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exception</strong></span>.</li>
              <li class="listitem">Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_04_10.png.jpg" alt="Getting ready…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec86"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's take a look at how to cancel a parallel LINQ query.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new <a id="id301" class="indexterm"></a>project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">CancelQuery</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, let's add some code to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class to create our <code class="literal">CancellationTokenSource</code> object. We also need to initialize a large range of random numbers that will be the source for the query.<div class="informalexample"><pre class="programlisting">var tokenSource = new CancellationTokenSource();
var random = new Random();
var numberList = ParallelEnumerable.Range(1, 100000).OrderBy(i =&gt; random.Next());</pre>
</div></li>
              <li class="listitem">Next, let's create a parallel LINQ query that uses the <code class="literal">WithCancellation </code>extension method to accept a cancellation token and uses the <code class="literal">Math.Pow</code> method to select the square of each number.<div class="informalexample"><pre class="programlisting">var results = numberList
    .AsParallel()
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .WithCancellation(tokenSource.Token)
    .Select(number =&gt; Math.Pow(number, 2));</pre>
</div></li>
              <li class="listitem">Now let's create a task that will sleep for 1 second to give the query time to start, and then it will call the <code class="literal">CancellationTokenSource.Cancel</code> method<a id="id302" class="indexterm"></a> to cancel the token.<div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    Thread.Sleep(1000);
    tokenSource.Cancel();
    Console.WriteLine("Cancelling query.");
});</pre>
</div></li>
              <li class="listitem">Finally, let's create a <code class="literal">try</code> block and a couple of <code class="literal">catch</code> blocks. The <code class="literal">try</code> block will just contain a <code class="literal">foreach</code> loop, to loop through the results of the query. The first <code class="literal">catch</code> block needs to catch <code class="literal">OperationCancelledException</code> and display a message to <code class="literal">Console</code>. The second <code class="literal">catch</code> block needs to catch <code class="literal">AggregateException</code> and display all <code class="literal">InnerException</code> messages to the <code class="literal">Console</code>. Lastly, let's wait for user input before exiting.<div class="informalexample"><pre class="programlisting">try
{
    foreach (var number in results)
    {
        Console.WriteLine("Result: {0}", number);
    }
}
catch (OperationCanceledException)
{
    Console.WriteLine("The operation was cancelled");
}
catch (AggregateException aggregateException)
{
    foreach (var exception in aggregateException.InnerExceptions)
    {
        Console.WriteLine("Handled exception: {0}",exception.Message);
    }
}
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012,<a id="id303" class="indexterm"></a> press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_12.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec87"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>We used two separate <code class="literal">catch</code> blocks in this recipe because the parallel LINQ framework does not roll <code class="literal">OperationCanceledExceptions</code> into <code class="literal">AggregateException</code>; the <code class="literal">OperationCanceledException</code> must be handled in a separate <code class="literal">catch</code> block or it will be left unhandled.</p>
          <p>If you have one or more<a id="id304" class="indexterm"></a> delegates, throw <code class="literal">OperationCanceledException</code> by using <code class="literal">CancellationToken</code>, but don't throw any other exception. Then, parallel LINQ will just throw a single <code class="literal">OperationCanceledException</code> rather than <code class="literal">System.AggregateException</code>. However, if a delegate throws <code class="literal">OperationCanceledException</code> and another delegate throws another <code class="literal">Exception</code> type, then both exceptions will be rolled into <code class="literal">AggregateException</code>. So, whenever you create a PLINQ query using the <code class="literal">WithCancellation</code> extension method, it is recommended that you create two <code class="literal">catch</code> blocks: one for <code class="literal">OperationCancelledException</code> and one for <code class="literal">AggregateException</code>.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Performing reduction operations">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec48"></a>Performing reduction operations</h1>
            </div>
          </div>
        </div>
        <p>Like sequential LINQ, parallel LINQ provides many common aggregation operations such as sum, average, min, <a id="id305" class="indexterm"></a>and max. It is pretty easy to perform aggregate operations by using one of LINQs extension methods.</p>
        <p>Sometimes, however, we need to perform a custom aggregation of our source data, either because we need to perform a calculation that isn't provided in one of the standard aggregation extension methods, or because we need to apply custom logic to the calculation.</p>
        <p>For such cases, parallel LINQ provides us with a <code class="literal">aggregate</code> method which can apply a custom accumulator function in parallel over a sequence of data.</p>
        <p>In this recipe, we are going to create a custom aggregation operation that calculates the average of a large range of numbers.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec88"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how to perform custom aggregation with PLINQ.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">Average</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre>
</div></li>
              <li class="listitem">First, let's add some code to the <code class="literal">Main</code> method to create a range of random numbers.<div class="informalexample"><pre class="programlisting">var random = new Random();
var numbers = ParallelEnumerable.Range(1, 1000).OrderBy(i =&gt; random.Next()).ToArray();</pre>
</div></li>
              <li class="listitem">Now let's create a PLINQ query that calls the <code class="literal">Aggregate</code> extension method of <code class="literal">ParallelEnumerable</code> passing delegate to calculate the average to the <code class="literal">intermediateReduceFunc</code>, <code class="literal">finalReduceFunc</code>, and <code class="literal">resultSelector</code> parameters. <a id="id306" class="indexterm"></a>Display the results to <code class="literal">Console</code> and wait for user input before exiting.<div class="informalexample"><pre class="programlisting">var result = numbers.AsParallel().Aggregate(() =&gt; new double[2],
    (accumulator, elem) =&gt; { accumulator[0] += elem; accumulator[1]++; return accumulator; },
    (accumulator1, accumulator2) =&gt; { accumulator1[0] += accumulator2[0]; accumulator1[1] += accumulator2[1]; return accumulator1; },
    accumulator =&gt; accumulator[0] / accumulator[1]);</pre>
</div></li>
              <li class="listitem">Finish up by displaying the results to the <code class="literal">Console</code> and waiting for the user input before exiting.<div class="informalexample"><pre class="programlisting">Console.WriteLine("Result: {0}",result);
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_13.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec89"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>An aggregation operation is an operation that iterates over a sequence of input data elements, maintaining <a id="id307" class="indexterm"></a>an accumulator that contains an intermediate result. At each step, a reduction function takes the current element and accumulator value as inputs, and yields a value that will overwrite the accumulator. The final accumulator value is the result of the computation.</p>
          <p>The <code class="literal">ParallelEnumerable</code> class <a id="id308" class="indexterm"></a>provides several overloads of the <code class="literal">aggregate</code> extension method. We are using the following overload:</p>
          <div class="informalexample">
            <pre class="programlisting">public static TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(
  this ParallelQuery&lt;TSource&gt; source,
  Func&lt;TAccumulate&gt; seedFactory,
  Func&lt;TAccumulate, TSource, TAccumulate&gt; updateAccumulatorFunc,
  Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; combineAccumulatorsFunc,
  Func&lt;TAccumulate, TResult&gt; resultSelector
)</pre>
          </div>
          <p>The <code class="literal">seedFactory</code> function<a id="id309" class="indexterm"></a> returns the initial accumulator value. The <code class="literal">updateAccumularorFunc</code> parameter is an <a id="id310" class="indexterm"></a>
<code class="literal">accumulator</code> function to be invoked on each element in a partition. The <code class="literal">combineAccumulatorsFunc</code> parameter is an <code class="literal">accumulator</code> function<a id="id311" class="indexterm"></a> to be invoked on the yielded accumulator result from each partition. Finally, the <code class="literal">resultSelector</code> parameter<a id="id312" class="indexterm"></a> is a function to transform the final accumulator value into the result value.</p>
          <p>We have provided our own delegate for each of these function parameters.</p>
          <div class="informalexample">
            <pre class="programlisting">numbers.AsParallel().Aggregate(() =&gt; new double[2], //Seed factory
    (accumulator, elem) =&gt;  //Update accumulator function
  { 
    accumulator[0] += elem; 
    accumulator[1]++; 
    return accumulator; 
  },
    (accumulator1, accumulator2) =&gt;  //Combine accumulator function
  { 
    accumulator1[0] += accumulator2[0]; 
    accumulator1[1] += accumulator2[1]; 
    return accumulator1; 
  },
    accumulator =&gt; accumulator[0] / accumulator[1]); //Result selector function</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Creating a custom partitioner">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch04lvl1sec49"></a>Creating a custom partitioner</h1>
            </div>
          </div>
        </div>
        <p>To parallelize an operation on a data source, one of the essential steps is to partition the source into multiple sections that can be accessed concurrently by multiple threads. Parallel LINQ provides default partitioners that work quite well for most parallel queries. However, for more advanced<a id="id313" class="indexterm"></a> scenarios, you can also create your own partitioner.</p>
        <p>For the recipe, we will create a custom static partitioner which will split our data source into a variable number of partitioned chunks. The exact number of partitions will be specified by TPL itself, and will be made available to our custom partitioner by overriding the <code class="literal">Partitioner&lt;T&gt;</code> method. We will then test the performance of a query that uses default partitioning against the performance of a query using our custom partitioner.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec90"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's take a look <a id="id314" class="indexterm"></a>at how to partition data for a parallel query.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">CustomPartitioner</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add a new class the project and name it <code class="literal">CustomPartitioner.cs</code>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your <code class="literal">CustomPartitioner</code> class:<div class="informalexample"><pre class="programlisting">using System.Collections.Concurrent;
using System.Collections.Generic;</pre>
</div></li>
              <li class="listitem">Apply a generic type parameter to the <a id="id315" class="indexterm"></a><code class="literal">CustomPartitioner</code> class, and declare <code class="literal">Partitioner&lt;T&gt;</code> as its base class. Optionally, mark the class visibility as internal.<div class="informalexample"><pre class="programlisting">internal class CustomPartitioner&lt;T&gt; : Partitioner&lt;T&gt;
{

}</pre>
</div></li>
              <li class="listitem">Create a private source field of type array of <code class="literal">T</code> and initialize the source data with the <code class="literal">Class</code> constructor.<div class="informalexample"><pre class="programlisting">internal class CustomPartitioner&lt;T&gt; : Partitioner&lt;T&gt;
{
  private readonly T[] _source;

    // Class constructor. Initializes source data to array
  public CustomPartitioner(T[] sourceData)
    {
        _source = sourceData;
    }
}</pre>
</div></li>
              <li class="listitem">Override the <code class="literal">SupportsDynamicPartitions</code> property<a id="id316" class="indexterm"></a> of the base class to return <code class="literal">false</code>. This partitioner can only allocate partitions statically.<div class="informalexample"><pre class="programlisting">public override bool SupportsDynamicPartitions
{
    get
    {
        return false;
    }
}</pre>
</div></li>
              <li class="listitem">Add a <code class="literal">GetItems</code> method that returns <code class="literal">IEnumerator&lt;T&gt;</code> for the items in the source.<div class="informalexample"><pre class="programlisting">internal IEnumerator&lt;T&gt; GetItems(int start, int end)
{
    for (var index = start; index &lt; end; index++)
        yield return _source[index];
}</pre>
</div></li>
              <li class="listitem">Finish up<a id="id317" class="indexterm"></a> the <code class="literal">CustomPartitioner</code> class by overriding the <code class="literal">GetPartitions</code> method<a id="id318" class="indexterm"></a> of the base class. This method will return <code class="literal">List&lt;IEnumerable&lt;T&gt;&gt;</code> which is a list of our partitioned data.<div class="informalexample"><pre class="programlisting">public override IList&lt;IEnumerator&lt;T&gt;&gt; GetPartitions(int partitionCount)
{
    IList&lt;IEnumerator&lt;T&gt;&gt; partitionedData = new List&lt;IEnumerator&lt;T&gt;&gt;();
    var items = _source.Length / partitionCount;
    for (var index = 0; index &lt; partitionCount - 1; index++)
    {
        partitionedData.Add(GetItems(index * items, (index + 1) * items));
    }
    partitionedData.Add(GetItems((partitionCount - 1) * items, _source.Length));
    return partitionedData;
}</pre>
</div></li>
            </ol>
          </div>
          <p>That's it for the <code class="literal">CustomPartitioner</code> class<a id="id319" class="indexterm"></a>. Now let's go to the <code class="literal">Program</code> class:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of the class:<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class add some code to create a large array of <a id="id320" class="indexterm"></a>random numbers that we will use for the source of our query. Also, create a <code class="literal">stopWatch</code> object, which we will use to capture our performance numbers.<div class="informalexample"><pre class="programlisting">var stopWatch = new Stopwatch();
var random = new Random();
var source = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next()).ToArray();</pre>
</div></li>
              <li class="listitem">Next, let's start <code class="literal">stopWatch</code> and run a query against the source data to select the square of each number. This query uses default partitioning.<div class="informalexample"><pre class="programlisting">stopWatch.Start();
source.AsParallel()
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .Select(item =&gt; Math.Sqrt(item));
    stopWatch.Stop();
    Console.WriteLine("PLINQ with no partioner ran in {0} ticks", stopWatch.ElapsedTicks );</pre>
</div></li>
              <li class="listitem">Finally, let's reset <code class="literal">stopWatch</code>, run the query with our custom partitioner, display the results, and wait for user input before exiting.<div class="informalexample"><pre class="programlisting">var partitioner = new CustomPartitioner&lt;int&gt;(source);

stopWatch.Reset();
stopWatch.Start();

partitioner.AsParallel()
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .Select(item =&gt; Math.Sqrt(item));
            
stopWatch.Stop();
Console.WriteLine("PLINQ with custom partioner ran in {0} ticks", stopWatch.ElapsedTicks);

Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_04_14.png.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch04lvl2sec91"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In some cases, it might be worthwhile to create your own partitioner, but for the most part, the default partitioning <a id="id321" class="indexterm"></a>works pretty well.</p>
          <p>To create a basic custom partitioner, derive a class from <code class="literal">Partitioner&lt;TSource&gt;</code> which is located in <code class="literal">System.Collections.Concurrent</code>, and override a couple of virtual methods and a virtual property getter.</p>
          <p>We provided an override for the <a id="id322" class="indexterm"></a>
<code class="literal">SupportsDynamicPartitions</code> property to indicate that our simple custom partitioner only supports static partitions by returning <code class="literal">true</code>.</p>
          <div class="informalexample">
            <pre class="programlisting">public override bool SupportsDynamicPartitions
{
    get
    {
        return false;
    }
}</pre>
          </div>
          <p>If we had indicated that this partitioner does support dynamic partitions, we would want to provide an override for the <code class="literal">GetDynamicPartitions</code> method<a id="id323" class="indexterm"></a>, which can be called instead of <code class="literal">GetPartitions</code> for dynamic partitioners.</p>
          <p>In our case, we just had to provide an override for <code class="literal">GetPartitions</code>. This method returns <code class="literal">IList(IEnumerator(TSource))</code> which represents our actual partitioned data.</p>
          <div class="informalexample">
            <pre class="programlisting">public override IList&lt;IEnumerator&lt;T&gt;&gt; GetPartitions(int partitionCount)
{
    IList&lt;IEnumerator&lt;T&gt;&gt; partitionedData = new List&lt;IEnumerator&lt;T&gt;&gt;();
    var items = _source.Length / partitionCount;
    for (var index = 0; index &lt; partitionCount - 1; index++)
    {
        partitionedData.Add(GetItems(index * items, (index + 1) * items));
    }
    partitionedData.Add(GetItems((partitionCount - 1) * items, _source.Length));
    return partitionedData;
}</pre>
          </div>
          <p>Lastly, we provided a <code class="literal">GetItems</code> method<a id="id324" class="indexterm"></a> which is a helper that <code class="literal">GetPartitions</code> uses to get an enumerator for the<a id="id325" class="indexterm"></a> items in our source data.</p>
          <div class="informalexample">
            <pre class="programlisting">internal IEnumerator&lt;T&gt; GetItems(int start, int end)
{
    for (var index = start; index &lt; end; index++)
        yield return _source[index];
}</pre>
          </div>
        </div>
      </div>
    </div>
</body>
</html>