<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-39"><a id="_idTextAnchor063"/>2</h1>
<h1 id="_idParaDest-40"><a id="_idTextAnchor064"/>Introduction to Algorithms</h1>
<p>While reading the first chapter of this book, you learned about various data types. Now, it is high time to introduce the topic of algorithms. In this chapter, you will take a look at their <strong class="bold">definition</strong>, as well as some real-world <strong class="bold">examples</strong>, <strong class="bold">notations</strong>, and <strong class="bold">types</strong>. As you should take care of the performance of your applications, the subject of computational complexity of the algorithms, including time complexity, will also be presented and explained.</p>
<p>First, it is worth mentioning that the topic of algorithms is very broad and complex. You can easily find a lot of scientific publications about them on the internet, published by researchers from all over the world. The number of algorithms is enormous and it is almost impossible to even remember the names of all the commonly used ones. Of course, some algorithms are simple to understand and implement, while others are extremely complex and almost impossible to understand without deep knowledge of algorithmics, mathematics, and other dedicated field of science. There are also various classifications of algorithms by different key features, and there are a lot of types, including recursive, greedy, divide-and-conquer, back-tracking, and heuristic. However, for various algorithms, you can specify the computational complexity by stating how much time or space they require to operate with the increasing size of a processed input.</p>
<p>Does this sound overwhelming, complicated, and difficult? Don’t worry. In this chapter, I will try to introduce the topic of algorithms in a way that everyone can understand, not only mathematicians or other scientists. For this reason, in this chapter, you will find some simplifications to make this topic simpler and easier to follow. However, the aim is to introduce you to this topic and <strong class="bold">make you interested in algorithms</strong>, not create another research publication or book with a lot of formal definitions and formulas. Are you ready? Let’s get started!</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What are algorithms?</li>
<li>Notations for algorithm representation</li>
<li>Types of algorithms</li>
<li>Computational complexity</li>
</ul>
<h1 id="_idParaDest-41"><a id="_idTextAnchor065"/><a id="_idTextAnchor066"/>What are algorithms?</h1>
<p>Did you know <a id="_idIndexMarker165"/>you typically use algorithms every day and that you are already an author of some algorithms, even without writing any lines of code or drawing a diagram? If this sounds impossible, give me a few minutes and read this section to get to know how is it possible.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor067"/>Definition</h2>
<p>First, you need <a id="_idIndexMarker166"/>to know what an <strong class="bold">algorithm</strong> is. It is a <strong class="bold">well-defined solution for solving a particular problem or performing a computation</strong>. It is an ordered list of precise <strong class="bold">instructions</strong> that are performed in a given order and take a well-defined <strong class="bold">input</strong> into account (if any) to produce a well-defined <strong class="bold">output</strong>, as shown here:</p>
<div><div><img alt="Figure 2.1 – Illustration of an algorithm" src="img/B18069_02_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Illustration of an algorithm</p>
<p>To be more precise, <strong class="bold">an algorithm should contain a finite sequence of unambiguous instructions, which provides you with an effective and efficient way of solving the problem</strong>. Of course, an algorithm can contain <strong class="bold">conditional expressions</strong>, <strong class="bold">loops</strong>, or <strong class="bold">recursion</strong>.</p>
<p class="callout-heading">Where can you find more information?<a id="_idTextAnchor068"/></p>
<p class="callout">If you are interested in the topic of algorithms, you can find a lot of detailed information about them in many books, including <em class="italic">Introduction to Algorithms</em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Of course, there are also many resources available online, such as <em class="italic">GeeksForGeeks</em> (<a href="https://www.geeksforgeeks.org">https://www.geeksforgeeks.org</a>), <em class="italic">The Algorithms</em> (<a href="https://the-algorithms.com">https://the-algorithms.com</a>), and <em class="italic">Algorithms, 4th Edition</em>, by Robert Sedgewick and Kevin Wayne (<a href="https://algs4.cs.princeton.edu">https://algs4.cs.princeton.edu</a>). A huge number of resources is also available if you browse the <em class="italic">Algorithms</em> topic on GitHub (<a href="https://github.com/topics/algorithms">https://github.com/topics/algorithms</a>). I strongly encourage you to search for various resources, either in books or over the internet, and continue learning about algorithms when you’ve finished reading this book.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor069"/>Real-world examples</h2>
<p>With the definition <a id="_idIndexMarker167"/>of algorithms under your belt, you might be thinking, “<em class="italic">Come on – inputs, outputs, instructions… where I can find them?</em>” The answer turns out to be much simpler than you might expect because you can find such items almost everywhere, all the time!</p>
<p>Let’s start with a <strong class="bold">simple morning routine</strong>. First, you wake up and take a look at your phone. If there are any notifications, you go through them and reply to urgent messages. For any unurgent items, you postpone them. Then, you go to the bathroom. If it is occupied, you wait until it is free, telling the person inside to hurry up. As soon as you are in the bathroom, you take a shower and brush your teeth. Finally, you choose suitable clothes according to the current weather and temperature. Surprise! Your morning routine is an algorithm. You can describe it as a set of instructions, which has some inputs, such as notifications and the current temperature, as well as outputs, such as chosen clothes. What’s more, some of the instructions are conditional, such as only replying to urgent messages. Others can be executed in a loop, such as waiting until the bathroom is vacant.</p>
<p>The preceding morning routine also contains other algorithms, such as those for <strong class="bold">unlocking a smartphone using face recognition</strong>. It is an algorithm-based mechanism that you can use to ensure that only you can unlock your phone. What’s more, even <strong class="bold">organizing notifications on your phone</strong> is the result of an algorithm that takes into account notifications as input, arranges them into groups, and sorts them suitably before presenting them to you.</p>
<p>At this point, you are dressed up and ready for a healthy and yummy breakfast. Imagine that you want to <strong class="bold">prepare scrambled eggs</strong> using your grandma’s secret recipe. You need some ingredients, namely three eggs, salt, and pepper. As a result, you will have created an amazing dish for your perfect breakfast. First, you crack the eggs into a bowl and whisk them with a pinch of salt and pepper. Then, you melt butter in a non-stick skillet over medium-low heat. Next, you pour the egg mixture into the skillet and keep the eggs moving <a id="_idIndexMarker168"/>until there is no liquid egg. With that, your breakfast is ready. However, what is it if not a well-written and organized algorithm with a precise input and yummy output?</p>
<p>After breakfast, you need to go to work. So, you jump into your car and launch a navigation app on your smartphone to see <strong class="bold">the fastest route to work</strong> while taking the current traffic <a id="_idIndexMarker169"/>into account. This task is performed by complicated algorithms that can even involve <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>), together with a computer-understandable representation of routes that use specialized data structures, as well as data obtained from other users. When combined, this forms traffic data. As you can see, the algorithm takes the complex input and performs various calculations to present you with an ordered list of route directions – for example, go to route A4, turn right to route S19, and follow this route until you reach your destination.</p>
<p>While at work, you need to prepare documents for your accountant, so you need to gather documents from colleagues, print some of them from emails, and then <strong class="bold">sort all invoices by numbers</strong>. How do you perform sorting? You take the first document from the stack and put it on the table. Then, you take the second document from the unsorted stack and put it either above, if the number is smaller than the first invoice, or below the previous one. Then, you take the third invoice and find a suitable place for it in the ordered stack. You perform this operation until there are no documents in the unsorted stack. Wow, another algorithm? Exactly! This is one of <strong class="bold">sorting algorithms</strong>. You'll learn about them in the next chapter.</p>
<p>It’s time for a break at work! You launch your favorite social app and <strong class="bold">receive suggestions for new friends</strong>. However, how are they found and proposed to you? Yes, you’re right – this is another algorithm that takes data from your profile and your activities, as well <a id="_idIndexMarker170"/>as the data of available users, as input, and returns a collection of best-suited suggestions for you. It can use many complex and advanced techniques, such as <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) algorithms, which can learn and take your previous reactions into account. Just think for a second about the data structures that can be used in such cases. How you can organize your relationships with friends and how can you find out how many other people are between you and your favorite actor from Hollywood? It would be great to know that your friend knows Mary, who knows Adam, who is a friend of your idol, wouldn’t it? Such a task can be accomplished using <a id="_idIndexMarker171"/>some graph-based structures, as you will see later in this book.</p>
<p class="callout-heading">Will you learn about AI algorithms in this book?</p>
<p class="callout">Unfortunately, no. Due to the limited number of pages, various algorithms related to AI are not included in this book. However, note that it is a very interesting topic that involves many <a id="_idIndexMarker172"/>concepts, such as <strong class="bold">ML</strong> and <strong class="bold">deep learning</strong> (<strong class="bold">DL</strong>), which are used in many applications, including recommendation systems, speech-to-text, searching <a id="_idIndexMarker173"/>over extremely high amounts of data (the concept of <strong class="bold">big data</strong>), generating textual and graphical content, as well as controlling self-driving cars. To achieve these goals, a lot of interesting algorithms are used. I strongly encourage you to take a look at this topic on your own or choose one of Packt’s books that focuses on AI-related topics.</p>
<p>Are these examples enough? If not, just think about <strong class="bold">choosing a movie in a cinema for the evening</strong> while considering the AI-based suggestions of movies with geolocation-based data of cinemas, or <strong class="bold">setting a clock alarm</strong> depending on your plan for the next day. As you can see, <strong class="bold">algorithms are everywhere and all of us use them, even if we do not </strong><strong class="bold">realize it</strong>.</p>
<p>So, if algorithms are so common and so useful, why don’t we benefit from the huge collection of ones that are available or even write our own algorithms? There are still some problems that need to be solved using algorithms. I, as the author of this book, am keeping my fingers crossed for you to solve them!</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor070"/>Notations for algorithm representation</h1>
<p>In the <a id="_idIndexMarker174"/>previous section, algorithms were presented in English. However, this is not the only way of specifying and documenting an algorithm. In this section, you will learn about four notations for algorithm representation, namely <strong class="bold">natural language</strong>, <strong class="bold">flowchart, pseudocode</strong>, and <strong class="bold">programming language</strong>.</p>
<p>To make this <a id="_idIndexMarker175"/>task easier to understand, you will specify the algorithm for calculating an <strong class="bold">arithmetic mean</strong> in all of these notations. As a reminder, the mean can be calculated using the following formula:</p>
<div><div><img alt="Figure 2.2 – Formula for calculating an arithmetic mean" src="img/B18069_02_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Formula for calculating an arithmetic mean</p>
<p>As you <a id="_idIndexMarker176"/>can see, two inputs are used, namely the provided numbers (<em class="italic">a</em>) and the total number of elements (<em class="italic">n</em>). If no numbers are provided, <code>null</code> is returned, indicating that no mean is available. Otherwise, you sum the numbers and divide them by the total number of elements to get the result.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor071"/>Natural language</h2>
<p>First, let’s specify the algorithm using a natural language. It is a very easy way of providing <a id="_idIndexMarker177"/>information about algorithms, but it can be ambiguous and unclear. So, let’s describe our algorithm in this way:</p>
<p><em class="italic">The algorithm reads the input, which represents the total number of elements from which an arithmetic mean will be calculated. If the entered number is equal to 0, the algorithm should return null. Otherwise, it should read the numbers in the amount equal to the expected total count. Finally, it should return the result as the sum of numbers divided by </em><em class="italic">their count.</em></p>
<p>Quite simple and understandable, isn’t it? You can use this notation for simple algorithms, but it can be useless for complex and advanced algorithms. Of course, some descriptions in the natural language are often useful, regardless of the complexity of an algorithm. They can give you a brief understanding of what the aim of the algorithm is, how it works, and what aspects should be taken into account while you’re analyzing or implementing the algorithm.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor072"/>Flowchart</h2>
<p>Another way <a id="_idIndexMarker178"/>of presenting an algorithm is via a <strong class="bold">flowchart</strong>. A flowchart <a id="_idIndexMarker179"/>uses a set of graphical elements to prepare a diagram that specifies the algorithm’s operation. Some of the available symbols are as follows:</p>
<div><div><img alt="Figure 2.3 – The available symbols while designing a flowchart" src="img/B18069_02_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – The available symbols while designing a flowchart</p>
<p>The algorithm should contain the <strong class="bold">entry point</strong> and one or more <strong class="bold">exit points</strong>. It can also contain other blocks, including <strong class="bold">operation</strong>, <strong class="bold">input</strong>, <strong class="bold">output</strong>, or <strong class="bold">condition</strong>. The following blocks are connected with <strong class="bold">arrows</strong> that specify the order of execution. You can also draw <strong class="bold">loops</strong>.</p>
<p>Let’s take a look at a flowchart for calculating the arithmetic mean:</p>
<div><div><img alt="Figure 2.4 – Flowchart for calculating the arithmetic mean" src="img/B18069_02_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Flowchart for calculating the arithmetic mean</p>
<p>The execution starts in the <code>START</code> block. Then, we assign <code>0</code> as a value of the <code>sum</code> variable, which stores the sum of all the entered numbers. Next, we read a value from the input and <a id="_idIndexMarker180"/>store it as a value of the <code>n</code> variable. This is the total number of elements used to calculate the arithmetic mean. Next, we check <a id="_idIndexMarker181"/>whether <code>n</code> is equal to <code>0</code>. If so, the <code>YES</code> branch is chosen, <code>null</code> is returned to the output, and the execution stops. If <code>n</code> is not equal to <code>0</code>, the <code>NO</code> branch is chosen and we assign <code>0</code> as a value of the <code>i</code> variable. It stores the number of elements already read from the input. Next, we read the number from the input and save it as a value of the <code>a</code> variable. The following operation block increases <code>sum</code> by the value of <code>a</code>, as well as increments the value of <code>i</code>.</p>
<p>The next block is a conditional one that checks whether <code>i</code> is not equal to <code>n</code>, which means that the required number of elements is not read from the input yet. If <code>i</code> is equal to <code>n</code>, the <code>NO</code> branch is chosen and a value of the <code>result</code> variable is set to a result of a division of <code>sum</code> by <code>n</code>. Then, the <code>result</code> variable is returned and the execution stops. An interesting construction is used when the conditional expression evaluates to <code>true</code>, which means that we need to read another input. Then, the loop is used and the execution comes back just before the input block for reading <code>a</code>. Thus, we can execute some operations multiple times, until the condition is met.</p>
<p>As you can see, a flowchart is a diagram that makes it possible to specify a way of algorithm operation in a more precise way than using natural language. It is an interesting option for simple algorithms, but it can be quite cumbersome in the case of advanced and complex ones, where it is impossible to present the whole operation within a diagram of a reasonably small size.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor073"/>Pseudocode</h2>
<p>The next <a id="_idIndexMarker182"/>notation we’ll look at is <strong class="bold">pseudocode</strong>. It allows you to specify algorithms <a id="_idIndexMarker183"/>in another way, which is a bit similar to the code written in a programming language. Here, we use the English language to define inputs and outputs, as well as to present a set of instructions clearly and concisely, but without the syntax of any programming language.</p>
<p>Here’s some example pseudocode for calculating the arithmetic mean:</p>
<pre class="source-code">
<strong class="bold">INPUT:</strong>
n – total number of elements used for mean calculation.
a – the following numbers entered by a user.
<strong class="bold">OUTPUT:</strong>
result - arithmetic mean of the entered numbers.
<strong class="bold">INSTRUCTIONS:</strong>
sum &lt;- 0
read n
if n = 0 then
   return null
endif
i &lt;- 0
do
   read a
   sum &lt;- sum + a
   i &lt;- i + 1
while i &lt;&gt; n
result &lt;- sum / n
return result</pre> <p>As you <a id="_idIndexMarker184"/>can see, the pseudocode provides us <a id="_idIndexMarker185"/>with a syntax that is easy to understand and follow, as well as quite close to a programming language. For this reason, it is a precise way of algorithm presentation and documentation that can be later used to transform it into a set of instructions in our chosen programming language.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor074"/>Programming language</h2>
<p>Now, let’s look at the last form of algorithm notation: <strong class="bold">programming language</strong>. It is very precise, can be compiled and run. Thus, we can see the result of its operation and check it using a set of test cases. Of course, we <a id="_idIndexMarker186"/>can implement an algorithm in any programming language. However, in this book, you will see only examples in the C# language.</p>
<p>Let’s take a look at the implementation of the mean calculation algorithm:</p>
<pre class="source-code">
double sum = 0;
Console.Write("n = ");
int.TryParse(Console.ReadLine(), out int n);
if (n == 0) { Console.WriteLine("No result."); }
int i = 0;
do
{
    Console.Write("a = ");
    double.TryParse(Console.ReadLine(), out double a);
    sum += a;
    i++;
}
while (i != n);
double result = sum / n;
Console.WriteLine($"Result: {result:F2}");</pre> <p>The preceding code contains an <code>if</code> conditional statement and a <code>do-while</code> loop.</p>
<p>If we run the application, we need to enter the number of elements from which we would like to calculate the arithmetic mean. Then, we will be asked to enter the number <code>n</code> times. When the number of provided elements is equal to the expected value, the result is calculated and presented in the console, as follows:</p>
<pre class="console">
n = 3
a = 1
a = 5
a = 10
Result: 5.33</pre> <p>That’s all! Now, you know what algorithms are, where you can find them in your <a id="_idIndexMarker187"/>daily life, as well as how to represent algorithms <a id="_idIndexMarker188"/>using natural language, flowcharts, pseudocode, and programming languages. With this knowledge, let’s proceed to learn about different types of algorithms, including recursive and heuristic algorithms.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor075"/>Types of algorithms</h1>
<p>As mentioned previously, algorithms are almost everywhere, and even intuitively, you use them each <a id="_idIndexMarker189"/>day while solving various tasks. There is an enormous amount of algorithms and a lot of their types, chosen according to different criteria. To simplify this topic, only a few types will be presented here, chosen from different classifications, to show you a variety and encourage you to learn more about them on your own. It is also quite common that the same algorithm is classified into a few groups.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor076"/>Recursive algorithms</h2>
<p>First, let’s <a id="_idIndexMarker190"/>take a look at <strong class="bold">recursive algorithms</strong>, which <a id="_idIndexMarker191"/>are strictly connected with the idea of <strong class="bold">recursion</strong> and are <a id="_idIndexMarker192"/>the opposite of <strong class="bold">iterative algorithms</strong>. What does this mean? <strong class="bold">An algorithm is recursive if it calls itself to solve smaller subproblems of the original problem</strong>. The algorithm calls itself multiple times until the <strong class="bold">base condition</strong> is met.</p>
<p>This technique provides you with a powerful solution for solving problems, can limit the amount of code, and can be easy to understand and maintain. However, recursion has some drawbacks <a id="_idIndexMarker193"/>related to performance or the requirement <a id="_idIndexMarker194"/>for more space in the stack’s memory, which could lead to stack overflow problems. Fortunately, you can prevent some of these issues using <strong class="bold">dynamic programming</strong>, an optimization technique that supports recursion.</p>
<p>Recursion can be used in several algorithms, including the following:</p>
<ul>
<li>Sorting an array with the <strong class="bold">merge sort</strong> and <strong class="bold">quicksort</strong> algorithms, which are implemented and presented in detail in <a href="B18069_03.xhtml#_idTextAnchor088"><em class="italic">Chapter 3</em></a>, <em class="italic">Arrays </em><em class="italic">and Sorting</em></li>
<li>Solving the <strong class="bold">Towers of Hanoi</strong> game, as depicted in <a href="B18069_05.xhtml#_idTextAnchor165"><em class="italic">Chapter 5</em></a>, <em class="italic">Stacks </em><em class="italic">and Queues</em></li>
<li><strong class="bold">Traversing a tree</strong>, as described in <a href="B18069_07.xhtml#_idTextAnchor233"><em class="italic">Chapter 7</em></a>, <em class="italic">Variants </em><em class="italic">of Trees</em></li>
<li>Getting a number from the <strong class="bold">Fibonacci series</strong>, as shown in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em></li>
<li><strong class="bold">Generating fractals</strong>, as shown in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em></li>
<li>Calculating a <code>n!</code>)</li>
<li>Getting the <strong class="bold">greatest common divisor of two numbers</strong> using the Euclidean algorithm</li>
<li><strong class="bold">Traversing the filesystem</strong> with directories and subdirectories</li>
</ul>
<h2 id="_idParaDest-51"><a id="_idTextAnchor077"/>Divide and conquer algorithms</h2>
<p>Another <a id="_idIndexMarker195"/>group of algorithms is named <strong class="bold">divide and conquer</strong>. It is <a id="_idIndexMarker196"/>related to the <strong class="bold">algorithmic paradigm of solving a problem by breaking it down into smaller subproblems (the “divide” step), calling them recursively until they are simple enough to be solved directly (“conquer”), and combining the results of subproblems to get the final result (“combine”)</strong>. This approach has many advantages, also taken from the pros of recursion, including ease of implementation, understanding, and maintenance. By dividing the problem into many subproblems, it supports <strong class="bold">parallel computing</strong>, which <a id="_idIndexMarker197"/>can lead to performance improvements. Unfortunately, this paradigm also has some disadvantages, including the necessity for a proper base case definition to terminate the execution of the algorithm. Performance issues, similar as in the case of recursive algorithms, can exist as well.</p>
<p>Divide and <a id="_idIndexMarker198"/>conquer is a popular approach for solving <a id="_idIndexMarker199"/>various algorithmic problems and you can see its implementations in a broad range of applications:</p>
<ul>
<li>Sorting an array with the <strong class="bold">m</strong><strong class="bold">erge sort</strong> and <strong class="bold">quicksort</strong> algorithms, which are implemented and presented in detail in <a href="B18069_03.xhtml#_idTextAnchor088"><em class="italic">Chapter 3</em></a>, <em class="italic">Arrays </em><em class="italic">and Sorting</em></li>
<li><strong class="bold">Finding the closest pair of points</strong> located on the two-dimensional surface, which will be presented in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em></li>
<li>Calculating the <strong class="bold">power of </strong><strong class="bold">a number</strong></li>
<li>Finding the <strong class="bold">minimum and maximum values</strong> in an array</li>
<li>Calculating the <strong class="bold">fast </strong><strong class="bold">Fourier transform</strong></li>
<li><strong class="bold">Multiplying large numbers</strong> using Karatsuba’s algorithm</li>
</ul>
<h2 id="_idParaDest-52"><a id="_idTextAnchor078"/>Back-tracking algorithms</h2>
<p>Next, we’ll <a id="_idIndexMarker200"/>cover <strong class="bold">back-tracking algorithms</strong>. <strong class="bold">They are used for solving problems that consist of a sequence of decisions, each depending on the decisions that have already been taken, incrementally building the solution. When you realize that the decisions that have been taken do not provide the correct solution, you </strong><strong class="bold">backtrack</strong>. Of course, you can <a id="_idIndexMarker201"/>support this approach with recursion to try various variants and therefore find a suitable solution, if one exists.</p>
<p>You can use this approach for many tasks, including the following:</p>
<ul>
<li>Solving the <strong class="bold">rat in a maze</strong> problem, as shown in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em></li>
<li>Solving <strong class="bold">Sudoku</strong>, as shown in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em></li>
<li>Solving <strong class="bold">crosswords</strong> by entering letters into empty spaces</li>
<li>Solving the <strong class="bold">eight queens </strong>problem of placing eight queens on a chessboard and not <a id="_idIndexMarker202"/>allowing them to attack each other</li>
<li>Solving the <strong class="bold">knight’s tour</strong>, where you place a knight on the first block on a chessboard <a id="_idIndexMarker203"/>and move it so that it visits all blocks exactly once</li>
<li>Generating <strong class="bold">gray codes</strong> to create bit patterns where the following ones differ by one bit only</li>
<li>Solving the <strong class="bold">m-coloring problem</strong> for graph-related topics</li>
</ul>
<h2 id="_idParaDest-53"><a id="_idTextAnchor079"/>Greedy algorithms</h2>
<p>Now that <a id="_idIndexMarker204"/>we’ve covered the recursive, divide-and-conquer, and back-tracking <a id="_idIndexMarker205"/>algorithms, it’s high time to present another type, namely greedy algorithms. <strong class="bold">A </strong><strong class="bold">greedy algorithm</strong><strong class="bold"> builds the solution piece by piece by choosing the best option in each step, not concerned about the overall solution, and being short-sighted in its operation</strong>. For this reason, there is no guarantee that the final result is optimal. However, in many scenarios, using the local optimal solutions can lead to global optimal solutions or can be good enough.</p>
<p>Here are <a id="_idIndexMarker206"/>some examples:</p>
<ul>
<li>Finding the shortest path in a graph using <strong class="bold">Dijkstra’s algorithm</strong>, as shown and explained in detail in <a href="B18069_08.xhtml#_idTextAnchor296"><em class="italic">Chapter 8</em></a>, <em class="italic">Exploring Graphs</em></li>
<li>Calculating the minimum spanning tree in a graph with <strong class="bold">Kruskal’s algorithm</strong> and <strong class="bold">Prim’s algorithm</strong>, as shown in <a href="B18069_08.xhtml#_idTextAnchor296"><em class="italic">Chapter 8</em></a>, <em class="italic">Exploring Graphs</em></li>
<li>Solving the <strong class="bold">minimum coin change</strong> problem, as explained in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em></li>
<li>The greedy approach to <strong class="bold">Huffman coding</strong> in <strong class="bold">data </strong><strong class="bold">compression algorithms</strong></li>
<li><strong class="bold">Load balancing</strong> and <strong class="bold">network routing</strong></li>
</ul>
<h2 id="_idParaDest-54"><a id="_idTextAnchor080"/>Heuristic algorithms</h2>
<p>Now, it’s time <a id="_idIndexMarker207"/>to add more “magic” to your algorithms via heuristics! <strong class="bold">A </strong><strong class="bold">heuristic algorithm</strong><strong class="bold"> calculates a near-optimal solution for an optimization problem and is especially useful for scenarios when the exact methods are not available or are too slow. Thus, you can see a significant speed boost, but with a decreased accuracy of the result.</strong> Such an approach is popular and <a id="_idIndexMarker208"/>adequate for solving various real-world problems, often complex and big, and is applied in many different fields of science, even those regarding bioinformatics.</p>
<p>Heuristic <a id="_idIndexMarker209"/>algorithms have many applications and subtypes:</p>
<ul>
<li><strong class="bold">Genetic algorithms</strong>, which are <strong class="bold">adaptive heuristic search algorithms</strong>, and <a id="_idIndexMarker210"/>can be used to guess the title of this book, as depicted in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em></li>
<li>Solving <strong class="bold">vehicle routing problems</strong> and the <strong class="bold">traveling salesman problem</strong> with the <strong class="bold">Tabu </strong><strong class="bold">Search algorithm</strong></li>
<li>Solving the <strong class="bold">Knapsack problem</strong>, where you need to choose items of the maximum total value to be packed within the mass limit</li>
<li><strong class="bold">Filtering and </strong><strong class="bold">processing signals</strong></li>
<li><strong class="bold">Detecting viruses</strong></li>
</ul>
<h2 id="_idParaDest-55"><a id="_idTextAnchor081"/>Dynamic programming</h2>
<p>Since we’re <a id="_idIndexMarker211"/>talking about various types of algorithms, it is <a id="_idIndexMarker212"/>worth mentioning <strong class="bold">dynamic programming</strong>. It is a <strong class="bold">technique that optimizes recursive algorithms by limiting the necessity of computing the same result multiple times</strong>. This technique can be used in one of two approaches:</p>
<ul>
<li>The <strong class="bold">top-down approach</strong>, which <a id="_idIndexMarker213"/>uses <strong class="bold">memoization</strong> to save <a id="_idIndexMarker214"/>the results of subproblems. Therefore, the <a id="_idIndexMarker215"/>algorithm can use the value from the cache and does not need to recalculate the same results multiple times or does not need to call the method with the same parameters multiple times.</li>
<li>The <strong class="bold">bottom-up approach</strong>, which uses <strong class="bold">tabulation</strong> to <a id="_idIndexMarker216"/>replace recursion <a id="_idIndexMarker217"/>with iteration. It limits the number <a id="_idIndexMarker218"/>of function calls and problems regarding stack overflow.</li>
</ul>
<p>Both of <a id="_idIndexMarker219"/>these approaches can significantly decrease the time complexity and increase performance, and therefore speed up <a id="_idIndexMarker220"/>your algorithm. Every time you use recursion, it is a good idea to try to optimize it using dynamic programming. If you want to learn how to optimize calculating a number from the <strong class="bold">Fibonacci series</strong>, go to <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See </em><em class="italic">in Action</em>.</p>
<p>You can also use dynamic programming to find the <strong class="bold">shortest path between all pairs of vertices in a graph</strong> by using the <strong class="bold">Floyd-Warshall algorithm</strong>, as well as in <strong class="bold">Dijkstra’s algorithm</strong>. Another application is for solving the <strong class="bold">Tower of Hanoi</strong> mathematical game. Possibilities are even broader and you can also apply it to <strong class="bold">artificial </strong><strong class="bold">neural networks</strong>.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor082"/>Brute-force algorithms</h2>
<p>While we’re <a id="_idIndexMarker221"/>presenting various types of algorithms, we should also consider brute-force algorithms. <strong class="bold">A </strong><strong class="bold">brute-force algorithm</strong><strong class="bold"> is a general solution for solving a problem by checking all possible options and choosing the best one</strong>. It is an approach that can have huge time complexity and its operation <a id="_idIndexMarker222"/>can take a lot of time, so it can be useless in real-world scenarios. However, a brute-force algorithm is often the first choice when you need to solve some algorithmic problem. There’s nothing bad in doing this as you can learn more about the domain of the problem you wish to solve and see some results for simpler cases. Nevertheless, while developing an algorithm, it is a good idea to enhance it significantly by using other paradigms.</p>
<p>Here are some <a id="_idIndexMarker223"/>examples of where you can use brute-force algorithms:</p>
<ul>
<li><strong class="bold">Guessing a password</strong>, where you check each possible password one after the other, as presented in <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a><em class="italic">,</em> <em class="italic">See </em><em class="italic">in Action</em></li>
<li><strong class="bold">Finding the minimum value in an unsorted array</strong>, where you need to iterate through all items as there is no relationship between values in the array</li>
<li><strong class="bold">Finding the best possible plan for a day</strong>, placing various tasks between meetings, and <a id="_idIndexMarker224"/>trying to organize it in a way that you can start working late and ending early</li>
<li>Solving the <strong class="bold">traveling </strong><strong class="bold">salesman</strong> problem</li>
</ul>
<p>After introducing a few types of algorithms, you can see that some of them provide you with a faster solution while others can have huge time complexity. But what does this mean? You will learn about computational complexity, especially time complexity, in the next section.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor083"/>Computational complexity</h1>
<p>In this final section, let’s take a look at the <strong class="bold">computational complexity</strong> of algorithms, focusing <a id="_idIndexMarker225"/>on both <strong class="bold">time complexity</strong> and <strong class="bold">space complexity</strong>. Why is this so important? Because it can decide whether your algorithm can be used in real-world scenarios. As an example, which of the following do you prefer?</p>
<ul>
<li><em class="italic">(A) Absolutely the best route directions to work, but you receive them after an hour, when you are already </em><em class="italic">at work.</em></li>
<li><em class="italic">(B) Good enough route directions to work, but you receive them within a few seconds, a moment after you enter </em><em class="italic">your car.</em></li>
</ul>
<p>I am sure that you chose <em class="italic">B</em> – me too!</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor084"/>Time complexity</h2>
<p>First, let’s <a id="_idIndexMarker226"/>focus on <strong class="bold">time complexity</strong>, which <a id="_idIndexMarker227"/>indicates <strong class="bold">the amount of time necessary to run an algorithm as a function of the input length</strong>, namely <em class="italic">n</em>. You can specify <a id="_idIndexMarker228"/>it using <strong class="bold">asymptotic analysis</strong>. This includes <strong class="bold">Big-O notation</strong>, which is <a id="_idIndexMarker229"/>used to indicate <strong class="bold">how much time the algorithm will take with the increasing size of </strong><strong class="bold">the input</strong>.</p>
<p>For example, if you search for the minimum value in an unsorted array of size <em class="italic">n</em>, you need to visit all elements so that the maximum number of operations is equal to <em class="italic">n</em>, which is written as <em class="italic">O(n)</em>. If the algorithm iterates through each item in a two-dimensional array of size <em class="italic">n x n</em>, the time complexity is <em class="italic">O(n*n)</em>, so it is <em class="italic">O(n</em>2<em class="italic">)</em>.</p>
<p>There are <a id="_idIndexMarker230"/>various time complexities, including <a id="_idIndexMarker231"/>the ones presented here:</p>
<div><div><img alt="Figure 2.5 – Illustration of time complexities" src="img/B18069_02_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Illustration of time complexities</p>
<p>The first is <strong class="bold">O(1)</strong> and is named the <strong class="bold">constant time</strong>. It indicates an algorithm whose execution time does <a id="_idIndexMarker232"/>not depend on the input size. The exemplary operations consistent with the <em class="italic">O(1)</em> constraint are getting an <em class="italic">i</em>-th element from an array, checking whether a hash set contains a given value, or checking whether a number is even or odd.</p>
<p>The next time <a id="_idIndexMarker233"/>complexity shown here is <strong class="bold">O(log n)</strong>, which is named the <strong class="bold">logarithmic time</strong>. In this case, the execution time is not constant, but it increases slower than in the linear approach. A well-known example of the <em class="italic">O(log n)</em> constraint is the problem of finding an item in a sorted array with binary search.</p>
<p>The third case is <strong class="bold">O(n)</strong> and is <a id="_idIndexMarker234"/>named the <strong class="bold">linear time</strong>. Here, the execution time increases linearly with the input length. You can take an algorithm for finding the minimum or maximum value in an unordered list or simply finding a given value in an unordered list as examples of the <em class="italic">O(n)</em> constraint.</p>
<p>The last time complexity <a id="_idIndexMarker235"/>shown here is the <strong class="bold">polynomial time</strong>, which is <strong class="bold">O(n</strong>m<strong class="bold">)</strong>, so it <a id="_idIndexMarker236"/>can be <em class="italic">O(n</em>2<em class="italic">)</em> (<strong class="bold">quadratic time</strong>), <em class="italic">O(n</em>3<em class="italic">)</em> (<strong class="bold">cubic time</strong>), and so <a id="_idIndexMarker237"/>on. In this case, the execution time increases much faster than in the case of the linear constraint. It can involve solutions that use nested loops. Examples include the bubble sort, insertion sort, and selection sort algorithms. We'll <a id="_idIndexMarker238"/>cover <a id="_idIndexMarker239"/>these in <a href="B18069_03.xhtml#_idTextAnchor088"><em class="italic">Chapter 3</em></a>, <em class="italic">Arrays </em><em class="italic">and Sorting</em>.</p>
<p>Of <a id="_idIndexMarker240"/>course, there <a id="_idIndexMarker241"/>are even <a id="_idIndexMarker242"/>more time complexities <a id="_idIndexMarker243"/>available, among <a id="_idIndexMarker244"/>which <a id="_idIndexMarker245"/>you will find <strong class="bold">double logarithmic time</strong>, <strong class="bold">polylogarithmic time</strong>, <strong class="bold">fractional power time</strong>, <strong class="bold">linearithmic time</strong>, <strong class="bold">exponential time</strong>, and <strong class="bold">factorial time</strong>.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor085"/>Space complexity</h2>
<p>Similar to <a id="_idIndexMarker246"/>time complexity, you can specify the <strong class="bold">space complexity</strong> using <a id="_idIndexMarker247"/>asymptotic analysis and the Big-O notation. Space complexity indicates <strong class="bold">how much memory is necessary to run the algorithm with the increasing <a id="_idTextAnchor086"/>length of input</strong>. You can use similar indicators, such as <em class="italic">O(1)</em>, <em class="italic">O(n)</em>, or <em class="italic">O(n</em>2<em class="italic">)</em>.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">In this chapter, only a very brief introduction to the subject of algorithms was presented. I strongly encourage you to try to broaden your knowledge regarding algorithms on your own. It is an extremely interesting and challenging topic. For example, you can learn more about various types of algorithms at <a href="https://www.techtarget.com/whatis/definition/algorithm">https://www.techtarget.com/whatis/definition/algorithm</a> and at <a href="https://www.geeksforgeeks.org/most-important-type-of-algorithms/">https://www.geeksforgeeks.org/most-important-type-of-algorithms/</a>, while about the computational complexity at <a href="https://en.wikipedia.org/wiki/Computational_complexity">https://en.wikipedia.org/wiki/Computational_complexity</a>. I am keeping my fingers crossed for you success with algorithms!</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor087"/>Summary</h1>
<p>You’ve just completed the second chapter of this book, which was all about data structures and algorithms in the C# language. This time, we focused on algorithms and indicated their crucial role in the development of various applications, regardless of their types.</p>
<p>First, you learned <strong class="bold">what an algorithm is</strong> and <strong class="bold">where you can find algorithms</strong> in your daily life. As you saw, algorithms are almost everywhere and you use and design them without even knowing it.</p>
<p>Then, you learned about <strong class="bold">notations for algorithm representation</strong>. There, you learned how to specify algorithms in a few ways, namely in a natural language, using a flowchart, via pseudocode, or directly in a programming language.</p>
<p>Next, you learned <strong class="bold">about a few different types of algorithms</strong>, starting with the recursive algorithms that call themselves to solve smaller subproblems. Then, you learned about <strong class="bold">divide and conquer</strong> algorithms, which divide the problem into three stages, namely divide, conquer, and combine. Next, you learned about <strong class="bold">back-tracking</strong> algorithms, which allow you to solve problems consisting of a sequence of decisions, each depending on a decision that’s already been taken, together with the backtrack option if the decisions do not provide a correct solution. Then, you learned about <strong class="bold">greedy</strong> algorithms, which choose the best option in each step of their operation while not being concerned about the overall solution. Another group you learned about was <strong class="bold">heuristic</strong> algorithms for finding near-optimal solutions. Then, you learned that you can optimize recursive algorithms using <strong class="bold">dynamic programming</strong> and its top-down and bottom-up approaches. Finally, you learned about <strong class="bold">brute-force</strong> algorithms.</p>
<p>The final part of this chapter looked at <strong class="bold">computational complexity</strong> in terms of time and space complexity. Asymptotic analysis, together with Big-O notation, was presented.</p>
<p>In the next chapter, we’ll cover <strong class="bold">arrays</strong> and various <strong class="bold">sorting algorithms</strong>. Are you ready to continue your adventure with data structures and algorithms in the C# language? If so, let’s go!</p>
</div>
</body></html>