- en: Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we explored the Factory Method, a direct, straightforward,
    variation of the Factory pattern. Now, we will implement a more advanced version
    of the Factory pattern: the well-named Abstract Factory. The primary goal of both
    forms of the Factory pattern is to encapsulate the creation process of objects.
    In this chapter, we will focus on isolating the main differences between the Factory
    Method and Abstract Factory, so that we can better understand in which context
    we might choose one over the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Abstract Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an NPC spawner using the Abstract Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the core differences between the Factory Method and Abstract Factory
    is sometimes used as a trick question in technical interviews. So, having a clear
    answer to this type of question can impress your interviewers.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is very hands-on, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following Unity engine and C# language concept(s):'
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concept(s), please review them before starting
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2HKybdy](http://bit.ly/2HKybdy)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Abstract Factory is often explained in overly complicated terms in academic
    documentation, but if you distill it to its elementary form, its design and intent
    are quite simple. The main purpose of the Abstract Factory is to organize the
    manufacturing process of products (objects) into related groups. This approach
    allows us to manage factories that produce specific families of products (objects).
    In other words, we are able to add layers of abstraction to the creation process
    of particular categories of products (objects), and specific individual types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see the basic structure of the Abstract Factory
    described visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/880e98a3-46b7-4544-a961-ac8bb087e9b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the following members of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FactoryProducer` is responsible for returning individual factories of a specific
    category (families) of products (Human or Animal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HumanFactory` and `AnimalFactory` are responsible for the creation of Human
    or Animal products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of using Abstract Factory is obvious when you are dealing with the
    creation of a catalog of products, with each group having its unique manufacturing
    specifications.
  prefs: []
  type: TYPE_NORMAL
- en: When describing a Factory pattern, we often use real-world terms such as *products*,
    *manufacturing*, and *producer*. It's always a wise approach to find correlations
    between real-life notions and computer science terms, because it helps in identifying
    and remembering their core purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The benefits and drawbacks of the Abstract Factory are very similar to those
    of the Factory Method, so it doesn't warrant repeating them in this chapter. But
    there's one significant benefit, which is the core difference between both patterns,
    that we need to address. While the Factory Method focuses on exposing a method
    that permits us to request the creation of objects of specific types, the Abstract
    Factory goes beyond this, by giving us a way to manage the creation of particular
    groups of objects.
  prefs: []
  type: TYPE_NORMAL
- en: This distinction might not sound important at first, but, if we consider a real-world
    analogy, such as the process of manufacturing a car, we can see why the Abstract
    Factory is advantageous. Your typical car is assembled with individually manufactured
    components, but the process of constructing an engine and tires is entirely different,
    so you need separate factories to create those crucial pieces of the final product.
    That's why the Abstract Factory is beneficial in software development, because
    it offers us a similar approach to structuring and organizing the way we produce
    a final, complex product, featuring multiple components with different object
    creation processes.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to extend the use case from the [Chapter 4](53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml),
    The *Factory Method*, by adding a new type of spawnable NPC, called Animals. So,
    in our example, Humans and Animals are considered non-playable characters, but
    have separate manufacturing processes, so they will need individual factories.
    This type of requirement is easily implementable with the Abstract Factory.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our code example is almost the same as the one that we completed in [Chapter
    4](53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml), *The Factory Method*. But we are
    going to add more depth to the system by including specific families of NPCs;
    in our case, Humans and Animals.
  prefs: []
  type: TYPE_NORMAL
- en: 'One key element of the Abstract Factory is that each family of products has
    an associated factory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the class is implemented like a Factory Method, because we use a
    simple `switch` case to return the correct `Factory` to the client depending on
    the requested type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need an `abstract` class to maintain consistency in the implementation
    of each product-specific `Factory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is our first concrete product factory, `HumanFactory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, `AnimalFactory`, which will produce cats and dogs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that both classes implement each other's `GetAnimal()` or `GetHuman()`
    function, but return a `null`, depending on the context. This approach is in case
    a client refers to the wrong factory when requesting a specific type of NPC; instead
    of throwing an exception, it will receive a null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using strings in our `switch`-type condition block, we are going
    to implement enums for each type of product we support, including the associated
    factories, as follows. This approach will avoid errors and maintain consistency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FactoryType`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`HumanType`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`AnimalType`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Animals don''t speak, but our Humans do, so they can''t share a standard
    interface. In that case, we are going to implement one for each type, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IHuman`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`IAnimal`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to write each concrete class for all our human and animal NPCs,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Beggar`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Farmer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Shopowner`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Dog`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Cat`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can extend our `NPCSpawner` class to support the spawning of Animal
    and Human NPCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As proof of our concept, our `Client` class can request `Animal` and `Human` NPCs
    from our `Spawner` without having to know the process behind the creation of the
    final product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Abstract Factory gives us a lot more flexibility than its
    cousin, the Factory Method. We can now manage families of products, and add more
    layers of abstraction to manufacturing processes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Abstract Factory, a close cousin of the
    Factory Method. As its name implies, Abstract Factory permits us to add layers
    of abstraction to the manufacturing process of specific types of product (objects).
    This pattern is very beneficial when dealing with multiple families of products.
    The main drawback of Abstract Factory, compared to the Factory Method, is that
    it's more wordy and involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to explore what is arguably the most famous
    design pattern of them all: the Singleton.'
  prefs: []
  type: TYPE_NORMAL
- en: While learning about Factory patterns, you might notice that we are using several
    terms related to traditional manufacturing processes. The manufacturing and software
    industries are quite related. Best practices associated with managing factories
    inspired several core ideas behind DevOps and Kanban, which are now cornerstones
    of robust software development processes.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point in the book, we have reviewed the two most popular forms of the
    Factory pattern: the Abstract Factory and the Factory Method. However, as an exercise,
    I would recommend expanding your knowledge of factories by implementing a third
    form, for example, the static Factory Method.'
  prefs: []
  type: TYPE_NORMAL
- en: You can learn about the static Factory Method pattern in Joshua Bloch's classic
    book, *Effective Java*. More information can be found in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Phoenix Project* by Kevin Behr, George Spafford, and Gene Kim[https://itrevolution.com/book/the-phoenix-project](https://itrevolution.com/book/the-phoenix-project/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Java* by Joshua Bloch[https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html](https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
