- en: Chapter 12. Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 性能
- en: In the previous chapter, we covered the most important security issues related
    to the Top 10 OWASP initiative, whose goal is, in their own words "to raise awareness
    about application security by identifying some of the most critical risks facing
    organizations".
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了与Top 10 OWASP倡议相关的最重要的安全问题，该倡议的目标是，用他们自己的话说，“通过识别组织面临的一些最关键风险来提高对应用安全性的认识”。
- en: 'In this chapter, we''re going to review the most common issues that a developer
    encounters in relation to an application''s performance, and we''ll also look
    at which techniques and tips are commonly suggested in order to obtain flexible,
    responsive, and well-behaved software, with a special emphasis on web performance.
    We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾开发者遇到的应用性能的常见问题，并探讨通常建议的技术和技巧，以获得灵活、响应迅速且表现良好的软件，特别强调网络性能。我们将涵盖以下主题：
- en: Reviewing the concepts behind performance (**Application Performance Engineering**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾性能背后的概念（**应用性能工程**）
- en: We'll look at some of the most interesting tools that we have available in Visual
    Studio to measure and tune performance, including IntelliTrace and new options,
    such as PerfTips and Diagnostic Tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨在Visual Studio中可用的最有趣的工具，用于测量和调整性能，包括IntelliTrace和新的选项，如PerfTips和诊断工具
- en: We will also check some of the most useful possibilities available in popular
    modern browsers in the **Developer's Tools** menu (*F12*)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将检查在**开发者工具**菜单（*F12*）中可用的最实用的可能性
- en: We'll comment on the most accepted well-known practices for performance and
    some of the software tools to check bottlenecks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将评论最被接受和知名的性能实践，以及一些用于检查瓶颈的软件工具
- en: Finally, we'll look at the most common problems in a web application's performance,
    focusing on the ASP.NET optimization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将关注网络应用性能中最常见的问题，重点关注ASP.NET优化
- en: Application Performance Engineering
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用性能工程
- en: According to Jim Metzler and Steve Taylor, **Application Performance Engineering**
    (**APE**) covers the roles, skills, activities, practices, tools and deliverables
    applied at every phase of the application life cycle that ensure that an application
    will be designed, implemented and operationally supported to meet the non-functional
    performance requirements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据吉姆·梅茨勒和史蒂夫·泰勒的说法，**应用性能工程**（**APE**）涵盖了在应用生命周期每个阶段应用的职责、技能、活动、实践、工具和可交付成果，以确保应用将被设计、实施和运营支持，以满足非功能性性能需求。
- en: The keyword in the definition is non-functional. It is assumed that the application
    works, but some aspects, such as the time taken to perform a transaction or a
    file upload, should be considered from the very beginning of the life cycle.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的关键词是非功能性。假设应用是工作的，但一些方面，如执行交易或文件上传所需的时间，应该从生命周期的开始就考虑。
- en: 'So, the problem can, in turn, be divided into several parts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题可以反过来分为几个部分：
- en: On the one hand, we have to identify which aspects of the application might
    produce meaningful **bottlenecks**.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一方面，我们必须确定应用哪些方面可能会产生有意义的**瓶颈**。
- en: 'This implies testing the application, and tests can vary depending on the type
    of application, of course: for example line of business, games, web applications,
    desktop, and so on. These should lead us to state the application''s performance
    goals in relation to the final production environment.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着测试应用，测试当然会根据应用类型而变化：例如，业务线、游戏、网络应用、桌面应用等。这些应该引导我们确定与最终生产环境相关的应用性能目标。
- en: 'The development team should be able to handle performance problems that can
    be solved (or ameliorated) using a proven software technique: turning intermediate
    code into native code, assembly restructuring, optimizing garbage collector, serializing
    messages for scalability, asynchronous requests, threads of execution, parallel
    programming, and so on.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队应该能够处理可以通过经过验证的软件技术解决（或改善）的性能问题：将中间代码转换为本地代码、汇编重构、优化垃圾收集器、序列化消息以实现可伸缩性、异步请求、执行线程、并行编程等。
- en: Another aspect is performance metrics. These metrics should be measurable using
    some performance testing in order to have real insight about the performance goal.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个方面是性能指标。这些指标应该可以通过某些性能测试来衡量，以便对性能目标有真正的洞察。
- en: 'There are many possible performance metrics that we could consider: physical/virtual
    memory usage, CPU utilization, network and disk operations, database access, execution
    time, start up time, and so on.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑许多可能性的性能指标：物理/虚拟内存使用、CPU利用率、网络和磁盘操作、数据库访问、执行时间、启动时间等等。
- en: Each type of application will suggest a distinct set of targets to care about.
    Also, remember that performance tests should not be carried out until all integration
    tests are completed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的应用程序都会建议一个独特的目标集来关注。此外，请记住，性能测试应在所有集成测试完成后进行。
- en: 'Finally, let''s say that usually, some tests are considered standard when measuring
    performance:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们说，通常，在衡量性能时，一些测试被认为是标准的：
- en: '**Load testing**: This is intended to test software under heavy loads, such
    as when you test a website simulating lots of users to determine at what point
    the application''s response time degrades or even fails.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：这是为了测试软件在重负载下的表现，例如当你模拟大量用户测试一个网站，以确定在什么点应用程序的响应时间会下降甚至失败。'
- en: '**Stress testing**: This is one of the tests that your application should pass
    if it wants to obtain the official "Made for Windows X.x" logo. It''s based on
    putting the system to work beyond its specifications to check where (and how)
    it fails. It might be by using heavy load (beyond the storage capacity, for example),
    very complex database queries, or continuous data input into the system or in
    database loading, and so on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：这是你的应用程序想要获得官方“为Windows X.x制作”标志必须通过的一项测试。它基于将系统工作在超出其规格的条件下，以检查它在哪里（以及如何）失败。这可能包括使用超出存储容量的重负载、非常复杂的数据库查询，或者连续向系统或数据库中输入数据，等等。'
- en: '**Capacity testing**: MSDN Patterns and Practices also include this type of
    test, which is complementary to load testing, in order to determine the server''s
    ultimate failure points, while the load testing checks the result at distinct
    levels of load and traffic.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容量测试**：MSDN模式和惯例也包括这种类型的测试，它是负载测试的补充，以确定服务器的最终故障点，而负载测试则检查在特定负载和流量级别下的结果。'
- en: In these types of tests, it's important to clearly determine what loads to target
    and to also create a contingency plan for special situations (this is more usual
    in websites, when, for some reason, a peak in users per second is expected).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类型的测试中，明确确定要针对的负载以及为特殊情况制定应急计划是很重要的（这在网站上更为常见，当预计每秒用户量会有峰值时）。
- en: The tools
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具
- en: Fortunately, we can count on of an entire set of tools in the IDE to carry out
    these tasks in many ways. As we saw in the first chapter, some of them are available
    directly when we launch an application in Visual Studio 2015 (all versions, including
    the Community Edition).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以依赖IDE中提供的一系列工具以多种方式执行这些任务。正如我们在第一章中看到的，其中一些工具在我们在Visual Studio 2015（包括社区版在内的所有版本）中启动应用程序时直接可用。
- en: Refer to the *A quick tip on execution and memory analysis of an assembly in
    Visual Studio 2015* section in [Chapter 1](part0015.xhtml#aid-E9OE2 "Chapter 1. Inside
    the CLR"), *Inside the CLR*, of this book for more details about these tools,
    including the **Diagnostic Tools** launched by default after any application's
    execution, showing **Events**, **CPU Usage**, and **Memory Usage**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些工具的更多详细信息，包括默认启动的**诊断工具**，显示**事件**、**CPU使用率**和**内存使用率**，请参阅本书第一章“CLR内部”中的“关于Visual
    Studio 2015中程序集执行和内存分析的快速提示”部分。
- en: 'As a reminder, the next screenshot shows the execution of a simple application
    and the predefined analysis that **Diagnostic Tools** show at runtime:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，下面的截图显示了简单应用程序的执行以及**诊断工具**在运行时显示的预定义分析：
- en: '![The tools](img/image00652.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![工具](img/image00652.jpeg)'
- en: However, keep in mind that some other tools might be useful as well, such as
    Fiddler, the traffic sniffer that plays an excellent role when analyzing web performance
    and request/response packets' contents.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，一些其他工具也可能很有用，例如Fiddler，这是一个流量嗅探器，在分析Web性能和请求/响应包内容时扮演着出色的角色。
- en: Other tools are programmable, such as the `StopWatch` class, which allows us
    to measure the time that a block of code takes to execute with precision, and
    we also have Performance Counters, available in .NET since the first versions
    and Event Tracing for Windows (ETW).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具是可编程的，例如`StopWatch`类，它允许我们精确地测量代码块执行所需的时间，我们还有.NET自第一版以来的性能计数器和Windows事件跟踪（ETW）。
- en: Even in the system itself, we can find useful elements, such as Event Log (for
    monitoring behavior—totally programmable in .NET), or external tools explicitly
    thought of for Windows, such as the suite SysInternals, which we have already
    mentioned in the first chapter. In this case, one of the most useful tools you'll
    find is **PerfMon** (**Performance Monitor**), although you may remember that
    we've mentioned FileMon and RegMon as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在系统本身中，我们也可以找到有用的元素，例如事件日志（用于监控行为——在.NET中完全可编程），或者为Windows专门设计的工具，例如我们在第一章中提到的SysInternals套件。在这种情况下，您会发现最有用的工具之一是**PerfMon**（**性能监控器**），尽管您可能还记得我们还提到了FileMon和RegMon。
- en: Advanced options in Visual Studio 2015
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio 2015的高级选项
- en: The IDE, however—especially the 2015 and 2017 versions—contains many more functionalities
    to check the execution and performance at runtime. Most of this functionality
    is available through the **Debug** menu options (some at runtime and others in
    the edition).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而——尤其是2015和2017版本——IDE包含了许多更多用于检查运行时执行和性能的功能。这些功能的大部分都可通过**调试**菜单选项（一些在运行时，一些在版本中）访问。
- en: However, one of the most ready-to-use tools available in the editor is a new
    option called **Performance Tips**, which shows how much time a function took
    to complete and it's presented in the next piece of code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在编辑器中可用的最易于使用的工具之一是一个名为**性能提示**的新选项，它显示了函数完成所需的时间，并在下一段代码中展示。
- en: 'Imagine that we have a simple method that reads file information from the disk
    and then selects those files whose names don''t contain spaces. It could be something
    like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的方法，它从磁盘读取文件信息，然后选择那些名称中不包含空格的文件。它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `RemoveInvalidNames` method uses another simple `CheckFile` method. Its
    code is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveInvalidNames`方法使用另一个简单的`CheckFile`方法。其代码如下：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could have inserted the `CheckFile` functionality inside `RemoveInvalidNames`,
    but applying the single responsibility principle has some advantages here, as
    we will see.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在`RemoveInvalidNames`方法内部插入`CheckFile`功能，但应用单一职责原则在这里有一些优势，正如我们将看到的。
- en: 'Since the selection of files will take some time, if we establish a breakpoint
    right before the `foreach` loop, we will be informed of the time in one of these
    tips:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件选择将花费一些时间，如果我们直接在`foreach`循环之前设置一个断点，我们将在这些提示中的一个中得知时间：
- en: '![Advanced options in Visual Studio 2015](img/image00653.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio 2015的高级选项](img/image00653.jpeg)'
- en: 'Of course, the real value in these code fragments is that we can see the whole
    process and evaluate it. This is not only about the time it takes, but also about
    the behavior of the system. So, let''s put another breakpoint at the end of the
    method and see what happens:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些代码片段的真实价值在于我们可以看到整个过程并对其进行评估。这不仅关乎所花费的时间，还关乎系统的行为。因此，让我们在方法末尾再设置一个断点，看看会发生什么：
- en: '![Advanced options in Visual Studio 2015](img/image00654.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio 2015的高级选项](img/image00654.jpeg)'
- en: 'As you can see, the entire process took about 1.2 seconds. And the IDE reminds
    us that we can open **Diagnostic Tools** to check how this code behaved and have
    a detailed summary, as the next compound screenshot shows (note that you will
    see it in three different docked windows inside the tools):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，整个过程大约花费了1.2秒。IDE提醒我们，我们可以打开**诊断工具**来检查这段代码的行为，并有一个详细的总结，如下一个复合截图所示（请注意，您将在工具中的三个不同的停靠窗口中看到它）：
- en: '![Advanced options in Visual Studio 2015](img/image00655.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio 2015的高级选项](img/image00655.jpeg)'
- en: In this manner, we don't need to explicitly create a `StopWatch` instance to
    measure how much the process delayed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们不需要显式创建一个`StopWatch`实例来测量过程延迟了多少。
- en: These **Performance Tips** report the time spent, indicating what is less than
    or equal to (<=) a certain amount. This means that they consider the overhead
    of the debugging process (symbol loading, and so on), excluding it from the measurement.
    Actually, the greatest accuracy is obtained on CLR v4.6 and Windows 10.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**性能提示**报告了花费的时间，表明小于或等于（<=）一定数量的内容。这意味着它们考虑了调试过程的开销（符号加载等），并将其排除在测量之外。实际上，在CLR
    v4.6和Windows 10上可以获得最高的精度。
- en: As for the CPU graph, it uses all the available cores, and when you find a spike
    it would be interesting to check, even if doesn't reach 100%, for different types
    of problems, which we will enumerate later (keep in mind that this feature is
    not available until debugging ends).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至于CPU图表，它使用所有可用的核心，当你发现一个值得检查的峰值时，即使它没有达到100%，对于不同类型的问题，我们将在后面列举（请记住，此功能在调试结束之前不可用）。
- en: Advanced options in the Diagnostic Tools menu
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 诊断工具菜单中的高级选项
- en: Actually, we can trace sentences one by one and see exactly where most of the
    time is spent (and where we should revise our code in search for improvements).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以逐句追踪并确切地看到大部分时间花在了哪里（以及我们应该在哪里修改代码以寻找改进）。
- en: 'If you reproduce this code on your machine, depending on the number of files
    read, you''ll see that in the bottom window of the **Diagnostic Tools** menu,
    there is a list that shows every event generated and the time it took to be processed,
    as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个机器上重现此代码，根据读取的文件数量，你会在**诊断工具**菜单的底部窗口中看到一个列表，显示每个生成的事件及其处理所需的时间，如下面的截图所示：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00656.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00656.jpeg)'
- en: Thanks to IntelliTrace, you can exactly configure the way you want the debugger
    to behave in general or for a specific application. Just go to **Tools** | **Options**
    and select **Intellitrace Events** (it has a separate entry in the tree view).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了IntelliTrace，您可以精确配置调试器在一般情况或特定应用程序中的行为方式。只需转到**工具** | **选项**，然后选择**IntelliTrace事件**（在树视图中有一个单独的条目）。
- en: 'This allows the developer to select the types of events they''re interested
    in. For instance, if we want to monitor the **Console** events, we can select
    which are the ones we need to target in our application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许开发者选择他们感兴趣的事件类型。例如，如果我们想监控**控制台**事件，我们可以选择在应用程序中需要针对的目标：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00657.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00657.jpeg)'
- en: 'To test this, I coded a very simple Console application to show a couple of
    values and the number of rows and columns available:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我编写了一个非常简单的控制台应用程序来显示一些值以及可用的行数和列数：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once IntelliTrace is configured to show the activities of this application,
    named `ConsoleApplication1`, we can follow all its events in **Event Window**
    and later select an event of our interest to us and check **Activate Historical
    Debugging** in it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦IntelliTrace配置为显示名为`ConsoleApplication1`的此应用程序的活动，我们就可以在**事件窗口**中跟踪所有事件，然后选择我们感兴趣的事件并检查其中的**激活历史调试**。
- en: '![Advanced options in the Diagnostic Tools menu](img/image00658.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00658.jpeg)'
- en: Once we do that, the IDE relaunches the execution, and, now, the **Autos**,
    **Locals**, and **Watch** windows appear again but show the values that the application
    managed at that precise time during the execution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，IDE将重新启动执行，现在，**自动**、**局部变量**和**监视**窗口再次出现，但显示应用程序在执行过程中在那个精确时刻管理的值。
- en: 'In practice, it''s like recording every step given by the application at runtime,
    including the values of any variable, object, or component that we had previously
    selected as a target during the process (refer to the next screenshot):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就像记录应用程序在运行时给出的每个步骤，包括我们在此过程中之前选定的任何变量、对象或组件的值（参见图表）：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00659.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00659.jpeg)'
- en: Also, note that the information provided also includes an exact indication of
    the time spent by every event at runtime.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，提供的信息还包括每个事件在运行时花费的确切时间指示。
- en: Moreover, other profiles for different aspects of our application are possible.
    We can configure them in the **Debugger** menu under the **Start Diagnostic Tools
    Without Debugging** option.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以为应用程序的不同方面配置其他配置文件。我们可以在**调试器**菜单下的**不进行调试启动诊断工具**选项中进行配置。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using **Start Diagnostic Tools Without Debugging**, the IDE will remind
    us to change the default configuration to **Release** if we want to obtain accurate
    results.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**不进行调试启动诊断工具**时，IDE会提醒我们更改默认配置为**发布**，如果我们想获得准确的结果。
- en: Observe that profiles can be attached to distinct applications in the system,
    not just the one we're building. A new configuration page opens, and the **Analysis
    Target** option shows distinct types of applications, as you can see in the next
    screenshot.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，配置文件可以附加到系统中的不同应用程序，而不仅仅是我们在构建的应用程序。将打开一个新的配置页面，**分析目标**选项显示不同类型的应用程序，如您在下一张屏幕截图中所见。
- en: 'It could be the current application (`ConsoleApplication1`), a Windows Store
    App (either running or already installed), browsing to a web page on a Windows
    phone, select any other executable, or launch an ASP.NET application running on
    IIS:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是当前的应用程序（`ConsoleApplication1`），一个 Windows 商店应用程序（无论是正在运行还是已经安装），在 Windows
    手机上浏览网页，选择任何其他可执行文件，或者启动在 IIS 上运行的 ASP.NET 应用程序：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00660.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00660.jpeg)'
- en: And this is not all in relation to performance and IntelliTrace. If you select
    the **Show All Tools** link, more options are presented, which relate to distinct
    types of applications and technologies to be measured.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是与性能和 IntelliTrace 相关的全部内容。如果您选择**显示所有工具**链接，将呈现更多选项，这些选项与要测量的不同类型的应用程序和技术相关。
- en: 'In this way, in the **Not Applicable Tools** link, we see other interesting
    features, such as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，在**不适用工具**链接中，我们看到其他一些有趣的功能，例如以下内容：
- en: '**Application timeline**: To check in which areas more time is spent in the
    application execution (such as the typical low frame rate).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序时间线**：用于检查在应用程序执行中花费更多时间的地方（例如典型的低帧率）。'
- en: '**HTML UI Responsiveness**: Especially useful when you have an application
    that mixes the server and client code, and some actions in the client take too
    much time (think of frameworks such as Angular, Ext, React, Ember, and so on).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML UI 响应性**：特别适用于您有一个混合服务器和客户端代码的应用程序，并且客户端的一些操作花费了太多时间（例如 Angular、Ext、React、Ember
    等框架）。'
- en: '**Network**: A very useful complement to the previous web scenario, where the
    problem resides in the network itself. You can check response headers, timelines
    for every request, cookies, and much more.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：这是之前提到的网络场景的一个非常有用的补充，问题就出在网络本身。您可以检查响应头、每个请求的时间线、cookies 以及更多内容。'
- en: '**Energy consumption**: This makes sense especially in mobile applications.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**能耗**：这在移动应用程序中尤其有意义。'
- en: '**JavaScript memory**: Again, very useful when dealing with web apps that use
    external frameworks in which we don''t know exactly where the potential memory
    leaks are.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript 内存**：再次，当处理使用外部框架的 Web 应用程序时，我们不知道潜在的内存泄漏在哪里时，非常有用。'
- en: 'The next screenshot shows these options:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了这些选项：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00661.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00661.jpeg)'
- en: As you can see, these options appear as **Not Applicable** since they don't
    make sense in a Console app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些选项显示为**不适用**，因为在控制台应用程序中它们没有意义。
- en: 'Once we launch the profile in the **Start** button, an assistant starts and
    we have to select the type of target: CPU Sampling, Instrumentation (to measure
    function calls), .NET Memory Allocation, and Resource Contention Data (concurrency),
    which can detect threads waiting for other threads.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在**开始**按钮中启动配置文件，助手就会启动，我们必须选择目标类型：CPU 样本、仪器（用于测量函数调用）、.NET 内存分配和资源争用数据（并发），这可以检测等待其他线程的线程。
- en: 'In the assistant''s last screen, we have a checkbox that indicates whether
    we want to launch the profiling immediately afterwards. The application will be
    launched and, when the execution is over, a profiling report is generated and
    presented in a new window:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在助手的最后屏幕上，我们有一个复选框，表示我们是否希望在之后立即启动分析。应用程序将被启动，当执行完成后，将生成一个分析报告并在新窗口中显示：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00662.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00662.jpeg)'
- en: 'We have several views available: **Summary**, **Marks** (which presents all
    related timing at the execution), and **Processes** (obviously, showing information
    about any process involved in the execution).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种可用的视图：**摘要**、**标记**（显示执行中所有相关的计时信息）和**进程**（显然，显示任何参与执行的过程的信息）。
- en: 'This latest option is especially interesting in the results we obtain. Using
    the same `ConsoleApplication1` file, I''m going to add a new method that creates
    a `Task` object and sleeps execution until `1500` ms:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得的结果中，这个最新的选项特别有趣。使用相同的 `ConsoleApplication1` 文件，我将添加一个新的方法来创建一个 `Task`
    对象，并使执行暂停至 `1500` 毫秒：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we activate this option of processes in the profiler, we''re shown a bunch
    of options to analyze, and the report generated holds information to filter data
    in distinct ways depending on what we need: **Time Call Tree**, **Hot Lines**,
    **Report Comparison** (with exports), **Filters**, and even more.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在分析器中激活此进程选项，我们将看到一系列分析选项，生成的报告包含根据我们的需求以不同方式过滤数据的信息：**时间调用树**、**热点行**、**报告比较**（带有导出）、**过滤器**，甚至更多。
- en: 'For example, we can view the Call Stack at the time the view was collected
    by double-clicking on an event inside the **Diagnostic Tools** menu:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过在**诊断工具**菜单中双击一个事件来查看在收集视图时的调用堆栈：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00663.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00663.jpeg)'
- en: 'Note how we have presented information related to **Most Contended Resources**
    and **Most Contended Threads**, with a breakdown of each element monitored: either
    handles or thread numbers. This is one of the features that, although available
    in previous versions of Visual Studio, should be managed via Performance Counters,
    as you can read in Maxim Goldin''s article *Thread Performance - Resource Contention
    Concurrency Profiling in Visual Studio 2010*, available as part of MSDN Magazine
    at [https://msdn.microsoft.com/en-us/magazine/ff714587.aspx](https://msdn.microsoft.com/en-us/magazine/ff714587.aspx).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何展示了与**最争用资源**和**最争用线程**相关的信息，并按每个监控元素进行了细分：要么是句柄，要么是线程编号。这是尽管在Visual Studio的早期版本中可用，但应通过性能计数器管理的功能之一，正如你在Maxim
    Goldin的文章《线程性能 - Visual Studio 2010中的资源争用并发分析》中读到的，该文章作为MSDN杂志的一部分提供，网址为[https://msdn.microsoft.com/en-us/magazine/ff714587.aspx](https://msdn.microsoft.com/en-us/magazine/ff714587.aspx)。
- en: 'Besides the information shown in the screenshot, a lot of other views give
    us more data about the execution: **Modules**, **Threads**, **Resources**, **Marks**,
    **Processes**, **Function Details**, and so on.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了截图显示的信息外，许多其他视图都提供了更多关于执行的数据：**模块**、**线程**、**资源**、**标记**、**进程**、**函数详情**等等。
- en: 'The next capture shows what you will see if you follow these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了如果你按照这些步骤操作，你将看到的内容：
- en: '![Advanced options in the Diagnostic Tools menu](img/image00664.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![诊断工具菜单中的高级选项](img/image00664.jpeg)'
- en: To summarize, you just learned how the IDE provides a wide set of modern, updated
    tools, and it's just a matter of deciding which one is the best solution for the
    analysis required.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你刚刚学习了IDE如何提供一套现代、更新的工具，而决定哪个是所需分析的最佳解决方案只是时间问题。
- en: Other tools
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他工具
- en: As we saw in the previous chapter, modern browsers offer new and exciting possibilities
    to analyze web page behavior in distinct ways.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，现代浏览器提供了分析网页行为的新颖和令人兴奋的可能性。
- en: Since it is assumed that the initial landing time is crucial in the user's perception,
    some of these features relate directly to performance (analyzing content, summarizing
    request time for every resource, presenting graphical information to catch potential
    problems with a glimpse, and so on).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于假设初始着陆时间对用户的感知至关重要，因此一些这些功能直接与性能相关（分析内容、总结每个资源的请求时间、通过一瞥展示图形信息等等）。
- en: The **Network** tab, usually present in most of the browsers, shows a detailed
    report of loading times for every element in the current page. In some cases,
    this report is accompanied by a graphical chart, indicating which elements took
    more time to complete.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络**标签通常存在于大多数浏览器中，显示了当前页面中每个元素的加载时间详细报告。在某些情况下，此报告附有图形图表，指示哪些元素花费了更多时间完成。'
- en: In some cases, the names might vary slightly, but the functionality is similar.
    For instance, in Edge, you have a **Performance** tab, which records activity
    and generates detailed reports, including graphical information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，名称可能会有所不同，但功能相似。例如，在Edge中，你有一个**性能**标签，它记录活动并生成详细的报告，包括图形信息。
- en: In Chrome, we find its **Timeline** tab, a recording of the page performance,
    which also presents a summary of the results.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中，我们发现其**时间线**标签，这是页面性能的记录，同时也展示了结果的摘要。
- en: 'Finally, in Firefox, we have an excellent set of tools to check the performance,
    starting with the **Net** tab, which analyzes the download time for every request
    and even presents a detailed summary when we pass the cursor over each element
    in the list, allowing us to filter these requests by categories: HTML, CSS, JS,
    images, plugins, and so on, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Firefox中，我们有一套出色的工具来检查性能，从**网络**标签开始，它分析每个请求的下载时间，甚至在我们将光标移至列表中的每个元素上时，还会显示详细的摘要，允许我们通过类别过滤这些请求：HTML、CSS、JS、图片、插件等，如下面的截图所示：
- en: '![Other tools](img/image00665.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![其他工具](img/image00665.jpeg)'
- en: 'Also, in Chrome, we find another interesting tab: **Audits**. The purpose is
    to monitor distinct aspects of page behaviors, such as the correct usage (and
    the impact) of CSS, combining JavaScript files to improve the overall performance
    (the operation called **Bundling and Minifying**), and, in general, a complete
    list of issues that Chrome considers improvable, mainly in two aspects: **Network
    Utilization** and **Web Page Performance**. The next screenshot shows the final
    report on a simple page:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Chrome中，我们还可以找到一个有趣的标签：**审计**。其目的是监控页面行为的各个方面，例如CSS的正确使用（及其影响），合并JavaScript文件以提高整体性能（称为**捆绑和压缩**操作），以及Chrome认为可以改进的完整问题列表，主要在两个方面：**网络利用率**和**网页性能**。下面的截图显示了简单页面的最终报告：
- en: '![Other tools](img/image00666.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![其他工具](img/image00666.jpeg)'
- en: To end this review of performance features linked to browsers, also consider
    that in some browsers, we find a **Performance** tab, specifically included to
    load response times or similar utilities, such as **PageInsights** in the case
    of Chrome and a similar one in Firefox (I would especially recommend Firefox Developer
    Edition for its highly useful features for a developer).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束与浏览器相关的性能功能回顾时，也要考虑在某些浏览器中，我们发现了一个**性能**标签，专门用于加载响应时间或类似工具，例如Chrome中的**页面洞察**和Firefox中的一个类似功能（我特别推荐Firefox开发者版，因为它为开发者提供了非常实用的功能）。
- en: 'In this case, you can record a session in which Firefox gets all the required
    information to give a view of the performance, which you can later analyze in
    many forms:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以记录一个会话，其中Firefox获取所有必要的信息来展示性能，你可以在以后以多种形式分析这些信息：
- en: '![Other tools](img/image00667.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![其他工具](img/image00667.jpeg)'
- en: Note that performance is mainly focused on JavaScript usage, but it is highly
    customizable for other aspects of a page's behavior.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，性能主要关注JavaScript的使用，但它可以高度自定义页面行为的其他方面。
- en: The process of performance tuning
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能调优的过程
- en: Just like with any other software process, we can conceive performance-tuning
    as a cycle. During this cycle, we try to identify and get rid of any slow feature
    or bottleneck, up to the point at which the performance objective is reached.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他软件过程一样，我们可以将性能调优视为一个周期。在这个周期中，我们试图识别并消除任何缓慢的功能或瓶颈，直到达到性能目标。
- en: The process goes through data collection (using the tools we've seen), analyzing
    the results, and changes in configuration, or sometimes in code, depending on
    the solution required.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程包括数据收集（使用我们看到的工具）、分析结果以及配置更改，有时甚至在代码中，具体取决于所需的解决方案。
- en: After each cycle of changes is completed, you should retest and measure the
    code again in order to check whether the goal has been reached and your application
    has moved closer to its performance objectives. Microsoft's MSDN suggests a cycle
    process that we can extrapolate for several distinct scenarios or types of applications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成每个周期更改后，你应该重新测试并测量代码，以检查是否达到了目标，并且你的应用程序是否更接近其性能目标。微软的MSDN建议一个周期过程，我们可以将其扩展到几个不同的场景或应用程序类型。
- en: Keep in mind that software tuning often implies tuning the OS as well. You should
    not change the system's configuration in order to make a particular application
    perform correctly. Instead, try to recreate the final environment and the possible
    (or predictable) ways in which that environment is going to evolve.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，软件调优通常意味着也要调整操作系统。你不应该更改系统的配置以使特定应用程序正确运行。相反，尝试重新创建最终环境和该环境可能（或可预测的）演变的方式。
- en: Only when you are absolutely sure that your code is the best possible should
    you suggest changes in the system (memory increase, better CPUs, graphic cards,
    and so on).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你绝对确信你的代码是最佳可能的情况下，你才应该建议对系统进行更改（增加内存、更好的CPU、显卡等）。
- en: 'The following graphic, taken from the official MSDN documentation, highlights
    this performance cycle:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下图来自官方MSDN文档，突出了这个性能周期：
- en: '![The process of performance tuning](img/image00668.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![性能调优的过程](img/image00668.jpeg)'
- en: Performance Counters
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能计数器
- en: As you probably know, the operating system uses Performance Counters (a feature
    installed by default), to check its performance and eventually notify the user
    about performance limitations or poor behavior.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，操作系统使用性能计数器（默认安装的功能）来检查其性能，并最终通知用户有关性能限制或不良行为。
- en: Although they're still available, the new tools that we've seen in the IDE provide
    a much better and integrated method to check and analyze the application's performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们仍然可用，但我们在IDE中看到的新工具提供了一个更好且更集成的方法来检查和分析应用程序的性能。
- en: Bottleneck detection
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瓶颈检测
- en: 'The official documentation in MSDN gives us some clues that we can keep in
    mind in the process of bottleneck detection and divides the possible origins mainly
    into four categories (each one proposing a distinct management): CPU, memory,
    disk I/O, and network I/O.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN的官方文档为我们提供了一些线索，我们可以在瓶颈检测过程中记住这些线索，并将可能的来源主要分为四类（每一类都提出了独特的管理）：CPU、内存、磁盘I/O和网络I/O。
- en: 'For .NET applications, some recommendations are assumed correctly when identifying
    the possible bottlenecks:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于.NET应用程序，在识别可能的瓶颈时，以下建议被认为是正确的：
- en: '**CPU**: As for the CPU, check Diagnostic Tools in search of pikes. If you
    find one, narrow the search to identify the cause and analyze the code. A pike
    is considered harmful if it increases beyond 75% of the CPU usage for more than
    a certain amount of time.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：至于CPU，请在诊断工具中查找峰值。如果您找到了一个，请缩小搜索范围以确定原因并分析代码。如果峰值在一段时间内超过CPU使用率的75%以上，则被视为有害。'
- en: The consequence, in this case, might well be associated with the code. Generally
    speaking, asynchronous processes, tasks, or parallel programming are recognized
    to have a positive impact on solving these kind of problems.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，后果可能与代码有关。一般来说，异步进程、任务或并行编程被认为对解决这类问题有积极影响。
- en: '**Memory**: Here, a memory peak can have several reasons. It may be our code,
    but it is also a process that implies the extensive use of memory (physical or
    virtual).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：在这里，内存峰值可能有几个原因。它可能是我们的代码，但也可能是一个涉及大量使用内存（物理或虚拟）的过程。'
- en: Possible causes are unnecessary allocations, nonefficient clean-up or garbage
    collection, lack of a caching system, and others. When virtual memory is used,
    the results may get worse immediately.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的原因包括不必要的分配、不高效的清理或垃圾回收、缺乏缓存系统等。当使用虚拟内存时，结果可能会立即变差。
- en: '**Disk I/O**: This refers to the number of operations (read/write) performed,
    either on the local storage system or in the network the application has access
    to.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘I/O**：这指的是在本地存储系统或应用程序可访问的网络中执行的操作（读取/写入）数量。'
- en: 'There are multiple causes that can provoke a bottleneck here: reading or writing
    to long files, accessing a network that is overused or not optimally configured,
    operations that imply ciphering data, unnecessary reads from databases, or an
    excess of paging activity.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多个原因可以引发这里的瓶颈：读取或写入长文件、访问过度使用或配置不佳的网络、涉及加密数据操作、从数据库中不必要的读取，或者过度的分页活动。
- en: 'To solve these kind of problems, MSDN recommends the following:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了解决这类问题，MSDN推荐以下方法：
- en: Start by removing any redundant disk I/O operations in your application.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先从您的应用程序中移除任何多余的磁盘I/O操作。
- en: Identify whether your system has a shortage of physical memory, and, if so,
    add more memory to avoid excessive paging.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定您的系统是否缺少物理内存，如果是，则添加更多内存以避免过度分页。
- en: Identify whether you need to separate your data onto multiple disks.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定您是否需要将数据分散到多个磁盘上。
- en: Consider upgrading to faster disks if you still have disk I/O bottlenecks after
    doing all of the preceding options.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在执行了所有前面的选项之后，您仍然有磁盘I/O瓶颈，请考虑升级到更快的磁盘。
- en: '**Network I/O**: This is about the amount of information sent/received by your
    server. It could be an excessive number of remote calls or the amount of data
    routed through a single network interface card (NIC traffic), or it might have
    to do with large chunks of data sent or received in a large number of calls.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络I/O**：这是关于您的服务器发送/接收的信息量。这可能是一个过多的远程调用数量，或者通过单个网络接口卡（NIC流量）路由的数据量，或者可能与大量调用中发送或接收的大量数据有关。'
- en: 'Every possible bottleneck might have a distinct root cause, and we should carefully
    analyze the possible origins based on questions such as these: is it because of
    my code or is it the hardware? If it is a hardware problem, is there a way to
    accelerate the process implied through software improvements? And so on.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能的瓶颈可能都有一个不同的根本原因，我们应该基于诸如以下问题仔细分析可能的起源：这是否是因为我的代码，还是因为硬件？如果是硬件问题，是否有通过软件改进来加速过程的方法？等等。
- en: Bottleneck detection in practice
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实际瓶颈检测
- en: At the time of determining bottlenecks in .NET, you can still use (besides all
    those tools we've already seen) Performance Counters, although the previous techniques
    we've seen are supposed to ease the detection process considerably.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定.NET瓶颈的时候，你仍然可以使用（除了我们已经看到的所有这些工具之外）性能计数器，尽管我们之前看到的技术本应大大简化检测过程。
- en: However, the official recommendations linked to some of the issue detections
    are still a valuable clue. So, the key here would be to look for the equivalent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与一些问题检测相关的官方建议仍然是一个有价值的线索。因此，关键在于寻找等效的值。
- en: 'There are several types depending on the feature to be measured, as MSDN suggests:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要测量的特性，有几种类型，如MSDN建议：
- en: '**Excessive memory consumption**: Since the cause is usually wrong memory management,
    we should look for values on the following:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度内存消耗**：由于原因通常是不正确的内存管理，我们应该在以下方面寻找值：'
- en: Process/private bytes
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程/私有字节
- en: .NET CLR memory/# bytes in all heaps
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET CLR 内存/# 所有堆的字节数
- en: Process/working set
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程/工作集
- en: .NET CLR memory/large object heap size
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET CLR 内存/大对象堆大小
- en: 'The key with these counters is, if you find out an increase in private bytes
    while the # of bytes in all heap counters remains the same, that means there is
    some kind of unmanaged memory consumption. If you observe an increase in both
    counters, then the problem is in the managed memory consumption.'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些计数器的关键是，如果你在所有堆的字节数保持不变的情况下发现私有字节的增加，这意味着存在某种未管理的内存消耗。如果你观察到两个计数器都增加，那么问题在于托管内存消耗。
- en: '**Large working set size**: We should understand *working set* means all memory
    pages loaded in RAM at a given time. The way to measure this problem is to use
    process\working set Performance Counter. Now we have other features, but the points
    to look for are the same, basically:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大的工作集大小**：我们应该理解*工作集*意味着在给定时间内加载到RAM中的所有内存页面。测量这个问题的方法是使用进程\工作集性能计数器。现在我们有了其他功能，但需要查找的点是一样的，基本上：'
- en: If you get a high value, it might mean that the number of assemblies loaded
    is very high as well. There's no specific threshold to watch in this counter;
    however, a high or frequently changing value could be the key to a memory shortage.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你得到一个高值，这可能意味着加载的程序集数量也非常高。在这个计数器中没有特定的阈值要关注；然而，一个高值或频繁变化的值可能是内存短缺的关键。
- en: If you see a high rate of page faults, it probably means that your server should
    have more memory.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你看到高页面错误率，这可能意味着你的服务器应该有更多的内存。
- en: '**Fragmented large object heap**: In this case, we have to care about objects
    allocated in **large object heap** (**LOH**). Generally, objects greater than
    85 KB are allocated there, and it was traditionally detected using the .NET CLR
    memory\large object heap size profiler, and now, using the memory diagnostic tools
    that we''ve already seen.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碎片化的大对象堆**：在这种情况下，我们必须关注分配在**大对象堆**（**LOH**）中的对象。通常，大于85 KB的对象被分配在那里，并且传统上使用.NET
    CLR 内存\大对象堆大小分析器来检测，现在使用我们之前看到的内存诊断工具。'
- en: They might be buffers (for large strings, byte arrays, and so on) that are common
    in I/O operations (such as in `BinaryReaders`).
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能是缓冲区（用于大字符串、字节数组等），这在I/O操作（如`BinaryReaders`）中很常见。
- en: These allocations fragment the LOH considerably. So, recycling these buffers
    is a good practice to avoid fragmentation.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些分配会极大地碎片化LOH。因此，回收这些缓冲区是一种良好的做法，以避免碎片化。
- en: '**High CPU utilization**: This is normally caused by managed code that is not
    optimally written, as happens when the code does the following:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高CPU利用率**：这通常是由于编写不佳的托管代码引起的，就像代码执行以下操作时发生的那样：'
- en: Forces an excessive use of GC. The measure of this feature was previously done
    using `%Time` in GC, counter.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制GC过度使用。这个特性的度量以前是用GC计数器的`%Time`完成的。
- en: Also, when the code provokes many exceptions, you can test that with `.NET CLR
    exceptions\# of exceptions thrown/sec`.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，当代码引发许多异常时，你可以使用`.NET CLR 异常/每秒抛出的异常数`来测试。
- en: A large number of threads is generated. This might cause the CPU to spend a
    lot of time switching between threads (instead of performing real work). Previously
    measured using the `Thread\Context Switches/sec`, now we can check it with the
    previously seen **Analysis Target** feature.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成大量线程。这可能会导致CPU花费大量时间在线程之间切换（而不是执行实际工作）。之前使用`Thread\Context Switches/sec`进行测量，现在我们可以使用之前看到的**分析目标**功能进行检查。
- en: '**Thread contention**: This happens when multiple threads try to access a shared
    resource (remember, a process creates an area of shared resources that all threads
    associated with it can access).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程争用**: 这发生在多个线程尝试访问共享资源时（记住，一个进程创建了一个所有与其关联的线程都可以访问的共享资源区域）。'
- en: 'The identification of this symptom is usually done by observing two performance
    counters:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常通过观察两个性能计数器来识别这种症状：
- en: '`.NET CLR LocksAndThreads\Contention Rate/sec`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NET CLR LocksAndThreads\Contention Rate/sec`'
- en: '`.NET CLR LocksAndThreads\Total # of Contentions`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NET CLR LocksAndThreads\Total # of Contentions`'
- en: Your application is said to have a contention rate issue or one that encounters
    thread contention when there is a meaningful increase in these two values. The
    responsible code should be identified and rewritten.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个值有意义地增加时，你的应用程序被认为存在争用率问题或遇到线程争用。应识别出负责的代码并进行重写。
- en: Using code to evaluate performance
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码评估性能
- en: As mentioned earlier, besides the set of tools we've seen, it is possible to
    combine these techniques with software tools especially designed to facilitate
    our own performance measures.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除了我们看到的工具集之外，还可以将这些技术与专门为方便我们自己的性能测量而设计的软件工具相结合。
- en: The first and best known is the `Stopwatch` class, which belongs to the `System.Diagnostics`
    namespace, which we've already used in the first chapters to measure sorting algorithms,
    for example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的是`Stopwatch`类，它属于`System.Diagnostics`命名空间，我们在第一章中已经使用它来测量排序算法等。
- en: 'The first thing to remember is that depending on the system, the `Stopwatch`
    class will offer different values. These values can be queried at first if we
    want to know how far we can get accurate measurements. Actually, this class holds
    two important properties: `Frequency` and `IsHighResolution`. Both properties
    are read-only.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要记住的是，根据系统不同，`Stopwatch`类将提供不同的值。如果我们想知道我们可以获得多精确的测量，我们最初可以查询这些值。实际上，这个类包含两个重要的只读属性：`Frequency`和`IsHighResolution`。
- en: 'Additionally, some methods complete a nice set of functionalities. Let''s review
    what they mean:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些方法完成了一套完整的功能。让我们回顾一下它们的意义：
- en: '`Frequency`: This gets the frequency of the timer as a number of ticks per
    second. The higher the number, the more precise our `Stopwatch` class can behave.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`频率`: 这将获取计时器的频率，以每秒的滴答次数表示。数字越高，我们的`Stopwatch`类表现越精确。'
- en: '`IsHighResolution`: This indicates whether the timer is based on a high-resolution
    performance counter.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsHighResolution`: 这表示计时器是否基于高分辨率性能计数器。'
- en: '`Elapsed`: This gets the total elapsed time that is measured.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Elapsed`: 这将获取测量的总经过时间。'
- en: '`ElapsedMilliseconds`: This is the same as `Elapsed`, but it is measured in
    milliseconds.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElapsedMilliseconds`: 这与`Elapsed`相同，但以毫秒为单位进行测量。'
- en: '`ElapsedTicks`: This is the same as `Elapsed`, but it is measured in ticks.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElapsedTicks`: 这与`Elapsed`相同，但以滴答为单位进行测量。'
- en: '`IsRunning`: This is a Boolean value that indicates whether `Stopwatch` is
    still in operation.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsRunning`: 这是一个布尔值，表示`Stopwatch`是否仍在运行。'
- en: 'The `Stopwatch` class also has some convenient methods to facilitate these
    tasks: `Reset`, `Restart`, `Start`, and `Stop`, whose functionality you can easily
    infer by their names.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch`类也有一些方便的方法来简化这些任务：`Reset`、`Restart`、`Start`和`Stop`，你可以通过它们的名字轻松推断出它们的功能。'
- en: 'So let''s use our reading file method from the previous and present tests,
    together with a `Stopwatch` to check these features with some basic code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用之前和现在的测试中的读取文件方法，以及一个`Stopwatch`来通过一些基本代码检查这些功能：
- en: '[PRE4]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using this basic approach, we have a simple indication of the total time elapsed
    in the process, as shown in the next screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种基本方法，我们可以得到进程总经过时间的简单指示，如下一张截图所示：
- en: '![Using code to evaluate performance](img/image00669.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![使用代码评估性能](img/image00669.jpeg)'
- en: We can get more precision using the other properties provided by the class.
    For example, we can measure the basic unit of time `Stopwatch` uses in attempting
    to get the nanosecond thanks to the `Frequency` property.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类提供的其他属性来获得更高的精度。例如，我们可以使用`Frequency`属性来测量`Stopwatch`在尝试获取纳秒时使用的基本时间单位。
- en: 'Besides, the class also has a static `StartNew()` method, which we can use
    for simple cases like these; so, we can change the preceding code in this manner:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类还有一个静态的`StartNew()`方法，我们可以用它来处理这些简单的情况；因此，我们可以这样更改前面的代码：
- en: '[PRE5]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we use a small loop to perform the measure three times. So,
    we can compare results and have a more accurate measure, calculating the average.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用一个小循环来执行测量三次。因此，我们可以比较结果，并得到一个更准确的测量，计算平均值。
- en: Also, we're using the static `StartNew` method of the class since it's valid
    for this test (think of some cases in which you might need several instances of
    the `Stopwatch` class to measure distinct aspects or blocks of the application,
    for instance).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在使用类的静态`StartNew`方法，因为它是针对这个测试有效的（想想你可能需要几个`Stopwatch`类的实例来测量应用程序的不同方面或块的情况）。
- en: 'Of course, the results won''t be exactly the same in every step of the loop,
    as we see in the next screenshot showing the output of the program (keep in mind
    that depending on the task and the machine, these values will vary considerably):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在循环的每一步中，结果都不会完全相同，正如我们在下一个截图中所看到的程序输出（请记住，根据任务和机器的不同，这些值会有很大的变化）：
- en: '![Using code to evaluate performance](img/image00670.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![使用代码来评估性能](img/image00670.jpeg)'
- en: Also, note that due to the system's caching and allocation of resources, every
    new loop seems to take less time than the previous one. This is the case in my
    machine depending on the distinct system's state. If you need close evaluations,
    it is recommended that you execute these tests at least 15 or 20 times and calculate
    the average.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，由于系统的缓存和资源分配，每个新的循环似乎比前一个循环花费的时间少。这在我的机器上取决于不同的系统状态。如果您需要进行精确评估，建议至少执行这些测试15或20次，并计算平均值。
- en: Optimizing web applications
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化Web应用程序
- en: Optimizing web applications is, for many specialists, a sort of a **black art**
    compound of so many features, that actually, there are a lot of books published
    on the subject.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多专家来说，优化Web应用程序是一种**黑魔法**，它结合了如此多的功能，实际上，关于这个主题已经出版了大量的书籍。
- en: We will focus on .NET, and, therefore, on ASP.NET applications, although some
    of the recommendations are extensible to any web application no matter how it
    is built.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于.NET，因此也将专注于ASP.NET应用程序，尽管一些建议可以扩展到任何Web应用程序，无论其如何构建。
- en: 'Many studies have been carried on the reasons that move a user to uninstall
    an application or avoid using it. Four factors have been identified:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多研究都探讨了推动用户卸载应用程序或避免使用它的原因。已确定以下四个因素：
- en: The application (or website) freezes
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序（或网站）冻结
- en: The application crashes
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序崩溃
- en: Slow responsiveness
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应缓慢
- en: Heavy battery usage (for mobiles and tablets, obviously)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池消耗量大（对于移动设备和平板电脑来说，显然）
- en: So, battery considerations apart, the application should be fast, fluid and
    efficient. But what do these keywords really mean for us?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除了电池考虑之外，应用程序应该快速、流畅和高效。但这些关键词对我们来说究竟意味着什么呢？
- en: 'Fast means that going from a point A to a point B should always be done in
    minimal time: starting from application launching and going through navigation
    between pages, orientation changes, and so on.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速意味着从一个点A到点B的移动应该始终以最短的时间完成：从应用程序启动到在页面之间导航、方向变化等等。
- en: Fluid has to do with smooth interactions. Panning pages, soft animations intended
    to indicate changes in the state or information presented, the elimination of
    glitches, image flickering, and so on.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流畅性涉及到平滑的交互。翻页、软动画旨在指示状态或展示的信息的变化，消除故障、图像闪烁等等。
- en: 'An application or website is considered efficient when the use of resources
    is adequate: disk resources, memory footprint, battery life, bandwidth, and so
    on.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当资源的使用是适当的时候，一个应用程序或网站被认为是高效的：磁盘资源、内存占用、电池寿命、带宽等等。
- en: 'In any case, the overall performance is usually linked to the following areas:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，整体性能通常与以下领域相关：
- en: Hosting environment (IIS, usually)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管环境（通常是IIS）
- en: The ASP.NET environment
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET环境
- en: The application's code
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的代码
- en: The client side
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端
- en: So, let's quickly review some aspects to keep in mind at the time of optimizing
    these factors, along with some other tips generally accepted as useful when improving
    the page's performance.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们快速回顾一下在优化这些因素时需要考虑的一些方面，以及一些在提高页面性能时通常被认为有用的其他建议。
- en: IIS optimization
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIS 优化
- en: 'There are a few techniques that are widely recognized to be useful when optimizing
    IIS, so I''m going to summarize some of these tips offered by Brian Posey in *Top
    Ten Ways To Pump Up IIS Performance* ([https://technet.microsoft.com/es-es/magazine/2005.11.pumpupperformance.aspx](https://technet.microsoft.com/es-es/magazine/2005.11.pumpupperformance.aspx))
    in a Microsoft TechNet article:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化 IIS 时，有一些技术被广泛认为是有效的，所以我将总结一些 Brian Posey 在 *Top Ten Ways To Pump Up IIS
    Performance* ([https://technet.microsoft.com/es-es/magazine/2005.11.pumpupperformance.aspx](https://technet.microsoft.com/es-es/magazine/2005.11.pumpupperformance.aspx))
    这篇 Microsoft TechNet 文章中提供的建议：
- en: '**Make sure HTTP Keep-Alives are enabled**: This holds the connection open
    until all files'' requests are finished, avoiding unnecessary opening and closing.
    This feature is enabled by default since IIS6, but it''s wise to check just in
    case.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保启用 HTTP Keep-Alives**：这将在所有文件请求完成之前保持连接开启，避免不必要的打开和关闭。自 IIS6 以来，此功能默认启用，但出于谨慎，最好还是检查一下。'
- en: '**Tune connection timeouts**: This means that after a period of inactivity,
    IIS will close the connection anyway. Make sure the timeout configured is enough
    for your site.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整连接超时**：这意味着在一段时间的不活动后，IIS 无论如何都会关闭连接。请确保配置的超时时间足以满足您网站的需求。'
- en: '**Enable HTTP compression**: This is especially useful for static content.
    But beware of compressing dynamic pages: IIS should compress them each time for
    every request. If you have heavy traffic, the consequence is a lot of extra work.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 HTTP 压缩**：这对于静态内容特别有用。但请注意，压缩动态页面：IIS 应该为每个请求每次压缩它们。如果您有大量流量，后果是额外的很多工作。'
- en: '**Consider web gardens**: You can assign multiple worker processes to your
    application''s pool using a web garden. If one of these processes hangs, the rest
    can keep attending requests.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑使用 Web Gardens**：您可以使用 Web Gardens 将多个工作进程分配给应用程序池。如果其中某个进程挂起，其余的可以继续处理请求。'
- en: '**Object cache TTL (Time to Live)**: IIS caches requested objects and assigns
    a TTL to everyone (so they''re removed afterwards). However, note that if this
    time is not enough, you should edit the registry and be very careful with it (the
    earlier mentioned article explains how to do this).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象缓存 TTL（生存时间）**：IIS 缓存请求的对象并为每个对象分配一个 TTL（因此之后会删除它们）。但是，请注意，如果这个时间不够，您应该编辑注册表，并且要非常小心（前面提到的文章解释了如何做这件事）。'
- en: '**Recycle**: You can avoid memory leaks in the server by recycling memory.
    You can specify that IIS recycles the application pool at set intervals (every
    3 hours or whatever is fine for you) at a specific time each day or else when
    you consider that the application pool has received a sufficient number of requests.
    The `<recycle>` element in `web.config` allows you to tune this behavior.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回收**：您可以通过回收内存来避免服务器中的内存泄漏。您可以指定 IIS 在每天特定时间（例如每 3 小时或您认为合适的任何时间）或当您认为应用程序池已收到足够多的请求时回收应用程序池。`web.config`
    中的 `<recycle>` 元素允许您调整此行为。'
- en: '**Limit Queue Length**: Just in case you detect an excess in the requests on
    your server, it might be useful to limit the number of requests that IIS is allowed
    to serve.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制队列长度**：如果您在服务器上检测到请求过多，限制 IIS 允许服务的请求数量可能是有用的。'
- en: ASP.NET optimization
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET 优化
- en: There are many tips to optimize ASP.NET in the recent versions that correspond
    to bug fixes, improvements, and suggestions made to the development team by developers
    all over, and you'll find abundant literature on the Web about it. For instance,
    Brij Bhushan Mishra wrote an interesting article on this subject (refer to [http://www.infragistics.com/community/blogs/devtoolsguy/archive/2015/08/07/12-tips-to-increase-the-performance-of-asp-net-application-drastically-part-1.aspx](http://www.infragistics.com/community/blogs/devtoolsguy/archive/2015/08/07/12-tips-to-increase-the-performance-of-asp-net-application-drastically-part-1.aspx)),
    recommending some not-so-well-known aspects of the ASP.NET engine.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近版本的ASP.NET中，有许多优化技巧，这些技巧对应于错误修复、改进以及开发人员向开发团队提出的建议，您可以在网上找到大量关于此的文献。例如，Brij
    Bhushan Mishra撰写了一篇关于这个主题的有趣文章（参考[http://www.infragistics.com/community/blogs/devtoolsguy/archive/2015/08/07/12-tips-to-increase-the-performance-of-asp-net-application-drastically-part-1.aspx](http://www.infragistics.com/community/blogs/devtoolsguy/archive/2015/08/07/12-tips-to-increase-the-performance-of-asp-net-application-drastically-part-1.aspx)），推荐了一些不太为人所知的ASP.NET引擎方面。
- en: 'Generally speaking, we can divide optimization into several areas: **general
    and configuration**, **caching**, **load balancing**, **data access**, and **client
    side**.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我们可以将优化分为几个区域：**通用和配置**、**缓存**、**负载均衡**、**数据访问**和**客户端**。
- en: General and configuration
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用和配置
- en: 'Some general and configuration rules apply at the time of dealing with optimization
    of ASP.NET applications. Let''s see some of them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理ASP.NET应用程序的优化时，有一些通用的和配置规则适用。让我们看看其中的一些：
- en: Always remember to measure your performance issues in the **Release** mode.
    The difference might be noticeable and hides performance issues.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是记得在**发布**模式下测量您的性能问题。差异可能很明显，并隐藏性能问题。
- en: Remember to use the profiling tools we've seen and compare the same sites using
    these tools and different browsers (sometimes, a specific feature can be affected
    in one browser but not so much in others).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得使用我们看到的分析工具，并使用这些工具和不同的浏览器比较相同的网站（有时，某个特定的功能可能在一个浏览器中受到影响，而在其他浏览器中则不太受影响）。
- en: 'Revise unused modules in the pipeline: even if they''re not used, requests
    will have to pass through all modules predefined for your application''s pool.
    However, how do I know which modules are active?'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修订管道中的未使用模块：即使它们没有被使用，请求也必须通过为您的应用程序池预定义的所有模块进行传递。然而，我如何知道哪些模块是激活的？
- en: 'There''s an easy way to code this. We can use the application instance and
    recover the collection of modules loaded in a variable, as you can see in the
    following code. Later on, just mark a breakpoint to see the results:'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种简单的方法来实现这一点。我们可以使用应用程序实例并在一个变量中恢复加载的模块集合，正如您在以下代码中所看到的。稍后，只需设置一个断点来查看结果：
- en: '[PRE6]'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see something like the following screenshot to help you decide which
    is in use and which is not:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到以下截图，以帮助您决定哪些正在使用，哪些没有：
- en: '![General and configuration](img/image00671.jpeg)'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![通用和配置](img/image00671.jpeg)'
- en: 'Once you see all the modules in action, if your website requires no authentication,
    you can get rid of these modules, indicating that in the `Web.config` file:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您看到所有模块在运行，如果您的网站不需要身份验证，您可以删除这些模块，并在`Web.config`文件中指明：
- en: '[PRE7]'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this way, we will use only those modules that our application requires, and
    that happens with every request the application makes.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样，我们只会使用我们的应用程序所需的模块，并且每当应用程序发出请求时都会发生这种情况。
- en: 'The configuration of Pipeline Mode: Starting from IIS7, there are two pipeline
    modes available: **Integrated** and **Classic**. However, the latter is only for
    compatibility purposes with versions migrated from IIS 6\. If your application
    doesn''t have to cope with compatibility issues, make sure **Integrated** is active
    in the **Edit Application Pool** option of IIS Management.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道模式的配置：从IIS7开始，有两种管道模式可用：**集成**和**经典**。然而，后者仅用于与从IIS 6迁移的版本兼容。如果您的应用程序不需要处理兼容性问题，请确保在IIS管理中的**编辑应用程序池**选项中**集成**是激活的。
- en: 'A good idea is to flush your HTML as soon as it is generated (in your `web.config`)
    and disable **ViewState** if you are not using it: `<pages buffer="true" enableViewState="false">`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好主意是在HTML生成后立即将其刷新（在您的`web.config`中），如果您没有使用它，请禁用**ViewState**：`<pages buffer="true"
    enableViewState="false">`。
- en: 'Another option to optimize ASP.NET application''s performance is to remove
    unused View Engines. By default, the engine searches for views in different formats
    and different extensions:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化ASP.NET应用程序性能的另一个选项是删除未使用的视图引擎。默认情况下，引擎会在不同的格式和不同的扩展名中搜索视图：
- en: 'If you''re using only Razor and C#, it doesn''t make sense to have activated
    options that you''ll never use. So, an option is to disable all engines at the
    beginning and only enable Razor. Just add the following code to the `application_start`
    event:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只使用Razor和C#，那么激活你永远不会使用的选项是没有意义的。因此，一个选择是在开始时禁用所有引擎，只启用Razor。只需将以下代码添加到`application_start`事件中：
- en: '[PRE8]'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another configuration option to keep in mind is the feature called `runAllManagedModulesForAllRequests`,
    which we can find in `Web.config` or `applicationHost.config` files. It's similar
    to the previous one in a way since it forces the ASP.NET engine to run for every
    request, including those that are not necessary, such as CSS, image files, JavaScript
    files, and so on.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个需要记住的配置选项是名为`runAllManagedModulesForAllRequests`的功能，我们可以在`Web.config`或`applicationHost.config`文件中找到它。它在某种程度上与前面的选项相似，因为它强制ASP.NET引擎为每个请求运行，包括那些不必要的请求，如CSS、图像文件、JavaScript文件等。
- en: 'To configure this without interfering with other applications that might need
    it, we can use a local directory version of `Web.config`, where these resources
    are located, and indicate it in the same modules section that we used earlier,
    assigning this attribute value to `false`:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在不干扰可能需要它的其他应用程序的情况下配置此属性，我们可以使用位于这些资源所在位置的本地目录版本的`Web.config`，并在我们之前使用的相同模块部分中指示它，将此属性值分配给`false`：
- en: '[PRE9]'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use Gzip to make sure the content is compressed. In your `Web.config`, you
    can add the following:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gzip确保内容被压缩。在你的`Web.config`中，你可以添加以下内容：
- en: '[PRE10]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Caching
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存
- en: First of all, you should consider the **Kernel Mode Cache**. It's an optional
    feature that might not be activated by default.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该考虑**内核模式缓存**。这是一个可选功能，可能默认未激活。
- en: Requests go through several layers in the pipeline and caching can be done at
    different levels as well. Refer to the next figure:![Caching](img/image00672.jpeg)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求在管道中经过几个层次，缓存也可以在不同的级别进行。参考下一图：![缓存](img/image00672.jpeg)
- en: We can go to **Cache Configuration** in **IIS Administration Tools** and add
    a new configuration, enabling the **Kernel Model Caching** checkbox.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在**IIS管理工具**中的**缓存配置**中添加一个新的配置，并启用**内核模式缓存**复选框。
- en: 'In relation to this, you also have the choice of using client caching. If you
    add a definition in a folder that holds static content, most of the time, you''ll
    improve the web performance:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此相关，你还可以选择使用客户端缓存。如果你在包含静态内容的文件夹中添加定义，大多数情况下，你会提高Web性能：
- en: '[PRE11]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another option is to use the `<OutputCache>` attribute linked to an `action`
    method. In this case, caching can be more granular using only information linked
    to a given function.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选项是使用与`action`方法链接的`<OutputCache>`属性。在这种情况下，缓存可以更细粒度地使用仅与给定函数链接的信息。
- en: 'It''s easy to indicate this:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示这一点很容易：
- en: '[PRE12]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just remember that most of the properties of this attribute are compatible with
    the `<OutputCache>` directive, except `VaryByControl`.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需记住，此属性的多数属性与`<OutputCache>`指令兼容，除了`VaryByControl`。
- en: 'Besides cookies, you can use the new JavaScript 5 API''s `localStorage` and
    `sessionStorage` attribute, which offer the same functionality but with a number
    of advantages in security and very fast access:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了cookies之外，你还可以使用新的JavaScript 5 API的`localStorage`和`sessionStorage`属性，它们提供相同的功能，但在安全和非常快速访问方面具有许多优势：
- en: All data stored using `sessionStorage` is automatically erased from the local
    browser's cache when you abandon the website, while the `localStorage` values
    are permanent.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sessionStorage`存储的所有数据，当你离开网站时，将自动从本地浏览器的缓存中删除，而`localStorage`的值是永久的。
- en: Data access
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据访问
- en: We've already mentioned some techniques for faster data access in this book,
    but in general, just remember that good practices almost always have a positive
    impact on access, such as some of the patterns we've seen in [Chapter 10](part0055.xhtml#aid-1KEEU1
    "Chapter 10. Design Patterns"), *Design Patterns*. Also, consider using repository
    patterns.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中已经提到了一些加快数据访问的技术，但总的来说，只需记住良好的实践几乎总是对访问有积极影响，例如我们在[第10章](part0055.xhtml#aid-1KEEU1
    "第10章。设计模式")中看到的某些模式，*设计模式*。此外，考虑使用仓库模式。
- en: Another good idea is the use of `AsQueryable`, which only creates a query that
    can be changed later on using `Where` clauses.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好主意是使用`AsQueryable`，它只创建一个可以在以后使用`Where`子句进行更改的查询。
- en: Load balancing
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Besides what we can obtain using web gardens and web farms, asynchronous controllers
    are recommended by MSDN all over the documentation, whenever an action depends
    on external resources.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们可以通过Web花园和Web农场获得的内容外，MSDN在其所有文档中推荐使用异步控制器，每当操作依赖于外部资源时。
- en: 'Using the async/await structure that we''ve seen, we create non-blocking code
    that is always more responsive. Your code should then look like the sample provided
    by the ASP.NET site ([http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4](http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4)):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们看到的async/await结构，我们可以创建非阻塞代码，这总是更响应。您的代码应该看起来像ASP.NET网站提供的示例（[http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4](http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4)）：
- en: '[PRE13]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the big difference is that the `Action` method returns `Task<ActionResult>`
    instead of `ActionResult` itself. I recommend that you read the previously mentioned
    article for more details.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主要区别在于`Action`方法返回的是`Task<ActionResult>`而不是`ActionResult`本身。我建议您阅读之前提到的文章以获取更多详细信息。
- en: Client side
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Optimization in the client side can be a huge topic, and you''ll find hundreds
    of references on the Internet. The following are some of the most used and accepted
    practices:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的优化可以是一个很大的话题，您将在互联网上找到数百个参考。以下是一些最常用和接受的实践：
- en: Use the optimization techniques that we've seen included in modern browsers
    in order to determine possible bottlenecks.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现代浏览器中包含的优化技术来确定可能的瓶颈。
- en: Use the Single Page Application architecture based on AJAX queries to partially
    refresh your pages' contents.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于AJAX查询的单页应用程序架构可以部分刷新页面内容。
- en: Use CDNs for scripts and media content. This improves the loading time on the
    client side since these sites are already highly optimized.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CDN来处理脚本和媒体内容。由于这些站点已经高度优化，这可以改善客户端的加载时间。
- en: Use bundling and minification techniques. If your application is built using
    ASP.NET 4.5 or higher, this technique is enabled by default. These two techniques
    improve the request load time by reducing the number of requests to the server
    and reducing the size of the requested resources (such as CSS and JavaScript).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用打包和压缩技术。如果您的应用程序使用ASP.NET 4.5或更高版本构建，则此技术默认启用。这两种技术通过减少对服务器的请求数量和减少请求资源的尺寸（如CSS和JavaScript）来提高请求加载时间。
- en: This technique has to do with the functionality of modern browsers, which usually
    limit the number of simultaneous requests to six per hostname. So, every additional
    request is queued by the browser.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术与现代浏览器的功能有关，通常每个主机名将限制并发请求数量为六个。因此，每个额外的请求都会被浏览器排队。
- en: In this case, check the loading time, using what we saw in the browser tools
    to get detailed information about every request.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，检查加载时间，使用我们在浏览器工具中看到的方法来获取每个请求的详细信息。
- en: Bundling allows you to combine or bundle multiple files into a single file.
    This can be done for certain types of assets for which merging content does not
    provoke malfunctioning.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包允许您将多个文件组合或捆绑成一个文件。这可以用于某些类型的资产，合并内容不会导致故障。
- en: You can create CSS, JavaScript, and other bundles because fewer files mean fewer
    requests and that improves the first-page load performance.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建CSS、JavaScript和其他捆绑包，因为文件越少，请求越少，这可以提高首次页面加载性能。
- en: 'The official documentation of ASP.NET shows the following comparative table
    of results with and without this technique and the percentage of change obtained
    (refer to [http://www.asp.net/mvc/overview/performance/bundling-and-minification
    for the complete explanation](http://www.asp.net/mvc/overview/performance/bundling-and-minification%20for%20the%20complete%20explanation)):'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET的官方文档显示了以下带有和不带有此技术的结果比较表以及获得的变化百分比（有关完整说明，请参阅[http://www.asp.net/mvc/overview/performance/bundling-and-minification](http://www.asp.net/mvc/overview/performance/bundling-and-minification)）：
- en: '|   | Using B/M | Without B/M | Change |'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '|   | 使用B/M | 不使用B/M | 变化 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| File requests | 9 | 34 | 256% |'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| File requests | 9 | 34 | 256% |'
- en: '| KB sent | 3.26 | 11.92 | 266% |'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| KB sent | 3.26 | 11.92 | 266% |'
- en: '| KB received | 388.51 | 530 | 36% |'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| KB received | 388.51 | 530 | 36% |'
- en: '| Load time | 510 MS | 780 MS | 53% |'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| Load time | 510 MS | 780 MS | 53% |'
- en: 'As the documentation explains: The bytes sent had a significant reduction with
    bundling as browsers are fairly verbose with the HTTP headers they apply on requests.
    The received reduction in bytes is not as large because the largest files (`Scripts\jquery-ui-1.8.11.min.js`
    and `Scripts\jquery-1.7.1.min.js`) are already minified. Note that the timings
    on the sample program used the Fiddler tool to simulate a slow network. (From
    the Fiddler **Rules** menu, select **Performance** and then select **Simulate
    Modem Speeds**.)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档所述：通过捆绑，发送的字节数显著减少，因为浏览器在请求上应用的HTTP头信息相当冗长。由于最大的文件（`Scripts\jquery-ui-1.8.11.min.js`
    和 `Scripts\jquery-1.7.1.min.js`）已经进行了压缩，所以接收到的字节数减少并不大。请注意，样本程序中的时间使用Fiddler工具模拟了慢速网络。（从Fiddler的**规则**菜单中选择**性能**，然后选择**模拟调制解调器速度**。）
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at distinct tools and techniques related to the optimization
    of applications and performance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与应用程序和性能优化相关的不同工具和技术。
- en: First, we saw the concepts of Application Performance Engineering and we went
    through the tools available inside Visual Studio 2015 (any version) and the modern
    browsers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们了解了应用程序性能工程的概念，并回顾了Visual Studio 2015（任何版本）和现代浏览器中可用的工具。
- en: Then, we covered some of the most important processes to follow in order to
    detect issues and performance problems and explored how to use classes to fine-tune
    measurement.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了为了检测问题和性能问题而应遵循的一些最重要的流程，并探讨了如何使用类来微调测量。
- en: Finally, we reviewed some of the most important techniques recommended for the
    optimization of websites, especially those written with ASP.NET MVC.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了一些推荐用于优化网站的重要技术，特别是那些使用ASP.NET MVC编写的网站。
- en: In the final chapter, we will cover many features that are difficult to include
    in any of the previous chapters, including advanced techniques, such as parallelism,
    **platform invoke** and an introduction to the new .NET Core.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将介绍许多难以包含在前几章中的功能，包括高级技术，如并行处理、**平台调用**以及.NET Core的简介。
