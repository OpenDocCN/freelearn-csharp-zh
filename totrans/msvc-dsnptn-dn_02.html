<html><head></head><body>
<div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.2.1">Working with the Aggregator Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we looked at some of the key elements that make up microservices. </span><span class="koboSpan" id="kobo.3.2">We will turn our attention to more practical applications of these concepts, starting with</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.4.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">aggregator pattern</span></strong><span class="koboSpan" id="kobo.6.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">These </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.9.1">combine to set a premise for scoping an application being built on microservices design principles.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The aggregator pattern and domain-driven design go hand in hand. </span><span class="koboSpan" id="kobo.10.2">For now, we will refer to </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.12.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">DDD</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">So, a DDD </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.15.1">aggregate is a group of domain objects, combined as a single unit. </span><span class="koboSpan" id="kobo.15.2">In practicality, we might have a customer record different from its documents, but it is prudent of us to display all of these bits of data as a single point of data, an aggregate.</span></p>
<p><span class="koboSpan" id="kobo.16.1">After reading this chapter, we will be able to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Understand DDD</span></li>
<li><span class="koboSpan" id="kobo.18.1">Understand how to derive domains in a system process</span></li>
<li><span class="koboSpan" id="kobo.19.1">Understand the importance of aggregates and the aggregate pattern</span></li>
<li><span class="koboSpan" id="kobo.20.1">Distinguish between aggregates and entities</span></li>
<li><span class="koboSpan" id="kobo.21.1">Understand value objects and their role in the design process</span></li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">The code references used in this chapter can be found in the project repository, which is hosted on GitHub at </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch02"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch02</span></a></p>
<p><span class="koboSpan" id="kobo.25.1">Ensure that you have at least one of the following software installed on your machine to be able to execute this code (use the links to download and install):</span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Visual Studio 2022: </span><a href="https://visualstudio.microsoft.com/vs/"><span class="koboSpan" id="kobo.27.1">https://visualstudio.microsoft.com/vs/</span></a></li>
<li><span class="koboSpan" id="kobo.28.1">Visual Studio Code: </span><a href="https://code.visualstudio.com/download"><span class="koboSpan" id="kobo.29.1">https://code.visualstudio.com/download</span></a></li>
</ul>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.30.1">Exploring DDD and its significance</span></h1>
<p><span class="koboSpan" id="kobo.31.1">DDD is a software </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.32.1">design approach that encourages us</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.33.1"> as developers to assess processes and subprocesses and decipher all the atomic elements therein. </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">Atomic</span></strong><span class="koboSpan" id="kobo.35.1"> means that one process might have many moving parts, and while they all combine to give one output, they have their own routines to carry out. </span><span class="koboSpan" id="kobo.35.2">Each subprocess can be seen as self-governing and can further be attributed to a </span><em class="italic"><span class="koboSpan" id="kobo.36.1">domain</span></em><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">This motivates us to break up a monolith into independent microservices that do their own thing against their own data. </span><span class="koboSpan" id="kobo.37.3">That is a domain.</span></p>
<p><span class="koboSpan" id="kobo.38.1">Before we go much further, let’s take some time to explore certain keywords and their definitions:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">Models</span></strong><span class="koboSpan" id="kobo.40.1">: These are </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.41.1">abstractions that define aspects of a domain and are used to solve domain problems. </span><span class="koboSpan" id="kobo.41.2">We organize information about the target domain into smaller pieces and call them models. </span><span class="koboSpan" id="kobo.41.3">A model is a central point of reference in our design and development process. </span><span class="koboSpan" id="kobo.41.4">These models can then be grouped into logical modules and dealt with one at a time. </span><span class="koboSpan" id="kobo.41.5">A domain contains too much information for just one model and sometimes, parts of the information can just be omitted. </span><span class="koboSpan" id="kobo.41.6">For instance, our healthcare management system does need to capture customer information, but we do not need to know their eye and hair colors. </span><span class="koboSpan" id="kobo.41.7">This might be a simple example, but it might get far more complicated than that in a real scenario. </span><span class="koboSpan" id="kobo.41.8">Sifting through the relevant parts of the body of knowledge will require close collaboration with developers, domain experts, and fellow designers.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.42.1">Ubiquitous language</span></strong><span class="koboSpan" id="kobo.43.1">: This is a language that is unique to a domain model and is used by team members within the context of activities related to the specific domain. </span><span class="koboSpan" id="kobo.43.2">We have already established that models for a domain need to be developed through collaboration with domain experts. </span><span class="koboSpan" id="kobo.43.3">Given the difference in skillsets and perceptions, there will be communication barriers. </span><span class="koboSpan" id="kobo.43.4">Developers tend to think and speak about concepts relative to programming. </span><span class="koboSpan" id="kobo.43.5">They generally think and talk in terms of inheritance, polymorphism, and so on. </span><span class="koboSpan" id="kobo.43.6">Unfortunately, domain experts don’t usually know or care for any of that. </span><span class="koboSpan" id="kobo.43.7">Domain experts will use their own jargon and terms that developers will not understand. </span><span class="koboSpan" id="kobo.43.8">This gap in communication does not bode well for any team.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Bounded context</span></strong><span class="koboSpan" id="kobo.45.1">: This defines boundaries in a system or subsystem that informs the work that a particular team will carry out and the focal point of their efforts, within their </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.46.1">domain. </span><span class="koboSpan" id="kobo.46.2">A </span><em class="italic"><span class="koboSpan" id="kobo.47.1">bounded context</span></em><span class="koboSpan" id="kobo.48.1"> is a logical boundary of a domain, where</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.49.1"> terms and rules apply. </span><span class="koboSpan" id="kobo.49.2">All terms, definitions, and concepts inside this boundary</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.50.1"> form the </span><em class="italic"><span class="koboSpan" id="kobo.51.1">ubiquitous language</span></em><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">Establishing bounded contexts is a core step in DDD, and it is strategically used in scoping large models, in large teams. </span><span class="koboSpan" id="kobo.52.3">In DDD, we subdivide our larger models into bounded contexts and then we scope the relationships that exist in between. </span><span class="koboSpan" id="kobo.52.4">Context mapping in DDD can be </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.53.1">confusing</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.54.1"> without real-world examples. </span><span class="koboSpan" id="kobo.54.2">Let’s use our healthcare management system as a sample implementation for two scenarios that use bounded context maps and learn to analyze the relationships between the maps. </span><span class="koboSpan" id="kobo.54.3">Say we have the context of document management and patient appointments. </span><span class="koboSpan" id="kobo.54.4">Both have unrelated and related concepts. </span><span class="koboSpan" id="kobo.54.5">Documents only exist in a document management system but will have a reference to patients. </span><span class="koboSpan" id="kobo.54.6">Context mapping is a common strategy used in DDD to depict the relationships that exist between bounded contexts.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.55.1">Figure 2.1</span></em><span class="koboSpan" id="kobo.56.1"> shows a relationship between two domains:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 2.1 – Each domain is standalone, but sometimes data overlaps. Both appointment and document management need patient data" src="image/Figure_2.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 2.1 – Each domain is standalone, but sometimes data overlaps. </span><span class="koboSpan" id="kobo.58.2">Both appointment and document management need patient data</span></p>
<p><span class="koboSpan" id="kobo.59.1">Let’s take a step back from microservice design patterns and assess what it takes to just build software. </span><span class="koboSpan" id="kobo.59.2">A domain is a category of business rules and operations. </span><span class="koboSpan" id="kobo.59.3">If your software is to be used in a bank, then the domain is banking; if it is used in a hospital, then the domain is healthcare.</span></p>
<p><span class="koboSpan" id="kobo.60.1">So, the software</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.61.1"> we </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.62.1">develop must complement the domain in order to solve the overall problem. </span><span class="koboSpan" id="kobo.62.2">The core concepts and elements of the domain must be present in the software’s design and models.</span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.63.1">Exploring the pros and cons of DDD</span></h2>
<p><span class="koboSpan" id="kobo.64.1">DDD is a big</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.65.1"> commitment. </span><span class="koboSpan" id="kobo.65.2">It promotes focus on smaller, individual pieces of a domain, and the resulting software is more flexible. </span><span class="koboSpan" id="kobo.65.3">It breaks our application into smaller chunks and allows us to more easily modify application parts and components, with fewer side effects. </span><span class="koboSpan" id="kobo.65.4">The application’s code tends to be well organized and highly testable, and the business logic for the domain is isolated to that particular code base. </span><span class="koboSpan" id="kobo.65.5">Even if you don’t use DDD end to end for a project, the principles can be beneficial to your application implementation activities. </span><span class="koboSpan" id="kobo.65.6">DDD is best used for breaking down complex business logic. </span><span class="koboSpan" id="kobo.65.7">It is not suitable for applications with simple requirements and business logic for creating, adding, updating, and deleting data. </span><span class="koboSpan" id="kobo.65.8">DDD is time-consuming and requires expert-level domain knowledge. </span><span class="koboSpan" id="kobo.65.9">So, bear in mind that non-technical resource persons will be required and have to be available throughout the duration of a project.</span></p>
<p><span class="koboSpan" id="kobo.66.1">Now that we</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.67.1"> understand DDD at a high level, let’s explore how the concepts that it promotes tie into microservice design patterns.</span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.68.1">DDD and microservices</span></h2>
<p><span class="koboSpan" id="kobo.69.1">Implementations</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.70.1"> of applications that have been scoped using</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.71.1"> DDD are best implemented through microservices. </span><span class="koboSpan" id="kobo.71.2">By now, we can appreciate that a microservice architecture promotes dividing one large concept for an application into self-contained and independent services. </span><span class="koboSpan" id="kobo.71.3">So, to use the concept of boundaries and context, each microservice serves its own bounded context. </span><span class="koboSpan" id="kobo.71.4">Each one will have its own models, language, business rules, and technology stack.</span></p>
<p><span class="koboSpan" id="kobo.72.1">This is not a catch-all fix though, since perfect alignment between a microservice and a bounded context might not always be true, but some applications, including ours, are perfect candidates for microservices and DDD.</span></p>
<p><span class="koboSpan" id="kobo.73.1">We can consider a number of scenarios where we can isolate certain services that are not the most obvious ones and wouldn’t have been originally scoped as bounded contexts. </span><span class="koboSpan" id="kobo.73.2">Take, for example, email and alert systems. </span><span class="koboSpan" id="kobo.73.3">It is easy enough to place that logic and functionality in the web application, such that when an appointment is submitted, we send confirmations to our patients and alerts to the staff. </span><span class="koboSpan" id="kobo.73.4">This is reasonable, but we could also create separate message queue-based services that serve the sole purpose of delivering these messages. </span><span class="koboSpan" id="kobo.73.5">That way, the web application has even less responsibility, and we run less risk of inadvertently modifying UI logic when addressing an email or alert maintenance concern.</span></p>
<p><span class="koboSpan" id="kobo.74.1">Ultimately, because DDD suggests that we separate contexts into standalone tranches, a microservice architecture is the perfect development pattern to support this ambition. </span><span class="koboSpan" id="kobo.74.2">Bear in mind that DDD serves as an initial guideline to carve out business rules that can stand on their own, and each microservice will be developed to support that set of business rules, as well as implement supporting services in the most efficient and loosely coupled manner.</span></p>
<p><span class="koboSpan" id="kobo.75.1">Now that we can appreciate how DDD and microservices go hand in hand, let’s begin looking into </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.76.1">the</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.77.1"> aggregator pattern and how we can begin assessing the different models and data that need to be captured.</span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.78.1">The purpose and use of aggregate patterns</span></h1>
<p><span class="koboSpan" id="kobo.79.1">The </span><em class="italic"><span class="koboSpan" id="kobo.80.1">aggregate pattern</span></em><span class="koboSpan" id="kobo.81.1"> is a </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.82.1">specific software design pattern within DDD. </span><span class="koboSpan" id="kobo.82.2">It </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.83.1">promotes the collection of related entities and aggregates them into a unit.</span></p>
<p><span class="koboSpan" id="kobo.84.1">Aggregates make it easier to define ownership of elements in large systems. </span><span class="koboSpan" id="kobo.84.2">Without them, we run the risk of sprawling and trying to do too much. </span><span class="koboSpan" id="kobo.84.3">After we have identified the different contexts in the domain, we can then begin to extract the exact data we need from potentially multiple contexts and sources and model them.</span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.85.1">Aggregates and aggregate roots</span></h2>
<p><span class="koboSpan" id="kobo.86.1">An aggregate</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.87.1"> comprises</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.88.1"> one or more entities and value object models that, in one way or another, interact. </span><span class="koboSpan" id="kobo.88.2">This interaction then encourages us to treat them as a unit for data changes. </span><span class="koboSpan" id="kobo.88.3">We also want to ensure that, at all times, there is consistency in the aggregate before making changes. </span><span class="koboSpan" id="kobo.88.4">In our concept of a healthcare management system, we have already scoped that we have a patient, who more than likely also has an address. </span><span class="koboSpan" id="kobo.88.5">A set of changes to a patient record and their address should be treated as a single transaction. </span><span class="koboSpan" id="kobo.88.6">We also want to consider that aggregates have roots or a parent object for all other aggregate members.</span></p>
<p><span class="koboSpan" id="kobo.89.1">Aggregates make it easier to enforce certain rules for data and validation across multiple objects. </span><span class="koboSpan" id="kobo.89.2">So, in our example so far, a patient can have multiple addresses but needs to have at least one to be in a valid state. </span><span class="koboSpan" id="kobo.89.3">These kinds of constraints are easier to apply across the board from a higher level of the root. </span><span class="koboSpan" id="kobo.89.4">It is also easier to ensure that data changes</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.90.1"> follow </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">ACID</span></strong><span class="koboSpan" id="kobo.92.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Atomicity, Consistency, Isolation, and Durability</span></strong><span class="koboSpan" id="kobo.94.1">) principles. </span><span class="koboSpan" id="kobo.94.2">We will explore these more in a later chapter.</span></p>
<p><span class="koboSpan" id="kobo.95.1">The aggregate roots also help us to maintain invariants. </span><span class="koboSpan" id="kobo.95.2">Invariants are non-negotiable conditions that ensure that a system is consistent. </span><span class="koboSpan" id="kobo.95.3">A good metric to use in determining what should be an aggregate root is to consider whether deleting a record should trigger a cascade deletion of other objects in the hierarchy. </span><span class="koboSpan" id="kobo.95.4">In essence, our aggregate root represents a cluster of associated objects, treated as a unit for data-related changes.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.96.1">Figure 2.2</span></em><span class="koboSpan" id="kobo.97.1"> shows </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.98.1">a</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.99.1"> relationship between a root and a non-root entity:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.100.1"><img alt="Figure 2.2 – Patient is our aggregate root, and using Address as an example, we have other entities related to the root object" src="image/Figure_2.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.101.1">Figure 2.2 – Patient is our aggregate root, and using Address as an example, we have other entities related to the root object</span></p>
<p><span class="koboSpan" id="kobo.102.1">As you can see, the </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">Patient</span></strong><span class="koboSpan" id="kobo.104.1"> entity plays the role of the aggregate root and has a relationship with the </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Address</span></strong><span class="koboSpan" id="kobo.106.1"> entity.</span></p>
<p><span class="koboSpan" id="kobo.107.1">It is always good to use diagrams to visualize how different entities and objects relate. </span><span class="koboSpan" id="kobo.107.2">This will assist in giving a broader understanding during the scoping exercise, as we assess the role that each model will play in the domain and how our data strategies will come to life.</span></p>
<p><span class="koboSpan" id="kobo.108.1">Now, let’s turn</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.109.1"> our</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.110.1"> sights on exploring relationships a bit more. </span><span class="koboSpan" id="kobo.110.2">We need to look at other parts of the system and determine what should be a child, a parent, or simply a sibling.</span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.111.1">Relationships in aggregates</span></h2>
<p><span class="koboSpan" id="kobo.112.1">Considering that </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.113.1">aggregates are clusters of related objects, it is important for us to fully appreciate the relationships between these objects. </span><span class="koboSpan" id="kobo.113.2">Generally speaking, we consider relationships to be two-way associations – that is, object A is related to object B, and vice versa. </span><span class="koboSpan" id="kobo.113.3">For example, a patient has an appointment, and we need them to have an appointment. </span><span class="koboSpan" id="kobo.113.4">This way of thinking might contradict the tenets of DDD though, in the sense that we are trying to simplify things, and a two-way relationship might add complexity to the mission at hand.</span></p>
<p><span class="koboSpan" id="kobo.114.1">In DDD, we want to promote the notion that one-way relationships will suffice. </span><span class="koboSpan" id="kobo.114.2">If we go for two-way relationships, which might very well happen, we need to ensure that the added complexity is justifiable. </span><span class="koboSpan" id="kobo.114.3">A relationship allows one object to traverse the details of the other. </span><span class="koboSpan" id="kobo.114.4">This means, for the patient, we should be able to see all the details of the related appointment, but we do not need to see all the details of the patient when going in the other direction. </span><span class="koboSpan" id="kobo.114.5">A simple ID reference to the patient can suffice. </span><span class="koboSpan" id="kobo.114.6">If we introduce a full bidirectional relationship, then we create a direct dependency between appointments and patients, which isn’t necessarily true. </span><span class="koboSpan" id="kobo.114.7">A good measure to use in defining our models is to ask, “</span><em class="italic"><span class="koboSpan" id="kobo.115.1">Can I define this object without needing the other?</span></em><span class="koboSpan" id="kobo.116.1">”</span></p>
<p><span class="koboSpan" id="kobo.117.1">A good guideline to use to govern our decisions is that our aggregates should always flow in a single direction from the root to its dependents, and never the other way around.</span></p>
<p><span class="koboSpan" id="kobo.118.1">We have looked at relationships that are obvious and tightly knit, but what happens when relationships are more widely spread? </span><span class="koboSpan" id="kobo.118.2">Let’s discuss how we handle relationships that traverse aggregates.</span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.119.1">Handling relationships that span aggregates</span></h2>
<p><span class="koboSpan" id="kobo.120.1">We know that aggregates</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.121.1"> are boundaries between logical groupings in our applications. </span><span class="koboSpan" id="kobo.121.2">We enforce these segregations by restricting direct references to objects in the aggregate if they are not the root. </span><span class="koboSpan" id="kobo.121.3">In our example of the patient and the address, we can safely make the patient record reference the address, making our address an entity or value object.</span></p>
<p><span class="koboSpan" id="kobo.122.1">The key thing to note in this association is that the only way to get the correct address for a patient is by searching the patient record. </span><span class="koboSpan" id="kobo.122.2">The address won’t be referenced anywhere else. </span><span class="koboSpan" id="kobo.122.3">A patient, however, can be referenced from other aggregates, such as from an appointment record or a document. </span><span class="koboSpan" id="kobo.122.4">So, it is important to understand when a bit of data can be referenced directly, or not, and we can use this to guide what aggregates can be made central to our application’s design.</span></p>
<p><span class="koboSpan" id="kobo.123.1">Think about designing our data objects for a database access library such as Entity Framework, where we have to consider the implications of all </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">Create, Read, Update, and Delete</span></strong><span class="koboSpan" id="kobo.125.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.126.1">CRUD</span></strong><span class="koboSpan" id="kobo.127.1">) operations </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.128.1">against our data. </span><span class="koboSpan" id="kobo.128.2">Based on the general design pattern of our entity classes, we would place navigation objects inside of both entities in the relationship, but this could lead to cascading issues if not managed properly. </span><span class="koboSpan" id="kobo.128.3">This is a key design decision to make, as it is sometimes better to remove the navigation object, sacrificing some of the magic of Entity Framework, and retain greater control and predictability of how our models will interact. </span><span class="koboSpan" id="kobo.128.4">By retaining only the foreign key ID reference, we can better enforce one way for aggregates to relate to non-root entities. </span><span class="koboSpan" id="kobo.128.5">Now that we have an understanding of aggregates, aggregate roots, and how we formulate them, let’s explore entities and compare how they differ from aggregates.</span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.129.1">Aggregates versus entities</span></h1>
<p><span class="koboSpan" id="kobo.130.1">As discussed, aggregates </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.131.1">are </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.132.1">conceptually composed of entities and value objects that relate to each other in some way. </span><span class="koboSpan" id="kobo.132.2">We need to understand fully what an entity is and the role that it plays in our development process.</span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.133.1">Entities and why we need them</span></h2>
<p><span class="koboSpan" id="kobo.134.1">Decisions made </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.135.1">in DDD are</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.136.1"> driven by behavior, but behaviors require objects. </span><span class="koboSpan" id="kobo.136.2">These objects are referred to as </span><em class="italic"><span class="koboSpan" id="kobo.137.1">entities</span></em><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">An entity is a representation of data in your system, something that you need to be able to retrieve, track changes on, and store. </span><span class="koboSpan" id="kobo.138.3">Entities also typically have an identity key, most commonly an auto-incrementing integer or a GUID value. </span><span class="koboSpan" id="kobo.138.4">In code, you would want to create a base entity type that allows you to set the desired key type relative to the derived type. </span><span class="koboSpan" id="kobo.138.5">Here is an example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">BaseEntity</span></strong><span class="koboSpan" id="kobo.140.1"> class in C#:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.141.1">
public abstract class BaseEntity&lt;TId&gt;
    {
        public TId Id { get; set; }
    }</span></pre>
<p><span class="koboSpan" id="kobo.142.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">BaseEntity</span></strong><span class="koboSpan" id="kobo.144.1"> class will take a generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">type</span></strong><span class="koboSpan" id="kobo.146.1"> parameter, which allows us the flexibility of setting the ID type as needed. </span><span class="koboSpan" id="kobo.146.2">We also ensure that we set the class type as </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">abstract</span></strong><span class="koboSpan" id="kobo.148.1"> to prevent independent instantiation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">BaseEntity</span></strong><span class="koboSpan" id="kobo.150.1">.</span></p>
<p><span class="koboSpan" id="kobo.151.1">It is one thing to have a mental map of the entities and data persistence strategy that you intend to implement. </span><span class="koboSpan" id="kobo.151.2">But modeling and coding are oftentimes different activities when the buck stops. </span><span class="koboSpan" id="kobo.151.3">Given the unique demands of DDD, there are patterns and techniques that can be employed to ensure that certain technical attributes are implemented in our DDD-styled entities. </span><span class="koboSpan" id="kobo.151.4">It is important to establish the central entity for your system and then design all other parts around that one. </span><span class="koboSpan" id="kobo.151.5">For instance, it could be said that appointment booking is the most central operation of our system, so all other entities are just to be referenced. </span><span class="koboSpan" id="kobo.151.6">In another scope, patient record management could be seen as the most integral part, so we would want to focus on making that aspect as robust as possible.</span></p>
<p><span class="koboSpan" id="kobo.152.1">These scenarios show that the decisions that you make need to be relative to the mission at hand. </span><span class="koboSpan" id="kobo.152.2">One size does not fit all, and your design considerations need to be what is best for your overall context. </span><span class="koboSpan" id="kobo.152.3">Beyond that, we need to ensure that we have a good grasp of the operations to be carried out before we can start implementing domain events, repositories, factories, and any other business logic-related elements.</span></p>
<p><span class="koboSpan" id="kobo.153.1">Now, let’s look at the concrete uses of entities in our DDD-styled system. </span><span class="koboSpan" id="kobo.153.2">We need to understand how entities should be employed and their actual uses in our system.</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.154.1">Practical uses of entities in code</span></h2>
<p><span class="koboSpan" id="kobo.155.1">An entity is </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.156.1">primarily defined by its identity and is important to the domain model. </span><span class="koboSpan" id="kobo.156.2">It is very important that we design and implement entities carefully.</span></p>
<p><span class="koboSpan" id="kobo.157.1">An entity represents data that might need to traverse multiple microservices and, as a result, needs to have an identity value that can uniquely identify it in any system. </span><span class="koboSpan" id="kobo.157.2">We generally use sequential integers for our ID values in a relational database, but given this constraint, we cannot rely on that sequential value being used in multiple databases. </span><span class="koboSpan" id="kobo.157.3">For this reason, we usually employ the use </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.158.1">of a </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">GUID</span></strong><span class="koboSpan" id="kobo.160.1">, which is a generally randomly generated block of an alphanumeric string. </span><span class="koboSpan" id="kobo.160.2">It is not sequential, but it is easier to count on it being consistent, since we set it in code rather than rely on a database to set it.</span></p>
<p><span class="koboSpan" id="kobo.161.1">The same identity can be modeled across multiple microservices. </span><span class="koboSpan" id="kobo.161.2">In a scenario where an identity value is shared across microservices, this doesn’t necessarily suggest that the same attributes and behaviors will be the same in each microservice or bounded context. </span><span class="koboSpan" id="kobo.161.3">For instance, the patient entity in the Patient Management microservice might contain all of the key attributes and behaviors of the patient we would have scoped, but the same entity in the appointment booking microservice might only need minimal data and behaviors, as needed by the appointment booking process. </span><span class="koboSpan" id="kobo.161.4">The entity’s contents will always be relative to the requirements of the microservices or bounded context.</span></p>
<p><span class="koboSpan" id="kobo.162.1">Domain entities generally implement behaviors in the form of methods, as well as data attributes. </span><span class="koboSpan" id="kobo.162.2">In DDD, domain entities need to implement behaviors and logic that are only useful for the specific domain or entity. </span><span class="koboSpan" id="kobo.162.3">In the case of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">patient</span></strong><span class="koboSpan" id="kobo.164.1"> class, there must be validation-related tasks and operations implemented as methods. </span><span class="koboSpan" id="kobo.164.2">The methods will handle invariants and rules of the entity so that they are not spread across the application layer.</span></p>
<p><span class="koboSpan" id="kobo.165.1">At this point, we have started to see that our entity models might not just be classes with properties but might also implement behaviors. </span><span class="koboSpan" id="kobo.165.2">Next, we take a look at anemic and rich domain models and how we implement them.</span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.166.1">A rich domain model versus an anemic domain model</span></h2>
<p><span class="koboSpan" id="kobo.167.1">At this point, it is</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.168.1"> good to appreciate the </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.169.1">difference between an </span><em class="italic"><span class="koboSpan" id="kobo.170.1">anemic model</span></em><span class="koboSpan" id="kobo.171.1"> and a </span><em class="italic"><span class="koboSpan" id="kobo.172.1">rich model</span></em><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">A rich model is more behavioral in nature and fits the description of what we have described – that is, a model that implements methods for tasks relative to the model within the domain. </span><span class="koboSpan" id="kobo.173.3">An anemic model is more data-centric and tends to only implement properties. </span><span class="koboSpan" id="kobo.173.4">Anemic models are usually implemented as child entities, where there isn’t any special logic. </span><span class="koboSpan" id="kobo.173.5">The logic is implemented in the aggregate root, or the business logic layers. </span><span class="koboSpan" id="kobo.173.6">Anemic domain models are implemented using procedural style programming. </span><span class="koboSpan" id="kobo.173.7">This means that the model has no behaviors and only exposes properties for the data points that it will be storing. </span><span class="koboSpan" id="kobo.173.8">We then tend to put all our behavior in </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">service</span></strong><span class="koboSpan" id="kobo.175.1"> objects in the business layer and run the risk of ending up with spaghetti code, thus losing the advantages that a domain model provides.</span></p>
<p><span class="koboSpan" id="kobo.176.1">Let’s take a look at a simpler or anemic entity model:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
    public class Patient : BaseEntity&lt;int&gt;
    {
        public Patient(string name, string sex, int? 
</span><span class="koboSpan" id="kobo.177.2">          primaryDoctorId = null)
        {
            Name = name;
            Sex = sex;
            PrimaryDoctorId = primaryDoctorId;
        }
        public Patient(int id)
        {
            Id = id;
        }
        private Patient() // required for EF
        {
        }
        public string Name { get; private set; }
        public string Sex { get; private set; }
        public int? </span><span class="koboSpan" id="kobo.177.3">PrimaryDoctorId { get; private set; }
        public void UpdateName(string name)
        {
            Name = name;
        }
        public override string ToString()
        {
            return Name.ToString();
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.178.1">It is a good idea to</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.179.1"> enforce</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.180.1"> encapsulation in your class by requiring values to be set upon instantiation of the object. </span><span class="koboSpan" id="kobo.180.2">At the end of the day, your decision on how rich or anemic your model is depends on the use or general operations of the microservice. </span><span class="koboSpan" id="kobo.180.3">Anemic models might be perfect for more simple CRUD services, where DDD might be a stretch for what you need to design the system. </span><span class="koboSpan" id="kobo.180.4">They are more simply used to model our persistence models, since we only use the models for data storage and CRUD purposes. </span><span class="koboSpan" id="kobo.180.5">In the following code block, we will look at an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Appointment</span></strong><span class="koboSpan" id="kobo.182.1"> class being implemented as a rich domain model, including logic to handle certain key operations on the data.</span></p>
<p><span class="koboSpan" id="kobo.183.1">The example has been broken into smaller chunks of code to highlight the different general</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.184.1"> components</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.185.1"> of a rich data model:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
public class Appointment : BaseEntity&lt;Guid&gt;
{
        public Appointment(Guid id,
          int appointmentTypeId,
          Guid scheduleId,
          int doctorId,
          int patientId,
          int roomId,
          DateTime start,
          DateTime end,
          string title,
          DateTime? </span><span class="koboSpan" id="kobo.186.2">dateTimeConfirmed = null)
{
            Id = id;
            AppointmentTypeId = appointmentTypeId;
            ScheduleId = scheduleId;
            DoctorId = doctorId;
            PatientId = patientId;
            RoomId = roomId;
            Start = start;
            End = end;
            Title = title;
            DateTimeConfirmed = dateTimeConfirmed;
        }</span></pre>
<p><span class="koboSpan" id="kobo.187.1">At a minimum, we need to ensure that we use constructors to enforce object creation rules. </span><span class="koboSpan" id="kobo.187.2">We list the values that are needed at a minimum and do the assignments upon creation. </span><span class="koboSpan" id="kobo.187.3">It is </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.188.1">also </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.189.1">common practice to include validation checks and/or default values at this stage:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
        public void UpdateRoom(int newRoomId)
       {
            if (newRoomId == RoomId) return;
            RoomId = newRoomId;
        }
        public void UpdateStartTime(DateTime newStartTime,)
        {
            if (newStartTime == Start) return;
            Start = newStartTime;
        }
        public void Confirm(DateTime dateConfirmed)
        {
            if (DateTimeConfirmed.HasValue) return;
            DateTimeConfirmed = dateConfirmed;
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.191.1">We also have some examples of behaviors that we implement in the method. </span><span class="koboSpan" id="kobo.191.2">Traditionally, you would want to implement these in the business logic layer or a repository, but for a rich data model, we equip it with the methods it needs to morph its own data as needed. </span><span class="koboSpan" id="kobo.191.3">We can also implement our own validation rules in these methods.</span></p>
<p><span class="koboSpan" id="kobo.192.1">Now that we</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.193.1"> understand </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.194.1">what an entity is, the rules surrounding how they are created, and have general guidelines on how they can be implemented, we can now explore value objects and how they differ from entities in our domain model.</span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.195.1">Understanding and using value objects</span></h1>
<p><span class="koboSpan" id="kobo.196.1">We have</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.197.1"> observed</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.198.1"> the main attributes that entity objects should be identified by, which are continuity and identity, and not necessarily their values. </span><span class="koboSpan" id="kobo.198.2">This brings us to ask the question, </span><em class="italic"><span class="koboSpan" id="kobo.199.1">what do we call objects that are indeed defined by their values</span></em><span class="koboSpan" id="kobo.200.1">? </span><span class="koboSpan" id="kobo.200.2">These are value objects. </span><span class="koboSpan" id="kobo.200.3">They too have their place in the domain model, as they are used to measure and quantify parts of the domain. </span><span class="koboSpan" id="kobo.200.4">They do not boast identity keys in the same way that entities do, but their keys are formed through the composition of the values of all their properties, hence the name </span><em class="italic"><span class="koboSpan" id="kobo.201.1">value objects</span></em><span class="koboSpan" id="kobo.202.1">.</span></p>
<p><span class="koboSpan" id="kobo.203.1">Given that the data they store is so important in defining their identity and uniqueness in our system, it is of the utmost importance that these objects never change once created and are immutable. </span><span class="koboSpan" id="kobo.203.2">It is also important to understand the differences between entity models and value objects.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.204.1">Figure 2.3</span></em><span class="koboSpan" id="kobo.205.1"> shows a</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.206.1"> comparison</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.207.1"> between entities and value objects:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.208.1"><img alt="Figure 2.3 – Value ﻿objects are fundamentally different from domain entities, and it is important to appreciate these differences" src="image/Figure_2.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.209.1">Figure 2.3 – Value objects are fundamentally different from domain entities, and it is important to appreciate these differences</span></p>
<p><span class="koboSpan" id="kobo.210.1">Immutability means that the object’s properties should never change once these objects have been created. </span><span class="koboSpan" id="kobo.210.2">Instead, another instance should be created with the new intended values when necessary. </span><span class="koboSpan" id="kobo.210.3">If these objects need to be compared, we can do so by comparing all the values. </span><span class="koboSpan" id="kobo.210.4">This </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.211.1">has become easier and a bit more practical since the</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.212.1"> introduction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">record</span></strong><em class="italic"> </em><span class="koboSpan" id="kobo.214.1">types in C# 10. </span><span class="koboSpan" id="kobo.214.2">Records are different from class and structs in that </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">record</span></strong><span class="koboSpan" id="kobo.216.1"> types are based on value-based equality for comparisons. </span><span class="koboSpan" id="kobo.216.2">Two </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">record</span></strong><span class="koboSpan" id="kobo.218.1"> objects are considered equal if the record definitions are identical and the values in both records are equal for every field.</span></p>
<p><span class="koboSpan" id="kobo.219.1">Value objects are allowed to have methods and behaviors, but their scope should be limited. </span><span class="koboSpan" id="kobo.219.2">Methods should only compute and never change the state of the value object, or values therein, and note that it is immutable. </span><span class="koboSpan" id="kobo.219.3">Just remember, if new values are required, we should create a new object for that purpose.</span></p>
<p><span class="koboSpan" id="kobo.220.1">Let’s delve a bit deeper into the basics of value objects. </span><span class="koboSpan" id="kobo.220.2">The truth is that we use them all the time in our development tasks, probably without noticing. </span><span class="koboSpan" id="kobo.220.3">A common example of these would be string objects. </span><span class="koboSpan" id="kobo.220.4">A string in .NET and most other languages is a collection of characters, or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">char</span></strong><span class="koboSpan" id="kobo.222.1"> array. </span><span class="koboSpan" id="kobo.222.2">This character collection gives the string a value or a specific meaning. </span><span class="koboSpan" id="kobo.222.3">If we change one value of the character array, or reorder them, then we change the whole meaning of the string. </span><span class="koboSpan" id="kobo.222.4">In .NET, it is relatively easy to augment these values through string manipulation methods that allow us to change the letter cases or extract a part of the string. </span><span class="koboSpan" id="kobo.222.5">In doing these operations, we don’t actually change the value of the string, but we actually end up getting a whole new object with the new values. </span><span class="koboSpan" id="kobo.222.6">As we said, immutable objects do not change in value, but a new object must be created if a change is desired.</span></p>
<p><span class="koboSpan" id="kobo.223.1">When scoping value objects for your system, it is important to assess all the information that is needed from the start to make them airtight. </span><span class="koboSpan" id="kobo.223.2">A good example of making sure the information is correct would be weight. </span><span class="koboSpan" id="kobo.223.3">It is easy enough to store data on a patient and state that they weigh 50. </span><span class="koboSpan" id="kobo.223.4">But 50 by itself is useless, considering how many possible units of measurement </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.224.1">there are. </span><span class="koboSpan" id="kobo.224.2">So, in practicality, this value has no meaning without the </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.225.1">unit. </span><span class="koboSpan" id="kobo.225.2">Fifty lbs (pounds) is an entirely different measurement from 50 kg. </span><span class="koboSpan" id="kobo.225.3">We would also need to ensure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">class</span></strong><span class="koboSpan" id="kobo.227.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">record</span></strong><span class="koboSpan" id="kobo.229.1"> type being used to store this information places restrictions on which value can be updated at one time. </span><span class="koboSpan" id="kobo.229.2">For instance, changing the numeric value is fine, as a person may have gained or lost weight, but allowing the same flexibility to update the unit by itself can have a deeper impact on what the numeric value really means in terms of the weight change. </span><span class="koboSpan" id="kobo.229.3">It would be a good idea to ensure that the unit can only be set when simultaneously setting the number value of the weight. </span><span class="koboSpan" id="kobo.229.4">You can also consider appointment scheduling. </span><span class="koboSpan" id="kobo.229.5">We should never entertain the acceptance of a start date and time without an accompanying end date and time. </span><span class="koboSpan" id="kobo.229.6">If we set this appointment start and end date time combination in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">record</span></strong><span class="koboSpan" id="kobo.231.1"> type, then it will make it much easier to carry out equality checks for clashes, and we don’t need to clutter our code with overloads and excess logic to ensure that the appointment times are acceptable for the system.</span></p>
<p><span class="koboSpan" id="kobo.232.1">The most important goal here, once again, is to ensure that the state of the value object is not changed after it is created. </span><span class="koboSpan" id="kobo.232.2">So, whenever you choose to use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">record</span></strong><span class="koboSpan" id="kobo.234.1"> or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">class</span></strong><span class="koboSpan" id="kobo.236.1"> type, the values should be set through the constructor at the time of object creation, and all validation and invariant checks need to be in the constructor as well. </span><span class="koboSpan" id="kobo.236.2">Values should also generally be set to be read-only types in order to guard against modifications beyond that. </span><span class="koboSpan" id="kobo.236.3">Do remember though that, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">class</span></strong><span class="koboSpan" id="kobo.238.1"> type, you will need to ensure that you include appropriate logic for equality comparison, whereas a </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">record</span></strong><span class="koboSpan" id="kobo.240.1"> type comes with that built in, since it is based on value-based equality semantics.</span></p>
<p><span class="koboSpan" id="kobo.241.1">We have looked</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.242.1"> into</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.243.1"> value objects and what makes them so much different from entities. </span><span class="koboSpan" id="kobo.243.2">We have also reviewed the best ways to implement them in C# code, to ensure their unique characteristics.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.244.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.245.1">In this chapter, we explored quite a few things. </span><span class="koboSpan" id="kobo.245.2">We sought to understand the fundamentals of DDD and what makes it so different from a regular software design approach. </span><span class="koboSpan" id="kobo.245.3">We then broke down the elements of DDD into what the data objects and expectations would be. </span><span class="koboSpan" id="kobo.245.4">Finally, we reviewed value objects and explored under what circumstances we would formulate them, and the best ways to implement them in C#.</span></p>
<p><span class="koboSpan" id="kobo.246.1">In our next chapter, we will explore the chain of responsibility pattern and how synchronous communication is best implemented between our microservices.</span></p>
</div>
</body></html>