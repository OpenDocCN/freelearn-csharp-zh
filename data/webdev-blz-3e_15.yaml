- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Moving from, or Combining with, an Existing Site
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有网站迁移或与之结合
- en: In this chapter, we will take a look at how we can combine different technologies
    and frameworks with Blazor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何结合不同的技术和框架使用 Blazor。
- en: What if we already have a site?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有了一个网站呢？
- en: There are different options when it comes to moving from an existing site; the
    first question is, do we want to move from it, or do we want to combine it with
    the new technology?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到从现有网站迁移时，有多种选择；第一个问题是，我们是否想要从现有网站迁移，还是想要将其与新技术结合？
- en: Microsoft has a history of making it possible for technologies to co-exist,
    and this is what this chapter is all about.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 微软有让技术共存的历史，这正是本章的主题。
- en: How can we use Angular and React in our Blazor site, or how can we introduce
    Blazor into an existing Angular and React site?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 Blazor 网站中使用 Angular 和 React，或者如何将 Blazor 引入现有的 Angular 和 React 网站？
- en: 'In this chapter, we will cover the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Introducing web components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Web 组件
- en: Exploring custom elements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索自定义元素
- en: Exploring the Blazor component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Blazor 组件
- en: Adding Blazor to an Angular site
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Blazor 添加到 Angular 网站
- en: Adding Blazor to a React site
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Blazor 添加到 React 网站
- en: Adding Blazor to MVC/Razor Pages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Blazor 添加到 MVC/Razor Pages
- en: Adding web components to a Blazor site
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Web 组件添加到 Blazor 网站
- en: Migrating from web forms
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Web 表单迁移
- en: Combining technologies can be very useful, either because we can’t convert a
    whole site in one go or because other technologies are a better fit for what we
    are trying to accomplish.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结合技术可以非常有用，要么是因为我们一次无法转换整个网站，要么是因为其他技术更适合我们想要实现的目标。
- en: Having said that, I prefer using one technology on my site, not mixing Blazor
    with Angular or React. But during a migration period or if our team is mixed,
    there are benefits to mixing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我更喜欢在我的网站上使用一种技术，而不是将 Blazor 与 Angular 或 React 混合。但在迁移期间或如果我们的团队是混合的，混合也有其好处。
- en: There is a cost to mixing technologies, which we will look at throughout the
    chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 混合技术是有成本的，我们将在本章中探讨这一点。
- en: While writing this chapter, revisiting Angular and React, I must take the opportunity
    to say how much I love the Razor syntax. React is JavaScript with HTML tags inside,
    and Angular has templates, which I find pretty nice and remind me of what the
    Razor syntax looks like.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本章、回顾 Angular 和 React 的过程中，我必须抓住机会说，我有多么喜欢 Razor 语法。React 是带有 HTML 标签的 JavaScript，Angular
    有模板，我觉得很棒，让人联想到 Razor 语法的样子。
- en: 'However, there are a lot of things involved: almost 300 MB of Node.js modules,
    npm, TypeScript, and webpack. Well, the list is long.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，涉及到的内容很多：几乎 300 MB 的 Node.js 模块、npm、TypeScript 和 webpack。好吧，列表很长。
- en: I love working with Blazor because I don’t need to work with everything I just
    mentioned. In my opinion, Blazor has the best syntax out of the three options.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用 Blazor，因为我不需要处理我刚才提到的所有内容。在我看来，Blazor 在这三个选项中拥有最好的语法。
- en: Technical requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is a reference chapter and is not connected in any way with the
    other chapters of the book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个参考章节，并且与本书的其他章节没有任何关联。
- en: You can find the source code for this chapter’s examples at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter15).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter15)找到本章示例的源代码。
- en: Introducing web components
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Web 组件
- en: To work with JavaScript, whether it’s bringing JavaScript to Blazor or bringing
    Blazor into JavaScript, we can use a technology called web components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 JavaScript 一起工作，无论是将 JavaScript 带入 Blazor 还是将 Blazor 带入 JavaScript，我们可以使用一种称为
    Web 组件的技术。
- en: Web components are a set of web platform APIs that allow us to create new, custom,
    reusable HTML tags. They are packaged in an encapsulated way, and we can use them
    very similarly to how we use components in Blazor.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Web 组件是一组 Web 平台 API，允许我们创建新的、自定义的、可重用的 HTML 标签。它们以封装的方式打包，我们可以像在 Blazor 中使用组件一样使用它们。
- en: The really nice thing is that we can use them in any JavaScript library or framework
    that supports HTML.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的好处是，我们可以在支持 HTML 的任何 JavaScript 库或框架中使用它们。
- en: Web components are built on top of existing web standards like shadow DOM, ES
    modules, HTML templates, and custom elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Web 组件建立在现有的 Web 标准（如 shadow DOM、ES 模块、HTML 模板和自定义元素）之上。
- en: We will also recognize some of these technologies or variations of them in Blazor.
    Shadow DOM is the same as Blazor’s render tree, and ES modules are the type of
    JavaScript modules we looked at in *Chapter 10*, *JavaScript Interop*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将在Blazor中识别一些这些技术或它们的变体。Shadow DOM与Blazor的渲染树相同，ES模块是我们第10章中讨论的*JavaScript互操作*中查看的JavaScript模块类型。
- en: The technology we are going to take a look at in this chapter is **custom elements**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中探讨的技术是**自定义元素**。
- en: Exploring custom elements
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索自定义元素
- en: To bring Blazor into an existing Angular or React site, we use a feature called
    `CustomElements`. It was introduced as an experimental feature in .NET 6 and has
    been a part of the framework since .NET 7.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Blazor引入现有的Angular或React网站，我们使用一个名为`CustomElements`的功能。它是在.NET 6中作为一个实验性功能引入的，并从.NET
    7开始成为框架的一部分。
- en: The idea is to create parts of your site in Blazor without having to migrate
    fully over to Blazor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的情况是在Blazor中创建网站的部分，而不必完全迁移到Blazor。
- en: For this feature to work, we need to have an ASP.NET backend or manually make
    sure the `_framework` files are available. This is so that we can serve the Blazor
    framework files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能正常工作，我们需要有一个ASP.NET后端或手动确保`_framework`文件可用。这样我们就可以提供Blazor框架文件。
- en: There are two ways of running `CustomElements`;we can run it as Blazor WebAssembly
    or as the Blazor Server. Since we are adding Blazor to a client framework like
    React or Angular, the most relevant method is to run it as Blazor WebAssembly.
    Therefore, the examples in these first sections will be for Blazor WebAssembly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`CustomElements`有两种方式；我们可以将其作为Blazor WebAssembly或作为Blazor Server运行。由于我们正在将Blazor添加到像React或Angular这样的客户端框架中，最相关的方法是将它作为Blazor
    WebAssembly运行。因此，这些第一部分中的示例将是针对Blazor WebAssembly的。
- en: In the GitHub repo, there is a folder called `CustomElements` in which you will
    find the code for the projects, from which we will see sample code in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库中，有一个名为`CustomElements`的文件夹，其中包含项目的代码，我们将从本章中看到示例代码。
- en: It is worth mentioning that since the components are being served and used on
    the client, there is nothing that hinders us (or people who mean us harm) from
    decompiling the code (if we are using WebAssembly). This is something client-side
    developers of all frameworks deal with all the time, but it is worth mentioning
    again.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于组件是在客户端提供和使用的，因此没有任何东西阻止我们（或对我们造成伤害的人）反编译代码（如果我们使用WebAssembly）。这是所有框架的客户端开发者一直在处理的事情，但再次提一下也是值得的。
- en: Exploring the Blazor component
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Blazor组件
- en: The first thing we need to try out is a Blazor component. I have created a `counter`
    component inside a Blazor WebAssembly project named `BlazorCustomElements`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要尝试的第一件事是一个Blazor组件。我在一个名为`BlazorCustomElements`的Blazor WebAssembly项目中创建了一个`counter`组件。
- en: The default template comes with a lot of things, and the repo project is stripped
    to the bare minimum, so it is easy to understand.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板包含了很多东西，而repo项目被简化到最基本，因此很容易理解。
- en: 'The component is nothing different from what we have seen in the book previously;
    it’s a `counter` component with a parameter that sets how much the counter should
    count up. It looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 组件与我们之前在书中看到的不同，它是一个带有设置计数器应增加多少的参数的`counter`组件。它看起来像这样：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The project also needs a reference to the NuGet package:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目还需要对NuGet包有一个引用：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `Program.cs`, we need to register the component/custom element like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，我们需要像这样注册组件/自定义元素：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s it for the Blazor project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor项目就到这里了。
- en: Now it’s time to use our custom element.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用我们的自定义元素了。
- en: Adding Blazor to an Angular site
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Blazor添加到Angular网站
- en: Let’s look at how we can add Blazor to an existing Angular site. This demo is
    based on the Angular and ASP.NET Core template in Visual Studio.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将Blazor添加到现有的Angular网站中。这个演示基于Visual Studio中的Angular和ASP.NET Core模板。
- en: The folder is called `Angular`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件夹被命名为`Angular`。
- en: First, we need a reference to our Blazor library. I added the `BlazorCustomElement`
    project as a reference to the server project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对我们的Blazor库有一个引用。我将`BlazorCustomElement`项目作为引用添加到服务器项目中。
- en: We need a reference to the `Microsoft.AspNetCore.Components.WebAssembly.Server
    NuGet` package; this is so we can serve the framework files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对`Microsoft.AspNetCore.Components.WebAssembly.Server NuGet`包的引用；这样我们就可以提供框架文件。
- en: 'To make our site serve the framework files, we need to add the following to
    `Program.cs`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的网站提供框架文件，我们需要将以下内容添加到`Program.cs`中：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By default, Angular will be upset when we add our custom element because it
    does not recognize the tag. To fix this, we need to tell Angular that we are using
    custom elements. In the `angularproject.client/src/app/app.module.ts`, add the
    following things:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们添加自定义元素时，Angular会感到不满，因为它不识别该标签。为了解决这个问题，我们需要告诉Angular我们正在使用自定义元素。在`angularproject.client/src/app/app.module.ts`中添加以下内容：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure to replace the row that already has an import for `NgModule`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 确保替换掉已经包含对`NgModule`导入的行。
- en: 'A bit further down in the same file, add:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件的下方一点，添加以下内容：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now Angular is okay with having custom elements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Angular对使用自定义元素表示满意。
- en: 'Next, it’s time to add our component. In `angularproject.client /src/app/app.component.html`,
    we add our custom tag:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候添加我们的组件了。在`angularproject.client/src/app/app.component.html`中，我们添加我们的自定义标签：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we set the `increment-amount` parameter to `10`, which will increase
    the counter by `10` every time we click it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`increment-amount`参数设置为`10`，每次点击时计数器将增加`10`。
- en: 'To make this all work, we need to load a couple of JavaScript scripts. In `angularproject.client/src/index.html`,
    we need to add:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这一切都能正常工作，我们需要加载一些JavaScript脚本。在`angularproject.client/src/index.html`中，我们需要添加以下内容：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have one last thing we need to fix. When running the Angular project, it
    spins up a developer server. Actually, it spins up two: one for the ASP.NET backend
    and one for the Angular frontend. We need to make the Angular server send all
    the framework requests to the ASP.NET backend.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一件事需要修复。当运行Angular项目时，它会启动一个开发者服务器。实际上，它会启动两个：一个用于ASP.NET后端，一个用于Angular前端。我们需要让Angular服务器将所有框架请求发送到ASP.NET后端。
- en: 'In the default project template, this is already done for the `/weatherforecast`
    path. Add the following code to the `angularproject.client/proxy.conf.js` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认项目模板中，这已经为`/weatherforecast`路径完成了。将以下代码添加到`angularproject.client/proxy.conf.js`文件中：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We tell the developer server that if there is a request going to `weatherforecast`,
    `_framework`, or `_content`, we want to redirect that request to the ASP.NET backend.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉开发者服务器，如果请求是发送到`weatherforecast`、`_framework`或`_content`，我们希望将该请求重定向到ASP.NET后端。
- en: We now have a working Angular/Blazor WebAssembly hybrid. I was honestly amazed
    at how easy and straightforward this was the first time I tried it. It makes it
    so easy to include some Blazor components on your Angular site, so you can convert
    it into Blazor step by step, and component by component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的Angular/Blazor WebAssembly混合应用。我第一次尝试时，真的对它有多么简单和直接感到惊讶。这使得在Angular网站上包含一些Blazor组件变得非常容易，因此您可以逐步将其转换为Blazor，组件一个接一个。
- en: Next, we will do the same using a React site.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用React网站执行相同的操作。
- en: Adding Blazor to a React site
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Blazor添加到React网站
- en: Adding Blazor to a React site is very similar to Angular. This demo is based
    on the React and ASP.NET Core template in Visual Studio. The project is called
    `ReactProject`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将Blazor添加到React网站与添加到Angular非常相似。这个演示基于Visual Studio中的React和ASP.NET Core模板。项目名为`ReactProject`。
- en: First, we need a reference to our Blazor library, and I added the `BlazorCustomElement`
    project as a reference.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对Blazor库有一个引用，我添加了`BlazorCustomElement`项目作为引用。
- en: We need a reference to the `Microsoft.AspNetCore.Components.WebAssembly.Server
    NuGet` package; this is so we can serve the framework files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对`Microsoft.AspNetCore.Components.WebAssembly.Server NuGet`包的引用；这样我们就可以提供框架文件。
- en: 'To make our site serve the framework files, we need to add the following to
    `Program.cs`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的网站能够提供框架文件，我们需要在`Program.cs`中添加以下内容：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, it’s time to add our component. In `reactproject.client/src/ /App.tsx`,
    we add our custom tag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候添加我们的组件了。在`reactproject.client/src/App.tsx`中，我们添加我们的自定义标签：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, we set the `increment-amount` parameter to `10`, which will increase
    the counter by `10` every time we click it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`increment-amount`参数设置为`10`，每次点击时计数器将增加`10`。
- en: 'To make this all work, we need to load a couple of JavaScript. In `reactproject.client/index.html`,
    we need to add:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这一切都能正常工作，我们需要加载一些JavaScript。在`reactproject.client/index.html`中，我们需要添加以下内容：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These scripts will make sure our components load.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本将确保我们的组件加载。
- en: 'We have one last thing we need to fix. When running the React project, it spins
    up a developer server. Actually, it spins up two: one for the ASP.NET backend
    and one for the React frontend.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一件事需要修复。当运行React项目时，它会启动一个开发者服务器。实际上，它会启动两个：一个用于ASP.NET后端，一个用于React前端。
- en: We need to make the React server send all the framework requests to the ASP.NET
    backend. In the default project template, this is already done for the `/weatherforecast`
    path.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让 React 服务器将所有框架请求发送到 ASP.NET 后端。在默认项目模板中，这已经为 `/weatherforecast` 路径完成了。
- en: 'Add the following code to the `reactproject.client/vite.config.ts` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `reactproject.client/vite.config.ts` 文件中：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We tell the developer server that if a request goes to `weatherforecast`, `_framework`,
    or `_content`, we want to redirect that request to the ASP.NET backend.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉开发者服务器，如果请求发送到 `weatherforecast`、`_framework` 或 `_content`，我们希望将那个请求重定向到
    ASP.NET 后端。
- en: We now have a working React/Blazor WebAssembly hybrid. This is very similar
    to Angular, and I was amazed at how easy and straightforward this was as well.
    It makes it so easy to include some Blazor components on your React site, so you
    can convert it to Blazor step by step, component by component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的 React/Blazor WebAssembly 混合。这非常类似于 Angular，我对它如何简单直接感到惊讶。这使得在 React
    网站上包含一些 Blazor 组件变得非常容易，这样你可以逐步将它们转换为 Blazor。
- en: Next, we will do the same using a Razor Pages site.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用一个 Razor Pages 网站做同样的事情。
- en: Adding Blazor to MVC/Razor Pages
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Blazor 添加到 MVC/Razor Pages
- en: When I started with Blazor, this was exactly the scenario we wanted to address.
    We had an MVC/Razor Pages mix, and it was time for an upgrade.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始使用 Blazor 时，这正是我们想要解决的问题。我们有一个 MVC/Razor Pages 混合，是时候升级了。
- en: We solved it by implementing Razor Pages that referred to Razor components.
    Looking back at it now, it was not a pretty solution, at least not for a while,
    until we got to the point where most of the code was rewritten in Blazor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现引用了 Razor 组件的 Razor Pages 解决了这个问题。现在回想起来，这并不是一个很漂亮的解决方案，至少一开始不是，直到我们到达大多数代码都在
    Blazor 中重写的点。
- en: The challenge is that if we navigate to a page that has a Blazor component (a
    Razor component), that page is connected to the server and establishes a WebSocket.
    If we navigate away from a Blazor page to an MVC page, for example, we reload
    the entire page, and the script gets reloaded as well. A new connection was established,
    leaving the old one on the server for 3 minutes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于，如果我们导航到一个包含 Blazor 组件（一个 Razor 组件）的页面，该页面会连接到服务器并建立 WebSocket。如果我们从 Blazor
    页面导航到一个 MVC 页面，例如，我们会重新加载整个页面，脚本也会重新加载。新的连接被建立，而旧的连接在服务器上保持 3 分钟。
- en: We don’t have many users, and for us, that technique works long enough for us
    to finish the migration and launch a new Blazor version of the site.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户不多，对我们来说，这种技术足以让我们完成迁移并推出网站的新的 Blazor 版本。
- en: But I have some good news!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但我有好消息！
- en: We can also use the same custom elements to run on a Razor Pages site.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用相同的自定义元素在 Razor Pages 网站上运行。
- en: Let’s take a look!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看吧！
- en: The project is called `RazorPagesProject`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目被称为 `RazorPagesProject`。
- en: In the previous examples with Angular and React, those technologies are client
    side; therefore, we used WebAssembly. Razor Pages is server side, and even though
    we could use WebAssembly here as well, this is an excellent opportunity to take
    a look at making the **custom component** use Blazor Server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 Angular 和 React 示例中，那些技术是客户端的；因此，我们使用了 WebAssembly。Razor Pages 是服务器端的，尽管我们也可以在这里使用
    WebAssembly，但这是一个很好的机会来看看如何使 **自定义组件** 使用 Blazor 服务器。
- en: First, we need a reference to our Blazor library. I added the `BlazorCustomElement`
    project as a reference.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要引用我们的 Blazor 库。我添加了 `BlazorCustomElement` 项目作为引用。
- en: 'Then we need to enable Blazor Server in our Razor Pages by adding the following
    code to `Program.cs`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要通过在 `Program.cs` 中添加以下代码来在我们的 Razor Pages 中启用 Blazor 服务器。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `Pages/Shared/_Layout.cshtml`, we need to add the JavaScript:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Pages/Shared/_Layout.cshtml` 中，我们需要添加以下 JavaScript：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, we add the script for Blazor Server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们添加 Blazor 服务器端的脚本。
- en: 'Last but not least, we need to add our component. In `Pages/Index.cshtml`,
    we add:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要添加我们的组件。在 `Pages/Index.cshtml` 中，我们添加：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And we are done; the custom component is now running inside our Razor Pages
    site (which, of course, is an ASP.NET site with Razor Pages turned on).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了；自定义组件现在正在我们的 Razor Pages 网站内运行（当然，这是一个启用了 Razor Pages 的 ASP.NET 网站）。
- en: The cool part is that with only a few changes, we can switch this implementation
    to run WebAssembly instead of Blazor Server for the Blazor components.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最酷的部分是，只需进行一些更改，我们就可以将此实现切换为使用 WebAssembly 而不是 Blazor 服务器运行 Blazor 组件。
- en: Again, I am super impressed by this; it makes it so simple to migrate existing
    sites to Blazor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我对这个项目印象深刻；它使得将现有网站迁移到 Blazor 变得非常简单。
- en: Next, we will look at how we can use Angular or React controls on our Blazor
    website.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在我们的 Blazor 网站上使用 Angular 或 React 控件。
- en: Adding web components to a Blazor site
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Web 组件添加到 Blazor 网站
- en: We have looked at adding Blazor to an existing Angular, React, and even MVC/Razor
    Pages site.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何将 Blazor 添加到现有的 Angular、React 以及 MVC/Razor Pages 网站。
- en: But sometimes, that perfect library you love to use might not have a Blazor
    counterpart. We know that we can make a JavaScript interop and build it ourselves,
    but can we also use Angular and React libraries from Blazor?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，你可能非常喜欢使用的那个完美的库可能没有 Blazor 对应版本。我们知道我们可以创建一个 JavaScript 互操作并自己构建它，但我们是否也可以从
    Blazor 使用 Angular 和 React 库？
- en: We have two options here; either we can convert our site into an Angular/React
    site and use those examples, or we can convert the JavaScript library into a web
    component and use it from Blazor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个选择；要么我们可以将我们的网站转换为 Angular/React 网站，并使用那些示例，要么我们可以将 JavaScript 库转换为 Web
    组件，并在 Blazor 中使用它。
- en: Until now, we haven’t used npm or anything like that because, in most cases,
    we don’t need it. But now we are mixing technologies, and for that, npm is the
    easiest way. `npm` is outside the scope of this book, so I will not go into any
    details about it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有使用 npm 或类似的东西，因为在大多数情况下，我们不需要它。但现在我们在混合技术，为此，npm 是最简单的方式。`npm` 不在本书的范围之内，所以我就不会深入介绍它了。
- en: How to convert Angular/React or anything else into a web component is also outside
    the scope of this book.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将 Angular/React 或其他任何东西转换为 Web 组件也不在本书的范围之内。
- en: The project is called `BlazorProject`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目被称为 `BlazorProject`。
- en: 'We can browse some of the web components on this site: [https://www.webcomponents.org/](https://www.webcomponents.org/).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以浏览这个网站上的一些 Web 组件：[https://www.webcomponents.org/](https://www.webcomponents.org/)。
- en: I found a Markdown editor from GitHub. Even though we are not implementing it
    on our blog, feel free to go back and do so if you want to.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 GitHub 上找到了一个 Markdown 编辑器。即使我们不会在我们的博客上实现它，如果你愿意，也可以随时回去实现。
- en: 'We can read about the editor here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里了解编辑器：
- en: '[https://www.webcomponents.org/element/@github/markdown-toolbar-element](mailto:https://www.webcomponents.org/element/@github/markdown-toolbar-element)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.webcomponents.org/element/@github/markdown-toolbar-element](mailto:https://www.webcomponents.org/element/@github/markdown-toolbar-element)'
- en: 'To get the required JavaScript files, we need to set up `npm`. In the project
    folder (`BlazorProject.Client`), run the following commands:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所需的 JavaScript 文件，我们需要设置 `npm`。在项目文件夹（`BlazorProject.Client`）中，运行以下命令：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will bring down the JavaScript we need.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载我们需要的 JavaScript。
- en: Next, copy the `BlazorProject\node_modules\@github\markdown-toolbar-element\`
    folder to the `wwwroot` folder (in the server project) and include it in the project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `BlazorProject\node_modules\@github\markdown-toolbar-element\` 文件夹复制到
    `wwwroot` 文件夹（在服务器项目中），并将其包含在项目中。
- en: Now, the JavaScript will be accessible from our project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript 将可以从我们的项目中访问。
- en: 'In `app.razor`, we need to add a reference to the JavaScript, and we put it
    below the Blazor JavaScript:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.razor` 中，我们需要添加对 JavaScript 的引用，并将其放在 Blazor JavaScript 下方：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This component is an ES6 module, so we set the type to `"module"`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件是一个 ES6 模块，所以我们将其类型设置为 `"module"`。
- en: Now, all that is remaining is to add our component. In the demo project, I added
    it to the `MarkdownDemo` component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的事情就是添加我们的组件。在演示项目中，我将它添加到了 `MarkdownDemo` 组件中。
- en: 'First, the component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是组件：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then the text area with binding to a C# variable, `markdown`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是绑定到 C# 变量 `markdown` 的文本区域：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The C# variable changes as soon as we edit the textbox, either by using the
    toolbar or typing some text.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编辑文本框时，C# 变量会立即改变，无论是通过使用工具栏还是输入一些文本。
- en: We have integrated a web component into our Blazor project, which binds to a
    C# variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将一个 Web 组件集成到我们的 Blazor 项目中，它绑定到一个 C# 变量。
- en: This is super powerful and gives us new possibilities to add existing functionality
    to our Blazor site.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大，为我们提供了将现有功能添加到我们的 Blazor 网站的新可能性。
- en: Now we know how to handle SPA frameworks like React and Angular. But what about
    server frameworks like Web Forms? This is what we will look at next.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理像 React 和 Angular 这样的 SPA 框架。但关于像 Web 表单这样的服务器框架怎么办？这就是我们接下来要看的。
- en: Migrating from Web Forms
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Web 表单迁移
- en: Last but not least, we have **web forms**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们有 **Web 表单**。
- en: There is honestly not any good upgrade path for web forms; there was a project
    that aimed for code reuse when migrating to Blazor, but it is not being actively
    worked on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于 Web 表单并没有一个好的升级路径；曾经有一个项目旨在将代码重用到 Blazor 迁移中，但现在它并没有被积极开发。
- en: The first thing we should know is that Blazor is in many ways very similar to
    web forms, so the learning curve to get to Blazor is almost nonexistent since
    we have state management in web forms as well as Blazor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该知道的是，Blazor在许多方面与Web表单非常相似，因此学习Blazor的曲线几乎不存在，因为我们既有Web表单也有Blazor中的状态管理。
- en: There are some migration strategies where you would use **Yet Another Reverse
    Proxy** (**YARP**). Still, my recommendation would be to migrate a part of the
    website to Blazor and have two sites running, until we reach the point where it
    is feature-complete. Moving to Blazor is fairly quick to do, and in the end, I
    believe it will save you time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些迁移策略，你可能会使用**另一个反向代理**（**YARP**）。然而，我的建议是将网站的一部分迁移到Blazor，并让两个网站同时运行，直到我们达到功能完整的点。迁移到Blazor相对较快，最终我相信这将为您节省时间。
- en: When we moved our site from MVC to Blazor, we realized that, in some cases,
    it was faster to rewrite the component to Blazor than trying to solve it in MVC.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将我们的网站从MVC迁移到Blazor时，我们意识到在某些情况下，将组件重写为Blazor比在MVC中解决问题要快。
- en: Web forms should be even faster to convert since the backend code is more similar
    to Blazor than MVC.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后端代码与Blazor比MVC更相似，Web表单的转换应该更快。
- en: So, what should we do? Should we upgrade or keep using web forms? Upgrade –
    you will not be disappointed!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该怎么做呢？是升级还是继续使用Web表单？升级——你不会失望的！
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed adding Blazor to other technologies, like Angular, React, and Razor
    Pages, using web components in this chapter. We looked at how to add web components
    to a Blazor project and leverage JavaScript libraries in our Blazor app.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了将Blazor添加到其他技术中，如Angular、React和Razor Pages，使用Web组件。我们探讨了如何将Web组件添加到Blazor项目中，并在我们的Blazor应用程序中利用JavaScript库。
- en: Upgrading a current site to Blazor can be a lot of work. At my former employer,
    we made this journey 4 years ago. In our case, we wanted to update our MVC site
    to be more interactive. We went for Blazor, and I would argue it saved our project
    and made us more productive, resulting in a more interactive user experience.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有网站升级到Blazor可能是一项大量工作。在我以前雇主那里，我们4年前就经历了这个过程。在我们的案例中，我们希望更新我们的MVC网站以使其更具交互性。我们选择了Blazor，我认为这挽救了我们的项目并提高了我们的生产力，从而带来了更丰富的用户体验。
- en: In the next chapter, we will delve deeper into Blazor WebAssembly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨Blazor WebAssembly。
- en: Join our community on Discord
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
- en: '![](img/QR_Code2668029180838459906.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2668029180838459906.png)'
