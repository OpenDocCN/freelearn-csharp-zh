- en: Implementing Responsive Data Validation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现响应式数据验证
- en: Data validation goes hand in hand with data input forms and is essential for
    promoting clean, usable data. While the UI controls in WPF can automatically corroborate
    the fact that values entered match the type of their data bound properties, they
    cannot validate the correctness of the data entered.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据验证与数据输入表单密切相关，对于促进清洁、可用的数据至关重要。虽然 WPF 中的 UI 控件可以自动验证输入的值是否与它们的数据绑定属性的类型匹配，但它们无法验证输入数据的正确性。
- en: For example, a `TextBox` control that is data bound to an integer may highlight
    an error if a user entered a non-numeric value, but it wouldn't validate the fact
    that the number entered had the correct number of digits, or that the first four
    digits were appropriate for the type of credit card specified.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个绑定到整数的 `TextBox` 控件如果用户输入了非数字值，可能会突出显示错误，但它不会验证输入的数字是否具有正确的位数，或者前四位数字是否适合指定的信用卡类型。
- en: In order to validate these types of data correctness when using MVVM, we'll
    need to implement one of the .NET validation interfaces. In this chapter, we'll
    examine in detail the available interfaces, looking at a number of implementations
    and explore the other validation-related features that WPF provides us with. Let's
    start by looking at the validation system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在使用 MVVM 时验证这些类型的数据正确性，我们需要实现 .NET 验证接口之一。在本章中，我们将详细检查可用的接口，查看多个实现，并探索 WPF
    提供的其他与验证相关的功能。让我们首先看看验证系统。
- en: In WPF, the validation system very much revolves around the static `Validation`
    class. This class has several Attached Properties, methods, and an Attached Event
    that support data validation. Each binding instance has a `ValidationRules` collection
    that can contain `ValidationRule` elements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 中，验证系统很大程度上围绕静态的 `Validation` 类。这个类有几个附加属性、方法和一个附加事件，支持数据验证。每个绑定实例都有一个
    `ValidationRules` 集合，可以包含 `ValidationRule` 元素。
- en: 'WPF provides three built-in rules:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 提供了三个内置规则：
- en: The `ExceptionValidationRule` object checks for any exceptions thrown as the
    binding source property is updated.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExceptionValidationRule` 对象检查在更新绑定源属性时抛出的任何异常。'
- en: The `DataErrorValidationRule` class checks for errors that may be raised by
    classes that implement the `IDataErrorInfo` interface.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataErrorValidationRule` 类检查实现 `IDataErrorInfo` 接口的类可能引发的错误。'
- en: The `NotifyDataErrorValidationRule` class checks for errors raised by classes
    that implement the `INotifyDataErrorInfo` interface.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotifyDataErrorValidationRule` 类检查实现 `INotifyDataErrorInfo` 接口的类引发的错误。'
- en: Each time an attempt is made to update a data source property, the binding engine
    first clears the `Validation.Errors` collection and then checks the binding's
    `ValidationRules` collection to see whether it contains any `ValidationRule` elements.
    If it does, it calls each rule's `Validate` method in turn until they all pass,
    or one returns an error.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每次尝试更新数据源属性时，绑定引擎首先清除 `Validation.Errors` 集合，然后检查绑定的 `ValidationRules` 集合，看它是否包含任何
    `ValidationRule` 元素。如果包含，它会依次调用每个规则的 `Validate` 方法，直到所有规则都通过，或者其中一个返回错误。
- en: When a data bound value fails the condition in the `Validation` method of a
    `ValidationRule` element, the binding engine adds a new `ValidationError` object
    to the `Validation.Errors` collection of the data binding target control.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据绑定值在 `ValidationRule` 元素的 `Validation` 方法中失败条件时，绑定引擎会将一个新的 `ValidationError`
    对象添加到数据绑定目标控件的 `Validation.Errors` 集合中。
- en: This, in turn, will set the `Validation.HasError` Attached Property of the element
    to `true` and, if the `NotifyOnValidationError` property of the binding is set
    to `true`, the binding engine will also raise the `Validation.Error` Attached
    Event on the data binding target.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使元素的 `Validation.HasError` 附加属性设置为 `true`，并且如果绑定的 `NotifyOnValidationError`
    属性设置为 `true`，绑定引擎还会在数据绑定目标上引发 `Validation.Error` 附加事件。
- en: Using validation rules – to do or not to do?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验证规则——做还是不做？
- en: In WPF, there are two different approaches for dealing with data validation.
    On the one hand, we have the UI-based `ValidationRule` classes, the `Validation.Error` Attached
    Event, and the `Binding.NotifyOnValidationError` and `UpdateSourceExceptionFilter`
    properties, and, on the other, we have two code-based validation interfaces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 中，处理数据验证有两种不同的方法。一方面，我们有基于 UI 的 `ValidationRule` 类、`Validation.Error`
    附加事件以及 `Binding.NotifyOnValidationError` 和 `UpdateSourceExceptionFilter` 属性，另一方面，我们还有两个基于代码的验证接口。
- en: While the `ValidationRule` classes and their related validation approach work
    perfectly well, they are specified in the XAML and, as such, are tied to the UI.
    Furthermore, when using the `ValidationRule` classes, we are effectively separating
    the validation logic from the data Models that they are validating and storing
    it in a completely different assembly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ValidationRule`类及其相关验证方法工作得非常完美，但它们是在XAML中指定的，因此与UI绑定。此外，当使用`ValidationRule`类时，我们实际上是将验证逻辑从它们验证的数据模型中分离出来，并将其存储在完全不同的程序集中。
- en: When developing a WPF application using the MVVM methodology, we work with data,
    rather than UI elements, and so we tend to shy away from using the `ValidationRule`
    classes and their related validation strategy directly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MVVM方法开发WPF应用程序时，我们与数据而不是UI元素一起工作，因此我们往往避免直接使用`ValidationRule`类及其相关的验证策略。
- en: Additionally, the `NotifyOnValidationError` and `UpdateSourceExceptionFilter`
    properties of the `Binding` class also require event or delegate handlers, respectively,
    and, as we have discovered, we prefer to avoid doing this when using MVVM. Therefore,
    we will not be looking at this UI-based validation approach in this book, instead
    focusing on the two code-based validation interfaces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Binding`类的`NotifyOnValidationError`和`UpdateSourceExceptionFilter`属性也需要事件或委托处理程序，正如我们所发现的，我们更喜欢在MVVM中使用时避免这样做。因此，我们不会在本书中探讨基于UI的验证方法，而是专注于两个基于代码的验证接口。
- en: Getting to grips with validation interfaces
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握验证接口
- en: In WPF, we have access to two main validation interfaces; the original one is
    the `IDataErrorInfo` interface, and, in .NET 4.5, the `INotifyDataErrorInfo` interface
    was added. In this section, we'll first investigate the original validation interface
    and its shortcomings and see how we can make it more usable, before examining
    the latter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，我们有访问两个主要验证接口的能力；原始的一个是`IDataErrorInfo`接口，而在.NET 4.5中，添加了`INotifyDataErrorInfo`接口。在本节中，我们将首先研究原始验证接口及其不足，并看看我们如何使其更易于使用，然后再检查后者。
- en: Implementing the IDataErrorInfo interface
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现IDataErrorInfo接口
- en: The `IDataErrorInfo` interface is a very simple affair, with only two required
    properties to implement. The `Error` property returns the error message that describes
    the validation error, and the `Item[string]` indexer returns the error message
    for the specified property.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDataErrorInfo`接口非常简单，只需要实现两个必需的属性。`Error`属性返回描述验证错误的错误消息，而`Item[string]`索引器返回指定属性的错误消息。'
- en: 'It certainly seems straightforward enough, so let''s take a look at a basic
    implementation of this interface. Let''s create another base class to implement
    this in and, for now, omit all other unrelated base class members so that we can
    concentrate on this interface:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来足够简单，那么让我们看看这个接口的基本实现。让我们创建另一个基类来实现这个接口，并且现在省略所有其他无关的基类成员，以便我们可以专注于这个接口：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this simplest of implementations, we have declared a protected `error` field,
    which will be accessible to derived classes. Note that the `Error` property that
    returns it uses the C# 6.0 expression-bodied property syntax. This syntax is a
    shorthand notation for methods, properties, indexers, constructors, and destructors,
    where the member body is replaced by an inline expression.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最简单的实现中，我们声明了一个受保护的`error`字段，它将被派生类访问。请注意，返回它的`Error`属性使用了C# 6.0表达式主体属性语法。这种语法是方法的简写表示法，其中成员体被内联表达式替换。
- en: We have declared the class indexer (the `this` property) as `virtual`, so that
    we can override it in the derived classes. Another option would be to declare
    it as `abstract`, so that derived classes were forced to override it. Whether
    you prefer to use `virtual` or `abstract` will depend on your particular circumstances,
    such as whether you expect every derived class to require validation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将类索引器（`this`属性）声明为`virtual`，这样我们就可以在派生类中重写它。另一个选择是将它声明为`abstract`，这样派生类就必须重写它。您是否更喜欢使用`virtual`或`abstract`将取决于您的具体情况，例如，您是否期望每个派生类都需要验证。
- en: 'Let''s take a look at an example of a class that derives from our new base
    class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个从我们的新基类派生出的类的示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we have a basic `Product` class that extends our new base class. The only
    job that each derived class that wants to participate in the validation process
    needs to do is to override the class indexer and supply details regarding their
    relevant validation logic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个基本的`Product`类，它扩展了我们的新基类。每个想要参与验证过程的派生类需要做的唯一工作就是重写类索引器，并提供有关其相关验证逻辑的详细信息。
- en: In the indexer, we first set the `error` field to an empty string. Note that
    this is an essential part of this implementation, as without it, any triggered
    validation errors would never be cleared. There are a number of ways to implement
    this method, with several different abstractions being possible. However, all
    implementations require validation logic to be run when this property is called.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引器中，我们首先将`error`字段设置为空字符串。请注意，这是此实现的一个基本部分，因为没有它，任何触发的验证错误永远不会被清除。有几种方法可以实现此方法，有几种不同的抽象是可能的。然而，所有实现都需要在调用此属性时运行验证逻辑。
- en: In our particular example, we simply use an `if` statement to check for errors
    in each property, although a `switch` statement works just as well here. The first
    condition checks the value of the `propertyName` input parameter, while multiple
    validation rules per property can be handled with inner `if` statements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定示例中，我们简单地使用一个`if`语句来检查每个属性的错误，尽管在这里`switch`语句也适用。第一个条件检查`propertyName`输入参数的值，而每个属性的多个验证规则可以通过内部的`if`语句来处理。
- en: If the `propertyName` input parameter equals `Name`, then we first check to
    ensure that it has some value and provide an error message in case of failure.
    If the property value is not `null` or empty, then a second validation condition
    checks that the length is no longer than 25 characters, which simulates a particular
    database constraint that we may have.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`propertyName`输入参数等于`Name`，那么我们首先检查确保它有一些值，并在失败的情况下提供错误消息。如果属性值不是`null`或空，那么第二个验证条件检查长度是否不超过25个字符，这模拟了我们可能有的特定数据库约束。
- en: If the `propertyName` input parameter equals `Price`, then we simply check that
    a valid, positive value has been entered and provide another error message in
    case of failure. If we had further properties in this class, then we would simply
    add further `if` conditions, checking their property names, and further relevant
    validation checks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`propertyName`输入参数等于`Price`，那么我们只需检查是否输入了一个有效且正的值，并在失败的情况下提供另一个错误消息。如果我们在这个类中有更多的属性，那么我们只需添加更多的`if`条件，检查它们的属性名，并进行进一步的验证检查。
- en: 'Now that we have our validatable class, let''s add a new View and View Model
    and the `DataTemplate` in the `App.xaml` file that connects the two, to demonstrate
    what else we need to do to get our validation logic connected to the data in the
    UI. Let''s first see the `ProductViewModel` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了可验证的类，让我们在`App.xaml`文件中添加一个新的视图和视图模型以及`DataTemplate`，以连接这两个组件，展示我们还需要做什么才能将验证逻辑连接到UI中的数据。让我们首先看看`ProductViewModel`类：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ProductViewModel` class simply defines a single `Product` object and exposes
    it via the `Product` property. Let''s now add some basic styles to the application
    resources file, which we''ll use in the related View:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductViewModel`类简单地定义了一个单个的`Product`对象，并通过`Product`属性公开它。现在让我们向应用程序资源文件中添加一些基本样式，我们将在相关的视图中使用这些样式：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now, let''s see the View:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看视图：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the XAML, we have a typical two column `Grid` panel, with two rows. The two
    `TextBlock` labels have the `LabelStyle` style applied, and the two `TextBox`
    input controls have the `FieldStyle` style applied. The binding applied to each
    `TextBox.Text` property has two important properties set on it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML中，我们有一个典型的两列`Grid`面板，有两行。两个`TextBlock`标签应用了`LabelStyle`样式，两个`TextBox`输入控件应用了`FieldStyle`样式。应用于每个`TextBox.Text`属性绑定的有两个重要属性被设置。
- en: The first is the `UpdateSourceTrigger` property, and this controls when the
    data source is updated and therefore, also when validation occurs. If you remember,
    a value of `PropertyChanged` causes updates to occur as soon as the data bound
    property value changes. An alternative value would be `LostFocus`, which causes
    updates to occur when the UI control loses focus, for example, when tabbing to
    the next control.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`UpdateSourceTrigger`属性，它控制数据源何时更新，因此也控制验证何时发生。如果你还记得，`PropertyChanged`的值会导致数据绑定属性值变化时立即发生更新。另一个值可以是`LostFocus`，它会在UI控件失去焦点时（例如，在切换到下一个控件时）导致更新。
- en: The other important property here is the `ValidatesOnDataErrors` property, without
    which our current example would not work. Setting this property to `True` on a
    binding causes a built-in `DataErrorValidationRule` element to be implicitly added
    to the `Binding.ValidationRules` collection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个重要的属性是 `ValidatesOnDataErrors` 属性，没有它，我们的当前示例将无法工作。将此属性设置为 `True` 在绑定上会导致内置的
    `DataErrorValidationRule` 元素隐式添加到 `Binding.ValidationRules` 集合中。
- en: As the data bound value changes, this element will check for errors raised by
    the `IDataErrorInfo` interface. It does this by calling the indexer in our data
    Model, with the name of the data bound property each time the data source is updated.
    Therefore, in this basic example, developers would be responsible for setting
    this property to `True` on each binding to make the validation work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据绑定值发生变化时，此元素将检查由 `IDataErrorInfo` 接口引发的错误。它是通过每次数据源更新时调用我们数据模型中的索引器，并使用数据绑定属性名称来完成的。因此，在这个基本示例中，开发者将负责在每次绑定时将此属性设置为
    `True` 以使验证生效。
- en: In .NET 4.5, Microsoft introduced a breaking change to the way that numeric
    data is entered in the `TextBox` control when the `UpdateSourceTrigger` binding is
    set to `PropertyChanged`. Their change stops users from entering numerical separators.
    Refer to the *Keeping Synchronized with Legacy Behavior* section later in this
    chapter to find out why and how to work around this issue.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 4.5 中，微软对当 `UpdateSourceTrigger` 绑定设置为 `PropertyChanged` 时 `TextBox`
    控件中输入数值数据的方式引入了一个破坏性更改。他们的更改阻止用户输入数值分隔符。请参阅本章后面的 *与旧行为保持同步* 部分，以了解原因和如何解决这个问题。
- en: 'When using a value of `PropertyChanged` for the `UpdateSourceTrigger` property,
    along with the fact that we validate each time the properties change, we have
    the benefit of immediate updates of errors. However, this method of validation
    works in a pre-emptive manner, with all validation errors being shown *b**efore*
    the user has a chance to enter any data. This can be somewhat off-putting to a
    user, so let''s take a quick look at our example when it first starts:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `PropertyChanged` 作为 `UpdateSourceTrigger` 属性的值，并且每次属性更改时都进行验证时，我们就有立即更新错误的优点。然而，这种验证方法是以预防性方式进行的，所有验证错误都会在用户有机会输入任何数据之前显示出来。这可能会让用户感到有些不快，所以让我们快速看一下示例程序启动时的样子：
- en: '![](img/1bc6e515-3321-4282-9ea5-0f37aff5e791.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bc6e515-3321-4282-9ea5-0f37aff5e791.png)'
- en: As you can see, it's clear that there are some problems, but it's unclear as
    to what they are. So far, we have no output for our error messages. One common
    output that we could use would be the tooltips of the various form controls.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，很明显存在一些问题，但尚不清楚它们是什么。到目前为止，我们还没有输出错误消息。我们可以使用的一个常见输出是各种表单控件的工具提示。
- en: 'We could add a trigger to our `FieldStyle` style, which listened to the `Validation.HasError` Attached
    Property and set the `TextBox` control''s tooltip to the `ErrorContent` property
    of the error whenever one was present. This is how Microsoft has traditionally
    demonstrated how to do this on their website:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的 `FieldStyle` 样式添加一个触发器，该触发器监听 `Validation.HasError` 附加属性，并在出现错误时将 `TextBox`
    控件的工具提示设置为错误的 `ErrorContent` 属性。这就是微软在他们的网站上传统上展示如何做到这一点的方式：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we use brackets in the binding path for the `Validation.Errors` collection
    because it is an Attached Property, and that we use the `RelativeSource.Self`
    instance because we want to target the `Errors` collection of the `TextBox` control
    itself. Also note that this example only displays the first `ValidationError`
    object in the `Errors` collection.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `Validation.Errors` 集合的绑定路径中使用方括号，因为它是一个附加属性，我们使用 `RelativeSource.Self`
    实例，因为我们想针对 `TextBox` 控件本身的 `Errors` 集合。此外，请注意，此示例仅显示 `Errors` 集合中的第一个 `ValidationError`
    对象。
- en: 'Using this style on our data bound `TextBox` controls helps to provide the
    user with further information when they position their mouse cursor over the relevant
    control(s):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据绑定 `TextBox` 控件上使用此样式有助于在用户将鼠标光标置于相关控件上时提供更多信息：
- en: '![](img/bab6015a-c774-409b-9b26-68a4c7ba4e4c.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bab6015a-c774-409b-9b26-68a4c7ba4e4c.png)'
- en: 'However, when there are no validation errors to display, an error will be seen
    in the Output window of Visual Studio, because we are attempting to view the first
    error from the `Validation.Errors` Attached Property collection, but none exist:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当没有要显示的验证错误时，Visual Studio 的输出窗口中会出现错误，因为我们正在尝试从 `Validation.Errors` 附加属性集合中查看第一个错误，但不存在：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a number of ways to avoid this error, such as simply displaying the
    whole collection, and we'll see an example of this later in the chapter. However,
    the simplest way is to make use of the `CurrentItem` property of the `ICollectionView`
    object that is implicitly used to wrap `IEnumerable` data collections, which are
    data bound to `ItemsControl` elements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以避免这个错误，例如简单地显示整个集合，我们将在本章后面看到这个示例。然而，最简单的方法是利用隐式用于包装`IEnumerable`数据集合的`ICollectionView`对象的`CurrentItem`属性，这些数据集合绑定到`ItemsControl`元素。
- en: This is similar to the way that a `ListBox` will implicitly wrap our data bound
    data items in `ListBoxItem` elements. The implementation of the `ICollectionView`
    interface that wraps our data collection is primarily used to enable sorting,
    filtering, and grouping of the data, without affecting the actual data, but its
    `CurrentItem` property is a bonus in this situation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`ListBox`隐式地将我们的数据绑定数据项包装在`ListBoxItem`元素中的方式类似。包装我们的数据集合的`ICollectionView`接口的实现主要用于启用排序、过滤和分组数据，而不影响实际数据，但在这个情况下，它的`CurrentItem`属性是一个额外的优势。
- en: 'With this, we can replace the indexer that was causing us a problem when there
    were no validation errors. Now, when there are no errors, the `CurrentItem` property
    will return `null`, rather than throwing an Exception and so, despite Microsoft''s
    own example showing the use of the indexer, this is a far better solution:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以替换掉在无验证错误时给我们造成问题的索引器。现在，当没有错误时，`CurrentItem`属性将返回`null`，而不是抛出异常，因此，尽管微软自己的示例展示了索引器的使用，但这仍然是一个更好的解决方案：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Nevertheless, if an end user is not aware of having to place their mouse cursor
    over the control to see the tooltip, then the situation is still not improved.
    Therefore, this initial implementation still has room for improvement. Another
    shortcoming of this interface is that it was designed to be atomic, so it only
    deals with a single error per property at a time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果最终用户不知道需要将鼠标光标放在控件上才能看到工具提示，那么情况仍然没有得到改善。因此，这种初始实现仍有改进的空间。这个界面的另一个缺点是它被设计成原子的，因此它一次只处理一个属性的单一错误。
- en: In our `Product` class example, we want to validate the fact that the `Name`
    property is not only entered, but also has a valid length. In the order that we
    declared our two validation conditions for this property, the first error will
    be raised when the field in the UI is empty, and the second will be raised if
    the entered value is too long. As the entered value cannot be both non-existent
    and too long at the same time, having only a single reported error at one time
    is not a problem in this particular example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Product`类示例中，我们想要验证`Name`属性不仅被输入，而且具有有效的长度。按照我们为该属性声明的两个验证条件的顺序，当UI中的字段为空时，将首先引发第一个错误，如果输入的值过长，将引发第二个错误。由于输入的值不能同时不存在且过长，所以在这种特定情况下，一次只报告一个错误并不成问题。
- en: 'However, if we had a property that had multiple validation conditions, such
    as a maximum length and a particular format, then with the usual `IDataErrorInfo`
    interface implementation, we''d only be able to view one of these errors at once.
    However, despite this limitation, we can still improve this basic implementation.
    Let''s see how we can do this with a new base class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有一个具有多个验证条件（如最大长度和特定格式）的属性，那么使用通常的`IDataErrorInfo`接口实现，我们一次只能查看这些错误中的一个。然而，尽管有这个限制，我们仍然可以改进这个基本实现。让我们看看我们如何使用一个新的基类来做到这一点：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we add two collections to hold error messages; the `Errors`
    collection property contains validation errors that are generated within the derived
    class, and the `ExternalErrors` collection property holds externally generated
    validation errors, typically from a parent View Model.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们添加了两个集合来存储错误消息；`Errors`集合属性包含在派生类中生成的验证错误，而`ExternalErrors`集合属性包含外部生成的验证错误，通常来自父视图模型。
- en: In the constructor, we attach the `ExternalErrors_CollectionChanged` event handler
    to the `CollectionChanged` event of the `ExternalErrors` collection property so
    that it is notified whenever items are added or removed from it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将`ExternalErrors_CollectionChanged`事件处理程序附加到`ExternalErrors`集合属性的`CollectionChanged`事件上，以便在向其中添加或从中删除项目时得到通知。
- en: After the declaration of the error collection properties, we see the `HasError`
    expression-bodied property, which checks whether the `Errors` collection contains
    any errors. Note that we check the `errors` field for `null`, rather than the
    `Errors` property, because calling the `Errors` property regenerates the error
    messages and we do not want to regenerate them all twice each time the `HasError` property
    is called.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误集合属性的声明之后，我们看到 `HasError` 表达式体的属性，该属性检查 `Errors` 集合是否包含任何错误。请注意，我们检查 `errors`
    字段是否为 `null`，而不是 `Errors` 属性，因为调用 `Errors` 属性会重新生成错误消息，而我们不希望在每次调用 `HasError`
    属性时都重新生成它们两次。
- en: Next, we see the new implementation of the `IDataErrorInfo` interface. The class
    indexer remains the same as the one from the previous implementation, but we see
    a difference in the definition of the `Error` property, which now compiles a complete
    list of all errors, rather than returning a single error message at a time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到 `IDataErrorInfo` 接口的新实现。类索引器与之前实现中的相同，但我们看到 `Error` 属性的定义有所不同，现在它编译了一个完整的错误列表，而不是一次返回一个错误消息。
- en: 'In it, we first check whether any errors exist, and return an empty string
    if not. If errors do exist, we initialize a `StringBuilder` object and use our
    `ForEach` Extension Method to iterate through the `Errors` collection and append
    each of them to it, if they haven''t already been included. We do this using another
    Extension Method before returning the output, so let''s see what that looks like
    now:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们首先检查是否存在任何错误，如果不存在则返回一个空字符串。如果存在错误，我们初始化一个 `StringBuilder` 对象，并使用我们的 `ForEach`
    扩展方法遍历 `Errors` 集合，并将它们中的每一个（如果它们尚未被包含）追加到其中。我们使用另一个扩展方法在返回输出之前这样做，所以现在让我们看看它是什么样子：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our `AppendUniqueOnNewLineIfNotEmpty` Extension Method, we first check that
    the input value is not an empty string and that it is not already present in the
    `StringBuilder` object. If the `text` input parameter is valid, we use the ternary
    operator to determine whether it is the first value to be added and whether we
    need to precede it with a new line or not, before adding the new, unique value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `AppendUniqueOnNewLineIfNotEmpty` 扩展方法中，我们首先检查输入值不是一个空字符串，并且它还没有存在于 `StringBuilder`
    对象中。如果 `text` 输入参数有效，我们使用三元运算符来确定它是否是第一个要添加的值，以及是否需要在添加新的唯一值之前添加一个新行，然后再添加新的唯一值。
- en: Returning to our validation base class now, we see the new implementation of
    the `INotifyPropertyChanged` interface. Note that we repeat our earlier `BaseSynchronizableDataModel`
    class example by raising the `PropertyChanged` event each time changes are registered
    for any other properties, but, unlike the previous example, we raise the `HasError`
    property here, rather than the `HasChanges` property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的验证基类，我们看到 `INotifyPropertyChanged` 接口的新实现。请注意，我们通过为任何其他属性的更改注册引发 `PropertyChanged`
    事件来重复我们之前的 `BaseSynchronizableDataModel` 类示例，但与之前的示例不同，我们在这次中引发的是 `HasError` 属性，而不是
    `HasChanges` 属性。
- en: We can combine both of these and raise the `PropertyChanged` event for both
    properties each time we receive notification of changes to other properties if
    we so desire. In this case, the purpose is to call the `HasError` property, which
    will be used in the UI to display or hide the control that displays the error
    messages, and so it will be updated after every validatable property change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以将这两个结合起来，并在接收到其他属性更改的通知时为这两个属性各自引发 `PropertyChanged` 事件。在这种情况下，目的是调用
    `HasError` 属性，该属性将在 UI 中用于显示或隐藏显示错误消息的控件，因此它将在每次有效的属性更改后更新。
- en: At the bottom of our class, we see the expression-bodied `ExternalErrors_CollectionChanged`
    method, which calls the `NotifyPropertyChanged` method for the `Errors` collection
    property. This notifies controls that are data bound to this property that its
    value has changed and that they should retrieve that new value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们班级的底部，我们可以看到表达式体的 `ExternalErrors_CollectionChanged` 方法，该方法为 `Errors` 集合属性调用
    `NotifyPropertyChanged` 方法。这会通知绑定到该属性的数据绑定控件，其值已更改，并且它们应该检索新的值。
- en: 'Let''s see an example implementation of this now, using an extended version
    of our `Product` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在的一个示例实现，使用我们 `Product` 类的扩展版本：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Therefore, when an error is externally added to the `ExternalErrors` collection,
    the `ExternalErrors_CollectionChanged` method will be called and this notifies
    changes to the `Errors` property. This results in the property being called and
    the external error(s) being added to the internal `errors` collection, along with
    any internal errors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当外部错误被添加到 `ExternalErrors` 集合时，将调用 `ExternalErrors_CollectionChanged` 方法，并通知
    `Errors` 属性的更改。这导致属性被调用，外部错误（错误）被添加到内部的 `errors` 集合中，以及任何内部错误。
- en: 'To get this particular implementation of the `IDataErrorInfo` interface to
    work, each data Model class will need to override this `Errors` property to add
    error messages from each validated property. We provide a few Extension Methods
    to make this task easier. As its name implies, the `AddUniqueIfNotEmpty` method
    adds strings to the collection if they do not already exist in it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个特定的 `IDataErrorInfo` 接口实现生效，每个数据模型类都需要重写这个 `Errors` 属性，以添加每个已验证属性的错误消息。我们提供了一些扩展方法来简化这项任务。正如其名称所暗示的，`AddUniqueIfNotEmpty`
    方法在字符串已存在于集合中时不会添加它们：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `AddRange` method is another useful Extension Method that simply iterates
    through the `range` collection input parameter and adds them to the `collection`
    parameter one by one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddRange` 方法是另一个有用的扩展方法，它简单地遍历输入参数 `range` 集合，并将它们逐个添加到 `collection` 参数中：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In addition to implementing this new `Errors` collection property in their
    derived classes, developers will also need to ensure that they notify changes
    to it each time a validatable property value is changed. We can do this using
    our overload of the `NotifyPropertyChanged` method that takes multiple values:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在派生类中实现这个新的 `Errors` 集合属性外，开发者还需要确保每次一个可验证的属性值发生变化时，都要通知对其的更改。我们可以通过使用接受多个值的
    `NotifyPropertyChanged` 方法重载来完成此操作：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Errors` property is responsible for calling the class indexer with the
    name of each of the properties that we want to validate. Any error messages that
    are returned, including those from the `ExternalErrors` collection property, are
    then added to the internal `errors` collection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Errors` 属性负责调用具有我们想要验证的每个属性的名称的类索引器。然后，将返回的错误消息（包括来自 `ExternalErrors` 集合属性的消息）添加到内部的
    `errors` 集合中。'
- en: In effect, we have replicated what the `Validation` class and the `DataErrorValidationRule`
    element does in the UI, but in our data Model instead. This means that we no longer
    have to set the `ValidatesOnDataErrors` property to `True` on each binding. This
    is a better solution when using MVVM, as we prefer to work with data, rather than
    UI elements, and now also have full access to all of the data validation errors
    in our View Models.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在数据模型中复制了 `Validation` 类和 `DataErrorValidationRule` 元素在 UI 中所做的工作。这意味着我们不再需要在每个绑定上设置
    `ValidatesOnDataErrors` 属性为 `True`。当使用 MVVM 时，这是一个更好的解决方案，因为我们更愿意与数据而不是 UI 元素一起工作，现在我们也可以完全访问我们视图模型中的所有数据验证错误。
- en: Furthermore, we now have the ability to manually feed in error messages from
    our View Models to our data Models via the `ExternalErrors` collection property.
    This can be very useful when we need to validate across a collection of data Model
    objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们现在有了通过 `ExternalErrors` 集合属性手动将错误消息从我们的视图模型传递到数据模型的能力。当我们需要跨一组数据模型对象进行验证时，这非常有用。
- en: 'For example, if we need to ensure that the name of each data Model object is
    unique within a collection of related objects, we can use this feature. Let''s
    now create a new `ProductViewModelExtended` class to see how we can accomplish
    this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们需要确保每个数据模型对象的名字在相关对象集合中是唯一的，我们可以使用这个功能。现在让我们创建一个新的 `ProductViewModelExtended`
    类来查看我们如何实现这一点：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Like the `ProductViewModel` class, our `ProductViewModelExtended` class also
    extends the `BaseViewModel` class, but it declares a `ProductsExtended` collection
    and adds two `ProductExtended` objects to it in the constructor, instead of the
    single `Product` instance used previously. The `ProductsExtended` class simply
    extends our `BaseCollection` class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ProductViewModel` 类类似，我们的 `ProductViewModelExtended` 类也扩展了 `BaseViewModel`
    类，但它声明了一个 `ProductsExtended` 集合，并在构造函数中添加了两个 `ProductExtended` 对象，而不是之前使用的单个 `Product`
    实例。`ProductsExtended` 类简单地扩展了我们的 `BaseCollection` 类：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the class constructor, we first add a couple of test products to the `ProductsExtended` collection
    and then attach the `Products_CurrentItemChanged` method to its `CurrentItemChanged`
    delegate. In order to set the second item as the current item, we call the `Last`
    method on the `ProductsExtended` collection and set that to its `CurrentItem`
    property.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在类构造函数中，我们首先向 `ProductsExtended` 集合中添加几个测试产品，然后将 `Products_CurrentItemChanged`
    方法附加到其 `CurrentItemChanged` 代理上。为了将第二个项目设置为当前项目，我们在 `ProductsExtended` 集合上调用 `Last`
    方法，并将其设置为 `CurrentItem` 属性。
- en: This ensures that the `Products_CurrentItemChanged` method is called when setting
    the second item as the current item and the `Product_PropertyChanged` handler
    is attached to it. After this, we then call the `ValidateUniqueName` method that
    is described shortly, passing in the current item.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了在将第二个项目设置为当前项目时调用 `Products_CurrentItemChanged` 方法，并且 `Product_PropertyChanged`
    处理器被附加到它上。之后，我们调用稍后描述的 `ValidateUniqueName` 方法，传入当前项目。
- en: After the declaration of the `Products` property, we see the `Products_CurrentItemChanged`
    method, which will be called each time the value of the `CurrentItem` property
    is changed. In it, we attach the `Product_PropertyChanged` method to the `PropertyChanged`
    event of the new, current `ProductExtended` object and detach it from the previous
    one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Products` 属性声明之后，我们看到 `Products_CurrentItemChanged` 方法，该方法将在 `CurrentItem`
    属性的值每次更改时被调用。在其中，我们将 `Product_PropertyChanged` 方法附加到新的、当前的 `ProductExtended` 对象的
    `PropertyChanged` 事件上，并从先前的对象中分离出来。
- en: The `Product_PropertyChanged` method will be called each time any property of
    the related `ProductExtended` object changes. If the property that changed was
    the `Name` property, we call the `ValidateUniqueName` method, as that is the property
    that we need to validate for uniqueness.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product_PropertyChanged` 方法将在相关 `ProductExtended` 对象的任何属性发生变化时被调用。如果发生变化的属性是
    `Name` 属性，我们将调用 `ValidateUniqueName` 方法，因为这是我们需要验证唯一性的属性。'
- en: The `ValidateUniqueName` method is responsible for adding or removing the error
    from the `ExternalErrors` collection property of the `product` input parameter.
    It does this by checking the result of the `IsProductNameUnique` method, which
    does the actual check for uniqueness.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidateUniqueName` 方法负责从 `product` 输入参数的 `ExternalErrors` 集合属性中添加或删除错误。它是通过检查
    `IsProductNameUnique` 方法的结果来实现的，该方法执行实际的唯一性检查。'
- en: In the expression-bodied `IsProductNameUnique` method, we use LINQ to query
    the `Products` collection and find out whether an existing item shares the same
    name. It does this by checking that each item does not have the same identification
    number, or, in other words, is not the object being edited, but does have the
    same name, and that the name is not an empty string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式体的 `IsProductNameUnique` 方法中，我们使用 LINQ 查询 `Products` 集合，以确定是否存在具有相同名称的现有项目。这是通过检查每个项目不具有相同的识别号，换句话说，不是正在编辑的对象，但确实具有相同的名称，并且该名称不是空字符串来实现的。
- en: If any other products that have the same name are found, then the method returns
    `false` and an error is added to the product's `ExternalErrors` collection in
    the `ValidateUniqueName` method. Note that we must manually remove this error
    if the name is found to be unique.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到任何具有相同名称的其他产品，则该方法返回 `false`，并在 `ValidateUniqueName` 方法中将错误添加到产品的 `ExternalErrors`
    集合中。请注意，如果发现名称是唯一的，我们必须手动删除此错误。
- en: 'Let''s now create a new `ProductViewExtended` class, to display these errors
    better. First, let''s add another reusable resource to the application resources
    file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的 `ProductViewExtended` 类，以更好地显示这些错误。首先，让我们向应用程序资源文件中添加另一个可重用资源：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This `DataTemplate` simply displays a `TextBlock` control, with its `Text`
    property data bound to the data context of the `DataTemplate`, and its `TextWrapping`
    property set to `Wrap`, which has the effect of wrapping text that does not fit
    into the width provided. Now, let''s look at the new `ProductViewExtended` class
    that uses this template:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `DataTemplate` 简单地显示一个 `TextBlock` 控件，其 `Text` 属性绑定到 `DataTemplate` 的数据上下文，并且其
    `TextWrapping` 属性设置为 `Wrap`，这具有将不适应提供的宽度的文本包装起来的效果。现在，让我们看看使用此模板的新 `ProductViewExtended`
    类：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we now have a `Grid` panel with two columns. In the left column,
    we have a `ListBox` control, and, in the right column, we have another `Grid`
    panel containing our form fields. The `ItemsSource` property of the `ListBox`
    control is data bound to the `Products` collection property from our View Model,
    and the `SelectedItem` property is data bound to its `CurrentItem` property.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们现在有一个具有两列的`Grid`面板。在左侧列中，我们有一个`ListBox`控件，而在右侧列中，我们有一个包含我们的表单字段的另一个`Grid`面板。`ListBox`控件的`ItemsSource`属性绑定到我们的视图模型中的`Products`集合属性，并且`SelectedItem`属性绑定到其`CurrentItem`属性。
- en: We set the `DisplayMemberPath` property to `Name`, to output the name of each
    product, as a shortcut for creating a `DataTemplate` for our `Product` class.
    Alternatively, we could have returned the value of the `Name` property from the
    `ToString` method in our `Product` class to achieve the same visual result, although
    that would not update in the UI when the property value changed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`DisplayMemberPath`属性设置为`Name`，以输出每个产品的名称，作为为我们的`Product`类创建`DataTemplate`的快捷方式。或者，我们也可以从`Product`类中的`ToString`方法返回`Name`属性的值以实现相同的视觉效果，尽管这样当属性值更改时，UI界面不会更新。
- en: In the `Grid` panel on the right, we declare three rows and, in the top one,
    we define a `Border` element containing an `ItemsControl` object. Its `ItemsSource`
    property is data bound to the `Errors` collection property of the item that is
    set to the `CurrentItem` property of the `Products` collection, and its `ItemTemplate`
    property is set to our new `WrapTemplate` data template. The `Visibility` property
    of the border is data bound to the item's `HasError` property using the `BoolToVisibilityConverter`
    instance from the application resources.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的`Grid`面板中，我们声明了三行，在顶部的一行中，我们定义了一个包含`ItemsControl`对象的`Border`元素。它的`ItemsSource`属性绑定到设置在`Products`集合的`CurrentItem`属性上的项的`Errors`集合属性，并且其`ItemTemplate`属性设置为我们的新`WrapTemplate`数据模板。边框的`Visibility`属性通过应用程序资源中的`BoolToVisibilityConverter`实例绑定到项的`HasError`属性。
- en: Therefore, when a change is made to a validated property of the item and an
    error is raised in our validation base class, the `PropertyChanged` event is raised
    for the `HasError` property and this alerts this binding to check the latest value
    and update its visibility value via the applied `BoolToVisibilityConverter` instance
    accordingly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当对项的验证属性进行更改并引发我们的验证基类中的错误时，`PropertyChanged`事件会为`HasError`属性引发，这会提醒此绑定检查最新值并通过应用的`BoolToVisibilityConverter`实例相应地更新其可见性值。
- en: Note that we use `ItemsControl` here, because with this collection, we have
    no need for the extra features that the `ListBox` control provides us with, such
    as a border, or the notion of a selected item. The two rows underneath the error
    output contain the form fields from the `ProductView` example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用`ItemsControl`，因为使用这个集合，我们不需要`ListBox`控件提供的额外功能，例如边框或选中项的概念。错误输出下面的两行包含来自`ProductView`示例的表单字段。
- en: When this example is run, we'll see two items that have the same name in our
    `ListBox` control. As such, there will already be a validation error displayed
    that highlights this fact and that was added through the `ExternalErrors` collection
    in the View Model.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个示例运行时，我们将在我们的`ListBox`控件中看到两个具有相同名称的项。因此，将已经显示一个验证错误，突出显示这一事实，并且这是通过在视图模型中的`ExternalErrors`集合中添加来实现的。
- en: 'In addition to this, we''ll see another error, highlighting the fact that a
    valid price needs to be entered:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将看到一个错误，突出显示需要输入有效价格的事实：
- en: '![](img/a201f297-20ff-44d8-b547-58b55ccb45c2.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a201f297-20ff-44d8-b547-58b55ccb45c2.png)'
- en: As the `UpdateSourceTrigger` property of the field bindings have been set to
    `PropertyChanged` and the data bound properties are validated straight away, the
    errors will immediately disappear and/or reappear as soon as we type in the relevant
    form fields. This setting, along with the fact that we validate each time the
    properties change, makes our validation work in a pre-emptive manner.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字段绑定的`UpdateSourceTrigger`属性已被设置为`PropertyChanged`，并且数据绑定的属性会立即进行验证，因此当我们输入相关表单字段时，错误会立即消失或重新出现。这种设置，加上我们每次属性更改时都会进行验证的事实，使得我们的验证工作以预防性方式进行。
- en: 'We can also change this to work only when a user presses a submit button by
    setting the `UpdateSourceTrigger` property to the `Explicit` value. However, this
    requires that we access the data bound controls in the code behind files and so
    we tend to avoid this approach when using the MVVM methodology:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将 `UpdateSourceTrigger` 属性设置为 `Explicit` 值来修改此行为，使其仅在用户按下提交按钮时生效。然而，这要求我们在代码背后文件中访问数据绑定控件，因此在使用
    MVVM 方法时，我们倾向于避免这种方法：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Alternatively, if we wanted to validate in this way when using MVVM, we could
    simply call the validation code when the command that is data bound to the submit
    or save button is executed instead. Let's now take a look at the `INotifyDataErrorInfo`
    interface to see how it differs from the `IDataErrorInfo` interface.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想在 MVVM 中以这种方式进行验证，我们可以在绑定到提交或保存按钮的命令执行时简单地调用验证代码。现在，让我们看看 `INotifyDataErrorInfo`
    接口，看看它与 `IDataErrorInfo` 接口有何不同。
- en: Introducing the INotifyDataErrorInfo interface
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 `INotifyDataErrorInfo` 接口
- en: The `INotifyDataErrorInfo` interface was added to the .NET Framework in .NET
    4.5 to address concerns over the previous `IDataErrorInfo` interface. Like the
    `IDataErrorInfo` interface, the `INotifyDataErrorInfo` interface is also a simple
    affair, with only three members for us to implement.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifyDataErrorInfo` 接口是在 .NET 4.5 中添加到 .NET Framework 中的，以解决对先前 `IDataErrorInfo`
    接口的问题。与 `IDataErrorInfo` 接口一样，`INotifyDataErrorInfo` 接口也是一个简单的事情，我们只需要实现三个成员。'
- en: 'With this interface, we now have a `HasErrors` property, which indicates whether
    the relevant data Model instance has any errors, a `GetErrors` method that retrieves
    the object''s error collection, and an `ErrorsChanged` event to raise when the
    entity''s errors change. We can see straight away that this interface was designed
    to work with multiple errors, unlike the `IDataErrorInfo` interface. Now, let''s
    take a look at an implementation of this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个接口，我们现在有一个 `HasErrors` 属性，它表示相关数据模型实例是否有任何错误，一个 `GetErrors` 方法来检索对象的错误集合，以及一个
    `ErrorsChanged` 事件，在实体错误更改时触发。我们可以立即看出，这个接口是为了处理多个错误而设计的，与 `IDataErrorInfo` 接口不同。现在，让我们看看这个接口的一个实现：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In our first implementation, we see the declaration of the read-only `AllPropertyErrors`
    auto property, initialized to a new instance. For this collection, we use the
    `Dictionary<string, List<string>>` type, where the name of each property in error
    is used as the dictionary key, and multiple errors for that property can be stored
    in the related `string` list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个实现中，我们看到只读的 `AllPropertyErrors` 自动属性声明，初始化为一个新的实例。对于这个集合，我们使用 `Dictionary<string,
    List<string>>` 类型，其中每个出错属性的名称用作字典键，该属性的错误可以存储在相关的 `string` 列表中。
- en: We then see the read-only, expression-bodied `Errors` property, which will hold
    the `string` collection of errors to be displayed in the UI. It is set to return
    a compilation of unique errors from the `AllPropertyErrors` collection. Next,
    we find an abstract `string` indexer that returns an `IEnumerable` of the `string` type,
    which is responsible for returning multiple validation errors from derived classes
    that relate to the property specified by the `propertyName` input parameter. We'll
    see how we can implement this property in a derived class shortly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到只读的、表达式体的 `Errors` 属性，它将保存要在 UI 中显示的错误 `string` 集合。它被设置为返回来自 `AllPropertyErrors`
    集合的唯一错误汇总。接下来，我们发现一个抽象的 `string` 索引器，它返回一个 `IEnumerable` 的 `string` 类型，负责从与 `propertyName`
    输入参数指定的属性相关的派生类返回多个验证错误。我们将在稍后看到我们如何在派生类中实现此属性。
- en: After that, we add two convenient `NotifyPropertyChangedAndValidate` methods,
    which we can use to both provide notification of changes to our property and to
    validate it in a single operation. In these methods, we call our implementation
    of the `NotifyPropertyChanged` method and then our `Validate` method, passing
    the relevant property name to each of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们添加了两个方便的 `NotifyPropertyChangedAndValidate` 方法，我们可以使用这两个方法在单个操作中既提供属性变更的通知，又对其进行验证。在这些方法中，我们调用我们的
    `NotifyPropertyChanged` 方法实现，然后是我们的 `Validate` 方法，并将相关的属性名称传递给每个方法。
- en: In the `Validate` method, we call the `UpdateErrors` method, passing in the
    `propertyName` input parameter and the related errors for the specified property,
    returned from the `this` indexer property. In the `UpdateErrors` method, we begin
    by checking whether there are any errors in the collection specified by the `errors`
    input parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Validate` 方法中，我们调用 `UpdateErrors` 方法，传入 `propertyName` 输入参数和指定属性的关联错误，这些错误是从
    `this` 索引器属性返回的。在 `UpdateErrors` 方法中，我们首先检查 `errors` 输入参数指定的集合中是否有任何错误。
- en: If there are, and it does contain some, we clear the errors for the relevant
    property from the `AllPropertyErrors` collection, or initialize a new entry for
    the property, with an empty collection otherwise. We then add the incoming errors
    to the `AllPropertyErrors` collection for the relevant property and call the `OnErrorsChanged` method
    to raise the `ErrorsChanged` event.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，并且确实包含一些错误，我们从 `AllPropertyErrors` 集合中清除相关属性的错误，或者如果没有错误，为该属性初始化一个新的条目，然后向
    `AllPropertyErrors` 集合中的相关属性添加传入的错误，并调用 `OnErrorsChanged` 方法来引发 `ErrorsChanged`
    事件。
- en: If there are no errors in the collection specified by the `errors` input parameter,
    we remove all previous entries from the `AllPropertyErrors` collection for the
    relevant property, after first validating that some exist, so as to avoid an Exception
    being thrown. We then call the `OnErrorsChanged` method to raise the `ErrorsChanged`
    event to notify changes to the collection.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `errors` 输入参数指定的集合中没有错误，我们将在验证相关属性存在之后，从 `AllPropertyErrors` 集合中移除所有之前的条目，以避免抛出异常。然后我们调用
    `OnErrorsChanged` 方法来引发 `ErrorsChanged` 事件，以通知集合的变化。
- en: Next, we see the required `INotifyDataErrorInfo` interface members. We declare
    the `ErrorsChanged` event for internal use only and the related `OnErrorsChanged`
    method that raises it using the null conditional operator, although this method
    is not technically part of the interface and we are free to raise the event as
    we see fit. After raising the event, we notify the system of changes to the `Errors` and `HasErrors`
    properties, to refresh the error collection, and to update the UI of any changes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到所需的 `INotifyDataErrorInfo` 接口成员。我们仅为了内部使用声明 `ErrorsChanged` 事件，并使用空条件运算符调用相关的
    `OnErrorsChanged` 方法来引发它，尽管这个方法在技术上不是接口的一部分，我们可以根据需要自由地引发事件。在引发事件后，我们通知系统 `Errors`
    和 `HasErrors` 属性的变化，以刷新错误集合，并更新任何更改的 UI。
- en: In the `GetErrors` method, we are required to return the errors for the `propertyName`
    input parameter. We start by initializing the `propertyErrors` collection, which
    we return immediately if the `propertyName` input parameter is `null`, or empty. Otherwise,
    we use the `TryGetValue` method to populate the `propertyErrors` collection with
    the errors that relate to the `propertyName` input parameter from the `AllPropertyErrors`
    collection. We then return the `propertyErrors` collection.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GetErrors` 方法中，我们需要返回 `propertyName` 输入参数的错误。我们首先初始化 `propertyErrors` 集合，如果
    `propertyName` 输入参数是 `null` 或空，我们立即返回该集合。否则，我们使用 `TryGetValue` 方法从 `AllPropertyErrors`
    集合中填充与 `propertyName` 输入参数相关的错误到 `propertyErrors` 集合。然后我们返回 `propertyErrors` 集合。
- en: The simplified `HasErrors` expression-bodied property follows and simply returns
    `true` if the `AllPropertyErrors` collection property contains any errors, or
    `false` otherwise. We complete the class with our default implementation of the
    `INotifyPropertyChanged` interface. Note that we can simply omit this if we intend
    this base class to extend another with its own implementation of this interface.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是简化的 `HasErrors` 表达式属性，它简单地返回 `true` 如果 `AllPropertyErrors` 集合属性包含任何错误，否则返回
    `false`。我们通过实现 `INotifyPropertyChanged` 接口的默认方法来完成类的定义。注意，如果我们打算这个基类扩展另一个具有该接口自己实现的类，我们可以简单地省略这一部分。
- en: 'Let''s copy our earlier `Product` class so as to create a new `ProductNotify`
    class that extends our new base class. Apart from the class name and the collection
    of errors, we need to make a number of changes. Let''s look at these now:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制我们之前定义的 `Product` 类，以便创建一个新的 `ProductNotify` 类，该类将扩展我们的新基类。除了类名和错误集合外，我们还需要进行一些修改。现在让我们来看看这些修改：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The main differences between the `ProductNotify` and `Product` classes relate
    to the base class, the notification method used, and the handling of multiple
    concurrent errors. We start by extending our new `BaseNotifyValidationModel` base
    class. Each property, with the Exception of the `Id` property, which requires
    no validation, now calls the `NotifyPropertyChangedAndValidate` method from the
    new base class, instead of the `NotifyPropertyChanged` method from the `BaseValidationModel`
    class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductNotify`类和`Product`类之间的主要区别在于基类、使用的通知方法和处理多个并发错误的方式。我们首先扩展了我们的新`BaseNotifyValidationModel`基类。除了不需要验证的`Id`属性外，每个属性现在都调用新基类中的`NotifyPropertyChangedAndValidate`方法，而不是`BaseValidationModel`类中的`NotifyPropertyChanged`方法。'
- en: In addition to that, the `this` indexer property can now report multiple errors
    simultaneously, rather than the single error that the `BaseValidationModel` class
    could work with. As such, it now declares a `string` list to hold the errors,
    with each valid error being added to it in turn. The final difference is that
    we have also added a new error, which validates the fact that the first letter
    of the product name should start with a capital letter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，`this`索引器属性现在可以同时报告多个错误，而不是像`BaseValidationModel`类可以处理的单个错误。因此，它现在声明了一个`string`列表来保存错误，每个有效的错误依次添加到其中。最大的不同之处在于我们还添加了一个新的错误，该错误验证产品名称的首字母应该以大写字母开头。
- en: 'Let''s now see our `ProductNotifyViewModel` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的`ProductNotifyViewModel`类：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We start our `ProductNotifyViewModel` View Model by extending our usual `BaseViewModel`
    base class. We declare a `ProductsNotify` collection and, in the constructor,
    we populate it with two `ProductNotify` objects, with the same property values
    that were used in the `ProductViewModelExtended` class example. We again call
    the `Last` method on the `ProductsNotify` collection and set that last element
    to its `CurrentItem` property to pre-select the second item in the UI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过扩展我们常用的`BaseViewModel`基类来开始我们的`ProductNotifyViewModel`视图模型。我们声明了一个`ProductsNotify`集合，并在构造函数中用两个`ProductNotify`对象填充它，这些对象的属性值与`ProductViewModelExtended`类示例中使用的相同。我们再次在`ProductsNotify`集合上调用`Last`方法，并将该最后一个元素设置为它的`CurrentItem`属性以在UI中预选第二个项目。
- en: 'We then call the `Validate` method twice on the object set to the `CurrentItem`
    property, passing in the `Name` and `Price` properties, using the `nameof` operator
    for correctness. The class ends with the standard declaration of the `Products`
    property. Note that the `ProductsNotify` class simply extends our `BaseCollection`
    class, just like our `Products` class did:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在设置为`CurrentItem`属性的`Validate`方法上调用两次，传入`Name`和`Price`属性，使用`nameof`运算符确保正确性。类以`Products`属性的常规声明结束。请注意，`ProductsNotify`类简单地扩展了我们的`BaseCollection`类，就像我们的`Products`类一样：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Also note that if we removed the call to the `Validate` method from the constructor,
    this implementation would no longer work in a pre-emptive manner. It would instead
    initially hide any pre-existing validation errors, such as empty required values,
    until the user makes changes and there is a problem. Therefore, empty required
    values would never cause an error to be raised, unless a value was entered and
    then deleted, to once again be empty.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，如果我们从构造函数中移除了对`Validate`方法的调用，这个实现将不再以预防的方式工作。它将最初隐藏任何现有的验证错误，例如空必填值，直到用户进行更改并且出现问题时。因此，空必填值永远不会引发错误，除非输入了一个值然后删除，再次变为空。
- en: 'To address this, we could instead declare a `ValidateAllProperties` method
    that our View Models can call to force a new validation pass, either pre-emptively,
    before the user has a chance to enter any data, or on the click of a save button,
    once all fields have been filled. We''ll see an example of this later in this
    chapter, but for now, let''s see the XAML of our `ProductNotifyView` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以声明一个`ValidateAllProperties`方法，我们的视图模型可以调用它来强制进行新的验证过程，要么在用户有机会输入任何数据之前预防性地进行，要么在所有字段都已填写后点击保存按钮时进行。我们将在本章后面看到这个示例，但现在让我们看看`ProductNotifyView`类的XAML：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the `Resources` section, we have declared a new `DataTemplate` element, named
    `ProductTemplate`. This just displays the value of the `Name` property, but importantly,
    with the binding’s `ValidatesOnNotifyDataErrors` property set to `False`, so that
    no error template is displayed within the `ListBoxItem` elements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Resources`部分，我们声明了一个新的`DataTemplate`元素，命名为`ProductTemplate`。这个模板只显示`Name`属性的值，但重要的是，将绑定的`ValidatesOnNotifyDataErrors`属性设置为`False`，这样在`ListBoxItem`元素内不会显示任何错误模板。
- en: Another point to note is that the `Visibility` property of the global error
    display's border has now been updated to work with the new `HasErrors` property from
    the `INotifyDataErrorInfo` interface, rather than the `HasError` property from
    our previous `BaseValidationModelExtended` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，全局错误显示边框的 `Visibility` 属性现在已更新，以与 `INotifyDataErrorInfo` 接口的新 `HasErrors`
    属性一起工作，而不是我们之前的 `BaseValidationModelExtended` 类中的 `HasError` 属性。
- en: The only other change was made to the `Text` property binding of the two `TextBox`
    controls; when using the `INotifyDataErrorInfo` interface, instead of setting
    the `ValidatesOnDataErrors` property to `True` as before, we now need to set the
    `ValidatesOnNotifyDataErrors` property to `True`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的其他更改是对两个 `TextBox` 控件的 `Text` 属性绑定进行的；当使用 `INotifyDataErrorInfo` 接口时，我们现在需要将
    `ValidatesOnNotifyDataErrors` 属性设置为 `True`，而不是像之前那样将 `ValidatesOnDataErrors` 属性设置为
    `True`。
- en: We'll update this example again shortly, but before that, let's explore another
    method of providing validation logic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在不久之后再次更新这个示例，但在那之前，让我们探索另一种提供验证逻辑的方法。
- en: Annotating data
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据标注
- en: The .NET Framework also provides us with an alternative, attribute-based validation
    system in the `System.ComponentModel.DataAnnotations` namespace. It is mostly
    comprised of a wide range of attribute classes that we can decorate our data Model
    properties with so as to specify our validation rules. In addition to these attributes,
    it also includes a few validation classes, which we will investigate later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架还在 `System.ComponentModel.DataAnnotations` 命名空间中为我们提供了一个基于属性的替代验证系统。它主要包含一系列属性类，我们可以用它们来装饰我们的数据模型属性，以便指定我们的验证规则。除了这些属性之外，它还包括一些验证类，我们将在稍后研究。
- en: 'As an example, let''s look at replicating the current validation rules from
    our `ProductNotify` class with these data annotation attributes. We need to corroborate
    the fact that the `Name` property is entered and has a length of 25 characters
    or less, and that the `Price` property is more than zero. For the `Name` property,
    we can use the `RequiredAttribute` and the `MaxLengthAttribute` attributes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何使用这些数据标注属性来复制我们的 `ProductNotify` 类中的当前验证规则。我们需要证实 `Name` 属性已被输入，并且长度不超过25个字符，以及
    `Price` 属性大于零。对于 `Name` 属性，我们可以使用 `RequiredAttribute` 和 `MaxLengthAttribute` 属性：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As with all attributes, we can omit the word `Attribute` when using them to
    decorate properties. Most of these data annotation attributes declare one or more
    constructors with a number of optional parameters. The `ErrorMessage` input parameter
    is used in each to set the message to output when the specified condition is not
    met.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有属性一样，当我们使用它们来装饰属性时，可以省略单词 `Attribute`。这些数据标注属性中的大多数都声明了一个或多个具有多个可选参数的构造函数。`ErrorMessage`
    输入参数用于设置在指定的条件未满足时输出的消息。
- en: The `RequiredAttribute` constructor has no input parameters and simply checks
    that the data bound value is not `null` or empty. The constructor of the `MaxLengthAttribute`
    class takes an integer that specifies the maximum allowable length of the data
    bound value and it will raise a `ValidationError` instance if the input value
    is longer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequiredAttribute` 构造函数没有输入参数，它只是简单地检查数据绑定值是否不是 `null` 或空。`MaxLengthAttribute`
    类的构造函数接受一个整数，指定数据绑定值的最大允许长度，如果输入值更长，它将引发一个 `ValidationError` 实例。'
- en: 'For the `Price` property, we can make use of the `RangeAttribute` with a really
    high maximum value, as there is no `MinimumAttribute` class available:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Price` 属性，我们可以使用具有非常高的最大值的 `RangeAttribute`，因为没有可用的 `MinimumAttribute` 类：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The constructor of the `RangeAttribute` class takes two `double` values, which
    specify the minimum and maximum valid values, and, in this example, we set the
    minimum to one penny and the maximum to the maximum `decimal` value, as our `Price`
    property is of the `decimal` type. Note that we could not use the `RequiredAttribute`
    class here, as numeric data bound values will never be `null` or empty.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeAttribute` 类的构造函数接受两个 `double` 值，指定最小和最大有效值，在这个例子中，我们将最小值设置为一分钱，最大值设置为最大的
    `decimal` 值，因为我们的 `Price` 属性是 `decimal` 类型。请注意，我们在这里不能使用 `RequiredAttribute` 类，因为数值数据绑定值永远不会是
    `null` 或空。'
- en: 'There are a large number of these data annotation attribute classes, covering
    the most common validation situations, but when we have a requirement that does
    not have a pre-existing attribute to help us, we can create our own custom attribute
    by extending the `ValidationAttribute` class. Let''s create an attribute that
    only validates a minimum value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量这些数据注释属性类，涵盖了最常见的验证场景，但当我们有一个没有预存在属性来帮助我们的需求时，我们可以通过扩展`ValidationAttribute`类来创建自己的自定义属性。让我们创建一个只验证最小值的属性：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When we extend the `ValidationAttribute` class, we only need to override the
    `IsValid` method to return `true` or `false`, depending on our input value, which
    is specified by the `value` input parameter. In our simple example, we first declare
    the `minimumValue` field to store the target minimum allowable value to use during
    validation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展`ValidationAttribute`类时，我们只需要重写`IsValid`方法以返回`true`或`false`，这取决于我们的输入值，该值由`value`输入参数指定。在我们的简单示例中，我们首先声明`minimumValue`字段以存储在验证期间使用的目标最小允许值。
- en: We populate this field in the class constructor, with the value that users of
    our class provide. Next, we override the `IsValid` method that returns a `ValidationResult`
    instance. In this method, we first check the type of the `value` input parameter
    and then cast it to `decimal`, in order to compare it with the value of our `minimumValue`
    field.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类构造函数中填充这个字段，使用我们的类用户提供的值。接下来，我们重写返回`ValidationResult`实例的`IsValid`方法。在这个方法中，我们首先检查`value`输入参数的类型，并将其转换为`decimal`，以便与我们的`minimumValue`字段的值进行比较。
- en: Note that we have hardcoded this `double` type as the type of our minimum value,
    because although our `Price` property is `decimal`, the `decimal` type is not
    considered primitive and therefore cannot be used in an attribute. A better, more
    reusable solution, would be to declare a number of constructors that accept different
    numerical types that could be used in a wider range of situations and to update
    our `IsValid` method to be able to compare the different types with the input
    value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将这个`double`类型硬编码为最小值的类型，因为尽管我们的`Price`属性是`decimal`类型，但`decimal`类型不被视为原始类型，因此不能用于属性。一个更好、更可重用的解决方案是声明多个构造函数，这些构造函数接受不同数值类型，可以在更广泛的场景中使用，并更新我们的`IsValid`方法，以便能够比较不同类型与输入值。
- en: In our example, if the input value is either the incorrect type, or the cast
    value is less than the value of the `minimumValue` field, we first create the
    `memberNames` variable and insert the value of the `MemberName` property from
    the `validationContext` input parameter. We then return a new instance of the
    `ValidationResult` class, inputting the used error message and our `memberNames`
    collection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果输入值是错误类型，或者转换值小于`minimumValue`字段的值，我们首先创建`memberNames`变量，并将`validationContext`输入参数中`MemberName`属性的值插入其中。然后，我们返回一个`ValidationResult`类的新实例，输入使用的错误消息和我们的`memberNames`集合。
- en: 'If the input value is valid according to our particular validation logic, then
    we simply return the `ValidationResult.Success` field to signify successful validation.
    Let''s now look at our new attribute being used on the `Price` property of our
    `ProductNotify` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入值根据我们的特定验证逻辑有效，那么我们只需返回`ValidationResult.Success`字段以表示验证成功。现在让我们看看我们的新属性被用于`ProductNotify`类的`Price`属性：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In effect, our new attribute will work exactly as the previously used `RangeAttribute`
    instance, but it clearly demonstrates how we can create our own custom validation
    attributes. Before we move on to see how we can read these errors with our code,
    let''s first see how we can access the value of a second property from the data
    Model in our attribute, as this is a common requirement when validating:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的新属性将完全按照之前使用的`RangeAttribute`实例工作，但它清楚地展示了我们如何创建自己的自定义验证属性。在我们继续查看如何使用我们的代码读取这些错误之前，让我们首先看看如何从我们的属性中的数据模型访问第二个属性的值，因为这在验证时是一个常见的要求：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example assumes that we have added a reference to the `System` and `System.Reflection`
    namespaces and declared a `string` field named `otherPropertyName`, which is populated
    with the name of the other property name in the constructor. Using reflection,
    we attempt to access the `PropertyInfo` object that relates to the specified property
    name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子假设我们已经添加了对`System`和`System.Reflection`命名空间的引用，并在构造函数中声明了一个名为`otherPropertyName`的`string`字段，该字段填充了其他属性名称。使用反射，我们尝试访问与指定属性名称相关的`PropertyInfo`对象。
- en: If the `PropertyInfo` object is `null`, we throw an `ArgumentNullException`
    object, alerting the developer that they have used a non-existent property name.
    Otherwise, we use the `GetValue` method of the `PropertyInfo` object to retrieve
    the value from the other property.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`PropertyInfo`对象为`null`，我们抛出一个`ArgumentNullException`对象，提醒开发者他们使用了不存在的属性名称。否则，我们使用`PropertyInfo`对象的`GetValue`方法从其他属性中检索值。
- en: 'Now that we''ve seen how to use and create our own custom validation attributes,
    let''s see how we can use them to validate our data Model instances from one of
    their base classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用和创建我们自己的自定义验证属性，让我们看看我们如何使用它们来验证从其基类之一的数据模型实例：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We start by initializing a `ValidationContext` object, passing in the data Model
    instance from the base class. The context object is then passed to the `TryValidateObject`
    method of the `Validator` class, in order to retrieve any validation errors from
    any of the data annotation attributes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化一个`ValidationContext`对象，传入基类中的数据模型实例。然后，上下文对象被传递到`Validator`类的`TryValidateObject`方法，以检索任何数据注释属性中的验证错误。
- en: We also initialize and pass a list of the `ValidationResult` type to the `TryValidateObject`
    method, which will get filled with errors for the current data object. Note that
    the fourth `bool` input parameter of this method specifies whether it will return
    errors for all properties, or just for those that have been decorated with `RequiredAttribute`
    from the data annotations namespace.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还初始化并传递一个`ValidationResult`类型的列表到`TryValidateObject`方法，该方法将填充当前数据对象的错误。请注意，此方法的第四个`bool`输入参数指定它是否将返回所有属性的错误，或者仅针对那些已用数据注释命名空间中的`RequiredAttribute`装饰的属性。
- en: Later, we'll see how we can incorporate this into our application framework's
    validation base class, but now let's investigate how we can perform different
    levels of validation in different scenarios.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将看到如何将此集成到我们的应用程序框架的验证基类中，但现在让我们研究如何在不同的场景中执行不同级别的验证。
- en: Varying levels of validation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多级验证
- en: One thing that is not addressed by either of the .NET validation interfaces
    is the ability to either turn validation on or off, or to set varying levels of
    validation. This can be useful in several different scenarios, such as having
    different Views to edit different properties of a data Model object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: .NET验证接口中未解决的问题之一是能够打开或关闭验证，或者设置不同的验证级别。这在几个不同的场景中可能很有用，例如，有不同视图来编辑数据模型对象的属性。
- en: An example of this might be having a View that enables users to update the security
    settings of a `User` object, where we want to validate that each property has
    a value, but only for the properties that are currently displayed in the View.
    After all, there is no point in informing the user that a certain field must be
    entered if they can't do that in their current View.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能有一个视图允许用户更新`User`对象的网络安全设置，我们希望验证每个属性都有值，但只针对当前在视图中显示的属性。毕竟，如果用户无法在当前视图中执行此操作，通知用户某个字段必须输入是没有意义的。
- en: 'The solution is to define a number of levels of validation, in addition to
    the levels that represent full and no validation. Let''s take a look at a simple
    `ValidationLevel` enumeration that could fulfill this requirement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是定义多个验证级别，除了表示完全验证和无验证的级别之外。让我们看看一个简单的`ValidationLevel`枚举，它可能满足这个要求：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we can see, in this simple example, we just have the three levels of validation,
    although we could have added many more. However, in practice, we could still manage
    with this simple enumeration. Let''s see how we could use it to implement multi-level
    validation in our validation base class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这个简单的例子中，我们只有三个验证级别，尽管我们可以添加更多。然而，在实践中，我们仍然可以用这个简单的枚举来管理。让我们看看我们如何使用它来实现验证基类中的多级验证：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We add a `ValidationLevel` property, with its `validationLevel` backing field
    that defaults to the `Full` enumeration member, as that is the normal action.
    Then, in the `Validate` method, we add a new line that simply exits the method
    if the `ValidationLevel` property is set to the `None` enumeration member.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`ValidationLevel`属性，其`validationLevel`后端字段默认为`Full`枚举成员，因为这通常是正常操作。然后，在`Validate`方法中，我们添加了一行代码，如果`ValidationLevel`属性设置为`None`枚举成员，则简单地退出该方法。
- en: 'Finally, the developers that use our application framework need to use the
    `ValidationLevel` property when validating their properties in the data Model
    classes. Imagine a scenario where users could edit the names of our products directly
    in a collection control, or edit all of the product''s properties in a separate
    View. Let''s see what our `ProductNotify` class indexer property would need to
    look like to demonstrate this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用我们的应用程序框架的开发者需要在数据模型类中验证属性时使用`ValidationLevel`属性。想象一下，用户可以直接在集合控件中编辑我们的产品名称，或者在单独的视图中编辑所有产品的属性。让我们看看我们的`ProductNotify`类索引器属性需要看起来像什么以展示这一点：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using our implementation of the `INotifyDataErrorInfo` interface, we first initialize
    a `string` list named `errors` and then we check the value of the `propertyName`
    input parameter. As this implementation enables us to return multiple validation
    errors per property, we need to take care with our `if` and `else` statements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们对`INotifyDataErrorInfo`接口的实现，我们首先初始化一个名为`errors`的`string`列表，然后检查`propertyName`输入参数的值。由于此实现使我们能够针对每个属性返回多个验证错误，我们需要注意我们的`if`和`else`语句。
- en: For example, when the `propertyName` input parameter equals `Name`, we have
    two `if` statements and one `else` statement. The first `if` statement verifies
    that the `Name` property has a value, while the `else` statement checks that its
    value is no longer than 25 characters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当`propertyName`输入参数等于`Name`时，我们有两个`if`语句和一个`else`语句。第一个`if`语句验证`Name`属性是否有值，而`else`语句检查其值是否不超过25个字符。
- en: As these two conditions cannot possibly both be true at the same time, we tie
    them together with the `if...else` statement. On the other hand, the product name
    could be longer than 25 characters and start with a lowercase letter and so, the
    next condition has its own `if` statement. In this example, the `Name` property
    will be validated when the `ValidationLevel` property is set to either the `Partial`
    or `Full` members.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个条件不可能同时为真，我们使用`if...else`语句将它们结合起来。另一方面，产品名称可能超过25个字符，并且以小写字母开头，因此下一个条件有自己的`if`语句。在这个例子中，当`ValidationLevel`属性设置为`Partial`或`Full`成员时，将验证`Name`属性。
- en: 'However, the remaining condition for the `Price` property is only to be validated
    when the `ValidationLevel` property is set to the `Full` member and so, that is
    simply added as a further condition. To trigger partial validation on a data Model
    variable, we can simply set its `ValidationLevel` property as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Price`属性的剩余条件仅在`ValidationLevel`属性设置为`Full`成员时才进行验证，因此这只是一个额外的条件。要触发数据模型变量的部分验证，我们可以简单地将其`ValidationLevel`属性设置为以下内容：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's now investigate how we can combine the different techniques that we have
    viewed so far.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们研究如何结合我们迄今为止看到的不同的技术。
- en: Incorporating multiple validation techniques
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合多种验证技术
- en: Now that we've had a good look at the two validation interfaces, the data annotation
    attributes and the ability to validate with different levels, let's take a look
    at how we can amalgamate these different techniques.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经仔细研究了两个验证接口、数据注释属性以及不同级别的验证能力，让我们看看我们如何将这些不同的技术结合起来。
- en: 'Let''s create a `BaseNotifyValidationModelExtended` class by copying what we
    have in our `BaseNotifyValidationModel` class, and incorporating these following
    new additions. First, we need to add some extra using directives to the ones used
    in the previous implementation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过复制我们在`BaseNotifyValidationModel`类中的内容来创建一个`BaseNotifyValidationModelExtended`类，并包含以下新添加的内容。首先，我们需要添加一些额外的`using`指令到之前实现中使用的那些：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we need to add our `validationLevel` field:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加我们的`validationLevel`字段：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to add a constructor, in which we attach the `ExternalErrors_CollectionChanged`
    event handler to the `CollectionChanged` event of the `ExternalErrors` collection
    property, as we did earlier:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个构造函数，在其中我们将`ExternalErrors_CollectionChanged`事件处理程序附加到`ExternalErrors`集合属性上的`CollectionChanged`事件，就像我们之前做的那样：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s add the familiar `ValidationLevel`, `Errors`, and `ExternalErrors`
    properties, along with the abstract `ValidateAllProperties` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加熟悉的`ValidationLevel`、`Errors`和`ExternalErrors`属性，以及抽象的`ValidateAllProperties`方法：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that in this implementation, users of our framework will no longer need
    to override the `Errors` property in order to ensure that their validatable properties
    are validated. While we still declare this property as virtual, so that it can
    be overridden if necessary, this base class implementation already compiles all
    validation errors into the internal collection, ready for display, and should
    replace the one that we copied from the previous base class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个实现中，我们的框架的用户将不再需要覆盖`Errors`属性以确保他们的可验证属性得到验证。虽然我们仍然将其声明为虚拟的，以便在必要时可以覆盖，但这个基类实现已经将所有验证错误编译到内部集合中，准备显示，并应替换我们从上一个基类中复制的那一个。
- en: This time, we initialize a new local `errors` collection with all of the unique
    errors from each property error collection in the `AllPropertyErrors` property
    `Dictionary` object. We then add any errors from the `ExternalErrors` collection,
    if they do not already exist in the `errors` collection. This string `Errors`
    collection is primarily used because it is convenient to data bind to in the UI.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用`AllPropertyErrors`属性`Dictionary`对象中每个属性错误集合的所有唯一错误初始化一个新的局部`errors`集合。然后，如果它们尚未存在于`errors`集合中，我们添加`ExternalErrors`集合中的任何错误。这个`Errors`字符串集合主要用于它方便在UI中进行数据绑定。
- en: After the new `Errors` property, we see the `ExternalErrors` auto property with
    its initializer and the abstract `ValidateAllProperties` method that needs to
    be implemented in the derived classes and can be called to force a new validation
    pass, either pre-emptively, or on the click of a save button, once all fields
    have been filled. We'll see an example implementation of this shortly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的`Errors`属性之后，我们看到具有初始化器的`ExternalErrors`自动属性以及需要在派生类中实现并可以调用来强制进行新的验证遍历的抽象`ValidateAllProperties`方法，无论是主动还是点击保存按钮，一旦所有字段都已填写。我们很快将看到这个的示例实现。
- en: 'Returning to our base class now, after the `ValidateAllProperties` method,
    we need to declare a couple of `Validate` methods, to replace the one from the `BaseNotifyValidationModel` class. The
    first of these is a convenience method that accepts any number of property name
    input parameters and simply calls the second method once for each property name:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的基类，在`ValidateAllProperties`方法之后，我们需要声明几个`Validate`方法，以替换`BaseNotifyValidationModel`类中的那个。其中第一个是一个便利方法，它接受任意数量的属性名称输入参数，并为每个属性名称简单调用第二个方法一次：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the `Validate` method, if the `ValidationLevel` property is set to the `None` member,
    we perform no validation and return from the method immediately. Otherwise, we
    retrieve the data annotation-related validation errors, as described earlier, in
    the *Annotating data* section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Validate`方法中，如果`ValidationLevel`属性设置为`None`成员，我们不执行任何验证并立即从方法返回。否则，我们检索与之前在*数据注释*部分中描述的数据注释相关的验证错误。
- en: We then filter just the errors that relate to the property that is specified
    by the `propertyName` input parameter and concatenate them with the collection
    of errors returned from the `this` indexer property. We end by passing the compiled
    collection, containing all of the errors, along with the `propertyName` input
    parameter, to the unchanged `UpdateErrors` method from our `BaseNotifyValidationModel` class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先过滤与由`propertyName`输入参数指定的属性相关的错误，并将它们与`this`索引器属性返回的错误集合连接起来。最后，我们将包含所有错误的编译后的集合以及`propertyName`输入参数传递给我们的`BaseNotifyValidationModel`类中的未更改的`UpdateErrors`方法。
- en: 'Next, we need to add the `ExternalErrors_CollectionChanged` method, that is
    now referenced in the constructor. It simply notifies changes to the `Errors`
    collection property and the `HasError` property, so that they will be updated
    in the UI each time an external error is added or removed:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加`ExternalErrors_CollectionChanged`方法，该方法现在在构造函数中被引用。它只是通知`Errors`集合属性和`HasError`属性的变化，以便每次添加或删除外部错误时，它们都会在UI中更新：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `HasErrors` property can be used to set the visibility of a collection
    control in the UI so that it can display the complete collection of errors, whenever
    any exist, and hide it when there are none. The last change that we need to make
    is to add an additional condition to the `HasErrors` property, which listens out
    for external errors, as well the internally generated ones:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`HasErrors`属性来设置UI中集合控制的可见性，以便它可以在存在任何错误时显示完整的错误集合，并在没有错误时隐藏它。我们需要做的最后一个更改是向`HasErrors`属性添加一个额外的条件，该条件监听外部错误以及内部生成的错误：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, our base validation class will manage errors that are defined in the indexer
    of each derived class, along with those defined in any data annotation attributes that
    may decorate the class properties and also those generated by external View Models.
    Let's now see how we can use this.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的基验证类将管理在索引器中定义的错误，以及可能装饰类属性的任何数据注释属性以及由外部视图模型生成的错误。现在让我们看看我们如何使用它。
- en: 'Let''s first duplicate our `ProductNotify` class, rename it to `ProductNotifyExtended`,
    and make it extend our new `BaseNotifyValidationModelExtended` base class. We''ll
    then need to make these following changes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先复制我们的 `ProductNotify` 类，将其重命名为 `ProductNotifyExtended`，并使其扩展我们新的 `BaseNotifyValidationModelExtended`
    基类。然后我们需要进行以下更改：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This new data Model is the same as the duplicated one, other than the name,
    the base class, the `ValidateAllProperties` method, and the addition of the extra
    condition to the `this` indexer, which was discussed in the previous section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的数据模型除了名称、基类、`ValidateAllProperties` 方法和在前一小节中讨论的向 `this` 索引器添加额外条件之外，与复制的模型相同。
- en: The `ValidateAllProperties` method calls the `Validate` method of the base class,
    passing in the names of the `Name` and `Price` properties, and can be called from
    a View Model to validate those two properties at any time. The `this` indexer
    has been updated according to the example from the previous section, to enable
    the `ValidationLevel` property to play its part in the validation process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidateAllProperties` 方法调用基类的 `Validate` 方法，传入 `Name` 和 `Price` 属性的名称，并且可以从视图模型中随时调用以验证这两个属性。`this`
    索引器已根据前一小节的示例进行更新，以便 `ValidationLevel` 属性在验证过程中发挥作用。'
- en: 'Now, let''s create a `ProductNotifyViewModelExtended` class by duplicating
    and renaming the `ProductNotifyViewModel` class and making the following changes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过复制并重命名 `ProductNotifyViewModel` 类来创建一个 `ProductNotifyViewModelExtended`
    类，并做出以下更改：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we replace all instances of the `ProductNotify` class with the `ProductNotifyExtended` class,
    and all instances of the `ProductsNotify` class with the `ProductsNotifyExtended` class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将所有 `ProductNotify` 类的实例替换为 `ProductNotifyExtended` 类，并将所有 `ProductsNotify`
    类的实例替换为 `ProductsNotifyExtended` 类。
- en: 'The `ProductsNotifyExtended` class is the standard wrapper for encapsulating
    our `BaseCollection` class'' functionality:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductsNotifyExtended` 类是封装我们的 `BaseCollection` 类功能的标准包装器：'
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The final change in the `ProductNotifyViewModelExtended` class is to alter the
    values of the second data item in the constructor to those shown in the new example. Let's
    also create a new `ProductNotifyViewExtended` class from our `ProductNotifyView` class
    by simply duplicating and renaming it. No other changes to it are required at
    this point.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductNotifyViewModelExtended` 类的最后一个更改是在构造函数中将第二个数据项的值更改为新示例中显示的值。让我们也通过简单地复制并重命名它来从我们的
    `ProductNotifyView` 类创建一个新的 `ProductNotifyViewExtended` 类。在此阶段不需要对其做其他更改。'
- en: 'After wiring up the View and View Model in the `App.xaml` file and running
    this example, we can see that, like our `BaseValidationModelExtended` example,
    this implementation also enables us to display multiple validation errors per
    property in our global error output collection control:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.xaml` 文件中连接视图和视图模型并运行此示例后，我们可以看到，就像我们的 `BaseValidationModelExtended`
    示例一样，此实现也使我们能够在全局错误输出集合控件中为每个属性显示多个验证错误：
- en: '![](img/4ef2fd29-6b5b-4d52-8ea0-2fe4a8eac54d.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ef2fd29-6b5b-4d52-8ea0-2fe4a8eac54d.png)'
- en: Let's now examine how we can customize the way in which we highlight these validation
    errors to users.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何自定义向用户突出显示这些验证错误的方式。
- en: Customizing the error template
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义错误模板
- en: In addition to the essential `Errors` and `HasError` properties, the `Validation`
    class also declares an `ErrorTemplate` Attached Property of the `ControlTemplate` type. The
    default template assigned to this property is responsible for defining the red
    rectangle that surrounds UI fields that have validation errors associated with
    them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 `Errors` 和 `HasError` 属性外，`Validation` 类还声明了一个 `ControlTemplate` 类型的附加属性
    `ErrorTemplate`。分配给此属性的默认模板负责定义围绕与验证错误关联的 UI 字段的红色矩形。
- en: However, this property enables us to change this template and so, we are able
    to define how validation errors are highlighted to the application users. As this
    property is an Attached Property, this effectively means that we could apply a
    different template to be displayed for each control in the UI. However, this cannot
    be recommended because it could make the application look less consistent.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个属性使我们能够更改这个模板，因此，我们可以定义如何将验证错误突出显示给应用程序用户。由于这个属性是一个附加属性，这意味着我们可以为UI中的每个控件应用不同的模板。然而，这并不推荐，因为这可能会使应用程序看起来不那么一致。
- en: This template actually uses an `Adorner` element to render its graphics in the
    adorner layer, on top of the related control in error. Therefore, in order to
    specify where our error visual(s) should be rendered in relation to the related
    control, we need to declare an `AdornedElementPlaceholder` element in the error
    template.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板实际上使用了一个`Adorner`元素来在装饰层中渲染其图形，在错误的相关控件之上。因此，为了指定我们的错误视觉元素相对于相关控件的位置，我们需要在错误模板中声明一个`AdornedElementPlaceholder`元素。
- en: 'Let''s take a look at a simple example, where we define a slightly thicker,
    non-blurry border, unlike the default one, and paint over the background of the
    related control with feint red for added emphasis. We first need to define a `ControlTemplate`
    object in a suitable resource section:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，其中我们定义了一个比默认值稍厚的、非模糊的边框，并使用浅红色在相关控件背景上绘制，以增加强调。我们首先需要在合适的位置定义一个`ControlTemplate`对象：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we declare the `AdornedElementPlaceholder` element inside a
    `Border` element, so that the border will be rendered around the outside of the
    related control. Note that without declaring this `AdornedElementPlaceholder`
    element, our border would resemble a tiny red dot in the top left of the related
    control when an error occurred.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`Border`元素内部声明了`AdornedElementPlaceholder`元素，这样边框就会渲染在相关控件的外侧。注意，如果没有声明这个`AdornedElementPlaceholder`元素，当发生错误时，我们的边框将类似于相关控件左上角的一个小红点。
- en: 'Now, let''s see how we apply this template, using our earlier example of the
    control that was data bound to the `Product.Price` property:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何应用这个模板，使用我们之前提到的绑定到`Product.Price`属性的控件示例：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s see what it looks like when rendered:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看渲染后的样子：
- en: '![](img/a7dad1ca-1f85-42a2-96ae-e9a1971b7f20.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7dad1ca-1f85-42a2-96ae-e9a1971b7f20.png)'
- en: 'If we wanted to position our error highlighting elements in a different position
    with relation to the related control in error, we could use one of the panels
    to position them. Let''s take a look at a slightly more advanced error template
    that we could use. Let''s begin by declaring some resources in a suitable resource
    section:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将错误突出显示元素定位在相对于错误的相关控件的不同位置，我们可以使用其中一个面板来定位它们。让我们看看我们可以使用的稍微复杂一些的错误模板。让我们首先在合适的位置声明一些资源：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, we declare a `ToolTip` resource named `ValidationErrorsToolTip`.
    In it, we declare an `ItemsControl` element to display all of the validation errors
    together. We define a `DataTemplate` element in the `ItemTemplate` property, which
    will output the value of the `ErrorContent` property of each `ValidationError`
    object in the `Validation.Errors` collection. This collection will be implicitly
    set as the data context of the control template.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明了一个名为`ValidationErrorsToolTip`的`ToolTip`资源。在其中，我们声明了一个`ItemsControl`元素来显示所有的验证错误。我们在`ItemTemplate`属性中定义了一个`DataTemplate`元素，它将输出`Validation.Errors`集合中每个`ValidationError`对象的`ErrorContent`属性的值。这个集合将隐式设置为控件模板的数据上下文。
- en: Next, we declare a `ControlTemplate` element to set to the `ErrorTemplate` property,
    with the `WarningErrorTemplate` key. In it, we define a horizontal `StackPanel`
    control and, within that, we declare the required `AdornedElementPlaceholder`
    element. This is followed by the warning icon, taken from the Visual Studio icon
    set, that was discussed in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces*, with the `ValidationErrorsToolTip` resource
    applied to its `ToolTip` property.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个`ControlTemplate`元素并将其设置为`ErrorTemplate`属性，使用`WarningErrorTemplate`键。在其中，我们定义一个水平的`StackPanel`控件，并在其中声明所需的`AdornedElementPlaceholder`元素。随后是来自Visual
    Studio图标集的警告图标，这在[第8章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)中讨论过，*创建视觉吸引力的用户界面*，并应用了`ValidationErrorsToolTip`资源到其`ToolTip`属性。
- en: 'We can apply this template using the `ErrorTemplate` property as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ErrorTemplate`属性如下应用此模板：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When a validation error now occurs on this `TextBox` control, it will look
    like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在在这个`TextBox`控件上发生验证错误时，它将看起来像这样：
- en: '![](img/62127b07-35d2-4b77-a551-486c2eace818.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62127b07-35d2-4b77-a551-486c2eace818.png)'
- en: Now that we've investigated a variety of ways to display our validation errors,
    let's move on to explore how we can avoid UI-based validation errors altogether.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调查了显示验证错误的各种方法，让我们继续探讨如何完全避免基于UI的验证错误。
- en: Avoiding UI-based validation errors
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免基于UI的验证错误
- en: In the last example from the previous section, we data bound the entire `Validation.Errors`
    collection to a tooltip in the error template for our `TextBox` control. We also
    data bound our own `Errors` collection from our base class to the `ItemsControl`
    element above the form fields.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中的最后一个示例中，我们将整个`Validation.Errors`集合数据绑定到我们的`TextBox`控件的错误模板中的工具提示。我们还从我们的基类将我们自己的`Errors`集合数据绑定到表单字段上方的`ItemsControl`元素。
- en: 'Our `Errors` collection can display all of the errors for all of the properties
    in each data Model. However, the `Validation.Errors` collection has access to
    UI-based validation errors that never make it back to the View Models. Take a
    look at the following example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Errors`集合可以显示每个数据模型中所有属性的错误。然而，`Validation.Errors`集合可以访问基于UI的验证错误，这些错误永远不会返回到视图模型。看看以下示例：
- en: '![](img/5c519c13-cfcf-4ea7-8e84-df346068215d.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c519c13-cfcf-4ea7-8e84-df346068215d.png)'
- en: The UI-based validation error says Value '0t' could not be converted, and that
    explains why the View Models never see this error. The type of value expected
    in the data bound property is `decimal`, but an unconvertible value has been entered.
    Therefore, the input value cannot be converted to a valid `decimal` number and
    so, the data bound value is never updated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 基于UI的验证错误提示说值'0t'无法转换，这解释了为什么视图模型从未看到这个错误。数据绑定属性中期望的值类型是`decimal`，但输入了一个不可转换的值。因此，输入值无法转换为有效的`decimal`数字，所以数据绑定值永远不会更新。
- en: However, the `Validation.Errors` collection is a UI element, and each data bound
    control has its own collection, and so we have no simple way to access them all
    from our View Model classes. Furthermore, the `ValidationError` class is in the
    `System.Windows.Controls` UI assembly, so we don't want to add a reference of
    that to our `ViewModels` project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Validation.Errors`集合是一个UI元素，每个数据绑定控件都有自己的集合，因此我们无法从我们的视图模型类中简单地访问它们。此外，`ValidationError`类位于`System.Windows.Controls`
    UI程序集中，所以我们不希望将对该程序集的引用添加到我们的`ViewModels`项目中。
- en: 'Instead of trying to control the UI-based validation errors from the View Models,
    we can alternatively extend controls, or define Attached Properties that restrict
    the ability of the users to enter invalid data in the first place, thereby avoiding
    the need for UI-based validation. Let''s take a look at one way in which we can
    modify a standard `TextBox` control, so that it will only accept numerical input,
    using our `TextBoxProperties` class:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图从视图模型中控制基于UI的验证错误，我们可以扩展控件，或者定义附加属性来限制用户最初输入无效数据的能力，从而避免基于UI的验证的需要。让我们看看我们如何使用`TextBoxProperties`类修改标准的`TextBox`控件，使其只能接受数值输入：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Excluding the other, existing members from our `TextBoxProperties` class, we
    first declare the `IsNumericOnly` Attached Property and its related getter and
    setter methods and attach the `OnIsNumericOnlyChanged` handler.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 排除`TextBoxProperties`类中的其他现有成员，我们首先声明`IsNumericOnly`附加属性及其相关获取器和设置器方法，并附加`OnIsNumericOnlyChanged`处理器。
- en: In the `OnIsNumericOnlyChanged` method, we first cast the `dependencyObject`
    input parameter to a `TextBox` element and then cast the `NewValue` property of
    the `DependencyPropertyChangedEventArgs` class to the `bool` `newIsNumericOnlyValue`
    variable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnIsNumericOnlyChanged`方法中，我们首先将`dependencyObject`输入参数转换为`TextBox`元素，然后将`DependencyPropertyChangedEventArgs`类的`NewValue`属性转换为`bool`类型的`newIsNumericOnlyValue`变量。
- en: If the `newIsNumericOnlyValue` variable is `true`, we attach our event handlers
    for the `PreviewTextInput`, `PreviewKeyDown`, and `DataObject.Pasting` events.
    If the `newIsNumericOnlyValue` variable is `false`, we detach the handlers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`newIsNumericOnlyValue`变量为`true`，我们将为`PreviewTextInput`、`PreviewKeyDown`和`DataObject.Pasting`事件附加我们的事件处理器。如果`newIsNumericOnlyValue`变量为`false`，我们将断开处理器。
- en: We need to handle all of these events in order to create a `TextBox` control
    that can only enter numerical values. The `UIElement.PreviewTextInput` event is
    raised when a `TextBox` element receives a text input from any device, the `Keyboard.PreviewKeyDown`
    event occurs specifically when a keyboard key is pressed, and the `DataObject.Pasting`
    event is raised when we paste from the clipboard.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理所有这些事件，以便创建一个只能输入数值的 `TextBox` 控件。当 `TextBox` 元素从任何设备接收文本输入时，会引发 `UIElement.PreviewTextInput`
    事件，当按下键盘键时，会触发特定的 `Keyboard.PreviewKeyDown` 事件，当我们从剪贴板粘贴时，会引发 `DataObject.Pasting`
    事件。
- en: The `TextCompositionEventArgs` object in the `TextBox_PreviewTextInput` handler
    method only provides us with the last typed character through its `Text` property,
    along with `TextComposition` details. At the stage that this tunneling event is
    called, the `Text` property of the relevant `TextBox` control is not yet aware
    of this latest character.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TextBox_PreviewTextInput` 处理方法中的 `TextCompositionEventArgs` 对象仅通过其 `Text`
    属性提供给我们最后输入的字符，以及 `TextComposition` 详细信息。在调用此隧道事件阶段，相关 `TextBox` 控件的 `Text` 属性尚未意识到这个最新字符。
- en: Therefore, in order to correctly validate the whole entered text value, we need
    to combine the existing value with this new character. We do that in the `GetFullText`
    method and pass the returned value to the `IsTextValid` method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了正确验证整个输入的文本值，我们需要将现有值与这个新字符组合起来。我们在 `GetFullText` 方法中这样做，并将返回值传递给 `IsTextValid`
    方法。
- en: We then set the inverted return value of the `IsTextValid` method to the `Handled`
    property of the `TextCompositionEventArgs` input parameter. Note that we invert
    this `bool` value, because setting the `Handled` property to `true` will stop
    the event from being routed any further and result in the latest character not
    being accepted. Therefore, we do this when the input value is invalid.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `IsTextValid` 方法的反转返回值设置到 `TextCompositionEventArgs` 输入参数的 `Handled`
    属性。请注意，我们反转这个 `bool` 值，因为将 `Handled` 属性设置为 `true` 将停止事件进一步路由，并导致最新字符不被接受。因此，我们在输入值无效时执行此操作。
- en: Next, we see the `TextBox_PreviewKeyDown` event handler method, and in it, we
    again start by casting the `sender` input parameter to a `TextBox` instance. We
    specifically need to handle this event, because the `PreviewTextInput` event does
    not get raised when the *Space bar*, *Delete*, or *Backspace* keys on the keyboard
    are pressed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到 `TextBox_PreviewKeyDown` 事件处理方法，在其中，我们再次将 `sender` 输入参数强制转换为 `TextBox`
    实例。我们特别需要处理此事件，因为当按下键盘上的 *空格键*、*删除* 或 *退格* 键时，不会引发 `PreviewTextInput` 事件。
- en: Therefore, we stop the event being routed any further by setting the `Handled`
    property of the `KeyEventArgs` input parameter to `true` if the pressed key is
    the *Space bar* key, or if the length of the entered text is a single character
    and the *Delete* or *Backspace* key is pressed; this stops the user from deleting
    the last character from the `TextBox` control, which would result in a UI-based
    validation error.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果按下的键是 *空格键*，或者输入文本的长度是单个字符并且按下了 *删除* 或 *退格* 键，我们将通过将 `KeyEventArgs` 输入参数的
    `Handled` 属性设置为 `true` 来停止事件进一步路由；这阻止用户从 `TextBox` 控件中删除最后一个字符，这会导致基于 UI 的验证错误。
- en: However, if the user was trying to delete the last character because it was
    incorrect and they wanted to replace it with a different value, this could be
    awkward. Therefore, in this situation, we replace the last character with a zero
    and place the caret position after it, which then enables the user to type a different
    value. Note our extra condition that clears the text if the input is `0`, so that
    it will be replaced with the typed character.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果用户尝试删除最后一个字符是因为它不正确，并且他们想用不同的值替换它，这可能会很尴尬。因此，在这种情况下，我们将最后一个字符替换为零，并将光标位置放置在其后，这样用户就可以输入不同的值。请注意，我们添加了一个额外条件，如果输入是
    `0`，则清除文本，以便用输入的字符替换它。
- en: In the `TextBox_Pasting` handler method, we check whether the `DataObject` property
    that is accessed from the `DataObjectPastingEventArgs` input parameter has any
    `string` data available, and call its `CancelCommand` method to cancel the paste
    operation if not.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TextBox_Pasting` 处理方法中，我们检查从 `DataObjectPastingEventArgs` 输入参数访问的 `DataObject`
    属性是否有可用的 `string` 数据，如果没有，则调用其 `CancelCommand` 方法来取消粘贴操作。
- en: If `string` data is present, we cast the `sender` input parameter to a `TextBox`
    instance and then pass the data from the `DataObject` property to the `GetFullText`
    method to reconstruct the whole entered string. We pass the reconstructed text
    to the `IsTextValid` method and, if it is invalid, then we call the `CancelCommand`
    method to cancel the paste operation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`string`数据，我们将`sender`输入参数转换为`TextBox`实例，然后将`DataObject`属性的数据传递给`GetFullText`方法以重建整个输入字符串。我们将重建的文本传递给`IsTextValid`方法，如果它无效，则调用`CancelCommand`方法以取消粘贴操作。
- en: Next is the `GetFullText` method, where the entered text from the `TextBox` element is
    reconstructed. In this method, if any text is selected in the `TextBox` control,
    we rebuild the string by concatenating the portion of text before the selection
    with the newly entered or pasted text and the portion of text after the selection.
    Otherwise, we use the `Insert` method of the `String` class, along with the `TextBox` control's
    `SelectionStart` property, to insert the new character into the appropriate place
    in the string.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`GetFullText`方法，其中重建了从`TextBox`元素输入的文本。在这个方法中，如果`TextBox`控件中选择了任何文本，我们就通过连接选择前的文本部分、新输入或粘贴的文本以及选择后的文本部分来重建字符串。否则，我们使用`String`类的`Insert`方法以及`TextBox`控件的`SelectionStart`属性，将新字符插入到字符串的适当位置。
- en: 'At the end of the class, we see the `IsTextValid` method, which simply returns
    the `Success` property value of the `Regex.Match` method. The regular expression
    that we validate with is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在课程结束时，我们看到`IsTextValid`方法，它简单地返回`Regex.Match`方法的`Success`属性值。我们验证的正则表达式如下：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The ampersand (`@`)marks the string as a Verbatim String Literal, which is useful
    when using characters that normally need to be escaped, the caret (`^`) signifies
    the start of the input line, `\d*` indicates that we can have zero or more numerical
    digits, `\.?` specifies that zero or one periods are then valid, `\d*` again indicates
    that we can then have zero or more numerical digits, and finally, `$` signifies
    the end of the input line.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`（`@`）标记字符串为字面量，这在使用通常需要转义的字符时很有用，而`^`（ caret）符号表示输入行的开始，`\d*`表示我们可以有零个或多个数字，`\.?`指定然后可以有一个或零个点，`\d*`再次表示我们可以有零个或多个数字，最后，`$`表示输入行的结束。'
- en: 'When attached to an ordinary `TextBox` control, we can now only enter numeric
    values, but both integer and decimal values are allowed. Note that this particular
    implementation does not accept the minus sign, as we don’t want to allow negative
    prices, but that could be easily changed. Using our earlier `ProductNotifyViewExtended`
    example, we can attach our new property like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加到普通的`TextBox`控件时，我们现在只能输入数值，但整数和小数都是允许的。请注意，这个特定的实现不接受负号，因为我们不想允许负价格，但这可以很容易地更改。使用我们之前的`ProductNotifyViewExtended`示例，我们可以这样附加我们的新属性：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Keeping Synchronized with Legacy Behavior
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持与旧行为同步
- en: Those of you who have been experimenting with our various `Product`-related
    examples may have noticed something peculiar occurring when attempting to enter
    a price. In .NET 4.5, Microsoft decided to introduce a breaking change to the
    way that data is entered in the `TextBox` control, when the binding `UpdateSourceTrigger`
    value is set to `PropertyChanged`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 那些尝试过我们各种`Product`相关示例的人可能会注意到，当尝试输入价格时发生了一些奇怪的事情。在.NET 4.5中，微软决定对`TextBox`控件中数据输入的方式引入一个破坏性更改，当`UpdateSourceTrigger`绑定值设置为`PropertyChanged`时。
- en: From .NET 4.5, we can no longer enter a numerical separator, neither a period
    nor a comma, when we have data bound the `TextBox.Text` property to a `float`,
    `double`, or `decimal` data type. The reason why they did this was because previously,
    the value displayed in the `TextBox` control would get out of sync with the data
    bound value, at the moment when the user types a non-numerical character.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 4.5开始，当我们将`TextBox.Text`属性绑定到`float`、`double`或`decimal`数据类型时，我们不能再输入数值分隔符，无论是点还是逗号。他们这样做的原因是，之前在用户输入非数字字符时，`TextBox`控件中显示的值会与绑定值不同步。
- en: Let’s investigate this situation; A user wants to enter `0.99` and, after the
    second character, the input value of `0.` is sent back to the data bound View
    Model. But as it is not a valid decimal value, it is therefore parsed to `0` and
    that value is sent back to the data bound `Textbox` element to be displayed. Therefore,
    the second character, the decimal point, is removed from the `Text` field.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查这种情况；一个用户想要输入`0.99`，在第二个字符之后，输入值`0.`被发送回数据绑定的视图模型。但由于它不是一个有效的十进制值，因此它被解析为`0`，并将该值发送回数据绑定的`Textbox`元素以进行显示。因此，第二个字符，即小数点，被从`Text`字段中移除。
- en: Unfortunately, this change means that users can no longer directly type decimal
    places into a `TextBox` control when the `UpdateSourceTrigger` property is set
    to `PropertyChanged`. This can be seen in our `ProductView` example, where there
    is simply no way to enter a valid value with decimal places in the `TextBox` control
    labeled `Price`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个变更意味着当`UpdateSourceTrigger`属性设置为`PropertyChanged`时，用户不能再直接在`TextBox`控件中输入小数位数。这可以在我们的`ProductView`示例中看到，其中在标记为`Price`的`TextBox`控件中根本无法输入带有小数位的有效值。
- en: There are a number of ways to get around this issue, but none of them are perfect.
    One simple way is to set the `Mode` property on the `Binding` element to the `OneWayToSource`
    member, to stop the value being returned from the View Model, although this will
    also stop any initial default values being sent as well.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以解决这个问题，但没有一个是完美的。一种简单的方法是将`Binding`元素上的`Mode`属性设置为`OneWayToSource`成员，以阻止从视图模型返回值，尽管这也会阻止任何初始默认值被发送。
- en: 'When this breaking change was announced in .NET 4.5, a new property was introduced
    along with the change; The `KeepTextBoxDisplaySynchronizedWithTextProperty` property
    was added to the `FrameworkCompatibilityPreferences` class and specifies whether
    a `TextBox` control should display the same as its data bound property value.
    If we set this to `false`, it should return the previous behavior:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当在.NET 4.5中宣布这个重大变更时，随着变更引入了一个新的属性；`KeepTextBoxDisplaySynchronizedWithTextProperty`属性被添加到`FrameworkCompatibilityPreferences`类中，并指定了一个`TextBox`控件是否应该显示与它的数据绑定属性值相同。如果我们将其设置为`false`，它应该返回之前的行为：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that we need to set this property very early in the application lifetime,
    such as in the constructor of the `App.xaml.cs` file. Once set, it cannot be changed.
    Another way to avoid this problem is to set the `UpdateSourceTrigger` property
    to any value other than `PropertyChanged`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要在应用程序生命周期非常早的时候设置这个属性，例如在`App.xaml.cs`文件的构造函数中。一旦设置，就不能更改。避免这个问题的另一种方法是将`UpdateSourceTrigger`属性设置为除`PropertyChanged`之外的其他任何值：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: However, this is no use if we want to validate pre-emptively, or want our data
    source to update with each key press. Alternatively, we could simply data bind
    a `string` property to our `TextBox` control and perform our own number parsing
    in our View Model. This is perhaps the best solution from a user’s point of view,
    as it would enable them to type their values with ease.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要提前验证，或者想要我们的数据源在每次按键时更新，这就没有用了。或者，我们可以简单地将一个`string`属性数据绑定到我们的`TextBox`控件，并在我们的视图模型中执行自己的数字解析。这可能是一个从用户角度来看的最佳解决方案，因为它将使用户能够轻松地输入他们的值。
- en: 'Another option would be to utilize the `Delay` property of the `Binding` class,
    that we discussed in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*. If we set this to a figure of just a
    few hundred milliseconds, this would give the user enough time to enter their
    number, including the decimal point and the following digit(s), before the value
    is parsed to the data bound type:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是利用我们在[第4章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)中讨论的`Binding`类的`Delay`属性，*精通数据绑定*。如果我们将其设置为仅几百毫秒的数值，这将给用户足够的时间输入他们的数字，包括小数点和随后的数字，在值被解析为数据绑定类型之前：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is the option that we used in our examples, primarily because it is a quick
    and easy fix for this problem. However, care should be taken when using this method
    with actual monetary properties, as mistakes can easily be made if the user types
    slowly and does not pay attention to the entered value.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例中使用的选项，主要是因为它是一个快速且简单的修复方案。然而，在使用这种方法处理实际货币属性时，应该小心谨慎，因为如果用户输入速度慢且没有注意输入的值，错误很容易发生。
- en: As always with WPF, there are a number of different ways to implement any solution.
    As we just saw in the previous section, there are also other ways to stop users
    from entering invalid data in the first place; we could build, or make use of
    a third-party numeric up/down control, enable users to enter time values using
    a custom clock control, or even use combo boxes to restrict the values that users
    can select to a set of allowable values.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就像WPF一样，实现任何解决方案都有许多不同的方法。正如我们在上一节中看到的，也有其他方法可以阻止用户最初输入无效数据；我们可以构建或使用第三方数字上下控制，使用自定义时钟控制让用户输入时间值，或者甚至使用组合框来限制用户可以选择的值集合。
- en: Amalgamating validation and visuals
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和视觉的融合
- en: Let's now utilize some of the techniques that we discussed in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces*, to design a visually appealing user interface
    that highlights validation errors in a novel way, using our glowing example. For
    this example, we want the ability to know when the data has changed, so we'll
    need to extend our earlier `BaseSynchronizableDataModel` class in another new
    base class.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将利用我们在[第8章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)，“创建视觉吸引人的用户界面”中讨论的一些技术，来设计一个视觉上吸引人的用户界面，以新颖的方式突出显示验证错误，使用我们的发光示例。对于这个示例，我们希望有知道数据何时发生变化的能力，因此我们需要扩展我们之前定义的`BaseSynchronizableDataModel`类，并创建一个新的基类。
- en: 'Let''s duplicate our `BaseNotifyValidationModelExtended` class so as to create
    a new `BaseNotifyValidationModelGeneric` class, and make it extend our synchronizable
    base class. In doing so, we will also need to make it generic and add the same
    generic constraints for the `T` generic type parameter from the base class to
    its declaration:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制我们的`BaseNotifyValidationModelExtended`类，以便创建一个新的`BaseNotifyValidationModelGeneric`类，并使其扩展我们的可同步基类。在这个过程中，我们还需要使其泛型化，并将基类中`T`泛型类型参数的相同泛型约束添加到其声明中：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll need to remove the copied implementation of the `INotifyPropertyChanged` interface
    and make use of the existing implementation from the `BaseSynchronizableDataModel` class
    instead. We''ll also need to implement the new base class'' required members in
    a new `ProductNotifyGeneric` class. Let''s start by duplicating the `ProductNotifyExtended` class,
    renaming it to `ProductNotifyGeneric`, and then adding these methods to the end
    of it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要移除复制的`INotifyPropertyChanged`接口实现，并使用来自`BaseSynchronizableDataModel`类的现有实现。我们还需要在新的`ProductNotifyGeneric`类中实现新基类所需的新成员。让我们先复制`ProductNotifyExtended`类，将其重命名为`ProductNotifyGeneric`，然后向其末尾添加这些方法：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, we extend from our new generic `BaseNotifyValidationModelGeneric` class
    and implement all required members of the base class; the `CopyValuesFrom` method
    is used to make cloned copies of the data object, the `PropertiesEqual` method
    is used to compare its property values with other `ProductNotifyGeneric` instances,
    and the `ToString` method provides a useful textual output for the class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们扩展自我们的新泛型`BaseNotifyValidationModelGeneric`类，并实现基类中所有必需的成员；`CopyValuesFrom`方法用于创建数据对象的克隆副本，`PropertiesEqual`方法用于将其属性值与其他`ProductNotifyGeneric`实例进行比较，而`ToString`方法为该类提供了有用的文本输出。
- en: 'Now that we have extended our `BaseNotifyValidationModelGeneric` class from
    our earlier `BaseSynchronizableDataModel` class and extended from this, in turn,
    in our `ProductNotifyGeneric` class, we can now create a new `ProductsNotifyGeneric` collection
    class to extend our earlier `BaseSynchronizableCollection` class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从之前的`BaseSynchronizableDataModel`类扩展了我们的`BaseNotifyValidationModelGeneric`类，并且反过来，在`ProductNotifyGeneric`类中扩展了它，我们现在可以创建一个新的`ProductsNotifyGeneric`集合类来扩展我们之前的`BaseSynchronizableCollection`类：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Let's now create a View Model for this new example, where we will use these
    new Models. We can start by duplicating the `ProductViewModelExtended` View Model
    and renaming it to `ProductNotifyViewModelGeneric`. We will need to replace all
    instances of the `ProductExtended` class with our new `ProductNotifyGeneric` class,
    and all instances of the `ProductsExtended` collection class with the new `ProductsNotifyGeneric` class.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为这个新示例创建一个视图模型，我们将使用这些新的模型。我们可以从复制`ProductViewModelExtended`视图模型开始，并将其重命名为`ProductNotifyViewModelGeneric`。我们需要将所有`ProductExtended`类的实例替换为我们的新`ProductNotifyGeneric`类，并将所有`ProductsExtended`集合类的实例替换为新的`ProductsNotifyGeneric`类。
- en: 'After adding the two unchanged products from the previous View Model to it, we
    can now call the `Synchronize` method on our new `ProductsNotifyGeneric` collection
    in the constructor, in order to set the unchanged state of all of the contained
    data items:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在将之前视图模型中的两个未更改的产品添加到其中之后，我们现在可以在构造函数中调用新的`ProductsNotifyGeneric`集合上的`Synchronize`方法，以便设置所有包含数据项的未更改状态：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The only other change in the constructor is that we now call the base class
    `Validate` method on the current item, passing in the names of the `Name` and
    `Price` properties, which validates these fields in a pre-emptive manner, before
    the user has a chance to enter any data.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的唯一其他更改是我们现在在当前项上调用基类`Validate`方法，并传入`Name`和`Price`属性的名称，这样可以在用户有机会输入任何数据之前以预防性方式验证这些字段。
- en: 'The final thing that we need to add to this class is a number of methods that
    handle a command from the UI:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到这个类中的最后一件事是一系列处理来自UI的命令的方法：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we use our `ActionCommand` class to create an `ICommand` instance, which
    users can use to delete the selected item from the product collection in the UI.
    In the `CanDelete` method, we verify that the item to delete actually exists in
    the collection, but this can be replaced with your own condition. For example,
    you could check whether the item has any changes, or whether the current user
    has the correct security permission to delete objects. In the `Delete` method,
    we simply remove the selected item from the collection.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的`ActionCommand`类创建一个`ICommand`实例，用户可以使用它从UI中的产品集合中删除所选项。在`CanDelete`方法中，我们验证要删除的项实际上存在于集合中，但这可以替换为您的自己的条件。例如，您可以检查项是否有任何更改，或者当前用户是否有删除对象的正确安全权限。在`Delete`方法中，我们简单地从集合中删除所选项。
- en: 'Now that our View Model is ready, let''s turn our attention to the accompanying
    View. For this, let''s create a new View and name it `ProductNotifyViewGeneric`. We''ll
    then need to supply some more resources to use in this example. Let''s start by
    adding two further glow brush resources to the application resources file, with
    the `GreenGlow` brush resource from [C*hapter 8*](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml),
    *Creating Visually Appealing User Interfaces*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了视图模型，让我们将注意力转向配套的视图。为此，让我们创建一个新的视图，并将其命名为`ProductNotifyViewGeneric`。然后我们需要提供一些更多资源用于本例。让我们首先向应用程序资源文件中添加两个额外的发光画笔资源，包括来自[第8章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)，*创建视觉吸引人的用户界面*的`GreenGlow`画笔资源：
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s now see the styles that use these brush resources:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看使用这些画笔资源的样式：
- en: '[PRE60]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This first style is reusable and can be declared in the global application
    resources, while the following styles extend the first, are data Model-specific,
    and could be declared locally in our new `ProductNotifyViewGeneric` class:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种样式是可重用的，可以在全局应用程序资源中声明，而以下样式扩展了第一种样式，是数据模型特定的，可以在我们新的`ProductNotifyViewGeneric`类中本地声明：
- en: '[PRE61]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We declare the `ProductGlowStyle` style for our form rectangle, and the `ProductItemGlowStyle`
    style for our data items in the `Products` collection. The only differences can
    be found in the binding paths of the two data triggers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为表单矩形声明了`ProductGlowStyle`样式，并为`Products`集合中的数据项声明了`ProductItemGlowStyle`样式。这两个样式之间的唯一区别在于两个数据触发器的绑定路径。
- en: In these styles, we add a `DataTrigger` element that sets the rectangle `Fill`
    property to the `GreenGlow` resource when the `HasChanges` property of the current
    item in the `Products` collection is `True`, and another that sets it to the `RedGlow`
    resource when the `HasErrors` property of the current item is `True`. As the trigger
    that highlights errors is declared after the one that highlights valid changes,
    this will override the first if both conditions are `True`, which is essential
    for this example.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些样式中，我们添加了一个`DataTrigger`元素，当`Products`集合中当前项的`HasChanges`属性为`True`时，将矩形的`Fill`属性设置为`GreenGlow`资源，另一个将`Fill`属性设置为`RedGlow`资源，当当前项的`HasErrors`属性为`True`时。由于声明突出显示错误的触发器在声明突出显示有效更改的触发器之后，如果两个条件都为`True`，这将覆盖第一个，这对于本例至关重要。
- en: 'Next, we need to alter our default styles, which we added to the application
    resources for our first product example. Let''s add these new styles that are
    based on the original ones to our `ProductNotifyViewGeneric` class, so that they
    override the default ones:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们为第一个产品示例添加到应用程序资源中的默认样式。让我们将这些基于原始样式的新样式添加到我们的`ProductNotifyViewGeneric`类中，以便它们覆盖默认样式：
- en: '[PRE62]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As these new styles are based on the previous ones, we keep the same attribute
    values, but add a further one to each style. The `WhiteLabelStyle` style sets
    the `Foreground` property to `White`, and the `ErrorFreeFieldStyle` style sets
    the `Validation.ErrorTemplate` Attached Property to `null`, as we will have other
    ways to highlight validation errors in this example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些新样式基于之前的样式，我们保留了相同的属性值，但为每个样式添加了一个额外的属性。`WhiteLabelStyle` 样式将 `Foreground`
    属性设置为 `White`，而 `ErrorFreeFieldStyle` 样式将 `Validation.ErrorTemplate` 附加属性设置为 `null`，因为我们将在本例中用其他方式突出显示验证错误。
- en: 'Let''s now see the data template resource for the new `ProductNotifyGeneric` class,
    which makes use of our new `ProductItemGlowStyle` style, first ensuring that we
    have added a couple of XML namespace prefixes for our `DataModels` and `Views`
    projects:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下新 `ProductNotifyGeneric` 类的数据模板资源，它使用了我们的新 `ProductItemGlowStyle` 样式，首先确保我们为
    `DataModels` 和 `Views` 项目添加了几个 XML 命名空间前缀：
- en: '[PRE63]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example, we reuse our double border technique from [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml),* Creating
    Visually Appealing User Interfaces*, so there's no need to examine that code again.
    Inside the borders, we declare a `Grid` panel, which contains a `Rectangle` element,
    that has our new `ProductItemGlowStyle` style applied to it, and another `Grid`
    panel to display each user's name and a couple of images.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们重用了来自[第8章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)的“创建视觉吸引人的用户界面”的双边框技术，因此无需再次检查该代码。在边框内，我们声明了一个
    `Grid` 面板，其中包含一个应用了我们的新 `ProductItemGlowStyle` 样式的 `Rectangle` 元素，以及另一个 `Grid`
    面板来显示每个用户的名称和一些图像。
- en: These images are from the Visual Studio Image Library, which we discussed earlier,
    and we use the first to signify that these objects are products. The `VerticalAlignment`
    property of each of the three elements is set to `Center`, to ensure that they
    are all aligned vertically, and the `TextWrapping` property of the `TextBlock`
    element is set to `Wrap` in case any products have a long name.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像来自我们之前讨论过的 Visual Studio 图像库，我们使用其中的第一个来表示这些对象是产品。三个元素中的每个 `VerticalAlignment`
    属性都设置为 `Center`，以确保它们在垂直方向上对齐，而 `TextBlock` 元素的 `TextWrapping` 属性设置为 `Wrap`，以防任何产品名称过长。
- en: Note that the `ErrorTemplate` property of the `Validation` class has been set
    to `null` here in order to remove the default error template, which usually shows
    up as an unappealing red rectangle. As we make the entire object glow red when
    it has an error, there is no need for the default template to be displayed as
    well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里将 `Validation` 类的 `ErrorTemplate` 属性设置为 `null`，是为了移除默认的错误模板，该模板通常以不吸引人的红色矩形的形式出现。由于当对象有错误时，我们将整个对象发光变红，因此不需要同时显示默认模板。
- en: The second image specifies that each of these items can be deleted. Note that
    it is declared within a `Button` control, and while we have not attempted to style
    that button, it could also be given the double border treatment, or any other
    custom style. This button is optional, but has been included merely as an example
    of linking a command from the View Model to each data object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张图像指定了这些项目中的每个都可以被删除。请注意，它是在 `Button` 控件中声明的，尽管我们没有尝试对该按钮进行样式化，但它也可以被给予双边框处理或其他任何自定义样式。此按钮是可选的，但仅作为从视图模型到每个数据对象的命令链接的示例。
- en: Note that the binding path in the button's `Command` property uses a `RelativeSource`
    binding to reference the ancestor of the `ProductNotifyViewGeneric` type. In particular,
    it references the `DeleteCommand` property of the `DataContext` of the View, which,
    in our case, is an instance of our `ProductNotifyViewModelGeneric` class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，按钮的 `Command` 属性中的绑定路径使用 `RelativeSource` 绑定来引用 `ProductNotifyViewGeneric`
    类的祖先。特别是，它引用了视图的 `DataContext` 的 `DeleteCommand` 属性，在我们的情况下，这是一个 `ProductNotifyViewModelGeneric`
    类的实例。
- en: The `CommandParameter` property is then data bound to the entire data context
    of each data template, which means that the whole `ProductNotifyGeneric` data
    Model object will be passed through as the command parameter. Using our `ActionCommand`
    class, this is specified by the `action` and `canExecute` fields in the earlier
    example from our `ProductNotifyViewModelGeneric` class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`CommandParameter` 属性被绑定到每个数据模板的整个数据上下文，这意味着整个 `ProductNotifyGeneric` 数据模型对象将作为命令参数传递。使用我们的
    `ActionCommand` 类，这通过 `ProductNotifyViewModelGeneric` 类中早期示例的 `action` 和 `canExecute`
    字段来指定。
- en: 'Now that we have styled our `ProductNotifyGeneric` items in the `ListBox` control
    with this data template, there is something else that we can do to improve the
    look further; we can remove the default selection rectangle of the `ListBoxItem`
    elements that wrap our data Models. In .NET 3.5 and before, we could simply add
    some resources to a style for the `ListBoxItem` class that would do the job for
    us:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用这个数据模板在`ListBox`控件中设置了`ProductNotifyGeneric`项的样式，我们还可以做另外一件事来进一步改善外观；我们可以移除包裹我们的数据模型的`ListBoxItem`元素的默认选择矩形。在.NET
    3.5及之前版本中，我们只需向`ListBoxItem`类的样式添加一些资源，就可以完成这项工作：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, from .NET 4.0 onward, this will no longer work. Instead, we now need
    to define a new `ControlTemplate` object for the `ListBoxItem` class that does
    not highlight its background when selected, or when the user''s mouse cursor is
    over it:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从.NET 4.0开始，这将不再工作。相反，我们现在需要为`ListBoxItem`类定义一个新的`ControlTemplate`对象，该对象在选中时或当用户的鼠标光标悬停在其上时不会突出显示其背景：
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To create the `ControlTemplate` element in this style, we first accessed the
    default template of the `ListBoxItem` class, as described in the *Modifying Existing
    Controls* section of [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job*, and then simply removed the triggers that
    colored the background. We then added it to a style with no `x:Key` directive,
    so that it will be implicitly applied to all `ListBoxItem` elements within scope.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这种样式的`ControlTemplate`元素，我们首先访问了`ListBoxItem`类的默认模板，如[第5章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)中“*修改现有控件*”部分所述，*使用适合工作的控件*，然后简单地移除了着色背景的触发器。接着，我们将它添加到一个没有`x:Key`指令的样式，这样它就会隐式地应用于作用域内的所有`ListBoxItem`元素。
- en: 'Next, we have the `ErrorBorderStyle` style, which styles the border of our
    global validation error display and uses our `BoolToVisibilityConverter` class
    to set the `Visibility` property to show the control when the `HasErrors` property
    of the current item in the `Products` collection is `True`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`ErrorBorderStyle`样式，它为我们的全局验证错误显示的边框设置样式，并使用我们的`BoolToVisibilityConverter`类设置`Visibility`属性，当`Products`集合中当前项的`HasErrors`属性为`True`时显示控件：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now that we''ve added all of the required resources for our View, let''s move
    on to see the XAML file in the `ProductNotifyViewGeneric` class that uses them:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的视图添加了所有必需的资源，让我们继续查看`ProductNotifyViewGeneric`类中的XAML文件，它使用了这些资源：
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We use the same `Grid` panel as in the last example, with a `ListBox` control
    on the left and some form controls on the right. Note that we set the `HorizontalContentAlignment`
    property to `Stretch` on the `ListBox` control to ensure that its `ListBoxItem`
    elements stretch to fit its whole width.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与上一个例子相同的`Grid`面板，左侧有一个`ListBox`控件，右侧有一些表单控件。请注意，我们在`ListBox`控件上设置了`HorizontalContentAlignment`属性为`Stretch`，以确保其`ListBoxItem`元素可以拉伸以适应整个宽度。
- en: On the right, we see the double borders and the `Rectangle` element that is
    painted with the glow color resource that we created in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml),
    *Creating Visually Appealing User Interfaces*. Rather than hardcoding one particular
    color resource, as we did earlier, we instead apply our new `ProductGlowStyle`
    style to it, which will change the color with its data triggers, according to
    the validity of the data.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们看到双边框和用我们创建的发光颜色资源着色的`Rectangle`元素，该资源在[第8章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)中介绍，*创建视觉吸引人的用户界面*。而不是像之前那样硬编码一个特定的颜色资源，我们现在将我们的新`ProductGlowStyle`样式应用到它上面，这样它就会根据数据的有效性，通过其数据触发器改变颜色。
- en: Note that we have added an outer `Grid` panel, that contains only the glow rectangle
    and the original `Grid` panel, which now adds an outer margin to our form. The
    original panel remains much unchanged from the previous example, although the
    error display border now uses our new `ErrorBorderStyle` style and is displayed
    underneath the form fields, in acknowledgment that some users don't like their
    fields moving as errors appear and disappear.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了一个外部的`Grid`面板，它只包含发光矩形和原始的`Grid`面板，这现在为我们的表单添加了外部边距。原始面板与上一个例子相比变化不大，尽管错误显示边框现在使用我们新的`ErrorBorderStyle`样式，并且显示在表单字段下方，以承认一些用户不喜欢字段在错误出现和消失时移动。
- en: The form fields also mostly remain the same, although when using our new implementation,
    we no longer need to set the `ValidatesOnNotifyDataErrors` property to `True`
    on each binding. We also apply our new `WhiteLabelStyle` and `ErrorFreeFieldStyle` styles
    to the form labels and fields, to color the label foreground white and to hide
    the default red error border when there are validation errors.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段也大多保持不变，尽管在使用我们新的实现时，我们不再需要在每个绑定上设置 `ValidatesOnNotifyDataErrors` 属性为 `True`。我们还应用了我们的新
    `WhiteLabelStyle` 和 `ErrorFreeFieldStyle` 样式到表单标签和字段上，以便将标签前景色设置为白色，并在存在验证错误时隐藏默认的红色错误边框。
- en: 'When running this View now, it would render the following visual output, with
    a red glow on the form and the item in error:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在运行此视图时，它将渲染以下视觉输出，表单和错误项目上都有红色发光效果：
- en: '![](img/f39840c4-cf84-421b-9a63-a8a9e9f1e86c.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f39840c4-cf84-421b-9a63-a8a9e9f1e86c.png)'
- en: 'After correcting the errors, we''ll see a green glow on the form and the edited
    item:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在纠正错误后，我们会在表单和编辑的项目上看到绿色发光：
- en: '![](img/7a0f8496-2a6f-4462-81a6-dc6f34d41b8e.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a0f8496-2a6f-4462-81a6-dc6f34d41b8e.png)'
- en: 'After saving the changes, we''d need to call the `Synchronize` method on the
    `Products` collection again and then we''d see the following screenshot, where
    all objects are now painted with the default blue glow:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改后，我们需要再次在 `Products` 集合上调用 `Synchronize` 方法，然后我们会看到以下截图，其中所有对象现在都涂上了默认的蓝色发光效果：
- en: '![](img/422e278f-b0d5-4657-85bc-26e4e964d378.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/422e278f-b0d5-4657-85bc-26e4e964d378.png)'
- en: In this way, we are able to use the color of the glow to clearly inform users
    of the state of the control at any given time.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们能够使用发光的颜色清楚地通知用户在任何给定时间控件的状态。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a thorough look at the data validation options that
    the .NET Framework offers us, primarily concentrating on a variety of ways to
    implement the two available validation interfaces. We investigated the use of
    the data annotation validation attributes, explored the provision of custom error
    templates, and aggregated our new found knowledge with that from [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces,* in order to build up a visually pleasing
    validation example.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们全面了解了 .NET Framework 提供的数据验证选项，主要集中讨论了实现两个可用验证接口的多种方法。我们研究了数据注释验证属性的使用，探讨了提供自定义错误模板，并将我们新获得的知识与
    [第 8 章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)，*创建视觉上吸引人的用户界面* 中的知识相结合，以构建一个视觉上令人愉悦的验证示例。
- en: In the next chapter, we'll look at a number of ways in which we can provide
    users of our applications with a great user experience, from asynchronous programming
    to feedback mechanisms. We will also examine how to make use of application settings
    to provide user preferences and explore a variety of ways of supplying in-application
    help to the application users. We will end with a further look into additional
    ways of improving the user experience for end users.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨多种方式，通过这些方式我们可以为我们的应用程序用户提供出色的用户体验，从异步编程到反馈机制。我们还将研究如何利用应用程序设置来提供用户偏好，并探索向应用程序用户提供应用程序内帮助的各种方式。我们将以进一步探讨为最终用户提供改进用户体验的额外方式结束。
