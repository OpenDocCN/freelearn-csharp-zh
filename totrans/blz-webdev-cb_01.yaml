- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Working with Component-Based Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与基于组件的架构一起工作
- en: Welcome to *Blazor Web Development Cookbook* . This book will be your comprehensive
    guide to enhancing your skills in building dynamic and scalable web applications
    with Blazor. It offers a collection of practical solutions and techniques for
    tackling the most common challenges in web development. In each chapter, we’ll
    dive into different areas of application development. This book is packed with
    detailed examples and actionable tips. We’ll explore a range of topics – from
    optimizing components, through managing **application state** to increasing your
    application’s interactivity and security. Having such a resource will allow you
    to gain development velocity and focus on addressing business requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用**Blazor Web Development Cookbook**。本书将成为您在Blazor中构建动态和可扩展Web应用的全面指南。它提供了一系列实用解决方案和技术，用于应对Web开发中最常见的挑战。在每一章中，我们将深入研究应用开发的各个领域。本书包含详细的示例和可操作的建议。我们将探讨一系列主题——从优化组件，到管理**应用程序状态**，再到提高您应用程序的交互性和安全性。拥有这样的资源将使您能够提高开发速度，并专注于满足业务需求。
- en: In this chapter, you’ll learn about the core principles of component-based architecture
    in Blazor. We’ll start by creating a basic **component** and progress to more
    complex aspects such as parameterization for reusability and handling required
    parameters. We’ll also explore advanced topics, such as building components with
    customizable content, implementing generic components, and increasing **loose
    coupling** with **DynamicComponent** .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解Blazor中基于组件架构的核心原则。我们将从创建一个基本的**组件**开始，并逐步过渡到更复杂的方面，如参数化以提高可重用性和处理必需参数。我们还将探讨高级主题，例如使用可定制内容的组件构建、实现泛型组件以及通过**DynamicComponent**增加**松耦合**。
- en: By the end of this chapter, you’ll be able to implement and optimize components
    in **Blazor** . Understanding **component-based architecture** is foundational
    in building more sophisticated, interactive, and responsive web applications.
    It’s also essential for writing scalable, maintainable, and reusable code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够实现和优化**Blazor**中的组件。理解**基于组件的架构**是构建更复杂、交互性和响应性Web应用的基础。它对于编写可扩展、可维护和可重用的代码也是必不可少的。
- en: 'We’re going to cover the following recipes in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下食谱：
- en: Initializing a project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化项目
- en: Creating your first basic component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个基本组件
- en: Declaring parameters on a component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件上声明参数
- en: Detecting render mode at runtime
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时检测渲染模式
- en: Ensuring that a parameter is required
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保参数是必需的
- en: Passing values from the parent component with **CascadingParameter**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**CascadingParameter**从父组件传递值
- en: Creating components with customizable content
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有可定制内容的组件
- en: Making components generic
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使组件泛型
- en: Decoupling components with **DynamicComponent**
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**DynamicComponent**解耦组件
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You don’t need any paid tools or add-ons to kick off your Blazor journey. To
    aid with this, we’ve decided to limit the dependencies for the recipes in this
    book. You can pick up any topic independently whenever you need to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要任何付费工具或附加组件来开始您的Blazor之旅。为了帮助您，我们决定限制本书中食谱的依赖项。您可以在需要时独立选择任何主题。
- en: 'For this chapter, you’ll need the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要以下内容：
- en: A modern IDE. We’ll be using Visual Studio 17.12.0, but any other is also fine,
    so long as it supports development in . NET 9.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代IDE。我们将使用Visual Studio 17.12.0，但任何其他支持.NET 9开发的IDE也是可以的。
- en: A modern web browser.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代网络浏览器。
- en: The .NET 9 SDK. If it wasn’t part of your IDE installation, you can get it from
    [https://dotnet.microsoft.com/en-us/download/dotnet/9.0](https://dotnet.microsoft.com/en-us/download/dotnet/9.0)
    .
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 9 SDK。如果它不是您IDE安装的一部分，您可以从[https://dotnet.microsoft.com/en-us/download/dotnet/9.0](https://dotnet.microsoft.com/en-us/download/dotnet/9.0)
    获取。
- en: 'You can find all the code examples for this chapter on GitHub at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter01](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter01)
    .'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的所有代码示例：[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter01](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter01)
    。
- en: Initializing a project
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: With .NET 9, the .NET team focused on improving the quality, stability, and
    performance of Blazor applications. Thankfully, there are no breaking changes
    between .NET 8, so you can safely raise the target framework of your application.
    However, with .NET 8, Blazor got a whole new solution type and rendering experience,
    so we’ll review the steps required to initialize a new project here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET 9，.NET 团队专注于提高 Blazor 应用程序的质量、稳定性和性能。幸运的是，在 .NET 8 和 .NET 9 之间没有破坏性更改，因此您可以安全地提高应用程序的目标框架。然而，在
    .NET 8 中，Blazor 获得了全新的解决方案类型和渲染体验，因此我们将在此处回顾初始化新项目所需的步骤。
- en: Let’s initialize a **Blazor Web App** with a per-component rendering scope.
    It’s a strategic choice for our cookbook as it enables me to highlight various
    render mode caveats while we explore different areas of web development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们初始化一个具有按组件渲染范围的 **Blazor Web App**。这是一个战略选择，因为它使我能够在探索不同领域的 Web 开发时突出显示各种渲染模式的注意事项。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll showcase initializing the project with the GUI provided
    as part of Visual Studio. So, start your IDE and dive in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示使用 Visual Studio 提供的图形用户界面初始化项目。因此，启动您的 IDE 并开始操作。
- en: If you’re using the **.NET CLI** in your environment, I’ll provide equivalent
    commands in the *There’s* *more...* section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在环境中使用 **.NET CLI**，我将在 *更多...* 部分提供等效的命令。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to initialize the Blazor Web App project:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以初始化 Blazor Web App 项目：
- en: 'Start Visual Studio and select **Create a new project** from the welcome window:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 并从欢迎窗口中选择 **创建新项目**：
- en: '![Figure 1.1: Navigating to the project creation panel](img/B22020_01_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：导航到项目创建面板](img/B22020_01_1.jpg)'
- en: 'Figure 1.1: Navigating to the project creation panel'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：导航到项目创建面板
- en: 'Use the search bar at the top of the next panel to narrow the list of available
    project types, select **Blazor Web App** , and confirm your choice by clicking
    **Next** :'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下一面板顶部的搜索栏缩小可用的项目类型列表，选择 **Blazor Web App**，并通过点击 **下一步** 确认您的选择：
- en: '![Figure 1.2: Selecting Blazor Web App from the available project types](img/B22020_01_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：从可用的项目类型中选择 Blazor Web App](img/B22020_01_2.jpg)'
- en: 'Figure 1.2: Selecting Blazor Web App from the available project types'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：从可用的项目类型中选择 Blazor Web App
- en: 'On the **Configure your new project** panel, define the project’s name and
    location and confirm these details by clicking **Next** :'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **配置您的新的项目** 面板上，定义项目的名称和位置，并通过点击 **下一步** 确认这些详细信息：
- en: '![Figure 1.3: Setting the name and location of the new project](img/B22020_01_3.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：设置新项目的名称和位置](img/B22020_01_3.jpg)'
- en: 'Figure 1.3: Setting the name and location of the new project'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：设置新项目的名称和位置
- en: 'On the **Additional information** panel, choose the following options:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **附加信息** 面板上，选择以下选项：
- en: '**.NET 9.0 (Standard Term Support)** under **Framework**'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 9.0（标准术语支持）** 在 **框架** 下'
- en: '**Auto (Server and WebAssembly)** under **Interactive** **render mode**'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动（服务器和 WebAssembly）** 在 **交互** **渲染模式** 下'
- en: '**Per page/component** under **Interactivity location**'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按页面/组件** 在 **交互位置** 下'
- en: 'On top of that, check the **Include sample pages** checkbox. Confirm your choice
    by clicking **Create** :'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，勾选 **包含示例页面** 复选框。通过点击 **创建** 确认您的选择：
- en: '![Figure 1.4: Configuring the project’s framework and interactivity](img/B22020_01_4.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4：配置项目的框架和交互性](img/B22020_01_4.jpg)'
- en: 'Figure 1.4: Configuring the project’s framework and interactivity'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：配置项目的框架和交互性
- en: 'Here’s what your initial solution structure will look like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您的初始解决方案结构将如下所示：
- en: '![Figure 1.5: Initial project structure](img/B22020_01_5.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5：初始项目结构](img/B22020_01_5.jpg)'
- en: 'Figure 1.5: Initial project structure'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：初始项目结构
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we started Visual Studio and selected the **Create a new project**
    option from the welcome menu. Since Visual Studio comes with many project templates
    preinstalled, in *step 2* , we utilized the search bar at the top of the panel
    and, by searching for the **blazor** keyword, we quickly found and selected **Blazor
    Web App** from the results list. We proceeded to the next stage by clicking the
    **Next** button. In *step 3* , we defined the project name and location. For this
    book, I chose **BlazorCookbook.App** and **D:\packt** . We continued the setup
    process by clicking **Next** .
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们启动了Visual Studio，并从欢迎菜单中选择**创建新项目**选项。由于Visual Studio预装了许多项目模板，在**步骤
    2**中，我们利用面板顶部的搜索栏，通过搜索**blazor**关键字，我们快速从结果列表中找到了并选择了**Blazor Web App**。然后，我们通过点击**下一步**按钮进入下一阶段。在**步骤
    3**中，我们定义了项目名称和位置。对于这本书，我选择了**BlazorCookbook.App**和**D:\packt**。我们通过点击**下一步**按钮继续设置过程。
- en: In *step 4* , we configured the project. Considering that we’ll focus on Blazor
    in .NET 9, we chose **.NET 9.0 (Standard Term Support)** from the **Framework**
    dropdown. Then, we chose a **render mode** for our application from the **Interactive
    render mode** dropdown. With the **None** option, we effectively indicate that
    Blazor should use **server-side rendering** ( **SSR** ) mode. SSR is the fastest
    render mode as the markup is statically generated on the server but offers limited
    to no interactivity. When we expect interactivity, we must choose from the interactive
    modes. Here, **Server** (represented in the code as **InteractiveServer** ) renders
    components on the server with UI interactions managed via a **SignalR** connection,
    allowing dynamic content updates while keeping component logic server-side. Alternatively,
    **WebAssembly** ( **InteractiveWebAssembly** ) renders components directly in
    the browser using **WebAssembly** , facilitating fully interactive experiences
    without server communication for UI updates. Lastly, with the **Auto (Server and
    WebAssembly)** option ( **InteractiveAuto** ), we let Blazor select the best rendering
    method based on the current environment state and network conditions. We want
    to explore various render mode behaviors, so **Auto (Server and Webassembly)**
    was the best option for us. For **Interactivity location** , we selected **Per
    page/component** so that we can define render modes at the component level, as
    opposed to **Global** , which would set the render mode globally across the project.
    We also checked the **Include sample pages** box to trigger the scaffold of a
    basic layout and CSS. We intentionally left **Authentication type** set to **None**
    to avoid unnecessary complexity, although we plan to revisit authentication in
    [*Chapter 8*](B22020_08.xhtml#_idTextAnchor273) . We finalized the project creation
    process by clicking **Create** .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们配置了项目。考虑到我们将专注于.NET 9中的Blazor，我们从**框架**下拉菜单中选择了**.NET 9.0 (标准支持期)**。然后，我们从**交互式渲染模式**下拉菜单中为我们的应用程序选择了一个**渲染模式**。使用**无**选项，我们有效地表明Blazor应使用**服务器端渲染**（**SSR**）模式。SSR是渲染速度最快的模式，因为标记是在服务器上静态生成的，但提供的交互性有限或没有。当我们期望交互性时，我们必须从交互式模式中选择。在这里，**服务器**（在代码中表示为**InteractiveServer**）在服务器上渲染组件，并通过**SignalR**连接管理UI交互，允许动态内容更新，同时将组件逻辑保持在服务器端。或者，**WebAssembly**（**InteractiveWebAssembly**）直接在浏览器中使用**WebAssembly**渲染组件，便于实现无需服务器通信即可更新UI的完全交互式体验。最后，使用**自动（服务器和WebAssembly）**选项（**InteractiveAuto**），我们让Blazor根据当前环境状态和网络条件选择最佳的渲染方法。我们想探索各种渲染模式的行为，因此**自动（服务器和WebAssembly）**对我们来说是最好的选项。对于**交互性位置**，我们选择了**每页/组件**，这样我们就可以在组件级别定义渲染模式，而不是选择**全局**，这将在整个项目中设置渲染模式。我们还勾选了**包含示例页面**复选框以触发基本布局和CSS的生成。我们故意将**身份验证类型**设置为**无**，以避免不必要的复杂性，尽管我们计划在[*第
    8 章*](B22020_08.xhtml#_idTextAnchor273)中重新访问身份验证。我们通过点击**创建**按钮最终完成了项目创建过程。
- en: At this point, you should see the initial project structure. If you spot two
    projects, **BlazorCookbook.App** and **BlazorCookbook.App.Client** , that’s correct.
    Here, **BlazorCookbook.App** represents the server-side components of our application,
    while **BlazorCookbook.App.Client** is the client-side part that compiles into
    WebAssembly code. Everything that’s placed in **BlazorCookbook.App.Client** will
    be transmitted to the user’s browser, so you shouldn’t place any sensitive or
    confidential information there. Since **BlazorCookbook.App** references **BlazorCookbook.App.Client**
    , there’s no need to duplicate code, regardless of how it’s rendered initially.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，您应该看到初始项目结构。如果您发现有两个项目，**BlazorCookbook.App** 和 **BlazorCookbook.App.Client**，这是正确的。在这里，**BlazorCookbook.App**
    代表我们应用程序的服务器端组件，而 **BlazorCookbook.App.Client** 是客户端部分，它编译成 WebAssembly 代码。放置在
    **BlazorCookbook.App.Client** 中的所有内容都将传输到用户的浏览器，因此您不应将其中的任何敏感或机密信息放置在那里。由于 **BlazorCookbook.App**
    引用了 **BlazorCookbook.App.Client**，因此无论最初如何渲染，都不需要重复代码。
- en: There’s more...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If your IDE doesn’t have a GUI similar to Visual Studio, you can leverage the
    cross-platform .NET CLI. Navigate to your working directory and run the following
    command to initialize a Blazor Web App project with the same configuration that
    was outlined in *step 4* :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 IDE 没有类似于 Visual Studio 的 GUI，您可以使用跨平台的 .NET CLI。导航到您的工作目录，并运行以下命令以使用与
    *步骤 4* 中概述的相同配置初始化一个 Blazor Web App 项目：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating your first basic component
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第一个基本组件
- en: A component is a self-contained chunk of the **user interface** ( **UI** ).
    A component in Blazor is a .NET class with markup, created as a **Razor** ( **.razor**
    ) file. In Blazor, components are the primary building blocks of any application
    and encapsulate markup, logic, and styling. They enable code reusability and increase
    code maintainability and testability. This modular approach streamlines the development
    process greatly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一个独立的用户界面（**UI**）块。在 Blazor 中，组件是一个具有标记的 .NET 类，以 **Razor**（**.razor**）文件的形式创建。在
    Blazor 中，组件是任何应用程序的主要构建块，封装了标记、逻辑和样式。它们使代码可重用，并提高了代码的可维护性和可测试性。这种模块化方法极大地简化了开发过程。
- en: For our first component, we’ll create a **Ticket** component that renders a
    tariff name and a price when the user navigates to a page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个组件，我们将创建一个 **Ticket** 组件，当用户导航到页面时，它会渲染一个运费名称和价格。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you dive into creating the first component, in your Blazor project, create
    a **Recipe02** directory – this will be your working directory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始创建第一个组件之前，在您的 Blazor 项目中创建一个 **Recipe02** 目录——这将成为您的工作目录。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create your first component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您的第一个组件：
- en: Navigate to the **Recipe02** directory that you just created.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您刚刚创建的 **Recipe02** 目录。
- en: 'Use the **Add New Item** feature and create a Razor component:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **添加新项目** 功能创建一个 Razor 组件：
- en: '![Figure 1.6: Adding a new Razor component prompt](img/B22020_01_6.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6：添加新的 Razor 组件提示](img/B22020_01_6.jpg)'
- en: 'Figure 1.6: Adding a new Razor component prompt'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：添加新的 Razor 组件提示
- en: 'In the **Ticket** component, add supporting HTML markup:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Ticket** 组件中，添加支持 HTML 标记：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a new **Offer** component. Use the **@page** directive to make it navigable
    and render the **Ticket** component within:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 **Offer** 组件。使用 **@page** 指令使其可导航，并在其中渲染 **Ticket** 组件：
- en: '[PRE2]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *step 1* , we navigated to **Recipe02** – our working directory. In *step
    2* , we leveraged a built-in Visual Studio prompt to create files and create the
    first component: **Ticket** . While building components in the Razor markup syntax,
    we named our component file **Ticket.razor** . In *step 3* , we added simple markup
    to **Ticket** – we rendered **Adult** and **10.00 $** , which describe a given
    ticket. In *step 4* , we created our first page – the **Offer** page. In Blazor,
    any component can become a page with the help of a **@page** directive, which
    requires a fixed path argument starting with **/** . The **@page "/ch01r02"**
    directive enables navigation to that component. In the **Offer** markup, we embedded
    **Ticket** using the **self-closing tag** syntax – a simpler, more convenient
    equivalent of the explicit opening and closing tags ( **<Ticket></Ticket>** ).
    However, we can only utilize it when the component doesn’t require any additional
    content to render.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们导航到**Recipe02** – 我们的工作目录。在**步骤 2**中，我们利用内置的 Visual Studio 提示创建文件并创建了第一个组件：**Ticket**。在构建使用
    Razor 标记语法组件的过程中，我们命名了组件文件为 **Ticket.razor**。在**步骤 3**中，我们在**Ticket**中添加了简单的标记
    – 我们渲染了**Adult**和**10.00 $**，这些描述了一个给定的票。在**步骤 4**中，我们创建了我们的第一个页面 – **Offer**页面。在
    Blazor 中，任何组件都可以通过**@page**指令的帮助成为一个页面，该指令需要一个以**/**开头的固定路径参数。**@page "/ch01r02"**指令允许导航到该组件。在**Offer**标记中，我们使用**自闭合标签**语法嵌入**Ticket**
    – 这是显式打开和关闭标签（**<Ticket></Ticket>**）的更简单、更方便的等效方式。然而，我们只能在组件不需要渲染任何额外内容时使用它。
- en: There’s more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: While componentization in Blazor offers numerous benefits, it’s essential to
    know when and how much to use it. Components are a great way to reuse representation
    markup with various data objects. They significantly enhance code readability
    and testability. However, caution is necessary – you can overdo componentization.
    Using too many components leads to increased reflection overhead and unnecessary
    complexities in managing render modes. It’s especially easy to overlook when you’re
    refactoring grids or forms. Ask yourself whether every cell must be a component
    and whether you need that input encapsulated. Always weigh what you might gain
    from higher markup granularity with the performance cost it brings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Blazor 中的组件化提供了许多好处，但了解何时以及如何使用它是至关重要的。组件是重用各种数据对象的表示标记的绝佳方式。它们显著提高了代码的可读性和可测试性。然而，需要谨慎
    – 你可能会过度组件化。使用过多的组件会导致反射开销增加和管理渲染模式的不必要复杂性。当你重构网格或表单时，这尤其容易忽视。问问自己是否每个单元格都必须是一个组件，以及你是否需要封装该输入。始终权衡从更高的标记粒度中获得的好处与它带来的性能成本。
- en: Declaring parameters on a component
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件上声明参数
- en: In Blazor, component parameters allow you to pass data into components. It’s
    the first step in making your application dynamic. Component parameters are like
    method parameters in traditional programming. You can utilize the same primitive,
    as well as the reference and complex types. This results in code flexibility,
    simplified UI structures, and high markup reusability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 中，组件参数允许你将数据传递到组件中。这是使你的应用程序动态化的第一步。组件参数类似于传统编程中的方法参数。你可以利用相同的原始类型，以及引用和复杂类型。这导致代码灵活性、简化的
    UI 结构和高度的标记重用性。
- en: Let’s create a parametrized component that represents a ticket so that we can
    display any incoming tariff and price without unnecessary code duplication or
    markup incoherence.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个参数化组件来表示票，这样我们就可以显示任何传入的运费和价格，而无需不必要的代码重复或标记不一致。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you dive into component parameterization, do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你深入组件参数化之前，请执行以下操作：
- en: Create a **Recipe03** directory – this will be your working directory
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe03**目录 – 这将是你的工作目录
- en: Copy the **Ticket** component from the *Creating your first basic component*
    recipe or copy its implementation from the **Chapter01** / **Recipe02** directory
    of this book’s GitHub repository
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**创建你的第一个基本组件**食谱复制**Ticket**组件，或者从本书 GitHub 存储库的**Chapter01** / **Recipe02**目录中复制其实现
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To declare parameters on your component, start with these foundational steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件中声明参数，请从以下基础步骤开始：
- en: 'In the **Ticket** component, declare parameters in the **@** **code** block:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Ticket**组件中，在**@** **code**块中声明参数：
- en: '[PRE3]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Modify the **Ticket** markup so that you can render values from parameters:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改**Ticket**标记，以便可以从参数渲染值：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an **Offer** page and enhance it so that it renders in **InteractiveWebAssembly**
    mode:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**Offer**页面，并增强它以便以**InteractiveWebAssembly**模式渲染：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Below the functional directives in the **Offer** component, add two parametrized
    instances of **Ticket** . Implement an **Add()** method as a placeholder for interactivity:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Offer**组件的功能指令下方，添加两个参数化的**Ticket**实例。实现一个**Add()**方法作为交互性的占位符：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we extended the **Ticket** component with a **@code** block, which
    Blazor recognizes as a container for the C# code. Within this **@code** block,
    we used the **Parameter** attribute to mark properties that are settable externally,
    such as method arguments in C#. In our example, we used a string for a ticket
    tariff and a decimal for its price. For the last parameter, we used the **EventCallback**
    type. It’s a Blazor-specific **struct** that carries an invokable action with
    an additional benefit. When you change the UI state, you should use the **StateHasChanged()**
    life cycle method to notify Blazor that something happened. By design, **EventCallback**
    triggers **StateHasChanged()** automatically, so you can’t omit it accidentally.
    In *step 2* , we rebuilt the **Ticket** markup based on parameter values that
    we accessed using the **@** symbol. That symbol signaled to the compiler that
    we were switching to dynamic C# code. If you pair it with round brackets, you
    can embed complex code blocks as well, as we did when we formatted the price in
    a money format.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们通过一个**@code**块扩展了**Ticket**组件，Blazor将其识别为C#代码的容器。在这个**@code**块内部，我们使用了**Parameter**属性来标记可外部设置的属性，例如C#中的方法参数。在我们的例子中，我们使用字符串作为票价，使用十进制表示价格。对于最后一个参数，我们使用了**EventCallback**类型。这是一个Blazor特定的**struct**，它携带一个可调用的操作，并具有额外的优势。当你更改UI状态时，你应该使用**StateHasChanged()**生命周期方法来通知Blazor发生了什么。按照设计，**EventCallback**会自动触发**StateHasChanged()**，所以你不会意外地省略它。在*步骤
    2*中，我们根据使用**@**符号访问的参数值重新构建了**Ticket**标记。该符号向编译器发出信号，我们正在切换到动态C#代码。如果你搭配圆括号，你还可以嵌入复杂的代码块，就像我们格式化价格时使用货币格式一样。
- en: In *step 3* , we created a navigable **Offer** page. This time, on top of the
    **@page** directive, we also declared a **@rendermode** directive, which allowed
    us to control how our component renders initially. We can choose from any of the
    render modes that a Blazor Web App supports, but as we expect some interactivity
    on the page, we opted for **InteractiveWebAssembly** mode. In *step 4* , in the
    **@code** block of **Offer** , we implemented an **Add()** placeholder method
    that simulates adding a ticket to the cart. We also implemented the **Offer**
    markup, where we rendered two **Ticket** instances with different parameters.
    You pass parameter values similarly to standard HTML attributes such as **class**
    or **style** . Blazor automatically recognizes that you’re calling a component,
    not an HTML element. Finally, we rendered **Adult** and **Child** tickets and
    attached the **Add()** method to the exposed **EventCallback** parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，我们创建了一个可导航的**Offer**页面。这次，除了**@page**指令外，我们还声明了一个**@rendermode**指令，这允许我们控制组件的初始渲染方式。我们可以选择Blazor
    Web App支持的任何渲染模式，但由于我们预计页面会有一些交互性，我们选择了**InteractiveWebAssembly**模式。在*步骤 4*中，在**Offer**的**@code**块中，我们实现了一个**Add()**占位符方法，模拟将票添加到购物车。我们还实现了**Offer**标记，其中我们渲染了两个具有不同参数的**Ticket**实例。你传递参数的方式类似于标准HTML属性，如**class**或**style**。Blazor会自动识别你正在调用的是一个组件，而不是一个HTML元素。最后，我们渲染了**Adult**和**Child**票，并将**Add()**方法附加到暴露的**EventCallback**参数上。
- en: There’s more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You must be aware that the number of parameters can directly affect the rendering
    speed. That’s because the renderer uses reflection to resolve parameter values.
    Over-reliance on reflection can significantly hinder performance. You can optimize
    that process by overriding the **SetParametersAsync()** method of the component
    life cycle, though that’s an advanced operation. Instead, you should focus on
    keeping the parameters list concise or introducing wrapper classes where necessary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须意识到参数的数量可以直接影响渲染速度。这是因为渲染器使用反射来解析参数值。过度依赖反射会显著降低性能。你可以通过覆盖组件生命周期中的**SetParametersAsync()**方法来优化这个过程，尽管这是一个高级操作。相反，你应该专注于保持参数列表简洁或在必要时引入包装类。
- en: 'Earlier in this chapter, we declared a specific render mode for a component
    when your Blazor application is set to expect interactivity at the page or component
    level. However, when you enable interactivity globally, you can still exclude
    certain pages from interactive routing. You’ll find it useful for pages that depend
    on standard request/response cycles or reading or writing HTTP cookies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们为组件声明了特定的渲染模式，当你的 Blazor 应用程序设置为在页面或组件级别期望交互性时。然而，当你全局启用交互性时，你仍然可以排除某些页面从交互路由中。你会发现这对于依赖于标准请求/响应周期或读取或写入
    HTTP cookies 的页面很有用：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To enforce static server-side rendering on a page, you must add the **ExcludeFromInteractiveRouting**
    attribute, using the **@attribute** directive, at the top of the page. In this
    case, you no longer add the **@rendermode** directive as it’s dedicated to declaring
    interactive render modes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在页面上强制执行静态服务器端渲染，你必须使用**@attribute**指令在页面的顶部添加**ExcludeFromInteractiveRouting**属性。在这种情况下，你不再添加**@rendermode**指令，因为它专门用于声明交互渲染模式。
- en: Detecting render mode at runtime
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时检测渲染模式
- en: Understanding where and how your component renders is crucial for optimizing
    performance and tailoring user experience. Blazor allows you to detect the render
    location, interactivity, and assigned render mode at runtime. You can query whether
    the component is operating in an interactive state or just prerendering. These
    insights open up new possibilities for debugging, performance optimization, and
    building components that adapt dynamically to their rendering context.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的组件在哪里以及如何渲染对于优化性能和定制用户体验至关重要。Blazor 允许你在运行时检测渲染位置、交互性和分配的渲染模式。你可以查询组件是否处于交互状态或只是预渲染。这些见解为调试、性能优化和构建能够动态适应其渲染上下文的组件开辟了新的可能性。
- en: Let’s hide the area with tickets in the **Offer** component to prevent user
    interactions, such as adding tickets to the cart, until the component is ready
    and interactive.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们隐藏**Offer**组件中的票据区域，以防止用户交互，例如将票据添加到购物车，直到组件准备就绪并具有交互性。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Before you explore render mode detection, do the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在你探索渲染模式检测之前，请执行以下操作：
- en: Create a **Recipe04** directory – this will be your working directory
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe04**目录——这将是你的工作目录
- en: Copy the **Offer** and **Ticket** components from the *Declaring parameters
    on a component* recipe or copy their implementations from the **Chapter01** /
    **Recipe03** directory of this book’s GitHub repository
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**在组件上声明参数**菜谱中复制**Offer**和**Ticket**组件，或者从本书 GitHub 存储库的**Chapter01** / **Recipe03**目录中复制它们的实现
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Navigate to the **Offer** component and update the path attached to the **@page**
    directive to avoid routing conflicts:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Offer**组件并更新附加到**@page**指令的路径，以避免路由冲突：
- en: '[PRE8]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Below the component directives, add some conditional markup to indicate that
    the component is getting ready based on the value of the **RendererInfo.IsInteractive**
    property:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件指令下方添加一些条件标记，以根据**RendererInfo.IsInteractive**属性的值指示组件正在准备中：
- en: '[PRE9]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *s* *tep 1* , we navigated to the **Offer** component and updated the path
    that was assigned to the **@page** directive. Blazor doesn’t allow duplicated
    routes, so we triggered a conflict since we copied the **Offer** component with
    a route from the *Declaring parameters on a* *component* recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们导航到**Offer**组件并更新了分配给**@page**指令的路径。Blazor 不允许重复的路由，因此我们由于从**在组件上声明参数**菜谱中复制了**Offer**组件并带有路由而触发了冲突。
- en: 'In *step 2* , we introduced a conditional markup block below the component
    directives. We leveraged the **RendererInfo** property that the **ComponentBase**
    class exposes, allowing us to track the component rendering state. The **RendererInfo**
    property has two properties:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们在组件指令下方引入了一个条件标记块。我们利用了**ComponentBase**类公开的**RendererInfo**属性，使我们能够跟踪组件的渲染状态。**RendererInfo**属性有两个属性：
- en: 'The **RendererInfo.Name** property tells us where the component is currently
    running and returns the following options:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RendererInfo.Name**属性告诉我们组件当前正在哪里运行，并返回以下选项：'
- en: '**Static** : This indicates that the component is running on the server without
    any interactivity'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**：这表示组件正在服务器上运行，没有任何交互性'
- en: '**Server** : This indicates that the component is running on the server and
    will be interactive after it fully loads'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：这表示组件正在服务器上运行，并在完全加载后具有交互性'
- en: '**WebAssembly** : This indicates that the component is running in the client’s
    browser and becomes interactive after loading'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebAssembly**：这表示组件在客户端浏览器中运行，并在加载后变得交互式'
- en: '**WebView** : This indicates that it’s dedicated to .NET MAUI and native devices'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebView**：这表示它是为.NET MAUI和原生设备定制的'
- en: The **RendererInfo.IsInteractive** property shows whether the component is in
    an interactive state or not (such as during prerendering or static SSR)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RendererInfo.IsInteractive**属性显示组件是否处于交互状态（例如，在预渲染或静态SSR期间）'
- en: We leveraged the **RendererInfo.IsInteractive** property to detect whether the
    interactivity is ready. If it isn’t, we display a **Getting ready...** message
    to inform users they should wait.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用**RendererInfo.IsInteractive**属性来检测交互性是否就绪。如果没有就绪，我们显示**正在准备...**消息，通知用户他们应该等待。
- en: Ensuring that a parameter is required
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保参数是必需的
- en: The **EditorRequired** attribute indicates to your IDE that passing data to
    the component is functionally critical. This attribute triggers data validation
    at compile time, creating a quick feedback loop and enhancing code quality. Utilizing
    the **EditorRequired** attribute ensures neither you nor anyone from your team
    will fall into errors due to missing parameters. You can simplify your code by
    skipping initial parameter value validation. Using the **EditorRequired** attribute
    leads to robust and predictable component behavior throughout the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorRequired**属性指示你的IDE，向组件传递数据在功能上是关键的。此属性在编译时触发数据验证，创建一个快速反馈循环并提高代码质量。使用**EditorRequired**属性确保你或你的团队中的任何人都不会因为缺少参数而陷入错误。你可以通过跳过初始参数值验证来简化你的代码。使用**EditorRequired**属性可以使组件在整个应用程序中表现出稳健和可预测的行为。'
- en: Let’s enhance the **Ticket** component parameters so that Blazor treats them
    as required. You’ll also learn how to configure your IDE so that you can flag
    any missing required parameters as compilation errors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强**Ticket**组件的参数，以便Blazor将它们视为必需的。你还将学习如何配置你的IDE，以便你可以将任何缺少的必需参数标记为编译错误。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Before setting up the required parameters, do the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置必需参数之前，执行以下操作：
- en: Create a **Recipe05** directory – this will be your working directory
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe05**目录 – 这将是你的工作目录
- en: Copy the **Ticket** and **Offer** components from the previous recipe or copy
    their implementation from the **Chapter01** / **Recipe04** directory of this book’s
    GitHub repository
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上一个食谱复制**Ticket**和**Offer**组件，或者从本书GitHub仓库的**Chapter01** / **Recipe04**目录中复制它们的实现
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Ensure parameters are required in your component by following these steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤确保组件中的参数是必需的：
- en: 'Navigate to the **@code** block of the **Ticket** component and extend attribute
    collection on parameters with the **EditorRequired** attribute:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Ticket**组件的**@code**块，并使用**EditorRequired**属性扩展参数的属性集合：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, navigate to the **.csproj** file of the project where you’re keeping your
    components.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到包含你的组件的项目中的**.csproj**文件。
- en: 'Add the **RZ2012** code to the **WarningsAsErrors** section:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**RZ2012**代码添加到**WarningsAsErrors**部分：
- en: '[PRE11]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the **Offer** markup, modify the **Ticket** instances by removing the **OnAdded**
    parameter from both. Additionally, remove the **Price** parameter from the second
    instance:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Offer**标记中，通过从两个实例中移除**OnAdded**参数以及从第二个实例中移除**Price**参数来修改**Ticket**实例：
- en: '[PRE12]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Compile your application so that you can see your IDE flagging the omitted
    but required **Price** parameter:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的应用程序，以便你可以看到你的IDE标记省略但必需的**Price**参数：
- en: '![Figure 1.7: IDE flags missing the Price parameter as a compilation error](img/B22020_01_7.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7：IDE将缺少Price参数视为编译错误](img/B22020_01_7.jpg)'
- en: 'Figure 1.7: IDE flags missing the Price parameter as a compilation error'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：IDE将缺少Price参数视为编译错误
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *s* *tep 1* , we enhanced the **Tariff** and **Price** parameters of the
    **Ticket** component with the **EditorRequired** attribute. This prompts your
    IDE to expect these values during compilation and flag the missing ones as warnings
    by default. I suggest that you raise that severity. In *step 2* , you navigated
    to the **.csproj** file of your project. Here, as outlined in *step 3* , you either
    found or added the **WarningsAsErrors** section and included the **RZ2012** code
    within. In *s* *tep 4* , we broke the **Offer** markup a little. We removed the
    **OnAdded** parameter from both **Ticket** instances and the **Price** parameter
    from one of them. Now, any compilation attempt will end with an error, similar
    to the one shown in *step 5* . This makes it practically impossible to miss required
    assignments and encounter related rendering errors. Notice that as we didn’t mark
    the **OnAdded** parameter with the **EditorRequired** attribute, the compiler
    will treat it as optional and allow it to be skipped.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤1**中，我们增强了**票价**和**价格**参数的**票**组件的**EditorRequired**属性。这会提示您的IDE在编译期间期望这些值，并将默认情况下缺失的值标记为警告。我建议您提高严重性。在**步骤2**中，您导航到您项目的**.csproj**文件。在这里，如**步骤3**中概述的，您要么找到了它，要么添加了**WarningsAsErrors**部分，并包含了**RZ2012**代码。在**步骤4**中，我们稍微修改了**报价**标记。我们从两个**票**实例中移除了**OnAdded**参数，并从其中一个实例中移除了**价格**参数。现在，任何编译尝试都将以错误结束，类似于**步骤5**中显示的错误。这使得实际上不可能错过所需的分配并遇到相关的渲染错误。请注意，由于我们没有将**OnAdded**参数标记为**EditorRequired**属性，编译器将将其视为可选的，并允许跳过它。
- en: Passing values from the parent component with CascadingParameter
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CascadingParameter从父组件传递值
- en: Sharing parameters across multiple components is a common scenario in web applications.
    It boosts performance as data can be shared rather than being requested from an
    external source by each component. It also simplifies the code, especially in
    parent-child scenarios. In Blazor, that’s where the concept of **CascadingParameter**
    comes into play. Its counterpart, **CascadingValue** , allows you to provide a
    value that cascades down the component tree. This pair enables child components
    to receive and use this shared data or state. This approach solves the challenge
    of passing information through component hierarchies without complex plumbing
    or tightly coupled communication.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，跨多个组件共享参数是一个常见场景。它可以提高性能，因为数据可以共享，而不是每个组件都从外部源请求。它还简化了代码，尤其是在父子场景中。在Blazor中，这就是**级联参数**概念发挥作用的地方。其对应物，**级联值**，允许您提供在组件树中级联的值。这对组合使子组件能够接收和使用这些共享数据或状态。这种方法解决了通过组件层次结构传递信息而不需要复杂的管道或紧密耦合通信的挑战。
- en: Let’s implement a **Cart** service and pass it downward in a cascading fashion
    so that we can intercept it within the offer area represented by **Ticket** components.
    We’ll also render the **Cart** summary – fully decoupled from the **Ticket** behavior.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个**购物车**服务，并以级联方式向下传递，这样我们就可以在由**票**组件表示的报价区域内拦截它。我们还将渲染**购物车**摘要——完全解耦于**票**行为。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start exploring how to pass the cascading value, do the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索如何传递级联值之前，请执行以下操作：
- en: Create a **Recipe06** directory – this will be your working directory
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe06**目录——这将是你的工作目录
- en: Copy the **Ticket** component from the *Ensuring that a parameter is required*
    recipe or copy its implementation from the **Chapter01** / **Recipe05** directory
    of this book’s GitHub repository.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*确保参数是必需的*食谱中复制**票**组件，或者从本书GitHub存储库的**Chapter01** / **Recipe05**目录中复制其实现。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement **CascadingParameter** for value sharing:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现**级联参数**以实现值共享：
- en: 'Add a **Cart** class and declare supporting **Content** and **Value** properties.
    Extend **Cart** so that you can communicate state changes by requiring a fallback
    **Action** property with a primary constructor and implement the basic **Add()**
    method that triggers this notification:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**购物车**类并声明支持**内容**和**值**属性。扩展**购物车**，以便可以通过要求具有主要构造函数的回退**操作**属性来通过通信状态变化，并实现基本的**添加()**方法，该方法触发此通知：
- en: '[PRE13]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a **SellingTickets** component so that our tickets can be sold:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**SellingTickets**组件，以便我们可以出售我们的票：
- en: '![Figure 1.8: Adding a new SellingTickets component](img/B22020_01_8.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8：添加新的SellingTickets组件](img/B22020_01_8.jpg)'
- en: 'Figure 1.8: Adding a new SellingTickets component'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：添加新的SellingTickets组件
- en: 'Use the **@rendermode** attribute to declare that **SellingTickets** operates
    in **InteractiveWebAssembly** mode and a **@page** directive to enable routing:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **@rendermode** 属性声明 **SellingTickets** 在 **InteractiveWebAssembly** 模式下运行，并使用
    **@page** 指令启用路由：
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the **@code** block of **SellingTickets** , declare the **Cart** object
    and initialize it within the **OnInitialized()** life cycle method:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **SellingTickets** 的 **@code** 块中，声明 **Cart** 对象并在 **OnInitialized()** 生命周期方法中初始化它：
- en: '[PRE15]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the **SellingTickets** markup, add the **CascadingValue** wrapper with the
    **Cart** instance as its value. Declare two sellable tickets within the cart’s
    operational scope, leveraging the **Ticket** component:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **SellingTickets** 标记中，添加带有 **Cart** 实例作为其值的 **CascadingValue** 包装器。在购物车操作范围内声明两个可售票，利用
    **Ticket** 组件：
- en: '[PRE16]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Below the **Cart** area of the **SellingTickets** markup, append additional
    markup to display the **Cart** summary:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **SellingTickets** 标记的 **Cart** 区域下方，附加额外的标记以显示 **Cart** 摘要：
- en: '[PRE17]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Navigate to the **Ticket** component. In the **@code** block, declare **CascadingParameter**
    so that you can intercept the **Cart** instance and replace the **OnAdded** parameter
    with an **Add()** method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **Ticket** 组件。在 **@code** 块中，声明 **CascadingParameter** 以便拦截 **Cart** 实例，并将
    **OnAdded** 参数替换为 **Add()** 方法：
- en: '[PRE18]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the **Ticket** markup, replace the **@onclick** button action so that you
    can execute the new **Add()** method:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Ticket** 标记中，替换 **@onclick** 按钮动作，以便执行新的 **Add()** 方法：
- en: '[PRE19]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we implemented the **Cart** class. We declared a **Value** property
    to hold the current cart value and a **Content** collection to store added ticket
    tariffs. We also implemented a parameterless **Volume** method to calculate the
    amount of tickets currently in the cart. Then, we implemented an **Add()** method
    that, in addition to the normal logic for adding to the cart, is responsible for
    communicating those changes to external objects by invoking the **onStateHasChanged**
    delegate, which is passed using the **primary constructor** pattern. That way,
    we ensured **Cart** initialization requires us to provide an action to execute
    upon state changes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们实现了 **Cart** 类。我们声明了一个 **Value** 属性来存储当前购物车价值，一个 **Content** 集合来存储添加的票价格。我们还实现了一个无参数的
    **Volume** 方法来计算当前购物车中的票数量。然后，我们实现了一个 **Add()** 方法，除了正常的添加到购物车的逻辑外，还负责通过调用通过 **primary
    constructor** 模式传递的 **onStateHasChanged** 委托来将这些更改通知外部对象。这样，我们确保 **Cart** 初始化需要我们提供一个在状态更改时执行的操作。
- en: In *step 2* , we created a **SellingTickets** component. In *step 3* , we declared
    it to render in **InteractiveWebAssembly** mode and leveraged the **@page** directive
    to enable routing. In *step 4* , in the **@code** block of **SellingTickets**
    , we declared a **Cart** instance. We initialized **Cart** as part of the overridden
    **OnInitialized()** life cycle method and, as an invokable **Action** delegate
    responsible for applying state changes, we passed in the **StateHasChanged()**
    life cycle method. With that in place, any change in the **Cart** object will
    prompt Blazor to recalculate DOM changes at the level of the **SellingTicket**
    component. To avoid any threading or race condition issues, we wrapped the **StateHasChanged()**
    method in the **InvokeAsync()** component base method. In *step 5* , we implemented
    the **SellingTickets** markup. We used a **CascadingValue** component and assigned
    **Cart** as its value. We also declared **CascadingValue** content by adding two
    **Ticket** instances, representing tickets available for sale. In *step 6* , we
    extended the **SellingTickets** markup further by adding a section that contained
    the summary of the cart, showing its current size and value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们创建了 **SellingTickets** 组件。在 *步骤 3* 中，我们将其声明为以 **InteractiveWebAssembly**
    模式渲染，并利用 **@page** 指令启用路由。在 *步骤 4* 中，在 **SellingTickets** 的 **@code** 块中，我们声明了一个
    **Cart** 实例。我们将 **Cart** 作为重写的 **OnInitialized()** 生命周期方法的一部分进行初始化，并且作为负责应用状态变化的可调用
    **Action** 委托，我们传递了 **StateHasChanged()** 生命周期方法。这样一来，任何对 **Cart** 对象的更改都会促使 Blazor
    在 **SellingTicket** 组件的级别重新计算 DOM 变更。为了避免任何线程或竞态条件问题，我们在 **InvokeAsync()** 组件基方法中包装了
    **StateHasChanged()** 方法。在 *步骤 5* 中，我们实现了 **SellingTickets** 标记。我们使用了一个 **CascadingValue**
    组件，并将其值设置为 **Cart**。我们还通过添加两个代表可供销售的票的 **Ticket** 实例来声明 **CascadingValue** 内容。在
    *步骤 6* 中，我们通过添加一个包含购物车摘要的节来进一步扩展 **SellingTickets** 标记，显示其当前大小和价值。
- en: In *step 7* , we navigated to the **@code** block of the **Ticket** component
    and declared **CascadingParameter** there. Blazor will intercept this parameter’s
    value as it cascades from a parent component. Notably, we didn’t use **EditorRequired**
    here – as Blazor resolves the cascading value just in time, it would have no impact
    on compilation. With **Cart** available in the scope of the **Ticket** component,
    we replaced the existing **OnAdded** parameter with an **Add()** method that invokes
    **Cart.Add()** directly. In *step 8* , we updated the **Ticket** markup by replacing
    the outdated **@onclick** assignment on the existing button with a reference to
    the newly implemented **Add()** method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 7* 中，我们导航到 **Ticket** 组件的 **@code** 块并声明了 **CascadingParameter**。Blazor
    将拦截此参数的值，因为它从父组件传递下来。值得注意的是，我们在这里没有使用 **EditorRequired** - 因为 Blazor 在编译时解析级联值，所以它不会对编译产生影响。由于
    **Cart** 在 **Ticket** 组件的作用域内可用，我们用直接调用 **Cart.Add()** 的 **Add()** 方法替换了现有的 **OnAdded**
    参数。在 *步骤 8* 中，我们通过将现有按钮上的过时 **@onclick** 赋值替换为对新实现的 **Add()** 方法的引用来更新了 **Ticket**
    标记。
- en: There’s more...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: So, why does the **Cart** implementation require an **Action** delegate to work?
    Here, **StateHasChanged()** is a component life cycle method, so it triggers DOM
    re-rendering scoped to that component and its nested children. Since adding to
    the cart happens at the **Ticket** component level and invokes **StateHasChanged()**
    , there’s no impact on the parent **SellingTickets** component, and the **Cart**
    summary section remains unchanged! Having the **Action** delegate allows the **Cart**
    object to persist a reference to the origin component and thus trigger a DOM update
    at any level of the component tree.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 **Cart** 的实现需要一个 **Action** 委托才能工作？在这里，**StateHasChanged()** 是一个组件生命周期方法，因此它触发该组件及其嵌套子组件的
    DOM 重新渲染。由于添加到购物车是在 **Ticket** 组件级别发生的，并调用 **StateHasChanged()**，因此它不会影响父 **SellingTickets**
    组件，并且 **Cart** 摘要部分保持不变！拥有 **Action** 委托允许 **Cart** 对象持久化对原始组件的引用，从而在任何组件树级别触发
    DOM 更新。
- en: Creating components with customizable content
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有可定制内容的组件
- en: Creating components with customizable content in Blazor applications is another
    level in building flexible and reusable UI elements. This approach allows you
    to design functional components that can be adapted to various content needs and
    data types. We’ll utilize the **RenderFragment** feature to address it. The **RenderFragment**
    feature represents a segment of UI content. It allows components to accept arbitrary
    HTML markup as a parameter. That’s how you can achieve higher flexibility. You
    can repurpose a single component structure with different content, enhancing the
    modularity and reusability of your code base.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 应用程序中创建具有可定制内容的组件是构建灵活且可重用 UI 元素的一个新层次。这种方法允许你设计功能组件，这些组件可以适应各种内容需求和数据类型。我们将利用
    **RenderFragment** 功能来实现这一点。**RenderFragment** 功能表示一段 UI 内容。它允许组件接受任意 HTML 标记作为参数。这就是你如何实现更高灵活性的方法。你可以使用不同的内容重用单个组件结构，从而增强代码库的模块化和可重用性。
- en: Let’s create a **Ticket** component with a customizable display of ticket details
    while keeping a fixed button so that you can add the ticket to a cart.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有可定制显示票务详情的 **Ticket** 组件，同时保留一个固定的按钮，以便你可以将票务添加到购物车中。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you start implementing a component with customizable content, do the
    following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现具有可定制内容的组件之前，请执行以下操作：
- en: Create a **Recipe07** directory – this will be your working directory
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Recipe07** 目录 - 这将是你的工作目录
- en: Copy the **Chapter01** / **Data** directory, which contains the **Samples**
    and **TicketViewModel** objects required for this recipe, next to the working
    directory
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Chapter01** / **Data** 目录复制到工作目录旁边，该目录包含此食谱所需的 **Samples** 和 **TicketViewModel**
    对象
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build a component with customizable content:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建具有可定制内容的组件：
- en: Create a new **Ticket** component. We’ll use this to display individual ticket
    details.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **Ticket** 组件。我们将使用它来显示单个票务详情。
- en: 'In the **@code** block of **Ticket** , add the **Id** and **ChildContent**
    parameters and an **Add()** placeholder method that simply writes a console message
    displaying the ID of the ticket that was added to the cart:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Ticket** 的 **@code** 块中，添加 **Id** 和 **ChildContent** 参数以及一个简单的 **Add()**
    占位符方法，该方法仅显示添加到购物车中的票务 ID 的控制台消息：
- en: '[PRE20]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the **Ticket** markup, render the **ChildContent** value and a button to
    trigger the **Add()** method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 **Ticket** 标记，渲染 **ChildContent** 值和一个按钮以触发 **Add()** 方法：
- en: '[PRE21]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a routable **Offer** component that renders in **InteractiveWebAssembly**
    mode. Add a **@using** directive so that the **Samples** object can be referenced:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可路由的**Offer**组件，以**InteractiveWebAssembly**模式渲染。添加一个**@using**指令，以便可以引用**Samples**对象：
- en: '[PRE22]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As markup of the **Offer** component, while leveraging the **Ticket** component,
    render a **Samples.Adult** ticket tariff and price and a **Samples.FreeAdmission**
    ticket with just a tariff name since it’s free to do so:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为**Offer**组件的标记，在利用**Ticket**组件的同时，渲染一个**Samples.Adult**成人票运费和价格，以及一个仅包含运费名称的**Samples.FreeAdmission**免费入场票，因为这样做是免费的：
- en: '[PRE23]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we created a new **Ticket** component and implemented its **@code**
    block in *step 2* . Then, we declared a set of required parameters – **Id** to
    add a ticket to the cart and **ChildContent** , which is of the **RenderFragment**
    type, to hold the custom markup for a **Ticket** instance. We leveraged the **EditorRequired**
    attribute and made both parameters required. In *step 3* , we implemented the
    **Ticket** markup. We embedded the **ChildContent** value to render ticket details
    by placing it the same as any other parameter. We also added a button that allows
    the user to add a ticket to the cart by leveraging the **Add()** method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们创建了一个新的**Ticket**组件，并在**步骤 2**中实现了其**@code**块。然后，我们声明了一组必需的参数——**Id**用于将票添加到购物车，以及**ChildContent**，它是**RenderFragment**类型，用于保存**Ticket**实例的自定义标记。我们利用了**EditorRequired**属性，并使这两个参数成为必需的。在**步骤
    3**中，我们实现了**Ticket**标记。我们将**ChildContent**值嵌入其中，通过将其放置在与其他参数相同的位置来渲染票详情。我们还添加了一个按钮，允许用户通过利用**Add()**方法将票添加到购物车。
- en: In *step 4* , we created an **Offer** component. We utilized the **@page** directive
    to make it routable and declared it so that it rendered in the **InteractiveWebAssembly**
    mode. On top of that, we added a **@using** directive with the namespace of the
    **Samples** object so that we could reference it within the **Offer** component
    (the namespace can vary depending on the structure and name of your solution).
    In *step 5* , we implemented the **Offer** markup and saw the **RenderFragment**
    object in action. For an adult ticket with a price tag, we rendered both its tariff
    and price. For the free admission ticket, we chose to render only the tariff name.
    Blazor will inject the custom markup in place of the **ChildContent** parameter,
    within the **Ticket** component, while retaining and reusing the interactive button
    implementation, regardless of the customized content.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们创建了一个**Offer**组件。我们使用了**@page**指令使其可路由，并声明它以**InteractiveWebAssembly**模式渲染。在此基础上，我们添加了一个带有**Samples**对象命名空间的**@using**指令，以便我们可以在**Offer**组件中引用它（命名空间可能根据解决方案的结构和名称而变化）。在**步骤
    5**中，我们实现了**Offer**标记，并看到了**RenderFragment**对象的实际应用。对于带有价格标签的成人票，我们渲染了其运费和价格。对于免费入场票，我们选择只渲染运费名称。Blazor将在**Ticket**组件内将自定义标记注入到**ChildContent**参数中，同时保留并重用交互式按钮的实现，无论定制内容如何。
- en: There’s more...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You can use a **RenderFragment** object to encapsulate common parts of your
    components. The testing and maintainability of your code will skyrocket. Another
    reason to leverage them is that a static **RenderFragment** instance positively
    impacts performance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**RenderFragment**对象来封装组件的公共部分。您的代码的测试和可维护性将大幅提升。利用它们的另一个原因是静态的**RenderFragment**实例对性能有积极影响。
- en: You might have noticed that when a **RenderFragment** parameter is named **ChildContent**
    , the compiler automatically recognizes and assigns its value. You can still opt
    to declare **<ChildContent>** **</ChildContent>** explicitly but there’s no need
    to complicate your code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，当**RenderFragment**参数命名为**ChildContent**时，编译器会自动识别并分配其值。您仍然可以选择显式声明**<ChildContent>**
    **</ChildContent>**，但这样做没有必要使代码复杂化。
- en: However, you might encounter scenarios where you need more than one customizable
    section within a component. Fortunately, Blazor allows you to have multiple **RenderFragment**
    parameters. To implement that, you must explicitly declare both **RenderFragment**
    values using markup element syntax within your component. This approach enables
    even higher modularity and adaptability of your UI. For instance, you could have
    **Details** and **Actions** content to structure your component with multiple
    customizable areas. You can see that in the following code blocks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会遇到需要在一个组件内具有多个可自定义部分的场景。幸运的是，Blazor允许你拥有多个**RenderFragment**参数。为了实现这一点，你必须在组件中显式声明两个**RenderFragment**值，使用标记元素语法。这种方法使你的UI具有更高的模块化和适应性。例如，你可以有**详情**和**操作**内容来结构化你的组件，具有多个可自定义区域。你可以在以下代码块中看到这一点。
- en: 'Here’s the **Ticket** component, which allows us to customize the **Details**
    and **Actions** areas:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是**票据**组件，它允许我们自定义**详情**和**操作**区域：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the **Ticket** component in action, with customized **Details** and
    **Actions** areas:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**票据**组件的实际应用，带有自定义的**详情**和**操作**区域：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Making components generic
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使组件通用
- en: A **generic class** in C# is a class that’s defined with a placeholder type,
    allowing it to operate with any data type. This flexibility enables the creation
    of a single class that can adapt its behavior to a variety of data types, enhancing
    code reusability and efficiency. Generic components in Blazor applications are
    a similar concept. These components are highly reusable across different contexts
    and data types. They abstract away specific details, allowing high adaptability
    to various data or functionalities with minimal changes. This approach significantly
    reduces code duplication. With that flexibility, you can achieve even higher delivery
    velocity. The most common scenario where you’ll see generic components shine is
    repetitive data display, especially grids.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的**通用类**是一个使用占位符类型定义的类，允许它使用任何数据类型进行操作。这种灵活性使得可以创建一个可以适应多种数据类型的单个类，从而提高代码的可重用性和效率。Blazor应用程序中的通用组件是一个类似的概念。这些组件在不同上下文和数据类型之间具有高度的可重用性。它们抽象出特定细节，允许在各种数据或功能上具有最小更改的高适应性。这种方法显著减少了代码重复。有了这种灵活性，你可以实现更高的交付速度。你会在最常见的情况下看到通用组件的亮点，尤其是在重复数据显示，尤其是网格中。
- en: Let’s create a generic **Grid** component that can render objects of any type
    by using the provided row template.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个通用的**Grid**组件，它可以通过提供的行模板渲染任何类型的对象。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you start implementing the generic grid, do the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现通用网格之前，执行以下操作：
- en: Create a **Recipe08** directory – this will be your working directory
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe08**目录——这将是你的工作目录
- en: Copy the **Chapter01** / **Data** directory, which contains the **Samples**
    and **TicketViewModel** objects required for this recipe, next to the working
    directory
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制**Chapter01**/ **数据**目录，该目录包含此食谱所需的**样本**和**TicketViewModel**对象，并将其放在工作目录旁边
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to build and use your generic component:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建和使用你的通用组件：
- en: 'Create a **Grid** component. At the top of the file, declare it as generic
    with the **@** **typeparam** attribute:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**Grid**组件。在文件顶部，使用**@** **typeparam**属性将其声明为通用：
- en: '[PRE26]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the **@code** block of the **Grid** component, declare parameters for data
    source and table area customization. The source and row template must be generic:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Grid**组件的**@code**块中，声明数据源和表格区域自定义的参数。源和行模板必须是通用的：
- en: '[PRE27]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the **Grid** markup, add a standard HTML table with the **Header** content
    rendered where the table header is. For the table body, iterate over **Data**
    and render the **Row** template for each element:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Grid**标记，添加一个标准的HTML表格，将**标题**内容渲染在表格标题的位置。对于表格主体，遍历**数据**并渲染每个元素的**行**模板：
- en: '[PRE28]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a routable **Offer** component that renders in **InteractiveWebAssembly**
    mode and uses the **Samples** assembly so that **Samples** can be referenced later:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可路由的**报价**组件，以**交互式WebAssembly**模式渲染，并使用**样本**组件，以便以后可以引用**样本**：
- en: '[PRE29]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the **@code** block of **Offer** , implement an **Add()** placeholder method
    that writes a simple action confirmation to **Console** :'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Offer**的**@code**块中，实现一个**Add()**占位符方法，将简单的操作确认写入**控制台**：
- en: '[PRE30]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the markup of the **Offer** component, use the **Grid** component and pass
    in **Samples.Tickets** as the data source for **Grid** :'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**报价**组件的标记中，使用**Grid**组件并将**Samples.Tickets**作为**Grid**的数据源：
- en: '[PRE31]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the required **Header** area inside the **Grid** instance in the
    **Offer** markup:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Offer**标记中的**Grid**实例内实现所需的**Header**区域：
- en: '[PRE32]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the **Grid** instance, in the **Offer** markup, implement the required
    **Row** template so that elements of the **TicketViewModel** type can be rendered:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Grid**实例内，**Offer**标记中，实现所需的**Row**模板，以便可以渲染**TicketViewModel**类型的元素：
- en: '[PRE33]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started this recipe by implementing the foundation for creating a generic
    component. In *step 1* , we created a **Grid** component and added the **@typeparam**
    attribute at the top. We also specified the name for the parameter type placeholder
    – much like you would in backend development. We chose to call it **T** . Blazor
    recognized **@typeparam** and now allows us to operate on **T** inside the component.
    The IDE will also apply all validations that generic modules require. In *step
    2* , we implemented the **@code** block of the **Grid** component by adding a
    **Data** parameter that will hold elements to render and two **RenderFragment**
    parameters, enabling **Grid** customization. You can learn more about **RenderFragment**
    in the *Creating components with customizable content* section. Notably, the **Data**
    collection isn’t the only generic object. The **Row** parameter, which contains
    a row template, is also generic, which means it will expect a data object of type
    **T** for initialization. In *step 3* , we implemented the **Grid** markup. We
    rendered the **Header** value inside the **<thead>** tags, where the table header
    normally goes; for the table body, we used a **foreach** loop to iterate over
    the **Data** collection and rendered the **Row** template for each element.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现创建通用组件的基础开始这个食谱。在*第1步*中，我们创建了一个**Grid**组件，并在顶部添加了**@typeparam**属性。我们还指定了参数类型占位符的名称——就像在后端开发中做的那样。我们选择称之为**T**。Blazor识别了**@typeparam**，现在允许我们在组件内部操作**T**。IDE还将应用所有泛型模块所需的验证。在*第2步*中，我们通过添加一个将持有要渲染的元素的**Data**参数和两个**RenderFragment**参数来实现**Grid**组件的**@code**块，这些参数使**Grid**可定制。你可以在*创建具有可定制内容的组件*部分了解更多关于**RenderFragment**的信息。值得注意的是，**Data**集合并不是唯一的泛型对象。包含行模板的**Row**参数也是泛型的，这意味着它将期望一个类型为**T**的数据对象进行初始化。在*第3步*中，我们实现了**Grid**标记。我们在**<thead>**标签内渲染了**Header**值，这是表格标题通常出现的地方；对于表格主体，我们使用**foreach**循环遍历**Data**集合，并为每个元素渲染**Row**模板。
- en: In *step 4* , we created a routable **Offer** component to test our grid. As
    we expected interactivity, we declared that **Offer** rendered in **InteractiveWebAssembly**
    mode. We also leveraged the **Samples** object, so we exposed the required assembly
    with the **@using** directive. In *step 5* , we implemented an **Add()** placeholder
    method within the **@code** block of the **Offer** component to test the **Grid**
    component’s interactivity. In *step 6* , we started implementing the **Offer**
    markup. We embedded the **Grid** component and passed the **Samples.Tickets**
    array as the value of the **Data** parameter. In *step 7* , we declared the content
    of **Header** , which in our case is a set of columns representing **TicketViewModel**
    properties and an additional column where we placed action buttons. The real rendering
    magic happened in *step 8* . As the **Row** template expects a **TicketViewModel**
    object, we can access **TicketViewModel** properties in the markup with a **@context**
    directive and place them in table columns matching the **Header** declaration.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们创建了一个可路由的**Offer**组件来测试我们的网格。正如我们所期望的交互性，我们声明**Offer**以**InteractiveWebAssembly**模式渲染。我们还利用了**Samples**对象，因此我们使用**@using**指令公开了所需的程序集。在*第5步*中，我们在**Offer**组件的**@code**块内实现了一个**Add()**占位符方法来测试**Grid**组件的交互性。在*第6步*中，我们开始实现**Offer**标记。我们嵌入**Grid**组件，并将**Samples.Tickets**数组作为**Data**参数的值传递。在*第7步*中，我们声明了**Header**的内容，在我们的案例中，它是一组表示**TicketViewModel**属性的列以及一个放置操作按钮的额外列。真正的渲染魔法发生在*第8步*。由于**Row**模板期望一个**TicketViewModel**对象，我们可以在标记中使用**@context**指令访问**TicketViewModel**属性，并将它们放置在与**Header**声明匹配的表格列中。
- en: There’s more...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The power of the generic component lies in its agnosticism to the data type
    you’ll use. It simply knows how to construct a template, and where to place customizable
    content. It’s up to you to define markup to present data properties.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通用组件的力量在于其对数据类型的不可知性。它只知道如何构建模板，以及在哪里放置可定制的内容。定义用于呈现数据属性的标记取决于你。
- en: You might find yourself in need of nesting multiple generic components. To do
    so, you’ll have to define all required **RenderFragment** parameters. However,
    a key challenge here is going to be distinguishing each generic context. In that
    case, you must assign custom names to the context of each generic component using
    the **Context** parameter. This parameter is inherited automatically, streamlining
    the process and enhancing the readability of your code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现自己需要嵌套多个泛型组件。为此，您必须定义所有必需的 **RenderFragment** 参数。然而，这里的挑战将是区分每个泛型上下文。在这种情况下，您必须使用
    **Context** 参数为每个泛型组件的上下文分配自定义名称。此参数会自动继承，简化流程并提高代码的可读性。
- en: 'Even though our example doesn’t require nesting, we can still leverage the
    **Context** naming feature to enhance the code’s readability:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的示例不需要嵌套，我们仍然可以利用 **Context** 命名功能来提高代码的可读性：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember that the more intuitive your code is, the easier it is to navigate
    and update, especially when you’re working in team environments or returning to
    the code after some time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您的代码越直观，导航和更新就越容易，尤其是在团队环境中工作或一段时间后返回代码时。
- en: Decoupling components with DynamicComponent
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DynamicComponent 解耦组件
- en: '**Decoupling** is a design principle that enhances the flexibility and maintainability
    of your applications. It comes down to reducing direct dependencies between various
    parts of your code. Blazor offers an elegant solution for rendering components
    dynamically. In this recipe, we’ll explore the strategic use of **DynamicComponent**
    . It allows you to render components dynamically at runtime based on certain conditions
    or parameters. You’re not required to specify the component type in the markup
    at compile time explicitly. Heads up – most compilation validators won’t apply
    here.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**解耦** 是一种设计原则，它增强了您应用程序的灵活性和可维护性。这涉及到减少代码各部分之间的直接依赖。Blazor 提供了一种优雅的动态渲染组件的解决方案。在本配方中，我们将探讨
    **DynamicComponent** 的战略使用。它允许您根据某些条件或参数在运行时动态渲染组件。您不需要在编译时显式指定组件类型。请注意 - 大多数编译验证器在这里不适用。'
- en: Let’s implement the fully decoupled and dynamic prompting of success and failure
    notifications when the user adds a ticket to the cart, based on that ticket’s
    availability.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据该票的可用性，实现用户将票添加到购物车时完全解耦和动态提示成功和失败通知。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you dive into implementing **DynamicComponent** , do the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始实现 **DynamicComponent** 之前，请执行以下操作：
- en: Create a **Recipe09** directory – this will be your working directory
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Recipe09** 目录 - 这将是您的工作目录
- en: Copy the **Offer** and **Grid** components from the *Making components generic*
    recipe or copy their implementation from the **Chapter01** / **Recipe08** directory
    of this book’s GitHub repository
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *制作组件泛型* 配方复制 **Offer** 和 **Grid** 组件，或从本书 GitHub 存储库的 **Chapter01** / **Recipe08**
    目录复制它们的实现
- en: Copy the **Chapter01** / **Data** directory, which contains the **Samples**
    and **TicketViewModel** objects required in this recipe, next to the working directory
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Chapter01** / **Data** 目录复制到工作目录旁边，该目录包含本配方所需的 **Samples** 和 **TicketViewModel**
    对象
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to learn how to create more modular and independent components
    using **DynamicComponent** :'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用 **DynamicComponent** 创建更模块化和独立的组件：
- en: Add a new **Alerts** directory to your project.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中添加一个新的 **Alerts** 目录。
- en: 'Within the **Alerts** directory, create the **AddedToCart** and **SoldOut**
    components:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Alerts** 目录中创建 **AddedToCart** 和 **SoldOut** 组件：
- en: '![Figure 1.9: Project structure with newly added alert components and sample
    objects](img/B22020_01_9.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9：包含新添加的警报组件和示例对象的工程结构](img/B22020_01_9.jpg)'
- en: 'Figure 1.9: Project structure with newly added alert components and sample
    objects'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：包含新添加的警报组件和示例对象的工程结构
- en: 'Navigate to the **AddedToCart** component and add a successful alert markup:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **AddedToCart** 组件并添加一个成功警报标记：
- en: '[PRE35]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Navigate to the **SoldOut** component. Declare a **Tariff** parameter and add
    a danger alert markup by using the **Tariff** value:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **SoldOut** 组件。声明一个 **Tariff** 参数，并使用 **Tariff** 值添加一个危险警报标记：
- en: '[PRE36]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Navigate to the **Offer** component and, in the **@code** block, declare additional
    **AlertType** and **AlertParams** variables:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **Offer** 组件，在 **@code** 块中声明额外的 **AlertType** 和 **AlertParams** 变量：
- en: '[PRE37]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the **@code** block of **Offer** , replace the **Add()** method’s implementation
    to validate ticket availability and display a designated notification:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Offer** 的 **@code** 块中，替换 **Add()** 方法的实现以验证票务可用性并显示指定的通知：
- en: '[PRE38]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the **Offer** markup, below the existing **Grid** instance, add a conditional
    rendering of **DynamicComponent** while leveraging the resolved values of the
    **AlertType** and **AlertParams** variables:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Offer** 标记中，在现有的 **Grid** 实例下方，添加对 **DynamicComponent** 的条件渲染，同时利用已解析的 **AlertType**
    和 **AlertParams** 变量的值：
- en: '[PRE39]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we added an **Alerts** directory where we could place different
    alert components. In *step 2* , we created the **AddedToCart** and **SoldOut**
    components, representing success and failure notifications when adding a ticket
    to the cart. In *step 3* , we focused on implementing the **AddedToCart** component,
    which renders an **alert-success** class with an **Added to cart successfully**
    message. In *step 4* , we implemented the **SoldOut** component, which renders
    an **alert-danger** class and renders the sold-out ticket tariff.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们添加了一个 **Alerts** 目录，我们可以将不同的警报组件放置在那里。在 *步骤 2* 中，我们创建了 **AddedToCart**
    和 **SoldOut** 组件，分别代表将票务添加到购物车时的成功和失败通知。在 *步骤 3* 中，我们专注于实现 **AddedToCart** 组件，它渲染一个带有
    **Added to cart successfully** 消息的 **alert-success** 类。在 *步骤 4* 中，我们实现了 **SoldOut**
    组件，它渲染一个 **alert-danger** 类，并渲染已售罄的票务价格。
- en: In *step 5* , we added two critical variables that **DynamicComponent** leverages.
    The first is **AlertType** , of the **Type** type, which determines the type of
    component to render. The second is **AlertParams** , a dictionary that allows
    us to dynamically pass parameter values to the loaded component. In *step 6* ,
    we resolved the state of the requested ticket. We checked seat availability and
    decided whether to use the **SoldOut** or **AddedToCart** component. When seats
    are unavailable, we conditionally add the **Tariff** parameter to our dynamic
    collection of parameters. Finally, in *step 7* , we embedded the **DynamicComponent**
    component in the **Offer** markup. If the **AlertType** value is unset, we skip
    rendering it. Otherwise, we append the dynamically resolved markup.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们添加了两个对 **DynamicComponent** 至关重要的变量。第一个是 **AlertType**，它是 **Type**
    类型，它决定了要渲染的组件类型。第二个是 **AlertParams**，这是一个字典，允许我们动态传递参数值到加载的组件。在 *步骤 6* 中，我们解析了请求的票务状态。我们检查了座位可用性，并决定是否使用
    **SoldOut** 或 **AddedToCart** 组件。当座位不可用时，我们条件性地将 **Tariff** 参数添加到我们的动态参数集合中。最后，在
    *步骤 7* 中，我们在 **Offer** 标记中嵌入了 **DynamicComponent** 组件。如果 **AlertType** 值未设置，我们跳过渲染。否则，我们附加动态解析的标记。
- en: Notice that we utilized the built-in **typeof()** and **nameof()** functions
    to declare the type and parameters of the current notification. If you want or
    need to take decoupling even further, you can initialize them purely from **string**
    variables. That’s especially powerful when you’re working in architecture such
    as **micro-frontends** .
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了内置的 **typeof()** 和 **nameof()** 函数来声明当前通知的类型和参数。如果你想或需要进一步解耦，你可以完全从
    **string** 变量中初始化它们。当你在一个如 **micro-frontends** 这样的架构中工作时，这尤其强大。
