<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>15 Object Mappers, Aggregate Services, and Façade</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="16">15 Object Mappers, Aggregate Services, and Façade</h1>

<h2 data-number="16.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file93.png" style="width:10em"/></p>
<p>In this chapter, we explore object mapping. As we saw in the previous chapter, working with layers often leads to copying models from one layer to another. Object mappers solve that problem. We first look at manually implementing an object mapper. Then, we improve our design by regrouping the mappers under a mapper service, exploring the Aggregate Services, and Mapping façade patterns along the way. Finally, we replace that manual work with two open-source tools that helps us generate business value instead of writing mapping code.In this chapter, we cover the following topics:</p>
<ul>
<li>Overview of object mapping and object mappers</li>
<li>Implementing a simple object mapper</li>
<li>Exploring the too-many-dependencies code smell</li>
<li>Exploring the Aggregate Services pattern</li>
<li>Implementing a Mapping Façade by leveraging the Façade pattern</li>
<li>Using the Service Locator pattern to create a flexible Mapping Service in front of our mappers</li>
<li>Using AutoMapper to map an object to another, replacing our homebrewed code</li>
<li>Using Mapperly instead of AutoMapper</li>
</ul>


<h2 data-number="16.2">Object mapper</h2>
<p>What is object mapping? In a nutshell, it is the action of copying the value of an object’s properties into the properties of another object. But sometimes, properties’ names do not match; an object hierarchy may need to be flattened and transformed. As we saw in the previous chapter, each layer can own its own model, which can be a good thing, but that comes at the price of copying objects from one layer to another. We can also share models between layers, but even then, we usually need to map one object into another. Even if it’s just to map your models to <strong>Data Transfer Objects</strong> (<strong>DTOs</strong>), it is almost inevitable.</p>
<blockquote>
<p>Remember that DTOs define our API’s contract. Independent contract classes help maintain the system, making us choose when to modify them. If you skip that part, each time you change your model, it automatically updates your endpoint’s contract, possibly breaking some clients. Moreover, if you input your model directly, a malicious user could try to bind the values of properties that they should not, leading to potential security issues (known as <strong>over-posting</strong> or <strong>over-posting attacks</strong>). Having good data exchange contracts is one of the keys to designing robust systems.</p>
</blockquote>
<p>In the previous projects, the mapping logic was hardcoded, sometimes duplicated and adding additional responsibilities to the class doing the mapping. In this chapter, we extract the mapping logic into object mappers to fix that issue.</p>

<h3 data-number="16.2.1">Goal</h3>
<p>The object mapper’s goal is to copy the value of an object’s properties into the properties of another object. It encapsulates the mapping logic away from where the mapping takes place. The mapper is also responsible for transforming the values from the original format to the destination format when both objects do not follow the same structure.</p>


<h3 data-number="16.2.2">Design</h3>
<p>We can design object mappers in many ways. Here is the most basic object mapper design:</p>
<figure>
<img alt="Figure 15.1: Basic design of the object mapper" src="img/file94.png"/><figcaption aria-hidden="true">Figure 15.1: Basic design of the object mapper</figcaption>
</figure>
<p>In the diagram, the <strong>Consumer</strong> uses the <code>IMapper</code> interface to map an object of <code>Type1</code> to an object of <code>Type2</code>. That’s not very reusable, but it illustrates the concept. By using the power of <strong>generics</strong>, we can upgrade that simple design to this more reusable version:</p>
<figure>
<img alt="Figure 15.2: Generic object mapper design" src="img/file95.png"/><figcaption aria-hidden="true">Figure 15.2: Generic object mapper design</figcaption>
</figure>
<p>This design lets us map any <code>TSource</code> to any <code>TDestination</code> by implementing the <code>IMapper&lt;TSource, TDestination&gt;</code> interface once per mapping rule. One class could also implement multiple mapping rules. For example, we could implement the mapping of <code>Type1</code> to <code>Type2</code> and <code>Type2</code> to <code>Type1</code> in the same class (a bidirectional mapper).Another way would be to use the following design and create an <code>IMapper</code> interface with a single method that handles all of the application’s mapping:</p>
<figure>
<img alt="Figure 15.3: Object mapping using a single IMapper as the entry point" src="img/file96.png"/><figcaption aria-hidden="true">Figure 15.3: Object mapping using a single IMapper as the entry point</figcaption>
</figure>
<p>The biggest advantage of this last design is the ease of use. We always inject a single <code>IMapper</code> instead of one <code>IMapper&lt;TSource, TDestination&gt;</code> per type of mapping, which reduces the number of dependencies and the complexity of consuming such a mapper.You can implement object mapping in any way your imagination allows, but the critical part is that the mapper is responsible for mapping an object to another. A mapper should avoid complex processes, such as loading data from a database and whatnot. It should copy the values of one object into another: that’s it. Think about the <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>) here: the class must have a single reason to change, and since it’s an object mapper, that reason should be object mapping.Let’s jump into some code to explore the designs in more depth with each project.</p>


<h3 data-number="16.2.3">Project – Mapper</h3>
<p>This project is an updated version of the Clean Architecture code from the previous chapter. The project aims to demonstrate the design’s versatility of encapsulating entity mapping logic into mapper classes, moving that logic away from the consumers. Of course, the project is again focused on the use case at hand, making learning the topics easier.First, we need an interface that resides in the <code>Core</code> project so the other projects can implement the mapping they need. Let’s adopt the second design that we saw:</p>
<div><pre><code>namespace Core.Mappers;
public interface IMapper&lt;TSource, TDestination&gt;
{
    TDestination Map(TSource entity);
}</code></pre>
</div>
<p>With this interface, we can start by creating the data mappers. But first, let’s start by creating record classes instead of anonymous types to name the DTOs returned by the endpoints. Here are all the DTOs (from the <code>Program.cs</code> file):</p>
<div><pre><code>// Input stock DTOs
public record class AddStocksCommand(int Amount);
public record class RemoveStocksCommand(int Amount);
// Output stock DTO
public record class StockLevel(int QuantityInStock);
// Output "read all products" DTO
public record class ProductDetails(int Id, string Name, int QuantityInStock);
// Output Exceptions DTO
public record class ProductNotFound(int ProductId, string Message);
public record class NotEnoughStock(int AmountToRemove, int QuantityInStock, string Message);</code></pre>
</div>
<p>Three of the four output DTOs need mapping:</p>
<ul>
<li><code>Product</code> to <code>ProductDetails</code></li>
<li><code>ProductNotFoundException</code> to <code>ProductNotFound</code></li>
<li><code>NotEnoughStockException</code> to <code>NotEnoughStock</code></li>
</ul>
<blockquote>
<p>Why not map the <code>StockLevel</code> DTO? In our case, the <code>StockService</code> returns an <code>int</code> when we add or remove stocks, so converting a primitive value like an <code>int</code> into a <code>StockLevel</code> object does not require an object mapper. Moreover, creating such an object mapper adds no value and makes the code more complex. If the service had returned an object, creating a mapper that maps an object to <code>StockLevel</code> would have made more sense.</p>
</blockquote>
<p>Let’s start with the product mapper (from the <code>Program.cs</code> file):</p>
<div><pre><code>public class ProductMapper : IMapper&lt;Product, ProductDetails&gt;
{
    public ProductDetails Map(Product entity)
        =&gt; new(entity.Id ?? default, entity.Name, entity.QuantityInStock);
}</code></pre>
</div>
<p>The preceding code is straightforward; the <code>ProductMapper</code> class implements the <code>IMapper&lt;Product,</code> <code>ProductDetails&gt;</code> interface. The <code>Map</code> method returns a <code>ProductDetails</code> instance. The highlighted code ensures the <code>Id</code> property is not <code>null</code>, which should not happen. We could also add a guard clause to ensure the <code>Id</code> property is not <code>null</code>.All in all, the <code>Map</code> method takes a <code>Product</code> as input and outputs a <code>ProductDetails</code> instance containing the same values.Then let’s continue with the exception mappers (from the <code>Program.cs</code> file):</p>
<div><pre><code>public class ExceptionsMapper : IMapper&lt;ProductNotFoundException, ProductNotFound&gt;, IMapper&lt;NotEnoughStockException, NotEnoughStock&gt;
{
    public ProductNotFound Map(ProductNotFoundException exception)
        =&gt; new(exception.ProductId, exception.Message);
    public NotEnoughStock Map(NotEnoughStockException exception)
        =&gt; new(exception.AmountToRemove, exception.QuantityInStock, exception.Message);
}</code></pre>
</div>
<p>Compared to the <code>ProductMapper</code> class, the <code>ExceptionsMapper</code> class implements the two remaining use cases by implementing the <code>IMapper</code> interface twice. The two <code>Map</code> methods handle mapping an exception to its DTO, leading to one class being responsible for mapping exceptions to DTOs.Let’s look at the <code>products</code> endpoint (original value from the <code>clean-architecture</code> project of <em>Chapter 14</em>, <em>Layering and Clean Architecture</em>):</p>
<div><pre><code>app.MapGet("/products", async (
    IProductRepository productRepository, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; new
    {
        p.Id,
        p.Name,
        p.QuantityInStock
    });
});</code></pre>
</div>
<p>Before analyzing the code, let’s look at the updated version (from the <code>Program.cs</code> file):</p>
<div><pre><code>app.MapGet("/products", async (
    IProductRepository productRepository, 
    IMapper&lt;Product, ProductDetails&gt; mapper, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; mapper.Map(p));
});</code></pre>
</div>
<p>In the preceding code, the request delegate uses the mapper to replace the copy logic (the highlighted lines of the original code). That simplifies the handler, moving the mapping responsibility into mapper objects instead (highlighted in the preceding code)—one more step toward the SRP.Let’s skip the add stocks endpoint since it is very similar to the remove stocks endpoint but simpler, and let’s focus on the later (original value from the <code>clean-architecture</code> project of <em>Chapter 14</em>, <em>Layering and Clean Architecture</em>):</p>
<div><pre><code>app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(new
        {
            ex.Message,
            ex.AmountToRemove,
            ex.QuantityInStock
        });
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(new
        {
            ex.Message,
            productId,
        });
    }
});</code></pre>
</div>
<p>Once again, before analyzing the code, let’s look at the updated version (from the <code>Program.cs</code> file):</p>
<div><pre><code>app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    IMapper&lt;ProductNotFoundException, ProductNotFound&gt; notFoundMapper, 
    IMapper&lt;NotEnoughStockException, NotEnoughStock&gt; notEnoughStockMapper, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(notEnoughStockMapper.Map(ex));
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(notFoundMapper.Map(ex));
    }
});</code></pre>
</div>
<p>The same thing happened for this request delegate, but we injected two mappers instead of just one. We moved the mapping logic from inline using an anonymous type to the mapper objects. Nevertheless, a code smell is emerging here; can you smell it? We will investigate this after we are done with this project; meanwhile, keep thinking about the number of injected dependencies.Now that the delegates depend on interfaces with object mappers encapsulating the mapping responsibility, we must configure the composition root and bind the mapper implementations to the <code>IMapper&lt;TSource, TDestination&gt;</code> interface. The service bindings look like this:</p>
<div><pre><code>.AddSingleton&lt;IMapper&lt;Product, ProductDetails&gt;, ProductMapper&gt;()
.AddSingleton&lt;IMapper&lt;ProductNotFoundException, ProductNotFound&gt;, ExceptionsMapper&gt;()
.AddSingleton&lt;IMapper&lt;NotEnoughStockException, NotEnoughStock&gt;, ExceptionsMapper&gt;()</code></pre>
</div>
<p>Since <code>ExceptionsMapper</code> implements two interfaces, we bind both to that class. That is one of the beauties of abstractions; the remove stocks delegate asks for two mappers but receives an instance of <code>ExceptionsMapper</code> twice without even knowing it.We could also register the classes so the same instance is injected twice, like this:</p>
<div><pre><code>.AddSingleton&lt;ExceptionsMapper&gt;()
.AddSingleton&lt;IMapper&lt;ProductNotFoundException, ProductNotFound&gt;, ExceptionsMapper&gt;(sp =&gt; sp.GetRequiredService&lt;ExceptionsMapper&gt;())
.AddSingleton&lt;IMapper&lt;NotEnoughStockException, NotEnoughStock&gt;, ExceptionsMapper&gt;(sp =&gt; sp.GetRequiredService&lt;ExceptionsMapper&gt;())</code></pre>
</div>
<blockquote>
<p>Yes, I did that double registration of the same class on purpose. That proves we can compose an application as we want without impacting the <strong>consumers</strong>. That is done by depending on abstractions instead of implementations, as per the <strong>Dependency Inversion Principle</strong> (<strong>DIP</strong>—the “D” in SOLID). Moreover, the division into small interfaces, as per the <strong>Interface Segregation Principle</strong> (<strong>ISP</strong>—the “I” in SOLID), makes that kind of scenario possible. Finally, we can glue all those pieces together using the power of <strong>Dependency Injection</strong> (<strong>DI</strong>).</p>
</blockquote>


<h3 data-number="16.2.4">Conclusion</h3>
<p>Before exploring more alternatives, let’s see how object mapping can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: Using mapper objects helps to separate the responsibility of mapping types from the consumers, making it easier to maintain and refactor the mapping logic.</li>
<li><strong>O</strong>: By injecting mappers, we can change the mapping logic without changing the code of their consumers.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: We explored different designs that provide a small mapper interface that reduces the dependencies between the components.</li>
<li><strong>D</strong>: The consumers depend only on abstractions, moving the implementation’s binding to the composition root and inverting the dependency flow.</li>
</ul>
<p>Now that we’ve explored how to extract and use mappers, let’s look at the code smell that emerged.</p>



<h2 data-number="16.3">Code smell – Too many dependencies</h2>
<p>Using this kind of mapping could become tedious in the long run, and we would rapidly see scenarios such as injecting three or more mappers into a single request delegate or controller. The consumer would likely already have other dependencies, leading to four or more.That should raise the following flag:</p>
<ul>
<li>Does the class do too much and have too many responsibilities?</li>
</ul>
<p>In this case, the fine-grained <code>IMapper</code> interface pollutes our request delegates with tons of dependencies on mappers, which is not ideal and makes our code harder to read.</p>
<blockquote>
<p>The preferred solution would be to move the exception-handling responsibility away from the delegates or controllers, leveraging a middleware or an exception filter, for example. This tactic would move boilerplate code away from the endpoints.</p>
<blockquote>
<p>Since we are talking about mappers, we will explore more object mapping concepts to help us with this problem instead, which applies to many use cases.</p>
</blockquote>
</blockquote>
<p>As a rule of thumb, you want to <strong>limit the number of dependencies to three or less</strong>. Over that number, ask yourself if there is a problem with that class; does it have too many responsibilities? Having more than three dependencies is not inherently wrong; it just indicates that you should investigate the design. If nothing is wrong, keep it at 4 or 5, or 10; it does not matter. If you find a way to reduce the number of dependencies or that the class actually does too many things refactor the code.If you don’t like having that many dependencies, you could extract service aggregates that encapsulate two or more dependencies and inject that aggregate instead. Beware that moving your dependencies around does not fix anything; it just moves the problem elsewhere if there was a problem in the first place. Using aggregates could increase the readability of the code, though.</p>
<blockquote>
<p>Instead of blindly moving dependencies around, analyze the problem to see if you could create classes with actual logic that could do something useful to reduce the number of dependencies.</p>
</blockquote>
<p>Next, let’s have a quick look at aggregating services.</p>


<h2 data-number="16.4">Pattern – Aggregate Services</h2>
<p>Even if the Aggregate Services pattern is not a magic problem-solving pattern, it is a viable alternative to injecting too many dependencies into another class. Its goal is to aggregate many dependencies in a class to reduce the number of injected services in other classes, grouping dependencies together. The way to manage aggregates would be to group them by concern or responsibility. Putting a bunch of services in another service just for the sake of it is rarely the way to go; aim for cohesion.</p>
<blockquote>
<p>Creating one or more aggregation services that expose other services can be a way to implement service discovery in a project. Like always, analyze if the problem is not elsewhere first. Loading a service that exposes other services can be handy. However, this may create issues, so don’t put everything into an aggregate firsthand either.</p>
</blockquote>
<p>Here is an example of a mapping aggregate to reduce the number of dependencies of a <strong>Create-Read-Update-Delete</strong> (<strong>CRUD</strong>) controller that allows the creation, updating, deletion, and reading of one, many, or all products. Here’s the aggregate service code and a usage example:</p>
<div><pre><code>public interface IProductMappers
{
    IMapper&lt;Product, ProductDetails&gt; EntityToDto { get; }
    IMapper&lt;InsertProduct, Product&gt; InsertDtoToEntity { get; }
    IMapper&lt;UpdateProduct, Product&gt; UpdateDtoToEntity { get; }
}
public class ProductMappers : IProductMappers
{
    public ProductMappers(IMapper&lt;Product, ProductDetails&gt; entityToDto, IMapper&lt;InsertProduct, Product&gt; insertDtoToEntity, IMapper&lt;UpdateProduct, Product&gt; updateDtoToEntity)
    {
        EntityToDto = entityToDto ?? throw new ArgumentNullException(nameof(entityToDto));
        InsertDtoToEntity = insertDtoToEntity ?? throw new ArgumentNullException(nameof(insertDtoToEntity));
        UpdateDtoToEntity = updateDtoToEntity ?? throw new ArgumentNullException(nameof(updateDtoToEntity));
    }
    public IMapper&lt;Product, ProductDetails&gt; EntityToDto { get; }
    public IMapper&lt;InsertProduct, Product&gt; InsertDtoToEntity { get; }
    public IMapper&lt;UpdateProduct, Product&gt; UpdateDtoToEntity { get; }
}
public class ProductsController : ControllerBase
{
    private readonly IProductMappers _mapper;
    // Constructor injection, other methods, routing attributes, ...
    public ProductDetails GetProductById(int id)
    {
        Product product = ...; // Fetch a product by id
        ProductDetails dto = _mapper.EntityToDto.Map(product);
        return dto;
    }
}</code></pre>
</div>
<p>The <code>IProductMappers</code> aggregate could be logical in this example as it groups the mappers used by the <code>ProductsController</code> class under its umbrella. It is responsible for mapping <code>ProductsController</code>-related domain objects to DTOs and vice versa while the controller gives up this responsibility.You can create aggregate services with anything, not just mappers. That’s a fairly common pattern in DI-heavy applications (which can also point to some design flaws).Now that we’ve explored the Aggregate Services pattern, let’s explore how to make a mapping façade instead.</p>


<h2 data-number="16.5">Pattern – Mapping Façade</h2>
<p>We studied façades already; here, we explore another way to organize our many mappers by leveraging that design pattern.Instead of what we just did, we will create a mapping façade to replace our aggregate services. The code consuming the façade will be more elegant because it uses the <code>Map</code> methods directly instead of the properties. The responsibility of the façade is the same as the aggregate, but it implements the interfaces instead of exposing them as properties.Let’s look at the code:</p>
<div><pre><code>public interface IProductMapperService : 
    IMapper&lt;Product, ProductDetails&gt;, 
    IMapper&lt;InsertProduct, Product&gt;, 
    IMapper&lt;UpdateProduct, Product&gt;
{
}
public class ProductMapperService : IProductMapperService
{
    private readonly IMapper&lt;Product, ProductDetails&gt; _entityToDto;
    private readonly IMapper&lt;InsertProduct, Product&gt; _insertDtoToEntity;
    private readonly IMapper&lt;UpdateProduct, Product&gt; _updateDtoToEntity;
    // Omitted constructor injection code
    public ProductDetails Map(Product entity)
    {
        return _entityToDto.Map(entity);
    }
    public Product Map(InsertProduct dto)
    {
        return _insertDtoToEntity.Map(dto);
    }
    public Product Map(UpdateProduct dto)
    {
        return _updateDtoToEntity.Map(dto);
    }
}</code></pre>
</div>
<p>In the preceding code, the <code>ProductMapperService</code> class implements the <code>IMapper</code> interfaces through the <code>IProductMapperService</code> interface and delegates the mapping logic to each injected mapper: a façade wrapping multiple individual mappers. Next, we look at the <code>ProductsController</code> that consumes the façade:</p>
<div><pre><code>public class ProductsController : ControllerBase
{
    private readonly IProductMapperService _mapper;
    // Omitted constructor injection, other methods, routing attributes, ...
    public ProductDetails GetProductById(int id)
    {
        Product product = ...; // Fetch a product by id
        ProductDetails dto = _mapper.Map(product);
        return dto;
    }
}</code></pre>
</div>
<p>From the consumer standpoint (the <code>ProductsController</code> class), I find it cleaner to write<code>_mapper.Map(...)</code> instead of <code>_mapper.SomeMapper.Map(...)</code>. The consumer does not want to know what mapper is doing what mapping; it only wants to map what needs mapping. If we compare the Mapping Façade with the Aggregate Services of the previous example, the façade takes the responsibility of choosing the mapper and moves it away from the consumer. This design distributes the responsibilities between the classes better.This was an excellent opportunity to review the Façade design pattern. Nonetheless, now that we've gone through multiple mapping options and examined the issue of having too many dependencies, it's time to move forward on our object mapping adventure with an enhanced version of our mapping façade.</p>


<h2 data-number="16.6">Project – Mapping service</h2>
<p>The goal is to simplify the implementation of the Mapper façade with a universal interface. To achieve this, we are implementing the diagram shown in <em>Figure 13.3</em>. Here’s a reminder:</p>
<figure>
<img alt="Figure 15.4: Object mapping using a single IMapper interface" src="img/file97.png"/><figcaption aria-hidden="true">Figure 15.4: Object mapping using a single IMapper interface</figcaption>
</figure>
<p>Instead of naming the interface <code>IMapper</code>, we will use the name <code>IMappingService</code>. This name is more suitable because it is not mapping anything; it is a dispatcher servicing the mapping request to the right mapper. Let’s take a look:</p>
<div><pre><code>namespace Core.Mappers;
public interface IMappingService
{
    TDestination Map&lt;TSource, TDestination&gt;(TSource entity);
}</code></pre>
</div>
<p>That interface is self-explanatory; it maps any <code>TSource</code> to any <code>TDestination</code>.On the implementation side, we are leveraging the <strong>Service Locator</strong> pattern, so I called the class <code>ServiceLocatorMappingService</code>:</p>
<div><pre><code>namespace Core.Mappers;
public class ServiceLocatorMappingService : IMappingService
{
    private readonly IServiceProvider _serviceProvider;
    public ServiceLocatorMappingService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
    }
    public TDestination Map&lt;TSource, TDestination&gt;(TSource entity)
    {
        var mapper = _serviceProvider.GetService&lt;IMapper&lt;TSource, TDestination&gt;&gt;();
        if (mapper == null)
        {
            throw new MapperNotFoundException(typeof(TSource), typeof(TDestination));
        }
        return mapper.Map(entity);
    }
}</code></pre>
</div>
<p>The logic is simple:</p>
<ul>
<li>Find the appropriate <code>IMapper&lt;TSource, TDestination&gt;</code> service, then map the entity with it</li>
<li>If you don’t find any, throw a <code>MapperNotFoundException</code></li>
</ul>
<p>The key to that design is to register the mappers with the IoC container instead of the service itself. Then we use the mappers without knowing every single one of them, like in the previous example. The <code>ServiceLocatorMappingService</code> class doesn’t know any mappers; it just dynamically asks for one whenever needed.</p>
<blockquote>
<p>The Service Locator pattern should not be part of the application’s code. However, it can be helpful at times. For example, we are not trying to cheat DI in this case. On the contrary, we are leveraging its power.</p>
<blockquote>
<p>Using a service locator is wrong when acquiring dependencies in a way that removes the possibility of controlling the program’s composition from the composition root, which breaks the IoC principle.</p>
</blockquote>
<blockquote>
<p>In this case, we load mappers dynamically from the IoC container, limiting the container’s ability to control what to inject which is acceptable since it has little to no negative impact on the program’s maintainability, flexibility, and reliability. For example, we can replace the <code>ServiceLocatorMappingService</code> implementation with another class without affecting the <code>IMappingService</code> interface consumers.</p>
</blockquote>
</blockquote>
<p>Now, we can inject that service everywhere we need mapping and use it directly. We already registered the mappers, so we only need to bind the <code>IMappingService</code> to its <code>ServiceLocatorMappingService</code> implementation and update the consumers. Here’s the DI binding:</p>
<div><pre><code>.AddSingleton&lt;IMappingService, ServiceLocatorMappingService&gt;();</code></pre>
</div>
<p>If we look at the new implementation of the remove stocks endpoint, we can see we reduced the number of mapper dependencies to one:</p>
<div><pre><code>app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    IMappingService mapper, 
    CancellationToken cancellationToken) =&gt; {
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(mapper.Map&lt;NotEnoughStockException, NotEnoughStock&gt;(ex));
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(mapper.Map&lt;ProductNotFoundException, ProductNotFound&gt;(ex));
    }
});</code></pre>
</div>
<p>The preceding code is similar to the previous sample, but we replaced the mappers with the new service (the highlighted lines). And that’s it; we now have a universal mapping service that delegates the mapping to any mapper we register with the IoC container.</p>
<blockquote>
<p>Even if you are not likely to implement object mappers manually often, exploring and revisiting those patterns and a code smell is very good and will help you craft better software.</p>
</blockquote>
<p>This is not the end of our object mapping exploration. We have two tools to explore, starting with AutoMapper, which does all the object mapping work for us.</p>


<h2 data-number="16.7">Project – AutoMapper</h2>
<p>We just covered different ways to implement object mapping, but here we leverage an open-source tool named AutoMapper that does it for us instead of implementing our own.Why bother learning all of that if a tool already does it? There are a few reasons to do so:</p>
<ul>
<li>It is important to understand the concepts; you don’t always need a full-fledged tool like AutoMapper.</li>
<li>It allowed us to cover multiple patterns we can use in other contexts and apply them to components with different responsibilities. So, all in all, you should have learned multiple new techniques during this object mapping progression.</li>
<li>Lastly, we dug deeper into applying the SOLID principles to write better programs.</li>
</ul>
<p>The AutoMapper project is also a copy of the Clean Architecture sample. The biggest difference between this project and the others is that we don’t need to define any interface because AutoMapper exposes an <code>IMapper</code> interface with all the methods we need and more.To install AutoMapper, you can install the <code>AutoMapper</code> NuGet package using the CLI (<code>dotnet add package AutoMapper</code>), Visual Studio’s NuGet package manager, or by updating your <code>.csproj</code> manually.The best way to define our mappers is by using AutoMapper’s profile mechanism. A profile is a simple class that inherits from <code>AutoMapper.Profile</code> and contains maps from one object to another. We use profiles to group mappers together, but in our case, with only three maps, I decided to create a single <code>WebProfile</code> class.Finally, instead of manually registering our profiles, we can scan one or more assemblies to load all of the profiles into AutoMapper by using the <code>AutoMapper.Extensions.Microsoft.DependencyInjection</code> package.</p>
<blockquote>
<p>When installing the <code>AutoMapper.Extensions.Microsoft.DependencyInjection</code> package you don’t have to load the <code>AutoMapper</code> package.</p>
</blockquote>
<p>There is more to AutoMapper than what we cover here, but it has enough resources online, including the official documentation, to help you dig deeper into the tool. The goal of this project is to do basic object mapping.In the <em>Web</em> project, we must create the following maps:</p>
<ul>
<li>Map <code>Product</code> to <code>ProductDetails</code></li>
<li>Map <code>NotEnoughStockException</code> to <code>NotEnoughStock</code></li>
<li>Map <code>ProductNotFoundException</code> to <code>ProductNotFound</code></li>
</ul>
<p>To do that, we create the following <code>WebProfile</code> class (in the <code>Program.cs</code> file, but could live anywhere):</p>
<div><pre><code>using AutoMapper;
public class WebProfile : Profile
{
    public WebProfile()
    {
        CreateMap&lt;Product, ProductDetails&gt;();
        CreateMap&lt;NotEnoughStockException, NotEnoughStock&gt;();
        CreateMap&lt;ProductNotFoundException, ProductNotFound&gt;();
    }
}</code></pre>
</div>
<p>A profile in AutoMapper is nothing more than a class where you create maps in the constructor. The <code>Profile</code> class adds the required methods for you to do that, such as the <code>CreateMap</code> method. What does that do?Invoking the method <code>CreateMap&lt;Product, ProductDetails&gt;()</code> tells AutoMapper to register a mapper that maps <code>Product</code> to <code>ProductDetails</code>. The other two <code>CreateMap</code> calls are doing the same for the other two maps. That’s all we need for now because AutoMapper maps properties using conventions, and both our model and DTO classes have the same sets of properties with the same names.</p>
<blockquote>
<p>In the preceding examples, we defined some mappers in the <code>Core</code> layer. In this example, we rely on a library, so it is even more important to consider the dependency flow. We are mapping objects only in the <code>Web</code> layer, so there is no need to put the dependency on AutoMapper in the <code>Core</code> layer. Remember that all layers depend directly or indirectly on <code>Core</code>, so having a dependency on AutoMapper in that layer means all layers would also depend on it.</p>
<blockquote>
<p>Therefore, in this example, we created the <code>WebProfile</code> class in the <code>Web</code> layer instead, limiting the dependency on AutoMapper to only that layer. Having only the <code>Web</code> layer depend on AutoMapper allows all outer layers (if we were to add more) to control how they do object mapping, giving more independence to each layer. It is also a best practice to limit object mapping as much as possible.</p>
</blockquote>
<blockquote>
<p>I’ve added a link to <em>AutoMapper Usage Guidelines</em> in the <em>Further reading</em> section at the end of the chapter.</p>
</blockquote>
</blockquote>
<p>Now that we have one profile, we need to register it with the IoC container, but we don’t have to do this by hand; we can scan for profiles from the composition root by using one of the <code>AddAutoMapper</code> extension methods to scan one or more assemblies:</p>
<div><pre><code>builder.Services.AddAutoMapper(typeof(WebProfile).Assembly);</code></pre>
</div>
<p>The preceding method accepts a <code>params Assembly[] assemblies</code> argument, meaning we can pass multiple <code>Assembly</code> instances to it.</p>
<blockquote>
<p>That <code>AddAutoMapper</code> extension method comes from the <code>AutoMapper.Extensions.Microsoft.DependencyInjection</code> package.</p>
</blockquote>
<p>Since we have only one profile in one assembly, we leverage that class to access the assembly by passing the <code>typeof(WebProfile).Assembly</code> argument to the <code>AddAutoMapper</code> method. From there, AutoMapper scans for profiles in that assembly and finds the <code>WebProfile</code> class. If there were more than one, it would register all it finds.The beauty of scanning for types like this is that once you register AutoMapper with the IoC container, you can add profiles in any registered assemblies, and they get loaded automatically; there’s no need to do anything else afterward but to write useful code. Scanning assemblies also encourages composition by convention, making it easier to maintain in the long run. The downside of assembly scanning is that debugging can be hard when something is not registered because the registration process is less explicit.Now that we’ve created and registered the profiles with the IoC container, it is time to use AutoMapper. Let’s look at the three endpoints we created initially:</p>
<div><pre><code>app.MapGet("/products", async (
    IProductRepository productRepository, 
    IMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; mapper.Map&lt;Product, ProductDetails&gt;(p));
});
app.MapPost("/products/{productId:int}/add-stocks", async (
    int productId, 
    AddStocksCommand command, 
    StockService stockService, 
    IMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.AddStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(mapper.Map&lt;ProductNotFound&gt;(ex));
    }
});
app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    IMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(mapper.Map&lt;NotEnoughStock&gt;(ex));
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(mapper.Map&lt;ProductNotFound&gt;(ex));
    }
});</code></pre>
</div>
<p>The preceding code shows how similar it is to use AutoMapper to the other options. We inject an <code>IMapper</code> interface, then use it to map the entities. Instead of explicitly specifying both <code>TSource</code> and <code>TDestination</code> like in the previous example, when using AutoMapper, we must specify only the <code>TDestination</code> generic parameter, reducing the code's complexity.</p>
<blockquote>
<p>Suppose you are using AutoMapper on an <code>IQueryable</code> collection returned by EF Core. In that case, you should use the <code>ProjectTo</code> method, which limits the number of fields that EF will query to those you need. In our case, that changes nothing because we need the whole entity.</p>
<blockquote>
<p>Here is an example that fetches all products from EF Core and projects them to <code>ProductDto</code> instances:</p>
</blockquote>
</blockquote>
<pre><code>public IEnumerable&lt;ProductDto&gt; GetAllProducts()
{
    return _mapper.ProjectTo&lt;ProductDto&gt;(_db.Products);
}</code></pre>
<blockquote>
<p>Performance-wise, this is the recommended way to use AutoMapper with EF Core.</p>
</blockquote>
<p>One last yet significant detail is that we can assert whether our mapper configurations are valid when the application starts. This does not identify missing mappers but validates that the registered ones are configured correctly. The recommended way of doing this is in a unit test. To make this happen, I made the autogenerated <code>Program</code> class public by adding the following line at the end:</p>
<div><pre><code>public partial class Program { }</code></pre>
</div>
<p>Then I created a test project named <code>Web.Tests</code> that contain the following code:</p>
<div><pre><code>namespace Web;
public class StartupTest
{
    [Fact]
    public async Task AutoMapper_configuration_is_valid()
    {
        // Arrange
        await using var application = new AutoMapperAppWebApplication();
        var mapper = application.Services.GetRequiredService&lt;IMapper&gt;();
        mapper.ConfigurationProvider.AssertConfigurationIsValid();
    }
}
internal class AutoMapperAppWebApplication : WebApplicationFactory&lt;Program&gt;{}</code></pre>
</div>
<p>In the preceding code, we validate that all the AutoMapper maps are valid. To make the test fail, you can uncomment the following line of the <code>WebProfile</code> class:</p>
<div><pre><code>CreateMap&lt;NotEnoughStockException, Product&gt;();</code></pre>
</div>
<p>The <code>AutoMapperAppWebApplication</code> class is there to centralize the initialization of the test cases when there is more than one.In the test project, I created a second test case ensuring the <code>products</code> endpoint is reachable. For both tests to work together, we must change the database name to avoid seeding conflicts so each test runs on its own database. This has to do with how we seed the database in the <code>Program.cs</code> file, which is not something we usually do except for development or proofs of concept. Nonetheless, testing against multiple databases can come in handy to isolate tests.Here’s that second test case and updated <code>AutoMapperAppWebApplication</code> class to give you an idea:</p>
<div><pre><code>public class StartupTest
{
    [Fact]
    public async Task The_products_endpoint_should_be_reachable()
    {
        await using var application = new AutoMapperAppWebApplication();
        using var client = application.CreateClient();
        using var response = await client.GetAsync("/products");
        response.EnsureSuccessStatusCode();
    }
    // Omitted AutoMapper_configuration_is_valid method
}
internal class AutoMapperAppWebApplication : WebApplicationFactory&lt;Program&gt;
{
    private readonly string _databaseName;
    public AutoMapperAppWebApplication([CallerMemberName]string? databaseName = default)
    {
        _databaseName = databaseName ?? nameof(AutoMapperAppWebApplication);
    }
    protected override IHost CreateHost(IHostBuilder builder)
    {
        builder.ConfigureServices(services =&gt;
        {
            services.AddScoped(sp =&gt;
            {
                return new DbContextOptionsBuilder&lt;ProductContext&gt;()
                    .UseInMemoryDatabase(_databaseName)
                    .UseApplicationServiceProvider(sp)
                    .Options;
            });
        });
        return base.CreateHost(builder);
    }
}</code></pre>
</div>
<p>Running the tests ensures that the mapping in our application works and that one of the endpoints is reachable. We could add more tests, but those two cover about 50% of our code.</p>
<blockquote>
<p>The <code>CallerMemberNameAttribute</code> used in the preceding code is part of the <code>System.Runtime.CompilerServices</code> namespace and allows its decorated member to access the name of the method that called it. In this case, the <code>databaseName</code> parameter receives the test method name.</p>
</blockquote>
<p>And this closes the AutoMapper project. At this point, you should begin to be familiar with object mapping. I’d recommend you evaluate whether AutoMapper is the right tool for the job whenever a project needs object mapping. You can always load another tool or implement your own mapping logic if AutoMapper does not suit your needs. If too much mapping is done at too many levels, maybe another application architecture pattern would be better, or some rethinking is in order.AutoMapper is convention-based and does a lot on its own without any configuration from us. It is also configuration-based, caching the conversions to improve performance. We can also create <strong>type converters</strong>, <strong>value resolvers</strong>, <strong>value converters</strong>, and more. AutoMapper keeps us away from writing that boring mapping code.Yet, AutoMapper is old, feature complete, and is almost unavoidable due to the number of projects that uses it. However, it is not the fastest, which is why we are exploring Mapperly next.</p>


<h2 data-number="16.8">Project – Mapperly</h2>
<p>Mapperly is a newer object mapper library that leverages source generation to make it lightning-fast. To get started, we must add a dependency on the <code>Riok.Mapperly</code> NuGet package.</p>
<blockquote>
<p>Source generators were introduced with .NET 5, allowing developers to generate C# code during compilation.</p>
</blockquote>
<p>There are many ways to create object mappers with Mapperly and many options to adjust the mapping process. The following code sample is similar to the others but using Mapperly. We cover the following ways to use Mapperly:</p>
<ul>
<li>Injecting a mapper class.</li>
<li>Using a static method.</li>
<li>Using an extension method.</li>
</ul>
<p>Let’s start with the injected mapper. First, the class must be <code>partial</code> for the source generator to extend it (that is how source generators work). Decorate the class with the <code>[Mapper]</code> attribute (highlighted). Then, in that partial class, we must create one or more <code>partial</code> methods that have the signature of the mappers we want to create (like the <code>MapToProductDetails</code> method), like this:</p>
<div><pre><code>[Mapper]
public partial class ProductMapper
{
    public partial ProductDetails MapToProductDetails(Product product);
}</code></pre>
</div>
<p>Upon compilation, the code generator creates the following class (I formatted the code to make it easier to read):</p>
<div><pre><code>public partial class ProductMapper
{
    public partial ProductDetails MapToProductDetails(Product product)
    {
        var target = new ProductDetails(
            product.Id ?? throw new ArgumentNullException(nameof(product.Id)),
            product.Name, 
            product.QuantityInStock
        );
        return target;
    }
}</code></pre>
</div>
<p>Mapperly writes the boilerplate code for us in a generated <code>partial</code> class, which is why it is so fast.To use the mapper, we must register it with the IoC Container and inject it into our endpoint. Let’s make it a singleton once again:</p>
<div><pre><code>builder.Services.AddSingleton&lt;ProductMapper&gt;();</code></pre>
</div>
<p>Then, we can inject and use it like this:</p>
<div><pre><code>app.MapGet("/products", async (
    IProductRepository productRepository, 
    ProductMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; mapper.MapToProductDetails(p));
});</code></pre>
</div>
<p>The highlighted code in the preceding block shows we can use our mapper like any other class. The biggest drawback is that we may end up injecting many mappers into a single class or endpoint if we do not consider how we create them wisely.Moreover, we must register all of our mappers with the IoC container, which creates a lot of boilerplate code but makes the process explicit. On the other hand, we could scan the assembly for all classes decorated with the <code>[Mapper]</code> attribute.If you want an abstraction layer like an interface for your mapper, you must design that yourself because Mapperly only generates the mappers. Here is an example:</p>
<div><pre><code>public interface IMapper
{
    NotEnoughStock MapToDto(NotEnoughStockException source);
    ProductNotFound MapToDto(ProductNotFoundException source);
    ProductDetails MapToProductDetails(Product product);
}
[Mapper]
public partial class Mapper : IMapper
{
    public partial NotEnoughStock MapToDto(NotEnoughStockException source);
    public partial ProductNotFound MapToDto(ProductNotFoundException source);
    public partial ProductDetails MapToProductDetails(Product product);
}</code></pre>
</div>
<p>The preceding code centralizes all the mapper methods under the same class and interface, allowing you to inject an interface similar to AutoMapper. In subsequent chapters, we explore ways to organize mappers and app code that does not involve creating a central mapper class.</p>
<blockquote>
<p>To inspect the generated code, you can add the <code>EmitCompilerGeneratedFiles</code> property in a <code>PropertyGroup</code> tag inside your project file and set its value to <code>true</code> like this:</p>
</blockquote>
<pre><code>&lt;PropertyGroup&gt;
    &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;
&lt;/PropertyGroup&gt;</code></pre>
<blockquote>
<p>Then the generated C# files will be available under the <code>obj\Debug\net8.0\generated</code> directory. Change the <code>net8.0</code> subdirectory to the SDK version and <code>Debug</code> by your configuration.</p>
</blockquote>
<p>Next, we explore how to make a static mapper, which follows a very similar process, but we must make both the class and the method <code>static</code> like this:</p>
<div><pre><code>[Mapper]
public static partial class ExceptionMapper
{
    public static partial ProductNotFound Map(ProductNotFoundException exception);
}</code></pre>
</div>
<p>Mapperly takes the preceding code and generates the following (formatted for improved readability):</p>
<div><pre><code>public static partial class ExceptionMapper
{
    public static partial ProductNotFound Map(ProductNotFoundException exception)
    {
        var target = new ProductNotFound(
            exception.ProductId, 
            exception.Message
        );
        return target;
    }
}</code></pre>
</div>
<p>Once again, the code generator writes the boilerplate code. The difference is that we don’t have to inject any dependency since it is a static method. We can use it this way (I only included the catch block, the rest of the code is unchanged):</p>
<div><pre><code>catch (ProductNotFoundException ex)
{
    return Results.NotFound(ExceptionMapper.Map(ex));
}</code></pre>
</div>
<p>It is pretty straightforward but creates a strong bond between the generated class and its consumers. You can use those static methods if having a hard dependency on a static class is acceptable for your project.The last way to map objects we are exploring is very similar, but we create an extension method in the same class instead of just a static method. Here’s the new method:</p>
<div><pre><code>public static partial NotEnoughStock ToDto(this NotEnoughStockException exception);</code></pre>
</div>
<p>The generated code for that method looks like the following (formatted):</p>
<div><pre><code>public static partial NotEnoughStock ToDto(this NotEnoughStockException exception)
{
    var target = new NotEnoughStock(
        exception.AmountToRemove, 
        exception.QuantityInStock, 
        exception.Message
    );
    return target;
}</code></pre>
</div>
<p>The only difference is the addition of the <code>this</code> keyword, making a regular static method into an extension method that we can use like this:</p>
<div><pre><code>catch (NotEnoughStockException ex)
{
    return Results.Conflict(ex.ToDto());
}</code></pre>
</div>
<p>An extension method is more elegant than a static method, yet it creates a bond similar to the static method. Once again, choosing how you want to proceed with your mapping is up to you.One noteworthy thing about Mapperly is that its analyzers yield information, warnings, or errors when the mapping code is incorrect or potentially incorrect. The severity of the messages is configurable. For example, if we add the following method in the <code>ExceptionMapper</code> class, Mapperly yields the <code>RMG013</code> error:</p>
<div><pre><code>public static partial Product NotEnoughStockExceptionToProduct(
    NotEnoughStockException exception
);</code></pre>
</div>
<p>Error message:</p>
<div><pre><code>RMG013 Core.Models.Product has no accessible constructor with mappable arguments</code></pre>
</div>
<p>Moreover, the two exception mapper methods yield messages about properties that do not exist on the target class as information. Here’s an example of such a message:</p>
<div><pre><code>RMG020 The member TargetSite on the mapping source type Core.ProductNotFoundException is not mapped to any member on the mapping target type ProductNotFound</code></pre>
</div>
<p>With those in place, we know when something is or can be wrong, which safeguards us from misconfigurations.Let’s wrap this chapter up.</p>


<h2 data-number="16.9">Summary</h2>
<p>Object mapping is an unavoidable reality in many cases. However, as we saw in this chapter, there are several ways of implementing object mapping, taking that responsibility away from the other components of our applications or simply coding it inline manually.At the same time, we took the opportunity to explore the Aggregate Services pattern, which gives us a way to centralize multiple dependencies into one, lowering the number of dependencies needed in other classes. That pattern can help with the too-many-dependencies code smell, which, as a rule of thumb, states that we should investigate objects with more than three dependencies for design flaws. When moving dependencies into an aggregate, ensure there is cohesion within the aggregate to avoid adding unnecessary complexity to your program and just moving the dependencies around.We also explored leveraging the Façade pattern to implement a mapping façade, which led to a more readable and elegant mapper.Afterward, we implemented a mapper service that mimicked the façade. Despite being less elegant in its usage, it was more flexible.We finally explored is AutoMapper and Mapperly, two open-source tools that do object mapping for us, offering us many options to configure the mapping of our objects. As we explored, just using the default convention of AutoMapper allowed us to eliminate all of our mapping code. On Mapperly’s side, we had to define the mapper contracts using partial classes and methods to let its code generator implement the mapping code for us. You can choose from many existing object mapper libraries, AutoMapper being one of the oldest, most famous, and hated at the same time, while Mapperly is one of the newest and fastest but yet in its infancy.Hopefully, as we are putting more and more pieces together, you are starting to see what I had in mind at the beginning of this book when stating this was an architectural journey.Now that we are done with object mapping, we explore the Mediator and CQRS patterns in the next chapter.</p>


<h2 data-number="16.10">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>Is it true that injecting an Aggregate Service instead of multiple services improves our system?</li>
<li>Is it true that using mappers helps us extract responsibilities from consumers to mapper classes?</li>
<li>Is it true that you should always use AutoMapper?</li>
<li>When using AutoMapper, should you encapsulate your mapping code into profiles?</li>
<li>How many dependencies should start to raise a flag telling you that you are injecting too many dependencies into a single class?</li>
</ol>


<h2 data-number="16.11">Further reading</h2>
<p>Here are some links to build upon what we learned in the chapter:</p>
<ul>
<li>If you want more information on object mapping, I wrote an article about that in 2017, titled <em>Design Patterns: ASP.NET Core Web API, Services, and Repositories | Part 9: the NinjaMappingService and the Façade Pattern</em>: <a href="https://adpg.link/hxYf">https://adpg.link/hxYf</a></li>
<li>AutoMapper official website: <a href="https://adpg.link/5AUZ">https://adpg.link/5AUZ</a></li>
<li><em>AutoMapper Usage Guidelines</em> is an excellent do/don’t list to help you do the right thing with AutoMapper, written by the library’s author: <a href="https://adpg.link/tTKg">https://adpg.link/tTKg</a></li>
<li>Mapperly (GitHub): <a href="https://adpg.link/Dwcj">https://adpg.link/Dwcj</a></li>
</ul>


<h2 data-number="16.12">Answers</h2>
<ol>
<li>Yes, an Aggregate Service can improve a system, but not necessarily. Moving dependencies around does not fix design flaws; it just moves those flaws elsewhere.</li>
<li>Yes, mappers help us follow the SRP. However, they are not always needed.</li>
<li>No, it is not suitable for every scenario. For example, when the mapping logic becomes complex, consider not using AutoMapper. Too many mappers may also mean a flaw in the application design itself.</li>
<li>Yes, use profiles to organize your mapping rules cohesively.</li>
<li>Four or more dependencies should start to raise a flag. Once again, this is just a guideline; injecting four or more services into a class can be acceptable.</li>
</ol>


</body>
</html>
