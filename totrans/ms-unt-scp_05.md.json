["```cs\n01 using UnityEngine;\n02 using System.Collections;\n03 //-------------------------------------------------------\n04 [ExecuteInEditMode]\n05 [RequireComponent(typeof(Camera))]\n06 //-------------------------------------------------------\n07 public class DrawFrustumRefined : MonoBehaviour \n08 {\n09 //-------------------------------------------------------\n10 private Camera Cam = null;\n11 public bool ShowCamGizmo = true;\n12 //-------------------------------------------------------\n13 void Awake()\n14 {\n15       Cam = GetComponent<Camera>();\n16 }\n17 //-------------------------------------------------------\n18 void OnDrawGizmos()\n19 {\n20       //Should we show gizmo?\n21       if(!ShowCamGizmo) return;\n22       //Get size (dimensions) of Game Tab\n23       Vector2 v = DrawFrustumRefined.GetGameViewSize();\n24       float GameAspect = v.x/v.y; //Calculate tab aspect ratio\n25       float FinalAspect = GameAspect / Cam.aspect; \n26 \n27       Matrix4x4 LocalToWorld = transform.localToWorldMatrix;\n28       Matrix4x4 ScaleMatrix = Matrix4x4.Scale(new Vector3(Cam.aspect * (Cam.rect.width / Cam.rect.height), FinalAspect,1)); \n\n29       Gizmos.matrix = LocalToWorld * ScaleMatrix;\n30       Gizmos.DrawFrustum(transform.position, Cam.fieldOfView, Cam.nearClipPlane, Cam.farClipPlane, FinalAspect); \n\n31       Gizmos.matrix = Matrix4x4.identity; //Reset gizmo matrix\n32 }\n33 //-------------------------------------------------------\n34 //Function to get dimensions of game tab\n35 public static Vector2 GetGameViewSize()\n36 {\n37       System.Type T = System.Type.GetType(\"UnityEditor.GameView,UnityEditor\");\n38        System.Reflection.MethodInfo GetSizeOfMainGameView = T.GetMethod(\"GetSizeOfMainGameView\",System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);\n\n39        return (Vector2)GetSizeOfMainGameView.Invoke(null,null);\n40 }\n41 //-------------------------------------------------------\n42 }\n43 //-------------------------------------------------------\n```", "```cs\n //----------------------------------------------\n using UnityEngine;\n using System.Collections;\n //----------------------------------------------\n public class ViewTester : MonoBehaviour \n {\n    //----------------------------------------------\n   void OnBecameVisible()\n    {\n          Debug.Log (\"Became Visible\");\n    }\n    /----------------------------------------------\n    void OnBecameInvisible()\n    {\n          Debug.Log (\"Became Invisible\");\n    }\n    //----------------------------------------------\n }\n //----------------------------------------------\n```", "```cs\n   void OnWillRenderObject()\n   {\n        Debug.Log (Camera.current.name);\n   }\n```", "```cs\n01 using UnityEngine;\n02 using System.Collections;\n03 //---------------------------------------------------------\n04 public class CamUtility\n05 {\n06 //---------------------------------------------------------\n07 //Function to determine whether a renderer is within frustum of a specified camera\n08 //Returns true if renderer is within frustum, else false\n09 public static bool IsRendererInFrustum(Renderer Renderable, Camera Cam)\n\n10 {\n11        //Construct frustum planes from camera\n12        //Each plane represents one wall of frustrum\n13        Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Cam);\n\n14 \n15       //Test whether renderable is within frustum planes\n16       return GeometryUtility.TestPlanesAABB(planes, Renderable.bounds);\n\n17 }\n18 //---------------------------------------------------------\n19 }\n```", "```cs\n //---------------------------------------------------------\n //Determines if point is within frustum of camera\n //Returns true if point is within frustum, else false\n //The out param ViewPortLoc defines the location \n\npublic static bool IsPointInFrustum(Vector3 Point, Camera Cam, out Vector3 ViewPortLoc)\n    {\n         //Create new bounds with no size\n         Bounds B = new Bounds(Point, Vector3.zero);\n\n        //Construct frustum planes from camera\n        //Each plane represents one wall of frustrum\n\n         Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Cam);\n\n        //Test whether point is within frustum planes\n        bool IsVisible = GeometryUtility.TestPlanesAABB(planes, B);\n        //Assign viewport location\n        ViewPortLoc = Vector3.zero;\n\n       //If visible then get viewport location of point\n       if(IsVisible)\n                ViewPortLoc = Cam.WorldToViewportPoint(Point);\n\n         return IsVisible;\n    }\n    //---------------------------------------------------------\n```", "```cs\n    //---------------------------------------------------------\n    //Function to determine whether an object is visible\n    public static bool IsVisible(Renderer Renderable, Camera Cam)\n    {\n         //If in frustrum then cast line\n         if(CamUtility.IsRendererInFrustum(Renderable, Cam))\n               return \n\n//Is direct line between camera and object?\n!Physics.Linecast(Renderable.transform.position, Cam.transform.position);\n         return false; //No line found or not in frustum\n    }\n    //---------------------------------------------------------\n```", "```cs\n using UnityEngine;\n using System.Collections;\n //-------------------------------------------------\n public class CamFieldView : MonoBehaviour \n {\n    //-------------------------------------------------\n    //Field of view (degrees) in which can see in front of us\n    //Measure in degrees from forward vector (left or right)\n    public float AngleView = 30.0f;\n\n    //Target object for seeing\n    public Transform Target = null;\n\n    //Local transform\n    private Transform ThisTransform = null;\n    //-------------------------------------------------\n    // Use this for initialization\n    void Awake () \n    {\n         //Get local transform\n         ThisTransform = transform;\n    }\n    //-------------------------------------------------\n     // Update is called once per frame\n     void Update ()\n    {\n         //Update view between camera and target\n         Vector3 Forward = ThisTransform.forward.normalized;\n         Vector3 ToObject = (Target.position - ThisTransform.position).normalized;\n\n         //Get Dot Product\n         float DotProduct = Vector3.Dot(Forward, ToObject);\n         float Angle = DotProduct * 180f;\n\n         //Check within field of view\n        if(Angle >= 180f-AngleView)\n         {\n                  Debug.Log (\"Object can be seen\");\n         }\n    }\n    //-------------------------------------------------\n }\n //-------------------------------------------------\n```", "```cs\n01 //-------------------------------------------------------\n02 using UnityEngine;\n03 using System.Collections;\n04 //-------------------------------------------------------\n05 [RequireComponent(typeof(Camera))] \n06 //-------------------------------------------------------\n07 public class OrthoCam : MonoBehaviour\n08 {\n09 //private reference to camera component\n10 private Camera Cam = null;\n11 \n12 //Reference to Pixels to World Units Scale\n13 public float PixelsToWorldUnits = 200f;\n14 //-------------------------------------------------------\n15 // Use this for initialization\n16 void Awake () \n17 {\n18        //Get camera reference\n19        Cam = GetComponent<Camera>();\n20 }\n21 //-------------------------------------------------------\n22 // Update is called once per frame\n23 void LateUpdate () \n24 {\n25        //Update orthographic size\n26        Cam.orthographicSize = Screen.height / 2f / PixelsToWorldUnits;\n\n27 }\n28 //-------------------------------------------------------\n29 }\n30 //-------------------------------------------------------\n```", "```cs\n001 //Class to fade from camera 0 to 1, and back from 1 to 0\n002 //This class assumes there are only two scene cameras\n003 //---------------------------------------\n004 using UnityEngine;\n005 using System.Collections;\n006 //---------------------------------------\n007 public class CameraFader : MonoBehaviour\n008 {\n009       //---------------------------------------\n010       //All cameras in the scene to be composited\n011       public Camera[] Cameras;\n012 \n013      //Color to multiply with render)\n014      public Color[] CamCols = null;\n015 \n016      //Fade in/out time in seconds \n017       public float FadeTime = 2.0f;\n018 \n019       //Material used as shader to final render\n020       public Material Mat = null;\n021       //---------------------------------------\n022       // Use this for initialization\n023       void Start () \n024       {\n025             //Assign render textures to each camera\n026             foreach(Camera C in Cameras)\n027                    C.targetTexture = new RenderTexture(Screen.width, Screen.height, 24); //Create texture\n\n028       }\n029       //---------------------------------------\n030       //Called once per frame after the camera has \n031       //finished rendering but before the render is shown\n032       //Companion function: OnPreRender\n033        void OnPostRender()\n034       {\n035            //Define screen rect\n036            Rect ScreenRct = new Rect(0,0,Screen.width,Screen.height);\n037 \n038            //Source Rect\n039            Rect SourceRect = new Rect(0,1,1,-1);\n040 \n041            //Render each camera to their target texture\n042            for(int i = 0; i<Cameras.Length; i++)\n043             {\n044                   //Render camera\n045                   Cameras[i].Render();\n046 \n047                   //Draw textures to screen using camera\n048                   GL.PushMatrix();\n049                   GL.LoadPixelMatrix();\n050                   Graphics.DrawTexture(ScreenRct, Cameras[i].targetTexture, SourceRect, 0,0,0,0, CamCols[i]); \n051                   GL.PopMatrix(); //Reset matrix\n052            }\n053       }\n054       //---------------------------------------\n055       //This function is called after OnPostRender\n056       //And when final pixels are to be shown on screen\n057       //src = current render from camera\n058       //dst = texture to be shown on screen\n059       void OnRenderImage(RenderTexture src, RenderTexture dst)\n060       {\n061             //Now push final pixels to screen with Mat\n062             Graphics.Blit(src, dst, Mat);\n063       }\n064       //---------------------------------------\n065       //Lerp color over period TotalTime\n066      //Fade alpha for topmost rendered camera CamCols[1]\n067      public IEnumerator Fade(Color From, Color To, float TotalTime)\n\n068      {\n069           float ElapsedTime = 0f;\n070 \n071            //Loop while total time is not met\n072            while(ElapsedTime <= TotalTime)\n073             {\n074                   //Update color\n075                   CamCols[1] = Color.Lerp(From, To, ElapsedTime/TotalTime);\n076 \n077                  //Wait until next frame\n078                  yield return null;\n079 \n080                 //Update Time\n081                 ElapsedTime += Time.deltaTime;\n082             }\n083 \n084            //Apply final color\n085             CamCols[1] = Color.Lerp(From, To, 1f);\n086     }\n087       //---------------------------------------\n088       //Sample for testing camera functionality\n089       //Press space bar to fade in and out between cameras\n090       void Update()\n091       {\n092             //Fade camera in or out when space is pressed\n093             if(Input.GetKeyDown(KeyCode.Space))\n094             {\n095                   StopAllCoroutines();\n096 \n097                   //Should we fade out or in\n098                   if(CamCols[1].a <= 0f)\n099                          StartCoroutine(Fade(CamCols[1], new Color(0.5f,0.5f,0.5f,1f), FadeTime)); //Fade in\n\n100                    else\n101                           StartCoroutine(Fade(CamCols[1], new Color(0.5f,0.5f,0.5f,0f), FadeTime)); //Fade out\n\n102            }\n103       }\n104       //---------------------------------------\n105 }\n```", "```cs\n using UnityEngine;\n using System.Collections;\n //---------------------\n public class CameraShake : MonoBehaviour \n {\n    private Transform ThisTransform = null;\n\n     //Total time for shaking in seconds\n     public float ShakeTime = 2.0f;\n     //Shake amount - distance to offset in any direction\n     public float ShakeAmount = 3.0f;\n\n     //Speed of camera moving to shake points\n     public float ShakeSpeed = 2.0f;\n\n    //---------------------\n    // Use this for initialization\n    void Start () \n    {\n         //Get transform component\n         ThisTransform = GetComponent<Transform>();\n\n         //Start shaking\n        StartCoroutine(Shake());\n    }\n    //---------------------\n    //Shake camera\n    public IEnumerator Shake()\n    {\n         //Store original camera position\n         Vector3 OrigPosition = ThisTransform.localPosition;\n\n          //Count elapsed time (in seconds)\n          float ElapsedTime = 0.0f;\n\n         //Repeat for total shake time\n         while(ElapsedTime < ShakeTime)\n         {\n               //Pick random point on unit sphere\n                Vector3 RandomPoint = OrigPosition + Random.insideUnitSphere * ShakeAmount;\n\n                //Update Position\n                ThisTransform.localPosition = Vector3.Lerp(ThisTransform.localPosition, RandomPoint, Time.deltaTime * ShakeSpeed);\n\n                //Break for next frame\n                yield return null;\n\n                //Update time\n                 ElapsedTime += Time.deltaTime;\n         }\n         //Restore camera position\n         ThisTransform.localPosition = OrigPosition;\n    }\n    //---------------------\n }\n //---------------------\n```", "```cs\n using UnityEngine;\n using System.Collections;\n //---------------------------------------------------------------\n public class CamFollow : MonoBehaviour \n {\n //---------------------------------------------------------------\n    //Follow target\n     public Transform Target = null;\n\n    //Reference to local transform\n    private Transform ThisTransform = null;\n\n    //Linear distance to maintain from target (in world units)\n    public float DistanceFromTarget = 10.0f;\n\n    //Height of camera above target\n    public float CamHeight = 1f;\n\n    //Damping for rotation\n    public float RotationDamp = 4f;\n\n    //Damping for position\n    public float PosDamp = 4f;\n //---------------------------------------------------------------\n    void Awake()\n    {\n         //Get transform for camera\n         ThisTransform = GetComponent<Transform>();\n    }\n //---------------------------------------------------------------\n    // Update is called once per frame\n    void LateUpdate () \n    {\n         //Get output velocity\n         Vector3 Velocity = Vector3.zero;\n\n         //Calculate rotation interpolate\n         ThisTransform.rotation = Quaternion.Slerp(ThisTransform.rotation, Target.rotation, RotationDamp * Time.deltaTime);\n\n         //Get new position\n         Vector3 Dest = ThisTransform.position = Vector3.SmoothDamp(ThisTransform.position, Target.position, ref Velocity, PosDamp * Time.deltaTime);\n\n         //Move away from target\n         ThisTransform.position = Dest - ThisTransform.forward * \nDistanceFromTarget;\n\n          //Set height\n          ThisTransform.position = new Vector3(ThisTransform.position.x, CamHeight, ThisTransform.position.z);\n\n         //Look at dest\n         ThisTransform.LookAt(Dest);\n    }\n //---------------------------------------------------------------\n }\n```", "```cs\n//-----------------------------\n using UnityEngine;\n using System.Collections;\n //-----------------------------\n public class CameraMover : MonoBehaviour \n {\n    //-----------------------------\n    //Total time for animation\n    public float TotalTime = 5.0f;\n\n    //Total Distance to move on each axis\n    public float TotalDistance = 30.0f;\n    //Curves for motion\n    public AnimationCurve XCurve;\n    public AnimationCurve YCurve;\n    public AnimationCurve ZCurve;\n\n    //Transform for this object\n    private Transform ThisTransform = null;\n    //-----------------------------\n    void Start()\n   {\n         //Get transform component\n         ThisTransform = GetComponent<Transform>();\n\n        //Start animation\n        StartCoroutine(PlayAnim());\n    }\n    //-----------------------------\n    public IEnumerator PlayAnim()\n    {\n         //Time that has passed since anim start\n         float TimeElapsed = 0.0f;\n\n          while(TimeElapsed < TotalTime)\n          {\n                //Get normalized time\n                float NormalTime = TimeElapsed / TotalTime;\n\n               //Sample graph for X Y and Z\n               Vector3 NewPos = ThisTransform.right.normalized * XCurve.Evaluate(NormalTime) * TotalDistance;\n\n                NewPos += ThisTransform.up.normalized * YCurve.Evaluate(NormalTime) * TotalDistance;\n\n                NewPos += ThisTransform.forward.normalized * ZCurve.Evaluate(NormalTime) * TotalDistance;\n\n               //Update position\n               ThisTransform.position = NewPos;\n\n               //Wait until next frame\n               yield return null;\n\n               //Update time\n               TimeElapsed += Time.deltaTime;\n          }\n    }\n    //-----------------------------\n\n }\n //-----------------------------\n```", "```cs\n using UnityEngine;\n using System.Collections;\n\n public class cam_itween_mover : MonoBehaviour \n {\n    // Use this for initialization\n    void Start () \n    {\n iTween.MoveTo(gameObject, iTween.Hash(\"path\", iTweenPath.GetPath(\"Camera Fly\") , \"time\", 4f, \"easetype\", iTween.EaseType.easeInOutSine));\n    }\n }\n```"]