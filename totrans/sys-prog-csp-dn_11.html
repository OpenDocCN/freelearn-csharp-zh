<html><head></head><body>
		<div id="_idContainer063">
			<h1 class="chapter-number" id="_idParaDest-236"><a id="_idTextAnchor237"/>11</h1>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor238"/>The One with the Debugging Dances</h1>
			<p><em class="italic">Debugging and Profiling </em><span class="No-Break"><em class="italic">System Applications</em></span></p>
			<p><strong class="bold">Debugging</strong> is the<a id="_idIndexMarker818"/> art of finding errors in your code and ensuring you have all the knowledge to fix them. That sounds simple enough, doesn’t it? Well, think again. Debugging can get complicated quickly, and you need good strategies to recover. Luckily, I am here to help you! In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What is debugging? What <span class="No-Break">is </span><span class="No-Break"><strong class="bold">profiling</strong></span><span class="No-Break">?</span></li>
				<li>How do we <span class="No-Break">use </span><span class="No-Break"><strong class="bold">breakpoints</strong></span><span class="No-Break">?</span></li>
				<li>What other debugging tools do we have in <span class="No-Break">Visual Studio?</span></li>
				<li>How do we deal with multithreaded and <span class="No-Break">asynchronous systems?</span></li>
				<li>How do we profile and benchmark our code to ensure it runs as fast <span class="No-Break">as possible?</span></li>
			</ul>
			<p>Debugging can get quite time-intensive. So, let’s not waste any time and <span class="No-Break">get started.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor239"/>Technical requirements</h1>
			<p>As always, you can find the source code for all samples in this chapter in the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11</span></a><span class="No-Break">.</span></p>
			<p>I only use Visual Studio in this chapter; I am not referring to any of the third-party tools that might do the same job. However, I will provide you with a list of alternative tools at the end of <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor240"/>Introducing debugging</h1>
			<p>True story: I once worked for a manager who claimed he wanted to lay off the testers in my team. He said, “If your team performs better, they will not produce bugs, and therefore we can save on the testers.” Obviously, he was wrong. I left that company shortly after <span class="No-Break">this happened.</span></p>
			<p>Developing software is a creative job. People think software development is an exact science that is close to mathematics and physics, but it is not. Sure, the roots look mathematical, but what we, as software developers, do is something else. We take an idea, think of something that does not yet exist, and then turn those ideas into something that can help others. We create something out of thin air by our imagination <span class="No-Break">and ingenuity.</span></p>
			<p>However, the creative mind is sloppy. We cut corners when we are in the flow. We make mistakes trying to realize our vision. Testers and QA professionals are our safety net; they are there to catch the things we forget about. But having a safety net does not mean you can do whatever you want and wing it. Once you have the first outline of your code ready, it is time to switch from being the creative developer to the pensive, analytical developer – the one who looks at their code and notices areas of improvement; and still then you will miss things. So, you test yourself. That is when you find issues. Or, you see the system does not run as smoothly as you expected. Maybe you find the results are not what they are supposed to be. That is when the debugging dance starts: you run the system, you try to pinpoint the area where things go wrong, you fix things, and repeat the <span class="No-Break">whole cycle.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Debugging<a id="_idIndexMarker819"/> can be a fun journey, or it can be an extremely frustrating experience. I am here to help you move your debugging experiences into a more fun one. If debugging means fixing bugs, then developing means creating bugs. There is nothing wrong with that, as long as you realize this is the case and you can resolve the issues before shipping. Let me help you <span class="No-Break">with that!</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor241"/>Debugging and profiling – an overview</h1>
			<p>I remember when they taught me how to write Cobol code on the university mainframe. It was a challenge, to be honest. The mainframe was a costly machine with many terminals attached. If you do not know what that means, imagine you have one computer with multiple keyboards and monitors connected to it, where each user can use their session to do their work, isolated from <span class="No-Break">the others.</span></p>
			<p>This worked fine when you had to do some simple stuff, such as working on a document or a spreadsheet; the mainframe could handle multiple sessions well. However, compiling code is something else: that takes a lot of CPU power. They fixed that by having the students submit their code to the compiler, which would then run sequentially at night. You could see what you did wrong when you returned the next day. Imagine forgetting a semicolon somewhere, meaning you have to wait another 24 hours before you can see the results of your fix. That way of working taught me to think about my code <span class="No-Break">very thoroughly.</span></p>
			<p>These days, when I enter C# code, I see the compiler working for me constantly. Visual Studio immediately tells me when I make <span class="No-Break">a mistake.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor242"/>Debugging</h2>
			<p><strong class="bold">Debugging</strong> was <a id="_idIndexMarker820"/>out of the question. All we could do was stuff the code with logging messages, run the program, and see the output. Then, we could try to deduce the errors in our code from the <span class="No-Break">log files.</span></p>
			<p>Nowadays, it’s so much easier: you can step through your code, see the statements as they are executed, and inspect variables, memory, threads, and <span class="No-Break">so on.</span></p>
			<p>Of course, the requirements of the software have also become much more complex, so writing software in itself hasn’t gotten <span class="No-Break">any easier.</span></p>
			<p>But modern debugging tools help – <span class="No-Break">a lot.</span></p>
			<p><em class="italic">Debugging is the process of identifying, isolating, and fixing problems or “bugs” in software. These bugs can be anywhere from simple syntax errors to more elusive logic errors that produce the wrong output </em><span class="No-Break"><em class="italic">or flow.</em></span></p>
			<p>The compiler helps us fix the most obvious mistakes: a typo in a statement is caught immediately. However, code that compiles does not result in a flawless program. Debugging can help <span class="No-Break">remedy that.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor243"/>Profiling</h2>
			<p><strong class="bold">Profiling</strong> is the twin of<a id="_idIndexMarker821"/> debugging. <em class="italic">While debugging aims to find logical errors, profiling is meant to help you find performance errors.</em> Performance errors can indicate that the system runs too slow, uses too much memory, or other things that stop the software from running as efficiently <span class="No-Break">as possible.</span></p>
			<p>Profiling helps you improve the efficiency of your software. It shows you where the bottlenecks are. Profiling can help you pinpoint where your memory usage goes up and where your logic fails when encountering <span class="No-Break">performance issues.</span></p>
			<p>Profiling can be as simple as logging some timing information or as complex as gathering 24 hours of activities of all your threads and performing a statistical analysis of that data. It all depends on <span class="No-Break">your needs.</span></p>
			<p>Debugging<a id="_idIndexMarker822"/> and profiling<a id="_idIndexMarker823"/> go hand in hand. With a profile session, you gather the evidence that something is not going as you want it to. You then use debugging techniques to find and fix the errors in <span class="No-Break">your code.</span></p>
			<p>Of course, this process is more like a cycle. You debug, then you profile, then debug to find the issues, fix them, then debug the fixes, then profile the fixes, and so on. It’s a never-ending dance. However, it can be quite satisfying: in the end, you have much better code and a better-performing system, and that must make it all <span class="No-Break">worth it!</span></p>
			<p>So, let’s investigate the tools we have to do all <span class="No-Break">this magic!</span></p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor244"/>Debugging 101</h1>
			<p><strong class="bold">Visual Studio</strong> is a <a id="_idIndexMarker824"/>great tool. It has many features that help you during development and the debugging process. So, it is natural to start by looking at Visual Studio first. I will not spend much time on debugging basics in Visual Studio. Still, I think revisiting the most apparent tools we have is <span class="No-Break">immensely clarifying.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor245"/>Debug builds versus Release builds</h2>
			<p>Let’s talk about that <a id="_idIndexMarker825"/>dropdown at the top in Visual Studio, where you can choose between <strong class="bold">Debug</strong> and <strong class="bold">Release</strong>. I am <a id="_idIndexMarker826"/>sure you have a feeling about what this is all about. You pick <strong class="bold">Debug</strong> when you are still writing the code, and want to debug your software. You choose <strong class="bold">Release</strong> when you are ready to release <span class="No-Break">your product.</span></p>
			<p>However, there is a bit more you should know about those options. Let me start by saying that you can still debug your code if it is built in Release mode. It’s just a <span class="No-Break">bit harder.</span></p>
			<p>Let me compare the results of a Debug setting and a Release setting. The following table shows the <span class="No-Break">main differences:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-10">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Debug</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Release</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Primarily <a id="_idIndexMarker827"/><span class="No-Break">for development.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Primarily<a id="_idIndexMarker828"/> <span class="No-Break">for production.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Optimization</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Minimal or <span class="No-Break">no optimization.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Highly optimized for performance and efficiency. The compiler removes unused code and applies <span class="No-Break">various optimizations.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Symbols</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Includes debugging symbols (<strong class="source-inline">.pdb</strong> files), which provide detailed information about the code (e.g., variable names, line numbers, and <span class="No-Break">so on).</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No or limited symbols. You can still get a <strong class="source-inline">.pdb</strong> file, but it will have much <span class="No-Break">less information.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Assertions</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Debug assertions <span class="No-Break">are enabled.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Debug assertions <span class="No-Break">are disabled.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Performance</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generally slower because there is <span class="No-Break">no optimization.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generally faster and <span class="No-Break">more efficient.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Size</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Larger files due to extra <span class="No-Break">debugging information.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Smaller because of optimizations and removal of <span class="No-Break">debugging information.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1: Comparing Debug and Release builds</p>
			<p>I suggest you use Debug builds when debugging. That is what it <span class="No-Break">is for.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor246"/>Breakpoints</h2>
			<p>The best tool Visual Studio offers is the <a id="_idIndexMarker829"/>mighty <strong class="bold">breakpoint</strong>. It is a straightforward construct, but it can help us a lot when trying to understand what is happening inside <span class="No-Break">our application.</span></p>
			<p>In the simplest form, a breakpoint is a code point that stops the program when the application reaches the code statement to which the breakpoint is attached. You can add breakpoints to all sorts of things as long as they are statements. You cannot add a breakpoint to a <span class="No-Break">code comment.</span></p>
			<p>You cannot set a breakpoint on a method declaration, but you can set it on the first <strong class="source-inline">{</strong> that marks the beginning of <span class="No-Break">the method.</span></p>
			<p>Also, declarations of variables are not a valid target for a breakpoint unless you do an <span class="No-Break">assignment simultaneously.</span></p>
			<p>For instance, look at the following <span class="No-Break">two lines:</span></p>
			<pre class="source-code">
int x; // Cannot add a breakpoint
int j = 0; // Can add a breakpoint</pre>			<p>We cannot add a breakpoint to the line where we declare <strong class="source-inline">i</strong>. We can add a breakpoint to the second line. Technically, that line consists of two parts: the declaration and the assignment; the breakpoint is set on the <span class="No-Break">assignment part.</span></p>
			<p>Namespace declarations and <strong class="source-inline">using</strong> statements are also invalid targets. Interfaces cannot have breakpoints, just as attribute declarations <span class="No-Break">are excluded.</span></p>
			<p>However, besides these obvious cases, you can place them wherever <span class="No-Break">you want.</span></p>
			<h3>What happens when a breakpoint is hit?</h3>
			<p>We have some software, placed a <a id="_idIndexMarker830"/>breakpoint, and ran the software. At one point, the execution point reaches our breakpoint. The question is: what <span class="No-Break">happens then?</span></p>
			<p>First, the execution stops. The program is frozen in time. In Visual Studio, some additional tools come <span class="No-Break">to life:</span></p>
			<ul>
				<li><strong class="bold">Locals</strong>: This window opens or updates, showing all variables reachable in the <span class="No-Break">current scope</span></li>
				<li><strong class="bold">Autos</strong>: This window displays variables used in the current line and the <span class="No-Break">surrounding context</span></li>
				<li><strong class="bold">Watch</strong>: This window shows any variables you might have added to <span class="No-Break">the Watch</span></li>
				<li><strong class="bold">Call Stack</strong>: This window displays a series of method calls that led up to the <span class="No-Break">current breakpoint</span></li>
				<li><strong class="bold">Immediate</strong>: This window allows you to type commands, evaluate expressions, or change variable values on <span class="No-Break">the fly</span></li>
			</ul>
			<p>With the program paused, you can inspect or modify variable values <span class="No-Break">if necessary.</span></p>
			<p>This helps you understand what happens in your program. However, it can lead to weird situations if you are <span class="No-Break">not careful.</span></p>
			<p>Let’s have a look at what I mean. Imagine you have this <span class="No-Break">code somewhere:</span></p>
			<pre class="source-code">
int sum = 0;
for (int i = 1; i &lt;= 10; i++)
{
    sum += i;
}
$"The sum of the numbers from 0 to 9 is {sum}".Dump(ConsoleColor.Cyan);</pre>			<p>This code iterates over the <strong class="source-inline">i</strong> variable, increasing it and adding its value to the <strong class="source-inline">sum</strong> variable. If you run this, you get the result of <strong class="source-inline">55</strong>. Now, place a breakpoint inside the loop. Run the code again, but after the ninth iteration, you decide you want to see what happens in that loop one more time. So, you change the value of <strong class="source-inline">i</strong> from <strong class="source-inline">9</strong> back to <strong class="source-inline">0</strong>. The <strong class="source-inline">sum</strong> variable will <a id="_idIndexMarker831"/>not make any sense anymore: the outcome is a vastly <span class="No-Break">different value.</span></p>
			<p>This sample is simple, but these side effects can happen quite quickly. Changing variables might have unintended consequences. So, be aware <span class="No-Break">of that.</span></p>
			<h3>Threads and breakpoints</h3>
			<p>Later in this chapter, we <a id="_idIndexMarker832"/>will discuss debugging multithreaded applications, but I want to discuss one item here. I said that when the code hits a breakpoint, the debugger <span class="No-Break">stops execution.</span></p>
			<p>Look at <span class="No-Break">this code:</span></p>
			<pre class="source-code">
ThreadPool.QueueUserWorkItem(_ =&gt;
{
    int inThreadCounter = 0;
    while (true)
    {
        $"In the thread with counter {inThreadCounter++}".Dump(ConsoleColor.Yellow);
        Thread.Sleep(100);
    }
});
int outThreadCounter = 0;
while (true)
{
    $"In the main thread with counter {outThreadCounter++}".Dump(ConsoleColor.Cyan);
    await Task.Delay(200);
}</pre>			<p>The code is straightforward enough. First, we get a <strong class="source-inline">thread</strong> from <strong class="source-inline">ThreadPool</strong>. An infinite loop logs a message in <strong class="source-inline">thread</strong>, increases a <strong class="source-inline">counter</strong>, and waits for <span class="No-Break">100 milliseconds.</span></p>
			<p>In the main part of the code, we do something similar but at a different time. Running this program shows that we get two messages from the inner thread for each message from the outer thread. Now, place a breakpoint on the last <strong class="source-inline">Task.Delay()</strong> statement. Run the code, let the debugger hit the breakpoint, wait for a few seconds, and continue <span class="No-Break">the run.</span></p>
			<p>Suppose you do that a couple of times. In that case, you will notice that although the sequence of the messages to the console is slightly different, we still get twice as many messages from the inner thread. In other words, if we pause the outer thread, the inner thread is <span class="No-Break">also paused.</span></p>
			<p>That is good, of course. You<a id="_idIndexMarker833"/> do not want other threads to continue, wreaking havoc on the program flow. But let’s change things a bit: replace the code where we create the thread with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var inThreadCounter = 0;
var timer = new Timer(100);
timer.Elapsed +=
    (_, _) =&gt;
    {
        $"In the timer call with counter {inThreadCounter++}".Dump(ConsoleColor.Yellow);
    };
timer.Start();</pre>			<p>Instead of having a <strong class="source-inline">thread</strong>, we now have a <strong class="source-inline">timer</strong>. This code achieves the same effect as our previous code: the <strong class="source-inline">timer</strong> works on a separate <strong class="source-inline">thread</strong> when the time has passed. If that happens, we will log the message and increase <span class="No-Break">the counter.</span></p>
			<p>However, if we repeat the little trick we did with the breakpoint on the code in the last loop, you will notice a completely different behavior. The number of messages from the timer is no longer double the number we get from the main loop; it is much more <span class="No-Break">than that.</span></p>
			<p>A breakpoint does not stop timers. Neither does it stop classes such as <strong class="source-inline">Stopwatch</strong>. Time-based events still happen, so you have a different outcome than expected. Be mindful of that when you <span class="No-Break">use timers!</span></p>
			<h3>Features of breakpoints</h3>
			<p>Breakpoints <a id="_idIndexMarker834"/>are more than <a id="_idIndexMarker835"/>just markers to show the debugger where to stop the execution. They have some properties that can be helpful if you use them correctly. Most of these settings are accessed by clicking the breakpoint in the <strong class="bold">Breakpoints</strong> window and selecting <strong class="bold">Settings</strong>. That window looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Figure 1﻿1.1: The Breakpoint Settings window in Visual Studio" src="image/B20924_12_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: The Breakpoint Settings window in Visual Studio</p>
			<p>You can also get this window by clicking on one of the settings you get when you right-click the breakpoint bullet in the <span class="No-Break">code editor.</span></p>
			<h4>Active and inactive breakpoints</h4>
			<p>Breakpoints <a id="_idIndexMarker836"/>by default are active, meaning<a id="_idIndexMarker837"/> that if the debugger comes to the statement containing the breakpoint, the execution stops. But you can also disable the breakpoint: this <a id="_idIndexMarker838"/>means the <a id="_idIndexMarker839"/>breakpoint is still there, but it does not do anything. This option can be handy if you are debugging some code but want to skip a specific breakpoint at this time but do not want to <span class="No-Break">delete it.</span></p>
			<h4>Conditional breakpoints</h4>
			<p>A conditional breakpoint<a id="_idIndexMarker840"/> only breaks when a particular condition<a id="_idIndexMarker841"/> has been met. The condition can be a single condition or a set of conditions, all of which must be true. The condition can include variables from the code as well. Let’s imagine I want a breakpoint in the previous code sample. I want the breakpoint to be on the line with the <strong class="source-inline">Task.Delay()</strong>code. However, I only want that breakpoint to be active if the <strong class="source-inline">outThreadCounter</strong> variable is larger than <strong class="source-inline">5</strong> and only if that breakpoint has been hit 6 times. In our code, that should be the same (every time we go through that loop, <strong class="source-inline">outThreadCounter</strong> is increased), but if this doesn’t happen, you can verify it using <span class="No-Break">this technique.</span></p>
			<p>You can specify <a id="_idIndexMarker842"/>this by placing a <a id="_idIndexMarker843"/>breakpoint, right-clicking on it, and then <span class="No-Break">choosing </span><span class="No-Break"><strong class="bold">Conditions</strong></span><span class="No-Break">.</span></p>
			<h4>Action breakpoints or tracepoints</h4>
			<p><strong class="bold">Action breakpoints</strong> can be real<a id="_idIndexMarker844"/> breakpoints or breakpoints that do not <a id="_idIndexMarker845"/>break. But besides breaking (or not), you <a id="_idIndexMarker846"/>can also specify that the debugger should write something in the <strong class="bold">Output</strong> window. In other words, this is a very lightweight and temporary log system. You can output a static text or the contents of a variable. Underneath the option where you specify the output, you can place a checkmark in the box saying <strong class="bold">Continue code execution</strong>. If you check that box, the debugger does not stop at this breakpoint and only displays the required information in the Output window. When you do not stop executing the code and<a id="_idIndexMarker847"/> only display <a id="_idIndexMarker848"/>some information, we call these <span class="No-Break">breakpoints </span><span class="No-Break"><strong class="bold">tracepoints</strong></span><span class="No-Break">.</span></p>
			<h4>One-time breakpoint</h4>
			<p>A <strong class="bold">one-time breakpoint</strong> only <a id="_idIndexMarker849"/>works once. It stops code execution when the<a id="_idIndexMarker850"/> breakpoint is hit and then disables itself. If you want to use it again, you must manually enable it. You create this breakpoint by selecting <strong class="bold">Disable breakpoint </strong><span class="No-Break"><strong class="bold">once hit</strong></span><span class="No-Break">.</span></p>
			<h4>Dependent breakpoint</h4>
			<p>The <strong class="bold">dependent breakpoint</strong> is <a id="_idIndexMarker851"/>only enabled after another breakpoint <a id="_idIndexMarker852"/>has been hit. This is particularly useful if you have a method that is called from different places in your code. Still, you only want to debug a particular path. In that case, you create a breakpoint in the flow you are interested in (you might even make it non-breakable so that it only acts as a trigger) and then connect the breakpoint in the method you are interested in into that <span class="No-Break">first breakpoint.</span></p>
			<p>The effect is that the <a id="_idIndexMarker853"/>breakpoint is disabled until that first breakpoint <span class="No-Break">is hit.</span></p>
			<p>To see this in action, take our last example. Increase the time for the <strong class="bold">Timer</strong> option to <strong class="source-inline">1</strong> second (1000 milliseconds). Then, add a breakpoint to the line where we write the message to the console. Tick the <strong class="bold">Action</strong> box in the properties of this breakpoint, but do not add anything to the <strong class="bold">Message</strong> dialog. However, make sure you tick the <strong class="bold">Continue code execution</strong> box. The settings should look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 1﻿1.2: Trigger breakpoint" src="image/B20924_12_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Trigger breakpoint</p>
			<p>Then, add<a id="_idIndexMarker854"/> another breakpoint <a id="_idIndexMarker855"/>to the line where we write the console the value of <strong class="source-inline">outThreadCounter</strong>. This time, change the settings to enable the <strong class="bold">Only enable when the following breakpoint is hit</strong> option and select the other breakpoint in the corresponding drop-down menu. That should look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 1﻿1.3: Depend﻿ent breakpoint" src="image/B20924_12_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: Dependent breakpoint</p>
			<p>If you run the <a id="_idIndexMarker856"/>program, the debugger ignores the last breakpoint during the first second. Then, the execution stops since our first breakpoint has <span class="No-Break">been hit.</span></p>
			<p>Of course, you can combine these settings <span class="No-Break">at will.</span></p>
			<p class="callout-heading">Adding other breakpoints quickly</p>
			<p class="callout">You probably know that you can add breakpoints to your code by clicking in what is known as <strong class="bold">the gutter</strong> to the left of the source code. If you do that, a red bullet appears in that gutter to indicate you have added a breakpoint at that position. But did you know you can also right-click in that gutter? If you do that, you get a pop-up menu to quickly add the breakpoints that were previously mentioned. In the long run, this might save you some <span class="No-Break">mouse clicks!</span></p>
			<h3>Some other features</h3>
			<p>Breakpoints have <a id="_idIndexMarker857"/>some other<a id="_idIndexMarker858"/> nice features that might be helpful. You usually access these in the <strong class="bold">Breakpoints</strong> window in Visual Studio by right-clicking the chosen breakpoint. Here are some <span class="No-Break">of them:</span></p>
			<ul>
				<li><strong class="bold">Breakpoints can have labels</strong>: This way, you can give more meaningful names to <span class="No-Break">the breakpoints.</span></li>
				<li><strong class="bold">You can group breakpoints</strong>: If you create a breakpoint group, you can add breakpoints to them. This way, you can quickly turn a large group of breakpoints on or off instead of going through <span class="No-Break">them individually.</span></li>
				<li><strong class="bold">You can search for breakpoints</strong>: In the breakpoints window, you can search for class names, line numbers, output, labels, and so on. This feature might be helpful if you have a large group <span class="No-Break">of breakpoints.</span></li>
				<li><strong class="bold">You can sort breakpoints by name, condition, hit count, label, and more</strong>: If you still can’t find <a id="_idIndexMarker859"/>what you need, you might want to <a id="_idIndexMarker860"/>reconsider your <span class="No-Break">breakpoint strategy!</span></li>
			</ul>
			<p>Most developers I encounter never come near all these options: all they do is toggle a breakpoint on a line of code to stop execution. But I hope you begin to appreciate the power these tools can <span class="No-Break">bring you.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor247"/>Debug windows</h2>
			<p>Visual Studio has a lot of windows<a id="_idIndexMarker861"/> that can help you get a grip on what is happening when you debug. Most of these windows are useless when editing code but come to life once the debugger starts. Let’s see what <span class="No-Break">we have!</span></p>
			<h3>Breakpoints</h3>
			<p>We already discussed<a id="_idIndexMarker862"/> breakpoints, but I want to point out<a id="_idIndexMarker863"/> the <strong class="bold">Breakpoints</strong> window. This window is where you see all the breakpoints in your application. It also shows additional information about those breakpoints. You can add columns to the window if you need more information. This is an example of what might <span class="No-Break">look like:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 1﻿1.4: The Breakpoints window" src="image/B20924_12_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: The Breakpoints window</p>
			<p>You can customize this window to fit <span class="No-Break">your needs.</span></p>
			<h3>Locals, autos, and watches</h3>
			<p>When debugging, you probably want to see the values of the variables in your code. To see the value, you can hover the mouse over a variable in the code editor window. However, there are windows in Visual Studio dedicated to giving you access to that data. Let’s <span class="No-Break">explore these.</span></p>
			<p>The <strong class="bold">Locals</strong> window<a id="_idIndexMarker864"/> shows all <a id="_idIndexMarker865"/>the variables in the current scope. That can be pretty useful: you see all variables in the current block without being distracted by <span class="No-Break">other variables.</span></p>
			<p>The <strong class="bold">Autos</strong> window<a id="_idIndexMarker866"/> is even better: it tries to guess which variables interest <a id="_idIndexMarker867"/>you when you break in the code and show them and <span class="No-Break">their values.</span></p>
			<p>Let’s have a look at this. We have the <span class="No-Break">following class:</span></p>
			<pre class="source-code">
internal class MyClass
{
    public int Counter { get; set; }
}</pre>			<p>We use it in the following code (I added line numbers so I can refer to the lines <span class="No-Break">later on):</span></p>
			<pre class="source-code">
1: MyClass myClass = new MyClass();
2: int myNumber = 0;
3: while (true)
4: {
5:     myClass.Counter++;
6:     Console.WriteLine($"Counter {myClass.Counter++}");
7: }</pre>			<p>Now, add a breakpoint on <em class="italic">line 3</em>. Run the code and see whether your output matches mine. I will step through all lines from <em class="italic">3</em> up until <em class="italic">7</em> and show you what the <strong class="bold">Autos</strong> window <span class="No-Break">tells me.</span></p>
			<p>The first breakpoint is on <em class="italic">line 3</em>, so the debugger stops there. It breaks on <em class="italic">line 3</em>, with the following result in the <span class="No-Break"><strong class="bold">Autos</strong></span><span class="No-Break"> window:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-8">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Type</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">myNumber</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline" lang="en-US" xml:lang="en-US">0</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Int</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.2</p>
			<p>Now, step to the<a id="_idIndexMarker868"/> following line. Then we get, if we stop on <em class="italic">line 4</em>, we get the<a id="_idIndexMarker869"/> <span class="No-Break">following results:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-6">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.3</p>
			<p>As you can see, we get no results. We stopped on <strong class="source-inline">{</strong>, and no variables can influence the path of the code now. So, there is nothing to show. Let’s continue and step to the following line, <span class="No-Break"><em class="italic">line 5</em></span><span class="No-Break">.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004-4">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">myClass</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">myClass}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">MyClass</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>    <span class="No-Break"><strong class="source-inline">Counter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">0</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Int</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">myClass.Counter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">0</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">int</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.4</p>
			<p>If you step to that line, you will see two items. The top one, <strong class="source-inline">myClass</strong>, can be expanded so you can see properties that might interest you. In our case, this is <strong class="source-inline">myClass.Counter</strong>. We also see the <strong class="source-inline">myClass.Counter</strong> variable separately since the compiler is smart enough to see this is significant in <span class="No-Break">our code.</span></p>
			<p>Let’s move to the next line, <span class="No-Break"><em class="italic">line 6</em></span><span class="No-Break">.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">MyClass.Counter.get returned</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">0</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">int</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">myClass</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">myClass}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">MyClass</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">    </strong><span class="No-Break"><strong class="source-inline">Counter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Int</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">myClass.Counter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">int</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.5</p>
			<p>That is interesting: the <strong class="bold">Locals</strong> window shows <a id="_idIndexMarker870"/>us that we called a method (<strong class="source-inline">MyClass.Counter.get</strong>) and got <a id="_idIndexMarker871"/>a result. There is also an icon to show you that this is indeed the return value. The “get” returned zero, but then we applied the <strong class="source-inline">++</strong> operator to change the <span class="No-Break">value locally.</span></p>
			<p>The next line, <em class="italic">line 7</em>, <span class="No-Break">produces this:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table006-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">MyClass.Counter.get returned</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">int</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear returned</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Counter 1</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">string</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.6</p>
			<p>We printed the line of text to the console and did that with the <strong class="source-inline">$</strong> interpolation command in front of the string. Now, you can see that doing that caused the <strong class="source-inline">System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear()</strong> method to be called, returning the resulting <strong class="source-inline">Counter 1</strong> string. Oh, and we lost <strong class="source-inline">myClass</strong> (well, it’s not lost; it’s just not shown any more since we will not use it in this scope anymore). As you can see, the <strong class="bold">Locals</strong> window is good at showing values of local variables and helping you figure out implicit method calls, such as the string interpolation and <span class="No-Break">property getters!</span></p>
			<p>The <strong class="bold">Locals</strong> window<a id="_idIndexMarker872"/> is pretty clever at figuring out what you need to see. Of <a id="_idIndexMarker873"/>course, if you disagree, there is always the <span class="No-Break"><strong class="bold">Watch</strong></span><span class="No-Break"> window.</span></p>
			<p>The <strong class="bold">Watch</strong> window<a id="_idIndexMarker874"/> does the same as the previous two debug windows, but it only shows <a id="_idIndexMarker875"/>you what you ask it to show. Once the debugger stops the flow of your program, you can right-click on a variable and select <strong class="bold">Add to Watch</strong>. The variable will then pop up in the <strong class="bold">Watch</strong> window, where you can do the same things as you can do with <strong class="bold">Locals</strong> and <strong class="bold">Autos</strong>: inspect the variables and <a id="_idIndexMarker876"/>change<a id="_idIndexMarker877"/> the values <span class="No-Break">if needed.</span></p>
			<p>However, this time, the variables stay there until you remove them. Suppose they go out of scope or are unreachable. In that case, you get an error in the <strong class="bold">Watch</strong> window telling you the variable does not exist in the current context. That doesn’t harm your experience, though: it will stay there as long as you need it, and if the variable comes back into context (in this or in a subsequent debugging session), it will be <span class="No-Break">back again.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor248"/>Diagnostic Tools</h2>
			<p>The <strong class="bold">Diagnostic Tools</strong> window<a id="_idIndexMarker878"/> almost deserves its very own book. It does many things for us! Let’s dive <span class="No-Break">into it.</span></p>
			<p>As with most other debugging tools in Visual Studio, you cannot use the <strong class="bold">Diagnostic Tools</strong> until you are at a breakpoint in your code while debugging. We will use a very silly program to show you some of <strong class="bold">Diagnostic Tools</strong>’ possibilities. It’s a <strong class="bold">console application</strong>, and the code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var memoryBlock = new Dictionary&lt;int, byte[]&gt;();
var passCounter = 0;
while (true)
{
    passCounter++;
    var newBlock = new byte[1024 * 1024];
    memoryBlock.Add(passCounter, newBlock);
}</pre>			<p>I also place a conditional breakpoint on the line with <strong class="source-inline">passCounter++</strong> (so, the first statement is in the while-loop). That condition looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
passCounter % 100 == 0</pre>			<p>In other words, the breakpoint stops every <span class="No-Break">100 passes.</span></p>
			<p>If we run this, the application will break on the first pass. That makes sense: 0 % of 100 equals 0. You can<a id="_idIndexMarker879"/> then open the <strong class="bold">Diagnostic Tools</strong> window (if it doesn’t show up automatically, you can open it by going to the <strong class="bold">Debug</strong> menu, then choosing <strong class="bold">Windows</strong>, followed by selecting <strong class="bold">Show Diagnostic Tools</strong>). I suggest you make the window bigger than usual so you can see all the goodies it gives us. Mine looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 1﻿1.5: The Diagnostic Tools window" src="image/B20924_12_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: The Diagnostic Tools window</p>
			<p>At the top of the <a id="_idIndexMarker880"/>window, there are some charts. Since nothing has happened yet in our program, these are not very interesting. But that will change! Below the charts, there are some tabs. Initially, you see the <strong class="bold">Summary</strong> tab, which summarizes the contents of the <span class="No-Break">other tabs.</span></p>
			<p>In the <strong class="bold">Summary</strong> tab, click <strong class="bold">Take Snapshot</strong> under the <strong class="bold">Memory Usage</strong> title. You can also do that in the <strong class="bold">Memory Usage</strong> tab itself. Doing this saves the current memory usage and allows it to be compared to a later point in time. Since our application hasn’t done much, this could give us a baseline. So, click on <strong class="bold">Take Snapshot</strong>. Then, continue running <span class="No-Break">the program.</span></p>
			<p>If you click <strong class="bold">Take Snapshot</strong>, the window <a id="_idIndexMarker881"/>should show you the <strong class="bold">Memory Usage</strong> tab, which shows the snapshot. Since we continued the program, we are not on the 100th iteration, so we can take another snapshot. Do that. That results in my system in <span class="No-Break">this view:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 1﻿1.6: Second pass in the Diagnostic Tools window" src="image/B20924_12_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6: Second pass in the Diagnostic Tools window</p>
			<p>This is getting more interesting. We can see in the <strong class="bold">Process Memory (MB)</strong> chart that we have started to allocate a lot more memory. But the real exciting stuff happens in the <strong class="bold">Memory Usage</strong> tab below. You can see a lot here: in the second snapshot, we can see that we have allocated more objects <span class="No-Break">and memory.</span></p>
			<p>You can click on most<a id="_idIndexMarker882"/> values, such as <strong class="bold">Object Count</strong>, <strong class="bold">Object Count Diff</strong>, <strong class="bold">Heap Size</strong>, and <strong class="bold">Heap Size Diff</strong>. If you do that, you will get more information. Let’s click on the <strong class="bold">Objects (Diff)</strong>, thus the number +112. On my system, I get this screen (I clicked on the <strong class="source-inline">Count Diff.</strong> column to sort <span class="No-Break">on that.)</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 1﻿1.7: Memory snapshot" src="image/B20924_12_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7: Memory snapshot</p>
			<p>We have 99 more <strong class="source-inline">Byte[]</strong> objects in memory, resulting in an increase of 104,858,955 bytes <span class="No-Break">of memory.</span></p>
			<p>You can do all sorts of things here. You can click on the line you want to learn more about and then drill down into the source code of that object. That way, you can probably discover why your memory usage <span class="No-Break">is increasing.</span></p>
			<p>A lot is going on in <strong class="bold">Diagnostic Tools</strong>. I suggest you play around with it and see what it can tell you about <span class="No-Break">your system!</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor249"/>Debugging multithreaded and asynchronous code</h1>
			<p>Let’s join the league of super debuggers. We are about to embark on a journey into the depths of multithreaded systems and where they <span class="No-Break">go wrong.</span></p>
			<p>Multithreaded code<a id="_idIndexMarker883"/> is notoriously hard to debug. Imagine you have two threads that interact with each other, and then things go wrong. However, if you step through the methods in Visual Studio, things work just fine, and that makes sense: some bugs appear only when certain timing <span class="No-Break">conditions happen.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor250"/>Parallel Watch</h2>
			<p>What about this: you have multiple<a id="_idIndexMarker884"/> threads, and something goes wrong. You want to inspect what happens in that thread. But if you set a breakpoint, how do you know you are in the <span class="No-Break">correct thread?</span></p>
			<p>Fear not: Visual Studio can help with this. Let’s start with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
var rnd = new Random();
for (int i = 0; i &lt; 10; i++)
{
    int threadNumber = i;
    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        var counter = 0;
        while (true)
        {
            $"Thread {threadNumber} with counter {counter++}".Dump(ConsoleColor.Yellow);
            Task.Delay(rnd.Next(1000)).Wait();
        }
    });
}</pre>			<p>This code creates 10 threads. Each thread has an infinite loop, displaying some text and counting up. However, each thread does this at a different speed: they all wait for a random time between <span class="No-Break">each iteration.</span></p>
			<p>Place a conditional <a id="_idIndexMarker885"/>breakpoint somewhere in that loop, with the condition saying it should break with this condition: <strong class="source-inline">counter % 10 == 0</strong>. Now, run <span class="No-Break">the program.</span></p>
			<p>You see the <strong class="source-inline">counter</strong> value in the <strong class="bold">Autos</strong> or <strong class="bold">Locals</strong> windows. That can be helpful; that variable is local to the thread you are currently in. Visual Studio did pause all other threads for us, but we have no idea what the state of the data is in those threads. How can we <span class="No-Break">find out?</span></p>
			<p>The answer to that question is this: open the <strong class="bold">Parallel Watch</strong> window. Again, you can find this in the <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> menu. On my system, after breaking in my breakpoint, it looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 1﻿1.8: The Parallel Watch window" src="image/B20924_12_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8: The Parallel Watch window</p>
			<p>In this particular case, I have apparently stopped execution in thread 14628. That doesn’t tell <span class="No-Break">me much.</span></p>
			<h3>Add a Parallel Watch</h3>
			<p>But as you can <a id="_idIndexMarker886"/>see, on the top of the window, it says <strong class="bold">&lt;Add Watch&gt;</strong>. If I click there, I can enter the variable’s name I am interested in. So, I add the <strong class="source-inline">counter</strong> variable there. As soon as I do that, the <strong class="bold">Watch</strong> window shows me the value of that variable, but it does that for <span class="No-Break">each thread:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="Figure 1﻿1.9: Parallel Watch with counter added" src="image/B20924_12_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9: Parallel Watch with counter added</p>
			<p>As you can see in the screenshot, all threads have their version of the <strong class="source-inline">counter</strong>, each with a different value. This <span class="No-Break">is helpful!</span></p>
			<h3>Jumping to frames</h3>
			<p>Although this <a id="_idIndexMarker887"/>window is primarily a <strong class="bold">Watch</strong> window, meaning it shows the variables you are interested in and their values, there are other things you can do here <span class="No-Break">as well.</span></p>
			<p>Since we stopped somewhere in the loop, you can hover over the variables in your code to see the values. However, as we discovered, those values only apply to that thread. You can add all the variables you are interested in into the <strong class="bold">Parallel Watch</strong> window, but what if you just want to see a variable once? Well, the <strong class="bold">Parallel Watch</strong> window can help you. Select one of the other threads in that window and right-click on that line, and you will see a context menu. One of the options is <strong class="bold">Switch To Frame</strong>. If you do that, the debugger makes the chosen thread the current one, allowing you to investigate the values of all variables in scope for that <span class="No-Break">particular thread.</span></p>
			<p>This way, you can jump between all active threads and inspect all values of all variables in scope <span class="No-Break">per thread.</span></p>
			<h3>Freezing and thawing threads</h3>
			<p>The ability to inspect variables in different threads is a potent tool. You can probably imagine that certain variables affect other threads. Finding issues usually requires a lot of logging and inspections of those logs to determine the results of unwanted behavior. Being able to break the code and see what is happening saves you from a lot of <span class="No-Break">that work.</span></p>
			<p>But sometimes, all<a id="_idIndexMarker888"/> those threads running simultaneously can get in the way. In those cases, you might want to focus on one or some threads in isolation. The <strong class="bold">Freeze</strong> and <strong class="bold">Thaw</strong> options<a id="_idIndexMarker889"/> can help in <span class="No-Break">this situation.</span></p>
			<p>Freezing a thread is nothing more than pausing it during debugging. You temporarily halt the execution of one or more threads so you can focus on what is important to you. When you have all the information you need, you can thaw the frozen threads and let them resume their regular work. You can use the <strong class="bold">Thread</strong> window, but you can also do that in the <strong class="bold">Parallel Watch</strong> window. All you have to do is right-click on the thread you want to freeze and select <strong class="bold">Freeze</strong> from the context menu. If you resume the program, the thread you have chosen to freeze will not do <span class="No-Break">anything anymore.</span></p>
			<p>To see that behavior in action, change the number of threads in our code to 2 instead of 2. Rerun the program and see which thread is active when the breakpoint hits. Obviously, one of the threads will cause the breakpoints condition (the <strong class="source-inline">counter</strong> variable in that thread must be a multiple of 10) to be satisfied. If you then resume the program, the other thread will likely be the following thread to stop: it is probably also close to satisfying the condition (I say “probably,” since the random behavior of the <strong class="source-inline">Wait()</strong> statement might, in theory, make it possible to <span class="No-Break">act otherwise).</span></p>
			<p>Restart the program and wait for the first time the breakpoint becomes active. This time, right-click on the other thread and select <strong class="bold">Freeze</strong>. Resume <span class="No-Break">the program.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 1﻿1.10: Freezing threads in Parallel Watch" src="image/B20924_12_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10: Freezing threads in Parallel Watch</p>
			<p>A pause <a id="_idIndexMarker890"/>symbol should be in front of the chosen thread. Resume the program. When the program breaks again, it will be on the same thread as the first<a id="_idIndexMarker891"/> time it did this. If you resume, the third time will also be on that thread. That makes sense: the other thread is not doing anything and thus never satisfies the <span class="No-Break">breakpoint conditions.</span></p>
			<p>Now, you can work on that one working thread to make sure you get what is going on. When you are ready to have the thread join the rest of the program, wait until the breakpoint happens again. Then, you can right-click the frozen thread and “thaw” it. Resume the program and see whether everything is back to normal: the debugger will break as soon as the condition is met in any of <span class="No-Break">the threads.</span></p>
			<p class="callout-heading">Freeze and Thaw: a word of warning</p>
			<p class="callout">As you probably saw, the program continues after thawing the thread without adjusting anything. Typically, the <strong class="source-inline">counter</strong> variable values in both threads should be close to each other. However, after freezing one thread, it falls behind, and it doesn’t catch up on that lag anymore. Freezing and thawing threads can have an unpredictable side effect: if the rest of your code somehow relies on that thread running, you might have inadvertently changed the logic flow. So, be aware <span class="No-Break">of that!</span></p>
			<p>Freezing and thawing can be a lovely addition to your tool belt. So, use them if needed, but use <span class="No-Break">them wisely!</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor251"/>Debugging deadlocks with Parallel Stacks and Thread windows</h2>
			<p>Deadlocks are pretty<a id="_idIndexMarker892"/> nasty. Simply put, a <strong class="bold">deadlock</strong> is when two threads wait for each other and thus cannot continue. It’s like driving your car on a narrow road and seeing someone coming from the other side. One of you will have to back off, or you will never leave that road. Deadlocks are like that, but your application freezes since neither of the involved threads is willing to drive back. I think it is obvious that you would not want that in <span class="No-Break">your code.</span></p>
			<p>However, as simple as the issue sounds, it can be challenging to debug and fix. But Visual Studio is here <span class="No-Break">to help!</span></p>
			<p>Let’s begin with <a id="_idIndexMarker893"/>a simple program. This is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
"Starting the threads".Dump(ConsoleColor.Cyan);
var lockA = new object();
var lockB = new object();
ThreadPool.QueueUserWorkItem(_ =&gt;
{
    lock (lockA)
    {
        "Thread 1 acquired lock A".Dump(ConsoleColor.Yellow);
        Thread.Sleep(1000);
        lock (lockB)
        {
            "Thread 1 acquired lock B".Dump(ConsoleColor.Yellow);
        }
    }
});
ThreadPool.QueueUserWorkItem(_ =&gt;
{
    lock (lockB)
    {
        "Thread 2 acquired lock B".Dump(ConsoleColor.Blue);
        Thread.Sleep(1000);
        lock (lockA)
        {
            "Thread 2 acquired lock A".Dump(ConsoleColor.Blue);
        }
    }
});
"Waiting for all threads to finish".Dump(ConsoleColor.Cyan);
Console.ReadLine();</pre>			<p>What do we do <a id="_idIndexMarker894"/>here? Simply put, we create two threads. They each use a <strong class="source-inline">lock</strong> statement. This means no other thread can enter that scope until the thread that owns the <strong class="source-inline">lock</strong> statement is done. That is not an issue in this code: both threads use a different <strong class="source-inline">lock</strong>. However, we also tried to use the other <strong class="source-inline">lock</strong> object in the thread. Because we have a <strong class="source-inline">Thread.Sleep(1000)</strong> in each thread, both threads have enough time to acquire the <strong class="source-inline">lock</strong> before accessing the other <strong class="source-inline">lock</strong>. But that never happens. No thread can release the <strong class="source-inline">lock</strong> since it waits for the other thread – and <span class="No-Break">vice versa.</span></p>
			<p>Run it. You will see that both threads print out their initial statements about acquiring their <strong class="source-inline">lock</strong>s. And then: nothing. The program is completely frozen. It doesn’t do anything anymore. We have a deadlock on <span class="No-Break">our hands.</span></p>
			<p>In this case, what is going on is obvious. Still, I am sure you can imagine these situations can be tricky to find in typical programs. The good news is that Visual Studio usually knows what is happening and can <span class="No-Break">tell us.</span></p>
			<p>Stop the <a id="_idIndexMarker895"/>program execution by going to the <strong class="bold">Debug</strong> menu, and then clicking on <strong class="bold">Break All</strong>. When Visual Studio has the focus, you can also press <em class="italic">Ctrl</em> + <em class="italic">Alt</em> + <span class="No-Break"><em class="italic">Break</em></span><span class="No-Break">.</span></p>
			<p>Breaking like this stops all threads as if the debugger has hit a breakpoint. Visual Studio stops at one of the three threads (the main thread or one of the bad-behaving ones), and you get a warning like <span class="No-Break">this one:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 1﻿1.11: Deadlock detected by Visual Studio" src="image/B20924_12_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11: Deadlock detected by Visual Studio</p>
			<p>So, at least know what caused the freezing: we have a deadlock. It is time to find out what is <span class="No-Break">going on.</span></p>
			<h3>Parallel Stacks</h3>
			<p>In <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.12</em>, you see <a id="_idIndexMarker896"/>the <strong class="bold">Show Parallel Stacks</strong> option in that dialog <a id="_idIndexMarker897"/>box. You can also get the <strong class="bold">Parallel Stacks</strong> window through the <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> menu option. Doing that gives you a nice visual representation of all currently known threads. On my machine, that looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Figure 1﻿1.12: Parallel Stacks in action" src="image/B20924_12_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12: Parallel Stacks in action</p>
			<p>Since we have very few threads running, spotting the issue is straightforward. The offending threads are marked with a red circle with a white line: the symbol globally known as a stop sign. This symbol indicates the threads that are currently deadlocked. To make it even more apparent, the information box below says <strong class="bold">[Deadlocked, double-click or press enter to view]</strong>. You can double-click on the <strong class="bold">Waiting on lock</strong> line to jump to the source code for <span class="No-Break">this thread.</span></p>
			<p>This window helps you identify thread issues very quickly. You can see which threads are running, if there are any issues, and where those threads <span class="No-Break">originated from.</span></p>
			<p>But if that is not enough, you can go deeper by looking at the <span class="No-Break"><strong class="bold">Threads</strong></span><span class="No-Break"> window.</span></p>
			<h3>Threads window</h3>
			<p>As you might have<a id="_idIndexMarker898"/> guessed from the name, the <strong class="bold">Threads</strong> window <a id="_idIndexMarker899"/>shows you all the threads you might be interested in. Let’s continue with our deadlock example. You have looked at <strong class="bold">Parallel Stacks</strong>, but you cannot find what <span class="No-Break">is happening.</span></p>
			<p>So, you open the <strong class="bold">Threads</strong> window. On my machine, it looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="Figure 1﻿1.13: The Threads window" src="image/B20924_12_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13: The Threads window</p>
			<p>These are all the threads currently known in my application. They are all up and running, and the current thread has an ID of <strong class="source-inline">95264</strong> (or managed thread ID <strong class="source-inline">10</strong>). It is a thread from the thread pool since the name is <strong class="source-inline">.NET TP Worker</strong>. You can also see the location: it is in <span class="No-Break">my application.</span></p>
			<p>If you click on <a id="_idIndexMarker900"/>the down arrow next to the name, you get <span class="No-Break">more </span><span class="No-Break"><a id="_idIndexMarker901"/></span><span class="No-Break">details:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 1﻿1.14: The Thread window with more details" src="image/B20924_12_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14: The Thread window with more details</p>
			<p>As you can see in the screenshot, this gives me more information, including the text that this thread is deadlocked and is waiting on a lock owned by thread <strong class="source-inline">14840</strong>. The <strong class="bold">Thread</strong> window also shows information about that particular thread, so you can open that one if you want to. Double-clicking on the location brings you to the source code, where you can investigate what you were doing before the whole thing <span class="No-Break">came crashing.</span></p>
			<p>Debugging threading issues is not easy. But without these tools, they can be found more easily than ever before. Of course, the best course of action is not to make mistakes in the first place, but as I explained to my manager all those years ago, we do not live in that kind <span class="No-Break">of world.</span></p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor252"/>Profiling application performance</h1>
			<p>By now, we have established that system programmers care about speed. Applications need to be as efficient and as fast as possible. But what if you think your application can go faster but do not know where or what to improve? That is where profiling and benchmarking <span class="No-Break">can help.</span></p>
			<p>Profiling is<a id="_idIndexMarker902"/> measuring and analyzing the performance of your application in terms of factors such as CPU usage, memory pressure, network performance, and so on. It’s like putting your app under a microscope. Things we look at during profiling are, amongst others, <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">CPU usage</strong>: Identify which parts of your application are using the most <span class="No-Break">processing power</span></li>
				<li><strong class="bold">Memory usage</strong>: Track how much memory is used and finding memory leaks or <span class="No-Break">excessive allocations</span></li>
				<li><strong class="bold">Function call frequency</strong>: See which methods are called the most and how long <span class="No-Break">they take</span></li>
				<li><strong class="bold">Performance hotspots</strong>: Pinpoint areas of code that are slower than they <span class="No-Break">should be</span></li>
			</ul>
			<p><strong class="bold">Benchmarking</strong> is related, but<a id="_idIndexMarker903"/> it is different. Benchmarking is measuring the performance of your code under different circumstances or comparing different approaches. This process involves running predefined tests and capturing metrics. Some of the metrics are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Execution time</strong>: Measuring how long it takes for a piece of code <span class="No-Break">to run</span></li>
				<li><strong class="bold">Throughput</strong>: Assessing how many operations or transactions can be processed in a <span class="No-Break">given period</span></li>
				<li><strong class="bold">Latency</strong>: Determining the delay between the initiation and the execution of <span class="No-Break">a task</span></li>
			</ul>
			<p>Profiling and <a id="_idIndexMarker904"/>benchmarking <a id="_idIndexMarker905"/>go hand in hand and are often used together to improve <span class="No-Break">your application.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor253"/>The prime application</h2>
			<p>To investigate<a id="_idIndexMarker906"/> how we might do this, let’s start with a program we want to improve performance. It is a simple program that calculates all the primes in the range 0 – 100,000 and sums them up. It’s nothing fancy or helpful, but it requires the CPU to do much work. We also want to see whether we can make things better. So, let’s start by looking at the code. First, we create a class called <strong class="source-inline">PrimeCalculator</strong>. That’s easy enough. The main method of this class is the <strong class="source-inline">Run</strong> method. It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public void Run()
{
    var limit = 100000;
    var stopwatch = Stopwatch.StartNew();
    var sum = SumOfPrimes(limit);
    stopwatch.Stop();
    $"Sum of primes up to {limit}: {sum}".Dump();
    $"Time taken: {stopwatch.ElapsedMilliseconds} ms".Dump();
}</pre>			<p>There is nothing special going on here. We create a <strong class="source-inline">Stopwatch</strong> to time the duration, then call the <strong class="source-inline">SumOfPrimes()</strong> method that does all the actual work. Finally, we display the results and <span class="No-Break">the duration.</span></p>
			<p>Let’s look at <span class="No-Break"><strong class="source-inline">SumOfPrimes()</strong></span><span class="No-Break"> next:</span></p>
			<pre class="source-code">
private long SumOfPrimes(int limit)
{
    long sum = 0;
    for (var i = 2; i &lt;= limit; i++)
        if (IsPrime(i))
            sum += i;
    return sum;
}</pre>			<p>This code is also <a id="_idIndexMarker907"/>pretty basic. We loop for all values between <strong class="source-inline">2</strong> and the given limit (<strong class="source-inline">2</strong> since <strong class="source-inline">1</strong> is technically not a prime number) and check whether that number is a prime. If it is, we add it to the sum. Let’s move <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IsPrime()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
private bool IsPrime(int number)
{
    if (number &lt; 2) return false;
    for (var i = 2; i &lt;= Math.Sqrt(number); i++)
        if (number % i == 0)
            return false;
    return true;
}</pre>			<p>This method is a lousy implementation to see whether a number is a prime, but it is simple enough to follow. We do this by checking whether the number we give it is divisible by any number that is less than the square root of that number. If it is divisible, it is not <span class="No-Break">a prime.</span></p>
			<p>For example, if I run this on the machine I am writing this text on, I get the sum of 454, 396, 537 and a total duration of 21 milliseconds. I have no idea if that sum is correct; I have no intention of calculating it by hand on my calculator app on my phone. It doesn’t matter: we are here to see whether we can <span class="No-Break">spot bottlenecks.</span></p>
			<p>21 milliseconds<a id="_idIndexMarker908"/> sounds like a short amount of time, but in reality, it is pretty long. After all, computers are fast these days, so I am sure I can improve on it. We can use the profiling tools from Visual Studio to see where the <span class="No-Break">bottlenecks are.</span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor254"/>Profiling in Visual Studio</h2>
			<p>In Visual Studio, under<a id="_idIndexMarker909"/> the main <strong class="bold">Debug</strong> menu, you find the <strong class="bold">Performance Profile</strong> option. The default shortcut key for that is <em class="italic">Alt</em> + <em class="italic">F2</em>, which might be helpful if you repeatedly run this (and <span class="No-Break">you will!)</span></p>
			<p>If you select that option, you see the <span class="No-Break">following screen:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer057">
					<img alt="Figure 1﻿1.15: Start of a profiling session" src="image/B20924_12_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15: Start of a profiling session</p>
			<p>Profiling can be done <a id="_idIndexMarker910"/>on many different levels. However, the most crucial choice is what you want to profile. By default, this tool chooses the current application. As you can see, in my case, that is the <strong class="source-inline">11_Profiling</strong> project. You can select other projects or running processes, browse for an application, and so on. Click that large <strong class="bold">Change Target</strong> button to change if necessary. There is also a warning underneath that button: we might want to switch from a Debug profile to a Release profile. Release is more closely related to what you run in production, so the figures you get are more like the ones you expect to see when you have deployed your application. However, Release mode optimizes your code, making it harder to find programming mistakes. So, I tend to leave it to Debug <span class="No-Break">during development.</span></p>
			<p>Then, you have to decide what you want to see. There are many options here: you might want to see async/awaits, or maybe you are interested in database communications. In my case, I want to know about <strong class="bold">CPU Usage</strong>. I also leave <strong class="bold">.NET Counters</strong> and <strong class="bold">Memory Usage</strong> checked; they might <span class="No-Break">be helpful.</span></p>
			<p>If you click the <strong class="bold">Start</strong> button, your program will build and run. In the background, Visual Studio starts collecting <span class="No-Break">the information.</span></p>
			<p>In our case, the program<a id="_idIndexMarker911"/> runs and ends, signaling Visual Studio to stop collecting. If your application keeps running, you must stop the program manually or click the <strong class="bold">stop collecting</strong> button in <span class="No-Break">Visual Studio.</span></p>
			<p>Once you have done that, Visual Studio shows you an overview of what it <span class="No-Break">has collected.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer058">
					<img alt="Figure 1﻿1.16: First results from a profiling session" src="image/B20924_12_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16: First results from a profiling session</p>
			<p>The results are not that impressive since we have a straightforward program. However, you can see in the <strong class="bold">Top Functions</strong> part that the <strong class="source-inline">_11_Profiling.PrimeCalculator.IsPrime(int)</strong> method takes a lot of time: 10 microseconds, or 10.64% of the <span class="No-Break">total time.</span></p>
			<p>That is good to know, but we want to see whether we can get more information. Click on that line, and you will get another view. You can select what you want to see at the top of that view. By default, you see all data grouped by <strong class="bold">Functions</strong>, but I want to see the call path. If you do that, you get <span class="No-Break">this result:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 1﻿1.17: The hot path leading to the slowest function" src="image/B20924_12_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17: The hot path leading to the slowest function</p>
			<p>You can<a id="_idIndexMarker912"/> click <strong class="bold">Show Hot Path</strong> and <strong class="bold">Expand Hot Path</strong> to see how the process came to the <span class="No-Break">slowest function.</span></p>
			<p>Finally, you can double-click on a line to see the source code. So, if you double-click on the <strong class="source-inline">IsPrime()</strong> method, you <span class="No-Break">get this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 1﻿1.18: The slowest lines of code highlighted" src="image/B20924_12_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18: The slowest lines of code highlighted</p>
			<p>Now, it becomes clear that the loop is the slowest part of the <strong class="source-inline">IsPrime()</strong> function. That makes sense: to make this loop work, the CPU has to calculate <strong class="source-inline">Math.Sqrt(number)</strong> every time. That takes time. How to improve that is obvious: pre-calculate that square root and use that variable in the <strong class="source-inline">for</strong> statement. That should speed <span class="No-Break">things up!</span></p>
			<p>As you can see, with the<a id="_idIndexMarker913"/> proper tooling, you can identify the bottlenecks in your application. Once you find them, you can restructure your code or replace parts with something faster. But how do you know which algorithm to use to speed things up? The answer to that is this: <span class="No-Break">benchmark them!</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor255"/>Benchmarking different solutions</h2>
			<p>I know that the <strong class="source-inline">number % i ==0</strong> line is not the fastest way to see whether a number is divisible by another number. However, I am not really sure how much quicker other ways are. To find out, I <a id="_idIndexMarker914"/>can use some benchmarking to figure <span class="No-Break">it out.</span></p>
			<p>There are several ways you can start with benchmarking, but in a case such as this, where I have several options for a specific algorithm, I like to use the <strong class="source-inline">Benchmarkdotnet</strong> NuGet package. This free package makes <span class="No-Break">benchmarking simple.</span></p>
			<p>To do this, start a<a id="_idIndexMarker915"/> new console application. Add the <strong class="source-inline">Benchmarkdotnet</strong> package to the project. Then, create a new class. I call this class <strong class="source-inline">ModuloTesters</strong> since I want to test the performance of the <strong class="source-inline">Module</strong> operator and any alternatives I <span class="No-Break">can find.</span></p>
			<p>I added a method called <strong class="source-inline">TestModulo</strong>. That method looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[Benchmark]
public void TestModulo()
{
    var numberOfMatches = 0;
    for (var i = 3; i &lt; numberOfLoopCount; i++)
        if (testNumber % i == 0)
            numberOfMatches++;
}</pre>			<p>As you can see, it is pretty simple. I just go through several iterations (<strong class="source-inline">numberOfLoopCount</strong> is defined as a constant in my class, and I have set it to 100,000) and calculate the modulo (<strong class="source-inline">testNumber</strong> is again a constant; it doesn’t really matter what it is, but I have set it to 400). The only thing that makes this method stand out from a typical method is the <strong class="source-inline">[Benchmark]</strong> attribute. This tells the benchmark tool that this method needs to <span class="No-Break">be measured.</span></p>
			<p>In the main program file, we need to kickstart the benchmarking. That is extremely easy: just add this line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
var summary = BenchmarkRunner.Run&lt;ModuloTesters&gt;();</pre>			<p>Set the build mode to <strong class="source-inline">Release</strong>, and run without debugging. The <strong class="source-inline">Benchmark</strong> tool will run the methods marked with <strong class="source-inline">Benchmark</strong> a couple of times (well, more than just a couple) and present you with <span class="No-Break">the results.</span></p>
			<p>But before we look at those<a id="_idIndexMarker916"/> results, we need to add something. Benchmarking is meant to compare solutions to a problem. Right now, we have one solution: the modulo operator. So, there is nothing to compare against. Let’s fix that. Add a new method to the <strong class="source-inline">ModuloTesters</strong> class that looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Benchmark]
public void TestMultiplicationAndDivision()
{
    var numberOfMatches = 0;
    for (var i = 3; i &lt; numberOfLoopCount; i++)
        if (testNumber - i * (testNumber / i) == 0)
            numberOfMatches++;
}</pre>			<p>This is another way of calculating a module. But is it faster? There is only one way to find out: run the benchmark! If you do that, you see the results. On my machine, it looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="Figure 1﻿1.19: Benchmark results" src="image/B20924_12_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19: Benchmark results</p>
			<p>So, the new algorithm is<a id="_idIndexMarker917"/> quicker: it takes 316.4 microseconds instead of 316.7 microseconds. Ok, I admit it is not that much faster. Maybe we can do better. You know what? We can. Let’s add a <span class="No-Break">third benchmark:</span></p>
			<pre class="source-code">
[Benchmark]
public void TestMultiplicationAndDivisionInParallel()
{
    var numberOfMatches = 0;
    var localNumberOfLoopCount = numberOfLoopCount;
    var localTestNumber = testNumber;
    var lockObj = new object();
    Parallel.For(3, localNumberOfLoopCount, i =&gt;
    {
        var div = localTestNumber / i;
        if (localTestNumber == i * div)
            lock (lockObj)
            {
                numberOfMatches++;
            }
    });
}</pre>			<p>Since all the calculations<a id="_idIndexMarker918"/> can be done independently, we can probably do them in parallel. So, that is what I am doing here: I use the <strong class="source-inline">Parallel.For()</strong> statement to divide the work into jobs that run simultaneously. I need a lock to update <strong class="source-inline">numberOfMatches</strong>, which might slow down the loop. But that is a guess: let’s test this. Run the benchmark. This is what <span class="No-Break">I get:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="Figure 1﻿1.20: New benchmark results" src="image/B20924_12_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20: New benchmark results</p>
			<p>Now, that is interesting. The addition of <strong class="source-inline">Parallel.For()</strong> made a massive difference in the time spent on <span class="No-Break">that method.</span></p>
			<p>If you think that could benefit your code, you can apply the findings to the actual application you are working on. Of course, I would profile it first, make the changes, and then profile again to see whether you have not added new bottlenecks. But all in all, I think we have made our prime calculator a <span class="No-Break">lot faster!</span></p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor256"/>Other tools</h1>
			<p>Visual Studio<a id="_idIndexMarker919"/> is an excellent tool for debugging and profiling your system. However, it is not the only one. There are many other solutions out there that can help you debug and profile your code. Some of them are paid, others are free. Some are easy to use, some are pretty hard to get to know. I will not discuss the other tools, but I want to give you a small list so you can investigate them <span class="No-Break">for yourself.</span></p>
			<p>Please look at what Visual Studio gives you first. Chances are, what you need is <span class="No-Break">already there!</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor257"/>Debugging tools</h2>
			<p>There are many debugging tools<a id="_idIndexMarker920"/> out there. This is just a sample of what you can <span class="No-Break">try out.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table007">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Tool Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Company</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Visual </strong><span class="No-Break"><strong class="bold">Studio Debugger</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Integrated<a id="_idIndexMarker921"/> into Visual Studio, supports .NET, C++, and <a id="_idIndexMarker922"/>other languages with breakpoints, watch variables, <span class="No-Break">and more.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">WinDbg</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker923"/>multipurpose debugger for Windows, useful for debugging <a id="_idIndexMarker924"/>user-mode and kernel-mode code and analyzing <span class="No-Break">crash dumps.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Visual Studio </strong><span class="No-Break"><strong class="bold">Code Debugger</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Built into <a id="_idIndexMarker925"/>Visual Studio Code, supports various languages and platforms through extensions, with breakpoints <a id="_idIndexMarker926"/>and <span class="No-Break">variable inspection.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Managed </strong><span class="No-Break"><strong class="bold">Debugger (MDbg)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A simple<a id="_idIndexMarker927"/> command-line debugger<a id="_idIndexMarker928"/> for .NET applications, offering basic debugging capabilities for <span class="No-Break">managed code.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Debug Diagnostic </strong><span class="No-Break"><strong class="bold">Tool (DebugDiag)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Assists<a id="_idIndexMarker929"/> in troubleshooting application crashes, hangs, memory leaks, and performance <a id="_idIndexMarker930"/>issues in <span class="No-Break">user-mode processes.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">ProcDump</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Command-line<a id="_idIndexMarker931"/> utility to monitor applications for CPU spikes<a id="_idIndexMarker932"/> and generate crash dumps <span class="No-Break">for analysis.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Microsoft Performance </strong><span class="No-Break"><strong class="bold">Tools (PerfView)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Performance <a id="_idIndexMarker933"/>analysis tool for collecting and analyzing ETW data, valuable for .NET application performance and<a id="_idIndexMarker934"/> <span class="No-Break">memory issues.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Son of Strike (SOS) Debugging </strong><span class="No-Break"><strong class="bold">Extension</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>An extension<a id="_idIndexMarker935"/> for WinDbg that provides<a id="_idIndexMarker936"/> insights into .NET runtime internals, aiding in-depth debugging of .<span class="No-Break">NET applications.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Windows Performance </strong><span class="No-Break"><strong class="bold">Recorder (WPR)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Tools <a id="_idIndexMarker937"/>for recording and analyzing performance data on Windows systems, capturing detailed <a id="_idIndexMarker938"/>system and <span class="No-Break">application behavior.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Remote </strong><span class="No-Break"><strong class="bold">Debugging Tools</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Tools for <a id="_idIndexMarker939"/>debugging applications running on<a id="_idIndexMarker940"/> different machines or environments, supporting both managed and <span class="No-Break">native code.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">GNU </strong><span class="No-Break"><strong class="bold">Debugger (GDB)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A powerful debugger for <a id="_idIndexMarker941"/>various programming languages, especially C and C++, to see <a id="_idIndexMarker942"/>what is happening inside <span class="No-Break">a program.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">GNU Project</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">LLVM </strong><span class="No-Break"><strong class="bold">Debugger (LLDB)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker943"/>modern, high-performance debugger part of <a id="_idIndexMarker944"/>the LLVM project, supporting languages such as C, C++, <span class="No-Break">and Objective-C.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">LLVM Project</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Valgrind</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A<a id="_idIndexMarker945"/> programming tool for memory debugging, memory leak <a id="_idIndexMarker946"/>detection, and profiling, including tools such <span class="No-Break">as Memcheck.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Valgrind <span class="No-Break">Developers</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Strace</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker947"/>diagnostic, debugging, and instructional utility for Linux that<a id="_idIndexMarker948"/> traces system calls <span class="No-Break">and signals.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Open Source</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.7: Debugging tools</p>
			<p>I do not endorse any of these products; I have merely listed them here for <span class="No-Break">your convenience.</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor258"/>Profiling tools</h2>
			<p>Profiling tools<a id="_idIndexMarker949"/> are also easy to find. A lot of companies next to Microsoft offer solutions for this. They each have their own strengths and weaknesses. So, please look at the following table as a guideline to help you find what is best <span class="No-Break">for you.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table008">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Tool Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Company</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Visual </strong><span class="No-Break"><strong class="bold">Studio Profiler</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Integrated <a id="_idIndexMarker950"/>into Visual Studio, provides detailed <a id="_idIndexMarker951"/>performance and memory usage data for .NET and <span class="No-Break">C++ applications.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">WPR</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Captures<a id="_idIndexMarker952"/> detailed performance data on Windows systems for<a id="_idIndexMarker953"/> <span class="No-Break">in-depth analysis.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Windows Performance </strong><span class="No-Break"><strong class="bold">Analyzer (WPA)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Analyzes <a id="_idIndexMarker954"/>performance data <a id="_idIndexMarker955"/>collected by WPR, helping to identify <span class="No-Break">performance issues.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">PerfView</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Collects <a id="_idIndexMarker956"/>and analyzes ETW data, useful for investigating <a id="_idIndexMarker957"/>performance and memory issues in .<span class="No-Break">NET applications.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">.NET </strong><span class="No-Break"><strong class="bold">Memory Profiler</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A powerful<a id="_idIndexMarker958"/> tool for finding memory leaks and <a id="_idIndexMarker959"/>optimizing memory usage in .<span class="No-Break">NET applications.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>SciTech <span class="No-Break">Software</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">ANTS Performance </strong><span class="No-Break"><strong class="bold">Profiler</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Provides .NET <a id="_idIndexMarker960"/>code profiling to find <a id="_idIndexMarker961"/>performance bottlenecks, including memory usage and execution <span class="No-Break">time analysis.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Redgate</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">JetBrains </strong><span class="No-Break"><strong class="bold">dotTrace</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A .NET<a id="_idIndexMarker962"/> profiler for performance, memory, and <a id="_idIndexMarker963"/>coverage analysis, integrated with <span class="No-Break">Visual Studio.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">JetBrains</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">VTune </strong><span class="No-Break"><strong class="bold">Profiler</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Performance <a id="_idIndexMarker964"/>analysis tool for C, C++, and Fortran <a id="_idIndexMarker965"/>applications, offering deep insights into CPU and <span class="No-Break">GPU performance.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Intel</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Valgrind</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Includes a <a id="_idIndexMarker966"/>suite of tools such as Cachegrind for cache<a id="_idIndexMarker967"/> profiling and Massif for heap profiling, primarily for C and <span class="No-Break">C++ programs.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Valgrind <span class="No-Break">Developers</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Google Performance </strong><span class="No-Break"><strong class="bold">Tools (gperftools)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A suite of <a id="_idIndexMarker968"/>utilities for performance <a id="_idIndexMarker969"/>profiling and heap analysis, providing insights into CPU and <span class="No-Break">memory usage.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Google</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">YourKit </strong><span class="No-Break"><strong class="bold">Profiler</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A profiler <a id="_idIndexMarker970"/>for Java and .NET applications, offering <a id="_idIndexMarker971"/>comprehensive CPU and memory <span class="No-Break">profiling features.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">YourKit</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Perf</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker972"/>performance analyzing tool in Linux that provides detailed <a id="_idIndexMarker973"/>information on CPU performance, helping <span class="No-Break">identify bottlenecks.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Linux <span class="No-Break">Community</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">GlowCode</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker974"/>performance and memory profiler for Windows, focusing<a id="_idIndexMarker975"/> on C++ and .<span class="No-Break">NET applications.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Electric <span class="No-Break">Software Inc.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">AQtime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>An<a id="_idIndexMarker976"/> advanced performance and memory profiling tool for <a id="_idIndexMarker977"/>various programming languages, integrated with <span class="No-Break">Visual Studio.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">SmartBear</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Perfino</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker978"/>Java profiler for production environments, focusing on <a id="_idIndexMarker979"/>performance monitoring and <span class="No-Break">problem resolution.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>EJ <span class="No-Break">Technologies</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.8: Profiling tools</p>
			<p>These tables do not contain all the tools available. New tools are added regularly, while others go away. I suggest you try some of them and stick to what works best for you. Maybe you prefer a CLI solution. Perhaps you want to work with a graphical tool. Whatever your preference is, there is always a tool that fits <span class="No-Break">your needs.</span></p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor259"/>Next steps</h1>
			<p>Writing code inevitably means making mistakes. That is part of the fun of the job, I believe. Coming up with new ideas, making something out of nothing, and then making it work and improve is a great process. However, you can only do that when you have the right tools and know how to <span class="No-Break">use them.</span></p>
			<p>In this chapter, we have looked at the debugging tools that Visual Studio provides. We looked at what debugging and profiling actually are, discovered the possibilities with breakpoints, and looked at the other helpful <span class="No-Break">debug windows.</span></p>
			<p>We also investigated how to deal with multithreaded applications and the debug challenges they give us. We looked at the windows that could help us and <span class="No-Break">investigated deadlocks.</span></p>
			<p>To top it off, we talked about profiling and benchmarking to uncover performance bottlenecks and how to <span class="No-Break">solve them.</span></p>
			<p>So, we now know how to tackle most of the issues in our code. However, we have one more important thing to discuss: how do we secure our code? What does that even mean? That is a big topic. It is so big that I have a complete chapter about it, and that is what is next. Please, <span class="No-Break">follow along!</span></p>
		</div>
	</body></html>