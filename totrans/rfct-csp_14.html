<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-298"><a id="_idTextAnchor297"/>14</h1>
<h1 id="_idParaDest-299"><a id="_idTextAnchor298"/>Refactoring Code with Roslyn Analyzers</h1>
<p>In the last chapter, we saw how you can build Roslyn analyzers to flag issues in your code. In this chapter, we’ll improve our analyzers by giving them the ability to fix code issues by providing <strong class="bold">Quick Actions</strong> the user can invoke to modify their source code. We’ll also discuss some additional ways of deploying Roslyn analyzers that improve your ability to provide a consistent experience to your team members.</p>
<p>This chapter covers the following:</p>
<ul>
<li>Building a Roslyn Analyzer code fix</li>
<li>Testing code fixes with RoslynTestKit</li>
<li>Publishing Roslyn analyzers as NuGet packages</li>
</ul>
<h1 id="_idParaDest-300"><a id="_idTextAnchor299"/>Technical requirements</h1>
<p>In this chapter, we’re starting right where we left off in <a href="B21324_13.xhtml#_idTextAnchor275"><em class="italic">Chapter 13</em></a>.</p>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter14/Ch14BeginningCode</code> folder.</p>
<h1 id="_idParaDest-301"><a id="_idTextAnchor300"/>Case study – Cloudy Skies Airlines</h1>
<p>In <a href="B21324_13.xhtml#_idTextAnchor275"><em class="italic">Chapter 13</em></a>, we <a id="_idIndexMarker830"/>built a <code>ToStringAnalyzer</code> that detects classes that do not override the <code>ToString</code> method. This results in suggestions in the Visual Studio editor and a message in the error list.</p>
<p>Cloudy Skies Airlines has deployed this internally and found it to be generally helpful, but there are a few things that need improvement:</p>
<ul>
<li>Although violations of the <code>ToString</code> override rule are flagged by the analyzer, not every developer is addressing this issue. When discussed internally, some developers stated they didn’t want to take the time to address it. Additionally, some of the newer developers didn’t fully understand the rule or what fixing it would look like.</li>
<li>Whenever a new analyzer is created or a bug in an existing analyzer is addressed, a new VSIX file must be created. Developers then need to download and install it to get the updated version. Because of this, it’s hard for the team to know which developers have the analyzer installed or which version each developer is using.</li>
</ul>
<p>In this chapter, we’ll address these concerns. We’ll look at creating and testing a code fix provider that can automatically resolve detected issues. After that, we’ll explore publishing analyzers <a id="_idIndexMarker831"/>via <strong class="bold">NuGet packages</strong> and show how they<a id="_idIndexMarker832"/> can help your team have a consistent analyzer experience.</p>
<h1 id="_idParaDest-302"><a id="_idTextAnchor301"/>Building a Roslyn Analyzer code fix</h1>
<p>Roslyn Analyzers <a id="_idIndexMarker833"/>allow you to provide options for users to automatically fix issues your analyzers detect in your code. They do this through something <a id="_idIndexMarker834"/>called a <strong class="bold">code fix provider</strong>, which can modify your document in an automated manner to resolve the diagnostic warning.</p>
<p>Think of it this way: diagnostic analyzers, like our <code>OverrideToStringAnalyzer</code>, help <em class="italic">detect</em> issues in your team’s code. On the other hand, code fix providers give you a way of <em class="italic">fixing</em> these issues.</p>
<p>Not all diagnostic analyzers will have code-fix providers, but in my experience, those that also provide code-fix providers tend to get addressed earlier and more consistently.</p>
<p>Let’s see how one works.</p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor302"/>Creating a CodeFixProvider</h2>
<p>First, we’ll add a new <a id="_idIndexMarker835"/>class to the <code>Packt.Analyzers</code> class <a id="_idIndexMarker836"/>library. We’ll call this class <code>ToStringCodeFix</code>. Replace its contents with the following code for a basic code fix:</p>
<pre class="source-code">
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeActions;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Composition;
using System.Linq;
using System.Threading.Tasks;
namespace Packt.Analyzers {
<strong class="bold">  [Shared]</strong>
<strong class="bold">  [ExportCodeFixProvider(LanguageNames.CSharp,</strong>
<strong class="bold">    Name = nameof(ToStringCodeFix))]</strong>
  public class <strong class="bold">ToStringCodeFix : CodeFixProvider</strong> {
    public override ImmutableArray&lt;string&gt;
      <strong class="bold">FixableDiagnosticIds</strong> =&gt;
        ImmutableArray.Create(ToStringAnalyzer.Rule.Id);
    public override FixAllProvider <strong class="bold">GetFixAllProvider</strong>()
      =&gt; WellKnownFixAllProviders.BatchFixer;
    public async override Task <strong class="bold">RegisterCodeFixesAsync</strong>(
      CodeFixContext context) {
      throw new NotImplementedException();
    }
  }
}</pre>
<p>This is the minimum amount of code we need in order to have a compiling code fix provider. Before we build out the rest of this class, let’s examine what’s here already.</p>
<p>First, we’re declaring a <code>ToStringCodeFix</code> class that inherits from <code>CodeFixProvider</code>. <code>CodeFixProvider</code> is the abstract class used for providing a fix for one or more diagnostics.</p>
<p>Note that we named our code fix <code>ToStringCodeFix</code> to pair with the <code>ToStringAnalyzer</code> class it provides a code fix for. This is a convention I like to follow to help clearly associate analyzers and their code fixes.</p>
<p>The class has two attributes assigned to it:</p>
<ul>
<li>The <code>ExportCodeFixProviderAttribute</code> tells Roslyn that the class represents a code fix, what the name of the code fix is, and the languages the code fix applies to</li>
<li>The <code>SharedAttribute</code> doesn’t do anything on its own, but it is needed for Roslyn to be comfortable registering your code fix in Visual Studio</li>
</ul>
<p>These two attributes <a id="_idIndexMarker837"/>should be on every code fix you <a id="_idIndexMarker838"/>create. Failing to use them will result in your code fix provider not appearing for some users (don’t ask me how I know).</p>
<p>The <code>ToStringCodeFix</code> class has three members at the moment:</p>
<ul>
<li><code>ToStringAnalyzer</code> rule, meaning it says it can fix that issue.</li>
<li><code>WellKnownFixAllProviders.BatchFixer</code>, we tell Visual Studio to allow the user to try to fix all issues of that type in the file, project, or even solution.</li>
<li><strong class="bold">RegisterCodeFixesAsync</strong>: This is where we can register our code fix and tell Visual Studio what to do if the user chooses to apply it.</li>
</ul>
<p>The bulk of our<a id="_idIndexMarker839"/> logic<a id="_idIndexMarker840"/> will be in <code>RegisterCodeFixesAsync</code>, so let’s implement that method now.</p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor303"/>Registering a code fix</h2>
<p>The job of <code>RegisterCodeFixesAsync</code> is to interpret code that violates the diagnostic rule we’ve<a id="_idIndexMarker841"/> set up and register an action that will let the user fix it.</p>
<p>The code to do this is fairly involved, so let’s look at parts of it at a time. The first part has to do with interpreting where in the document the diagnostic violation occurred:</p>
<pre class="source-code">
public async override Task RegisterCodeFixesAsync(
  CodeFixContext context) {
  Diagnostic diagnostic = context.Diagnostics.First();
  TextSpan span = diagnostic.Location.SourceSpan;
  Document doc = context.Document;</pre>
<p>Here, we get a <code>CodeFixContext</code> object that contains information about the code analysis diagnostic violations.</p>
<p>These <code>Diagnostic</code> objects contain information about the exact span of text within the document that triggered the rule. In our case, this should be the text for the name of the class that doesn’t override <code>ToString</code>.</p>
<p>Next, we get a reference to the <code>Document</code> containing the violation. Think of a <code>Document</code> as a file of source code somewhere in your solution. It’s possible to have analyzers and code fixes that look over your entire solution, so this <code>Document</code> helps narrow down the scope to the file containing the offending code.</p>
<p>With this <code>Document</code>, we can gain access to the syntax tree and its <code>type</code> declarations:</p>
<pre class="source-code">
  SyntaxNode root = await doc
    .GetSyntaxRootAsync(context.CancellationToken)
    .ConfigureAwait(false);
  TypeDeclarationSyntax typeDec =
    root.FindToken(<strong class="bold">span.Start</strong>)
        .Parent
        .AncestorsAndSelf()
        <strong class="bold">.OfType&lt;TypeDeclarationSyntax&gt;()</strong>
        .First();</pre>
<p>Here, we’re getting the <code>SyntaxRoot</code> element representing the base of our document and then finding the declaration of the class by the location of that span of text within the document.</p>
<p>This lets us jump from the raw text we had in the span to an object representing the <code>Type</code> declaration. Having this object allows us to make changes and provide a fix.</p>
<p>The final portion of the <a id="_idIndexMarker842"/>method registers the code action to fix the issue:</p>
<pre class="source-code">
  CodeAction fix = CodeAction.Create(
    title: "Override ToString",
    createChangedDocument: c =&gt; <strong class="bold">FixAsync(doc, typeDec)</strong>
  );
  <strong class="bold">context.RegisterCodeFix(fix, diagnostic);</strong>
}</pre>
<p>This code creates a <code>CodeAction</code> and registers it as a fix for the diagnostic rule. This fix has a title representing the text the user will see in the <code>FixAsync</code> method we’ve yet to see.</p>
<p class="callout-heading">Additional options</p>
<p class="callout">There are several overloads and optional parameters to <code>CodeAction.Create</code> that let you change the entire solution instead of a single document or resolve conflicts when multiple code fixes have the same title.</p>
<p>Now that we’ve <a id="_idIndexMarker843"/>registered our code fix, let’s see how the fix action works.</p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor304"/>Modifying the document with a code fix</h2>
<p>The final step in implementing<a id="_idIndexMarker844"/> our code fix is the <code>FixAsync</code> method. This method’s job is to modify the <code>Document</code> so that it no longer violates the diagnostic rule.</p>
<p>In our case, the fix will be to generate code such as this:</p>
<pre class="source-code">
public override string ToString()
{
  throw new NotImplementedException();
}</pre>
<p>Sadly, it’s a lot easier to write the raw C# here than it is to build it with the Roslyn API.</p>
<p>To add this with Roslyn, we’ll follow these steps:</p>
<ol>
<li>Create a method body that throws a <code>NotImplementedException</code>.</li>
<li>Create a list of modifiers that go with the method (<code>public</code> and <code>override</code>).</li>
<li>Create a method declaration with the appropriate name and return type and make sure this method has the list of modifiers and the method body.</li>
<li>Create a version of the <code>Type</code> declaration that has the new method.</li>
<li>Find the <code>Type</code> declaration in the <code>Document</code> and replace it with our new one.</li>
</ol>
<p>Let’s see how this works, starting with the code that declares the new method body:</p>
<pre class="source-code">
private Task&lt;Document&gt; FixAsync(Document doc,
  TypeDeclarationSyntax typeDec) {
  const string exType = "NotImplementedException";
  IdentifierNameSyntax exId =
    SyntaxFactory.IdentifierName(exType);
  BlockSyntax methodBody = SyntaxFactory.Block(
    SyntaxFactory.ThrowStatement(
      SyntaxFactory.ObjectCreationExpression(exId)
        .WithArgumentList(SyntaxFactory.ArgumentList())
    )
  );</pre>
<p>As you can see, the code to declare anything in Roslyn can get a bit dense. When you take a step back, though, this code is just declaring a method block that instantiates and throws a <code>NotImplementedException</code>.</p>
<p>Next, we’ll define<a id="_idIndexMarker845"/> the method definition that uses this method body:</p>
<pre class="source-code">
  SyntaxToken[] modifiers = new SyntaxToken[] {
    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
    SyntaxFactory.Token(SyntaxKind.OverrideKeyword)
  };
  SyntaxToken returnType =
    SyntaxFactory.Token(SyntaxKind.StringKeyword);
  MethodDeclarationSyntax newMethod =
    SyntaxFactory.MethodDeclaration(
      SyntaxFactory.PredefinedType(returnType),
      SyntaxFactory.Identifier("ToString")
    )
    .WithModifiers(SyntaxFactory.TokenList(modifiers))
    .WithBody(methodBody);</pre>
<p>This code is almost as dense as the last block, but all it really does is declare the method. This method brings together a return type of <code>string</code>, a name of <code>ToString</code>, the <code>public</code> and <code>override</code> modifiers, and the body we declared in the previous block.</p>
<p>The final step in the fix is to modify the editor’s code with our code fix. We do this with the following code:</p>
<pre class="source-code">
  TypeDeclarationSyntax newType =
    <strong class="bold">typeDec.AddMembers(newMethod)</strong>;
  SyntaxNode root = typeDec.SyntaxTree.GetRoot();
  SyntaxNode newRoot = <strong class="bold">root.ReplaceNode(typeDec, newType)</strong>;
  Document newDoc = <strong class="bold">doc.WithSyntaxRoot(newRoot)</strong>;
  return Task.FromResult(newDoc);
}</pre>
<p>This code creates a new version of the <code>Type</code> declaration that has our new method. We then find the old <code>Type</code> declaration in the <code>Document</code> and replace it with the new one. This creates a new <code>Document</code> that we then return from our code fix, and Visual Studio updates our code<a id="_idIndexMarker846"/> accordingly.</p>
<p>With that, we now have a working code fix. How do we know it’s working? We test it!</p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor305"/>Testing Code Fixes with RoslynTestKit</h1>
<p>In <a href="B21324_13.xhtml#_idTextAnchor275"><em class="italic">Chapter 13</em></a>, we <a id="_idIndexMarker847"/>saw how the <code>RoslynTestKit</code> library <a id="_idIndexMarker848"/>helps your diagnostic analyzers flag code issues appropriately. In this chapter, we’ll revisit the library to verify our new code fix.</p>
<p>We will start by creating a new class in our test project named <code>ToStringCodeFixTests</code> due to our common naming conventions.</p>
<p>This class will start by declaring a test fixture like it did with the analyzer:</p>
<pre class="source-code">
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.Diagnostics;
using RoslynTestKit;
namespace Packt.Analyzers.Tests;
public class <strong class="bold">ToStringCodeFixTests : CodeFixTestFixture</strong> {
 protected override string LanguageName
   =&gt; LanguageNames.CSharp;
 protected override CodeFixProvider <strong class="bold">CreateProvider</strong>()
   =&gt; <strong class="bold">new ToStringCodeFix();</strong>
 protected override IReadOnlyCollection&lt;DiagnosticAnalyzer&gt;
   <strong class="bold">CreateAdditionalAnalyzers</strong>()
   =&gt; new[] { <strong class="bold">new ToStringAnalyzer()</strong> };</pre>
<p>Like before, our test class inherits from a test fixture, but this time it’s a <code>CodeFixTestFixture</code> since we’re testing a code fix.</p>
<p>Also like before, we need to specify that our code fix affects the C# programming language and provide a reference to our class through the <code>CreateProvider</code> method.</p>
<p>Unlike before, we also need to provide the code analyzer we’re testing through the <code>CreateAdditionalAnalyzers</code> method. The compiler will allow you to not override this method, but if you forget to do so, your analyzer will never trigger in the steps ahead, so be sure to include your analyzer here.</p>
<p>Next, we test our<a id="_idIndexMarker849"/> code<a id="_idIndexMarker850"/> fix by providing a block of bad code and a block of good code and verifying that the code fix successfully moves from the bad code to the good code:</p>
<pre class="source-code">
  public const string BadCode = @"
using System;
public class <strong class="bold">[|Flight|]</strong>
{
    public string Id {get; set;}
    public string DepartAirport {get; set;}
    public string ArriveAirport {get; set;}
}";
  public const string GoodCode = @"
using System;
public class Flight
{
    public string Id {get; set;}
    public string DepartAirport {get; set;}
    public string ArriveAirport {get; set;}
<strong class="bold">    public override string ToString()</strong>
<strong class="bold">    {</strong>
<strong class="bold">        throw new NotImplementedException();</strong>
<strong class="bold">    }</strong>
}";
  [Fact]
  public void CodeFixShouldMoveBadCodeToGood() {
    string ruleId = ToStringAnalyzer.Rule.Id;
    <strong class="bold">TestCodeFix(BadCode, GoodCode, ruleId)</strong>;
  }
}</pre>
<p>This code should <a id="_idIndexMarker851"/>be <a id="_idIndexMarker852"/>somewhat familiar from the last chapter. Just like with analyzers, we need to denote the location the fix is triggered from using the <code>[|</code> and <code>|]</code> markers as we see on <code>[|Flight|]</code>.</p>
<p>The actual verification step occurs through the <code>TestCodeFix</code> method call. This method call will convert your bad code to a new form using the code fix and then compare that result to the expected good code.</p>
<p>This comparison is very sensitive, and any extra space, line breaks, or differences at all will result in a failing test with the observed differences between the two strings highlighted, as shown in <em class="italic">Figure 14</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 14.1 – A test failure showing a string difference due to styling choices" src="img/B21324_14_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – A test failure showing a string difference due to styling choices</p>
<p>Assuming your formatting is consistent, your test should now pass, proving you have a good code fix.</p>
<p>If you want, you can now launch your VSIX extension project and verify the code fix in Visual Studio. After that, you could share the VSIX file with colleagues or people in the .NET community and they’d have access to your analyzer and its fix.</p>
<p>However, VSIX <a id="_idIndexMarker853"/>deployment <a id="_idIndexMarker854"/>has some downsides as we’ll soon see. Let’s close the chapter by looking at using NuGet packages to share your code fixes in a more controlled manner.</p>
<h1 id="_idParaDest-307"><a id="_idTextAnchor306"/>Publishing Roslyn Analyzers as NuGet packages</h1>
<p>Using VSIX files<a id="_idIndexMarker855"/> to share code analyzers works, but isn’t<a id="_idIndexMarker856"/> an ideal solution.</p>
<p>Since VSIX files must be manually installed and updated, this means that with a team of software engineers, you’re never sure who has the extension installed at all or who is on which version of the extension.</p>
<p>Because each developer must install the VSIX themselves and keep it updated, this makes it harder to onboard new team members, release new analyzers or code fixes, or issue patches for issues found in your existing analyzers.</p>
<p>Thankfully, there’s a better option: <em class="italic">NuGet </em><em class="italic">package deployment</em>.</p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor307"/>Understanding NuGet package deployment</h2>
<p>Analyzers and code fixes<a id="_idIndexMarker857"/> can be packed into NuGet packages and deployed to a NuGet feed so others can find them. Once in a NuGet feed, any developer on the team can install the package into one or more projects.</p>
<p>Once a NuGet package is installed, any developer who opens the project will automatically have the package downloaded through the largely invisible NuGet package restore step. If you install a NuGet package and then add, commit, and push the change, other developers will see it automatically installed when they pull your changes and open the project in Visual Studio.</p>
<p>This means that only one developer on your team needs to install any NuGet package, including a package containing Roslyn Analyzers. Additionally, if you ever need to update the package to include new analyzers, any developer on the team can update the version of the package that is installed.</p>
<p>By using NuGet package deployment for Roslyn Analyzers, your analyzers become:</p>
<ul>
<li>Easy to install</li>
<li>Easy to update</li>
<li>Consistently available across all developers on the team</li>
<li>Intentionally associated with the project</li>
</ul>
<p>That last point is an interesting one. With VSIX deployment, analyzers apply to any code that a developer opens on their machine. There is no formal link between the analyzer and your team’s source code, but if a developer has a VSIX analyzer installed, they’ll see its recommendations.</p>
<p>With NuGet packages, you’re explicit about which analyzers should analyze which projects because you explicitly associate them via the NuGet install process. This means that you can look at any project in your solution and get a sense of what analyzer rules should apply for all developers on your project, which is very hard to accomplish through VSIX deployment.</p>
<p>Because of these things, I strongly recommend deploying your analyzers and code fixes as NuGet packages.</p>
<p>Let’s see how that’s done.</p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor308"/>Building a NuGet package</h2>
<p>Visual Studio gives you an easy<a id="_idIndexMarker858"/> way of packaging most .NET projects: just right-click on a project in <strong class="bold">Solution Explorer</strong>, select <strong class="bold">Properties</strong>, and then find the <strong class="bold">General</strong> blade under <strong class="bold">Package</strong> in the navigator. From there, you can check the <strong class="bold">Produce a package file during build operations</strong> checkbox, as shown in <em class="italic">Figure 14</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 14.2 – Enabling NuGet package creation in Visual Studio" src="img/B21324_14_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Enabling NuGet package creation in Visual Studio</p>
<p>When this box is checked, you should see something like the following in your build output after building:</p>
<pre class="console">
1&gt;Successfully created package 'C:\PacktBook\Chapter14\Ch14BeginningCode\Packt.Analyzers\bin\Debug\Packt.Analyzers.1.0.0.nupkg'.
1&gt;Done building project "Packt.Analyzers.csproj".</pre>
<p>The general blade also lets you configure many of the pieces of metadata associated with the package. This lets you specify a readme file or a logo, enter any legal information you need, and more. These pieces of information will later be visible to users considering installing your package.</p>
<p>The many things to consider when configuring a NuGet package for publishing to the public are beyond the scope of this book, but additional resources are listed in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
<p>Unfortunately, when building packages for Roslyn Analyzers, you need to customize more than Visual Studio makes available in the properties user interface.</p>
<p>Double-click on <code>Packt.Analyzers</code> in <code>.csproj</code> file and replace it with<a id="_idIndexMarker859"/> this:</p>
<pre class="source-code">
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
 &lt;PropertyGroup&gt;
   &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
<strong class="bold">   &lt;GeneratePackageOnBuild&gt;True&lt;/GeneratePackageOnBuild&gt;</strong>
<strong class="bold">   &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;</strong>
<strong class="bold">   &lt;Authors&gt;YourName&lt;/Authors&gt;</strong>
<strong class="bold">   &lt;Company&gt;YourCompany&lt;/Company&gt;</strong>
<strong class="bold">   &lt;PackageId&gt;YourCompany.Analyzers&lt;/PackageId&gt;</strong>
<strong class="bold">   &lt;PackageVersion&gt;1.0.0&lt;/PackageVersion&gt;</strong>
<strong class="bold">   &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;</strong>
<strong class="bold">   &lt;Description&gt;</strong>
<strong class="bold">      Sample analyzer with fix from "Refactoring with C#"</strong>
<strong class="bold">      by Matt Eland via Packt Publishing.</strong>
<strong class="bold">   &lt;/Description&gt;</strong>
<strong class="bold">   &lt;PackageProjectUrl&gt;</strong>
<strong class="bold">https://github.com/PacktPublishing/Refactoring-with-CSharp</strong>
<strong class="bold">   &lt;/PackageProjectUrl&gt;</strong>
<strong class="bold">   &lt;RepositoryUrl&gt;https://github.com/PacktPublishing/</strong>
<strong class="bold">Refactoring-with-CSharp&lt;/RepositoryUrl&gt;</strong>
 &lt;/PropertyGroup&gt;
 &lt;ItemGroup&gt;
   &lt;PackageReference Include="Microsoft.CodeAnalysis"
                     Version="4.0.1" /&gt;
<strong class="bold">   </strong><strong class="bold">&lt;None Include="$(OutputPath)\Packt.Analyzers.dll"</strong>
<strong class="bold">         Pack="true"</strong>
<strong class="bold">         PackagePath="analyzers/dotnet/cs"</strong>
<strong class="bold">         Visible="false" /&gt;</strong>
 &lt;/ItemGroup&gt;
&lt;/Project&gt;</pre>
<p>These additional pieces of metadata customize how your package will be installed. Let’s talk about each one of the<a id="_idIndexMarker860"/> relevant changes separately:</p>
<ul>
<li><strong class="bold">GeneratePackageOnBuild</strong> is the same thing as checking the box on the properties page to build the package on build.</li>
<li><code>ItemGroup</code> section.</li>
<li><code>Packt.Analyzers</code>, I recommend using your name without spaces or punctuation in place of <code>Packt</code> to avoid conflicts publishing this.</li>
<li><strong class="bold">PackageVersion</strong> is the release version number of your package. The latest version of a package is typically what people install using NuGet.</li>
<li><strong class="bold">PackageLicenseExpression</strong> is optional, but it allows you to tell others what open-source license, if any, applies to the usage of your package. The various license types and their legal implications are beyond the scope of this book.</li>
<li><strong class="bold">Description</strong> is a short user-friendly description of what the package does and why someone might want to install it.</li>
<li><strong class="bold">RepositoryUrl</strong> is optional and tells others where the package code is available.</li>
</ul>
<p>The really critical part of this file is the <code>None</code> element in the <code>ItemGroup</code>. This step tells the packaging process to take the compiled DLL of the analyzer project and put it in the <code>analyzers/dotnet/cs</code> directory of the NuGet package.</p>
<p>This directory is a special directory that .NET looks at when loading Roslyn Analyzers from various sources. If it doesn’t see your analyzers there, those analyzers will not be loaded.</p>
<p>With these steps configured and the file saved, rebuild the project and you should see your NuGet package created inside the <code>bin\Debug</code> or <code>bin\Release</code> directory of your <code>Packt.Analyzers</code> project.</p>
<p class="callout-heading">Debug vs Release builds</p>
<p class="callout">When publishing<a id="_idIndexMarker861"/> software, you’ll<a id="_idIndexMarker862"/> want to use the <code>Release</code> configuration instead of <code>Debug</code>. The <code>Debug</code> configuration suppresses certain compiler optimizations and adds extra build byproducts that help you debug your applications. <code>Release</code> builds tend to be smaller and faster and are generally recommended. You can change which configuration is active using the main toolbar in Visual Studio.</p>
<p>Once your <code>.nupkg</code> file is <a id="_idIndexMarker863"/>created, you’re ready to publish it for others to use.</p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor309"/>Deploying the NuGet package</h2>
<p>Now that we <a id="_idIndexMarker864"/>have a <code>.nupkg</code> file, we can deploy it to any NuGet feed. This can be a feed you set up yourself at your organization, a private NuGet registry on GitHub, or a public NuGet feed such as the one at <code>NuGet.org</code>.</p>
<p>Because <code>NuGet.org</code> is the standard place for sharing open-source code packages, we’ll explore this path in this chapter. If your code is proprietary and you only want to share it within your organization, it should not go on <code>NuGet.org</code>.</p>
<p class="callout-heading">NuGet hosting options</p>
<p class="callout">If you’d like to host<a id="_idIndexMarker865"/> your NuGet packages outside of <code>NuGet.org</code>, you have a few options including setting up a private NuGet server or using a team-shared NuGet repository service such as those offered on GitHub. See the <em class="italic">Further reading</em> section for more information.</p>
<p>To get started, navigate to <a href="http://NuGet.org">NuGet.org</a>, create a user, and then log in as that user.</p>
<p>Once you are authenticated, click on the <strong class="bold">Upload</strong> tab to begin the process of uploading a NuGet package. This will allow you to drag and drop or click <strong class="bold">Browse…</strong> to find your NuGet package, as shown in <em class="italic">Figure 14</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 14.3 – Uploading a NuGet package" src="img/B21324_14_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Uploading a NuGet package</p>
<p>If you need help finding your <code>.nupkg</code> file, it should be inside of the <code>Packt.Analyzers</code> project in the <code>\bin\Debug</code> folder or the <code>\bin\Release</code> folder depending on if you<a id="_idIndexMarker866"/> build your project in <code>Debug</code> or <code>Release</code> mode.</p>
<p class="callout-heading">Tip</p>
<p class="callout">It’s always best to publish <code>Release</code> builds when sharing code with others.</p>
<p>Once you’ve selected your NuGet package, the page will update with the information it detects about your package. This includes the version number, license file, readme file, and other information. While it’s best to configure these values in Visual Studio, some things, such as the readme file, can be customized here before publishing.</p>
<p>If something doesn’t look right, you can create a new <code>.nupkg</code> file and upload that file.</p>
<p>Once you’re satisfied with the information on the preview screen, click <code>NuGet.org</code> will begin checking your file for anything harmful and indexing the package so others can import it.</p>
<p>This process typically takes 5 to 15 minutes but can vary. If you want to check on the status of your package, you can refresh the package details page found in <em class="italic">Figure 14</em><em class="italic">.4</em> to check on the status.</p>
<div><div><img alt="Figure 14.4 – NuGet.org checking and indexing a package" src="img/B21324_14_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – NuGet.org checking and indexing a package</p>
<p>Once this process <a id="_idIndexMarker867"/>finishes, you’re ready to reference the package in Visual Studio.</p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor310"/>Referencing the NuGet package</h2>
<p>Once your package is<a id="_idIndexMarker868"/> published on <code>NuGet.org</code>, you can reference it in any compatible .NET project.</p>
<p>To prove this, open a solution from a previous chapter or create a new console application. Next, choose <strong class="bold">Manage NuGet Packages…</strong> for that project in <strong class="bold">Solution Explorer</strong>.</p>
<p>Once <strong class="bold">NuGet Package Manager</strong> comes up, go to the <strong class="bold">Browse</strong> tab and search for your package by its name. Assuming the name is correct and your package has finished indexing, you should see the package in <em class="italic">Figure 14</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 14.5 – Referencing your package in NuGet Package Manager" src="img/B21324_14_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Referencing your package in NuGet Package Manager</p>
<p>Click <strong class="bold">Install</strong> to install the latest published version of your package and notice the dependencies and license terms that appear based on your choices when creating the NuGet package.</p>
<p>Once your package is<a id="_idIndexMarker869"/> installed, your analyzer will now be active and will appear inside of the <strong class="bold">Analyzers</strong> node nested inside of the project’s <strong class="bold">Dependencies</strong> node in <strong class="bold">Solution Explorer</strong>, as shown in <em class="italic">Figure 14</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 14.6 – Our analyzers package installed and active in a project" src="img/B21324_14_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Our analyzers package installed and active in a project</p>
<p>The analyzer will also be active for any class in your project and it will provide suggestions and code fixes.</p>
<p>Once you commit and push your changes to the project, others on your team will pull down the reference to the new NuGet dependency. Visual Studio will then restore your NuGet packages and install the analyzer locally into that project for your coworkers.</p>
<p>If you ever need to update your NuGet package, you can create a new version of the package and upload it to <code>NuGet.org</code>. Once the new version is indexed, you’ll be able to update the installed version of the package from NuGet Package Manager.</p>
<p>The NuGet deployment <a id="_idIndexMarker870"/>process makes it easy to install and update packages in your project that are then available to every developer on your team. This is why this process is my default recommendation for sharing your Roslyn Analyzers with your team.</p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor311"/>Packaging a CodeFixProvider as an extension</h2>
<p>If you want to<a id="_idIndexMarker871"/> package your code fix in a VSIX <a id="_idIndexMarker872"/>extension, you can do that in largely the same way as we did in <a href="B21324_13.xhtml#_idTextAnchor275"><em class="italic">Chapter 13</em></a> with one additional change.</p>
<p>To get your <code>CodeFixProvider</code> to work in the extension, you’ll need to add a <strong class="bold">Managed Extensibility Framework (MEF)</strong> asset <a id="_idIndexMarker873"/>to your installer’s manifest.</p>
<p>To do this, go to the <strong class="bold">Assets</strong> pane of your Installer project’s manifest and click <strong class="bold">New</strong>.</p>
<p>Next, select <strong class="bold">Microsoft.VisualStudio.MefComponent</strong> as the type, specify the source as <strong class="bold">A project in current solution</strong>, and specify your analyzers project as the project (see <em class="italic">Figure 14</em><em class="italic">.7</em> for an example).</p>
<div><div><img alt="Figure 14.7 – Adding an MEF component asset to the installer manifest" src="img/B21324_14_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – Adding an MEF component asset to the installer manifest</p>
<p>This change will ensure your code fix is properly registered by the installer.</p>
<p>In my experience, it’s usually easier to maintain analyzers via a NuGet package than a VSIX installer, but <a id="_idIndexMarker874"/>both <a id="_idIndexMarker875"/>deployment models have their advantages. Pick the approach that makes the most sense for your installation, updating, and security needs.</p>
<h1 id="_idParaDest-313"><a id="_idTextAnchor312"/>Summary</h1>
<p>In this chapter, we saw how Roslyn Analyzers can be extended to provide code fixes along with the diagnostic information they already provided.</p>
<p>Code fixes work by interpreting the tree structure of your code and making modifications to that structure, resulting in a new document or solution. Visual Studio then reacts to these changes by updating the source code.</p>
<p>This means that code fixes can automatically make pre-configured modifications to your code to address known issues in a repeatable and safe manner.</p>
<p>We also discussed how NuGet package deployment allows you to wrap up your Roslyn Analyzers into a package and share them with other developers – either other developers on your team or other developers worldwide.</p>
<p>This concludes <em class="italic">Part 3</em> of this book. In the final part of this book, we’ll explore some of the unique challenges and opportunities found in refactoring code in real-world organizations and teams.</p>
<h1 id="_idParaDest-314"><a id="_idTextAnchor313"/>Questions</h1>
<ol>
<li>What is the relationship between a <code>DiagnosticAnalyzer</code> and a <code>CodeFixProvider</code>?</li>
<li>How can you test a code fix?</li>
<li>What are some of the advantages of NuGet deployment versus VSIX deployment?</li>
</ol>
<h1 id="_idParaDest-315"><a id="_idTextAnchor314"/>Further reading</h1>
<p>You can find more information about materials from this chapter at the following URLs:</p>
<ul>
<li><em class="italic">Get started with syntax </em><em class="italic">transformation</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/syntax-transformation">https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/syntax-transformation</a></li>
<li><em class="italic">Configuring and Publishing NuGet </em><em class="italic">Packages</em>: <a href="https://learn.microsoft.com/en-us/nuget/quickstart/create-and-publish-a-package-using-visual-studio?tabs=netcore-cli">https://learn.microsoft.com/en-us/nuget/quickstart/create-and-publish-a-package-using-visual-studio?tabs=netcore-cli</a><a href="https://learn.microsoft.com/en-us/nuget/quickstart/create-and-publish-a-package-using-visual-studio "/></li>
<li><em class="italic">Hosting your own NuGet </em><em class="italic">feeds</em>: <a href="https://learn.microsoft.com/en-us/nuget/hosting-packages/overview ">https://learn.microsoft.com/en-us/nuget/hosting-packages/overview</a></li>
<li><em class="italic">Working with NuGet on </em><em class="italic">GitHub</em>: <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-nuget-registry">https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-nuget-registry</a></li>
</ul>
</div>


<div><h1 id="_idParaDest-316" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor315"/>Part 4: Refactoring in the Enterprise</h1>
<p>In the fourth and final part of the book, we focus on the social aspects of refactoring: communicating technical debt to others, adopting code standards as an engineering organization, and refactoring in agile environments.</p>
<p>Convincing a large team or organization of the importance of refactoring can be a critical battle, and so this part looks at how software engineers can partner with business leaders. These chapters contain key tips and tricks to ensure that refactoring actually happens and that the right areas of technical debt get refactored first.</p>
<p>We specifically focus on refactoring in an agile environment and how to handle refactoring scenarios that are so large that it feels like a complete rewrite is necessary.</p>
<p>This part contains the following chapters:</p>
<ul>
<li><a href="B21324_15.xhtml#_idTextAnchor316"><em class="italic">Chapter 15</em></a><em class="italic">, Communicating Technical Debt</em></li>
<li><a href="B21324_16.xhtml#_idTextAnchor341"><em class="italic">Chapter 16</em></a><em class="italic">, Adopting Code Standards</em></li>
<li><a href="B21324_17.xhtml#_idTextAnchor354"><em class="italic">Chapter 17</em></a><em class="italic">, Agile Refactoring</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>