<html><head></head><body>
		<div id="_idContainer050">
			<h1 id="_idParaDest-96"><em class="italic"><a id="_idTextAnchor146"/>Chapter 5</em>: Exploring the ASP.NET Core and ABP Infrastructure</h1>
			<p>Both ASP.NET Core and ABP Framework provide many building blocks and features for modern application development. This chapter will explore the most basic building blocks so that you can understand how an application is configured and initialized.</p>
			<p>We will start with the ASP.NET Core <strong class="source-inline">Startup</strong> class to understand why we need a modular system and how ABP provides a modular way to configure and initialize an application. Then we will explore the ASP.NET Core dependency injection system and ABP's way of automating dependency injection registration with predefined rules. We will continue by looking at configuration and the options pattern to learn ASP.NET Core's way of configuring the options of ASP.NET Core and other libraries.</p>
			<p>Here are all the topics we'll cover in this chapter:</p>
			<ul>
				<li>Understanding modularity</li>
				<li>Using the dependency injection system</li>
				<li>Configuring an application</li>
				<li>Implementing the options pattern</li>
				<li>Logging</li>
			</ul>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor147"/>Technical requirements</h1>
			<p>If you want to follow and try the examples, you need to have installed an IDE/editor (such as Visual Studio) to build the ASP.NET Core projects.</p>
			<p>You can download the code examples from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor148"/>Understanding modularity</h1>
			<p><strong class="bold">Modularity</strong> is a design technique for breaking down the functionalities of a large software into smaller parts and allowing each part to communicate with the others through standardized interfaces as needed. Modularity has the following main benefits:</p>
			<ul>
				<li>It reduces complexity when every module is designed to be isolated from the other modules, and inter-module communications are well defined and limited.</li>
				<li>It provides flexibility when you design modules to be loosely coupled. You can refactor or even replace a module in the future.</li>
				<li>It allows re-using modules across applications when you design them to be application-independent.</li>
			</ul>
			<p>Most enterprise software systems are designed to be modular. However, implementing modularity is not easy, and the plain ASP.NET Core doesn't help much. One of ABP Framework's main goals is to provide infrastructure and tooling to develop truly modular systems. We will cover modular application development in <a href="B17287_15_Epub_AM.xhtml#_idTextAnchor443"><em class="italic">Chapter 15</em></a><em class="italic">, Working with Modularity</em>, but this section introduces the basics of ABP modules.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor149"/>The Startup class</h2>
			<p>Before defining a module class, it is best to remember the <strong class="source-inline">Startup</strong> class in ASP.NET Core to understand the need for module classes. The following code block shows a <strong class="source-inline">Startup</strong> class in a simple ASP.NET Core application:</p>
			<p class="source-code">public class Startup</p>
			<p class="source-code">{</p>
			<p class="source-code">    public void ConfigureServices(IServiceCollection                 services)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        services.AddMvc();</p>
			<p class="source-code">        services.AddTransient&lt;MyService&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void Configure(</p>
			<p class="source-code">        IApplicationBuilder app, IWebHostEnvironment env)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        app.UseRouting();</p>
			<p class="source-code">        if (env.IsDevelopment())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            app.UseDeveloperExceptionPage();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        app.UseEndpoints(endpoints =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            endpoints.MapControllers();</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">ConfigureServices</strong> method is used to configure other services and register new services to the dependency injection system. The <strong class="source-inline">Configure</strong> method, on the other hand, is used to configure the <strong class="bold">ASP.NET Core request pipeline</strong> that processes the HTTP requests through middleware components.</p>
			<p>Once you have the <strong class="source-inline">Startup</strong> class, you typically register it in the <strong class="source-inline">Program.cs</strong> file while configuring the host builder so that it works on application startup:</p>
			<p class="source-code">public class Program</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static void Main(string[] args)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        CreateHostBuilder(args).Build().Run();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static IHostBuilder CreateHostBuilder(string[]           args) =&gt;</p>
			<p class="source-code">        Host.CreateDefaultBuilder(args)</p>
			<p class="source-code">            .ConfigureWebHostDefaults(webBuilder =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                webBuilder.UseStartup&lt;Startup&gt;();</p>
			<p class="source-code">            });</p>
			<p class="source-code">}</p>
			<p>These code parts are already included in ASP.NET Core's startup templates, so you normally don't write them manually.</p>
			<p>The problem with the <strong class="source-inline">Startup</strong> class is that it is unique. That means you have only a single point to configure and initialize all your application services. However, in a modular application, you expect that every module configures and initializes the services related to that particular module. Also, it is typical that a module uses or depends on other modules, so the modules should be configured and initialized in the correct order. That is where ABP's module definition class comes into play.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor150"/>Defining a module class</h2>
			<p>An ABP module is a group of types (such as classes or interfaces) developed and shipped together. It is an assembly (a <em class="italic">project</em> in Visual Studio) with a module class derived from <strong class="source-inline">AbpModule</strong>. The module class is responsible for configuring and initializing that module and configures any dependent modules if necessary.</p>
			<p>Here is a simple module definition class for an SMS sending module:</p>
			<p class="source-code">using Microsoft.Extensions.DependencyInjection;</p>
			<p class="source-code">using Volo.Abp.Modularity;</p>
			<p class="source-code">namespace SmsSending</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class SmsSendingModule : AbpModule </p>
			<p class="source-code">    {</p>
			<p class="source-code">        public override void ConfigureServices(</p>
			<p class="source-code">            ServiceConfigurationContext context)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            context.Services.AddTransient&lt;SmsService&gt;();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Every module can override the <strong class="source-inline">ConfigureServices</strong> method in order to register its services to the dependency injection system and configure the other modules. The module in this example registers <strong class="source-inline">SmsService</strong> to a dependency injection system with a transient lifetime. I've written this example to show the same registration code done in the <strong class="source-inline">Startup</strong> class in the previous section. However, most of the time, you don't need to register your services manually, thanks to ABP Framework's conventional registration system explained in the <em class="italic">Using the dependency injection system</em> section of this chapter.</p>
			<p>The <strong class="source-inline">AbpModule</strong> class defines the <strong class="source-inline">OnApplicationInitialization</strong> method that is executed after the service registration phase is complete and the application is ready to run. With this method, you can execute any operation you need to perform on application startup. For example, you can initialize a service:</p>
			<p class="source-code">public class SmsSendingModule : AbpModule </p>
			<p class="source-code">{</p>
			<p class="source-code">    //...</p>
			<p class="source-code">    <a id="_idTextAnchor151"/>public override void OnApplicationInitialization(</p>
			<p class="source-code">        ApplicationInitializationContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var service = context.ServiceProvider</p>
			<p class="source-code">            .GetRequiredService&lt;SmsService&gt;();</p>
			<p class="source-code">        service.Initialize();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this code block, we are using <strong class="source-inline">context.ServiceProvider</strong> to request a service from the dependency injection system and initialize the service. We can request services because the dependency injection system is ready at this point.</p>
			<p>You can also think of the <strong class="source-inline">OnApplicationInitialization</strong> method as the <strong class="source-inline">Configure</strong> method of the <strong class="source-inline">Startup</strong> class. So, you can build the ASP.NET Core request pipeline here. However, you typically configure the request pipeline in the startup module, as explained in the next section.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor152"/>Module dependencies and the startup module</h2>
			<p>A business application generally consists of more than one module, and ABP Framework allows you to declare dependencies between modules. An application should always have a <strong class="bold">startup module</strong>. The startup module can have dependencies on some modules, and these modules can have dependencies on some other modules, and so on.</p>
			<p>The following diagram shows a simple module dependency graph:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_5.1_B17287.jpg" alt="Figure 5.1 – Example module dependency graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Example module dependency graph</p>
			<p>ABP respects module dependencies<a id="_idIndexMarker239"/> and initializes modules based on the dependency<a id="_idIndexMarker240"/> graph. If module A depends on module B, then module B is always initialized before module A. That allows module A to use, set, change, or override configurations and services defined by module B.</p>
			<p>For the example graph in <em class="italic">Figure 5.1</em>, the module initialization will be in the following order: G, F, E, D, B, C, A. You don't have to know the exact initialization order; only know that if your module depends on module <em class="italic">X</em>, then module <em class="italic">X </em> is initialized before your module.</p>
			<p>Defining a module dependency is declared with the <strong class="source-inline">[DependsOn]</strong> attribute of a module<a id="_idTextAnchor153"/>:</p>
			<p class="source-code">[DependsOn(typeof(ModuleB), typeof(ModuleC))]</p>
			<p class="source-code">public class ModuleA : AbpModule</p>
			<p class="source-code">{    </p>
			<p class="source-code">}</p>
			<p>In the preceding code block, <strong class="source-inline">ModuleA</strong> depends on <strong class="source-inline">ModuleB</strong> and <strong class="source-inline">ModuleC</strong> by declaring the <strong class="source-inline">[DependsOn]</strong> attribute.</p>
			<p>For an ASP.NET Core application, the startup<a id="_idIndexMarker241"/> module (<strong class="source-inline">ModuleA</strong> in this example) is responsible for setting up<a id="_idIndexMarker242"/> the ASP.NET Core request pipeline:</p>
			<p class="source-code">[DependsOn(typeof(ModuleB), typeof(ModuleC))]</p>
			<p class="source-code">public class ModuleA : AbpModule</p>
			<p class="source-code">{</p>
			<p class="source-code">    //...</p>
			<p class="source-code">    public override void OnApplicationInitialization(</p>
			<p class="source-code">        ApplicationInitializationContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var app = context.GetApplicationBuilder();</p>
			<p class="source-code">        var env = context.GetEnvironment();</p>
			<p class="source-code">        </p>
			<p class="source-code">        app.UseRouting();</p>
			<p class="source-code">        if (env.IsDevelopment())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            app.UseDeveloperExceptionPage();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        app.UseEndpoints(endpoints =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            endpoints.MapControllers();</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>With this code block, we've built the same ASP.NET Core request pipeline built previously in the <em class="italic">The Startup class</em> section. <strong class="source-inline">context.GetApplicationBuilder()</strong> and <strong class="source-inline">context.GetEnvironment()</strong> are just shortcuts to obtain the standard <strong class="source-inline">IApplicationBuilder</strong> and <strong class="source-inline">IWebHostEnvironment</strong> services from the dependency injection system.</p>
			<p>Then, we can use<a id="_idIndexMarker243"/> this module in the <strong class="source-inline">Startup</strong> class<a id="_idIndexMarker244"/> of ASP.NET Core to integrate ABP Framework with ASP.NET Core:</p>
			<p class="source-code">public class Startup</p>
			<p class="source-code">{</p>
			<p class="source-code">    public void ConfigureServices(IServiceCollection                 services)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        services.AddApplication&lt;ModuleA&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void Configure(IApplicationBuilder app)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        app.InitializeApplication();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">services.AddApplication()</strong> method is defined by ABP Framework to configure the modules. It basically execute<a id="_idTextAnchor154"/>s the <strong class="source-inline">ConfigureServices</strong> methods of all the modules by respecting the order of module dependencies. The  <strong class="source-inline">app.InitializeApplication()</strong> method is also defined by ABP Framework; similarly, it executes the <strong class="source-inline">OnApplicationInitialization</strong> methods of all the modules by respecting the order of module dependencies.</p>
			<p>The <strong class="source-inline">ConfigureServices</strong> and <strong class="source-inline">OnApplicationInitialization</strong> methods are the most commonly used methods in a module class; there are more methods explained in the next section.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor155"/>Module lifecycle methods</h2>
			<p>The <strong class="source-inline">AbpModule</strong> class defines useful methods that you can override to execute code on application startup and shutdown. We saw <strong class="source-inline">ConfigureServices</strong> and <strong class="source-inline">OnApplicationInitialization</strong> in the previous section; here is a list<a id="_idIndexMarker245"/> of all the lifecycle methods:</p>
			<ul>
				<li><strong class="source-inline">PreConfigureServices</strong>: This method is called before the <strong class="source-inline">ConfigureServices</strong> method. It allows you to write code to be executed before <strong class="source-inline">ConfigureServices</strong> of the depended-upon modules.</li>
				<li><strong class="source-inline">ConfigureServices</strong>: This is the main method to configure the module and register services, as explained in the previous section.</li>
				<li><strong class="source-inline">PostConfigureServices</strong>: This method is called after the <strong class="source-inline">ConfigureServices</strong> method of all the modules (including the modules depending on your module), so you may perform a final configuration.</li>
				<li><strong class="source-inline">OnPreApplicationInitialization</strong>: This method is called before the <strong class="source-inline">OnApplicationInitialization</strong> method. In this stage, you can resolve services from dependency injection.</li>
				<li><strong class="source-inline">OnApplicationInitialization</strong>: This method allows your module to configure the ASP.NET Core request pipeline and initialize your services, as explained in the previous section.</li>
				<li><strong class="source-inline">OnPostApplicationInitialization</strong>: This method is called in the initialization phase.</li>
				<li><strong class="source-inline">OnApplicationShutdown</strong>: You can implement your module's shutdown logic if necessary.</li>
			</ul>
			<p><strong class="source-inline">Pre…</strong> and <strong class="source-inline">Post…</strong> methods (such as <strong class="source-inline">PreConfigureServices</strong> and <strong class="source-inline">PostConfigureServices</strong>) have the same purpose as the original method. They are rarely used and provide a way to perform some configuration/initialization code that works before or after all other modules.</p>
			<p class="callout-heading">Asynchronous Lifecycle Methods</p>
			<p class="callout">The lifecycle methods explained in this section are synchronous. At the time of writing this book, the ABP Framework team<a id="_idIndexMarker246"/> was working to introduce asynchronous lifecycle methods with ABP Framework version 5.1. You can see <a href="https://github.com/abpframework/abp/pull/10928">https://github.com/abpframework/abp/pull/10928</a> for details.</p>
			<p>As explained before, a module class mainly contains code to register and configure services related to that module. In the next section, we will see how to register services with ABP Framework.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor156"/>Using the dependency injection system</h1>
			<p>Dependency injection<a id="_idIndexMarker247"/> is a technique for obtaining a class's dependencies. It separates creating a class from using that class.</p>
			<p>Assume that we have a <strong class="source-inline">UserRegistrationService</strong> class that uses <strong class="source-inline">SmsService</strong> to send a verification SMS, as shown<a id="_idIndexMarker248"/> in the following co<a id="_idTextAnchor157"/>de block:</p>
			<p class="source-code">public class UserRegistrationService</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly SmsService _smsService;</p>
			<p class="source-code">    public UserRegistrationService(SmsService smsService)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _smsService = smsService;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public async Task RegisterAsync(</p>
			<p class="source-code">        string username,</p>
			<p class="source-code">        string password,</p>
			<p class="source-code">        string phoneNumber)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //...save user in the database</p>
			<p class="source-code">        await _smsService.SendAsync(</p>
			<p class="source-code">            phoneNumber,</p>
			<p class="source-code">            "Your verification code: 1234"</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">SmsService</strong> has been obtained using the <strong class="bold">Constructor-Injection pattern</strong>. Using the Constructor-Injection pattern<a id="_idIndexMarker249"/> practically means that we define parameters in the constructor of our class, then we let the dependency injection system instantiate the class's dependencies and pass them to the constructor of our class. We then assign these object instances to the fields in our class to use later in our methods. <strong class="source-inline">SmsService</strong>, in this example, is used in the <strong class="source-inline">RegisterAsync</strong> method to send a verification code after saving the user into the database.</p>
			<p>ASP.NET Core natively provides a dependency injection<a id="_idIndexMarker250"/> infrastructure<span class="Annotation-reference">,</span> and ABP leverages this infrastructure rather than using a third-party dependency injection framework. Once you register all the services to the dependency injection system, any service can constructor-inject the dependent services without dealing with creating them (and their dependencies).</p>
			<p>The most important thing you should consider while designing your services is the service lifetime.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor158"/>Service lifetime</h2>
			<p>ASP.NET Core<a id="_idIndexMarker251"/> offers different lifetime options on service registration, so we should select a lifetime for every service. There are three lifetimes in ASP.NET Core:</p>
			<ul>
				<li><strong class="bold">Transient</strong>: Transient <a id="_idIndexMarker252"/>services are created whenever<a id="_idIndexMarker253"/> you inject them. Every time you request/inject the service, a new instance is created.</li>
				<li><strong class="bold">Scoped</strong>: Scoped services <a id="_idIndexMarker254"/>are created per scope. This is generally considered by request lifetime, as each HTTP request<a id="_idIndexMarker255"/> creates a new scope in ASP.NET Core. You share the same instance in the same scope and get a different instance in different scope.</li>
				<li><strong class="bold">Singleton</strong>: A<a id="_idIndexMarker256"/> singleton service<a id="_idIndexMarker257"/> has only a single instance in an application. All the requests and clients use the same instance. The object is created the first time you request it. Then the same object instance is reused in the subsequent requests.</li>
			</ul>
			<p>The following module registers two services, one as transient and the other as a singleton:</p>
			<p class="source-code">public class MyModule : AbpModule</p>
			<p class="source-code">{</p>
			<p class="source-code">    public override void ConfigureServices(</p>
			<p class="source-code">        ServiceConfigurationContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        context.Services.AddTransient&lt;ISmsService,                       SmsService&gt;();</p>
			<p class="source-code">        context.Services.AddSingleton&lt;OtherService&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">context.Services</strong> is a type of <strong class="source-inline">IServiceCollection</strong>, and all the ASP.NET Core extension methods can be used to register and configure your services manually.</p>
			<p>In the first example, <strong class="source-inline">AddTransient&lt;ISmsService, SmsService&gt;()</strong>, I've registered the <strong class="source-inline">SmsService</strong> class with the <strong class="source-inline">ISmsService</strong> interface. In this way, whenever I inject <strong class="source-inline">ISmsService</strong>, the dependency injection system creates an <strong class="source-inline">SmsService</strong> object for me. For the second example, <strong class="source-inline">AddSingleton&lt;OtherService&gt;()</strong>, I've registered <strong class="source-inline">OtherService</strong> as a singleton with the class reference. To use this service, I should inject the <strong class="source-inline">OtherService</strong> class reference.</p>
			<p class="callout-heading">Scoped Dependencies and ASP.NET Core's Dependency Injection Documentation</p>
			<p class="callout">As mentioned, scoped services<a id="_idIndexMarker258"/> are created per HTTP request for an ASP.NET Core application by default. For non-ASP.NET Core applications, you may need to manage scopes yourself. Please refer to ASP.NET Core's documentation for all the details<a id="_idIndexMarker259"/> of the dependency injection system: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</a>.</p>
			<p>When you use ABP Framework, you don't have to think so much about service registration, thanks to ABP Framework's conventional and declarative service registration system.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor159"/>Conventional service registrations</h2>
			<p>In ASP.NET Core, you should explicitly register all your services to <strong class="source-inline">IServiceCollection</strong>, as shown in the previous section. However, most of these registrations are just repetitive code and can be automated.</p>
			<p>ABP automatically registers services for dependency injection<a id="_idIndexMarker260"/> for the following types:</p>
			<ul>
				<li>MVC controllers</li>
				<li>Razor page models</li>
				<li>View components</li>
				<li>Razor components</li>
				<li>SignalR hubs</li>
				<li>Application services</li>
				<li>Domain services</li>
				<li>Repositories</li>
			</ul>
			<p>All these services are registered with the transient lifetime. So, you don't need<a id="_idIndexMarker261"/> to care about service registration for these kinds of classes. If you have another class type, you can use one of the dependency interfaces, or the <strong class="source-inline">Dependency</strong> attribute as explained in the next sections.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor160"/>Dependency interfaces</h2>
			<p>You can implement an <strong class="source-inline">ITransientDependency</strong>, <strong class="source-inline">IScopedDependency</strong>, or <strong class="source-inline">ISingletonDependency</strong> interface to register your service for dependency injection. For example, in this code block, we've registered the service as a singleton, so only one shared instance<a id="_idIndexMarker262"/> is created in the application's lifetime:</p>
			<p class="source-code">public class UserPermissionCache : ISingletonDependency</p>
			<p class="source-code">{ }</p>
			<p>Dependency interfaces are easy and the suggested way for most cases, but they are limited compared to the <strong class="source-inline">Dependency</strong> attribute.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor161"/>The Dependency attribute</h2>
			<p>The <strong class="source-inline">Dependency</strong> attribute provides options<a id="_idIndexMarker263"/> for fine control of dependency registration with the following properties:</p>
			<ul>
				<li><strong class="source-inline">Lifetime</strong> (<strong class="source-inline">enum</strong>): The lifetime of the service: <strong class="source-inline">Singleton</strong>, <strong class="source-inline">Transient</strong>, or <strong class="source-inline">Scoped</strong></li>
				<li><strong class="source-inline">TryRegister</strong> (<strong class="source-inline">bool</strong>): Registers the service only if it's not already registered</li>
				<li><strong class="source-inline">ReplaceServices</strong> (<strong class="source-inline">bool</strong>): Replaces the previous registration if the service is already registered</li>
			</ul>
			<p>Here is an example of service registration using the <strong class="source-inline">Dependency</strong> attribute:</p>
			<p class="source-code">using Microsoft.Extensions.DependencyInjection;</p>
			<p class="source-code">using Volo.Abp.DependencyInjection;</p>
			<p class="source-code">namespace UserManagement</p>
			<p class="source-code">{</p>
			<p class="source-code">    [Dependency(ServiceLifetime.Transient, TryRegister =         true)]</p>
			<p class="source-code">    public class UserPermissionCache</p>
			<p class="source-code">    { }</p>
			<p class="source-code">}</p>
			<p>Here, I used the <strong class="source-inline">[Dependency]</strong> attribute with a <strong class="source-inline">Transient</strong> lifetime and also with the <strong class="source-inline">TryRegister</strong> option to register the class to the dependency injection system.</p>
			<p class="callout-heading">Dependency Attribute versus Dependency Interfaces</p>
			<p class="callout">The <strong class="source-inline">Dependency</strong> attribute<a id="_idIndexMarker264"/> can be used alongside the dependency interfaces introduced in the previous section. The <strong class="source-inline">Dependency</strong> attribute has a higher priority than the dependency interfaces if it defines the <strong class="source-inline">Lifetime</strong> property.</p>
			<p>Registering a class to the dependency injection<a id="_idIndexMarker265"/> system makes it usable in an application. However, a class may be injected with different types of class or interface references, depending on what service types are exposed by that class.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor162"/>Exposing services</h2>
			<p>When a class doesn't implement an interface, it can only be injected<a id="_idIndexMarker266"/> by the class reference. The <strong class="source-inline">UserPermissionCache</strong> class in the previous section is used by directly injecting the class type. However, it is common to implement interfaces for services.</p>
			<p>Assume that we have an interface to abstract the SMS sending:</p>
			<p class="source-code">public interface ISmsService</p>
			<p class="source-code">{</p>
			<p class="source-code">    Task SendAsync(string phoneNumber, string message);</p>
			<p class="source-code">}</p>
			<p>That is a pretty simple interface that only has a single method to send an SMS. Assume that you want to implement the <strong class="source-inline">ISmsService</strong> interface by using Azure:</p>
			<p class="source-code">public class AzureSmsService : ISmsService, ITransientDependency</p>
			<p class="source-code">{</p>
			<p class="source-code">    public async Task SendAsync(string phoneNumber, string message)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //TODO: ...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">AzureSmsService</strong> class implements the <strong class="source-inline">ISmsService</strong> and <strong class="source-inline">ITransientDependency</strong> interfaces. The <strong class="source-inline">ITransientDependency</strong> interface is only for registering this service for dependency injection, as explained in the previous section.</p>
			<p>You typically want to use the <strong class="source-inline">AzureSmsService</strong> class by injecting the <strong class="source-inline">ISmsService</strong> interface. ABP is smart enough<a id="_idIndexMarker267"/> to understand your purpose and automatically registers the <strong class="source-inline">AzureSmsService</strong> class for the <strong class="source-inline">ISmsService</strong> interface. You can consume the <strong class="source-inline">AzureSmsService</strong> class either by injecting the <strong class="source-inline">ISmsService</strong> interface or the <strong class="source-inline">AzureSmsService</strong> class reference. Injecting the <strong class="source-inline">AzureSmsService</strong> class by the <strong class="source-inline">ISmsService</strong> interface is possible by its naming conventions: the <strong class="source-inline">ISmsService</strong> interface is the <em class="italic">default interface</em> for the <strong class="source-inline">AzureSmsService</strong> class because it ends with the <strong class="source-inline">SmsService</strong> suffix.</p>
			<p>Assume that we have a class that implements multiple interfaces as shown in the following code block:</p>
			<p class="source-code">public class PdfExporter: IExporter, IPdfExporter, ICanExport, ITransientDependency</p>
			<p class="source-code">{ }</p>
			<p>The <strong class="source-inline">PdfExporter</strong> service can be used by injecting the <strong class="source-inline">IPdfExporter</strong> and <strong class="source-inline">IExporter</strong> interfaces or directly with the <strong class="source-inline">PdfExporter</strong> class reference. However, you can't inject it using the <strong class="source-inline">ICanExport</strong> interface because the name of <strong class="source-inline">PdfExporter</strong> doesn't end with <strong class="source-inline">CanExport</strong>.</p>
			<p>If you need to change the default<a id="_idIndexMarker268"/> behavior, you can use the <strong class="source-inline">ExposeServices</strong> attribute, as shown in the following code block:</p>
			<p class="source-code">[ExposeServices(typeof(IPdfExporter))]</p>
			<p class="source-code">public class PdfExporter: IExporter, IPdfExporter, ICanExport, ITransientDependency</p>
			<p class="source-code">{ }</p>
			<p>Now, you can use the <strong class="source-inline">PdfExporter</strong> class only by injecting the <strong class="source-inline">IPdfExporter</strong> interface.</p>
			<p class="callout-heading">Question: Should I Define Interfaces for Each Service?</p>
			<p class="callout">One potential question you may ask is whether you should define interfaces for your services and inject them using interfaces. ABP doesn't force you to do anything here, and general interface best practices are applicable: define interfaces if you want to loosely couple your services, have multiple implementations of a service, mock in unit tests easily, physically separate interfaces from the implementations (say, we define application service interfaces in the <strong class="source-inline">Application.Contracts</strong> project and implement them in the <strong class="source-inline">Application</strong> project, or we define repository interfaces in the domain layer but implement them in the infrastructure layer), and so on.</p>
			<p>We've seen how to register and consume services. Some services or libraries have options, and you may need to configure them before using them. The next two sections explain the standard infrastructure and patterns to configure options provided by such services and libraries.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor163"/>Configuring an application</h1>
			<p>ASP.NET Core's <strong class="bold">configuration</strong> system provides a<a id="_idIndexMarker269"/> convenient way to read<a id="_idIndexMarker270"/> key-value-based configurations for applications. It is an extensible system and can read key-value pairs from various resources, such as JSON settings files, environment<a id="_idIndexMarker271"/> variables, command-line arguments, and Azure Key Vault.</p>
			<p class="callout-heading">ABP Framework versus ASP.NET Core's Configuration System</p>
			<p class="callout">ABP Framework<a id="_idIndexMarker272"/> doesn't add a specific feature to ASP.NET Core's configuration system. However, it is essential to understand it to work with ASP.NET Core and ABP Framework properly. I will cover the basics in this book. Please see ASP.NET Core's<a id="_idIndexMarker273"/> documentation for a complete reference: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration</a>.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor164"/>Setting the configuration values</h2>
			<p>The easiest way to set a configuration<a id="_idIndexMarker274"/> value is to use the <strong class="source-inline">appsettings.json</strong> file by default. Assume that we are building a service to send SMS using Azure, and we need the following configuration values:</p>
			<ul>
				<li><strong class="source-inline">Sender</strong>: The sender number shown to the target user</li>
				<li><strong class="source-inline">ConnectionString</strong>: The connection string of your Azure resouce</li>
			</ul>
			<p>We can define these settings in the configuration section of the <strong class="source-inline">appsettings.json</strong> file:</p>
			<p class="source-code">{</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  "AzureSmsService": {</p>
			<p class="source-code">    "Sender": "+901112223344",</p>
			<p class="source-code">    "ConnectionString": "..."</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The configuration section name (<strong class="source-inline">AzureSmsService</strong> here) and key names are completely arbitrary. You can set any name as long as you use the same keys in your code.</p>
			<p>Once you've set values in the settings<a id="_idIndexMarker275"/> file, you can easily read them from your application code.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor165"/>Reading the configuration values</h2>
			<p>You can inject and use the <strong class="source-inline">IConfiguration</strong> service whenever you need to read configured values. For example, we can get<a id="_idIndexMarker276"/> the Azure configuration to send SMS in the <strong class="source-inline">AzureSmsService</strong> class:</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Microsoft.Extensions.Configuration;</p>
			<p class="source-code">using Volo.Abp.DependencyInjection;</p>
			<p class="source-code">namespace SmsSending</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class AzureSmsService : ISmsService,                     ITransientDependency</p>
			<p class="source-code">    {</p>
			<p class="source-code">        private readonly IConfiguration _configuration;</p>
			<p class="source-code">        public AzureSmsService(IConfiguration configuration)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _configuration = configuration;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        </p>
			<p class="source-code">        public async Task SendAsync(</p>
			<p class="source-code">            string phoneNumber, string message)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            string sender = _configuration["AzureSmsService:Sender"];</p>
			<p class="source-code">            string ConnectionString = _configuration["AzureSmsService:ConnectionString"];</p>
			<p class="source-code">            //TODO: Use Azure to send the SMS message</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This class gets the configuration values from the <strong class="source-inline">IConfiguration</strong> service, and the<strong class="source-inline">:</strong> notation is used to access values in nested sections. In this example, <strong class="source-inline">AzureSmsService:Sender</strong> is used to get the <strong class="source-inline">Sender</strong> value inside the <strong class="source-inline">AzureSmsService</strong> section.</p>
			<p>The <strong class="source-inline">IConfiguration</strong> service<a id="_idIndexMarker277"/> is also usable in the <strong class="source-inline">ConfigureServices</strong> of your module:</p>
			<p class="source-code">public override void ConfigureServices(</p>
			<p class="source-code">    ServiceConfigurationContext context)</p>
			<p class="source-code">{</p>
			<p class="source-code">    IConfiguration configuration =                                   context.Services.GetConfiguration();</p>
			<p class="source-code">    string sender =                                                 configuration["AzureSmsService:Sender"];</p>
			<p class="source-code">}</p>
			<p>This way, you can access the configured values even before the dependency injection registration phase is completed.</p>
			<p>The configuration system is a perfect way to configure and get key-value-style settings for your application. However, if you are building a reusable library, the options pattern can be a better way to define type-safe options for your library.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor166"/>Implementing the options pattern</h1>
			<p>With the <strong class="bold">options pattern</strong>, we use a plain class (sometimes called a <strong class="bold">POCO</strong> – <strong class="bold">Plain Old C# Object</strong>) to define a group of related<a id="_idIndexMarker278"/> options. Let's begin with how to define, configure, and use the configuration<a id="_idIndexMarker279"/> using the options pattern.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor167"/>Defining an options class</h2>
			<p>An options class is a simple<a id="_idIndexMarker280"/> plain C# class. We can define an options class for the Azure SMS service as shown in the following code block:</p>
			<p class="source-code">public class AzureSmsServiceOptions</p>
			<p class="source-code">{</p>
			<p class="source-code">    public string Sender { get; set; }</p>
			<p class="source-code">    public string ConnectionString { get; set; }</p>
			<p class="source-code">}</p>
			<p>It is a convention to add the <strong class="source-inline">Options</strong> suffix to options classes. Once you define such a class, any module using this service can configure the options easily.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor168"/>Configuring the options</h2>
			<p>As mentioned in the <em class="italic">ABP modules</em> section, you can configure<a id="_idIndexMarker281"/> the services of the dependent modules in the <strong class="source-inline">ConfigureServices</strong> method of your module. We use the <strong class="source-inline">IServiceCollection.Configure</strong> extension method to set values for any options class. You can configure <strong class="source-inline">AzureSmsServiceOptions</strong> as shown in the following code block:</p>
			<p class="source-code">[DependsOn(typeof(SmsSendingModule))]</p>
			<p class="source-code">public class MyStartupModule : AbpModule</p>
			<p class="source-code">{</p>
			<p class="source-code">    public override void ConfigureServices(</p>
			<p class="source-code">        ServiceConfigurationContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        context.Services</p>
			<p class="source-code">            .Configure&lt;AzureSmsServiceOptions&gt;(options =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            options.Sender = "+901112223344";</p>
			<p class="source-code">            options.ConnectionString = "...";</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">context.Services.Configure</strong> method is a generic method that gets the options class<a id="_idIndexMarker282"/> as the generic parameter. It also takes a delegate (an action) to set the option values. In this example, we've configured <strong class="source-inline">AzureSmsServiceOptions</strong> by setting the <strong class="source-inline">Sender</strong> and <strong class="source-inline">ConnectionString</strong> properties in the specified lambda expression.</p>
			<p>The <strong class="source-inline">AbpModule</strong> base class provides a <strong class="source-inline">Configure</strong> method as a shortcut of the <strong class="source-inline">context.Services.Configure</strong> method, so you could re-write the code as follows:</p>
			<p class="source-code">public override void ConfigureServices(</p>
			<p class="source-code">    ServiceConfigurationContext context)</p>
			<p class="source-code">{</p>
			<p class="source-code">    Configure&lt;AzureSmsServiceOptions&gt;(options =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        options.Sender = "+901112223344";</p>
			<p class="source-code">        options.ConnectionString = "...";</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>We've just replaced the <strong class="source-inline">context.Services.Configure&lt;…&gt;</strong> call with the <strong class="source-inline">Configure&lt;…&gt;</strong> shortcut method.</p>
			<p>Configuring the options<a id="_idIndexMarker283"/> is simple. Now, we can see how to use the configured values.</p>
			<p class="callout-heading">Multiple Configure Actions</p>
			<p class="callout">You can configure the same options multiple times in an application. The same instance is sent to all delegates so that you can change the previously configured values. If multiple modules configure<a id="_idIndexMarker284"/> the same value, the last one wins. Remember that modules are initialized by the dependency order.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor169"/>Using the configured option values</h2>
			<p>ASP.NET Core provides an <strong class="source-inline">IOptions&lt;T&gt;</strong> interface to inject the options class to read the configured values. We can<a id="_idIndexMarker285"/> re-write the <strong class="source-inline">AzureSmsService</strong> class to use <strong class="source-inline">AzureSmsServiceOptions</strong> instead of the <strong class="source-inline">IConfigur<a id="_idTextAnchor170"/>ation</strong> service, as in the following code block:</p>
			<p class="source-code">public class AzureSmsService : ISmsService, ITransientDependency</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly AzureSmsServiceOptions _options;</p>
			<p class="source-code">    public AzureSmsService(IOptions&lt;AzureSmsServiceOptions&gt;         options)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _options = options.Value;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    public async Task SendAsync(string phoneNumber, string message)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        string sender = _options.Sender;</p>
			<p class="source-code">        string ConnectionString = _options.ConnectionString;</p>
			<p class="source-code">        //TODO...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Notice that we are injecting <strong class="source-inline">IOptions&lt;AzureSmsServiceOptions&gt;</strong> and using its <strong class="source-inline">Value</strong> property to obtain the <strong class="source-inline">AzureSmsServiceOptions</strong> instance. The <strong class="source-inline">IOptions&lt;T&gt;</strong> interface is defined by the <strong class="source-inline">Microsoft.Extensions.Options</strong> package and is the standard way to inject an options class. It internally executes all the <strong class="source-inline">Configure</strong> methods and provides<a id="_idIndexMarker286"/> a configured instance of the options class for you. If you directly inject the <strong class="source-inline">AzureSmsServiceOptions</strong> class by mistake, you get a dependency injection exception. So, always inject as <strong class="source-inline">IOptions&lt;AzureSmsServiceOptions&gt;</strong>.</p>
			<p>We've simply defined, configured, and used the options. What if we want to use the configuration system to set the options defined with the options pattern?</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor171"/>Setting the options via the configuration</h2>
			<p>The options pattern<a id="_idIndexMarker287"/> allows us to set the option values in any way. That means<a id="_idIndexMarker288"/> we can use the <strong class="source-inline">IConfiguration</strong> service to read the application configuration and set the option values. The following code block sets <strong class="source-inline">AzureSmsServiceOptions</strong> by getting the values from the configuration service:</p>
			<p class="source-code">[DependsOn(typeof(SmsSendingModule)<a id="_idTextAnchor172"/>)]</p>
			<p class="source-code">public class MyStartupModule : AbpModule</p>
			<p class="source-code">{</p>
			<p class="source-code">    public override void ConfigureServices(</p>
			<p class="source-code">        ServiceConfigurationContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var configuration =                                            context.Services.GetConfiguration();        </p>
			<p class="source-code">        Configure&lt;AzureSmsServiceOptions&gt;(options =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            options.Sender =                                                 configuration["AzureSmsService:Sender"];</p>
			<p class="source-code">            options.ConnectionString = configuration["AzureSmsService:ConnectionString"];</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We are getting the <strong class="source-inline">IConfiguration</strong> interface using <strong class="source-inline">context.Services.GetConfiguration()</strong>, then using the configuration values to set the option values.</p>
			<p>However, since this usage<a id="_idIndexMarker289"/> is pretty common, there is a shortcut for it. We could<a id="_idIndexMarker290"/> re-write the code as shown in the following block:</p>
			<p class="source-code">public override void ConfigureServices(</p>
			<p class="source-code">    ServiceConfigurationContext context)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var configuration = context.Services.GetConfiguration();    </p>
			<p class="source-code">    Configure&lt;AzureSmsServiceOptions&gt;(</p>
			<p class="source-code">        configuration.GetSection("AzureSmsService"));</p>
			<p class="source-code">}</p>
			<p>With this usage, the <strong class="source-inline">Configure</strong> method gets a configuration section instead of a delegate action. It automatically matches the configuration keys with the properties of the options class by naming conventions. This code does not affect the options if the <strong class="source-inline">AzureSmsService</strong> section is not defined in the configuration.</p>
			<p>The options pattern gives more flexibility to the application<a id="_idIndexMarker291"/> developers; they may set these<a id="_idIndexMarker292"/> options from <strong class="source-inline">IConfiguration</strong> or any other source they like.</p>
			<p class="callout-heading">Tip: Set Options from the Configuration by Default</p>
			<p class="callout">If you are building a reusable module, it is a good practice to set your options from the configuration wherever possible. That is, you can write the preceding code into your module. In this way, an application developer can directly configure their module from the <strong class="source-inline">appsettings.json</strong> file.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor173"/>ASP.NET Core and ABP options</h2>
			<p>ASP.NET Core and ABP Framework<a id="_idIndexMarker293"/> intensively use the options pattern for their<a id="_idIndexMarker294"/> configuration options.</p>
			<p>The following example shows configuring an option in ABP Framework:</p>
			<p class="source-code">Configure&lt;AbpAuditingOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.IgnoredTypes.Add(typeof(ProductDto));</p>
			<p class="source-code">});</p>
			<p><strong class="source-inline">AbpAuditingOptions</strong> is defined by the audit logging system of ABP Framework. We are adding a type, <strong class="source-inline">ProductDto</strong>, to be ignored on audit logging.</p>
			<p>The next example shows configuring an option in ASP.NET Core:</p>
			<p class="source-code">Configure&lt;MvcOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.RespectBrowserAcceptHeader = true;</p>
			<p class="source-code">});</p>
			<p><strong class="source-inline">MvcOptions</strong> is defined by ASP.NET Core to customize the behavior of the ASP.NET Core MVC framework.</p>
			<p class="callout-heading">Complex Types in the Options Classes</p>
			<p class="callout">Notice that <strong class="source-inline">AbpAuditingOptions.IgnoredTypes</strong> is a list of <strong class="source-inline">Type</strong>, which is not a simple primitive type that you can define in an <strong class="source-inline">appsettings.json</strong> file. That is one of the benefits of the options pattern: you can define properties with complex types or even action callbacks.</p>
			<p>The configuration system and the options pattern provide a convenient way to configure and customize the behavior of the services being used. You can configure ASP.NET Core and ABP Framework<a id="_idIndexMarker295"/> and define configuration options<a id="_idIndexMarker296"/> for your own services.</p>
			<p>The next section explains logging, another fundamental system that you will frequently use in your application code.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor174"/>Logging</h1>
			<p><strong class="bold">Logging</strong> is a common aspect used in every application. ASP.NET Core provides a simple yet efficient<a id="_idIndexMarker297"/> logging system. It can be integrated with popular logging libraries such as NLog, Log4Net, and Serilog.</p>
			<p>Serilog is a widely used library that provides many options for the log target, including console, text files, and Elasticsearch. ABP startup templates come with the Serilog library pre-installed and configured. It writes logs into a log file in the <strong class="source-inline">Logs</strong> folder of the application. So, you can directly use the logging system in your services. If you need, you can configure Serilog to write logs to different targets. Please refer to Serilog's documentation to configure the Serilog options. Serilog is not a core dependency of ABP Framework. All the configuration is included in the startup template. So, if you like, you can easily change it with another provider.</p>
			<p>The <strong class="source-inline">ILogger&lt;T&gt;</strong> interface is used to write logs in ASP.NET Core, where <strong class="source-inline">T</strong> is typically your service type.</p>
			<p>Here is an example service that writes logs:</p>
			<p class="source-code">public class AzureSmsService : ISmsService,                     ITransientDependency</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly ILogger&lt;AzureSmsService&gt; _logger;</p>
			<p class="source-code">    public AzureSmsService(ILogger&lt;AzureSmsService&gt; logger)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _logger = logger;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public async Task SendAsync(string phoneNumber, string           message)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _logger.LogInformation(</p>
			<p class="source-code">            $"Sending SMS to {phoneNumber}: {message}");</p>
			<p class="source-code">        //TODO...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">AzureSmsService</strong> class injects the <strong class="source-inline">ILogger&lt;AzureSmsService&gt;</strong> service in its constructor and uses the <strong class="source-inline">LogInformation</strong> method to write information-level log text to the<a id="_idIndexMarker298"/> logging system.</p>
			<p>There are more methods on the <strong class="source-inline">ILogger</strong> interface to write logs with different severity levels, such as LogError and LogDebug. Please refer to ASP.NET Core's documentation for all details<a id="_idIndexMarker299"/> of the logging system: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging">https:<span id="_idTextAnchor175"/>//docs.microsoft.com/en-us/aspnet/core/fundamentals/logging</a>.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor176"/>Summary</h1>
			<p>This chapter has covered the core building blocks of ASP.NET Core and ABP Framework.</p>
			<p>You've learned about using the <strong class="source-inline">Startup</strong> class, configuration system, and options pattern to configure ASP.NET Core and ABP Framework services on application startup and implement your own configuration options when you need them.</p>
			<p>ABP offers a modularity system that takes ASP.NET Core's initialization and configuration system one step further to create multiple modules where each module initializes its services and configures its dependencies. In this way, you can split your application into modules to better organize your code base or create modules that can be reused in different applications.</p>
			<p>The dependency injection system is the most fundamental infrastructure of an ASP.NET Core application. A service consumes others using the dependency injection system. I've introduced the essential aspects of the dependency injection system and explained how ABP simplifies registering your services.</p>
			<p>The next chapter focuses on data access infrastructure, which is an essential aspect of a business application. We will see how ABP Framework standardizes defining entities and using repositories to abstract and perform database operations while automating database connections and transaction management.</p>
		</div>
	</body></html>