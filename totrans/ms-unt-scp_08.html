<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Customizing the Unity Editor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Customizing the Unity Editor</h1></div></div></div><p>The Unity Editor is a<a id="id600" class="indexterm"/> powerful, general purpose game development tool. Nevertheless, there are times during development when you probably wished the editor offered a specific feature that it doesn't have or behaved in a particular way, simply because it would be more convenient for you and your specific game. Maybe you'd like the path editing features, batch renaming functionality, or mesh creation tools, among others. In such cases, you can search the Asset Store for add-ons that meet your needs. But even then, you may still not find what you need. Consequently, the focus then turns to how the editor can be adapted or customized to achieve your purpose. Thankfully, there are many ways Unity can be changed as a tool, and this chapter focuses on particular case studies. First, it explores how to create a<a id="id601" class="indexterm"/> <span class="strong"><strong>Batch Rename</strong></span> tool for renaming multiple selected objects in one operation. Second, it covers how to create a color range field in the Object Inspector to blend between two colors using a slider. Third, it explores how to expose public C# properties in the Object Inspector for both setting and getting values. Lastly, it covers how to use C# attributes to create a localization toolkit that allows you to automatically change all in-game strings to a chosen language (English, French, and so on) at the touch of a button.</p><div class="section" title="Batch renaming"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec84"/>Batch renaming</h1></div></div></div><p>When creating scenes with multiple enemies, power-ups, props, or other object instances, you'll typically use the duplicate feature to clone objects (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span>). This leads to many objects sharing the same <a id="id602" class="indexterm"/>name. Now, while there's nothing technically wrong in name duplication per se, it's both inconvenient and untidy. It results in a hierarchy panel of many identically named objects, and it's practically impossible to<a id="id603" class="indexterm"/> distinguish between specific objects by their name alone. Furthermore, object searches in script using the <code class="literal">GameObject.Find</code> function <a id="id604" class="indexterm"/>cannot be relied on to retrieve the specific object that you need, since it could return any one of the identically named objects. The solution, then, is to name each object uniquely and appropriately. But doing this can be tedious, especially if you're working with many objects. Thus, there's a need for a Batch Rename tool.</p><p>This would, in theory, allow you to select multiple objects in the hierarchy panel and then to rename them automatically according to a numbered convention. The only technical problem with this is that Unity doesn't natively <a id="id605" class="indexterm"/>support such a feature. But we can code it ourselves, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_08_01.jpg" alt="Batch renaming"/><div class="caption"><p>Creating a Batch Rename editor add-on</p></div></div><p>To begin customizing the Unity Editor, first create a folder named <code class="literal">Editor</code> inside the project. This is important. <code class="literal">Editor</code> is a special folder recognized by Unity as a place to house all the editor customizing scripts. Thus, if you plan on changing the Unity Editor, be sure all customizing scripts are inside the <code class="literal">Editor</code> folder. It doesn't matter whether your project features multiple folders named <code class="literal">Editor</code>; the only thing that matters is that there's at least one <code class="literal">Editor</code> folder and an editor script inside it, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_08_02.jpg" alt="Batch renaming"/><div class="caption"><p>Create an Editor folder for all editor scripts</p></div></div><p>Next, we'll create a Batch Rename utility from the <code class="literal">ScriptableWizard</code> class. This class is an ancestor from<a id="id606" class="indexterm"/> which we derive new classes. All derived classes will work much like a pop-up utility dialog that can be launched from the Unity main menu. Their purpose is to present a set of options from which the user can choose before pressing a confirmation button that performs a one-time process. In other words, classes derived from <code class="literal">ScriptableWizard</code> are ideal for performing automated, one-time operations on single or multiple objects.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/>Tip</h3><p>More information on the <a id="id607" class="indexterm"/>
<code class="literal">ScriptableWizard</code> class can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/ScriptableWizard.html">http://docs.unity3d.com/ScriptReference/ScriptableWizard.html</a>.</p></div></div><p>The following code sample 8-1 lists the complete source code for a Batch Rename utility:</p><div class="informalexample"><pre class="programlisting">01 //------------------------------------
02 using UnityEngine;
<span class="strong"><strong>03 using UnityEditor;</strong></span>
04 using System.Collections;
05 //------------------------------------
<span class="strong"><strong>06 public class BatchRename : ScriptableWizard</strong></span>
07 {
08 //Base name
09 public string BaseName = "MyObject_";
10 
11 //Start Count
12 public int StartNumber = 0;
13 
14 //Increment
15 public int Increment = 1;
16 
<span class="strong"><strong>17 [MenuItem("Edit/Batch Rename...")]</strong></span>
<span class="strong"><strong>18     static void CreateWizard()</strong></span>
<span class="strong"><strong>19     {</strong></span>
<span class="strong"><strong>20         ScriptableWizard.DisplayWizard("Batch Rename",typeof(BatchRename),"Rename");</strong></span>
<span class="strong"><strong>21     }</strong></span>
22 //------------------------------------
23 //Called when the window first appears
24 void OnEnable()
25 {
26       UpdateSelectionHelper();
27 }
28 //------------------------------------
29 //Function called when selection changes in scene
30 void OnSelectionChange()
31 {
32       UpdateSelectionHelper();
33 }
34 //------------------------------------
35 //Update selection counter
36 void UpdateSelectionHelper()
37 {
38        helpString = "";
39 
40        if (Selection.objects != null)
41 helpString = "Number of objects selected: " + Selection.objects.Length;
42 }
43 //------------------------------------
44 //Rename
<span class="strong"><strong>45 void OnWizardCreate()</strong></span>

<span class="strong"><strong>46 {</strong></span>
47       //If selection empty, then exit
48       if (Selection.objects == null)
49              return;
50 
51       //Current Increment
52       int PostFix = StartNumber;
53 
54       //Cycle and rename
<span class="strong"><strong>55       foreach(Object O in Selection.objects)</strong></span>
56       {
57              O.name = BaseName + PostFix;
58              PostFix += Increment;
59       }
60 }
61 //------------------------------------
62 }
63 //------------------------------------</pre></div><p>The following are the<a id="id608" class="indexterm"/> comments for code sample 8-1:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 03</strong></span>: The editor extensions should include the <code class="literal">UnityEditor</code> namespace that allows you to access editor classes and objects.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 06</strong></span>: The <code class="literal">BatchRename</code> class derives not from <code class="literal">MonoBehaviour</code>, as with most script files, but from <code class="literal">ScriptableWizard</code>. Classes deriving from here will be treated by Unity like independent utilities that may be launched from the application menu.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 17-21</strong></span>: The <code class="literal">MenuItem</code> attribute is prefixed to the <code class="literal">CreateWizard</code> function. This creates a menu entry in the application menu listed under <span class="strong"><strong>Edit/Batch Rename</strong></span> and invokes the <code class="literal">CreateWizard</code> function when clicked on to display the <span class="strong"><strong>Batch Rename</strong></span> window.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 8-16</strong></span>: After <code class="literal">CreateWizard</code> is invoked, the <code class="literal">BatchRename</code> window shows. From here, all public<a id="id609" class="indexterm"/> class members (including <span class="strong"><strong>Base Name</strong></span>, <span class="strong"><strong>Start Number</strong></span>, and <span class="strong"><strong>Increment</strong></span>) will automatically feature in the window as editable fields for the user.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 45-60</strong></span>: The <code class="literal">OnWizardCreate</code> function<a id="id610" class="indexterm"/> is invoked as an event when the user presses the <span class="strong"><strong>Rename</strong></span> button from the <span class="strong"><strong>Batch Rename</strong></span> window. The button is called <span class="strong"><strong>Rename</strong></span> in this case because of line 20. The <code class="literal">OnWizardCreate</code> function iterates through all selected objects in the scene, if any, and renames them in sequence according to the <span class="strong"><strong>Base Name</strong></span>, <span class="strong"><strong>Start Number</strong></span>, and <span class="strong"><strong>Increment</strong></span> fields, as shown here:<div class="mediaobject"><img src="graphics/0655OT_08_03.jpg" alt="Batch renaming"/><div class="caption"><p>The Batch Rename tool</p></div></div></li></ul></div><p>To use the Batch Rename tool, just select a group of objects in the scene and then click on the <span class="strong"><strong>Batch Rename</strong></span> option<a id="id611" class="indexterm"/> in <span class="strong"><strong>Edit</strong></span> from the application menu. The <span class="strong"><strong>Base Name</strong></span> field defines a string that needs to be prefixed to all object names, and the <span class="strong"><strong>Increment</strong></span> field defines the amount by which an integer counter should increase that is prefixed to the base name. The <span class="strong"><strong>Start Number</strong></span> value is the point from which all<a id="id612" class="indexterm"/> incrementing begins, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_08_04.jpg" alt="Batch renaming"/><div class="caption"><p>Renamed objects using the Batch Rename tool</p></div></div></div></div>
<div class="section" title="C# attributes and reflection"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec85"/>C# attributes and reflection</h1></div></div></div><p>From this point forward in the chapter, all editor extensions will rely heavily on the concepts of attributes and reflection. These concepts are not specific to Unity but refer to more general ideas in <a id="id613" class="indexterm"/>computer science, programming, and to their application in languages such as C# as well as in the .NET framework. Before proceeding to the<a id="id614" class="indexterm"/> next editor extension, let's consider attributes and the related concept<a id="id615" class="indexterm"/> of reflection using the<a id="id616" class="indexterm"/> example of the <code class="literal">Range</code> attribute, which is native to Unity. Consider the following line of code:</p><div class="informalexample"><pre class="programlisting">public float MyNumber = 0;</pre></div><p>This public variable will be displayed in the Object Inspector with an edit field that allows the user to type in any valid floating point number thereby setting the value of <code class="literal">MyNumber</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_08_05.jpg" alt="C# attributes and reflection"/><div class="caption"><p>Entering in floating point values from the Object Inspector</p></div></div><p>This code works fine and is suitable in many cases, but there are times when it's preferable to<a id="id617" class="indexterm"/> validate the numerical entry to within a range, clipping the numbers between a minimum and maximum. You can do this in the code using the <a id="id618" class="indexterm"/>
<code class="literal">Mathf.Clamp</code> function but you<a id="id619" class="indexterm"/> can also validate the entry using an attribute. You can attach a <code class="literal">Range</code> attribute to the floating point variable (<code class="literal">MyNumber</code>) to display a slider instead of an edit box, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> [Range(0f,1f)]</strong></span>
public float MyNumber = 0;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip55"/>Tip</h3><p>More information on attributes <a id="id620" class="indexterm"/>can be found in the online Unity documentation at <a class="ulink" href="http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes">http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes</a>.</p></div></div><p>When this code is compiled, the <code class="literal">MyNumber</code> variable displays differently in the Object Inspector, honoring the numerical range between <code class="literal">0</code> and <code class="literal">1</code>, as shown in the following screenshot. Notice that all numbers provided to the <code class="literal">Range</code> attribute as arguments must be explicit values known at compile time and not expressions, which depend on variables that can vary at runtime. All attribute values must be known at compile time.</p><div class="mediaobject"><img src="graphics/0655OT_08_06.jpg" alt="C# attributes and reflection"/><div class="caption"><p>Using attributes to customize inspector display</p></div></div><p>So how do attributes work? In short, attributes are a form of metadata; they work like tags. Programmers can attach an attribute to a class, variable, or a method to associate data with it, which<a id="id621" class="indexterm"/> is known to the compiler. The attribute itself is entirely descriptive because it does nothing; it's simply data. The importance of attributes arises because all the code based on .NET (or Mono) has the ability to step outside itself and become self-conscious, that is, the ability to look at all the classes and data types and instances <a id="id622" class="indexterm"/>contained inside the program. For each object in the program, its metadata (attributes) can be queried and examined. This ability of a program to "look at itself from the outside" is known as reflection as it's like looking in a mirror. Of course, the program does not see itself in reverse or in distorted terms but rather as it truly is, including all its metadata. To give a quick example of reflection, try out the following code sample 8-2. This code will cycle through all the custom-made classes in your Unity application across all source files. Notice it doesn't just list all the instances of classes in the scene but all classes themselves (that is, the blueprints, metaphorically speaking):</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 using System.Reflection;
04 using System;
05 
06 public class MyTestScript : MonoBehaviour 
07 {
08 // Use this for initialization
09 void Start () 
10 {
11        //List all classes in assembly
12 foreach(Type t in Assembly.GetExecutingAssembly().GetTypes())

13        {
14              Debug.Log (t.Name);
15        }
16 }
17 }</pre></div><p>The following are the <a id="id623" class="indexterm"/>comments for code sample 8-2:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 03-04</strong></span>: Both the namespaces <code class="literal">System</code> and <code class="literal">System.Reflection</code> should be included as they feature all classes and objects necessary for performing reflection in .NET.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 12</strong></span>: This <code class="literal">foreach</code> loop cycles through all classes (types) in the active assembly (that is, the compiled code, including all your custom made script files).</li></ul></div><p>You can take the concept of reflection even further. For example, having listed all types from code sample 8-2, you can even list the methods, properties, and variables (<code class="literal">Fields</code>) for a type. Refer to the following<a id="id624" class="indexterm"/> code sample 8-3 that, given a specific type as an argument, will list all its public member variables:</p><div class="informalexample"><pre class="programlisting"> //Function to list all public variables for class t
 public void ListAllPublicVariables(Type t)
 {
    //Loop through all public variables
    foreach(FieldInfo FI in t.GetFields(BindingFlags.Public | BindingFlags.Instance)
    {
         //Print name of variable
         Debug.Log (FI.Name);
    }
 }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip56"/>Tip</h3><p>More information on <a id="id625" class="indexterm"/>bitwise operations, as used in this code sample, can be found online at <a class="ulink" href="http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx">http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx</a>.</p></div></div><p>Most crucially, however, you can list the attributes assigned to a type too. This lets you query a type for its metadata and examine its properties at runtime as shown in the following code sample 8-4:</p><div class="informalexample"><pre class="programlisting">01 public void ListAllAttributes(Type t)
02 {
03 foreach(Attribute attr in t.GetCustomAttributes(true))
04 {
05        //List the type of attribute found
06        Debug.Log (attr.GetType());
07 }
08 }</pre></div><p>The code sample 8-4 demonstrates that all attribute data can be retrieved for a given data type in the code at runtime. This means data types and variables may have metadata associated with them, which can be retrieved and used to further influence how the objects should be<a id="id626" class="indexterm"/> handled. This is powerful for editor plugins because by creating our own custom-defined attributes that can be attached to data types and member variables, we can integrate our code with the Unity Editor without making its logical or runtime structure<a id="id627" class="indexterm"/> invalid. That is, we can tag variables in code with attributes to customize how they appear in the Unity Editor without invalidating or affecting it in terms of its logic or structure at runtime. Next, we'll see how to create custom attributes to customize the editor.</p></div>
<div class="section" title="Color blending"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec86"/>Color blending</h1></div></div></div><p>The <code class="literal">Range</code> attribute explored previously may be attached to integer and floating-point variables, by way of their declarations, to limit the accepted values for them between a minimum and maximum in<a id="id628" class="indexterm"/> the Unity Editor. In the Unity Editor, a slider control is substituted for an editable field that controls the accepted values for the variable. This does not, of course, affect the values assigned to the same variables in the code. In the code, at runtime, the <code class="literal">Range</code> attribute has no effect itself. Rather, the <code class="literal">Range</code> attribute simply<a id="id629" class="indexterm"/> controls how numerical public variables are presented in the Object Inspector, and how they are entered there via user input. Behind the scenes, an <code class="literal">Editor</code> class is querying object <code class="literal">Attribute</code> data through reflection to control how the data type is rendered in the Object Inspector.</p><p>The <code class="literal">Range</code> attribute works well for numbers. But it'd be great to deploy similar behavior for other data types besides just numbers. For example, it's common to fade between different colors, such as fading from black to transparency to create fade-in and fade-out effects for scene transitions. This is known as Color Lerping (linear interpolation). That is, an intermediary color is generated between two extremes using a normalized float (between <code class="literal">0</code> and <code class="literal">1</code>).</p><p>An appropriate <code class="literal">Inspector</code> property for this data type would be a slider control as with the <code class="literal">Range</code> attribute, which controls the interpolated color between <code class="literal">0</code> and <code class="literal">1</code>, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_08_07.jpg" alt="Color blending"/><div class="caption"><p>Lerping between two colors</p></div></div><p>In essence then, we need to customize the editor such that whenever an object is selected in the scene, which has a public member of a custom type we specify, we'll want to customize how the member is rendered inside the Object Inspector. This lets us present custom controls and inputs in the Object Inspector, which validates data entry for that member as opposed to simply <a id="id630" class="indexterm"/>accepting its defaults. To begin this process, let's create a custom class and define all data for a total color blend. A color blend requires four variables, namely the <code class="literal">SourceColor</code> and <code class="literal">DestColor</code> marking the limits of the blend. Next, the <code class="literal">BlendFactor</code> is a normalized float between <code class="literal">0</code> and <code class="literal">1</code> (start and end) which determines which intermediary color should be generated through Lerping. And then, finally, the output color itself (<code class="literal">BlendedColor</code>). The complete class definition for this process is included in the following code sample 8-5:</p><div class="informalexample"><pre class="programlisting">[System.Serializable]
 public class ColorBlend : System.Object
 {
    public Color SourceColor = Color.white;
    public Color DestColor = Color.white;
    public Color BlendedColor = Color.white;
    public float BlendFactor = 0f;
 }</pre></div><p>As the <code class="literal">ColorBlend</code> class<a id="id631" class="indexterm"/> uses the <code class="literal">[System.Serializable]</code> attribute, Unity will automatically render the class and its members inside the Object Inspector when it's added as a public member of a class. By default, all public members of <code class="literal">ColorBlend</code> will be rendered, and the <code class="literal">BlendFactor</code> field will be rendered as an editable field inside which numbers can be directly entered, including numbers outside <code class="literal">0</code> and <code class="literal">1</code>, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_08_08.jpg" alt="Color blending"/><div class="caption"><p>Exposing the Color Adjuster class by its defaults and by changing its properties</p></div></div><p>Let's now start customizing how Unity should render this class inside the Object Inspector. Begin by <a id="id632" class="indexterm"/>creating a new attribute class called <code class="literal">ColorRangeAttribute</code>, as shown in the following code sample 8-6:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>01 public class ColorRangeAttribute : PropertyAttribute</strong></span>
<span class="strong"><strong>02 {</strong></span>
03 //------------------------------------------------------------
04 public Color Min;
05 public Color Max;
06 //------------------------------------------------------------
<span class="strong"><strong>07 public ColorRangeAttribute(float r1, float g1, float b1, float a1,</strong></span>
<span class="strong"><strong>08                            float r2, float g2, float b2, float a2)</strong></span>
09 {
10       this.Min = new Color(r1, g1, b1, a1);
11       this.Max = new Color(r2, g2, b2, a2);
12 }
13 //------------------------------------------------------------
14 }</pre></div><p>The following are the comments for code sample 8-6:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 01</strong></span>: The <a id="id633" class="indexterm"/><code class="literal">ColorRangeAttribute</code> class defines a metadata structure that we can tag to other data types. Notice that it derives from <code class="literal">PropertyAttribute</code>. This signifies, above everything else, that <code class="literal">ColorRangeAttribute</code> is an attribute and metadata structure but not a regular class. It's not supposed to be instantiated as a standard class is.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 07</strong></span>: The attribute has a constructor function that accepts eight floating-point values defining the RGBA channels for the source and destination colors of the Lerp. These will be used soon when attaching the attribute to a variable.</li></ul></div><p>Now, we'll write a class<a id="id634" class="indexterm"/> declaring an instance of <code class="literal">ColorBlend</code> with the <code class="literal">ColorRangeAttribute</code> attribute attached. Even now, however, the addition of <code class="literal">ColorRangeAttribute</code> will do nothing per se because no <code class="literal">Editor</code> class has yet been written to handle it. We can see this in the following code:</p><div class="informalexample"><pre class="programlisting">public class ColorAdjuster : MonoBehaviour 
{
   [ColorRangeAttribute(1f,0f,0f,0f,   0f,1f,0f,1f)]
   public ColorBlend MyColorBlend;
}</pre></div><p>Creating an <code class="literal">Editor</code> class for rendering <code class="literal">ColorBlend</code> in the Object Inspector with a slider control involves handling the <code class="literal">ColorRangeAttribute</code> class. Specifically, Unity offers us the extension <code class="literal">PropertyDrawer</code> base class from which we can derive new classes to override the Object Inspector rendering for any specific attribute we add to our variables. In short, the <code class="literal">PropertyDrawer</code> class lets us customize inspector drawing for any and all variables tagged with a common attribute. Therefore, inside the <code class="literal">Editor</code> folder of your project, create a new <code class="literal">ColorRangeDrawer</code> class, as shown in the following code sample 8-7:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using UnityEditor; //Be sure to include UnityEditor for all extension classes
03 using System.Collections;
04 //------------------------------------------------------------
05 //CustomPropertyDrawer attribute for overriding drawing of all ColorRangeAttribute members

06 [CustomPropertyDrawer(typeof(ColorRangeAttribute))]
07 public class ColorRangeDrawer : PropertyDrawer
08 {
09 //------------------------------------------------------------
10 //Event called by Unity Editor for updating GUI drawing of controls

<span class="strong"><strong>11 public override void OnGUI (Rect position, SerializedProperty property, GUIContent label)</strong></span>

12 {
13        //Get color range attribute meta data
<span class="strong"><strong>14 ColorRangeAttribute range  = attribute as ColorRangeAttribute;</strong></span>
15 
16        //Add label to inspector
17 position = EditorGUI.PrefixLabel (position, new GUIContent ("Color Lerp"));
18 
19        //Define sizes for color rect and slider controls
20 Rect ColorSamplerRect = new Rect(position.x, position.y, 100, position.height);

21 Rect SliderRect = new Rect(position.x+105, position.y, 200, position.height);
22 
23       //Show color rect control
24 EditorGUI.ColorField(ColorSamplerRect, property.FindPropertyRelative("BlendedColor").colorValue);
25 
26      //Show slider control
27 property.FindPropertyRelative("BlendFactor").floatValue = EditorGUI.Slider(SliderRect, property.FindPropertyRelative("BlendFactor").floatValue, 0f, 1f);
28 
29      //Update blended color based on slider
30 property.FindPropertyRelative("BlendedColor").colorValue = Color.Lerp(range.Min, range.Max, property.FindPropertyRelative("BlendFactor").floatValue);
31 }
32 //------------------------------------------------------------
33 }
34 //------------------------------------------------------------</pre></div><p>The following are the comments for code sample 8-7:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 01</strong></span>: The <a id="id635" class="indexterm"/><code class="literal">CustomPropertyDrawer</code> attribute is used here to associate the <code class="literal">PropertyDrawer</code> class with the <code class="literal">ColorRangeAttribute</code> attribute. The Unity Editor uses this metadata internally to determine which types require custom rendering in the Object Inspector. In this case, all members with <code class="literal">ColorRangeAttribute</code> will be drawn manually by the <code class="literal">OnGUI</code> function of the <code class="literal">PropertyDrawer</code> class.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 11</strong></span>: The<a id="id636" class="indexterm"/> <code class="literal">OnGUI</code> function is overridden<a id="id637" class="indexterm"/> from the base class to define how all fields with <code class="literal">ColorRangeAttribute</code> should be rendered in the Object Inspector. <code class="literal">EditorGUI</code> is a native Unity Editor utility class for drawing GUI elements, such as buttons, textboxes, and sliders. For more information on<a id="id638" class="indexterm"/> <code class="literal">EditorGUI</code>, see the online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/EditorGUI.html">http://docs.unity3d.com/ScriptReference/EditorGUI.html</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 14</strong></span>: The <code class="literal">OnGUI</code> function is called once, perhaps many times per second, for each unique member to render manually in the Object Inspector. The attribute data for <code class="literal">ColorRangeAttribute</code> is retrieved here with typecasting, and this gives us access directly to all its members for the current object being rendered. To access the member variables of the object itself (for read/write access), as opposed to its attribute, the <code class="literal">SerializedProperty</code> argument should be used, such as the <a id="id639" class="indexterm"/><code class="literal">FindPropertyRelative</code> method. For<a id="id640" class="indexterm"/> more information, see the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/SerializedProperty.html">http://docs.unity3d.com/ScriptReference/SerializedProperty.html</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 24</strong></span>: From here onwards, the <code class="literal">FindPropertyRelative</code> function is called to retrieve public<a id="id641" class="indexterm"/> member variables, such as the <code class="literal">SourceColor</code>, <code class="literal">DestColor</code>, and <code class="literal">BlendedColor</code> in the selected object. This is where the values are actually set by moving the slider component.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip57"/>Tip</h3><p>More information on the<a id="id642" class="indexterm"/> <code class="literal">PropertyDrawer</code> class can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/editor-PropertyDrawers.html">http://docs.unity3d.com/Manual/editor-PropertyDrawers.html</a>.</p></div></div></li></ul></div><p>The code sample 8-7 overrides the Object Inspector drawing for any <code class="literal">ColorBlend</code> instances when tagged with the <code class="literal">ColorRangeAttribute</code> attribute. This offers an accessible and easy-to-use way of creating blended colors. Remember, you can make your source and destination colors public, in order to be accessible from the <span class="strong"><strong>Inspector</strong></span> tab, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_08_09.jpg" alt="Color blending"/><div class="caption"><p>Creating a ColorBlender display for the ColorBlend class</p></div></div></div>
<div class="section" title="Property exposing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec87"/>Property exposing</h1></div></div></div><p>By default, the Object<a id="id643" class="indexterm"/> Inspector displays all public member variables of a class unless it's in <span class="strong"><strong>Debug</strong></span> mode or a private member is explicitly marked with the<a id="id644" class="indexterm"/> <code class="literal">SerializeField</code> attribute and in these cases private member variables will be shown too:</p><div class="mediaobject"><img src="graphics/0655OT_08_10.jpg" alt="Property exposing"/><div class="caption"><p>Property accessing from the Object Inspector</p></div></div><p>However, C# properties will never be displayed by default, either in <span class="strong"><strong>Release</strong></span> or <span class="strong"><strong>Debug</strong></span> mode. As discussed in <a class="link" href="ch01.html" title="Chapter 1. Unity C# Refresher">Chapter 1</a>, <span class="emphasis"><em>Unity C# Refresher</em></span>, C# properties act like accessor functions to a variable. They essentially permit validation on each <code class="literal">get</code> and <code class="literal">set</code> operation because every <code class="literal">get</code> and <code class="literal">set</code> operation entails an internal function call. However, regardless of Unity's limitation in the Object Inspector, it's possible to write an editor extension that will show all properties for a class in the Object Inspector, which allows you to get and set the values directly. This section considers how in more detail. Again, we'll have reason to rely heavily on reflection.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip58"/>Tip</h3><p>More information on the <a id="id645" class="indexterm"/>
<code class="literal">SerializeField</code> class can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/SerializeField.html">http://docs.unity3d.com/ScriptReference/SerializeField.html</a>.</p></div></div><p>Consider the following code sample 8-8 that features a few properties:</p><div class="informalexample"><pre class="programlisting"> //----------------------------------------------
 using UnityEngine;
 using System.Collections;
 //----------------------------------------------
 [System.Serializable]
 public class ClassWithProperties : System.Object
 {
    //Class with some properties
    //----------------------------------------------
<span class="strong"><strong>    public int MyIntProperty</strong></span>
    {
          get{return _myIntProperty;} 
          //Performs some validation on values
    set{if(value &lt;= 10)_myIntProperty = value;else _myIntProperty=0;}
    }
    //----------------------------------------------
 <span class="strong"><strong>   public float MyFloatProperty</strong></span>
   {
          get{return _myFloatProperty;}
          set{_myFloatProperty = value;}
   }
    //----------------------------------------------
<span class="strong"><strong>    public Color MyColorProperty</strong></span>
   {
          get{return _myColorProperty;}
          set{_myColorProperty = value;}
    }
    //----------------------------------------------
    //Private members
    private int _myIntProperty;
    private float _myFloatProperty;
    private Color _myColorProperty;
    //----------------------------------------------
 }
 //----------------------------------------------</pre></div><p>This class will be used internally by a different class as a public member, as shown in the following code sample 8-9:</p><div class="informalexample"><pre class="programlisting"> using UnityEngine;
 using System.Collections;
 
 public class LargerClass : MonoBehaviour 
 {
    public ClassWithProperties MyPropClass;
 }</pre></div><p>By default, the public <code class="literal">MyPropClass</code> member (although tagged as <code class="literal">System.Serializable</code>) will not show its members in the Object Inspector. This is because C# properties are not natively supported:</p><div class="mediaobject"><img src="graphics/0655OT_08_11.jpg" alt="Property exposing"/><div class="caption"><p>By default, the Object Inspector will not render the C# properties</p></div></div><p>To solve this issue, we can return to the <code class="literal">PropertyDrawer</code> class; this time associating the class with a specific class rather than an attribute, as shown in the following code sample 8-10:</p><div class="informalexample"><pre class="programlisting">01 //Custom Editor class to expose global properties of a class
02 //----------------------------------------------
03 using UnityEngine;
04 using UnityEditor;
05 using System.Collections;
06 using System.Reflection;
07 //----------------------------------------------
<span class="strong"><strong>08 [CustomPropertyDrawer(typeof(ClassWithProperties))]</strong></span>
09 public class PropertyLister : PropertyDrawer
10 {
11 //Height of inspector panel
<span class="strong"><strong>12 float InspectorHeight = 0;</strong></span>
13 
14 //Height of single row in pixels
<span class="strong"><strong>15 float RowHeight = 15;</strong></span>
16 
17 //Spacing between rows
18 float RowSpacing = 5;
19 
20 // Draw the property inside the given rect
21 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) 
22 {
23        EditorGUI.BeginProperty(position, label, property);
24 
25        //Get referenced object
<span class="strong"><strong>26        object o = property.serializedObject.targetObject;</strong></span>
<span class="strong"><strong>27 ClassWithProperties CP = o.GetType().GetField(property.name).GetValue(o) as ClassWithProperties;</strong></span>
28 
29        int indent = EditorGUI.indentLevel;
30        EditorGUI.indentLevel = 0;
31 
32       //Layout
33 Rect LayoutRect = new Rect(position.x, position.y, position.width, RowHeight);
34 
35       //Find all properties for object
<span class="strong"><strong>36 foreach(var prop in typeof(ClassWithProperties).GetProperties(BindingFlags.Public | BindingFlags.Instance))</strong></span>
37       {
38              //If integer property
39              if(prop.PropertyType.Equals(typeof(int)))
40              {
41 prop.SetValue(CP, EditorGUI.IntField(LayoutRect, prop.Name, (int)prop.GetValue(CP,null)), null);

42 LayoutRect = new Rect(LayoutRect.x, LayoutRect.y + RowHeight+RowSpacing, LayoutRect.width, RowHeight);
43              }
44 
45             //If float property
46             if(prop.PropertyType.Equals(typeof(float)))
47             {
48 prop.SetValue(CP, EditorGUI.FloatField(LayoutRect, prop.Name, (float)prop.GetValue(CP,null)), null);

49 LayoutRect = new Rect(LayoutRect.x, LayoutRect.y + RowHeight+RowSpacing, LayoutRect.width, RowHeight);
50             }
51 
52             //If color property
53              if(prop.PropertyType.Equals(typeof(Color)))
54              {
55 prop.SetValue(CP, EditorGUI.ColorField(LayoutRect, prop.Name, (Color)prop.GetValue(CP,null)), null);

56 LayoutRect = new Rect(LayoutRect.x, LayoutRect.y + RowHeight+RowSpacing, LayoutRect.width, RowHeight);
57             }
58        }
59 
60        //Update inspector height
61        InspectorHeight = LayoutRect.y-position.y;
62 
63        EditorGUI.indentLevel = indent;
64        EditorGUI.EndProperty();
65 }
66 //----------------------------------------------
67 //This function returns how high (in pixels) the field should be
68 //This is to make controls not overlap
69 public override float GetPropertyHeight (SerializedProperty property, GUIContent label)
70 {
<span class="strong"><strong>71        return InspectorHeight;</strong></span>
72 }
73 //----------------------------------------------
74 }
75 //----------------------------------------------</pre></div><p>The following are the comments for code sample 8-10:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 08</strong></span>: Notice that the <code class="literal">CustomPropertyDrawer</code> attribute is now associated with a regular class as opposed to an attribute. In this case, the rendering of a specific class is being customized for the Object Inspector as opposed to various properties of different types, which can share a common attribute.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 12-18</strong></span>: Some public members are declared, primarily to calculate the height (in pixels) of a single row in the Object Inspector. By default, the Object Inspector allocates one row (or line) for our custom rendering and all drawing is supposed to fit within that space. If the total height of our rendering exceeds the height of one line, all additional controls and data will overlap and mix with controls and widgets beneath. To address this problem, the <code class="literal">GetPropertyHeight</code> (at line 69) function can be used to return a pixel height allocated for our custom drawing.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 26-27</strong></span>: These lines are especially important. They use reflection to retrieve a type-correct object reference to the <code class="literal">ClassWithProperties</code> instance currently being drawn for this call to <code class="literal">OnGUI</code>. Specifically, a reference to <code class="literal">targetObject</code> is retrieved (the object selected), and then an instance to <code class="literal">ClassWithProperties</code> is retrieved from that. The result is that this code gives us direct and immediate access to the <code class="literal">ClassWithProperties</code> object.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 37-58</strong></span>: Each public property on the object is cycled in sequence, and for valid or supported data types, an inspector property is drawn that allows both read/write access to the property, provided the property itself supports both methods.</li></ul></div><p>The following screenshot shows the C# properties:</p><div class="mediaobject"><img src="graphics/0655OT_08_12.jpg" alt="Property exposing"/><div class="caption"><p>Accessing C# properties</p></div></div></div>
<div class="section" title="Localization"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec88"/>Localization</h1></div></div></div><p>Perhaps one of the most underappreciated and underdocumented aspect of game development is localization. This refers to the broad range of technical, economic, and logistical measures a developer takes to support multiple natural languages in their game, such as English, French, German, Spanish, Esperanto, and so on. The technical aim is not so much to support this or that specific language, but rather to establish an infrastructure that could support any<a id="id646" class="indexterm"/> arbitrary language chosen at any time, now or later. The entire scope and role of localization in development is beyond the scope of this book, but here we'll examine one way in which the Unity Editor can be customized to<a id="id647" class="indexterm"/> facilitate a quick and easy localization workflow. For example, consider the following sample XML file, in which game text for the buttons in a main menu system is defined in both English and a "spoof language" called Yoda:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;text&gt;
    &lt;language id="english"&gt;
         &lt;text_entry id="text_01"&gt;&lt;![CDATA[new game]]&gt;&lt;/text_entry&gt;
         &lt;text_entry id="text_02"&gt;&lt;![CDATA[load game]]&gt;&lt;/text_entry&gt;
         &lt;text_entry id="text_03"&gt;&lt;![CDATA[save game]]&gt;&lt;/text_entry&gt;
         &lt;text_entry id="text_04"&gt;&lt;![CDATA[exit game]]&gt;&lt;/text_entry&gt;
   &lt;/language&gt;
   &lt;language id="yoda"&gt;
         &lt;text_entry id="text_01"&gt;&lt;![CDATA[new game, you start]]&gt;&lt;/text_entry&gt;
         &lt;text_entry id="text_02"&gt;&lt;![CDATA[load game, you will]]&gt;&lt;/text_entry&gt;
         &lt;text_entry id="text_03"&gt;&lt;![CDATA[game save, you have]]&gt;&lt;/text_entry&gt;
         &lt;text_entry id="text_04"&gt;&lt;![CDATA[leave now, you must]]&gt;&lt;/text_entry&gt;
   &lt;/language&gt;
&lt;/text&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip59"/>Tip</h3><p>Notice, the CDATA element encloses all custom text nodes to allow the use of any characters and symbols. More information on CDATA can<a id="id648" class="indexterm"/> be found online at <a class="ulink" href="http://www.w3schools.com/xml/xml_cdata.asp">http://www.w3schools.com/xml/xml_cdata.asp</a>.</p></div></div><p>The XML defined earlier creates four text elements, one for each button on a sample user interface menu. Each text element is assigned a unique ID: <code class="literal">text_01</code>, <code class="literal">text_02</code>, <code class="literal">text_03</code>, and <code class="literal">text_04</code>. These IDs uniquely identify each item of text in the game and will match across all specified languages. The purpose here is to import the text file into Unity that allows the <a id="id649" class="indexterm"/>developer to switch between languages at the touch of a button, and have all relevant text elements in the game change automatically to accommodate the language switch. Let's see how this works.</p><p>First import the localized text into a <code class="literal">Resources</code> folder in a Unity project. Create a folder named <code class="literal">Resources</code> and then import the localized text file into it, as shown in the following screenshot. In code, this means any object or class can load or open the text file using a <code class="literal">Resources.Load</code> call, as we'll see soon.</p><div class="mediaobject"><img src="graphics/0655OT_08_13.jpg" alt="Localization"/><div class="caption"><p>Importing localized text into a project</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip60"/>Tip</h3><p>More information<a id="id650" class="indexterm"/> on resources can be found online at the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Resources.html">http://docs.unity3d.com/ScriptReference/Resources.html</a>.</p></div></div><p>The imported text file simply contains all text data to be included in the game, where each element is associated with its ID. Thus, each string value is married to an ID, and the ID is consistent across language schemes that allow a seamless transition between languages. The ID is the one common denominator that makes an automated localization possible. To implement the localization system in code, we'll first create an attribute that should be applied to all localized strings. The attribute defines only the ID to be attached to a specific string variable, as shown in the following code sample 8-11:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
 using System.Collections;
 
 //Attribute to attach to string objects
 public class LocalizationTextAttribute : System.Attribute
 {
    //ID to assign
    public string LocalizationID = string.Empty;
 
    //Constructor
    public LocalizationTextAttribute(string ID)
    {
           LocalizationID = ID;
   }
 }</pre></div><p>With the <code class="literal">LocalizationTextAttribute</code> attribute now created, we can apply it to string members in code, which <a id="id651" class="indexterm"/>associates them with a specific ID, as shown in the following code sample 8-12:</p><div class="informalexample"><pre class="programlisting">//----------------------------------------------
 using UnityEngine;
 using System.Collections;
 //----------------------------------------------
 public class SampleGameMenu : MonoBehaviour 
 {
    [LocalizationTextAttribute("text_01")]
    public string NewGameText = string.Empty;
 
    [LocalizationTextAttribute("text_02")]
    public string LoadGameText = string.Empty;
 
   [LocalizationTextAttribute("text_03")]
   public string SaveGameText = string.Empty;
 
    [LocalizationTextAttribute("text_04")]
    public string ExitGameText = string.Empty;
 }
 //----------------------------------------------</pre></div><p>The <code class="literal">SampleGameMenu</code> class appears as a regular class in the Object Inspector, as shown in the following screenshot. Later, through our <code class="literal">Editor</code> class, we'll develop the ability to automatically change all string members to the selected language.</p><div class="mediaobject"><img src="graphics/0655OT_08_14.jpg" alt="Localization"/><div class="caption"><p>A SampleGameMenu class features all texture required for a sample menu screen</p></div></div><p>Now, we'll code an <code class="literal">Editor</code> class to switch between languages. This class will add menu entries on the application menu, which when clicked will change the active language, as shown in the following code sample 8-13. This sample draws on a range of related concepts we've seen <a id="id652" class="indexterm"/>already, including new ones. Specifically, it uses the <code class="literal">Reflection</code>, <code class="literal">Linq</code>, and <code class="literal">Editor</code> classes as well as the Mono Framework XML handling classes:</p><div class="informalexample"><pre class="programlisting">01 //-------------------------------------------
02 using UnityEngine;
03 using UnityEditor;
04 using System.Collections;
05 using System.Xml;
06 using System.Linq;
07 using System.Reflection;
08 //-------------------------------------------
09 public class LanguageSelector
10 {
<span class="strong"><strong>11 [MenuItem ("Localization/English")]</strong></span>
12 public static void SelectEnglish()
13 {
14        LanguageSelector.SelectLanguage("english");
15 }
16 
<span class="strong"><strong>17 [MenuItem ("Localization/French")]</strong></span>
18 public static void SelectFrench()
19 {
20        LanguageSelector.SelectLanguage("french");
21 }
22 
<span class="strong"><strong>23 [MenuItem ("Localization/Yoda")]</strong></span>
24 public static void SelectYoda()
25 {
26        LanguageSelector.SelectLanguage("yoda");
27 }
28 
29 public static void SelectLanguage(string LanguageName)
30 {
31        //Access XML Text File in Project
<span class="strong"><strong>32 TextAsset textAsset = Resources.Load("LocalText") as TextAsset;</strong></span>
33 
34        //Load text into XML Reader object
<span class="strong"><strong>35         XmlDocument xmlDoc = new XmlDocument();</strong></span>
<span class="strong"><strong>36         xmlDoc.LoadXml(textAsset.text);</strong></span>
37 
38       //Get language nodes
39 XmlNode[] LanguageNodes = (from XmlNode Node in xmlDoc.GetElementsByTagName("language")

40 where Node.Attributes["id"].Value.ToString().Equals(LanguageName.ToLower())
41       select Node).ToArray();
42 
43        //If no matching node found, then exit
44        if(LanguageNodes.Length &lt;= 0)
45              return;
46 
47       //Get first node
48       XmlNode LanguageNode = LanguageNodes[0];
49 
50      //Get text object
51 SampleGameMenu GM = Object.FindObjectOfType&lt;SampleGameMenu&gt;() as SampleGameMenu;
52 
53      //Loop through child xml nodes
54      foreach (XmlNode Child in LanguageNode.ChildNodes)
55        {
56              //Get text Id for this node
57              string TextID = Child.Attributes["id"].Value;
58               string LocalText = Child.InnerText;
59 
60              //Loop through all fields
<span class="strong"><strong>61 foreach(var field in GM.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy))</strong></span>
62              {
63                    //If field is a string then is relevant
64                    if(field.FieldType == typeof(System.String))
65                    {
66                          //Get custom attributes for field
67 System.Attribute[] attrs = field.GetCustomAttributes(true) as System.Attribute[];

68 
69                    foreach (System.Attribute attr in attrs)
70                    {
71        if(attr is LocalizationTextAttribute)
72                                 {
73                                     //We've found text
74 LocalizationTextAttribute LocalAttr = attr as LocalizationTextAttribute;
75 
76               if(LocalAttr.LocalizationID.Equals( TextID ))
77                           {
78                          //id matches, now set value
79                          field.SetValue(GM, LocalText);
80                           }
81                     }
82              }
83              }
84       }
85       }
86 }
87 }
88 //-------------------------------------------</pre></div><p>The following are the comments for code sample 8-13:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 02-07</strong></span>: Remember to include wide range of namespaces as shown here. Our code will rely on them all to some degree.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 11-23</strong></span>: For this sample application, the three languages: <span class="strong"><strong>English</strong></span>, <span class="strong"><strong>French</strong></span>, and <span class="strong"><strong>Yoda</strong></span> are selectable from the application menu. For your own projects, your language<a id="id653" class="indexterm"/> list may be different. But crucially, based on the localization system given here, integration of additional languages, even at a much later time, is easy.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 32</strong></span>: The <code class="literal">Resources.Load</code> function is called here to open the XML text file from the <code class="literal">Resources</code> folder in the project that extracts its text contents into one single concatenated string variable.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 35-36</strong></span>: The XML string is loaded into an <code class="literal">XmlDocument</code> object, which is a Mono class encapsulating a complete XML file, either on disk or in memory. The class also validates the document on loading, which means an exception will be generated here if the file contains syntax errors.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 53</strong></span>: Once a language is selected from the XML file, all child nodes of the language (each node a unique string) are cycled to find a matching ID.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 61</strong></span>: For each <a id="id654" class="indexterm"/>string entry, all public string members for the text class are searched for an appropriate <code class="literal">LocalizationTextAttribute</code> and when found, the string ID is compared to check for a match. When a match is found, the string variable is assigned the corresponding localized string.</li></ul></div><p>To use the localization framework given here, first add a <code class="literal">SampleGameMenu</code> object to the scene as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_08_15.jpg" alt="Localization"/><div class="caption"><p>Adding a Sample Game Menu object to the scene with localized text members</p></div></div><p>Then, choose a language from the application main menu by selecting <span class="strong"><strong>English</strong></span> or <span class="strong"><strong>Yoda</strong></span> from the <span class="strong"><strong>Localization</strong></span> tab, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_08_16.jpg" alt="Localization"/><div class="caption"><p>Setting the active language for the game</p></div></div><p>Once the active<a id="id655" class="indexterm"/> language is specified, all strings with the <code class="literal">LocalizationTextAttribute</code> attribute will be updated, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_08_17.jpg" alt="Localization"/><div class="caption"><p>Localized text is updated after selecting an active language</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec89"/>Summary</h1></div></div></div><p>This chapter explored in depth the relationship between reflection, as a concept, and its practical use for creating <code class="literal">Editor</code> classes that extended the editor behavior beyond its defaults to accommodate custom intentions. The ability to do this is not always essential to building Unity games themselves but it can make your work easier. Furthermore, it can lead to making money via the Asset Store, should you wish to develop custom add-ons that can help other developers. Here, you saw how to create a Batch Rename tool with the <code class="literal">ScriptableWizard</code> class and then a color blending property for the Object Inspector. Next, we made extensive use of reflection to expose all public C# properties in the Object Inspector that allowed us direct access to the set and get property values as if we'd accessed them at runtime. Further, we moved on to see how a localization framework could be implemented from XML files via the <code class="literal">Editor</code> classes that allow string variables to be automatically changed to match a selected language. For more information, you can visit <a class="ulink" href="http://catlikecoding.com/unity/tutorials/editor/custom-data/">http://catlikecoding.com/unity/tutorials/editor/custom-data/</a> and <a class="ulink" href="http://catlikecoding.com/unity/tutorials/editor/custom-list/">http://catlikecoding.com/unity/tutorials/editor/custom-list/</a>. In the next chapter, we'll move our conceptual and technical baggage to explore the world of 2D from more unconventional angles.</p></div></body></html>