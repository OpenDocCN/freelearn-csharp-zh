<html><head></head><body>
		<div><h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor117"/>Chapter 6</em>: The .NET Collections </h1>
			<p>Collections are an integral part of .NET. There are different ways to use these collections. Microsoft .NET makes heavy use of arrays and collections when dealing with things such as datasets, arrays, lists, dictionaries, stacks, and queues. You will be hard-pressed to write a C# program without having to use the Collections Framework. The different ways of using the collections and arrays differ in terms of their performance degradation and performance improvement. Therefore, understanding when to use arrays and when to use collections will form an important aspect of your C# and .NET programming skills.</p>
			<p>In this chapter, you will learn how to improve the performance of your collection operations. By using <code>BenchmarkDotNet</code> with different versions of the code, you will be able to see the differences in performance and be in a position to choose the best method that suits your needs.</p>
			<p>We will be covering the following topics in this chapter:</p>
			<ul>
				<li><code>System.Collections</code>, <code>System.Collections.Generic</code>, <code>System.Collections.Concurrent</code>, and <code>System.Collections.Specialized</code> namespaces. </li>
				<li><code>IEnumerable</code> and <code>IQueryable</code>. This section will show you how to develop our sample database with sample data that will be used later in this chapter.</li>
				<li><strong class="bold">Deciding between interfaces and concrete classes</strong>: In this section, you will benchmark the performance between using classes and interfaces. Then, you will be able to decide on the method that best suits your needs.</li>
				<li><strong class="bold">Deciding between using arrays or collections</strong>: There are strengths and weaknesses between using arrays and collections. In this section, you will benchmark the performance of arrays and collections and decide which to use based on your performance requirements.</li>
				<li><strong class="bold">Accessing objects using indexers</strong>: In this section, we will discuss accessing objects in the same way we would access items in an array by using indexers.</li>
				<li><strong class="bold">Comparing IEnumerable and IEnumerator</strong>: In this section, we will benchmark iterations using both IEnumerable and IEnumerator. You will see that there is a definite performance difference between these ways of enumerating.</li>
				<li><strong class="bold">Database query performance</strong>: In this section, we will query a database using five different methods, benchmarking their performance to see which method produces the fastest performance.</li>
				<li><code>yield</code> keyword and how it relates to the performance of your applications, especially when it comes to iterating through collections and arrays.</li>
				<li><strong class="bold">Learning the difference between concurrency and parallelism</strong>: In this section, you will understand the difference between concurrency and parallelism, and learn when to use one over the other.</li>
				<li><strong class="bold">Learning the difference between Equals() and ==</strong>: In this section, you will understand the differences between the different equality operators, and learn when to use one over the other.</li>
				<li><strong class="bold">Studying LINQ performance</strong>: LINQ is a C# query language that is heavily utilized when it comes to processing collections, but it can be slow or fast, depending on the way you code your queries. In this section, you will learn how to benchmark different ways of performing the same types of queries. In doing so, you will see the difference in performance between the different ways of writing the same queries.</li>
			</ul>
			<p>By the end of this chapter, you will be able to do the following:</p>
			<ul>
				<li>Describe the different collections available and their uses</li>
				<li>Choose between using interfaces and collections</li>
				<li>Understand the trade-offs between arrays and collections</li>
				<li>Write indexers</li>
				<li>Choose the best form of iteration for your particular needs</li>
				<li>Use the <code>yield</code> keyword</li>
				<li>Know which equality operator to use for different types of equality checking</li>
				<li>Improve LINQ query performance</li>
			</ul>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need access to the following tools:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>SQL Server (any version) Express or higher</li>
				<li>SQL Server Management Studio</li>
				<li>This book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06</a><a href="https://github.com/PacktPublishing/Mastering-High-Performance-with-C-10.0-and-.NET-6&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Understanding the different collection offerings</h1>
			<p>A collection<a id="_idIndexMarker607"/> is a group of records that can be treated as one logical unit. Examples of logical record groups include people, countries, products, ingredients, books, authors, and more. </p>
			<p>There are four main types of collections, as follows:</p>
			<ul>
				<li><strong class="bold">Index-based</strong> collections, such as an array<a id="_idIndexMarker608"/> or list. Index-based collections<a id="_idIndexMarker609"/> contain an internal index. The index can be either numeric or string-based. An index-based collection is more commonly accessed using a numerical index. Numerical indexes are zero-based. This means that a collection's index will start<a id="_idIndexMarker610"/> at zero for the first record<a id="_idIndexMarker611"/> and increase in value by the order of one for each subsequent record. Collections that can be accessed using numerical indexes include arrays and lists. </li>
				<li><code>Hashtable</code> and <code>SortedList</code> use a key to look up the value stored in a collection. So, for example, if you have a collection of products, you can access the product you need by using the product code that was assigned as the key when the product was added to the key/value pair collection.</li>
				<li><strong class="bold">Prioritized</strong> collections, such as a stack<a id="_idIndexMarker614"/> or queue. Prioritized collections<a id="_idIndexMarker615"/> allow you to store and extract<a id="_idIndexMarker616"/> records in a particular sequence. A queue uses the <strong class="bold">First In First First Out</strong> (<strong class="bold">FIFO</strong>) sequence, while a stack<a id="_idIndexMarker617"/> uses the <strong class="bold">Last In First Out</strong> (<strong class="bold">LIFO</strong>) sequence.</li>
				<li><code>CollectionsUtil</code> class, which creates collections that ignore the case in strings, and the <code>ListDictionary</code> class, which is recommended for collections that contain less than 10 items. It implements <code>IDictionary</code> using a singly linked list.</li>
			</ul>
			<p>The .NET Collections Framework consists of the legacy <code>System.Collections</code> namespaces, as well as the newer <code>System.Collections.Generic</code>, <code>System.Collections.Concurrent</code>, and <code>System.Collections.Specialized</code> namespaces. Before we delve into the performance of collections, it is a good idea to reacquaint ourselves with the different collections that are available in each of the aforementioned namespaces.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>The System.Collections namespace</h2>
			<p>The <code>System.Collections</code> namespace contains various<a id="_idIndexMarker620"/> classes, structures, and<a id="_idIndexMarker621"/> interfaces. In this section, we will briefly cover what is available. The collections in this namespace are not thread-safe. If you require thread-safe collections, it would be better to use the collections in the <code>System.Collections.Concurrent</code> namespace instead, as advised by Microsoft!</p>
			<p>The <code>ICollection</code> interface defines the size, enumerators, and synchronization methods for all non-generic collections. To compare two objects, you can implement the <code>IComparer</code> interface. You can represent non-generic key/value pair collections using <code>Idictionary</code>. To enumerate a non-generic dictionary, you can use the <code>IDictionaryEnumerator</code> interface. Simple iteration over non-generic collections is provided by the <code>IEnumerator</code> interface, while equality between objects is implemented via the <code>IEqualityComparer</code> interface. The <code>IList</code> interface is used to implement non-generic collections of objects that can be individually accessed using the index. Structural comparison of objects and structural equality comparison of objects is implemented using the <code>IStructuralComparable</code> and <code>IStructuralEquatable</code> interfaces, respectively.</p>
			<ul>
				<li>The <code>ArrayList</code> class implements the <code>IList</code> interface using a dynamic array that can grow and shrink in size as required. </li>
				<li>On (<code>0</code>) and off (<code>1</code>), which are represented by the Boolean values <code>false</code> and <code>true</code>, respectively, are managed by the <code>BitArray</code> class. </li>
				<li>To compare two objects while ignoring string casing, you can use the <code>CaseInsensitiveComparer</code> class. Use <code>CaseInsensitiveHashCodeProvider</code> to generate hash codes using algorithms that ignore string casing. </li>
				<li>When you're building a strongly typed collection, inherit from the <code>CollectionBase</code> class. </li>
				<li>The <code>Comparer</code> class is used to compare two objects for equivalence with case-sensitive string comparison. </li>
				<li>Use <code>DictionaryBase</code> as the abstract class when developing strongly typed collections of key/value pairs. </li>
				<li>A collection of key/value pairs organized by key-based hash codes is represented by the <code>Hashtable</code> class. </li>
				<li>The <code>Queue</code> class provides a collection with FIFO access. </li>
				<li>The <code>ReadOnlyCollectionBase</code> abstract class is used as the base class for strongly typed non-generic, read-only collections. </li>
				<li>Use the <code>SortedList</code> class to hold a collection of key/value pairs that are sorted by the keys and are accessible by key or index. </li>
				<li>Use the <code>Stack</code> class if you need LIFO access for your collection. </li>
				<li>To compare two collection objects structurally, you can use the <code>StructuralComparisons</code> class. </li>
				<li>The <code>DictionaryEntry</code> structure defines a dictionary key/value pair that can be set or retrieved. <p class="callout-heading">Note</p><p class="callout"><code>IHashCodeProvider</code> has now been marked obsolete and is no longer recommended by Microsoft for new development. Microsoft recommends that you use the <code>IEqualityComparer</code> and <code>IEqualityComparer&lt;T&gt;</code> interfaces instead.</p></li>
			</ul>
			<p>We now know<a id="_idIndexMarker622"/> what is available in<a id="_idIndexMarker623"/> the <code>System.Collections</code> namespace. Now, let's look at what's available in the <code>System.Collections.Generic</code> namespace.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>The System.Collections.Generic namespace</h2>
			<p>The classes and interfaces<a id="_idIndexMarker624"/> that are available in the <code>System.Collections.Generic</code> namespace provide<a id="_idIndexMarker625"/> collections that are strongly typed and that perform better than the classes within the <code>System.Collections</code> namespace. This namespace contains many classes, structs, and interfaces.</p>
			<p>The <code>CollectionExtensions</code> class provides<a id="_idIndexMarker626"/> extension methods for generic collections. To compare two objects, you<a id="_idIndexMarker627"/> can use the <code>Comparer&lt;T&gt;</code> class, which implements the <code>IComparer&lt;T&gt;</code> interface. The <code>IComparer&lt;T&gt;</code> interface defines the method types to implement to compare two objects.</p>
			<p>The <code>IDictionary&lt;TKey, TValue&gt;</code> interface provides methods for implementing generic dictionaries. For a dictionary to be read-only, it must implement the <code>IReadOnlyDictionary&lt;TKey, TValue&gt;</code> interface. A collection of keys and values is represented by the <code>Dictionary&lt;TKey, TValue&gt;</code> class. <code>Dictionary&lt;TKey, TValue&gt;.KeyCollection</code> cannot be inherited and represents the collection of keys within a <code>Dictionary&lt;TKey, TValue&gt;</code> collection. Finally, <code>Dictionary&lt;TKey, TValue&gt;.ValueCollection</code> cannot be inherited and represents the collection of values within a <code>Dictionary&lt;TKey, TValue&gt;</code> collection.</p>
			<p>The <code>IEqualityComparer&lt;T&gt;</code> interface defines methods that you can use to compare objects for equality. A base class for implementations of the <code>IEqualityComparer&lt;T&gt;</code> interface is provided called <code>EqualityComparer&lt;T&gt;</code>.</p>
			<p><code>HashSet&lt;T&gt;</code> represents a set of values. When a key that's been used to access a collection cannot be found within the collection that's being searched, then a <code>KeyNotFoundException</code> is raised. A key/value pair instance is generated using the <code>KeyValuePair</code> class. For a doubly linked list, use the <code>LinkedList&lt;T&gt;</code> class. The non-inheritable <code>LinkedListNode&lt;T&gt;</code> class represents a node in a collection of the <code>LinkedList&lt;T&gt;</code> type.</p>
			<p><code>IList&lt;T&gt;</code> represents a collection of objects for implementing lists that can be accessed by index. Read-only lists implement the <code>IReadOnlyList&lt;T&gt;</code> interface. When you need a collection that is strongly typed that enables searching, sorting, and manipulating lists, then use the <code>List&lt;T&gt;</code> class. For FIFO collections, use the <code>Queue&lt;T&gt;</code> class.</p>
			<p><code>ReferenceEqualityComparere</code> is an <code>IEqualityComparer&lt;T&gt;</code> that uses reference equality by calling <code>ReferenceEquals(Object, Object)</code> instead of using value equality by calling <code>Equals(Object)</code> when comparing two object instances.</p>
			<p>A key/value pair collection that's sorted on the key is represented by the <code>SortedDictionary&lt;TKey, TValue&gt;</code> class. This type of collection is represented by <code>SortedDictionary&lt;TKey, TValue&gt;.KeyCollection</code>, which cannot be inherited. The values that have been collected are represented by <code>SortedDictionary&lt;TKey, TValue&gt;.ValueCollection</code>, which cannot be inherited.</p>
			<p>The <code>SortedList&lt;TKey, TValue&gt;</code> class represents<a id="_idIndexMarker628"/> a collection of key/value pairs that are sorted by key based<a id="_idIndexMarker629"/> on the associated <code>IComparer&lt;T&gt;</code> implementation. A collection of objects that has been maintained in sorted order is represented by the <code>SortedSet&lt;T&gt;</code> class. The <code>Stack&lt;T&gt;</code> class provides LIFO manipulation for instances of the same type.</p>
			<p>There are several structures available for the various generic collection classes that allow you to enumerate<a id="_idIndexMarker630"/> the elements in the collection. These structures are called enumerators.</p>
			<p>Asynchronously enumerating over values of a specific type can be done by implementing the <code>IAsyncEnumerable&lt;T&gt;</code> interface. <code>IAsyncEnumerator&lt;T&gt;</code> provides the necessary support to iterate over a generic collection. <code>ICollection&lt;T&gt;</code> defines the methods needed to manipulate generic collections. Strongly typed collections that are read-only implement the <code>IReadOnlyCollection&lt;T&gt;</code> interface. Sets implement the <code>ISet&lt;T&gt;</code> interface, while read-only sets implement the <code>IReadOnlySet&lt;T&gt;</code> interface.</p>
			<p>Now that we've looked at what the <code>System.Collections.Generic</code> namespace has to offer, let's turn our attention to the <code>System.Collections.Concurrent</code> namespace.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>The System.Collections.Concurrent namespace</h2>
			<p>The collections in the <code>System.Collections.Concurrent</code> namespace<a id="_idIndexMarker631"/> are thread-safe. Whenever multiple<a id="_idIndexMarker632"/> threads are concurrently accessing a collection, use the collections in this namespace over the collections in the <code>System.Collections</code> and <code>System.Collections.Generic</code> namespaces.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Extension methods and explicit interface implementations of these collections are not guaranteed to be thread-safe. To ensure thread safety, synchronization may be required in these instances.</p>
			<p><code>IProducerConsumerCollection&lt;T&gt;</code> defines methods that form<a id="_idIndexMarker633"/> the basis of thread-safe collection manipulation<a id="_idIndexMarker634"/> in producer/consumer usage (also known as publisher/subscriber usage). Higher-level abstractions<a id="_idIndexMarker635"/> such as the <code>BlockingCollection&lt;T&gt;</code> class can use<a id="_idIndexMarker636"/> this collection as their underlying storage mechanism.</p>
			<p>The <code>BlockingCollection&lt;T&gt;</code> class provides blocking and bounding capabilities to thread-safe collections that implement the <code>IProducerConsumerCollection&lt;T&gt;</code> interface.</p>
			<p>Options to control partitioner buffering behavior are specified by the <code>EnumerablePartitionerOptions</code> enum.</p>
			<p>Arrays, lists, and enumerable partitioning strategies are provided by the <code>Partitioner</code> class. The <code>Partitioner&lt;Tsource&gt;</code> class provides a particular manner of splitting a data source into multiple partitions, while <code>OrderablePartioner&lt;Tsource&gt;</code> splits an orderable data source into multiple partitions.</p>
			<p>The <code>Concurrent&lt;T&gt;</code> class contains a thread-safe unordered list of objects. Thread-safe FIFO collections use the <code>ConcurrentQueue&lt;T&gt;</code> class, while thread-safe LIFO collections use the <code>ConcurrentStack&lt;T&gt;</code> class. To concurrently access key/value pairs in a thread-safe manner, use the <code>ConcurrentDictionary&lt;Tkey, Tvalue&gt;</code> class.</p>
			<p>With that, we've covered the <code>System.Collections.Concurrent</code> namespace. Now, let's look at the <code>System.Collections.Specialized</code> namespace.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>The System.Collections.Specialized namespace</h2>
			<p>The <code>System.Collections.Specialized</code> namespace contains<a id="_idIndexMarker637"/> specialized and strongly<a id="_idIndexMarker638"/> typed collections. Let's see what it has to offer.</p>
			<p>The <code>CollectionChangedEventManager</code> class provides a <code>WeakEventManager</code> implementation. By using the <code>WeakEventListener</code> pattern, you can attach listeners for the collection-changed event.</p>
			<p>To build a collection of strings that ignores the string casing, you can use the <code>CollectionUtils</code> class.</p>
			<p>The <code>HybrdDictionary</code> class changes its behavior when the collection is small, and when the collection grows in size. It does this by implementing <code>IDictionary</code> using a <code>ListDictionary</code> when the collection is small; it uses a <code>Hashtable</code> when the collection grows in size and becomes large.</p>
			<p>For fewer than 10 items, you can use <code>ListDictionary</code>, which implements <code>IDictionary</code> by using a singly linked list.</p>
			<p>To hold a collection of the string keys of a collection, use <code>NameObjectCollectionBase.KeysCollection</code>.</p>
			<p>When you need to provide data for the <code>CollectionChanged</code> event, use the <code>NotifyCollectionChangedEventArgs</code> class.</p>
			<p>When you have an ordered collection of key/value pairs that you need to be accessible via either the key or the index, use <code>OrderedDictionary</code>.</p>
			<p>You can use the <code>StringCollection</code> class to hold a collection of strings, and you can use the <code>StringEnumerator</code> class to perform a simple iteration of the <code>StringCollection</code> class.</p>
			<p>To get a hash table of keys and strongly typed string values, use the <code>StringDictionary</code> class.</p>
			<p>To store a Boolean value or small integer in 32 bits of memory, you can use the <code>BitVector32</code> structure. You can use <code>BitVector32.Section</code> of the vector to store an integer number.</p>
			<p>Indexed collections of key/value pairs are represented by the <code>IOrderedDictionary</code> interface. The <code>INotifyCollectionChanged</code> interface is used to notify listeners of dynamic changes to a collection, such as when items are added, modified, or removed. The <code>NotifyCollectionChangedAction</code> enum describes<a id="_idIndexMarker639"/> the action that resulted<a id="_idIndexMarker640"/> in the <code>CollectionChanged</code> event being fired.</p>
			<p>Now, let's look at custom collections and write one.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>Creating custom collections</h2>
			<p>To create custom<a id="_idIndexMarker641"/> collections, you must inherit from <code>CollectionBase</code>. The <code>CollectionBase</code> class has a read-only <code>ArrayList</code> property called <code>InnerList</code>, and it implements the <code>IList</code>, <code>ICollection</code>, and <code>IEnumerable</code> interfaces. Then, you can add your own <code>Add</code>, <code>Remove</code>, <code>Clear</code>, and <code>Count</code> methods. We'll do this in our project. We will create a very simple custom collection that inherits from <code>CollectionBase</code> so that you can see how easy it is to create custom collections. Follow these steps:</p>
			<ol>
				<li>Add a new class under the <code>CustomCollections</code> folder called <code>CustomCollections</code> that inherits from <code>CollectionBase</code>.</li>
				<li>Add the <code>Add(object item)</code> method to the class:<pre>public void Add(object item)
{
      InnerList.Add(item);
}</pre></li>
			</ol>
			<p>This method adds an item to <code>InnerList</code>, which we have inherited from the <code>CollectionBase</code> class.</p>
			<ol>
				<li value="3">Add the <code>Remove(object item)</code> method to the class:<pre>public void Remove(object item)
{
      InnerList.Remove(item);
}</pre></li>
			</ol>
			<p>This method removes<a id="_idIndexMarker642"/> an item from the inherited <code>InnerList</code>.</p>
			<ol>
				<li value="4">Add the <code>Clear()</code> method:<pre>public new void Clear()
{
InnerList.Clear();
}</pre></li>
			</ol>
			<p>This method clears all the items from <code>InnerList</code>.</p>
			<ol>
				<li value="5">Add the <code>Count()</code> method:<pre>public new int Count()
{
      return InnerList.Count;
}</pre></li>
			</ol>
			<p>This method returns the count of the number of items in <code>InnerList</code>.</p>
			<p>As you can see, creating custom collections does not have to be hard. Our implementation is very simple and basic. However, such a class can be made to hold specific types instead of the generic object type. You could also make your class generic so that it accepts classes that implement a specific interface.</p>
			<p>The following is a detailed article by<a id="_idIndexMarker643"/> Microsoft on implementing custom collections by implementing <code>ICollection</code>: <a href="https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.">https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.</a></p>
			<p>As you read through this chapter, you will see different aspects of collections. You will also measure their performance. This way, as you create custom collections, you can choose the most performant way of doing things for the tasks at hand.</p>
			<p>Now that we've briefly<a id="_idIndexMarker644"/> covered the different collection offerings in the .NET Collections Framework, let's look at what Big O notation is.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>Understanding Big O notation</h1>
			<p>Big O notation is used to determine algorithmic<a id="_idIndexMarker645"/> efficiency. It determines how time scales concerning input. Constant time equates to a Big O notation value of O(1). Data operations that scale linearly over time, depending on the size of the operation, have a Big O notation value of (<em class="italic">N</em>), where <em class="italic">N</em> equals the amount of data being processed. </p>
			<p>For example, if you were iterating over several elements in an array or collection, you would use O(<em class="italic">N</em>), which is a linear time, where <em class="italic">N</em> is the size of the array or collection. If an iteration contains pairs such as <em class="italic">x</em> and <em class="italic">y</em>, where you iterate over <em class="italic">x</em> in the iteration and then <em class="italic">y</em> in the iteration, then your Big O notation would be O(<em class="italic">N</em>2). Another scenario would be identifying the amount of time it takes to harvest a square plot of land. This could be written as O(<em class="italic">a</em>), where <em class="italic">a</em> is the area of land. Alternatively, you could write the Big O notation as O(<em class="italic">s</em>2), where <em class="italic">s</em> is the length of one size.</p>
			<p>There are some rules<a id="_idIndexMarker646"/> to consider when using Big O notation:</p>
			<ul>
				<li>Different steps in your algorithm are added together. So, if step 1 takes O(<em class="italic">a</em>) time, and step 2 takes O(<em class="italic">b</em>) time, then your Big O notation for the algorithm will be O(<em class="italic">a+b</em>).</li>
				<li>Drop constants. For example, if you have two operations that are both constants in your algorithm, you do not write O(<em class="italic">2N</em>). The notation remains O(<em class="italic">N</em>).</li>
				<li>If you have different inputs that are different variables, such as collection a and collection b, then your Big O notation would be O(<em class="italic">a*b</em>).</li>
				<li>Drop non-dominant terms. So, O(<em class="italic">n</em>2) is equivalent to O(<em class="italic">n + n</em>2), which is equivalent to (<em class="italic">n</em>2<em class="italic">+n</em>2).</li>
			</ul>
			<p>Now that we understand what Big O notation is and the various collections available to us, let's look at choosing the right collections for our work items.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Choosing the right collection</h2>
			<p>The key to performance when working<a id="_idIndexMarker647"/> with multiple items of data in memory is to choose the correct storage mechanism that offers the fastest processing time for your requirements. Here's the list of the different types of collections and their strengths to help you choose the right collections for the right tasks:</p>
			<ul>
				<li>A <code>Dictionary</code> is an unordered<a id="_idIndexMarker648"/> collection with contiguous storage that is directly accessible via a key. A dictionary's lookup efficiency using a key is O(1) and its manipulation efficiency is also O(1). Dictionaries are best used for high-performance lookups.</li>
				<li>A <code>HashSet</code> is unordered, has contiguous<a id="_idIndexMarker649"/> storage, and is directly accessible via a key. It has a lookup efficiency using a key of O(1), and a manipulation efficiency of O(1). <code>HashSet</code> is a unique unordered collection, called <code>Dictionary</code>, except the key and the value are the same object.</li>
				<li>A <code>LinkedList</code> lets the user have complete<a id="_idIndexMarker650"/> control over how it is ordered, does not have contiguous storage, and is not directly accessible. It has a lookup efficiency value of O(<em class="italic">n</em>), and a manipulation efficiency of O(1). It's best to use lists when you need to insert or remove items and no direct access is required.</li>
				<li>A <code>List</code> lets the user have complete control<a id="_idIndexMarker651"/> over how it is ordered, has contiguous storage, and is directly accessible via an index. It has a lookup efficiency using an index of O(1), and a lookup efficiency using a value of O(<em class="italic">n</em>). Its manipulation efficiency is O(<em class="italic">n</em>). It is best to use this list when direct access is required, the list is small, and there is no sorting.</li>
				<li>A <code>Queue</code> is ordered according<a id="_idIndexMarker652"/> to FIFO, has contiguous storage, and only has direct access from the front of the queue. It has a lookup efficiency at the front of the queue of O(1), and a manipulation index of O(1). It is essentially<a id="_idIndexMarker653"/> the same as <code>List&lt;T&gt;</code>, except it is only processed using FIFO.</li>
				<li>A <code>SortedDictionary</code> is ordered, does not have contiguous storage, and can be directly<a id="_idIndexMarker654"/> accessed using a key. It has a lookup efficiency using the key of O(<em class="italic">log n</em>) with a manipulation efficiency of O(<em class="italic">log n</em>). This collection makes a trade-off between speed and ordering and uses a binary search tree.</li>
				<li>A <code>SortedList</code> is ordered, has contiguous<a id="_idIndexMarker655"/> storage, and is directly accessible via a key. It has a lookup<a id="_idIndexMarker656"/> efficiency using the key of O(<em class="italic">log n</em>) and a manipulation efficiency of (O(<em class="italic">n</em>). The tree is implemented as an array, making lookups faster on preloaded data, but slower on loads.</li>
				<li>A <code>SortedSet</code> is ordered, does not have<a id="_idIndexMarker657"/> contiguous storage, and is directly accessible via a key. It has a lookup efficiency using a key of O(<em class="italic">log n</em>), and a manipulation efficiency of O(<em class="italic">log n</em>). It's a unique sorted collection, similar to a <code>SortedDictionary</code>, except the key and value are the same object.</li>
				<li>A <code>Stack</code> is ordered according to LIFO, has<a id="_idIndexMarker658"/> contiguous storage, and can only be directly accessed from the top of the stack. It has a lookup efficiency of the top item of O(1) and a manipulation efficiency of O(1)*. It is essentially the same as <code>List&lt;T&gt;</code>, except it is only processed using LIFO.<p class="callout-heading">Note</p><p class="callout">For mission-critical code, it is advised that you avoid using classes in the <code>System.Collection</code> namespace. Instead, you should be using the classes from the <code>System.Collections.Generic</code> namespace. Although this may sound like tried and tested advice, you are advised to run benchmark tests to see which method is best for your particular scenario.</p></li>
			</ul>
			<p>Now that you have been introduced to arrays and collections, we will set up our sample database before we continue looking at collections from a performance perspective.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor127"/>Setting up our sample database</h1>
			<p>In this chapter, we will be demonstrating<a id="_idIndexMarker659"/> the difference between how different collection interfaces handle data. For our demonstrations, we require access to database data. To do so, we will create a database, add a table to it, and populate it with data. We will use SQL Server for our database engine and SQL Server Management Studio to develop our sample database.</p>
			<p>To add our database, follow these steps:</p>
			<ol>
				<li value="1">Open <strong class="bold">SQL Server Management Studio</strong> and connect to your database engine.</li>
				<li>Right-click on the <strong class="bold">Databases</strong> folder in <strong class="bold">Object Explorer</strong>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_6.1.jpg" alt="Figure 6.1 – SQL Server Management Studio – Object Explorer &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – SQL Server Management Studio – Object Explorer </p>
			<ol>
				<li value="3">Select <strong class="bold">New Database</strong> from the context menu. This will display the <strong class="bold">New Database</strong> dialog, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_6.2.jpg" alt="Figure 6.2 – SQL Server Management Studio – the New Database dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – SQL Server Management Studio – the New Database dialog</p>
			<ol>
				<li value="4">Once you have entered <code>SampleData</code> under <strong class="bold">Database name</strong>, click on the <strong class="bold">OK</strong> button to create<a id="_idIndexMarker660"/> the database.</li>
				<li>Locate the database by expanding the <code>Products</code>, as shown here:</li>
			</ol>
			<div><div><img src="img/Table_6.1.jpg" alt="Table 6.1 – The Products table's design&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.1 – The Products table's design</p>
			<ol>
				<li value="6"><strong class="bold">Save</strong> the table, and then<a id="_idIndexMarker661"/> expand the <strong class="bold">Tables</strong> folder. Right-click on the <strong class="bold">Product</strong> table and select <strong class="bold">Edit Top n records</strong>, where <em class="italic">n</em> will be the number of configured records to edit. This is 200 by default.</li>
				<li>Add the data shown in the following table to the <strong class="bold">Product</strong> table:</li>
			</ol>
			<div><div><img src="img/Table_6.2.jpg" alt="Table 6.2 – The Product table's row data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.2 – The Product table's row data</p>
			<p>We now have a database<a id="_idIndexMarker662"/> with a single table filled with data that we will later use in this chapter. Now, let's understand collections from a performance perspective. Let's start by looking at how we decide between using arrays or collections.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor128"/>Deciding between interfaces and concrete classes</h1>
			<p>In this section, we will show<a id="_idIndexMarker663"/> that declaring a collection using an interface declaration rather than a concrete class declaration provides better time-based performance. We will accomplish this by benchmarking the generation of collections using an <code>IList</code> interface, as well as by using a <code>List</code> concrete class, so that you can see the difference in the performance of the different approaches. Follow these steps:</p>
			<ol>
				<li value="1">In the <code>CH06_Collections</code> project, add a new folder called <code>ConcreteVsInterface</code>.</li>
				<li>In the <code>ConcreteVsInterface</code> folder, add the <code>ITax</code> interface:<pre>internal interface ITax
{
      int Id { get; set; }
      TaxType TaxType { get; set; }
      TaxRate TaxRate { get; set; }
      decimal LowerLimit { get; set; }
      decimal UpperLimit { get; set; }
      decimal Percentage { get; set; }
      decimal Calculate(decimal amount);
}</pre></li>
			</ol>
			<p>This interface defines<a id="_idIndexMarker664"/> a contract that various concrete tax classes will have to adhere to. It enforces impact analysis since a change in this interface will be felt by all the classes that implement it.</p>
			<ol>
				<li value="3">Next, add the <code>BaseTax</code> class:<pre>internal abstract class BaseTax : ITax
{
    public int Id { get; set; }
    public TaxType TaxType { get; set; }
    public TaxRate TaxRate { get; set; }
    public decimal LowerLimit { get; set; }
    public decimal UpperLimit { get; set; }
    public decimal Percentage { get; set; }
    public abstract decimal Calculate(decimal amount);
}</pre></li>
			</ol>
			<p>This abstract class implements the <code>ITax</code> interface but marks <code>Calculate(decimal amount)</code> as abstract so that its implementation is left up to the subclasses. </p>
			<ol>
				<li value="4">Now, add<a id="_idIndexMarker665"/> the <code>TaxRate</code> enum:<pre>using System;
[Flags]
internal enum TaxRate
{
    TaxFreePersonalAllowance,
    StarterRate,
    BasicRate,
    IntermediateRate,
    HigherRate,
    AdditionalRate
}</pre></li>
			</ol>
			<p>The <code>TaxRate</code> enum provides the different types of tax rates for UK income tax. </p>
			<ol>
				<li value="5">Add the <code>TaxtType</code> enum:<pre>[Flags]
internal enum TaxType
{
    CorporationTax,
    ValueAddedTax,
    IncomeTax,
    NationInsuranceContributions,
    ExciseDuties,
    RoadTax,
    StampDuty
}</pre></li>
			</ol>
			<p>The <code>TaxType</code> interface provides the different kinds of UK taxes. Add the <code>BaseRate</code> class. This class<a id="_idIndexMarker666"/> will inherit from the <code>BaseTax</code> class. </p>
			<ol>
				<li value="6">Then, add the following constructor:<pre>public BasicRate()
{
    this.LowerLimit = 14550M;
    this.UpperLimit = 24944M;
    this.TaxType = TaxType.IncomeTax;
    this.TaxRate = TaxRate.BasicRate;
    this.Percentage = 0.2M;
}</pre></li>
			</ol>
			<p>This constructor sets the properties contained within <code>BaseClass</code> to the values applicable to basic rate income tax. </p>
			<ol>
				<li value="7">Now, implement the <code>Calculate(decimal amount)</code> method:<pre>public override decimal Calculate(decimal amount)
{
      if (Percentage &gt; 1)
            throw new Exception("Invalid percentage. 
                Percentage must be between 0 and 1.");
if (amount &lt; LowerLimit &amp; amount &gt; UpperLimit)
    return 0;
return Percentage * amount;
}</pre></li>
			</ol>
			<p>This method checks if the percentage is less than one and throws an exception if it is not. The lower<a id="_idIndexMarker667"/> and upper amounts a person earns that are taxed are checked. If the amount is outside of this range, then zero is returned. The amount of tax on earnings is then returned and the method exits.</p>
			<ol>
				<li value="8">Add a new class called <code>TaxMan</code>:<pre>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Order;
using CH06_Collections.Linq;
using System.Collections.Generic;
using System.Threading;
[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
[RankColumn]
public class TaxMan { }</pre></li>
			</ol>
			<p>Our class is now configured to perform benchmarking using <code>BenchmarkDotNet</code>. </p>
			<ol>
				<li value="9">Add the following method:<pre>[Benchmark]
public void BasicRateInterface()
{
      IList&lt;BasicRate&gt; basicRate = new 
          List&lt;BasicRate&gt;();
}</pre></li>
			</ol>
			<p>The <code>BasicRateInterface()</code> method<a id="_idIndexMarker668"/> declares a list of <code>BasicRate</code> objects using the <code>IList</code> interface. </p>
			<ol>
				<li value="10">Add the <code>BasicRateConcrete()</code> method:<pre>[Benchmark]
public void BasicRateConcrete()
{
      List&lt;BasicRate&gt; basicRate = new 
          List&lt;BasicRate&gt;();
}</pre></li>
			</ol>
			<p>The <code>BasicRateConcrete()</code> method declares a list of <code>BasicRate</code> objects using the concrete <code>List</code> class.</p>
			<ol>
				<li value="11">In the <code>Program</code> class, comment out the code in the <code>Main</code> method and add the following line of code:<pre>BenchmarkRunner.Run&lt;TaxMan&gt;();</pre></li>
			</ol>
			<p>This line of code will run our benchmarks. Do a release build, and then run the executable from the command line. You should see the following output or similar:</p>
			<div><div><img src="img/B16617_Figure_6.3.jpg" alt="Figure 6.3 – The BenchmarkDotNet summary report showing the time difference between assigning IList&lt;T&gt; and List&lt;T&gt;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The BenchmarkDotNet summary report showing the time difference between assigning IList&lt;T&gt; and List&lt;T&gt;</p>
			<p>As we can see from the report, memory<a id="_idIndexMarker669"/> utilization is the same for both the interface and the concrete class implementations. But the faster instantiation time is obtained by assigning <code>IList&lt;T&gt;</code> instead of <code>List&lt;T&gt;</code>. Although the value will not be noticeable to the naked eye, it will become more noticeable over some time if there are a large number of assignments, such as when a large data iteration is taking place.</p>
			<p>Now, let's look at array and collection performance.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>Deciding between using arrays or collections</h1>
			<p>In this section, we'll discuss<a id="_idIndexMarker670"/> the pros and cons of using arrays and collections. We will also perform various benchmarks that measure array and collection performance. Armed with benchmark information, you can then make informed decisions as to whether arrays or collections are best suited to your specific needs. We will start by looking at arrays.</p>
			<p>The downsides to using arrays<a id="_idIndexMarker671"/> are as follows:</p>
			<ul>
				<li>Arrays are fixed in size, meaning that once the size of the array has been changed, its size cannot be changed.</li>
				<li>Since arrays are fixed in size, they are not recommended for efficient memory usage.</li>
				<li>Arrays can only hold heterogeneous data types, and data types can be primitive and object types.</li>
				<li>Data elements of the <code>object</code> type can hold different types of data elements. </li>
				<li>Arrays lack many useful<a id="_idIndexMarker672"/> methods.</li>
			</ul>
			<p>The benefits of using<a id="_idIndexMarker673"/> arrays are as follows:</p>
			<ul>
				<li>Arrays have a small memory footprint and have undergone some serious performance improvements in C# 9.0 and .NET 5.</li>
				<li>However, as arrays are fast and have undergone speed improvements, they are recommended when performance matters. </li>
			</ul>
			<p>The downside to using collections<a id="_idIndexMarker674"/> is as follows:</p>
			<ul>
				<li>When it comes to performance, they are not recommended over arrays.</li>
			</ul>
			<p>The benefits of using arrays<a id="_idIndexMarker675"/> are as follows:</p>
			<ul>
				<li>Collections effectively wrap arrays; <code>generic List&lt;T&gt;</code> is a good example.</li>
				<li>They are growable, which<a id="_idIndexMarker676"/> means that we can shrink and grow our collections as required. Because of this, collections are recommended over arrays when it comes to efficient memory utilization.</li>
				<li>Data elements (item data) in a collection can be homogeneous and heterogeneous.</li>
				<li>Collection classes have ready-made method support for most operations and can easily be extended. By this, we mean that arrays lack some useful methods that we get for free when we use collections.<p class="callout-heading">Note</p><p class="callout">It is recommended that you do not use the collections in the <code>System.Collections</code> namespace. Instead, you are encouraged to use the collections in the <code>System.Collections.Generic</code> namespaces.</p></li>
			</ul>
			<p>The standard collection that most programmers will be familiar with is the generic <code>List&lt;T&gt;</code> class. In this section, we will create a new project. Then, we will build up a <code>uint</code> array and a <code>List&lt;uint&gt;</code> collection and iterate through them. This process will be benchmarked using <code>BenchmarkDotNet</code>.</p>
			<p>We will be benchmarking adding items, iterating through, and retrieving items from arrays and collections. So, let's begin:</p>
			<ol>
				<li value="1">Add a new class under<a id="_idIndexMarker677"/> the project root called <code>ArraysVsCollections</code> with the following <code>using</code> statements:<pre>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Order;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;</pre></li>
			</ol>
			<p>These <code>using</code> statements give us what we need to work with arrays and collections and benchmark them. </p>
			<ol>
				<li value="2">Add the following member variables:<pre>private int[] array;
private List&lt;int&gt; collection;</pre></li>
			</ol>
			<p>The array of <code>int</code> and the list of <code>int</code> will be used to benchmark adding, getting, and iterating arrays and collections. </p>
			<ol>
				<li value="3">Next, add the <code>GlobalSetup()</code> method:<pre>[GlobalSetup]
public void GlobalSetup()
{
array = new int[1000];
collection = new List&lt;int&gt;(1000);
for (int i = 0; i &lt; 1000; i++)
{
    array[i] = i;
    collection.Add(i);
}
}</pre></li>
			</ol>
			<p>The <code>GlobalSetup()</code> method is attributed to the <code>[GlobalSetup]</code> attribute. This informs <code>BenchmarkDotNet</code> to run this method before all other benchmark methods. It initializes<a id="_idIndexMarker678"/> the array and collection with a size of <code>1000</code> and adds a value of <code>i</code> in the current iteration to both the array and collection. </p>
			<ol>
				<li value="4">Although we will not be utilizing the <code>GlobalCleanup()</code> method, we will add it for completeness so that you know how to perform cleanup operations when benchmarking:<pre>[GlobalCleanup]
public void GlobalCleanup()
{
// Disposing logic
}</pre></li>
			</ol>
			<p>The <code>GlobalCleanup()</code> method is where you would provide your cleanup logic if it were needed. </p>
			<ol>
				<li value="5">Now, add the <code>ArrayAdd1000Logic()</code> method:<pre>[Benchmark]
public void ArrayAdd1000Logic1()
{
int[] list = new int[1000];
for (int i = 0; i &lt; 1000; i++)
{
    list[i] = i;
}
}</pre></li>
			</ol>
			<p>The <code>ArrayAdd1000Logic()</code> method declares<a id="_idIndexMarker679"/> an array of 1000 <code>int</code> values and later proceeds to add integer values to each element in the array. </p>
			<ol>
				<li value="6">Add the <code>CollectionAdd1000Logic()</code> method:<pre>[Benchmark]
public void CollectionAdd1000Logic()
{
Ilist&lt;int&gt; list = new new List&lt;int&gt;();
for (int i = 0; i &lt; 1000; i++)
      list.Add(i)
}</pre></li>
			</ol>
			<p>The <code>CollectionAdd1000Logic ()</code> method declares a list of <code>int</code> elements. Then, it loops 1,000 times using a <code>for</code> loop and adds the current value to the collection. </p>
			<ol>
				<li value="7">Add the <code>ArrayIterationLogic()</code> method:<pre>[Benchmark]
public int ArrayIterationLogic()
{
int res = 0;
for (int i = 0; i &lt; 1000; i++)
    res += array[i];
return res;
}</pre></li>
			</ol>
			<p>The <code>ArrayIterationLogic()</code> method<a id="_idIndexMarker680"/> declares an <code>int</code> variable and assigns it a value of <code>0</code>. A <code>for</code> loop is used to iterate 1,000 times and add the value of the array at the index position to the <code>res</code> value. Once the iteration is over, the <code>res</code> variable is returned. </p>
			<ol>
				<li value="8">Now, add the <code>CollectionIterationLogic()</code> method:<pre>[Benchmark]
public int CollectionIterationLogic()
{
int res = 0;
for (int i = 0; i &lt; 1000; i++)
    res += collection[i];
return res;
}</pre></li>
			</ol>
			<p><code>CollectionIterationLogic()</code> declares an <code>int</code> variable and assigns it a value of <code>0</code>. A <code>for</code> loop is used to iterate 1,000 times and add the value of the array at the index position to the <code>res</code> value. Once the iteration is over, the <code>res</code> variable is returned.</p>
			<ol>
				<li value="9">Add the <code>ArrayGetElement500Logic()</code> method:<pre>[Benchmark]
public int ArrayGetElement500Logic()
{
return array[500];
}</pre></li>
			</ol>
			<p>The <code>ArrayGetElement500Logic()</code> method<a id="_idIndexMarker681"/> returns the value of the array at position <code>500</code>. </p>
			<ol>
				<li value="10">Now, add the <code>CollectionGetElement500Logic()</code> method:<pre>[Benchmark]
public int CollectionGetElement500Logic()
{
return collection[500];
}</pre></li>
			</ol>
			<p>The <code>CollectionGetElement500Logic()</code> method returns the value of the collection at position <code>500</code>. </p>
			<ol>
				<li value="11">Replace the code in the <code>Main</code> method with the following line of code:<pre>BenchmarkRunner.Run&lt;ArraysVsCollections&gt;();</pre></li>
			</ol>
			<p>This call will run our benchmarks. Release build your code and run it from the console. You should see a report with similar timings to those shown in the following screenshot:</p>
			<div><div><img src="img/B16617_Figure_6.4.jpg" alt="Figure 6.4 – The BenchmarkDotNet summary report for array and collection operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The BenchmarkDotNet summary report for array and collection operations</p>
			<p>Looking at the performance<a id="_idIndexMarker682"/> in terms of time, adding items to an array is faster than adding items to a collection. Iterating a collection is faster than iterating over an array and getting an item from an array using its index is faster than getting a collection from a collection by its index. Based on these findings, you need to decide what your requirements are, and then choose the best type based on these requirements. </p>
			<p>Now, let's look at indexers.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Accessing objects using indexers</h1>
			<p>Indexes enable objects<a id="_idIndexMarker683"/> in classes to be accessed in the same way you access items<a id="_idIndexMarker684"/> in an array. An indexer will have a modifier, a return type, the <code>this</code> keyword to indicate the object of the current class, and an argument list. You will always use the <code>this</code> keyword when creating an indexer. Indexer is the term given to a parameterized property. The index is created using the <code>get</code> and <code>set</code> accessors. You are not allowed to use the <code>ref</code> or <code>out</code> keywords to modify indexer parameters. A minimum of one parameter should be specified. An indexer cannot be static since it is an instance member. However, the indexer properties can be static. You would implement an indexer if you need to operate on a group of elements. The main difference between a property and an indexer is that you identify and access a property by its name. On the other hand, with an indexer, it is identified by its signature and accessed using indexes. Moreover, you can overload indexers.</p>
			<p>Now, let's write a simple indexer<a id="_idIndexMarker685"/> example. In this example, we will have a class<a id="_idIndexMarker686"/> that has a constructor that takes a size. This size will set the size of an internal array of strings. We will be able to get the index of a string in the array by name and get an item from the array by index using indexers. Follow these steps:</p>
			<ol>
				<li value="1">Add a new class called <code>Indexers</code> and add a <code>using</code> statement to <code>System namespace</code>. Then, add the following array and constructor at the top of the class:<pre>private string[] _items;
public Indexers(int size)
{
      _items = new string[size];
}</pre></li>
			</ol>
			<p>The <code>_items</code> array will contain several strings. The size of the array is set by the value that's passed into the constructor that initializes the array. </p>
			<ol>
				<li value="2">Add the indexer to get a string by index:<pre>public string this[int index]
{
  get
{
    if (IsValidIndex(index))
        return _items[index];
    else
        return string.Empty;
}
  set
{
    if (IsValidIndex(index))
        _items[index] = value;
}
} </pre></li>
			</ol>
			<p>This indexer uses an <code>int</code> value to get an item from the array and set the value of the array at the given<a id="_idIndexMarker687"/> index. Items are only set and retrieved<a id="_idIndexMarker688"/> if the index is valid.</p>
			<ol>
				<li value="3">We can check the index by passing it into the <code>IsValidIndex(int index)</code> method, which returns a <code>bool</code>. Let's add the <code>IsValidIndex(int index)</code> method:<pre>private bool IsValidIndex(int index)
{
    return index &gt; -1 &amp;&amp; index &lt; _items.Length;
}</pre></li>
			</ol>
			<p>This method returns <code>true</code> if the index is greater than -1 and less than the length of the array. Otherwise, it returns <code>false</code>. </p>
			<ol>
				<li value="4">Now, add the index that takes a <code>string</code> and returns the string's index:<pre>public int this[string item]
{
  get
{
    return Array.IndexOf(_items, item);
}
}</pre></li>
			</ol>
			<p>This indexer takes a <code>string</code>. Then, it looks up the index for the string<a id="_idIndexMarker689"/> and returns the index. There<a id="_idIndexMarker690"/> is no setter for this index. </p>
			<ol>
				<li value="5">In the <code>Program</code> class, add the <code>IndexerExample()</code> method:<pre>public static void IndexerExample()
{
      Indexers indexers = new Indexers(1000);
      for (int i = 0; i &lt; 1000; i++)
            indexers[i] = $"Item {i}";
Console.WriteLine($"The item at position 500 is 
     \"{indexers[500]}\".");
Console.WriteLine($"The index of \"Item 500\" is 
     {indexers["Item 500"]}.");
}</pre></li>
			</ol>
			<p>This method creates a new <code>Indexer</code> object with an internal array size of <code>1000</code>. Then, it loops 1,000 times and sets the value of each item in the array. After that, it prints out the value of the array at position 500 and prints out the value of <code>Item 500</code>. </p>
			<ol>
				<li value="6">Comment out the code in the <code>Main</code> method, and then add the following line:<pre>IndexerExample();</pre></li>
			</ol>
			<p>This statement calls the method that executes our <code>Indexer</code> method. You should see the following output:</p>
			<pre><strong class="bold">The item at position 500 is "Item 500".</strong>
<strong class="bold">The index of "Item 500" is 500.</strong></pre>
			<p>That concludes our look at indexers. As you can see, they are pretty simple. You can use any data item that you like for an indexer. However, it will be up to you to see how well such indexers<a id="_idIndexMarker691"/> perform. Now, let's look<a id="_idIndexMarker692"/> at the difference between the <code>IEnumerable</code> and <code>IEnumerator</code> interfaces.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor131"/>Comparing IEnumerable and IEnumerator</h1>
			<p>The <code>IEnumerable</code> and <code>IEnumerator</code> interfaces can both<a id="_idIndexMarker693"/> be used for iteration but in different ways. Let's understand each in brief.</p>
			<p>An object of the <code>IEnumerable</code> type will know how to traverse the collection that it holds, regardless of what its internal structure is like. There is one method that makes up an enumerable: <code>GetEnumerator()</code>. It returns as an instance of a class that implements the <code>IEnumerable</code> interface. Iteration is normally carried out using a <code>foreach</code> loop. Iterations of an enumerable are carried out using a <code>foreach</code> loop. However, an enumerable does not remember its location when iterating.</p>
			<p>Objects of the <code>Ienumerator</code> type declare two methods: <code>MoveNext()</code> and <code>Reset()</code>. There is one property called <code>Current</code> that gets the current item in the list that's being enumerated. The <code>MoveNext()</code> method moves to the next record in a collection and returns a Boolean value indicating the end of the collection. <code>Reset()</code> will reset the position to the first item in the collection. The <code>Current</code> property is called through an object that implements the <code>IEnumerable</code> interface, which returns the current element in the collection. An enumerator remembers its current location and uses a <code>while</code> loop when iterating.</p>
			<p>Let's see which method of enumeration is fastest. Will it be looping using an enumerable, or will it be looping using an iterator?</p>
			<ol>
				<li value="1">Add a new class called <code>IEnumerableVsIEnumerable</code> with the following <code>using</code> statements:<pre>    using BenchmarkDotNet.Attributes;
    using BenchmarkDotNet.Running;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;</pre></li>
			</ol>
			<p>These <code>using</code> statements provide the elements we will need to build and test the performance between <code>IEnumerable</code> and <code>IEnumerator</code>. </p>
			<ol>
				<li value="2">Add the following<a id="_idIndexMarker694"/> code to the class:<pre>private List&lt;int&gt; _years;
public IEnumerableVsIEnumerator()
{
  _years = new List&lt;int&gt; { 1970, 1971, 1972, 1973, 1974, 
      1975, 1976, 1977, 1978, 1979 };
}</pre></li>
			</ol>
			<p>Here, we are declaring a list of <code>int</code> values that will hold several year values. Our constructor then initializes the array with the years <code>1970</code> to <code>1979</code>. </p>
			<ol>
				<li value="3">Add the <code>IterateEnumerator1970to1975()</code> method:<pre>public void IterateEnumerator1970To1975()
{
  var years = _years.GetEnumerator();
  while (years.MoveNext())
{
    Debug.WriteLine(years.Current);
    if (years.Current &gt; 1975)
        IterateEnumberator1976To1979(years);
}
}</pre></li>
			</ol>
			<p>This method iterates over the values <code>1970</code> to <code>1975</code> and prints the values out to the debug window. </p>
			<ol>
				<li value="4">If the current year<a id="_idIndexMarker695"/> is greater than <code>1975</code>, then the enumerator is passed into the <code>IterateEnumerator1976To1979(IEnumerator&lt;int&gt; years)</code> method, which we will add now:<pre>public void IterateEnumberator1976To1979
    (IEnumerator&lt;int&gt; years)
{
while (years.MoveNext())
{
    Debug.WriteLine(years.Current);
}
}</pre></li>
			</ol>
			<p>This method takes in an enumerator and iterates through it. On each iteration, it prints the current year to the debug window. </p>
			<ol>
				<li value="5">Add the following line to the end of the <code>Main</code> method in the <code>Program</code> class:<pre>IEnumerableVsIEnumeratorExample();</pre></li>
			</ol>
			<p>This line of code calls a method that will run our example and show how an enumerator remembers where it is in the iteration. </p>
			<ol>
				<li value="6">Add the <code>IEnumerableVsIEnumeratorExample()</code> method to the <code>Program</code> class:<pre>private static void IEnumerableVsIEnumeratorExample()
{
  IEnumerableVsIEnumerator eve = new 
    IEnumerableVsIEnumerator();
  eve.IterateEnumerator1970To1975();
}</pre></li>
			</ol>
			<p>This method runs our code. If you do a debug build and run the code, then you should see the years <em class="italic">1970</em> to <em class="italic">1979</em> printed to the output window. </p>
			<p>Now that you have seen an enumerator<a id="_idIndexMarker696"/> in action, we will add two methods to the <code>IEnumerableVsIEnumerator</code> class. </p>
			<ol>
				<li value="7">Add the <code>BenchmarkIEnumerabled()</code> method:<pre>[Benchmark]
public void BenchmarkIEnumerable()
{
  IEnumerable&lt;int&gt; enumerable = IEnumerable&lt;int&gt;)_years;
  foreach (int i in enumerable)
      Debug.WriteLine(i);
}</pre></li>
			</ol>
			<p>This method uses an enumerable and a <code>foreach</code> loop to iterate through the years and write them to the debug window. </p>
			<ol>
				<li value="8">Add the <code>BenchmarkIEnumerator()</code> method:<pre>[Benchmark]
public void BenchmarkIEnumerator()
{
  IEnumerator&lt;int&gt; enumerator = _years.GetEnumerator();
  while (enumerator.MoveNext())
      Debug.WriteLine(enumerator.Current);
}</pre></li>
			</ol>
			<p>This method uses an enumerator and a <code>while</code> loop to iterate through the years and write them to the debug window. </p>
			<ol>
				<li value="9">Comment out the code<a id="_idIndexMarker697"/> in the <code>Main</code> method in the <code>Program</code> class, and then add the following line:<pre>BenchmarkRunner.Run&lt;IEnumerableVsIEnumerator&gt;();</pre></li>
			</ol>
			<p>This line of code detects our benchmarks and runs them to produce a summary report on performance. Do a release build and run the program from the command prompt. You should see the following output:</p>
			<div><div><img src="img/B16617_Figure_6.5.jpg" alt="Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator &#13;&#10;is faster than IEnumerable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator is faster than IEnumerable</p>
			<p>As we can see, even though <code>IEnumerable</code> and <code>IEnumerator</code> both perform iterations on the same collection, they do so in different ways. And by viewing the benchmarking summary report, we can see that the clear winner in terms of performance is the <code>IEnumerator</code> interface. Now, let's look at the difference between <code>IEnumerable</code>, <code>IEnumerator</code>, and <code>IQueryable</code>, and the effects<a id="_idIndexMarker698"/> these differences have on performance when performing LINQ queries on a database.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor132"/>Database query performance</h1>
			<p>In the previous section, we saw how <code>IEnumerator</code> is different from and performs faster than <code>IEnumerable</code> when iterating through an in-memory collection. Now, let's query a database<a id="_idIndexMarker699"/> and iterate through the resulting collection using various benchmarked techniques. To do so, we'll follow these steps:</p>
			<ol>
				<li value="1">Add a new class called <code>IEnumeratorVsIQueryable</code>.</li>
				<li>We will be connecting to a SQL Server database, and we will have information we need to keep secret. Our <code>secret.json</code> files do not get checked into version control. So, right-click on the project and select <strong class="bold">Manage User Secrets</strong> from the context menu.</li>
				<li>A dialog box will pop up, informing you that additional packages are required. Click on <strong class="bold">Yes</strong>:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_6.6.jpg" alt="Figure 6.6 – A dialog box, informing you that additional packages are required to manage user secrets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – A dialog box, informing you that additional packages are required to manage user secrets</p>
			<ol>
				<li value="4">Visual Studio will then open the <code>secrets.json</code> file in a new tab. This is where you will add your user secrets.</li>
				<li>Open the Package Manager Console and add the following packages:<ul><li><code>Microsoft.EntityFrameworkCore</code></li><li><code>Microsoft.EntityFrameworkCore.SqlServer</code></li><li><code>Microsoft.EntityFrameworkCore.Tools</code></li><li><code>Microsoft.Extensions.Configuration</code></li><li><code>Microsoft.Extensions.Configuration.EnvironmentVariables</code></li><li><code>Microsoft.Extensions.Configuration.UserSecrets</code></li><li><code>Microsoft.Extensions.OptionsConfigurationExtensions</code></li></ul></li>
			</ol>
			<p>These packages<a id="_idIndexMarker700"/> allow you to connect to and extract data from our SQL Server database. </p>
			<ol>
				<li value="6">Update your <code>secrets.json</code> file with the connection string to the database that we created at the start of this chapter:<pre>{
  "DatabaseSettings": {
    "ConnectionString": "YOUR_CONNECTION_STRING"
  }
}</pre></li>
			</ol>
			<p>This connection string will be used to connect to our database, perform a query that returns some data, and allow us to iterate through that data and perform some operations on it. </p>
			<ol>
				<li value="7">Add a folder called <code>Configuration</code>. In that folder, add a class called <code>SecretsManager</code> with an empty static constructor and the following <code>using</code> statements:<pre>using Microsoft.Extensions.Configuration;
using System;
using System.IO;</pre></li>
			</ol>
			<p>We need these <code>using</code> statements for our file I/O and system configuration, such as obtaining secrets from a <code>secrets.json</code> file. </p>
			<ol>
				<li value="8">Add the following line<a id="_idIndexMarker701"/> at the top of the <code>SecretsManager</code> class:<pre>public static IConfigurationRoot Configuration { get; 
    set; }</pre></li>
			</ol>
			<p>This line declares our static configuration property, which is used to obtain the configuration data within our application. </p>
			<ol>
				<li value="9">Now, add the following code:<pre>public static T GetSecrets&lt;T&gt;(string sectionName) 
    where T : class
{
var devEnvironmentVariable = Environment
    .GetEnvironmentVariable("NETCORE_ENVIRONMENT");
var isDevelopment = string.IsNullOrEmpty
    (devEnvironmentVariable) || devEnvironmentVariable
        .ToLower() == "development";
var builder = new ConfigurationBuilder()    
    .SetBasePath(Directory.GetCurrentDirectory())
.AddJsonFile("appsettings.json", optional: true, 
    reloadOnChange: true)
.AddEnvironmentVariables();
if (isDevelopment) //only add secrets in development
{
    builder.AddUserSecrets&lt;T&gt;();
}
Configuration = builder.Build();
return Configuration.GetSection(sectionName).Get&lt;T&gt;();
}</pre></li>
			</ol>
			<p>This code gets the environment<a id="_idIndexMarker702"/> variables for the .NET Core environment. Then, it gets the code to see if it is running in a software development environment. The configuration is built for the environment it will be running in. If we are in development, then we must add our <code>secrets</code> class as defined by the <code>T</code> variable. Switch to the <code>Product</code> class in the <code>Models</code> folder.</p>
			<ol>
				<li value="10">Add a <code>using</code> statement for <code>System.ComponentModel.DataAnnotations</code>. Change the struct to a class, and add the <code>[Key]</code> attribute to the <code>Id</code> property. We need these changes since we are using Entity Framework to connect to a database and extract data.</li>
				<li>Add the <code>DatabaseSettings</code> class to the <code>Configuration</code> folder:<pre>public class DatabaseSettings
{
    public string ConnectionString { get; set; }
}</pre></li>
			</ol>
			<p>This class has a single property called <code>ConnectionString</code> that will hold our connection string to our <code>SampleData</code> database. Notice that the name of the class and property match the name of the JSON section and property! </p>
			<ol>
				<li value="12">Now, add <code>appsettings.json</code> to the root of your project with the following contents:<pre>{
  "DatabaseSettings": {
    "ConnectionString": "Set in Azure. For 
        development, set in User Secrets"
  }
}</pre></li>
			</ol>
			<p>This file contains the same layout as the <code>secrets.json</code> file and the <code>DatabaseSettings</code> class. This file is used to store our connection string. In development, it is set in our <code>secrets</code> file, while in production, it is set in Azure. Now that we have our database configuration in place, we can add our benchmarking code.</p>
			<ol>
				<li value="13">Add a new class<a id="_idIndexMarker703"/> to the root of the project called <code>DatabaseQueryAndIteration</code> that implements <code>IDisposable</code> with the following code:<pre>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Order;
using CH06_Collections.Configuration;
using CH06_Collections.Data;
using CH06_Collections.Models;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.Declared)]
[RankColumn]
public class DatabaseQueryAndIteration : IDisposable 
{
}</pre></li>
			</ol>
			<p>This code declares our class and defines the fact that it implements <code>IDisposable</code>. It is also configured to be benchmarked.</p>
			<ol>
				<li value="14">Implement the <code>IDisposable</code> interface<a id="_idIndexMarker704"/> in our class:<pre>private bool disposedValue;
protected virtual void Dispose(bool disposing)
{
    if (!disposedValue) {
        if (disposing)
            _context.Dispose();
        disposedValue = true;
    }
}
public void Dispose(){
    Dispose(disposing: true);
    GC.SuppressFinalize(this);
}</pre></li>
			</ol>
			<p>This code disposes of our managed resources and suppresses the call to the class finalizer method.</p>
			<ol>
				<li value="15">We have everything in place to benchmark the methods in this class, access database resources, and clean up after ourselves. Add the following code to the class:<pre>private DatabaseContext _context;
[GlobalSetup]
public void GlobalSetup()
{
    var connectionString = SecretsManager.
        GetSecrets&lt;DatabaseSettings&gt;(nameof
          (DatabaseSettings)).ConnectionString;
_context = new DatabaseContext(connectionString);
}
[GlobalCleanup]
public void GlobalCleanup()
{
        Dispose(true);
}</pre></li>
			</ol>
			<p>The _<code>context</code> variable provides<a id="_idIndexMarker705"/> us with our database access. The <code>GlobalSetup()</code> method gets our connection string from our secrets file and creates a new <code>DatabaseContext</code> using the safely stored connection string. The <code>GlobalSetup()</code> method will run before our benchmarks. The <code>GlobalCleanup()</code> method calls the <code>Dispose(disposing)</code> method to clean up our managed resources after our benchmarks have finished running.</p>
			<ol>
				<li value="16">Next, add the <code>QueryDb()</code> method:<pre>[Benchmark]
public void QueryDb()
{
    var products = (from p in _context.Products
                    where p.Id &gt; 1 select p);
foreach (var product in products)
    Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p>The <code>QueryDb()</code> method performs<a id="_idIndexMarker706"/> a simple LINQ query on the database by selecting products with an ID that's greater than <code>1</code>. Then, it iterates each product in the <code>lQueryable&lt;Product&gt;</code> list and writes the product name out to the debug window. </p>
			<ol>
				<li value="17">Now, add the <code>QueryDbAsList()</code> method:<pre>[Benchmark]
public void QueryDbAsList()
{
List&lt;Product&gt; products = (from p in _context.Products
where p.Id &gt; 1
select p).ToList&lt;Product&gt;();
foreach (var product in products)
Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p><code>QueryDbAsList()</code> performs the same query as <code>QueryDb()</code>, except the processed type is of the <code>List&lt;Product&gt;</code> type.</p>
			<ol>
				<li value="18">Add the <code>QueryDbAsIEnumerable()</code> method:<pre>[Benchmark]
public void QueryDbAsIEnumerable()
{
var products = (from p in _context.Products
                where p.Id &gt; 1
                select p).AsEnumerable&lt;Product&gt;();
foreach (var product in products)
    Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p>The <code>QueryDbAsIEnumerable()</code> method performs the same query as <code>QueryDbAsList</code>, but the processed type is of the <code>Ienumerable&lt;Product&gt;</code> type instead. </p>
			<ol>
				<li value="19">Add the <code>QueryDbAsIEnumerator()</code> method:<pre>[Benchmark]
public void QueryDbAsIEnumerator()
{
      var products = (from p in _context.Products
                where p.Id &gt; 1
                select p).GetEnumerator();
while (products.MoveNext())
    Debug.WriteLine(products.Current.Name);
}</pre></li>
			</ol>
			<p><code>QueryDbAsIEnumerator()</code> does the same as the previous<a id="_idIndexMarker707"/> methods but operates on the <code>IEnumerator&lt;Product&gt;</code> type and iterates using a <code>while</code> loop instead of a <code>foreach</code> loop. </p>
			<ol>
				<li value="20">Our final method in this class is the <code>QueryDbAsIQueryable()</code> method:<pre>[Benchmark]
public void QueryDbAsIQueryable()
{
var products = (from p in _context.Products
                where p.Id &gt; 1
                select p).AsQueryable&lt;Product&gt;();
foreach (var product in products)
    Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p>This method is the same as <code>QueryDb</code> but explicitly operates on the <code>IQueryable&lt;Product&gt;</code> type.</p>
			<ol>
				<li value="21">Replace the code in the <code>Main</code> method<a id="_idIndexMarker708"/> within the <code>Program</code> class with the following code:<pre>BenchmarkRunner.Run&lt;DatabaseQueryAndIteration&gt;();</pre></li>
			</ol>
			<p>This code runs our benchmarks. Do a release build of the code and run the executable from the command line. You should see a summary report similar to the following:</p>
			<div><div><img src="img/B16617_Figure_6.7.jpg" alt="Figure 6.7 – The different times and memory allocations of various database query types using LINQ&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – The different times and memory allocations of various database query types using LINQ</p>
			<p>In terms of memory usage, the worst performer is the <code>QueryDb()</code> method, followed by the <code>QueryDbAsList()</code> method. <code>QueryDbAsIEnumerable()</code> and <code>QueryDbAsIQueryable()</code> are both slightly better than the previous two. However, the best performing method in terms of memory allocation out of all five methods is the <code>QueryDbAsIEnumerator()</code> method.</p>
			<p>Speedwise, the <code>QueryDb()</code> method was the worst again, followed by <code>QueryDbAsIEnumerable()</code>, then <code>QueryDbAsList()</code>, and then <code>QueryDbAsIQueryable()</code>. And again, the best performer in terms of speed is the <code>QueryDbAsIEnumerator()</code> method.</p>
			<p>Here, we can see that the best performing method<a id="_idIndexMarker709"/> for querying and iterating a database in terms of both speed and memory usage is the <code>QueryDbAsIEnumerator()</code> method. Now, let's look at the <code>yield</code> keyword.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor133"/>Exploring the yield keyword</h1>
			<p>The <code>yield</code> keyword:</p>
			<ul>
				<li><code>yield return &lt;expression&gt;;</code>: This returns the value of the expression.</li>
				<li><code>yield break;</code>: This will exit from the iteration</li>
			</ul>
			<p>When using the <code>yield</code> keyword, there are some restrictions to be aware of. These are as follows:</p>
			<ul>
				<li>You cannot use the <code>yield</code> keyword in <code>unsafe</code> blocks of code.</li>
				<li>You cannot use the <code>ref</code> or <code>out</code> parameters for methods, operators, or accessors.</li>
				<li>You cannot return using the <code>yield</code> keyword in a <code>try-catch</code> block.</li>
				<li>You cannot use the <code>yield</code> keyword in anonymous methods.</li>
				<li>You can use <code>yield</code> in a <code>try</code> block if the <code>try</code> block is followed by the <code>finally</code> block.</li>
				<li>You can use <code>yield break</code> in a <code>try-catch</code> block but not the <code>finally</code> block.</li>
			</ul>
			<p>In this section, we are going to add<a id="_idIndexMarker711"/> a class that shows the <code>yield</code> keyword in action. Then, we will benchmark two ways to return an <code>IEnumerable&lt;long&gt;</code> consisting of 1 million items, and show the vast difference in performance between them. Let's begin:</p>
			<ol>
				<li value="1">Add a new class called <code>Yield</code> to the root of the project:<pre>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Order;
using System;
using System.Collections.Generic;
[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.Declared)]
[RankColumn]
public class Yield { }</pre></li>
			</ol>
			<p>This class will benchmark the use of the <code>yield</code> keyword. </p>
			<ol>
				<li value="2">Now, add the <code>YieldSample()</code> method:<pre>public void YieldSample()
{
DoCountdown();
PrintMonthsOfYear();
DoBreakIteration();
}</pre></li>
			</ol>
			<p>The <code>YieldSample()</code> method will be called from our <code>Program</code> class. It will run all three methods. </p>
			<ol>
				<li value="3">Add the <code>Countdown()</code> method:<pre>private IEnumerable&lt;int&gt; Countdown()
{
      for (int x = 10; x &gt;= 0; x--)
      yield return x;
}</pre></li>
			</ol>
			<p>This method loops<a id="_idIndexMarker712"/> from <code>10</code> to <code>0</code>. Each iteration is returned using the <code>yield</code> keyword.</p>
			<ol>
				<li value="4">Add the <code>DoCountdown()</code> method:<pre>private void DoCountdown()
{
foreach (int x in Countdown())
    Console.WriteLine(x);
}</pre></li>
			</ol>
			<p>The <code>DoCountdown()</code> method prints the countdown from <code>10</code> to <code>0</code> to the console window. </p>
			<ol>
				<li value="5">Add a class called <code>Month</code>:<pre>internal class Month
{
      public string Name { get; set; }
      public int MonthOfYear { get; set; }
}</pre></li>
			</ol>
			<p>This class holds the name of a month of the year and its number. </p>
			<ol>
				<li value="6">Now, add<a id="_idIndexMarker713"/> the <code>Months</code> class:<pre>internal class Months
{
   public IEnumerable&lt;Month&gt; MonthsOfYear
   {
    get
   {
    yield return new Month { Name = "January", 
        MonthOfYear = 1 };
    yield return new Month { Name = "February", 
        MonthOfYear = 2 };
    yield return new Month { Name = "March", 
        MonthOfYear = 3 };
    yield return new Month { Name = "April", 
        MonthOfYear = 4 };
    yield return new Month { Name = "May", 
        MonthOfYear = 5 };
    yield return new Month { Name = "June", 
        MonthOfYear = 6 };
    yield return new Month { Name = "July", 
        MonthOfYear = 7 };
    yield return new Month { Name = "August", 
        MonthOfYear = 8 };
    yield return new Month { Name = "September", 
        MonthOfYear = 9 };
    yield return new Month { Name = "October", 
        MonthOfYear = 10 };
    yield return new Month { Name = "November", 
        MonthOfYear = 11 };
    yield return new Month { Name = "December", 
        MonthOfYear = 12 };
    }
}
}</pre></li>
			</ol>
			<p>This class returns a collection<a id="_idIndexMarker714"/> of <code>Month</code> objects using the <code>yield</code> keyword. Switch back to the <code>Yield</code> class. </p>
			<ol>
				<li value="7">Add the <code>PrintMonthsOfYear()</code> method:<pre>private void PrintMonthsOfYear()
{
foreach (Month month in new Months().MonthsOfYear)
    Console.WriteLine($"{month.Name} is month 
        {month.MonthOfYear} of the year.");
}</pre></li>
			</ol>
			<p>This method iterates through the months of the year and prints them out to the console window. </p>
			<ol>
				<li value="8">Add the <code>BreakIteration()</code> method:<pre>private IEnumerable&lt;int&gt; BreakIteration()
{
int x = 0;
while (x &lt; 20)
{
    if (x &lt; 15)
        yield return x;
    else
        yield break;
    x++;
}
}</pre></li>
			</ol>
			<p>This method iterates <code>20</code> times. A check is made upon<a id="_idIndexMarker715"/> each iteration. If the value is less than <code>15</code>, the result is yielded and the variable is incremented. Otherwise, the iteration is exited. </p>
			<ol>
				<li value="9">Add the <code>DoBreakIteration()</code> method:<pre>private void DoBreakIteration()
{
        foreach (int x in BreakIteration())
            Console.WriteLine($"Line {x}:");
}</pre></li>
			</ol>
			<p>The <code>DoBeakIteration()</code> method iterates through <code>BreakIteraton()</code> and writes the value to the console window. </p>
			<ol>
				<li value="10">In the <code>Program</code> class, add a method called <code>Yield()</code>, and call it from your <code>Main</code> method:<pre>private static void Yield()
{
        var yieldToMe = new Yield();
        yieldToMe.YieldSample();
}</pre></li>
			</ol>
			<p>This method runs our <code>yield</code> keyword examples. Do a debug build and step through the code so that you can see how it behaves. You will see that each time the <code>yield</code> keyword is encountered, it returns to the calling method. Then, it continues the iteration from where it left off.</p>
			<ol>
				<li value="11">Now, let's add our benchmarking<a id="_idIndexMarker716"/> to test the performance of the <code>yield</code> keyword. Add the <code>GetValues()</code> method:<pre>public IEnumerable&lt;long&gt; GetValues()
{
      List&lt;long&gt; list = new List&lt;long&gt;();
      for (long i = 0; i &lt; 1000000; i++)
            list.Add(i);
return list;
}</pre></li>
			</ol>
			<p>This method creates a collection of <code>long</code> values using a generic <code>List</code>. It iterates 1 million items and adds them to the collection. Once complete, the collection is returned to the caller as an <code>IEnumerable&lt;long&gt;</code> collection. </p>
			<ol>
				<li value="12">Add the <code>GetValuesYield()</code> method:<pre>public IEnumerable&lt;long&gt; GetValuesYield()
{
      for (long i = 0; i &lt; 1000000; i++)
          yield return i;
}</pre></li>
			</ol>
			<p>This method iterates through 1 million items and returns a collection of <code>IEnumerable&lt;long&gt;</code>. The iteration uses the <code>yield</code> keyword, so each iteration is returned to the caller. </p>
			<ol>
				<li value="13">Add the <code>GetValuesBenchmark()</code> method:<pre>[Benchmark]
public void GetValuesBenchmark()
{
      var data = GetValues();
}</pre></li>
			</ol>
			<p>This method benchmarks<a id="_idIndexMarker717"/> the <code>GetValues()</code> method.</p>
			<ol>
				<li value="14">Add the <code>GetValuesYieldBenchmark()</code> method:<pre>[Benchmark]
public void GetValuesYieldBenchmark()
{
      var data = GetValuesYield();
}</pre></li>
			</ol>
			<p>This method benchmarks the <code>GetValuesYield()</code> method. </p>
			<ol>
				<li value="15">Replace the code in the <code>Main</code> method in the <code>Program</code> class with the following line of code:<pre>BenchmarkRunner.Run&lt;Yield&gt;();</pre></li>
			</ol>
			<p>This line of code runs our benchmarks. Do a release build and then run the executable from the command line. You should see the following summary report:</p>
			<div><div><img src="img/B16617_Figure_6.8.jpg" alt="Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits of using the yield keyword&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits of using the yield keyword</p>
			<p>As you can see from the report, building a list of 1 million <code>long</code> values is much slower compared to using the <code>yield</code> keyword. The <code>yield</code> keyword significantly speeds up how collections are processed. That's a 13,102,611.27 ns / 14.50 ns = 903,628.26 times increase in performance! So, you can<a id="_idIndexMarker718"/> see that the use of the <code>yield</code> keyword is very beneficial to the performance of your computer programs.</p>
			<p>In the next section, we will look at the difference between concurrency and parallelism and the effects they have on performance.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor134"/>Learning the difference between concurrency and parallelism</h1>
			<p>Concurrency and parallelism<a id="_idIndexMarker719"/> are often mistaken for the same thing, but they<a id="_idIndexMarker720"/> are different. Concurrency does many tasks at the same time using multi-threading. Multi-threading allots time to various threads based on time/context switching. This presents the illusion that the computer is doing multiple things at the same time. But it is, in reality, only doing one thing. Parallelism, on the other hand, does many things all at the same time.</p>
			<p>Concurrency is used to manage<a id="_idIndexMarker721"/> multiple computations simultaneously. It accomplishes this using interleaving operations. The benefit of concurrency is that it increases the amount of work that can be completed over time. It uses context switching to perform interleaving operations. Concurrency can work with a single processor. You are already aware of concurrency at work, as you will have had multiple applications running at the same time. All these programs are making use of concurrency. </p>
			<p>The main usage of concurrency<a id="_idIndexMarker722"/> is to have usable applications that are non-blocking. For example, if you<a id="_idIndexMarker723"/> have an application that performs a long-running operation, this operation can be run on a background thread to allow the user to still use the application and get work done. So, concurrency is not necessarily about performance – it is more about not blocking your users from being able to do what they intend with your application.</p>
			<p>Parallelism performs multiple<a id="_idIndexMarker724"/> computations at the same time in parallel to each other. To accomplish parallelism, multiple processors are required. The benefit of using parallelism is increased computational processing speed. Running document crawlers over a cluster and performing parallel queries and big data are examples of using parallelism. </p>
			<p>The main goal of parallelism is performance. In other words, the intention of using parallelism is to complete an operation in the shortest amount of time. An example of parallelism in use would be data-intensive number crunching for report generation.</p>
			<p>You should never mix concurrency with performance. If you do, your design will either be bad or over-engineered. So, if you want user interfaces to be non-blocking, use concurrency. However, if you want non-UI tasks to complete in the shortest possible time, use parallelism. Later in this book, we will devote whole chapters to concurrency, parallelism, and asynchronous processing. But for now, let's turn our attention to the difference between <code>Equals()</code> and <code>==</code>.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor135"/>Learning the difference between Equals() and ==</h1>
			<p>The <code>==</code> operator compares <a id="_idIndexMarker725"/>object references, known<a id="_idIndexMarker726"/> as shallow comparison, while the <code>Equals()</code> method compares<a id="_idIndexMarker727"/> object content, known<a id="_idIndexMarker728"/> as deep comparison. Both the operator<a id="_idIndexMarker729"/> and the method can be overloaded.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you overload the <code>==</code> operator, then you should overload the <code>Equals()</code> method and vice versa. </p>
			<p>The <code>==</code> operator<a id="_idIndexMarker730"/> returns <code>true</code> in the following<a id="_idIndexMarker731"/> situations:</p>
			<ul>
				<li><code>Value Type Value == Value Type Value</code></li>
				<li><code>Reference Type Instance == Reference Type Instance</code></li>
				<li><code>String == String</code></li>
			</ul>
			<p>The <code>Equals()</code> method <a id="_idIndexMarker732"/>returns <code>true</code> in the following situations:</p>
			<ul>
				<li><code>ReferenceType.Equals(ReferenceType)</code> both refer to the same object reference</li>
				<li><code>ValueType.Equals(ValueType)</code> are both the same type and have the same value</li>
			</ul>
			<p>Now, let's add a new class called <code>Equality</code> to the root of the <em class="italic">CH06_Collections</em> project to demonstrate the difference in performance between the <code>==</code> operator and the <code>Equals()</code> method. Let's get started: </p>
			<ol>
				<li value="1">Add the <code>Equality</code> class, as follows:<pre>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Order;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.Declared)]
[RankColumn]
public class Equality { }</pre></li>
			</ol>
			<p>With that, our class has been configured to perform benchmarking. </p>
			<ol>
				<li value="2">Add the following code to the top of the class:<pre>private List&lt;string&gt; _listOne;
private List&lt;string&gt; _listTwo;
private int _value1;
private int _value2;
private string _string1;
private string _string2;</pre></li>
			</ol>
			<p>Here, we have<a id="_idIndexMarker733"/> our value types, reference types, and string <a id="_idIndexMarker734"/>types in place that will have their equality tested. </p>
			<ol>
				<li value="3">Now, add the <code>GlobalSetup()</code> method:<pre>[GlobalSetup]
public void GlobalSetup()
{
      _listOne = new List&lt;string&gt;
{
    "Alpha", "Beta", "Gamma", "Delta", "Eta", "Theta"
};
  _listTwo = _listOne;
  _value1 = 123;
  _value2 = _value1;
  _string1 = "Hello, world!";
  _string2 = _string1;
}</pre></li>
			</ol>
			<p>This method assigns our variables<a id="_idIndexMarker735"/> in preparation for our equality<a id="_idIndexMarker736"/> benchmarks. </p>
			<ol>
				<li value="4">Add the <code>ValueOperatorValue()</code> method:<pre>[Benchmark]
public void ValueOperatorValue()
{
      bool value = _value1 == _value2;
}</pre></li>
			</ol>
			<p>The <code>ValueOperatorValue()</code> method benchmarks the equality checking of two values using the <code>equality</code> operator. </p>
			<ol>
				<li value="5">Add the <code>ValueEqualsValue()</code> method:<pre>[Benchmark]
public void ValueEqualsValue()
{
      bool value = _value1.Equals(_value2);
}</pre></li>
			</ol>
			<p>The <code>ValueEqualsValue()</code> method benchmarks the equality checking of two values using the <code>Equals(value)</code> method. </p>
			<ol>
				<li value="6">Add the <code>ReferenceOperatorReference()</code> method:<pre>[Benchmark]
public void ReferenceOperatorReference()
{
      bool value = _listOne == _listTwo;
}</pre></li>
			</ol>
			<p>The <code>ReferenceOperatorReference()</code> method benchmarks<a id="_idIndexMarker737"/> the equality checking of two reference<a id="_idIndexMarker738"/> values using the equality operator. </p>
			<ol>
				<li value="7">Add the <code>ReferenceEqualsReference()</code> method:<pre>[Benchmark]
public void ReferenceEqualsReference()
{
      bool value = _listOne.Equals(_listTwo);
}</pre></li>
			</ol>
			<p>The <code>ReferenceEqualsReference()</code> method benchmarks the equality checking of two values using the <code>Equals(reference)</code> method. </p>
			<ol>
				<li value="8">Add the <code>StringOperatorString()</code> method:<pre>[Benchmark]
public void StringOpertatorString()
{
      bool value = _string1 == _string2;
}</pre></li>
			</ol>
			<p>The <code>StringOperatorString()</code> method benchmarks the equality testing of two strings using the <code>==</code> operator. </p>
			<ol>
				<li value="9">Next, add the <code>StringEqualsString()</code> method:<pre>[Benchmark]
public void StringEqualsString()
{
      bool value = _string1.Equals(_string2);
}</pre></li>
			</ol>
			<p>The <code>StringEqualsString()</code> method benchmarks<a id="_idIndexMarker739"/> the equality testing of two<a id="_idIndexMarker740"/> strings using the <code>Equals()</code> method. </p>
			<ol>
				<li value="10">Add <code>BenchmarkRunner.Run&lt;Equality&gt;();</code> to the <code>Main</code> method of the <code>Program</code> class, do a <code>Release</code> build, and then run your executable from the command line. You should end up with the following benchmark report:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_6.9.jpg" alt="Figure 6.9 – The BenchmarkDotNet summary report for various equality checks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – The BenchmarkDotNet summary report for various equality checks</p>
			<p>As we can see, it is quicker to test value type equality using the <code>==</code> operator, quicker to use the <code>==</code> operator to test reference type equality, and quicker to use <code>Equals(string)</code> when comparing strings. </p>
			<p>With that, we have completed<a id="_idIndexMarker741"/> this chapter. But before<a id="_idIndexMarker742"/> we move on to <a href="B16617_07_Final_SB_Epub.xhtml#_idTextAnchor139"><em class="italic">Chapter 7</em></a>, <em class="italic">LINQ Performance</em>, let's summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor136"/>Summary</h1>
			<p>In this chapter, we learned about the different types of collections and their usage. We saw that we should prefer using generic collections over non-generic collections. Then, we briefly touched on Big O Notation and how to use it to determine algorithmic efficiency. After that, we looked at choosing the right type of collection for what we needed.</p>
			<p>After that, we set up a sample database to test the querying and iteration of data using further on in the chapter. Then, we looked at how to choose between using interfaces and concrete classes and choosing between arrays and collections. Next, we looked at indexers and then moved on to look at <code>IEnumerable&lt;T&gt;</code>, <code>IEnumerator&lt;T&gt;</code>, and <code>IQueryable&lt;T&gt;</code> and their performance. </p>
			<p>The next topic we looked at was using the <code>yield</code> keyword. We touched on the differences between concurrency and parallelism and mentioned that these will be looked at in more depth in later chapters. Finally, we looked at the difference between the <code>==</code> operator and the <code>Equals()</code> method in terms of performance.</p>
			<p>In the next chapter, we will be looking at LINQ performance. But for now, see if you can answer the following questions, and check out the <em class="italic">Further reading</em> section to solidify what you have learned in this chapter.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor137"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">List the different namespace collections.</li>
				<li>What is Big O notation used for?</li>
				<li>What does algorithmic efficiency measure?</li>
				<li>Is it preferable to use <code>IList&lt;T&gt;</code> or <code>List&lt;T&gt;</code> in terms of instantiation speed?</li>
				<li>Should we use collections or arrays?</li>
				<li>What does an indexer do?</li>
				<li>Which method of iteration is fastest on an in-memory collection between <code>IEnumerable&lt;T&gt;</code> and <code>IEnumerator&lt;T&gt;</code>?</li>
				<li>In terms of memory and speed performance, what database query method performs best?</li>
				<li>When building a collection using iteration, what is the quickest way to build the collection up and return the results?</li>
			</ol>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor138"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li><em class="italic">Indexers</em>: <a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/">https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/</a>. </li>
				<li><em class="italic">ConsoleSecrets</em>: <a href="https://github.com/jasonshave/ConsoleSecrets">https://github.com/jasonshave/ConsoleSecrets</a>.</li>
				<li><em class="italic">Equality Operators</em>: <a href="https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators">https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators</a>.</li>
				<li><em class="italic">Interesting Performance Implications of C# 9 Records Equality Check</em>: <a href="https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919">https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919</a>.</li>
				<li><em class="italic">Improving Struct Equality Performance in C#:</em> <a href="http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C">http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C</a>.</li>
				<li><em class="italic">String Equality and Performance in C#:</em> <a href="https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/">https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/</a>.</li>
				<li><em class="italic">Performance Implications of Default Struct Equality in C#:</em> <a href="https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/">https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/</a>.</li>
				<li><em class="italic">Performance Best Practices in C#:</em> <a href="https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a">https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a</a>.</li>
				<li><em class="italic">8 Techniques to Avoid GC Pressure and Improve Performance in C# .NET</em>: <a href="https://michaelscodingspot.com/avoid-gc-pressure/">https://michaelscodingspot.com/avoid-gc-pressure/</a>.</li>
			</ul>
		</div>
	</body></html>