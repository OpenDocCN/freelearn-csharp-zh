<html><head></head><body>
		<div><h1 id="_idParaDest-182" class="chapter-number"><a id="_idTextAnchor185"/>11</h1>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor186"/>Packaging and Deployment</h1>
			<p>Now that we have completed the development and testing of our application, it is time to release it to the world! We will need to package and deploy it in order to distribute it to (millions of) users worldwide.</p>
			<p>Each platform (such as Windows, macOS, and Linux) has its own approach to distributing applications. Since .NET 8 is cross-platform, we can distribute Bookmarkr to even more users, no matter what platform they are using.</p>
			<p>However, before we package and distribute the application, it is important that we test it on every target platform.</p>
			<p>In this chapter, we will explore different packaging and deployment techniques that will help us achieve this goal. More specifically, we will do the following:</p>
			<ul>
				<li>Explore the different options when it comes to packaging and distributing a CLI application</li>
				<li>Learn how to package and distribute a cross-platform CLI application</li>
				<li>Learn how to deploy that CLI application to multiple platforms</li>
				<li>Learn how to manage versions of a distributed application</li>
			</ul>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor187"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11</a>.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor188"/>A bit of terminology</h1>
			<p>Throughout this chapter, you will come across the terms “packaging,” “distribution,” and “deployment.” For those of you who are not familiar with these terms, here is a brief definition of each:</p>
			<ul>
				<li><strong class="bold">Packaging</strong>: Packaging <a id="_idIndexMarker401"/>refers to the process of preparing the application for release. This includes bundling all necessary files, libraries, and resources into a single unit that can be easily installed or executed by our users. Effective packaging ensures that the application is compatible with various environments and simplifies the installation process. It often involves creating installers or archives that streamline the deployment of the application.</li>
				<li><code>apt-get</code> repositories). The goal of distribution is to make the application accessible to its intended audience while ensuring that it reaches them in a secure and efficient manner.</li>
				<li><strong class="bold">Deployment</strong>: Deployment is <a id="_idIndexMarker403"/>the mechanism by which the distributed application is installed and made operational on the user’s computer. This can involve configuring settings, integrating with existing systems, and ensuring that all components work appropriately. Deployment can be done manually or can be automated through various tools and scripts. The aim is to allow users to access and utilize the application effectively.</li>
			</ul>
			<p>As you may have figured out, making an application (including a CLI application) available to a user is a three-step process that can be summarized by this diagram:</p>
			<div><div><img src="img/B22400_11_01.jpg" alt="Figure 11.1 – The process of making an application available to users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The process of making an application available to users</p>
			<p>Now that we understand the terminology, let’s start by exploring the available options when it comes to the packaging, distribution, and deployment of a CLI application.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor189"/>Packaging and distribution options for CLI applications</h1>
			<p>When it comes to packaging a CLI application, several methods exist, and choosing the most appropriate one depends on the way we intend to distribute it.</p>
			<p>The most common options are as follows:</p>
			<ul>
				<li><strong class="bold">MSI installer</strong>: This<a id="_idIndexMarker404"/> option allows for a more traditional installation experience and can be achieved using tools such as WiX or Visual Studio Installer Projects. Keep in mind that this option only works for Windows. Hence, if we intend to distribute our CLI application to multiple platforms, this option may not be the best one.</li>
				<li><code>dotnet tool install</code> command. Since our CLI application is built using a version of .NET that is cross-platform, we can distribute it as a .NET tool to various platforms. The downside of this approach is in the installation mechanism: it requires the .NET CLI. This is great if our audience is developers or IT professionals but not that appropriate otherwise. We should only consider this approach if our CLI application is a developer or IT administrator tool, which is not the case with our bookmark management application.</li>
				<li><strong class="bold">Docker container</strong>: This<a id="_idIndexMarker406"/> is also a great option for multiplatform distribution. A noticeable advantage of a Docker container is that it has a lower footprint on the local machine since no local installation is performed and limited access to the system is required. A Docker container is a self-contained file. However, as with the .NET tool option, this option mainly targets developers or IT administrators since users need to have knowledge of using Docker in order to deploy our application.</li>
				<li><code>apt-get</code> package manager, while macOS provides Homebrew and Windows provides WinGet. These options are great since users of each platform are familiar with them no matter their technical knowledge. This means that these distribution mechanisms don’t just target developers and IT administrators but everyone! Once again, since our CLI application is built with cross-platform technology (.NET), we can use the same code and package it for distribution on each of these platforms.</li>
			</ul>
			<p>As you can see, several packaging and distribution options are provided to us, and you can use whichever best suits your situation. In this chapter, we will explore the last three packaging and distribution options: .NET tool, Docker container, and WinGet (as a platform-specific packaging option).</p>
			<p>Let’s get started!</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor190"/>Packaging and distributing a CLI application</h1>
			<p>In this section, we will explore the subtleties of packaging and distributing our application, Bookmarkr, using three different options. We will take this opportunity to explain when each approach is most appropriate.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor191"/>Option #1 – as a .NET tool</h2>
			<p>By packaging and<a id="_idIndexMarker408"/> distributing our application as a .NET tool, our users will be able to install it using the .NET CLI. It is, however, important that users ensure they have the appropriate .NET version installed to avoid version mismatches, which may cause unexpected behaviors in the application.</p>
			<h3>Step 1 – packaging</h3>
			<p>The first step is to<a id="_idIndexMarker409"/> modify the <code>.csproj</code> file to add properties that indicate that it should be packaged as a tool. These properties should be added to the <code>&lt;</code><code>PropertyGroup&gt;</code> section:</p>
			<pre class="source-code">
&lt;PackageId&gt;bookmarkr&lt;/PackageId&gt;
&lt;Version&gt;1.0.0&lt;/Version&gt;
&lt;Authors&gt;Tidjani Belmansour&lt;/Authors&gt;
&lt;Description&gt;Bookmarkr is a bookmarks manager provided as a CLI application.&lt;/Description&gt;
&lt;PackAsTool&gt;true&lt;/PackAsTool&gt;
&lt;ToolCommandName&gt;bookmarkr&lt;/ToolCommandName&gt;
&lt;PackageOutputPath&gt;./nupkg&lt;/PackageOutputPath&gt;
&lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;
&lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;
&lt;Copyright&gt;Tidjani Belmansour. All rights reserved.&lt;/Copyright&gt;
&lt;PackageProjectUrl&gt;https://github.com/PacktPublishing/Building-CLI-Applications-with-C#-and-.NET&lt;/PackageProjectUrl&gt;
&lt;RepositoryUrl&gt;https://github.com/PacktPublishing/Building-CLI-Applications-with-C#-and-.NET&lt;/RepositoryUrl&gt;
&lt;PackageTags&gt;.net cli;bookmark manager;.net 8&lt;/PackageTags&gt;</pre>			<p>Let’s explain what we have just added here:</p>
			<ul>
				<li><code>PackageId</code>: This represents the unique identifier for our package.</li>
				<li><code>Version</code>: This indicates the version of our package. We will need to change this value when we need to package a newer version.</li>
				<li><code>Authors</code>: This represents the author (or the list of authors) of a package.</li>
				<li><code>Description</code>: This provides a brief description of what the application does.</li>
				<li><code>PackAsTool</code>: Set to <code>true</code>, this indicates that the application should be packaged as a .NET tool.</li>
				<li><code>ToolCommandName</code>: This<a id="_idIndexMarker410"/> is the name of the command users will type into their terminal to execute our application.</li>
				<li><code>PackageOutputPath</code>: Since a .NET tool is packaged as a NuGet package, an <code>.nupkg</code> file is then generated. This property indicates where this file will be generated.</li>
				<li><code>PackageLicenseExpression</code>: I chose to provide the code as an MIT license since it is a permissive license that allows for the reuse of the code in any project as long as the original copyright notice and license are included in all copies or substantial portions of the software.</li>
				<li><code>PackageReadmeFile</code>: This points to a Markdown file in which we explain the purpose of the application, how to get started using it, and a link to its documentation, among other things. The content of this Markdown file will be displayed on the package page on the NuGet site for the user to read. You will find that file in the code repository.</li>
				<li><code>Copyright</code>: This presents the copyright details of the application.</li>
				<li><code>PackageProjectUrl</code>: This points to the home page of the project’s website.</li>
				<li><code>RepositoryUrl</code>: This points to the repository where the application’s code resides.</li>
				<li><code>PackageTags</code>: This presents a semicolon-delimited list of keywords that can be used when searching for packages.</li>
			</ul>
			<p>To specify<a id="_idIndexMarker411"/> the location and how to treat the <code>README.md</code> file, we need to add the following XML code to the <code>.</code><code>csproj</code> file:</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;None Include="README.md" Pack="true" PackagePath="\"/&gt;
&lt;/ItemGroup&gt;</pre>			<p>The second step is to package the application. This is achieved by running this command:</p>
			<pre class="console">
dotnet pack --configuration Release</pre>			<p>Remember that it will be generated at the location indicated by the value of the <code>PackageOutputPath</code> property.</p>
			<p>Our package is now ready for distribution.</p>
			<h3>Step 2 – distribution</h3>
			<p>The <a id="_idIndexMarker412"/>most common way to distribute a .NET tool is to provide it through the NuGet site, located at <a href="https://www.nuget.org">https://www.nuget.org</a>.</p>
			<p>So, let’s head to the NuGet site and click on the <strong class="bold">Sign in</strong> link in the top-right corner of the page:</p>
			<div><div><img src="img/B22400_11_02.jpg" alt="Figure 11.2 – Signing in to the NuGet site"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Signing in to the NuGet site</p>
			<p>I will be signing in with my personal account and granting the required permissions to the NuGet site, as shown here:</p>
			<div><div><img src="img/B22400_11_03.jpg" alt="Figure 11.3 – Granting required permissions to the NuGet site"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Granting required permissions to the NuGet site</p>
			<p>Since this is<a id="_idIndexMarker413"/> the first time I have signed in with this account, the NuGet site asks me to provide a username:</p>
			<div><div><img src="img/B22400_11_04.jpg" alt="Figure 11.4 – Choosing a username for the NuGet site"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Choosing a username for the NuGet site</p>
			<p>And that’s it! As a publisher of NuGet packages, I am now all set, and I can start uploading my packages:</p>
			<div><div><img src="img/B22400_11_05.jpg" alt="Figure 11.5 – All set as a NuGet package publisher"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – All set as a NuGet package publisher</p>
			<p>Let’s now upload our package!</p>
			<p>All we <a id="_idIndexMarker414"/>need to do is to click on <code>.nupkg</code> file we generated earlier. The package is then analyzed and the validation results are presented:</p>
			<div><div><img src="img/B22400_11_06.jpg" alt="Figure 11.6 – Uploading a package to the NuGet website"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Uploading a package to the NuGet website</p>
			<p>Since <a id="_idIndexMarker415"/>our package is valid, we can submit it by clicking the <strong class="bold">Submit</strong> button at the bottom of the page.</p>
			<p>Once uploaded, it usually takes around 15 minutes (but can sometimes take up to an hour) for the package to be validated and indexed before it appears in search results:</p>
			<div><div><img src="img/B22400_11_07.jpg" alt="Figure 11.7 – Package awaiting validation and indexing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Package awaiting validation and indexing</p>
			<p>Once the <a id="_idIndexMarker416"/>package validation and indexing have been completed, it will appear on the NuGet website just as any other NuGet package:</p>
			<div><div><img src="img/B22400_11_08.jpg" alt="Figure 11.8 – Bookmarkr is available on the NuGet website!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Bookmarkr is available on the NuGet website!</p>
			<p>Now that <a id="_idIndexMarker417"/>our application can be found by users, let’s see how it can be deployed.</p>
			<h3>Step 3 – deployment</h3>
			<p>A user <a id="_idIndexMarker418"/>can deploy (that is, install) our application on their machine very easily by typing this command:</p>
			<pre class="console">
dotnet tool install --global bookrmarkr</pre>			<p>After the installation is complete, the user can execute our application by typing this command:</p>
			<pre class="console">
bookrmarkr</pre>			<p>And that’s it! We’ve <a id="_idIndexMarker419"/>packaged, distributed, and deployed Bookmarkr as a .NET tool.</p>
			<p>Let’s now see how we can deliver Bookmarkr to our users as a Docker container.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor192"/>Option #2 – as a Docker container</h2>
			<p>Packaging and distributing our application as a Docker container allows our users to install and use our application by reducing the footprint of the application on their environment (i.e., operating system and data).</p>
			<h3>Step 1 – packaging</h3>
			<p>If you are<a id="_idIndexMarker420"/> familiar with containers, you may already know that in order to create a container image, a Dockerfile is required.</p>
			<p>A Dockerfile is a file with no extension that should be located at the root of the project directory. For our application, its content is the following:</p>
			<pre class="source-code">
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /app
COPY *.csproj ./
RUN dotnet restore
COPY . ./
RUN dotnet publish -c Release -o out
FROM mcr.microsoft.com/dotnet/runtime:8.0
WORKDIR /app
COPY --from=build /app/out .
ENTRYPOINT [«dotnet», «bookmarkr.dll»]</pre>			<p>In essence, this file instructs Docker to build and publish the application (the first six lines of it), and then to build a container image out of the published application (the remaining five lines).</p>
			<p>Before<a id="_idIndexMarker421"/> we run the command to actually build the image, we need to ensure that both Docker Desktop and <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) are<a id="_idIndexMarker422"/> installed and running. Note that Docker Desktop requires administrator privileges on the local machine.</p>
			<p>Docker Desktop can be installed using the following command:</p>
			<pre class="console">
winget install Docker.DockerDesktop</pre>			<p>WSL can be installed using the following command (Windows needs to be rebooted after WSL is installed):</p>
			<pre class="console">
<a id="_idTextAnchor193"/>wsl --install</pre>			<p>The command for building a Docker image is as follows:</p>
			<pre class="console">
docker build -t bookmarkr .</pre>			<p>The <code>-t bookmarkr</code> parameter is used to tag the Docker image to be generated with a name and an optional version number (more on that later).</p>
			<p>The last dot character is<a id="_idIndexMarker423"/> neither a typo nor is it optional. It refers to what we call the <strong class="bold">build context</strong>. More specifically, it instructs Docker where to look for the Dockerfile, which, in this case, is the current directory.</p>
			<p>The operation should take about five minutes, and once it is complete, the Docker image will be created, and it can be retrieved by typing the following:</p>
			<pre class="console">
docker images</pre>			<p>Note that the container image has been generated on our local machine. We should, however, distribute it through a location that everyone can easily find.</p>
			<h3>Step 2 – distribution</h3>
			<p>The most <a id="_idIndexMarker424"/>common way to distribute Docker images is through Docker Hub.</p>
			<p>To do that, we need to head<a id="_idIndexMarker425"/> to the Docker Hub portal, located at <a href="https://hub.docker.com">https://hub.docker.com</a>. If you don’t already have a Docker Hub account, you can create one from there. I already have such an account, and my username is <code>theAzurian</code>.</p>
			<p>So, let’s follow the steps to push our local Docker image to Docker Hub.</p>
			<p>First, let’s log in to our Docker Hub account using this command:</p>
			<pre class="console">
docker login -u theazurian -p ****</pre>			<p>I’m passing<a id="_idIndexMarker426"/> my <code>-p</code> parameter. This PAT was created through the Docker Hub portal.</p>
			<p>Next, we need<a id="_idIndexMarker427"/> to tag the image to include the Docker Hub username of its author, the name of the application, and its version, such as the following:</p>
			<pre class="console">
docker tag bookmarkr theazurian/bookmarkr:1.0.0</pre>			<p>Finally, we need to push the tagged image to Docker Hub using this command:</p>
			<pre class="console">
docker push theazurian/bookmarkr:1.0.0</pre>			<p>We can ensure that the image has effectively been pushed to Docker Hub by heading to the portal and looking for it in our Docker Hub profile:</p>
			<div><div><img src="img/B22400_11_09.jpg" alt="Figure 11.9 – Bookmarkr is available in the Docker Hub portal!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Bookmarkr is available in the Docker Hub portal!</p>
			<p>We can also perform a search for it in the Docker Hub portal:</p>
			<div><div><img src="img/B22400_11_10.jpg" alt="Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal</p>
			<p>Our application <a id="_idIndexMarker428"/>can now be found by our users. Let’s see how it can be deployed.</p>
			<h3>Step 3 – deployment</h3>
			<p>In <a id="_idIndexMarker429"/>order for a user to run Docker on a Windows machine, they also need to have both Docker Desktop and WSL installed.</p>
			<p>Docker Desktop can be installed using the following command:</p>
			<pre class="console">
winget install Docker.DockerDesktop</pre>			<p>WSL can be installed using the following command (Windows needs to be rebooted after WSL is installed):</p>
			<pre class="console">
wsl --install</pre>			<p>Now, our user can obtain the application from Docker Hub by typing this command:</p>
			<pre class="console">
docker pull theazurian/bookmarkr:1.0.0</pre>			<p>They can execute it by typing this command:</p>
			<pre class="console">
docker run theazurian/bookmarkr:1.0.0</pre>			<p>Bookmarkr can then be run on the user’s computer as a Docker container:</p>
			<div><div><img src="img/B22400_11_11.jpg" alt="Figure 11.11 – Bookmarkr running as a Docker container"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Bookmarkr running as a Docker container</p>
			<p>And that’s it! We<a id="_idIndexMarker430"/> packaged, distributed, and deployed Bookmarkr as a Docker container.</p>
			<p>Let’s now see how we can deliver Bookmarkr to our users as a WinGet package.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor194"/>Option #3 – as a WinGet package</h2>
			<p>By <a id="_idIndexMarker431"/>packaging and distributing our application as a WinGet package, we allow our users to install it as any other application they have installed using WinGet, Microsoft’s package manager.</p>
			<h3>Packaging</h3>
			<p>To<a id="_idIndexMarker432"/> package a .NET CLI application for distribution through WinGet (the official Windows package manager), we first need to create a manifest file.</p>
			<p>Although it is possible to manually create and submit the manifest to the WinGet package repository on GitHub (<a href="https://github.com/microsoft/winget-pkgs">https://github.com/microsoft/winget-pkgs</a>), the easiest way to do so is using the <code>WingetCreate</code> CLI.</p>
			<p>Let’s first install it using this command:</p>
			<pre class="console">
winget install wingetcreate</pre>			<p>Before we create the new manifest, we first need to build our CLI application as a self-contained .NET application using this command:</p>
			<pre class="console">
dotnet publish -c Release -r win-x64 -p:selfcontained=true -p:IncludeNativeLibrariesForSelfExtract=true -p:PublishSingleFile=true</pre>			<p>Let’s take a closer look at this command:</p>
			<ul>
				<li><code>-c Release</code>: Since this is a production-ready version of the application, we want to publish it using the Release configuration to ensure that it is optimized for performance.</li>
				<li><code>-r win-x64</code>: Since WinGet is the package manager for Windows (and Windows only), we specify the target runtime to be the 64-bit version of Windows.</li>
				<li><code>-p:selfcontained=true</code>: A self-contained application already includes the .NET runtime, so the user’s machine doesn’t need to have it installed. The application will then carry everything it needs to run, including the runtime, libraries, and dependencies.</li>
				<li><code>-p:IncludeNativeLibrariesForSelfExtract=true</code>: This ensures that platform-specific libraries, along with unmanaged native libraries, are included in<a id="_idIndexMarker433"/> the published application. This is useful if we use some specific Serilog sinks and for the SQLite library.</li>
				<li><code>-p:PublishSingleFile=true</code>: This instructs .NET to bundle everything (including the application code, the .NET runtime, and the dependencies) into a single executable file. While this makes it more convenient for distribution (because we are distributing a single file), it results in a file that is larger in size than framework-dependent publishing.</li>
			</ul>
			<p>The application will be generated in the <code>bin\Release\net8.0\win-x64\publish</code> directory.</p>
			<p>Next, we will <a id="_idIndexMarker434"/>upload it to a location that should be accessible to the WinGet tool. It is common to pick a remote, publicly accessible, read-only location. I decided to use an Azure Storage account. Hence, the location of the executable will be <a href="https://bookmarkr.blob.core.windows.net/releases/1.0.0/">https://bookmarkr.blob.core.windows.net/releases/1.0.0/</a>.</p>
			<p class="callout-heading">About GitHub releases</p>
			<p class="callout">If your application is built as an open source project on GitHub, you will likely make your executable versions available as releases. However, releases on GitHub follow certain guidelines that go way beyond the scope of this book. If this is a topic you are interested in, I recommend that you explore these guidelines by visiting <a href="https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md">https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md</a>.</p>
			<p>Let’s now create our manifest files! We can do so using this command:</p>
			<pre class="console">
wingetcreate new https://bookmarkr.blob.core.windows.net/releases/1.0.0/bookmarkr.exe</pre>			<p>The tool will ask a series of questions required to generate the manifest files. Here is an example of what it looks like:</p>
			<div><div><img src="img/B22400_11_12.jpg" alt="Figure 11.12 – Generating the WinGet manifest files"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Generating the WinGet manifest files</p>
			<p>There <a id="_idIndexMarker435"/>will be three files generated:</p>
			<ul>
				<li><strong class="bold">Version manifest (theAzurian.bookmarkr.yaml)</strong>: Contains metadata about the specific version of the application being packaged.</li>
				<li><strong class="bold">Installer manifest (theAzurian.bookmarkr.installer.yaml)</strong>: Details the installation specifics of the application.</li>
				<li><strong class="bold">Default locale manifest (theAzurian.bookmarkr.locale.en-CA.yaml)</strong>: Defines localization settings for the application. It ensures that users receive a version of the application that is appropriately localized, enhancing user experience by presenting information in their preferred language.</li>
			</ul>
			<p>I personally like to keep these files inside my Visual Studio project, inside the following folder structure that I create at the root of the project:</p>
			<pre class="source-code">
/manifests/ApplicationName/Version</pre>			<p>So, in our case, this folder structure will look like this:</p>
			<pre class="source-code">
/manifests/Bookmarkr/1.0.0</pre>			<p>Before we <a id="_idIndexMarker436"/>submit our manifest to the WinGet team, it is recommended that we test it locally to ensure that it works as expected. This is important as submitting our package could lead to a delay during the WinGet approval process if the manifest contains issues.</p>
			<p>To do this, we first need to activate the ability to install applications from local manifests. This can be done by executing the following command in a terminal running as administrator:</p>
			<pre class="console">
winget settings --enable LocalManifestFiles</pre>			<p>Next, we run this command, providing the path to the <code>manifests.json</code> file:</p>
			<pre class="console">
winget install --manifest "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.0\"</pre>			<p>As we can see, the application is installed and runs as expected:</p>
			<div><div><img src="img/B22400_11_13.jpg" alt="Figure 11.13 – Testing the WinGet package locally before submission"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Testing the WinGet package locally before submission</p>
			<p>We are now ready to submit our manifest to the WinGet team!</p>
			<p>Submitting our manifest to the WinGet package repository requires us to generate a PAT for our GitHub account. We can do this using the <code>wingetcreate token</code> command, or we can skip this step and, when submitting the manifest, <code>wingetcreate</code> will prompt us to authenticate to our GitHub account. Let’s do it this way!</p>
			<p>Let’s run the following command:</p>
			<pre class="console">
wingetcreate submit "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.0\"</pre>			<p>This will open the browser and take us to the GitHub sign-in page. We will have to log on to our account. Once done, we will need to provide the required authorization:</p>
			<div><div><img src="img/B22400_11_14.jpg" alt="Figure 11.14 – Authorizing WingetCreate for our GitHub account"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Authorizing WingetCreate for our GitHub account</p>
			<p>It will then<a id="_idIndexMarker437"/> take us to the Pull Request page where we can follow its progress. After about 30 minutes, the pull request is completed, and the package is available for our users to install.</p>
			<p>Users can then install Bookmarkr using WinGet by typing this command:</p>
			<pre class="console">
winget install --id theAzurian.Bookmarkr</pre>			<p>And voilà! We have packaged, distributed, and deployed Bookmarkr as a WinGet package.</p>
			<p>So, we have seen three different approaches to packaging, distributing, and deploying our application. But how do we manage multiple versions of that application? That’s what we are going to explore in the next section.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor195"/>Managing versions of the application</h1>
			<p>All the options<a id="_idIndexMarker438"/> that we presented earlier provide version management mechanisms. Version management is as important as the packaging and distribution mechanism that we select.</p>
			<p>As our <a id="_idIndexMarker439"/>application evolves and new features are added, modified, or removed, we want to offer a way for our users to consume these updates at their convenience. That is where versioning comes into play.</p>
			<p>Currently, only a single version of our application is distributed. We can hence install it by either omitting its version number or explicitly indicating it.</p>
			<p>But what if we update the application? How can we distribute the new version? And what if the new version introduces a bug and we need to roll back to the previous version?</p>
			<p>Let’s explore how we can achieve this for each of the distribution methods that we covered earlier.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor196"/>Semantic versioning primer</h2>
			<p>Before <a id="_idIndexMarker440"/>we dive into managing different versions of an application, let us start by introducing <strong class="bold">semantic versioning</strong>.</p>
			<p>If you are familiar with this approach to versioning applications, you know that it is probably the most common and widely adopted approach in the industry. If you haven’t heard about it before, let me give you a quick introduction. If you want to go deeper in your exploration of semantic versioning, I recommend that you visit its official website at <a href="https://semver.org">https://semver.org</a>.</p>
			<p>In essence, semantic versioning expresses a version number using this format:</p>
			<pre class="source-code">
Major.Minor.Patch</pre>			<p>Here, we have the following:</p>
			<ul>
				<li><strong class="bold">Major</strong>: Indicates that this version of the application contains breaking changes that are incompatible with the previous major version</li>
				<li><strong class="bold">Minor</strong>: Indicates that this version of the application only adds new functionalities that are backward compatible with the previous versions of the same major version</li>
				<li><strong class="bold">Patch</strong>: Indicates that this version of the application contains bug fixes that are backward compatible with the previous versions of the same major version</li>
			</ul>
			<p>Each part is<a id="_idIndexMarker441"/> represented as a number that is incremented with each new version.</p>
			<p>Now that we understand semantic versioning, let’s use it to manage different versions of our application.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor197"/>Managing versions of a .NET tool</h2>
			<p>If you <a id="_idIndexMarker442"/>ran the version of Bookmarkr that we provided as a .NET tool, you will certainly have noticed that it returns the following error message:</p>
			<div><div><img src="img/B22400_11_15.jpg" alt="Figure 11.15 – Bookmarkr as a .NET tool fails to execute"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Bookmarkr as a .NET tool fails to execute</p>
			<p>Let’s then fix the problem and distribute a new version.</p>
			<p>The error comes from the fact that the <code>appsettings.json</code> file is not being made part of the package when the <code>dotnet pack</code> command is executed.</p>
			<p>Fortunately, fixing this problem is straightforward. Locate the following entry in the <code>.</code><code>csproj</code> file:</p>
			<pre class="source-code">
&lt;None Update="appsettings.json"&gt;</pre>			<p>Replace it with the following:</p>
			<pre class="source-code">
&lt;None Update="appsettings.json" Pack="true" PackagePath="\"&gt;</pre>			<p>Now, since<a id="_idIndexMarker443"/> the new version we are about to package and distribute only provides a bug fix, we shall increment the patch number, so the version number looks like the following:</p>
			<pre class="source-code">
&lt;Version&gt;1.0.3&lt;/Version&gt;</pre>			<p>We can now package and distribute the new version by following the same steps that we described earlier.</p>
			<p>However, before we distribute it, it is recommended to test it locally using the following command:</p>
			<pre class="console">
dotnet tool install --global bookmarkr --version 1.0.3 --add-source "C:\code\Chap11\bookmarkr\nupkg"</pre>			<p>The <code>--add-source</code> parameter allows us to specify a location from which the package will be deployed. Here, I am specifying the path where the NuGet package was generated on my local machine.</p>
			<p>After ensuring that this new version works successfully on the local machine, we can proceed with pushing it to the NuGet website.</p>
			<p>Users can get a specific version of the tool by providing its version number as a parameter. In this case, this could be achieved by typing this command:</p>
			<pre class="console">
dotnet tool install --global bookmarkr --version 1.0.3</pre>			<p>Or, they can simply type the following command to get the latest version:</p>
			<pre class="console">
dotnet tool install --global bookmarkr</pre>			<p>Once this command is executed, the previous version of the tool will be replaced by the new one.</p>
			<p>By running the new version of the application, we can now see that the error is resolved:</p>
			<div><div><img src="img/B22400_11_16.jpg" alt="Figure 11.16 – Bookmarkr as a .NET tool running successfully"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Bookmarkr as a .NET tool running successfully</p>
			<p>And that’s it! We <a id="_idIndexMarker444"/>now know how to manage versions of a .NET tool.</p>
			<p>Let’s see how we manage versions of a Docker container.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor198"/>Managing versions of a Docker container</h2>
			<p>As you <a id="_idIndexMarker445"/>may have noticed, when we pushed the Docker image to Docker Hub, we tagged it with a version number. Hence, if we want to distribute a new version, we can tag the new image with a different version number.</p>
			<p>However, if you are familiar with Docker, you may know about working with containers without providing their version number or using the <code>latest</code> tag.</p>
			<p>When distributing multiple versions of a container, it is important to indicate which one of these is the latest version, by tagging that version using the <code>latest</code> tag.</p>
			<p>So, let’s assume that we are distributing a new version of Bookmarkr and that we want to indicate that this new version is the latest one. We can achieve this as follows:</p>
			<pre class="source-code">
docker build -t theazurian/bookmarkr:2.0.0 .
docker tag theazurian/bookmarkr:2.0.0 theazurian/bookmarkr:latest
docker push theazurian/bookmarkr:2.0.0
docker push theazurian/bookmarkr:latest</pre>			<p>Let’s explain these commands:</p>
			<ul>
				<li>The first one creates a new Docker image that is tagged with version 2.0.0</li>
				<li>The second one tags version 2.0.0 as the latest version</li>
				<li>The third command pushes the image tagged with version 2.0.0 to Docker Hub</li>
				<li>The fourth one pushes the image tagged with the latest version to Docker Hub</li>
			</ul>
			<p>The <a id="_idIndexMarker446"/>fact that we push the same image using two different tags allows our users to get it (using the <code>docker pull</code> command) with or without specifying its version number. Hence, as we keep updating the application and pushing new Docker images, we will tag the newest version with the <code>latest</code> tag. Should that version contain a bug, we can direct our users to a previous version by tagging it with the <code>latest</code> tag.</p>
			<p>If we head to the Docker Hub portal, we will see that the new version has been successfully pushed. Notice that there are two versions of the same image: one with version number 2.0.0 as a tag, and the other with the <code>latest</code> tag.</p>
			<div><div><img src="img/B22400_11_17.jpg" alt="Figure 11.17 – New version of the Docker image pushed to Docker Hub"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – New version of the Docker image pushed to Docker Hub</p>
			<p>On the <a id="_idIndexMarker447"/>user’s side, they can get a specific version by explicitly mentioning its tag, as follows:</p>
			<pre class="console">
docker pull theazurian/bookmarkr:2.0.0</pre>			<p>Or, they can get the latest version (i.e., the version tagged as <code>latest</code>) by omitting the tag, as follows:</p>
			<pre class="console">
docker pull theazurian/bookmarkr</pre>			<p>The user will then see this:</p>
			<div><div><img src="img/B22400_11_18.jpg" alt="Figure 11.18 – Running the new version of the Docker container"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Running the new version of the Docker container</p>
			<p>And that’s it! We <a id="_idIndexMarker448"/>now know how to manage versions of a Docker image.</p>
			<p>Let’s see how we manage versions of a WinGet package.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor199"/>Managing versions of a WinGet package</h2>
			<p>In order to <a id="_idIndexMarker449"/>submit a new version of the application, following an update to the application’s code or functionalities, we first need to update the version number in the <code>.csproj</code> file (the <code>&lt;</code><code>Version&gt;</code> element).</p>
			<p>Next, we need to publish the application again using the same command we saw earlier:</p>
			<pre class="console">
dotnet publish -c Release -r win-x64 -p:selfcontained=true -p:IncludeNativeLibrariesForSelfExtract=true -p:PublishSingleFile=true</pre>			<p>We then<a id="_idIndexMarker450"/> need to upload the resulting binaries to our distribution location, which is our Azure Storage account, keeping in mind that we should create a new directory for the new version. The path will then look like this for version 1.0.3:</p>
			<pre class="source-code">
https://bookmarkr.blob.core.windows.net/releases/1.0.3/bookmarkr.exe</pre>			<p>The next step is to update the manifest using this command:</p>
			<pre class="console">
wingetcreate update theAzurian.Bookmarkr --version 1.0.3 https://bookmarkr.blob.core.windows.net/releases/1.0.3/bookmarkr.exe</pre>			<p>The new manifest is then generated and is ready for submission.</p>
			<p>However, as we previously learned, it is always good practice to test the new version locally before submitting it. To do that, we will execute the same command as we did previously:</p>
			<pre class="console">
winget install --manifest "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.3\"</pre>			<p>Once the tests are successful, we submit the new version using this command:</p>
			<pre class="console">
wingetcreate submit "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.3\"</pre>			<p>The remaining steps are similar to those we followed when submitting the initial version of the application.</p>
			<p>Once the new version has been approved and added to the WinGet package repository, users can find it and install it. They can install the latest version using this command:</p>
			<pre class="console">
winget install --id theAzurian.Bookmarkr</pre>			<p>Or, they can install a specific version by passing the desired version number as a parameter to the command, as follows:</p>
			<pre class="console">
winget install --id theAzurian.Bookmarkr --version 1.0.3</pre>			<div><div><img src="img/B22400_11_19.jpg" alt="Figure 11.19 – The updated version of Bookmarkr is available in WinGet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – The updated version of Bookmarkr is available in WinGet</p>
			<p>And that’s it! This is<a id="_idIndexMarker451"/> how we manage multiple versions of a WinGet package.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor200"/>Summary</h1>
			<p>In this chapter, we learned how to package and deploy Bookmarkr onto different platforms in order to distribute it to users all around the world, no matter their platform of choice, be it Windows, Linux, or macOS.</p>
			<p>This is quite a milestone we achieved, from the inception of the idea of our CLI application all the way to getting it into the hands of millions of users worldwide. Let’s take a moment to celebrate this achievement and be proud of ourselves. Congratulations! 🎉</p>
			<p>However, some users are telling us that the application is sometimes slow. We haven’t experienced these performance issues since we are running on fast and powerful computers, but that is not the case with all our users. Although we could simply specify the minimum requirements to run Bookmarkr, we don’t want to limit the number of users that can benefit from and be able to use it. So, we have decided to see whether there is something we can do.</p>
			<p>In the next chapter, we will explore different techniques that will allow us to optimize the performance of our application.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor201"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>An even better way is by challenging yourself to complete tasks. Hence, I challenge you to improve the Bookmarkr application by adding the following features.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor202"/>Task #1 – allowing Linux users to install Bookmarkr using apt-get</h2>
			<p>Currently, Bookmarkr can be deployed to Windows using WinGet. However, this doesn’t work on Linux, where Linux users typically use <code>apt-get</code> for deploying applications. You are thus challenged to distribute Bookmarkr as an <code>apt-get</code> package so Linux users can also enjoy using it.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor203"/>Task #2 – allowing macOS users to install Bookmarkr using Homebrew</h2>
			<p>The same applies to macOS users: they typically install their applications using the <code>brew</code> command. You are thus challenged to distribute Bookmarkr as a Homebrew formula.</p>
		</div>
	

		<div><h1 id="_idParaDest-200" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor204"/>Part 5: Advanced Techniques and Best Practices</h1>
			<p>In this part, you will explore crucial aspects of CLI application development that enhance performance, security, and functionality. You'll delve into performance optimization and tuning techniques, learning how to profile your CLI applications, identify bottlenecks, and implement efficient algorithms and data structures. This includes strategies like caching, load balancing, and code refactoring to improve execution speed and resource utilization. Next, you'll focus on security considerations specific to CLI applications, covering best practices and protection against common vulnerabilities. You'll learn how to implement strong authentication mechanisms, use encryption for sensitive data, and follow the principle of least privilege in your CLI tools. Finally, you'll explore additional resources and libraries that will allow you to dive deeper into the various concepts and techniques presented in this book.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B22400_12.xhtml#_idTextAnchor205"><em class="italic">Chapter 12</em></a><em class="italic">, Performance Optimization and Tuning</em></li>
				<li><a href="B22400_13.xhtml#_idTextAnchor220"><em class="italic">Chapter 13</em></a><em class="italic">, Security Considerations for CLI Applications</em></li>
				<li><a href="B22400_14.xhtml#_idTextAnchor236"><em class="italic">Chapter 14</em></a><em class="italic">, Additional Resources and Libraries</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>