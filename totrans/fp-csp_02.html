<html><head></head><body>
		<div><h1 id="_idParaDest-27" class="chapter-number"><a id="_idTextAnchor026"/>2</h1>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Expressions and Statements</h1>
			<p>Welcome to the first hands-on chapter of our journey! In this chapter, we are going to discuss expressions and statements, lambda expressions, and expression trees. These are the topics we will cover:</p>
			<ul>
				<li>Understanding the difference between expressions and statements</li>
				<li>Writing clear and declarative code using expressions</li>
				<li>Utilizing expression-bodied members, lambda expressions, anonymous methods, and local functions effectively</li>
				<li>Manipulating expressions at runtime using expression trees</li>
			</ul>
			<p>Before we dive in, I want to tell you that I value your time, so most of the chapters will start with assessment tasks. These tasks are not meant to be solved all the time and are aimed to help you measure your existing understanding of the topic. If these tasks are no-brainers for you, you might want to skip the chapter for now. And vice versa, if the tasks are quite challenging for you, you might want to dedicate more time and effort to the chapter. At the end of each chapter with tasks, you will find the solutions section to check your answers. Now that you know the deal, let’s check the three tasks designed for this chapter.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Task 1 – Name and count all expressions and all statements</h1>
			<p>Name and<a id="_idIndexMarker041"/> count all <a id="_idIndexMarker042"/>expressions and all statements in the code snippet below:</p>
			<pre class="source-code">
Tower mainTower = new(position: new Vector2(5, 5));
for (int level = 1; level &lt;= mainTower.MaxLevel; level++)
{
     double upgradeCost = 100 * Math.Pow(1.5, level - 1);
     Console.WriteLine($"Upgrading to level {level} costs {upgradeCost} gold");
     if (playerGold &gt;= upgradeCost)
     {
                  mainTower.Upgrade();
                  playerGold -= upgradeCost;
     }
}</pre>			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Task 2 – Use expressions instead of statements</h1>
			<p>Refactor the code<a id="_idIndexMarker043"/> below to use expressions instead of statements:</p>
			<pre class="source-code">
string GetTowerDamageReport(IEnumerable&lt;Tower&gt; towers)
{
      int totalDamage = 0;
      foreach (Tower tower in towers)
      {
           if (tower.IsActive)
           {
                totalDamage += tower.Damage;
           }
      }
      return $"Active towers deal {totalDamage} total damage";
}</pre>			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Task 3 – Create an expression tree</h1>
			<p>Create an expression<a id="_idIndexMarker044"/> tree that is the lambda expression <code>(baseDamage, level) =&gt; baseDamage * level</code>. Then, compile and invoke it.</p>
			<p>If you’re 100% sure that you know the answers to all three tasks, then you can confidently skip this chapter. However, there’s always a chance you might miss something useful, so instead of skipping the chapter entirely, you might want to save it for later. In any case, you can always come back and read it if you have any questions, or if anything becomes uncle<a id="_idTextAnchor031"/>ar.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/>Understanding the difference between expressions and stateme<a id="_idTextAnchor033"/>nts</h1>
			<p>At its core, an <strong class="bold">expression</strong> in C# is just <a id="_idIndexMarker045"/>a piece of code that <a id="_idIndexMarker046"/>evaluates to a value. Simple expressions include constants, variables, and method calls. On the other hand, a <strong class="bold">statement</strong> is a standalone unit of code that performs an action. In essence, it is an executable instruction. The best way to understand something is through practice. So, let’s not delay anymore and look at expressions and statements through exam<a id="_idTextAnchor034"/>ples.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Example of expressions</h2>
			<p>Consider<a id="_idIndexMarker047"/> the following C# code:</p>
			<pre class="source-code">
var pagesPerChapter = 20;
var totalBookPages = pagesPerChapter<a id="_idTextAnchor036"/> * 10;</pre>			<p>In this snippet, 20, <code>pagesPerChapter</code>, <code>10</code>, and <code>pagesPerChapter * 10</code> are all expressions. Each of these pieces of code evaluates to a <a id="_idTextAnchor037"/>value.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor038"/>Example of statements</h2>
			<p>Now, let’s identify <a id="_idIndexMarker048"/>statements:</p>
			<pre class="source-code">
var pagesPerChapter = 20;
var totalBookPages = pagesPerChapter * 10;</pre>			<p>Here, var pagesPerChapter = 20; and var totalBookPages = pagesPerChapter * 10; are statements. The first line instructs the program to declare a pagesPerChapter variable and initialize it with a value of 20. The second line instructs the program to multiply the value of pagesPerChapter by 10 and save it in the <code>totalBookPages</code> variable. Both are standalone code<a id="_idIndexMarker049"/> units that perform actions, fitting our definition of a st<a id="_idTextAnchor039"/>atement.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor040"/>Key differences between expressions and statements</h2>
			<p>Although statements<a id="_idIndexMarker050"/> and expressions can sometimes look<a id="_idIndexMarker051"/> similar, remember that an expression produces a value and can be used in larger expressions. In contrast, a statement performs an action and serves as a part of a method or program structure.</p>
			<p>In C#, every expression can be turned into a statement, but not every statement can be an expression. For example, <code>x = y + 2</code> is a statement where <code>y + 2</code> is an expression. However, a <code>for</code> loop or an <code>if</code> statement cannot be ex<a id="_idTextAnchor041"/>pressions.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor042"/>Guided exercise – finding expressions and statements in sample code</h2>
			<p>Let’s exercise your knowledge. Can <a id="_idIndexMarker052"/>you find and count all the<a id="_idIndexMarker053"/> expressions and statements in a slightly more complex code snippet?</p>
			<pre class="source-code">
int bookCount = 5;
for(int chapter = 1; chapter &lt;= bookCount; chapter++)
{
     var wordCount = chapter * 1000;
     Console.WriteLine($"Chapter {chapter} contains {wordCount} words.");
}</pre>			<p>Here, we have 8 expressions and 4 statements. S<a id="_idTextAnchor043"/>pecifically:</p>
			<ul>
				<li><code>5</code>, <code>1</code>, <code>chapter</code>, <code>bookCount</code>, <code>chapter &lt;= bookCount</code>, <code>chapter++</code>, <code>1000</code>, <code>chapter * 1000</code>, <code>chapter</code>, <code>wordCount</code>, and <code>$"Chapter {chapter} contains {</code><code>wordCount} words."</code></li>
				<li><code>int bookCount = 5;</code>, <code>for(int chapter = 1; chapter &lt;= bookCount; chapter++)</code>, <code>var wordCount = chapter * 1000;</code>, and <code>Console.WriteLine($"Chapter {chapter} contains {</code><code>wordCount} words.");</code></li>
			</ul>
			<p>Understanding the difference between expressions and statements helps you write better, clearer code. As you keep learning C#, you’ll get used to these basics and be able to make <a id="_idIndexMarker054"/>better<a id="_idIndexMarker055"/> software. Keep going with this knowledge, and let’s keep exploring functiona<a id="_idTextAnchor044"/>l programming.</p>
			<h1 id="_idParaDest-37">How to use expressions for clear a<a id="_idTextAnchor045"/>nd simple code</h1>
			<p>Using short and clear<a id="_idIndexMarker056"/> code makes it easy to understand what it’s doing. It’s also easier for you and others to read later on. Using expressions in C# can help us do this. Let’s learn how to shape our code wi<a id="_idTextAnchor046"/>th expressions.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor047"/>The power of expressions – improving readability and maintainability</h2>
			<p>Expressions support<a id="_idIndexMarker057"/> the idea of immutability, a cornerstone of functional programming. Since expressions evaluate to a value and don’t modify the state of our program, they allow us to write code that’s less prone to bugs, easier to reason about, and simple to test.</p>
			<p>One day, Steve received a phone call from his old friend Irene, a renowned author of children’s books. She had begun to notice that books with longer titles seemed to be more popular. To test her theory, she gathered the titles of all the top-selling books and asked Steve to develop a program to calculate the average title length associated with popularity.</p>
			<p>Initially, Steve created the program in the manner he was accustomed to:</p>
			<pre class="source-code">
double averageLength = 0;
foreach (string title in bookTitles)
{
    int titleLength = title.Length;
    averageLength += titleLength;
}
averageLength /= bookTitles.Length;</pre>			<p>However, the code looked wordy, and he decided to practice a functional approach and rewrite the code. He replaced the <code>foreach</code> loop with a simple  <code>Average</code> expression that computes the average character count:</p>
			<pre class="source-code">
var averageLength = bookTitles.Average(title =&gt; title.Length);</pre>			<p>With what almost<a id="_idIndexMarker058"/> seemed like magic, all these computations became just a single line of code. One line of more functional and concise code using expressions inste<a id="_idTextAnchor048"/>ad of statements.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor049"/>Techniques to convert statements to expressions</h2>
			<p>A great step <a id="_idIndexMarker059"/>toward embracing functional programming<a id="_idIndexMarker060"/> in C# is turning your statements into expressions where possible. As we just saw, <strong class="bold">LINQ</strong> (which stands for <strong class="bold">Language INtegrated Query</strong>) can be <a id="_idIndexMarker061"/>a powerful tool in this transformation.</p>
			<p>In the previous example, we used the <code>Average</code> method from LINQ. These are extension methods available for any <code>IEnumerable&lt;T&gt;</code>, allowing us to perform complex operations on collections with simple, expressive code.</p>
			<p>We can further leverage other LINQ methods, such as <code>Where</code> for filtering, <code>OrderBy</code> for sorting, and <code>Aggregate</code> for reducing a collection to a single value.</p>
			<p>Also, the code can be transformed to comply with the functional approach even without LINQ methods. For example, we can convert <code>if</code> statements into a conditional operator:</p>
			<pre class="source-code">
// If-else statement
string bookStatus;
if (pageCount &gt; 300)
{
     bookStatus = "Long read";
}
else
{
     bookStatus = "Quick read";
}
// Conditional operator
string bookStatus = pageCount &gt; 300 ? "Long read" : "Quick read";</pre>			<p>Moreover, all <code>for</code>, <code>while</code>, <code>foreach</code>, and so on loops can be replaced with recursive methods, which will<a id="_idIndexMarker062"/> be expressions when run. In addition, we<a id="_idIndexMarker063"/> can use the <code>Result</code> type instead of exceptions and higher-order functions, which will be discus<a id="_idTextAnchor050"/>sed in later chapters.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor051"/>Guided exercise – refactoring code using expressions</h2>
			<p>Emily approached<a id="_idIndexMarker064"/> Steve with a request to help her create <a id="_idIndexMarker065"/>a program that would display the view count of her YouTube videos. However, Emily’s channel comprises both private and public videos, and she was interested in counting views only for her public ones.</p>
			<p>Steve wrote a program in which the primary method of counting views looked like this:</p>
			<pre class="source-code">
string GetPublicVideosViewsMessage(IEnumerable&lt;Video&gt; videos)
{
     int totalPublicViews = 0;
     foreach (Video video in videos)
     {
          if (video.IsPublic)
          {
               totalPublicViews += video.Views;
          }
     }
     return $"Public videos have {totalPublicViews} views";
}</pre>			<p>Then, Steve thought he should use this chance to get better at using the functional approach and <a id="_idIndexMarker066"/>expressions instead of statements. So, he<a id="_idIndexMarker067"/> made changes to his code using expressions and LINQ methods to make the code clearer and shorter. Now the new version looks like this:</p>
			<pre class="source-code">
string GetPublicVideosViewsMessage(IEnumerable&lt;Video&gt; videos)
{
     var totalPublicViews = videos
               .Where(v =&gt; v.IsPublic)
               .Sum(v =&gt; v.Views);
     return $"Public videos have {totalPublicViews} views";
}</pre>			<p>Here’s what we changed:</p>
			<ul>
				<li>The <code>if</code> statement has been replaced with the <code>Where</code> method. This method filters out the elements that do not satisfy a certain condition – in this case, where <code>v.IsPublic</code> is <code>false</code>.</li>
				<li>The loop that manually adds each video’s views to <code>totalPublicViews</code> has been replaced with the <code>Select</code> method. This method transforms each element – in this case, it takes each video (<code>v</code>) and transforms it into its view count (<code>v.Views</code>).</li>
				<li>Finally, the <code>Sum</code> method adds up the views from each of the public videos to get the total.</li>
			</ul>
			<p>By using LINQ methods and expressions, the resulting code is clearer, more declarative, and more concise. We can now see at a glance what the code does – calculate the total number of views <a id="_idIndexMarker068"/>for<a id="_idIndexMarker069"/> all public videos – rather than how it does it. This is the power of expressions in C# – they allow for cleane<a id="_idTextAnchor052"/>r, more human-readable code.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor053"/>Lambda expressions, expression-bodied members, and anonymous methods</h1>
			<p>Modern C# syntax offers a set of powerful tools for expressing complex functionality with elegance and brevity. Let’s take a closer look at these language features and how we can use them to make our code more functional,<a id="_idTextAnchor054"/> readable, and maintainable.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor055"/>What are lambda expressions?</h2>
			<p>Lambda expressions, denoted<a id="_idIndexMarker070"/> by the <code>=&gt;</code> symbol, are a succinct way to create anonymous functions. Most likely, you use them daily when working with LINQ and similar functional programming constructs.</p>
			<p>So, let’s look at the following example where we define a lambda to square a number:</p>
			<pre class="source-code">
Func&lt;Book, int&gt; getWordCount = book =&gt; book.PageCount * 250;</pre>			<p>This defines a lambda expression that takes an integer, <code>x</code>, and returns its square. We can then use this function like so:</p>
			<pre class="source-code">
int wordCount = getWordCount(book);</pre>			<p>Lambda expressions offer great flexibility in parameter types and return values. They can take multiple <a id="_idIndexMarker071"/>parameters, return complex objects, or even have no para<a id="_idTextAnchor056"/>meters or return value at all.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor057"/>Multiple parameters in lambda expressions</h2>
			<p>Of course, methods <a id="_idIndexMarker072"/>in C# can contain more than one parameter, and lambda expressions can do so as well. In LINQ, one of the easiest methods to demonstrate it is <code>SelectMany</code>:</p>
			<pre class="source-code">
List&lt;Publisher&gt; publishers = GetPublishers();
List&lt;Book&gt; books = GetBooks();
var publisherBookPairs = publishers.SelectMany(
    publisher =&gt; books.Where(book =&gt; book.PublisherId == publisher.Id),
    (publisher, book) =&gt; new { PublisherName = publisher.Name, BookTitle = book.Title }
);</pre>			<p>Here, in addition to the collection of books and the one-parameter lambda expression, <code>publisher =&gt; books.Where(book =&gt; book.PublisherId == publisher.Id)</code>, this method also takes a two-parameter lambda expression, <code>(publisher, book) =&gt; new { PublisherName = publisher.Name, BookTitle = book.Title }</code>. As you can see, we just need to add parenthesis <a id="_idTextAnchor058"/>to use any number of variables.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor059"/>Lambda expressions evolution</h2>
			<p>Being a teacher in <a id="_idIndexMarker073"/>online C# courses, I like to illustrate the “evolution” of lambda expressions to my students. The first thing you need to know here is that this type of expression is just syntactic sugar over methods. Let’s look at this example:</p>
			<pre class="source-code">
bool IsBookPopular(Book book)
{
     if (book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000)
     {
          return true;
     }
     return false;
}</pre>			<p>This method calculates whether a book is popular or not and is written in an imperative way (tells how to do things, not what to do). To make it smaller, we can replace <code>if</code> with <code>return</code>:</p>
			<pre class="source-code">
bool IsBookPopular(Book book)
{
     return book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000;
}</pre>			<p>To make it even<a id="_idIndexMarker074"/> shorter, let’s use expression-bodied member syntax:</p>
			<pre class="source-code">
bool IsBookPopular(Book book) =&gt; book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000;</pre>			<p>If we try to use the same conditions in the LINQ <code>Where</code> function, it will look like this:</p>
			<pre class="source-code">
books.Where(book =&gt; book.AverageRating &gt; 4.5 &amp;&amp; book.NumberOfReviews &gt; 1000)</pre>			<p>Do you see the similarities? This is basically one and the same, so we can use our function in the <code>Where</code> method:</p>
			<pre class="source-code">
books.Where(book =&gt; IsBookPopular(book))</pre>			<p>Here is another example:</p>
			<pre class="source-code">
books.Where(IsBookPopular)</pre>			<p>This happens because <code>Where</code> takes a <code>Func&lt;T, bool&gt;</code> type as its parameter, which is basically what our lambda expression is.</p>
			<p>And now let me tell you that the example that we used to understand “lambda expressions evolution” is actually not a lambda expression. Lambda expressions are a syntactic sugar for <a id="_idIndexMarker075"/>anonymous methods, and we used an expression-bodied member here. So, let’s dig deeper and understand<a id="_idTextAnchor060"/> the difference between those two.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor061"/>Understanding anonymous methods</h2>
			<p>Anonymous methods, as the <a id="_idIndexMarker076"/>name suggests, are methods without a name. This ability to write unnamed methods right at the place where they are used, especially as arguments to other methods, is a significant feature of functional programming languages. Here is an interesting fact: anonymous methods are one of the oldest features of C#; they were introduced with version 2.0.</p>
			<p>Here is a simple example:</p>
			<pre class="source-code">
List&lt;Video&gt; videos = GetVideos();
videos.ForEach(delegate(Video video)
     {
         Console.WriteLine($"{video.Title}: {video.Views} views");
     });</pre>			<p>In this example, <code>delegate(Video video){...}</code> is an anonymous method, and as you can see, it is used directly as<a id="_idTextAnchor062"/> an argument to the <code>ForEach</code> method.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor063"/>How do anonymous methods work?</h2>
			<p>Anonymous methods <a id="_idIndexMarker077"/>work by generating a hidden method at compile time. The compiler generates a unique name for the method that isn’t valid in the context of C# naming rules, ensuring no possi<a id="_idTextAnchor064"/>ble conflict with your method names.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor065"/>When to use anonymous methods</h2>
			<p>The use of anonymous<a id="_idIndexMarker078"/> methods is particularly suitable when the logic of the method doesn’t justify a full method declaration. If the code is short, easily understandable, and used only in one place, an anonymous method is a good choice.</p>
			<p>The most common scenarios for using anonymous methods include the following:</p>
			<ul>
				<li><strong class="bold">Working with LINQ</strong>: LINQ heavily relies on delegates and anonymous methods, especially when filtering, ordering, or projecting data</li>
				<li><strong class="bold">Event handling</strong>: Anonymous methods can be used when attaching events, especially when the event handling code is simple</li>
				<li><strong class="bold">Asynchronous programming</strong>: Tasks an<a id="_idTextAnchor066"/>d threads often use anonymous methods</li>
			</ul>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor067"/>Practical examples – applying these features in real code</h2>
			<p>Another day on the street, Steve met his old friend Konstatos, founder of a small game studio that develops mobile games. Konstatos said that he wanted to analyze the behavior of a group of players<a id="_idIndexMarker079"/> he called “new whales.” Usually, people who spend much more money than others on something are <a id="_idIndexMarker080"/>called “whales.” So, he needed to get this subset of players using two conditions: firstly, they must have been registered in a game not earlier than a year ago, and secondly, they must <a id="_idTextAnchor068"/>have spent at least $10,000 since then.</p>
			<p>Steve happily agreed, and now, having practiced a lot on previous tasks, he came up with this functional solution:</p>
			<pre class="source-code">
List&lt;string&gt; GetWhales(IEnumerable&lt;Player&gt; players, DateTime date, decimal minSpend)
{
     return players
     .Where(p =&gt; p.JoinDate &gt; date)
     .Where(p =&gt; p.Spend &gt; minSpend)
     .Select(p =&gt; p.Nickname)
     .ToList();
}</pre>			<p>Pay attention that the condition is broken down into<a id="_idIndexMarker081"/> two <code>Where</code> methods. You could do it with just one <code>Where</code> method:</p>
			<pre class="source-code">
List&lt;string&gt; GetWhales(IEnumerable&lt;Player&gt; players, DateTime date, decimal minSpend)
{
     return players
     .Where(p =&gt; p.JoinDate &gt; date &amp;&amp; p.Spend &gt; minSpend)
     .Select(p =&gt; p.Nickname)
     .ToList();
}</pre>			<p>However, the cognitive load for <code>Where</code> with two conditions inside is greater, which is why the first approach is preferred. Plus, the first method reduces the number of affected lines when making further code changes, it’s easier to expand (you simply add new <code>Where</code> methods on new lines), and it causes fewer merge conflicts.</p>
			<p>Okay, so now that we have seen anonymous methods, <a id="_idTextAnchor069"/>let’s look at expression-bodied members.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor070"/>Expression-bodied members</h2>
			<p>Expression-bodied<a id="_idIndexMarker082"/> members are a syntax shortcut that allows methods, properties, and other members to be defined using a lambda-like syntax, where the body of the member is defined by a single expression following the <code>=&gt;</code> operator.</p>
			<p>Consider the following traditional method for calculating royalty:</p>
			<pre class="source-code">
public int CalculateRoyalty(Book book)
{
    if(book.CopiesSold &lt; 10000)
    {
        return book.CopiesSold * 0.2;
    }
    else
    {
        return book.CopiesSold * 0.3;
    }
}</pre>			<p>Now, let’s turn this into an expression-bodied member:</p>
			<pre class="source-code">
public int CalculateRoyalty(Book book) =&gt;
    book.CopiesSold &lt; 10000
       ? book.CopiesSold * 2
       : book.CopiesSold * 3;</pre>			<p>We’ve condensed our method to a one-liner (a piece of functionality written in a single line), concise line. The improved brevity enhances readability, especially for simple methods and properties. It is important to remember that it is not obligatory for the code to use expression-bodied members to be considered functional style. In my work, I stick to the rule that only single-line expression-bodied members can exist. If the method body starts to contain two or more lines, it is better to have fewer merge conflicts and readability to use a regular syntax for methods.</p>
			<p>In the next section, we<a id="_idIndexMarker083"/> will tackle the powerful concept of expression trees and uncover their utility in C#. But first, take some time to absorb these concepts and see how you can use them <a id="_idTextAnchor071"/>to write more expressive and concise code.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor072"/>Exercise – implementing lambda expressions and anonymous methods</h2>
			<p>In order for you to <a id="_idIndexMarker084"/>have more practice with a functional <a id="_idIndexMarker085"/>approach, here is a challenge to refactor the following code using expression-bodied members, lambda expressions, and anonymous methods:</p>
			<pre class="source-code">
public bool IsVideoTrending(Video video)
{
     int viewThreshold = CalculateViewThreshold(video.UploadDate);
     return video.Views &gt; viewThreshold;
}
private int CalculateViewThreshold(DateTime uploadDate)
{
     int daysOld = (DateTime.Now - uploadDate).Days;
     return 1000 * daysOld;
}</pre>			<p>While it is quite an<a id="_idIndexMarker086"/> easy task, it can help us to clarify the difference <a id="_idIndexMarker087"/>between standard methods and lambda expression<a id="_idTextAnchor073"/>s, making our code in a more functional style.</p>
			<h1 id="_idParaDest-51">Expression trees and how to<a id="_idTextAnchor074"/> use them to manipulate expressions at runtime</h1>
			<p>Expression trees <a id="_idIndexMarker088"/>offer a unique capability in C#: the ability to treat code as data<a id="_idIndexMarker089"/> and manipulate it at runtime. They are central to the functionality of LINQ, allowing us to use the same query syntax for in-memory objects and external data sources. Let’s explore this fascinating feature. At a high level, an expression tree is a data structure that represents some code in a tree-like format, where each node is an expression. Expression trees are constructed from lambda expressions and allow you to inspect the code within the lambda as data.</p>
			<p>To illustrate this, consider a simple lambda expression:</p>
			<pre class="source-code">
Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b;</pre>			<p>Now, let’s rewrite it as a binary expression:</p>
			<pre class="source-code">
ParameterExpression a = Expression.Parameter(typeof(int), "a");
ParameterExpression b = Expression.Parameter(typeof(int), "b");
ParameterExpression c = Expression.Parameter(typeof(int), "c");
BinaryExpression addExpression = Expression.Add(a, b);</pre>			<p>The difference <a id="_idIndexMarker090"/>might be not significant in code, but let’s look at the inner<a id="_idIndexMarker091"/> representation of our variables. Here is our <code>add</code>:</p>
			<div><div><img src="img/B21069_02_001.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>As you can see, it has only two fields: <code>Target</code>, the class in which this method is, and the <code>Method</code> field, with the method’s information. Not that much to look at. Now, let’s look at <code>addExpression</code>:</p>
			<div><div><img src="img/B21069_02_002.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>As you can see, the<a id="_idIndexMarker092"/> expression <a id="_idIndexMarker093"/>has <code>NodeType</code> as <code>Add</code> and two parts: <code>Left</code> and <code>Right</code>. Visually, it can be represented like this:</p>
			<div><div><img src="img/B21069_02_003.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Not scary at all, <a id="_idTextAnchor075"/>right? If so, let’s move on to expression trees.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor076"/>Building and manipulating expression trees</h2>
			<p>Building an expression tree manually provides a deeper understanding of its structure. Let’s recreate our addition expression:</p>
			<pre class="source-code">
// Define parameters
ParameterExpression a = Expression.Parameter(typeof(int), "a");
ParameterExpression b = Expression.Parameter(typeof(int), "b");
// Define body
BinaryExpression body = Expression.Add(a, b);
// Combine them
Expression&lt;Func&lt;int, int, int&gt;&gt; addExpression = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(body, a, b);</pre>			<p>This code creates<a id="_idIndexMarker094"/> the <a id="_idIndexMarker095"/>same expression tree as before but shows the structure more clearly. The lambda is formed from a body, <code>(a + b)</code>, and a list of parameters, <code>(</code><code>a, b)</code>:</p>
			<div><div><img src="img/B21069_02_004.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Now, our <a id="_idIndexMarker096"/>expression<a id="_idIndexMarker097"/> tree has two main branches, <code>Body</code> and <code>Parameters</code>:</p>
			<div><div><img src="img/B21069_02_005.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>That looks more <a id="_idIndexMarker098"/>like a <a id="_idIndexMarker099"/>tree to me. However, it has only one operation in it and real expression trees usually contain multiple operations. Let’s add a multiplication operation:</p>
			<pre class="source-code">
// Define parameters
ParameterExpression a = Expression.Parameter(typeof(int), "a");
ParameterExpression b = Expression.Parameter(typeof(int), "b");
ParameterExpression c = Expression.Parameter(typeof(int), "c");
// Define bodies for addition and multiplication
BinaryExpression addBody = Expression.Add(a, b);
BinaryExpression multiplyBody = Expression.Multiply(addBody, c);
// Combine them
Expression&lt;Func&lt;int, int, int, int&gt;&gt; combinedExpression = Expression.Lambda&lt;Func&lt;int, int, int, int&gt;&gt;(multiplyBody, a, b, c);</pre>			<p>This example is <a id="_idIndexMarker100"/>much<a id="_idIndexMarker101"/> more interesting, and its inner representation is bigger:</p>
			<div><div><img src="img/B21069_02_006.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>And this is what our modified visual tree looks like:</p>
			<div><div><img src="img/B21069_02_007.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>I hope that now<a id="_idIndexMarker102"/> you<a id="_idIndexMarker103"/> have a better understanding of what an expression tree looks like. This <a id="_idTextAnchor077"/>will help us to move forward to a more complex example.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor078"/>Creating and manipulating complex expression trees</h2>
			<p>The other day, Irene <a id="_idIndexMarker104"/>asked Steve to meet her publisher. It appeared<a id="_idIndexMarker105"/> that the publisher wanted a program to easily filter popular books. Steve gladly agreed and created the advanced filter as an expression tree for their system.</p>
			<p>The filter checks whether a book’s title contains a specific keyword, whether its number of pages is more than a particular limit, and whether its rating is above a certain threshold. Therefore, the expression tree has three different expressions:</p>
			<pre class="source-code">
// Define parameters
ParameterExpression book = Expression.Parameter(typeof(Book), "book");
ParameterExpression keyword = Expression.Parameter(typeof(string), "keyword");
ParameterExpression minPages = Expression.Parameter(typeof(int), "minPages");
ParameterExpression minRating = Expression.Parameter(typeof(double), "minRating");
// Define body
MethodCallExpression titleContainsKeyword = Expression.Call(
    Expression.Property(book, nameof(Book.Title)),
    typeof(string).GetMethod("Contains", new[] { typeof(string) }),
    keyword
);
BinaryExpression pagesGreaterThanMinPages = Expression.GreaterThan(
    Expression.Property(book, nameof(Book.Pages)),
    minPages
);
BinaryExpression ratingGreaterThanMinRating = Expression.GreaterThan(
    Expression.Property(book, nameof(Book.Rating)),
    minRating
);
// Combine expressions with 'AND' logical operator
BinaryExpression andExpression = Expression.AndAlso(
    Expression.AndAlso(titleContainsKeyword, pagesGreaterThanMinPages),
    ratingGreaterThanMinRating
);
// Combine parameters and body into a lambda expression
Expression&lt;Func&lt;Book, string, int, double, bool&gt;&gt; filterExpression = Expression.Lambda&lt;Func&lt;Book, string, int, double, bool&gt;&gt;(
    andExpression,
    book, keyword, minPages, minRating
);</pre>			<p>The only thing they need to do in their publishing system is to use <code>filterExpression</code> to create a delegate for filtering books and use it:</p>
			<pre class="source-code">
var filter = filterExpression.Compile();
var popularBooks = books
    .Where(book =&gt; filter(book, keyword, minPages, minRating))
    .ToList();</pre>			<p>The real power of expression trees comes from their ability to be manipulated at runtime. You can <a id="_idIndexMarker106"/>dynamically build, modify, or even compile and run<a id="_idIndexMarker107"/> expression trees. This is a powerful tool for runtime code generation and provides th<a id="_idTextAnchor079"/>e basis for technologies such as LINQ and Entity Framework.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor080"/>Querying data with expression trees – LINQ and beyond</h2>
			<p>LINQ uses <a id="_idIndexMarker108"/>expression<a id="_idIndexMarker109"/> trees under the hood to enable the same <a id="_idIndexMarker110"/>query syntax for different types of data. When you write a LINQ query against an <code>IQueryable&lt;T&gt;</code>, you’re actually building an expression tree. This tree is then passed to the query provider, which translates it into the appropriate format (such as SQL for a database).</p>
			<p>Here’s an example of a LINQ query that gets translated into SQL by Entity Framework (a popular tool to work with databases in C#):</p>
			<pre class="source-code">
var youngCustomers = dbContext.Customers
    .Where(c =&gt; c.Age &lt; 30)
    .Select(c =&gt; new { c.Name, c.Age });</pre>			<p>When this query is run, Entity Framework generates an expression tree, converts it into SQL, sends it to<a id="_idTextAnchor081"/> the <a id="_idIndexMarker111"/>database, and materializes the<a id="_idIndexMarker112"/> results back into objects.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor082"/>Guided exercise – constructing and manipulating expression trees</h1>
			<p>To help you<a id="_idIndexMarker113"/> understand expression trees better, let’s look at this <a id="_idIndexMarker114"/>exercise. Our goal is to create an expression tree representing the lambda expression <code>(x, y) =&gt; x * y</code>. This represents a multiplication operation. Afterward, we’ll compile and invoke this expression, effectively performing the multiplication of two numbers.</p>
			<p>Let’s break down the steps:</p>
			<ol>
				<li>Define the parameters for the lambda expression. These are <code>x</code> and <code>y</code>, which are both of the <code>int</code> type:<pre class="source-code">
ParameterExpression x = Expression.Parameter(typeof(int), "x");
ParameterExpression y = Expression.Parameter(typeof(int), "y");</pre></li>				<li>Construct the body of the lambda expression. This is the <code>x * </code><code>y</code> operation:<pre class="source-code">
BinaryExpression body = Expression.Multiply(x, y);</pre></li>				<li>Now, we combine the parameters and the body into a lambda expression:<pre class="source-code">
Expression&lt;Func&lt;int, int, int&gt;&gt; multiplyExpression = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(body, x, y);</pre></li>				<li>Now that we have our expression tree, we can compile it into a delegate:<pre class="source-code">
Func&lt;int, int, int&gt; multiply = multiplyExpression.Compile();</pre></li>				<li>Invoke the delegate with two numbers:<pre class="source-code">
int result = multiply(6, 7); // This returns 42</pre></li>			</ol>
			<p>Awesome! We have successfully created an expression tree that represents a lambda expression, compiled it, and invoked it. This is a fundamental step in understanding how expression trees in C# allow us to use code as data, opening up powerful, dynamic programming possibilities.</p>
			<p>Keep practicing these steps with different lambda expressions. Mastery of expression trees lets you<a id="_idIndexMarker115"/> harness the full potential of C#, giving you capabilities<a id="_idIndexMarker116"/> such as dynamic code generation and manipulation, advance<a id="_idTextAnchor083"/>d querying abilities, and much more. Keep at it, you’re doing great!</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor084"/>Problem sets and exercises</h1>
			<p>After reading<a id="_idIndexMarker117"/> about <a id="_idIndexMarker118"/>expressions<a id="_idIndexMarker119"/> and<a id="_idIndexMarker120"/> statements, lambda expressions, and expression trees, Steve wrote an email to Julia, asking for the best way to get more hands-on experience. Julia congratulated Steve and sent him the list with five points that from her understanding every person trying to learn this topic should do:</p>
			<ol>
				<li><code>IEnumerable&lt;T&gt;</code> and a predicate in the form of an expression tree and returns the filtered results. Use it to filter a list of strings based on their length.</li>
				<li><strong class="bold">Refactor a class</strong> with traditional methods into a version using expression-bodied members where appropriate. Compare the two versions.</li>
				<li><strong class="bold">Write an application</strong> that takes a mathematical expression as a string at runtime, converts it into an expression tree, and evaluates it. The application should support operations such as addition, subtraction, multiplication, and division.</li>
				<li><strong class="bold">Design a mini query language</strong> for querying in-memory objects. This language should support basic operations such as filtering and sorting. Use expression trees to implement it.</li>
				<li><strong class="bold">Code review a project</strong>. Find an open source project on GitHub that uses C#, and examine the code to identify where these features (expression-bodied members, lambda expressions, and anonymous methods) are used. Analyze how they contribute <a id="_idIndexMarker121"/>to<a id="_idIndexMarker122"/> the<a id="_idIndexMarker123"/> code’s <a id="_idIndexMarker124"/>readability and maintainability.</li>
			</ol>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor085"/>Exercises</h1>
			<p>In this section, you will help Steve to develop and refactor his tower defense game in a functional programming way.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor086"/>Exercise 1</h2>
			<p>Name and count all expressions and all statements in the code snippet below:</p>
			<pre class="source-code">
Tower mainTower = new(position: new Vector2(5, 5));
for (int level = 1; level &lt;= mainTower.MaxLevel; level++)
{
     double upgradeCost = 100 * Math.Pow(1.5, level - 1);
     Console.WriteLine($"Upgrading to level {level} costs {upgradeCost} gold");
     if (playerGold &gt;= upgradeCost)
     {
                  mainTower.Upgrade();
                  playerGold -= upgradeCost;
     }
}</pre>			<h2 id="_idParaDest-59"><a id="_idTextAnchor087"/>Exercise 2</h2>
			<p>Refactor the code below to use expressions instead of statements</p>
			<pre class="source-code">
string GetTowerDamageReport(IEnumerable&lt;Tower&gt; towers)
{
      int totalDamage = 0;
      foreach (Tower tower in towers)
      {
           if (tower.IsActive)
           {
                totalDamage += tower.Damage;
           }
      }
      return $"Active towers deal {totalDamage} total damage";
}</pre>			<h2 id="_idParaDest-60"><a id="_idTextAnchor088"/>Exercise 3</h2>
			<p>Create an expression tree that is the lambda expression, <code>(x, y) =&gt; x * y</code>. Then, compile and invoke it to multiply two numbers.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor089"/>Solutions</h1>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor090"/>Exercise 1</h2>
			<pre class="source-code">
Tower mainTower = new(position: new Vector2(5, 5));
for (int level = 1; level &lt;= mainTower.MaxLevel; level++)
{
     double upgradeCost = 100 * Math.Pow(1.5, level - 1);
     Console.WriteLine($"Upgrading to level {level} costs {upgradeCost} gold");
     if (playerGold &gt;= upgradeCost)
     {
                  mainTower.Upgrade();
                  playerGold -= upgradeCost;
     }
}</pre>			<p>Expressions:</p>
			<ul>
				<li><code>new </code><code>Vector2(5, 5)</code></li>
				<li><code>5 (x-coordinate)</code></li>
				<li><code>5 (y-coordinate)</code></li>
				<li><code>new(position: new </code><code>Vector2(5, 5))</code></li>
				<li><code>1</code></li>
				<li><code>level</code></li>
				<li><code>mainTower.MaxLevel</code></li>
				<li><code>level &lt;= </code><code>mainTower.MaxLevel</code></li>
				<li><code>level++</code></li>
				<li><code>100</code></li>
				<li><code>1.5</code></li>
				<li><code>1</code></li>
				<li><code>level - 1</code></li>
				<li><code>Math.Pow(1.5, level - </code><code>1)</code></li>
				<li><code>100 * Math.Pow(1.5, level - </code><code>1)</code></li>
				<li><code>level (in </code><code>string interpolation)</code></li>
				<li><code>upgradeCost (in </code><code>string interpolation)</code></li>
				<li><code>$"Upgrading to level {level} costs {</code><code>upgradeCost} gold"</code></li>
				<li><code>playerGold</code></li>
				<li><code>upgradeCost</code></li>
				<li><code>playerGold &gt;= </code><code>upgradeCost</code></li>
				<li><code>upgradeCost (</code><code>in subtraction)</code></li>
			</ul>
			<p>Statements:</p>
			<ul>
				<li><code>Tower mainTower = new(position: new </code><code>Vector2(5, 5));</code></li>
				<li><code>for (int level = 1; level &lt;= </code><code>mainTower.MaxLevel; level++)</code></li>
				<li><code>double upgradeCost = 100 * Math.Pow(1.5, level - </code><code>1);</code></li>
				<li><code>Console.WriteLine($"Upgrading to level {level} costs {</code><code>upgradeCost} gold");</code></li>
				<li><code>if (playerGold &gt;= </code><code>upgradeCost)</code></li>
				<li><code>mainTower.Upgrade();</code></li>
				<li><code>playerGold -= </code><code>upgradeCost;</code></li>
			</ul>
			<p>Total: 22 expressions and 7 statements</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor091"/>Exercise 2</h2>
			<pre class="source-code">
string GetTowerDamageReport(IEnumerable&lt;Tower&gt; towers) =&gt;
     $"Active towers deal {towers.Where(t =&gt; t.IsActive).Sum(t =&gt; t.Damage)} total damage";</pre>			<p>This refactored version uses LINQ expressions to filter active towers and sum their damage in a single line, eliminating the need for explicit loops and conditional statements.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor092"/>Exercise 3</h2>
			<pre class="source-code">
ParameterExpression baseDamage = Expression.Parameter(typeof(int), "baseDamage");
ParameterExpression level = Expression.Parameter(typeof(int), "level");
BinaryExpression multiply = Expression.Multiply(baseDamage, level);
Expression&lt;Func&lt;int, int, int&gt;&gt; damageCalc = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(multiply, baseDamage, level);
// Compile the expression
Func&lt;int, int, int&gt; calculateDamage = damageCalc.Compile();
// Calculate tower damage
int towerDamage = calculateDamage(10, 5);
Console.WriteLine($"Tower damage: {towerDamage}");</pre>			<p>This solution creates an expression tree representing <code>(baseDamage, level) =&gt; baseDamage * level</code>, compiles it into a function, and then invokes that functio<a id="_idTextAnchor093"/>n to calculate a tower’s damage based on its base damage (10) and level (5).</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor094"/>Summary</h1>
			<p>In this chapter, we dove into functional programming in C#, focusing on expressions and statements, and the powerful tools that C# provides to elevate your code. Let’s summarize the key takeaways:</p>
			<ul>
				<li>We learned the difference between expressions and statements. Functional programming often prefers expressions for their simple and direct style.</li>
				<li>We looked at expression-bodied members, which give a shorter and cleaner way to write methods and properties.</li>
				<li>We studied lambda expressions and anonymous methods. Both help in writing clear, brief, and contained code.</li>
				<li>We touched on expression trees, a special feature in C# that lets us handle code-like data. This is useful for things such as data queries in LINQ.</li>
			</ul>
			<p>Throughout, our goal was to understand not just how to use these tools but also why and when they’re helpful.</p>
			<p>Next, we’ll learn about pure functions, what makes a method “pure,” and what side effects mean.</p>
		</div>
	</body></html>