- en: Setting Up a JavaScript Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explore setting up your JavaScript development environment
    with examples in pure JavaScript and React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will gain an understanding of:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Installing your IDE
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up your testing framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first tests in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js, commonly called Node, is practically a requirement for doing modern
    web application development. In this section, we will discuss what Node is exactly,
    provide reasons why you need Node, and, finally, talk about where you can get
    Node installation instructions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with these subjects, then feel free to jump to the
    next section, where we discuss NPM in a similar fashion.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: What is Node?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node was created in late 2009 by Ryan Dahl. Based on Chrome's V8 engine, Node
    provides a JavaScript runtime built for the purpose of providing evented, non-blocking
    I/O (input/output) for serving web applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: At the time, Chrome had created the fastest JavaScript engine available. At
    the same time, they had decided to open-source the code for it. For these two
    extremely compelling reasons, Node decided to use the V8 engine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Ryan Dahl was unhappy with the performance, at the time, of the very popular
    Apache HTTP server. One of the problems with the way that Apache was handling
    concurrent connections was that it was creating a new thread for each connection.
    Task creation and task switching between these threads are both CPU-and memory-intensive.
    For these reasons, instead of using threads for concurrent connections, Dahl decided
    to write Node with the intent of using an event loop coupled with a callback paradigm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need Node?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform TDD in JavaScript for a modern web application, we absolutely need
    Node. When writing a modern web application, you will very likely be using one
    of these popular frameworks: ReactJS, Angular, Ember.js, Vue.js, or Polymer. The
    majority of these applications require a compilation step in Node.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for using Node is that we want to take advantage of new features
    in JavaScript. Node doesn’t support these features itself, but libraries have
    been written that will allow you to transpile the newer versions of JavaScript,
    ECMAScript 2015+, into a version of JavaScript that is supported by your target
    browsers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, for the purposes of this book, we need Node so that we can run our tests.
    Later, we will discuss how we can also run our tests continuously while we are
    writing our code. This is known as continuous testing and is a must-have for rapid
    development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several options for installing Node on your machine. We will cover
    installing manually and installing from a package management repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using a package management repository are many. The main reason
    that you would want to install this way would be the benefit of version management.
    Node updates versions frequently, and using a package manager can help to notify
    you of available updates. It can also help install those updates in a simple and
    efficient manner. We will start with a manual install, followed by installing
    using a Linux package manager, a Mac OSX package manager, and finally a Windows
    package manager.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: To install Node manually, open your favorite browser and go to [http://nodejs.org](http://nodejs.org).
    You should see something similar to the following screenshot. Regardless of your
    operating system, the Node website will have a download link for both current
    and **Long Term Support** (**LTS**) versions of Node installation files. For Windows
    and Mac, the Node website provides installers. For Linux, Node provides binaries
    and source code. Assuming you are familiar with your operating system, the installation
    process is fairly straightforward and shouldn't present any issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: Package managers greatly simplify the installation of many applications. If
    you are unfamiliar with package managers in general, they are based on the concept
    of having a repository of applications and tools that are available for installation
    on the system the package manager is for. Almost every system available has a
    package manager for it now. Linux has a different package manager for many distributions.
    Mac uses a system called *Homebrew, *and Windows has a package manager named *Chocolatey*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will cover using the Ubuntu package manager, called `apt`, as Ubuntu
    is one of the most popular Linux systems. If you are using a different distribution,
    the process should be very similar. The only difference is the name of your package
    manager. Open a terminal window and enter the following commands to install Node
    for Ubuntu:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's that simple; now the latest version of Node is installed and ready for
    you to begin using. These same commands will update Node when a new version is
    available.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Mac OSX
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mac doesn''t come with a package manager preinstalled. To install Homebrew,
    you must open a Terminal and execute the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that you have Homebrew installed, you also have one more requirement that
    you must fulfill. You must install Apple''s Xcode, which can be found by searching
    the App Store. Just like any other application on a Mac, once you have found it,
    just click the Install application button, and Xcode will download and install:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have both prerequisites for Node installed on the system, installation
    is extremely simple. From a Terminal window, execute the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Updating Node is also just as simple. Occasionally, when you want to update,
    execute the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You now have the latest version of Node installed on your Mac.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows also has a package manager. Just like Mac, the Windows package manager
    does not come preinstalled. The package manager for Windows is named Chocolatey
    and can be found at [https://chocolatey.org](https://chocolatey.org):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'To install Chocolatey, open a Command Prompt (`cmd.exe`) as administrator and
    execute the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the Chocolatey installation has finished, you may need to restart the
    command window before you can use it. Restart the Command Prompt as an administrator,
    and then execute the following commands to install Node on windows using the Chocolatey
    package manager:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you've executed the first command, you will be prompted to execute a script.
    You will need to agree to run the script to install Node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To upgrade Node using Chocolatey, execute the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may need to agree to run the installation script. If prompted, simply hit
    the *Y* key and press *Enter*. You now have the latest version of Node.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: NPM
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NPM is a critical piece of the Node environment and community. Without NPM,
    Node would not have taken off quite like it has. In this section, we will discuss
    what NPM is, what NPM isn't, why you need NPM for doing Node development, and
    finally, where you can get NPM and how to install it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: What is NPM?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially released in early 2010, **NPM** (**Node Package Manager**). NPM was
    written by Isaac Z. Schlueter, and is now maintained by a team of developers.
    Although NPM has Node in the acronym, it can also be used to manage packages for
    the browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In the past few years, many package managers were created specifically for browser
    packages. One of the most prominent is *Bower*. These secondary package managers
    were created because NPM was perceived as a package manager best suited for, or
    perhaps only suited for, managing Node packages. This belief has subsided; however,
    Bower’s own website now suggests that it not be used.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need NPM?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you do need to install NPM, you don't necessarily have to use it. In late
    2016, Facebook released an alternative package manager named *Yarn*, which uses
    the NPM registry, so all of your favorite packages are available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: There are likely other package management alternatives to NPM as well. These
    alternative package managers are important because they drive improvements in
    NPM, but ultimately, they will likely fade and NPM will continue to be the preferred
    package manager for Node, and for JavaScript in general. If you do decide to use
    an alternative package manager such as Yarn, you will need to install it using
    NPM.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Installing NPM?
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Good news; you already have NPM installed if you have gone through the process
    of installing Node. You may occasionally want to upgrade NPM outside Node''s release
    cycle. To attempt an upgrade, simply open your operating system''s preferred console
    or Terminal window and execute the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: NPM is just another executable on your computer. It takes a list of arguments
    or parameters. In this case, we are asking NPM to install a package. The second
    argument, `-g`, tells NPM that we want to install the requested package globally.
    Lastly, the package we are asking NPM to install is NPM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to JavaScript IDEs
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you don't need an **IDE** (**Integrated Development Environment**) per
    se, you will need a text editor. Why not have a text editor that does a little
    bit of the heavy lifting for you? There are, essentially, two types of IDEs available
    for JavaScript development. The first kind is really more of a text editor than
    anything else, whereas the second kind is a full-blown editor with compiling and
    source control built in.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: While you can work on JavaScript with only a simple text editor and a console/Terminal
    window, we recommend using something with at least a little more power.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code, as described in the C# section, is a lightweight editor
    based on the Electron framework and developed in TypeScript, a language designed
    by Microsoft to extend JavaScript with static types. TypeScript compiles to JavaScript,
    so ultimately Visual Studio Code is a JavaScript application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Why Visual Studio Code?
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For working with JavaScript, there are several reasons why you might choose
    Visual Studio Code or one of the other Electron-based editors. VSCode is lightweight,
    has an extensive plugin architecture, is integrated with source control, and is
    very easy to set up and use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio Code
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing VSCode is extremely simple. If you have already followed along in
    the *C#* section, then you likely have VSCode installed already. If not, here
    are some alternative ways to install it that were not discussed there.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install on Linux (again, this is an example for Ubuntu), simply execute
    the following commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Mac
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, I don't have a fancy command-line way to install  VSCode on a
    Mac. Instead, go to the Visual Studio Code homepage at [https://code.visualstudio.com](https://code.visualstudio.com) and
    follow the installation instructions there.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Windows, just like with Node, we can install VSCode using Chocolatey. To
    install using Chocolatey ([https://chocolatey.org/install](https://chocolatey.org/install)),
    execute the following command in a console window. Remember, you may want to run
    the console as an administrator:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Installing the plugins you will need
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two plugins that we would recommend getting are `npm` and `npm-intellisense`
    because they will aid in the flow and provide hints when you are not 100% sure
    that you are using the correct package name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the testing environment
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code offers built-in test running capabilities. We are not going
    to choose those options for JavaScript development, however. For the purposes
    of test driving our application and demonstrating our approach to testing, we
    think using the available Terminal inside VSCode will be more appropriate and
    better suited to the flow that will be used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: WebStorm
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebStorm is a full-blown IDE written by JetBrains in Java.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Why WebStorm?
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebStorm basically comes with everything you need to develop a JavaScript-based
    application. It also supports many of the JavaScript ecosystem alternatives to
    JavaScript, such as TypeScript, Flow, and React JSX. WebStorm also integrates
    seamlessly with many code-quality tools such as ESLine, TSLint, and JSHint.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The only downside to WebStorm is that it does cost money. But, when you look
    at it, a paid product is actually a good thing. The company making the paid product
    has a good reason to continue maintaining it. JetBrains offers the purchase of
    WebStorm through a single purchase or through a subscription. We suggest the subscription,
    as the upfront cost to you is minimized and JetBrains has more motivation to keep
    you happy this way.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Installing WebStorm
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install WebStorm, we are going to use a newer program created by JetBrains
    called *The JetBrains Toolbox App*. The Toolbox App is designed to track version
    updates and provide a common launching point for all JetBrains products. Once
    installed, it becomes very easy to install any of the JetBrains tools.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There does not appear to be, at the time of writing, a way to install ToolBox
    or WebStorm from `apt-get`*.* So, we will have to do it the hard way. Go to the
    ToolBox download page at [https://www.jetbrains.com/toolbox/app/](https://www.jetbrains.com/toolbox/app/) and
    download the Linux tarball. Then, open a Terminal to your download directory.
    Once there, execute the following commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Mac
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Mac, we can again use Homebrew for installation. Just execute the following
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Windows
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Windows, we are able to use Chocolatey to install Toolbox. Execute the following
    command and then launch the app:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our ultimate goal when installing the Toolbox was to install WebStorm. So, with
    the Toolbox open, either sign in if you have purchased any JetBrains products
    or skip the sign in if you just want to try them out. Next, find WebStorm in the
    products list and click the button to install it. Once the install has finished,
    you will be able to click a Launch button that will replace the Install button.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Installing the plugins you will need
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've got good news for plugins with WebStorm. WebStorm offers a great plugin
    community, with every plugin you could possibly want accessible through a plugin
    management system built into the application. For the purposes of this book, however,
    you don't actually need any. So, we are done installing plugins! In fact, if anything,
    WebStorm has too much functionality built in, and we will be ignoring or even
    turning off some of it so that we can work the way we want to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the testing environment
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as in Visual Studio Code, for WebStorm we are not going to cover setting
    up any of the built-in test running capability. WebStorm offers a Terminal display
    that can be turned on and supports having multiple contexts open at the same time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Create React App
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have Node and NPM installed and up-to-date, turn your attention
    to the application you want to test drive. Due to its constantly increasing popularity,
    we are choosing to explain and demonstrate Test-Driven Development by testing
    a React application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: According to the React website, React is *A JavaScript library for building
    user interfaces*. We are going to focus on using it for a front-end browser application,
    but it can be used to create mobile and desktop applications as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: React was created and is maintained by Facebook. React was created to solve
    issues that Facebook had in its own user interface, and it is now taking the internet
    by storm. Facebook has also created a library called Create React App to quickly
    get a React application going.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: What is Create React App?
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create React App is an NPM package created by Facebook for the purpose of providing
    a zero-configuration way to create a react application. React requires quite a
    lot to get started, and it can take days to configure a React application manually.
    Create React App can reduce that time to under a minute.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Installing the global module
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create React App has a global NPM package that must be installed before you
    can use the command-line utility to actually create a React application. To install
    the latest version of the Create React App global script, execute the following
    command in a console or Terminal window:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a React application
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the global module is installed, you will be ready to start using Create
    React App. Creating a React application is extremely streamlined and simple. On
    my system, I have a directory `\projects` that I use to house all my front-end
    application projects. Open a console/Terminal window to a similarly purposed directory
    on your machine and execute the following command to create a new React application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our case, the name of our test case is Speaker Meet, so as an example, my
    command is displayed as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: SpeakerMeet, as mentioned in the C# section, has both a back-end (the RESTful
    Web API) and a front-end (a React-based **SPA** (**Single Page Application**)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Running the Create React App script
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `create-react-app` script finishes running, a list of available commands
    is displayed. You want to make sure that everything was successfully created.
    You can launch the application by executing the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If everything installed correctly, your default browser will open and a new
    React application will be running.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Mocha and Chai
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create React App supports testing right out of the box. Initially, Create React
    App uses a testing library named Jest. We want to use Mocha and Chai due to their
    popularity in the JavaScript community.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Jest
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest is a testing framework written by Facebook. Just like Create React App,
    Jest is designed to be a zero-configuration tool. Jest also supports continuous
    testing and code coverage analysis.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Jest is designed to work within the common **BDD** (**behavior-driven development**)
    paradigms, as are many other JavaScript testing frameworks. As such, the testing
    functions `describe` and `it` can both be used to write your tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha is another JavaScript testing framework and is the one we would like to
    use. As for library interaction differences, there doesn't appear to be much different
    in terms of base interactions. The differences come down to the assertion library
    and the mocking library.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Mocking, which will be covered in detail in [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195), *What
    to Know Before Getting Started*, is essentially a way to provide alternative implementations
    of objects, classes, and functions, specifically to aid the testing process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Mocha itself doesn't come with an assertion library, so one must be provided.
    The assertion library is what controls test results and how to verify that your
    code is executing correctly. Most developers who use Mocha rely on Chai for assertions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, another consideration is what mocking library you want
    to use. For many Mocha users, that library is unquestionably *Sinon*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We will explain the purpose of any and all parts of Mocha that we use in this
    book. If you want to know more or want the documentation for quick reference while
    you are developing, you can go to the Mocha home page at [https://mochajs.org](https://mochajs.org).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocha can be installed into a JavaScript application using the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Chai
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chai is a BDD assertion library. Chai uses a fluent API to allow for extremely
    flexible assertions. The two most popular ways that Chai is used are through the *should* and *expect* interfaces
    provided. The way that Chai works, and in fact, the way that every testing frameworks
    assertion works, is by throwing an exception when the check done by the assertion
    fails.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you had a variable named `foo` with a value *3* and your assertion
    was `expect(foo).to.equal(5)` when the test ran, that assertion would throw an
    exception with a message that says `expected 3 to equal 5`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Chai into your project, run the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have Chai installed, there is one more step that must be taken to
    be able to use it within your project. You must include the following import at
    the top of each test file in your application:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you wish to use should assertions, you can either replace `expect` with `should` or
    add `should` inside the curly braces, separating it from `expect` with a comma.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: For more information or to refer to the documentation, the Chai home page is [https://chaijs.com](https://chaijs.com).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Sinon
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won't be getting into mocking until [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195),
    *What to Know Before Getting Started*, but Sinon is the generally preferred mocking
    library among Mocha + Chai users. Some testing frameworks, such as Jest and Jasmine,
    come with their own mocking library features, but Mocha does not, and Sinon provides
    an excellent mocking experience.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Sinon into your project, execute the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once installed, you will need to import Sinon before you can use it. Use the
    following import statement to enable the use of Sinon:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enzyme
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enzyme is a library designed to aid in the testing of React components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Enzyme into your project, execute the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The extra libraries listed, `react-test-renderer` and `react-dom`, are dependencies
    of Enzyme that it needs to function correctly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other testing utilities mentioned in this section, we will get
    into usage as needed, while we discuss the topics covered in this book. But here
    is a quick example of a test using Enzyme from the Enzyme documentation at [https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ejecting the React app
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, this is where we part company with Create React App. In order
    to use Mocha, we will need to find an alternative way to work with the application.
    Because of the zero-configuration setup of Create React App, we cannot simply
    update the testing framework being used, and that is a problem for us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Create React App gives us an out in the form of ejecting the application.
    Ejecting the React application will install all the necessary configuration files
    and utilities into our project and remove Create React App.  Once the ejection
    process is finished, we will have access to all the configuration files and we
    will have the ability to switch to using Mocha.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'To eject Create React App, execute the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you take a look at the `package.json` in the root of the project, you will
    see that a lot of information and configuration have been added.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: After any major modification to `package.json`, it is a good idea to delete
    `node_modules` and `package-lock.json` and then re-run `npm install`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Configuring to use Mocha and Chai
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have ejected the React app, before you make any further modifications,
    you should make sure everything still works. Execute the following command before
    making any further modifications:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now check that a browser launched and that the application is running correctly.
    You will have to *Ctrl* + *C* to exit the running process:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After this command, check that a build folder was created at the root of your
    project and that there were no errors displayed in the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even though you are about to change the test configuration, you will be using
    some of the libraries that were provided by Create React App. You want to make
    sure that those prerequisites transitioned properly when you ejected. As with `npm
    start`, you will have to *Ctrl* + *C* to exit this process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming all of the commands executed without issues, you can now start the
    process of switching the test environment over to Mocha. Execute the following
    command to ensure the installation of the necessary dependencies:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open `package.json` and update the following lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change the preceding code to:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will also need to install the BabelJS preset for ES2015:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, find and delete the `jest` setting in `package.json`. You are now ready
    to change the `test` script to execute Mocha instead of Jest. Find NPM scripts
    and update the test script as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Change the preceding code to:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The change you just made will cause Mocha to execute all of your tests. It will
    only execute them once, though. You want a way to have your tests running continuously
    while you work, so you need to add an additional script. Add a comma to the end
    of the line you just modified and then add the following script just beneath `test`*:*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, you need to update the `test.js` file provided when you ejected. Open `<project
    root>/scripts/test.js` and replace all the code inside with the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This file just sets up the base environment for your tests to execute inside.
    Make note of the `noop` function and usage. Currently, you are ignoring the `css`
    and `svg` extensions that are required by your production code when you are testing.
    In the course of testing, if you run into issues while requiring a different extension,
    you might have to come back to this file and add the troublesome extension to
    the list.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'You are almost done; you only have one more modification to make before you
    are officially switched over to Mocha. Find the file `App.test.js` in your `src` directory,
    and change its name to `App.spec.js`, then update the contents to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All you have really done here is import Chai and add a `describe` block. The
    rest of this test has remained unchanged and is the default test provided with
    Create React App.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: A quick kata to check our test setup
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this setup test, you are going to do the Palindrome code kata. This code
    kata can get complex, but you are only going to concern yourself with the most
    basic form.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The requirements
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this kata are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The execution
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you always should, you will begin with a templated test file designed to
    verify that the unit testing framework is configured correctly:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have shown a failing version of this template. Before you begin writing the
    tests that are actually for the kata, run the `test:watch` NPM script and verify
    that the test fails. Also, verify that it fails for the right reason. It should
    fail because *1* was expected but *0* was the actual result. After the test properly
    fails, change the zero to a one and verify that the test now passes. As long as
    these two validations work correctly, we will continue and begin working through
    the code kata.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Starting the kata
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you will do for the kata is write an `ItExists` test. Again,
    these types of test help to get the ball rolling and prevent writer's block. You
    will replace the code for checking the framework with the following.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '*Red phase*; write a failing test that expects an `isPalindrome` function to
    exist:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Verify that this test fails. It's important to see a failure before moving on
    to making the test pass. This will help confirm that your test setup is working
    properly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: And now the *green phase*; make the test pass. Define an `isPalindrome` function
    and run the test once more to see it pass.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the next test, we want to think of the simplest test case that would produce
    a result. Again, we are skipping bad data issues. The simplest test case we can
    think of that would product a result is a single letter. For the definition of
    palindrome that you will be using for these tests, a single letter is a palindrome.
    Add the following test under the previous one:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, to make it pass:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now you have a passing test, but you are always returning true. You want the
    next test to fail when you write it. So, you should write a test for when the
    value passed in is not a palindrome. The simplest non-palindrome would be two
    letters that are not the same:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, make it pass:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Okay, so now you only return true single letters. This opens us up for our
    next test, flipping back to something that is a palindrome; write a test for two
    letters that are the same:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, to make it pass:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next test is to have a three-letter word that is a palindrome. Currently,
    this should fail:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make this test pass, think about what you have so far. One algorithm for
    checking a palindrome is to simply start on the outsides and check the two outermost
    letters. If those two letters are a match, then move in one letter on each side.
    Repeat this check until you get to the center of the word or phrase. If the center
    is one letter, then it''s a palindrome; otherwise, check if the two center-most
    characters are a match. Let''s try this concept out by using recursion to make
    the latest test pass:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We now need to check if a four-letter palindrome will pass:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It passes; excellent! We will end this code kata with two exercises for you.
    The first exercise is to add a test for "a man a plan a canal panama" and make
    it pass. The second exercise is to refactor the code for `isPalindrome`. While
    this is a small function, it could still do with some tidying up, and potentially
    some optimizations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have Node installed and your JavaScript development environment
    configured. JavaScript examples throughout the rest of the book will assume your
    use of WebStorm.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该已经安装了Node，并且配置好了您的JavaScript开发环境。本书余下的JavaScript示例将假设您使用WebStorm。
- en: But, before diving right in, [Chapter 4](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195), *What
    to Know Before Getting Started*, will focus on what more you need to know before
    getting started.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在深入之前，[第4章](part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195)，*开始之前需要了解的内容*，将专注于在开始之前您还需要了解什么。
