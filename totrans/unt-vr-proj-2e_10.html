<html><head></head><body>
        

                            
                    <h1 class="header-title">Using All 360 Degrees</h1>
                
            
            
                
<p class="calibre3">360-degree photos and videos are a different way of using virtual reality that is accessible to consumers today, both in terms of experiencing them as well as producing and publishing them. Viewing prerecorded images requires much less compute power than rendering full 3D scenes, and this works very well on mobile phone-based VR in particular. In this chapter, we will explore the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Understanding 360-degree media and formats</li>
<li class="calibre12">Using textures to view globes, photo spheres, and skyboxes</li>
<li class="calibre12">Adding 360-degree video to your Unity projects</li>
<li class="calibre12">Writing and using custom shaders</li>
<li class="calibre12">Capturing 360-degree images and video from within your Unity app</li>
</ul>
<p>Note that the projects in this chapter are separate and not directly required by the other chapters in this book. If you decided to skip any of it or not save your work, that's okay.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">360-degree media</h1>
                
            
            
                
<p class="calibre3">The terms 360-degree and <em class="calibre14">virtual reality</em> are tossed around a lot lately, often in the same sentence. Consumers may be led to believe that it's all the same thing, it's all figured out, and it's all very easy to produce, when in fact it is not so simple.</p>
<p class="calibre3">Generally, the term 360-degree refers to viewing of prerecorded photos or videos in a manner that allows you to rotate your view's direction to reveal content that was just outside your field of view.</p>
<p class="calibre3">Non-VR 360-degree media has become relatively common. For example, many real-estate listing sites provide panoramic previews with a web-based player that lets you interactively pan around to view the space. Similarly, Facebook and YouTube support uploading and playback of 360-degree videos and provides a player with interactive controls to look around during the playback. Google Maps lets you upload 360-degree still photosphere images, much like their Street View that you can create with an Android or iOS app or a consumer camera (for more information, visit <a href="https://www.google.com/maps/about/contribute/photosphere/" class="calibre10">https://www.google.com/maps/about/contribute/photosphere/</a>). The internet is teeming with 360-degree media!</p>
<p class="calibre3">With a VR headset, viewing 360-degree media is surprisingly immersive, even just still photos. You're standing at the center of a sphere with an image projected onto the inside surface, but you feel like you're really there in the captured scene. Simply turn your head to look around. It's one of those things that gets people interested in VR the first time they see it, and it is a popular application for Google Cardboard and Gear VR, having jump-started the consumer VR revolution for a lot of people.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Equirectangular projections</h1>
                
            
            
                
<p class="calibre3">Ever since it was discovered that the Earth is round, cartographers and mariners have struggled with how to project the spherical globe onto a two-dimensional chart. The variations are plentiful and the history is fascinating (if you're fascinated by that sort of thing!) The result is an inevitable distortion of some areas of the globe.</p>
<p>To learn more about map projections and spherical distortions, visit <a href="http://en.wikipedia.org/wiki/Map_projection" class="calibre20">http://en.wikipedia.org/wiki/Map_projection</a>.</p>
<p class="calibre3">As a computer graphics designer, it's perhaps a little less mysterious than it was to ancient mariners because we know about <em class="calibre14">UV Texture mapping</em>.</p>
<p class="calibre3">3D computer models in Unity are defined by <em class="calibre14">meshes</em>-a set of Vector3 points connected with edges, forming triangular-shaped facets. You can unwrap a mesh (in Blender, for instance) into a flattened 2D configuration to define the mapping of texture pixels to the corresponding areas on the mesh surface (UV coordinates). A globe of the Earth, when unwrapped, will be distorted, as defined by the unwrapped mesh. The resulting image is called a <strong class="calibre5">UV Texture image</strong>.</p>
<p class="calibre3">In computer graphic modeling, this UV mapping can be arbitrary and depends on the artistic requirements at hand. However, for 360-degree media, this typically is done using an <em class="calibre14">equirectangular</em> (or a Meridian) projection (for more information, visit <a href="http://en.wikipedia.org/wiki/Equirectangular_projection" class="calibre10">http://en.wikipedia.org/wiki/Equirectangular_projection</a>), where the sphere is unraveled into a cylindrical projection, stretching the texture as you progress towards the north and south poles while keeping the meridians as equidistant vertical straight lines. The following <em class="calibre14">Tissot's indicatrix</em> (visit <a href="http://en.wikipedia.org/wiki/Tissot%27s_indicatrix" class="calibre10">http://en.wikipedia.org/wiki/Tissot%27s_indicatrix</a> for more information) shows a globe with strategically arranged identical circles (illustration by Stefan Kühn):</p>
<div><img class="image-border13" src="img/f695cbde-47c3-4a57-b695-d7a76748677b.png"/></div>
<p class="calibre3">The following image shows the globe unwrapped with an equirectangular projection:</p>
<div><img class="image-border14" src="img/9e26ea8f-b682-4664-bde2-102d79283334.png"/></div>
<p>Illustration by Eric Gaba - Wikimedia Commons user: Sting</p>
<p class="calibre3">We will use an equirectangular mesh for our photo spheres and an appropriately projected (warped) image for its texture map.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">VR is hacking your field of view</h1>
                
            
            
                
<p class="calibre3">OK, but why are 360-degree media in virtual reality so compelling? There's a huge difference in how we experience viewing a 360-degree video on a flat screen versus inside a VR headset. For example, an IMAX cinema theater with larger screens than that of the conventional cinema encompasses more of your peripheral vision and has a wider <strong class="calibre5">field of view</strong> (<strong class="calibre5">FOV</strong>). A mobile phone or computer monitor, at a natural viewing distance, is about a 26-degree FOV; a movie theatre is 54 degrees (IMAX is 70 degrees). Oculus Rift and HTC VIVE are about 120 degrees. In human vision, one eye is about 160 degrees, both eyes combined provides about a 200-degree horizontal field of view.</p>
<p>For more information about FOV adjustments in conventional video games, read the excellent article <em class="calibre2">All about</em> FOV (July 18, 2014) by visiting <a href="http://steamcommunity.com/sharedfiles/filedetails/?id=287241027" class="calibre20">http://steamcommunity.com/sharedfiles/filedetails/?id=287241027</a>.</p>
<p class="calibre3">In VR, you're not so obviously limited by the FOV and physical dimensions of the screen because you can easily move your head to change your view direction at any time. This provides a fully immersive view, horizontal 360 degrees, as you look side to side and up and down by 180 degrees. In VR, with your head still, the field of view is only significant with regard to the outer reaches of your peripheral vision and eyeball movement. But move your head (at the neck and/or full body); the software detects the change in head pose (viewing direction) and updates the display. The result is you believe to have an uninterrupted view of the 360-degree image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">180-degree media</h1>
                
            
            
                
<p class="calibre3">I sometimes joke that taking pictures and videos with my consumer 360-degree camera is like shooting a landscape and a selfie at the same time! Especially if you're holding the camera when taking the pictures, you are always in it. But really, when you take a photo, you're most likely already facing the action, and so when viewing the photo the user is also facing the action. So maybe all you need is 180 degrees. Furthermore, it can be tedious to look all the way behind you. As the name implies, a 180-degree image is half a 360 one, projected onto a hemisphere.</p>
<p class="calibre3">In 2017, Google introduced a standard for 180-degree media intended for VR (<a href="https://vr.google.com/vr180/" class="calibre10">https://vr.google.com/vr180/</a>). In addition to offering equirectangular projection, the cameras have two lenses for capturing stereographic, one for each eye. It works pretty well for a 180-degree view because while you can move left-right to look around, the actual movement needed is relatively small (human peripheral vision is about 200-degree horizontal anyway). Stereo 360 is more challenging.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stereo 360-degree media</h1>
                
            
            
                
<p class="calibre3">To capture monoscopic 360-degree media, you can use a consumer 360-degree camera. These cameras typically have a couple of back-to-back super wide angle lenses and corresponding image sensors. The resulting image captures are stitched together, using clever algorithms to avoid seams, and the result is processed into an equirectangular projection. Viewing it in VR, each eye sees the same 360 photo. For landscapes, such as mountain views or other large areas, where the subject is more than 20 meters from your viewing position, it is fine because there is no parallax. Each eye sees pretty much from the same viewing angle. But if the photo includes objects closer to you, it will look incorrect, or at least artificially flattened, because you expect parallax where each eye has a slightly different view. </p>
<p class="calibre3">What about true 360-degree stereo? Shouldn't each eye have its own photo sphere offset from the other eye's position? </p>
<p class="calibre3">To capture <em class="calibre14">stereo</em> 360-degree media, it cannot simply be photographed by two 360 cameras from two viewpoints but can be constructed by stitching together images from a rotating stereo pair. The distance between camera image captures simulates a human's separation between eyes (IPD, interpupillary distance).  There is a new generation of consumer cameras (such as <em class="calibre14">Fuze Camera</em>, <a href="https://vuze.camera/" class="calibre10">https://vuze.camera/</a> with eight cameras), and high-end professional camera rigs, such as <em class="calibre14">Google Jump</em> (<a href="https://vr.google.com/jump/" class="calibre10">https://vr.google.com/jump/</a>), which arranges sixteen separate cameras in a cylindrical array. Advanced image processing software then constructs stereographic views. </p>
<p class="calibre3">Google has introduced an advanced file format for stereo 360-degree video: <em class="calibre14">omni-directional stereo</em>, or ODS. It is a variant of conventional equirectangular projections with the advantages of avoiding bad seams or dead zones, it is pre-rendered for faster playback, and video uses conventional encoding so you can edit using conventional tools.  And Unity supports ODS in their Panoramic Skybox shaders (see the topic later in this chapter).</p>
<p>For a more detailed explanation of the challenges and geometry of stereo 360 media captures, see the Google whitepaper <em class="calibre2">Rendering Omni-directional Stereo Content</em> (<a href="https://developers.google.com/vr/jump/rendering-ods-content.pdf" class="calibre20">https://developers.google.com/vr/jump/rendering-ods-content.pdf</a>). Also, check out the article <em class="calibre2">Stereographic 3D Panoramic Images</em> by Paul Bourke (May 2002) by visiting <a href="http://paulbourke.net/stereographics/stereopanoramic/" class="calibre20">http://paulbourke.net/stereographics/stereopanoramic/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fun with photo globes</h1>
                
            
            
                
<p class="calibre3">To begin exploring these concepts, let's have a little fun as we apply an ordinary (rectangular) image as a texture to a sphere, just to see what it does and how bad it looks. Then, we'll use a properly distorted equirectangular photosphere texture.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Crystal balls</h1>
                
            
            
                
<p class="calibre3"><em class="calibre14">Auntie Em! Auntie Em!</em> cried Dorothy in the Wizard of Oz, as she gazed into a crystal ball seeking help from the Wicked Witch. Let's consider making a crystal ball using Unity, <em class="calibre14">my little pretty!</em></p>
<p class="calibre3">First, set up a new scene for this chapter by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Create a new scene by navigating to File | New Scene. Then, navigate to File | Save Scene As... and name it <kbd class="calibre13">360Degrees</kbd>.</li>
<li class="calibre12">Create a new plane by navigating to GameObject | 3D Object | Plane and reset its transformation using the Transform component's <em class="calibre2">gear</em> icon | Reset.</li>
<li class="calibre12">Set the Main Camera Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-1</kbd>)</li>
</ol>
<p class="calibre3">You can choose to use the MeMyselfEye camera rig we've been using throughout the book, but it is not necessary in this project. The Main Camera will implement the VR camera based on the SDK you've selected in Player Settings. We will not be using device-specific input or other features.</p>
<p class="calibre3">Now, create the first sphere and write a rotator script while we're at it. I'm using the <kbd class="calibre13">EthanSkull.png</kbd> image that was provided with this book (drag and drop it into your Project Assets Textures folder). </p>
<p class="calibre3">Then, perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Create a new sphere by navigating to GameObject | 3D Object | Sphere, reset its transformation using the Transform component's <em class="calibre2">gear</em> icon | Reset, and name it <kbd class="calibre13">CrystalBall</kbd>.</li>
<li class="calibre12">Set its Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">1.5</kbd>, <kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">Drag and drop the texture named <kbd class="calibre13">EthanSkull</kbd> (you can use any photo that you want) onto the sphere.</li>
<li class="calibre12">Create a new script by navigating to Add Component | New Script and name it <kbd class="calibre13">Rotator</kbd>.</li>
</ol>
<p class="calibre3">Note that dropping the texture onto the game object will automatically create a corresponding Material named <kbd class="calibre13">EthanSkull.mat</kbd> in your <kbd class="calibre13">Materials/</kbd> folder, with this texture in the Albedo texture map slot.</p>
<p class="calibre3">Open the <kbd class="calibre13">rotator.cs</kbd> script and write it, as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class Rotator : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    [Tooltip("Rotation rate in degrees per second")]<br class="title-page-name"/>    public Vector3 rate;<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        transform.Rotate(rate * Time.deltaTime);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Note that we added a <kbd class="calibre13">Tooltip</kbd> attribute for the Unity Editor that gives the developer more detail how to use the <kbd class="calibre13">rate</kbd> values. </p>
<p class="calibre3">Then, set the rotation rate so that it spins around the <em class="calibre14">y</em> axis 20 degrees per second, as follows:</p>
<ol class="calibre15">
<li class="calibre12">On the Rotator Script component, set Rate for X, Y, Z as (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">20</kbd>, <kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">Save the scene. Try it in VR.</li>
</ol>
<div><img src="img/d934cac4-dcc4-4e67-a1f5-d19d02aa51fd.png" class="calibre24"/></div>
<p class="calibre3"><em class="calibre14">Is that scary or what?</em> No worries. The projected image may be distorted, but it looks wicked cool. For some applications, a little distortion is the artistic intent, and you don't need to worry about it.</p>
<p>Careful editing such as smudging the edges of the photo can help avoid seams in the texture map.</p>
<p class="calibre3">While we're at it, lets try making the ball look more like crystal glass by adjusting the shader properties:</p>
<ol class="calibre15">
<li class="calibre12">Select <kbd class="calibre13">CrystalBall</kbd> in Inspector</li>
<li class="calibre12">Set its Metallic value to <kbd class="calibre13">0.75</kbd></li>
<li class="calibre12">Set its Smoothness value to <kbd class="calibre13">0.75</kbd></li>
<li class="calibre12">Open the Albedo color (click the color swatch), and adjust the Alpha (A) value to <kbd class="calibre13">100</kbd></li>
</ol>
<p class="calibre3">That looks better. Add more objects with various textures into your scene to visualize the transparency and specular highlights.  </p>
<p class="calibre3">If you're interested in more realistic glass simulation for your crystal balls, here are some suggestions:</p>
<ul class="calibre11">
<li class="calibre12">Consider adding a reflection probe to the scene (<a href="https://docs.unity3d.com/Manual/class-ReflectionProbe.html" class="calibre10">https://docs.unity3d.com/Manual/class-ReflectionProbe.html</a>) so the surface seems to reflect other objects in the scene.</li>
<li class="calibre12">For transparency and refraction, a <kbd class="calibre13">GlassRefractive</kbd> material is provided in the Standard Assets Effects package.</li>
<li class="calibre12">Try a custom shader in your material. An example of a Simple Glass shader is given in the Unity ShaderLab documentation (<a href="https://docs.unity3d.com/Manual/SL-CullAndDepth.html" class="calibre10">https://docs.unity3d.com/Manual/SL-CullAndDepth.html</a>).</li>
<li class="calibre12">Also consider third-party materials and shaders that simulate glass with refraction, distortions, glass surface patterns, and colors (search the Asset Store, <a href="https://assetstore.unity.com/search?q=category%3A121&amp;q=glass" class="calibre10">https://assetstore.unity.com/search?q=category%3A121&amp;q=glass</a>).</li>
<li class="calibre12">Note that transparency should be used sparingly in VR applications as it requires additional rendering passes per pixel, potentially slowing your frame generation and causing unwanted latency.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Globes</h1>
                
            
            
                
<p class="calibre3">Next, we'll make another sphere and add a texture, like we just did, but this time use a texture with an equirectangular (photosphere) distortion.</p>
<p class="calibre3">Import the <kbd class="calibre13">Tissot_euirectangular.png</kbd> image, which is included with this book (and available on Wikipedia at <a href="https://en.wikipedia.org/wiki/Tissot%27s_indicatrix#/media/File:Tissot_behrmann.png" class="calibre10">https://en.wikipedia.org/wiki/Tissot%27s_indicatrix#/media/File:Tissot_behrmann.png</a>),  into your Texture folder and perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Create a new sphere and name it <kbd class="calibre13">Globe</kbd>. Add the <kbd class="calibre13">Rotator</kbd> script if you want.</li>
<li class="calibre12">Drag the texture named <kbd class="calibre13">Tissot_equirectangular</kbd> onto the sphere.</li>
<li class="calibre12">Try it in VR. Take a close look at the globe, as shown in the following image:</li>
</ol>
<div><img class="image-border15" src="img/dd9f3888-fb32-406f-8169-a9d864dffbab.png"/></div>
<p class="calibre3">Note that unfortunately the Tissot circles are oval, not circular, except along the equator. It turns out that the default sphere provided in Unity does not mesh well for equirectangular texture maps. Instead, I have provided one designed specifically for this purpose, <kbd class="calibre13">PhotoSphere.fbx</kbd> (which happens to be the default sphere model in 3D Studio Max). Let's try it:</p>
<ol class="calibre15">
<li class="calibre12">Import the <kbd class="calibre13">PhotoSphere.fbx</kbd> file by dragging it into your Project Assets Models folder (or through the menu: Assets | Import New Asset...).</li>
<li class="calibre12">Create a new equirectangular sphere by dragging the <kbd class="calibre13">PhotoSphere</kbd> model from Project Assets into Scene.</li>
<li class="calibre12">Set its position and name it <kbd class="calibre13">Globe2</kbd>. Add the <kbd class="calibre13">Rotator</kbd> script if you want.</li>
<li class="calibre12">Drag the texture named <kbd class="calibre13">Tissot_equirectangular</kbd> onto the sphere.</li>
</ol>
<p class="calibre3">Try it in VR. <em class="calibre14">Much better.</em> You can see the texture is correctly mapped now; the circles are round (and the underlying mesh grid is more regular):</p>
<div><img class="image-border16" src="img/4b928357-0792-4f5e-8f71-7daeacca25dc.png"/></div>
<p class="calibre3">Now you can apply any 360 degree photo to the globe, creating your own <em class="calibre14">photo-globes</em> or virtual Christmas tree ornaments!</p>
<p class="calibre3">Expanding upon this topic further, you could build a nice model of the Solar System. Equirectangular texture maps of each of the planets and moons can be downloaded free from Solar System Scope (<a href="https://www.solarsystemscope.com/" class="calibre10">https://www.solarsystemscope.com/</a>). Data regarding the rate of rotation (day/night) and orbit (around the sun) can be found on the NASA site (<a href="https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html" class="calibre10">https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html</a>). A complete Unity tutorial project can be found in the book <em class="calibre14">Augmented Reality for Developers</em> (<a href="https://www.amazon.com/Augmented-Reality-Developers-Jonathan-Linowes/dp/1787286436" class="calibre10">https://www.amazon.com/Augmented-Reality-Developers-Jonathan-Linowes/dp/1787286436</a>).</p>
<p class="calibre3">Another idea is that photo globes have been used as a teleportation mechanism in VR games-- as a player, you grab a globe depicting another scene, put it on your face and you are teleported into that world. See the topic on <em class="calibre14">Capturing 360-degree media</em> for how to capture a 360-degree photo of your Unity scenes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rendering photospheres</h1>
                
            
            
                
<p class="calibre3">The inverse of a globe is a photosphere. Where a globe maps an equirectangular texture onto the outside surface of a sphere, a photosphere would map the texture onto the inside surface, and you view it from the inside so it surrounds you.</p>
<p class="calibre3">For our examples, I'm using the <kbd class="calibre13">Farmhouse.png</kbd> image which is provided with this book, as shown below. Feel free to use your own 360-degree photo, whether you have a 360-degree camera such as the Ricoh Theta or other brand, use a photo stitching app for Android or iOS, or download one from any number of photo sources on the web.</p>
<div><img class="calibre24" src="img/a52dc709-37e7-43c5-b207-0f6e2686fd2a.png"/></div>
<p class="calibre3">As we've seen, Unity ordinarily renders only the outward-facing surfaces of objects. This is determined, mathematically, as the <em class="calibre14">normal</em> direction vector of each facet of its surface mesh. A Plane is the simplest example. Back in <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre10">Chapter 2</a>, <em class="calibre14">Content, Objects, and Scale</em>, we created a big screen image plane with the Grand Canyon on it. When you are facing the plane, you see the image. But if you move around behind the plane, it is not rendered, as if it were not in the scene at all. Similarly, suppose there is a cube or sphere in front of you; you will see it rendered, lit, and shaded. But if you put your head inside the object, it seems to disappear, because you're now looking at the inside faces of the object's mesh. This is all handled by the shader. And since we want to change it, we need to use a different shader. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing a custom Inward shader</h1>
                
            
            
                
<p class="calibre3">We are going to write a custom shader to render our texture on the inside of the sphere mesh.</p>
<p class="calibre3">Shaders are a critical part of the Unity rendering pipeline, and it's where a lot of the magic of computer graphics and virtual reality actually occurs. Unity provides an impressive set of built-in shaders, as you've likely noticed just by opening the Shader select list on any object's Material in the Inspector. Many asset packages you import may also include shaders that implement custom effects, including some we've already used in previous chapters, such as TextMeshPro and TiltBrush. The VR toolkits from Oculus, Google Daydream, and SteamVR also include shaders that provide an extra kick in performance and optimization of the rendering pipeline.</p>
<p class="calibre3">Writing shaders is an advanced topic in computer graphics and Unity development. Nonetheless, Unity provides tools to facilitate the programming of shaders (see <a href="https://docs.unity3d.com/Manual/SL-Reference.html" class="calibre10">https://docs.unity3d.com/Manual/SL-Reference.html</a>), including a declarative language called <em class="calibre14">ShaderLab</em>, a lot of documentation and tutorials, and example shaders to work from. We are not going to go very deep here but many find it a very interesting and valuable skill to learn. </p>
<p class="calibre3">To create a new shader, begin as follows:</p>
<ol class="calibre15">
<li class="calibre12">Navigate to Create | Shader | Unlit Shader and name it <kbd class="calibre13">MyInwardShader</kbd></li>
<li class="calibre12">Double-click the new shader file to open it for editing</li>
</ol>
<p class="calibre3">To turn the shader into an inside shader, all you need to do is add the line <kbd class="calibre13">Cull Front</kbd>, for example, immediately after the <kbd class="calibre13">Tags</kbd> line as follows:</p>
<pre class="calibre18">    ...<br class="title-page-name"/>    Tags { "RenderType"="Opaque" }<br class="title-page-name"/>    Cull Front<br class="title-page-name"/>    ...</pre>
<p class="calibre3">The <kbd class="calibre13">Cull</kbd> command tell the shader whether to ignore front or back facing surfaces. The default is Back; we're changing it to cull the front ones and render the back ones. (For details on this, see <a href="https://docs.unity3d.com/Manual/SL-CullAndDepth.html" class="calibre10">https://docs.unity3d.com/Manual/SL-CullAndDepth.html</a>.) </p>
<p class="calibre3">Save the file. Now we can use it in our project.</p>
<p class="calibre3">Notice that the top line of the shader file names it <kbd class="calibre13">Shader "Unlit/MyInwardShader"</kbd>, which means you'll find it in the select Shader | Unlit submenu, or you can modify it without the submenu to <kbd class="calibre13">Shader "MyInwardShader"</kbd>.</p>
<p class="calibre3">Since we're inverting the texture, it may appear mirrored backwards. We will fix that by setting its X Tiling to <kbd class="calibre13">-1</kbd>, as we will see.</p>
<p class="calibre3">An alternative approach is to invert the vertex normals within the shader. We used that technique in the first edition of this book, and it is shown here:</p>
<pre class="calibre18">Shader "MyInwardNormalsShader" {<br class="title-page-name"/>    Properties {<br class="title-page-name"/>        _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>    }<br class="title-page-name"/>    SubShader {<br class="title-page-name"/>        Tags { "RenderType" = "Opaque" }<br class="title-page-name"/>        Cull Off<br class="title-page-name"/><br class="title-page-name"/>        CGPROGRAM<br class="title-page-name"/>        #pragma surface surf Lambert vertex:vert<br class="title-page-name"/>        sampler2D _MainTex;<br class="title-page-name"/><br class="title-page-name"/>        struct Input {<br class="title-page-name"/>            float2 uv_MainTex;<br class="title-page-name"/>            float4 color : COLOR;<br class="title-page-name"/>        };<br class="title-page-name"/><br class="title-page-name"/>        void vert(inout appdata_full v) {<br class="title-page-name"/>            v.normal.xyz = v.normal * -1;<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        void surf (Input IN, inout SurfaceOutput o) {<br class="title-page-name"/>             fixed3 result = tex2D(_MainTex, IN.uv_MainTex);<br class="title-page-name"/>             o.Albedo = result.rgb;<br class="title-page-name"/>             o.Alpha = 1;<br class="title-page-name"/>        }<br class="title-page-name"/>        ENDCG<br class="title-page-name"/>    }<br class="title-page-name"/>      Fallback "Diffuse"<br class="title-page-name"/>}</pre>
<p class="calibre3">Briefly, this shader script declares the following:</p>
<ul class="calibre11">
<li class="calibre12">Lets you supply  both a texture and a color property</li>
<li class="calibre12">Does no culling of surfaces (the texture will be visible both inside and out)</li>
<li class="calibre12">Uses a simple Lambert diffuse lighting algorithm (versus unlit or the Standard Unity physically-based lighting)</li>
<li class="calibre12">The <kbd class="calibre13">vert</kbd> function inverts the mesh vertices (by multiplying the normal vector by <kbd class="calibre13">-1</kbd>)</li>
<li class="calibre12">The <kbd class="calibre13">surf</kbd> renderer copies the texture pixel and also lets you tint it with an Albedo color (but forces Alpha to be opaque)</li>
</ul>
<p class="calibre3">You can use this shader instead of the quick one we wrote previously.</p>
<p>Consider what would happen if you used an Alpha channel in your shader settings and set up a cutout mask. It would allow photospheres with some areas completely transparent. This opens the possibility of nesting multiple photospheres to create visual layers of 360 activity within your scene!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Magic orbs</h1>
                
            
            
                
<p class="calibre3">Before we do full 360-photo viewing, for fun let's first consider a special case, <em class="calibre14">magic orbs</em>. For this example, we'll look at the sphere from the inside, mapping a 360-degree image onto its inside surface. Then, we'll put a solid colored <em class="calibre14">shell</em> around the outside. So, you really have to stick your head into the sphere to see what's there, or grab the sphere and "put it on your eyes!"</p>
<p class="calibre3">To build it, follow these steps:</p>
<ol class="calibre15">
<li class="calibre12">Create a new material by navigating to Assets | Create | Material and name it <kbd class="calibre13">FarmhouseInward</kbd>.</li>
<li class="calibre12">In Inspector, use the Shader selector and choose Unlit | MyInwardShader, the one we just created.</li>
<li class="calibre12">Locate the <kbd class="calibre13">Farmhouse</kbd> texture image and drag it onto the shader component's Albedo texture. If needed, set Tiling X to <kbd class="calibre13">-1</kbd> to compensate for mirroring.</li>
<li class="calibre12">Add a new sphere to the scene, dragging the <kbd class="calibre13">PhotoSphere.fbx</kbd> from your <em class="calibre2">Models</em> folder introduced before, and name it "MagicOrb."</li>
<li class="calibre12">Drag the <kbd class="calibre13">FarmhouseInward</kbd> material onto the sphere. </li>
</ol>
<p class="calibre3">We'll encase it in a solid colored orb by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">MagicOrb</kbd> object in Hierarchy, right-click, and navigate to 3D Object | Sphere so that the new sphere is a child.</li>
</ol>
<p class="calibre3"> </p>
<ol start="2" class="calibre15">
<li class="calibre12">Set its Scale to something a little bigger than the inner sphere, such as (<kbd class="calibre13">1.02</kbd>, <kbd class="calibre13">1.02</kbd>, <kbd class="calibre13">1.02</kbd>)</li>
<li class="calibre12">Disable its Sphere Collider component by unchecking it.</li>
<li class="calibre12">Find a solid material, such as the one we made in a previous chapter named <kbd class="calibre13">RedMaterial</kbd>, and drag it onto the new sphere.</li>
</ol>
<p class="calibre3">Try it in VR. From the outside, it looks like a solid ball, but lean into it and there's a whole new little world in there! The following image is a capture of what I see. It's like peering into an egg shell!</p>
<div><img src="img/4e051aec-b008-4d5b-b497-9b7bd2764a29.png" class="calibre80"/></div>
<p class="calibre3">For non-positionally tracked mobile VR devices, you may not be able to do this in VR, but you can manually drag the camera rig in the Scene view while playing the scene in the Editor. Or, add some locomotion as described in <a href="f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml" target="_blank" class="calibre10">Chapter 7</a>, <em class="calibre14">Locomotion and Comfort</em>. Or, make the orb grab-able, so the player can pick it up and move it very close to their face, using techniques described in <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables</em>.</p>
<p>If you want to dive deeper into shaders, as an exercise, try and see how you could modify InwardShader to take an additional Color parameter that is used to render the outward facing surface, while the texture is used to render the inward facing ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Photospheres</h1>
                
            
            
                
<p class="calibre3"><em class="calibre14">Yes sir, it's all the rage these days. It's better than panoramas. It's better than selfies. It may be even better than Snapchat! We're finally getting to the moment that you've been waiting for! It's 360-degree photospheres!</em></p>
<p class="calibre3">We covered a lot of topics in this chapter, which will now make it fairly easy to talk about 360-degree photospheres. To build one, we'll just make a very big sphere with the <kbd class="calibre13">MyInwardShader</kbd> shader.</p>
<p class="calibre3">Start with a new empty scene:</p>
<ol class="calibre15">
<li class="calibre12">Create a new scene by navigating to File | New Scene. Then, File | Save Scene and name it <kbd class="calibre13">PhotoSphere</kbd>. Delete the default Main Camera.</li>
<li class="calibre12">Add the <kbd class="calibre13">MyMyselfEye</kbd> prefab and reset its Transform Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">Create an equirectangular sphere by dragging the <kbd class="calibre13">PhotoSphere</kbd> model from the <kbd class="calibre13">Project Models</kbd> folder into the scene (as imported from <kbd class="calibre13">PhotoSphere.fbx</kbd> in the previous example).</li>
<li class="calibre12">Reset its Transform  (<em class="calibre2">gear</em> icon | Reset) and set its Scale to (<kbd class="calibre13">10</kbd>, <kbd class="calibre13">10</kbd>, <kbd class="calibre13">10</kbd>).</li>
<li class="calibre12">Create a material (Create | Material) and name it to <kbd class="calibre13">PhotoSphere Material</kbd>.</li>
<li class="calibre12">Navigate to Shader | Unlit | MyInwardShader (as created earlier in this chapter).</li>
<li class="calibre12">Drag the <kbd class="calibre13">Photosphere</kbd> Material onto the <kbd class="calibre13">Photosphere</kbd> game object.</li>
<li class="calibre12">If there will be other objects in the Scene, you may need to disable shadows. On the Photosphere game object, in its Mesh Renderer component, uncheck the Receive Shadows checkbox.</li>
</ol>
<p class="calibre3">Now, to add the photo:</p>
<ol class="calibre15">
<li class="calibre12">Import the photo that you want to use; ours is named <kbd class="calibre13">FarmHouse.jpg</kbd>. </li>
<li class="calibre12">With <kbd class="calibre13">PhotoSphere</kbd> selected (or the <kbd class="calibre13">PhotoSphere Material</kbd> itself), drag the <kbd class="calibre13">FarmHouse</kbd> texture onto the Albedo texture tile.</li>
<li class="calibre12">Set the Tiling X value to <kbd class="calibre13">-1</kbd> to compensate for the mirror inversion, if necessary.</li>
</ol>
<p class="calibre3">Press Play. You should now see the photosphere surrounding you in the scene.</p>
<p class="calibre3">If you are using a device with positional tracking, such as the Oculus Rift, we need to disable it. Create a new script on  <kbd class="calibre13">MemMyselfEye</kbd> as follows:</p>
<pre class="calibre18">public class DisablePositionalTracking : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        UnityEngine.XR.InputTracking.disablePositionalTracking = true;<br class="title-page-name"/>    }<br class="title-page-name"/>} </pre>
<p class="calibre3">You may find that the default texture resolution and/or compression are not high enough quality for your taste. To modify the resolution, follow these steps: </p>
<ol class="calibre15">
<li class="calibre12">Select the texture (Farmhouse.png)</li>
<li class="calibre12">In Inspector, change the Max Size to <kbd class="calibre13">4096</kbd> or <kbd class="calibre13">8192</kbd></li>
<li class="calibre12">Press Apply to re-import the texture</li>
</ol>
<p class="calibre3">Note the file size (at bottom of Inspector) can grow exponentially, affecting the final size of your app, load times, and runtime performance. Also try the other compression settings, including the new Crunch Compression (<a href="https://blogs.unity3d.com/2017/11/15/updated-crunch-texture-compression-library/" class="calibre10">https://blogs.unity3d.com/2017/11/15/updated-crunch-texture-compression-library/</a>). You can configure these settings on a per-platform basis.</p>
<p class="calibre3">To switch images, repeat the last two steps: import the asset and assign it to the Albedo texture of the <kbd class="calibre13">Photosphere Mataterial</kbd>. If you want to do this in-game, you can do this in a script (for example, by using <kbd class="calibre13">Material.mainTexture()</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing 360-degree videos</h1>
                
            
            
                
<p class="calibre3">The steps for adding a 360-degree video are pretty much the same as adding a regular rectangular one to your project (see <a href="https://docs.unity3d.com/Manual/class-MovieTexture.html" class="calibre10">https://docs.unity3d.com/Manual/class-MovieTexture.html</a>). To play a 360-degree video, you use a  <kbd class="calibre13">Video Player</kbd> to render the video on a <kbd class="calibre13">Render Texture</kbd>.  If you do not have a 360-degree video handy, search the web free downloads and pick one that's not too long and a limited file size. </p>
<p>Depending on the format of your video, you may need to install QuickTime on your system first before you can import it into Unity, for the conversion codec. </p>
<p class="calibre3">If you would like, start a new scene and reset the MyMyselfEye Transform to the origin. Then, import a 360 video into your Project Assets. Note its dimensions (for example, a 4K video is 4096 x 2048). You can see it in Inspector, if you're not sure.</p>
<p class="calibre3">Add a video player to your project as follows:</p>
<ol class="calibre15">
<li class="calibre12">Create an Empty named <kbd class="calibre13">"VideoPlayer"</kbd></li>
<li class="calibre12">Add Component | Video Player</li>
<li class="calibre12">Drag your video file onto its Video Clip slot</li>
<li class="calibre12">Check the Play On Awake checkbox and the Loop checkbox</li>
<li class="calibre12">Ensure Render Mode is set to Render Texture</li>
</ol>
<p class="calibre3">Now, we will create a <kbd class="calibre13">Render Texture</kbd>, a special Unity texture that will be rendered at runtime by the video player:</p>
<ol class="calibre15">
<li class="calibre12">In your Project Assets, Create | Render Texture, name it <kbd class="calibre13">"Video Render Texture"</kbd></li>
<li class="calibre12">Set the Size to exactly the size of your video, (such as 4096 x 2048).</li>
<li class="calibre12">Setting Anti aliasing to 2 samples is recommended.</li>
<li class="calibre12">You can set Depth Buffer to No Depth Buffer</li>
<li class="calibre12">Select VideoPlayer in Hierarchy and drag VideoRenderTexture onto its Target Texture slot</li>
</ol>
<p class="calibre3">Now, create your photosphere:</p>
<ol class="calibre15">
<li class="calibre12">Create a new 3D Sphere and name it "VideoSphere"</li>
<li class="calibre12">Reset its Transform, so its Position is (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>), then set its Scale to  (<kbd class="calibre13">10</kbd>, <kbd class="calibre13">10</kbd>, <kbd class="calibre13">10</kbd>)</li>
<li class="calibre12">Drag Video Render Texture onto the sphere and make a new Material (or you could have separately created this material first)</li>
<li class="calibre12">Change the Material Shader to MyInwardShader</li>
</ol>
<p class="calibre3">A resulting VideoPlayer in Inspector is shown here:</p>
<div><img src="img/4f207c7e-e32f-44d4-8c85-1e12178cb4f3.png" class="calibre24"/></div>
<p class="calibre3">Press Play. You now have a basic 360 video player built with Unity.</p>
<p class="calibre3">To review, the sphere uses a material with an inward shader. The shader renders an equirectangular texture on the inside of the sphere. The video player modifies that texture each update with the next video frame.</p>
<p>When building for Android and iOS, you must put your video file (such as MP4) into a folder named <em class="calibre2">StreamingAssets</em> in your Project Assets. For more information on this and other considerations for Video Player and codecs, see the Unity documentation at <a href="https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html" class="calibre20">https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html</a>.</p>
<p class="calibre3">If the video has audio, we can make the video an Audio Source as follows:</p>
<ul class="calibre11">
<li class="calibre12">Select the VideoPlayer and Add Component | Audio Source</li>
<li class="calibre12">Drag <kbd class="calibre13">VideoPlayer</kbd> itself onto its Video Player component's Audio Source slot</li>
</ul>
<p class="calibre3">As with all Unity components, the video player has an API and can be controlled via scripting. For example, to simply pause the video with a button click, you could add this script to the <kbd class="calibre13">VideoPlayer</kbd>:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Video;<br class="title-page-name"/><br class="title-page-name"/>public class PlayPause : MonoBehaviour {<br class="title-page-name"/>    private VideoPlayer player;<br class="title-page-name"/><br class="title-page-name"/>    void Start() {<br class="title-page-name"/>        player = GetComponent&lt;VideoPlayer&gt;();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void Update() {<br class="title-page-name"/>        if (Input.GetButtonDown("Fire1"))<br class="title-page-name"/>        {<br class="title-page-name"/>            if (player.isPlaying)<br class="title-page-name"/>            {<br class="title-page-name"/>                player.Pause();<br class="title-page-name"/>            }<br class="title-page-name"/>            else<br class="title-page-name"/>            {<br class="title-page-name"/>                player.Play();<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p>For additional tips, also check out the tutorial from Unity <em class="calibre2">Getting started in interactive 360 video: Download our sample project</em> at  <a href="https://blogs.unity3d.com/2018/01/19/getting-started-in-interactive-360-video-download-our-sample-project/" class="calibre20">https://blogs.unity3d.com/2018/01/19/getting-started-in-interactive-360-video-download-our-sample-project/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Unity skyboxes</h1>
                
            
            
                
<p class="calibre3">Back in the olden days, or at least before 360 photos, we simply referred to <em class="calibre14">skyboxes</em> as the way to create background imagery in computer graphics. Skyboxes depict what's far on the horizon, may contribute to the ambient lighting of the scene, be used for rendering reflections on object surfaces, and are not interactable. Unity supports skyboxes as part of the Lighting Environment for each scene. We used skyboxes already in a few of the previous chapters' projects (including Wispy Sky and Skull Platform ones).</p>
<p class="calibre3">Common sources of skyboxes are cylindrical panorama, spherical panorama (360 images), and a six-sided cube. We won't consider the cylindrical one, since it's less useful for VR. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Six-sided or cubemap skyboxes</h1>
                
            
            
                
<p class="calibre3">A skybox can be represented by a six sides of a cube, where each side is akin to a camera capturing its view pointing in each of the six directions, as illustrated here:</p>
<div><img src="img/78ce7543-9205-4ef8-9d59-52b9e69e89d8.jpg" class="calibre81"/></div>
<p class="calibre3">Given these six images, as textures, you'd create a <em class="calibre14">six-sided</em> skybox material like the one shown next for the WispySky cubemap. And then, set it in the Lighting window as the Skybox Material for the scene:</p>
<div><img src="img/17612320-89bb-42d0-a15b-c2d3827a621a.png" class="calibre24"/></div>
<p class="calibre3">Alternatively, you could combine the six images into a single <em class="calibre14">cubemap</em> image, laid out similarly. </p>
<p class="calibre3">Cubemaps have an advantage because equirectangular textures waste pixels where the image is stretched at the top and bottom poles of the spherical projection. On the other hand, care must be taken to properly design images so they'll smoothly stitch together and not cause seams or other visual artifacts.</p>
<p>A variant over traditional cubemaps is the <strong class="calibre1">Equi-Angular Cubemap</strong> (<strong class="calibre1">EAC</strong>). EAC strives to have even more uniform pixel sizes and "equal angle pixel distribution in 3D."  (See <a href="https://blog.google/products/google-vr/bringing-pixels-front-and-center-vr-video/" class="calibre20">https://blog.google/products/google-vr/bringing-pixels-front-and-center-vr-video/</a>.)</p>
<p class="calibre3">But most 360 media today, especially coming from consumer cameras, use equirectangular projections, aka spherical panoramas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Spherical panoramic skyboxes </h1>
                
            
            
                
<p class="calibre3">Using a 360 photo for a skybox is referred to a <em class="calibre14">spherical panoramic</em>. Earlier in this chapter we used a spherical game object to render an equirectangular texture and placed the player camera dead-center inside it. Now, we'll now use the same image in a skybox. (Note, this will also work for 180-degree content.)</p>
<p class="calibre3">Start with a new empty scene:</p>
<ol class="calibre15">
<li class="calibre12">Create a new scene by navigating to File | New Scene. Then, File | Save Scene and name it <kbd class="calibre13">Skybox</kbd>. Replace the <kbd class="calibre13">Main Camera</kbd> with the <kbd class="calibre13">MyMyselfEye</kbd> prefab.</li>
<li class="calibre12">Assuming you're using the <kbd class="calibre13">Farmhouse.jpg</kbd> image as earlier, create a new <kbd class="calibre13">Material</kbd> and name it <kbd class="calibre13">Farmhouse Skybox</kbd>.</li>
<li class="calibre12">For the material's Shader, choose Skybox | Panoramic.</li>
<li class="calibre12">Drag your 360 image (<kbd class="calibre13">Farmhouse.jpg</kbd>) onto the Spherical texture area.</li>
<li class="calibre12">Set the Mapping to Latitude Longitude Layout.</li>
<li class="calibre12">Set the Image Type to 360 Degrees.</li>
</ol>
<p class="calibre3">The Material settings are shown here:</p>
<div><img src="img/d3e9a35d-d730-4581-bd73-702ab099fab3.png" class="calibre24"/></div>
<p class="calibre3">Now to use it in your scene:</p>
<ol class="calibre15">
<li class="calibre12">Open the Lighting window tab (if not in your Editor, navigate to Window | Lighting)</li>
<li class="calibre12">Drag your <kbd class="calibre13">Farmhouse Skybox</kbd> material onto the Skybox Material slot</li>
</ol>
<p class="calibre3">The Lighting Environment settings are shown here:</p>
<div><img src="img/0d6bd60f-d428-4a70-a8f8-8ffe841991e9.png" class="calibre82"/></div>
<p class="calibre3">Press Play. <em class="calibre14">Voila! </em>You should now see the photosphere surrounding you in the scene. That was almost too easy. Thank goodness! </p>
<p class="calibre3">One thing that's interesting is, since skyboxes are always rendered as if at a very far distance away, the camera will always be at the center of the photosphere. Thus, we don't need to set the camera rig at the origin, and we don't need to disable positional tracking, as we did for the spherical game object version of this project. Wherever you move, the skybox will surround you just the same. If your 360 image contains content (people or objects) that are relatively near, this may feel very unnatural, as if the objects are projected or flattened against the spherical projection (which they are!). This is why skyboxes are generally used for landscapes and wide open spaces. (Later, we'll see how this can be solved using <em class="calibre14">stereo</em> skyboxes.) </p>
<p class="calibre3">At this point, you can add more content to your scene. After all, we're in Unity and not just making an generic 360 photo viewer. Enhance your lovely outdoor scene by adding falling snow or leaves (for example, see the <em class="calibre14">Falling Leaves</em> particle package, <a href="https://assetstore.unity.com/packages/3d/falling-leaves-54725" class="calibre10">https://assetstore.unity.com/packages/3d/falling-leaves-54725</a>). </p>
<p class="calibre3">A common application is to use a 360 image in a lobby scene, and add an interactive menu panel for launching other apps or scenes. The Google Daydream lobby comes to mind.</p>
<p class="calibre3">Another application is to make the 360 image more interactive by add UI canvases to label content in the photo. It may take some thoughtful work to align the labels with the photosphere. Then, using a camera raycast, you can dynamically highlight what the player is looking at (see <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em> for coding tips). </p>


            

            
        
    

        

                            
                    <h1 class="header-title">360 video skyboxes</h1>
                
            
            
                
<p class="calibre3">Turning your skybox into a 360 degree video player is nearly identical to the steps outlined previously for the spherical game object version. We won't repeat everything again, but briefly it goes as follows:</p>
<ol class="calibre15">
<li class="calibre12">Set up a <kbd class="calibre13">Video Player</kbd> to play back the video source to a <kbd class="calibre13">Render Texture</kbd></li>
<li class="calibre12">Set up a <kbd class="calibre13">Skybox Material</kbd> that will receive the <kbd class="calibre13">Render Texture</kbd></li>
<li class="calibre12">Set the scene to use the <kbd class="calibre13">Skybox Material</kbd></li>
</ol>
<p class="calibre3">Note, according to Unity, equirectangular videos should have an aspect ratio of exactly 2:1 (or for 180-degree content, 1:1) for the skybox shader. Also, many desktop hardware video decoders are limited to 4K resolutions and mobile hardware video decoders are often limited to 2K or less, limiting the resolution that can be played back in real time on those platforms. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">3D stereo skyboxes</h1>
                
            
            
                
<p class="calibre3">If you have a 360 image or video with stereo views, for each of the left and right eyes, Unity can now use that too. As of Unity 2017.3, the Panoramic Skybox material supports 3D textures in with a 3D layout. You can specify Side by side or Over under, as shown here:</p>
<div><img src="img/a4bb26a6-bff9-459c-a55a-3be8628c4a59.png" class="calibre24"/></div>
<p class="calibre3">An example 3D stereographic equirectangular over-under image is given in the next topic, where we discuss capturing 360 media within your Unity project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Capturing 360-degrees in Unity</h1>
                
            
            
                
<p class="calibre3">We've talked about using 360-degree media captured using 360 cameras. But what if you wanted to capture a 360 image or video from within your Unity app and share it on the internet? This could be useful for marketing and promoting your VR apps, or just simply using Unity as a content generation tool but using 360 video as the final distribution medium.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Capturing cubemaps and reflection probes</h1>
                
            
            
                
<p class="calibre3">Unity includes support for capturing scene views as part of its lighting engine. A call to <kbd class="calibre13">camera.RenderToCubemap()</kbd> will bake a static cubemap of your scene, using the camera's current position and other settings.</p>
<p class="calibre3">The example script given in the Unity documentation,  <a href="https://docs.unity3d.com/Documentation/ScriptReference/Camera.RenderToCubemap.html" class="calibre10">https://docs.unity3d.com/Documentation/ScriptReference/Camera.RenderToCubemap.html</a>, implements an editor wizard for capturing a cubemap of your scene directly in the Editor, and is included here:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEditor;<br class="title-page-name"/>using System.Collections;<br class="title-page-name"/><br class="title-page-name"/>public class RenderCubemapWizard : ScriptableWizard<br class="title-page-name"/>{<br class="title-page-name"/>    public Transform renderFromPosition;<br class="title-page-name"/>    public Cubemap cubemap;<br class="title-page-name"/><br class="title-page-name"/>    void OnWizardUpdate()<br class="title-page-name"/>    {<br class="title-page-name"/>        string helpString = "Select transform to render from and cubemap to render into";<br class="title-page-name"/>        bool isValid = (renderFromPosition != null) &amp;&amp; (cubemap != null);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void OnWizardCreate()<br class="title-page-name"/>    {<br class="title-page-name"/>        // create temporary camera for rendering<br class="title-page-name"/>        GameObject go = new GameObject("CubemapCamera");<br class="title-page-name"/>        go.AddComponent&lt;Camera&gt;();<br class="title-page-name"/>        // place it on the object<br class="title-page-name"/>        go.transform.position = renderFromPosition.position;<br class="title-page-name"/>        go.transform.rotation = Quaternion.identity;<br class="title-page-name"/>        // render into cubemap<br class="title-page-name"/>        go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);<br class="title-page-name"/><br class="title-page-name"/>        // destroy temporary camera<br class="title-page-name"/>        DestroyImmediate(go);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    [MenuItem("GameObject/Render into Cubemap")]<br class="title-page-name"/>    static void RenderCubemap()<br class="title-page-name"/>    {<br class="title-page-name"/>        ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(<br class="title-page-name"/>            "Render cubemap", "Render!");<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">To run the wizard:</p>
<ol class="calibre15">
<li class="calibre12">Create an Empty game object for the camera position to capture from</li>
<li class="calibre12">Create a cubemap to render into (Assets | Create | Legacy | Cubemap)</li>
<li class="calibre12">Set Face size to a high resolution, such as <kbd class="calibre13">2048</kbd></li>
<li class="calibre12">Check the Readable checkbox</li>
<li class="calibre12">Run the wizard (GameObject | Render into Cubemap)</li>
<li class="calibre12">Drag the position object into the Render From Position slot</li>
<li class="calibre12">Drag cubemap into the Cubemap slot</li>
<li class="calibre12">Press Render!</li>
</ol>
<p class="calibre3">This <kbd class="calibre13">.cubemap</kbd> file can now be used in a Skybox Cubemap material.</p>
<p class="calibre3">A similar but different approach is to use Reflection probes. They're normally used by objects with reflective materials to render realistic surface reflections (see <a href="https://docs.unity3d.com/Manual/class-ReflectionProbe.html" class="calibre10">https://docs.unity3d.com/Manual/class-ReflectionProbe.html</a>). A reflection probe captures a spherical view of its surroundings and is then stored as a cubemap. Scene designers will strategically place multiple reflection probes in a scene to provide more realistic rendering. You can repurpose a reflection probe as a 360 image capture of your scene! Since they're intended for reflection lighting, they're usually low resolution.</p>
<p class="calibre3">Unity chooses where to store the reflection probe lightmap file (<kbd class="calibre13">.exr</kbd>) depending on your lighting settings. To save it under your <em class="calibre14">Assets</em> folder (rather than the GI cache), go to the Lighting tab, disable Realtime Global Illumination, and disable Auto Generate. This will generate the refection probe <kbd class="calibre13">.exr</kbd> file in a folder with the same name as your scene.</p>
<p class="calibre3">Try adding one to your scene by navigating to GameObject | Light | Reflection Probe. Set Resolution to a high value, like <kbd class="calibre13">2048</kbd>. Then, press Bake.  You can then assign this <kbd class="calibre13">.exr</kbd> file to a Skybox Cubemap material, making a quick and easy 360 scene-shot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a third-party package for 360 image capture</h1>
                
            
            
                
<p class="calibre3">There are a number of packages that provide the ability to capture 360 images and video in Unity, including:</p>
<ul class="calibre11">
<li class="calibre12">360 Panorama Capture from eVRydayVR (free) (<a href="https://assetstore.unity.com/packages/tools/camera/360-panorama-capture-38755" class="calibre10">https://assetstore.unity.com/packages/tools/camera/360-panorama-capture-38755</a>)</li>
<li class="calibre12">VR Panorama 360 PRO from OliVR ($49) (<a href="https://assetstore.unity.com/packages/tools/video/vr-panorama-360-pro-renderer-35102" class="calibre10">https://assetstore.unity.com/packages/tools/video/vr-panorama-360-pro-renderer-35102</a>)</li>
<li class="calibre12">Oculus 360-Capture-SDK (free), includes a sample Unity project (<a href="https://github.com/facebook/360-Capture-SDK" class="calibre10">https://github.com/facebook/360-Capture-SDK</a>)</li>
</ul>
<p class="calibre3">Each of these packages support mono and stereoscopic capture, sequenced captures for video encoding, and possibly other features for color conversion, antialiasing, camera image effects, and 3D spatialized audio.</p>
<p class="calibre3">Using the  360 Panorama Capture script from eVRydayVR, for example, to capture a single 360 image, open a scene you want to capture, then:</p>
<ol class="calibre15">
<li class="calibre12">Create an Empty game object, named <kbd class="calibre13">CapturePanorama</kbd>, positioned where you want to make the capture</li>
<li class="calibre12">Add the Capture Panorama script as a component</li>
<li class="calibre12">Press Play, then press <em class="calibre2">P</em> on the keyboard</li>
</ol>
<p class="calibre3">The screen will fade to black, and an image will be captured and saved to your project root directory. The component options are shown here:</p>
<div><img src="img/5594290d-e4aa-4bc6-979b-39cb13e54e2e.png" class="calibre24"/></div>
<p class="calibre3">To capture video, you would enable the Capture Every Frame checkbox. It recommends the open source <em class="calibre14">ffmpeg</em> tool (<a href="https://www.ffmpeg.org/" class="calibre10">https://www.ffmpeg.org/</a>) to assemble the frames and encode the video. See the README file for details.</p>
<p class="calibre3">Of course, this component can also be controlled via scripts, and can be built into your runtime game, not just used in the Editor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity built-in stereo 360 image and video capture </h1>
                
            
            
                
<p class="calibre3">As of Unity 2018.1, Unity includes an integrated stereo 360 image and video capture capability. The feature is based on Google's omni-directional stereo (ODS), described at the beginning of this chapter. Details in this section summarize the Unity Blogs post from January, 2018 (<a href="https://blogs.unity3d.com/2018/01/26/stereo-360-image-and-video-capture/" class="calibre10">https://blogs.unity3d.com/2018/01/26/stereo-360-image-and-video-capture/</a>), which explains how to capture ODS stereo cubemaps and convert them to stereo equirectangular textures.</p>
<p class="calibre3">To capture a scene in Editor or standalone player, call <kbd class="calibre13">camera.RenderToCubemap()</kbd> once per eye. We used this function earlier; there is a variant that takes a <kbd class="calibre13">stereoEye</kbd> parameter, for example:</p>
<pre class="calibre18">camera.stereoSeparation = 0.064; // Eye separation (IPD) of 64mm.<br class="title-page-name"/>camera.RenderToCubemap(cubemapLeftEye, 63, <br class="title-page-name"/>        Camera.MonoOrStereoscopicEye.Left);<br class="title-page-name"/>camera.RenderToCubemap(cubemapRightEye, 63,<br class="title-page-name"/>        Camera.MonoOrStereoscopicEye.Right);</pre>
<p class="calibre3">To convert cubemaps to stereo equirectangular maps, call <kbd class="calibre13">RenderTexture.ConvertToEquirect()</kbd> as follows:</p>
<pre class="calibre18">cubemapLeftEye.ConvertToEquirect(equirect, <br class="title-page-name"/>        Camera.MonoOrStereoscopicEye.Left);<br class="title-page-name"/>cubemapRightEye.ConvertToEquirect(equirect, <br class="title-page-name"/>        Camera.MonoOrStereoscopicEye.Right);</pre>
<p class="calibre3">Using the Unity frame recorder (<a href="https://github.com/Unity-Technologies/GenericFrameRecorder" class="calibre10">https://github.com/Unity-Technologies/GenericFrameRecorder</a>), a sequence of these images can be captured as frames of a stereo 360 video.</p>
<p class="calibre3">To capture in the PC standalone build, you need to enable the 360 Stereo Capture in the Build Settings, as shown here, so Unity generates the shader variants required by this feature:</p>
<div><img src="img/4556c754-2c22-4e95-83db-9c99e7aa2557.jpg" class="calibre83"/></div>
<p class="calibre3">Here is an example of a resulting stereo equirectangular video capture (from the Unity blog, <a href="https://blogs.unity3d.com/wp-content/uploads/2018/01/image5-2.gif" class="calibre10">https://blogs.unity3d.com/wp-content/uploads/2018/01/image5-2.gif</a>): </p>
<div><img src="img/4e293df6-c23e-4662-9b62-1b95e06258fb.jpg" class="calibre24"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="calibre3">360-degree media is compelling because VR hacks your field of view (FOV). The view you see is updated in real time as you move your head around, making it seem to have no edges. We started this chapter by describing what 360-degree images are, and how the surface of a sphere would be flattened (projected) into a 2D image, and equirectangular projections in particular. Stereo 3D media includes separate equirectangular views for the left and right eyes.</p>
<p class="calibre3">We began exploring this in Unity by simply mapping a regular image on the outside of a sphere, and were perhaps frightened by the distortions. Then, we saw how an equirectangular texture covers the sphere evenly. Next, we inverted the sphere with a custom shader, mapping the image inside the sphere, making it a 360 photosphere viewer. And, we added video.</p>
<p class="calibre3">Then, we looked at using skyboxes instead of a game object for rendering 360 media. We saw how Unity supports cubemaps and spherical panoramas, video skyboxes, and 3D stereo skyboxes too.  Lastly, we explored capturing 360 media from within your Unity scenes using third-party packages and Unity's built-in API. </p>
<p class="calibre3">In the next chapter, we consider an important application of virtual reality, for storytelling. Using the animation and cinematic editing feature of Unity, we build a short VR cinematic experience.</p>
<p class="calibre3"> </p>
<p class="calibre3"> </p>


            

            
        
    </body></html>