- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Masks, Scrollbars, and Scroll Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve learned how to make UI that has all of its components visible on the screen
    at once, but often you will have UI elements that are off-screen or off-menu and
    not visible until you navigate to them or reveal them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use masks to hide portions of UI Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Scrollbars and accessing their properties via code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the UI Scroll View to create scrollable menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a settings menu with a mask and scrolling text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the examples shown in this chapter can be found within the Unity project
    provided in the code bundle. They can be found within the scene labeled **Chapter12**.
  prefs: []
  type: TYPE_NORMAL
- en: Each example image has a caption stating the example number within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the scene, each example is on its own Canvas, and some of the Canvases are
    deactivated. To view an example on a deactivated Canvas, simply select the checkbox
    next to the Canvas’ name in the **Inspector**. Each Canvas is also given its own
    Event System. This will cause errors if you have more than one Canvas activated
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2012](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2012)'
  prefs: []
  type: TYPE_NORMAL
- en: Using masks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Masks affect the visibility of objects within their shape. If an object is affected
    by a mask, any part of it outside the mask’s restricted area will be invisible.
    The visible area of a mask can either be determined by an Image with the **Mask**
    component or a Rect Transform with the **Rect Mask** **2D** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'With UI, masking can be used for scrolling menus, so items that exist outside
    of the menu’s area will not be visible. It is also used to *cut out* images. For
    example, the following image shows a cat’s image being cut out by a circular mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Circular Mask Example in the Chapter12 scene](img/B18327_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Circular Mask Example in the Chapter12 scene'
  prefs: []
  type: TYPE_NORMAL
- en: You may note that the edges of the cat with the mask don’t look great. To avoid
    this, ensure that you use sprites with appropriate image resolutions and try different
    filtering modes on the Sprite’s **Import Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: The Mask component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Mask** component can be added to any UI object with an **Image** component.
    If it is added to a UI object that doesn’t have an **Image** component, it won’t
    function since it needs an **Image** to determine the restricted area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Mask** component can be added to a UI object by selecting **Add Component**
    | **UI** | **Mask** within the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: The Mask component](img/B18327_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The Mask component'
  prefs: []
  type: TYPE_NORMAL
- en: Any children of the UI object containing the **Mask** component will then have
    their visibility restricted to only the area within the opaque area of the **Source
    Image** on its **Image** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, the object named `Mask` is a UI Image with a **Mask**
    component added to it. As you can see, the purple triangle on the left of the
    Panel is only partially visible, while the green triangle on the right is fully
    visible. The green triangle is fully visible because it is not a child of the
    UI Image that contains a **Mask** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: The Mask Component Example in the Chapter12 scene](img/B18327_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The Mask Component Example in the Chapter12 scene'
  prefs: []
  type: TYPE_NORMAL
- en: You have the option to hide the **Source Image** that defines the **Mask** component’s
    visibility area. If you deselect **Show Mask Graphic**, the parent’s **Source
    Image** will not be visible. It’s important to note that changing the opacity
    on the **Source Image** does not affect the **Mask** component’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Rect Mask 2D component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the **Mask** component allows you to restrict the visible area to a non-rectangular
    shape. However, if you want to restrict the visible area to a rectangular shape
    and don’t want to use an image to restrict the visible area, you can use a **Rect
    Mask** **2D** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rect Mask 2D component can be added to a UI Object by selecting **Add Component**
    | **UI** | **Rect Mask 2D** within the **Inspector**, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: A Rect Mask 2D component](img/B18327_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: A Rect Mask 2D component'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the component allows you to adjust **Padding** and **Softness**.
  prefs: []
  type: TYPE_NORMAL
- en: When a **Rect Mask 2D** component is added to a GameObject, the visibility of
    its children will be affected by the shape of its Rect Transform. An **Image**
    component is not required on the parent object for the **Rect Mask 2D** component
    to function properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, an `Empty` UI GameObject is created and a **Rect Mask
    2D** component is added to it. It is then given a child UI Image. As you can see,
    the triangle is masked by the Rect Transform area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: A Rect Mask 2D Component Example in the Chapter12 scene](img/B18327_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: A Rect Mask 2D Component Example in the Chapter12 scene'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to apply a mask to a rectangular shape, I highly recommend that
    you use the **Rect Mask 2D** component rather than the standard **Mask** component,
    as it is more performant.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that, as implied by the name **Rect Mask 2D**, this mask
    will only work on 2D objects. You can read more about its limitations at [https://docs.unity3d.com/Manual/script-RectMask2D.xhtml](https://docs.unity3d.com/Manual/script-RectMask2D.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: As I stated earlier, one common use for a mask is to create a menu with objects
    that *spill out* of the visible area. Creating these types of menus requires scrollbars
    and scroll views, so let’s look at those components now.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UI Scrollbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **UI Scrollbar** object allows the user to drag a handle along a path. The
    position of the handle on the path affects the position of an image or object
    within a usable area.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having trouble seeing what a scroll bar is from the preceding description,
    here’s an easier explanation with context. It is most commonly used in video games
    with menus that have a lot of information within a viewable area that is smaller
    than the area that all the information takes up.
  prefs: []
  type: TYPE_NORMAL
- en: To create a UI Scrollbar, select `Sliding Area`. The `Sliding Area` also has
    a child named `Handle`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Sliding Area` child is an empty GameObject. Its purpose is to ensure that
    its child, the `Handle`, is correctly positioned and aligned. The `Handle` is
    a UI Image. It represents the interactable area of the Scrollbar.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change the appearance of the Scrollbar’s background and `Handle`,
    you need to change the `Handle` child, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The Scrollbar component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent Scrollbar object has a **Scrollbar** component. It has all the properties
    common to the interactable UI objects, along with a few that are exclusive to
    Scrollbars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: The properties of the Scrollbar component](img/B18327_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: The properties of the Scrollbar component'
  prefs: []
  type: TYPE_NORMAL
- en: A Scrollbar’s `0` and `1`. Scrollbars are used to move objects that take up
    more room than the viewable space. Due to this, the Scrollbar’s position should
    easily translate to a percentage or a value between `0` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Handle` is assigned to this property. You›ll note that the Rect Transform
    component on the `Handle` GameObject has the `Handle` is affected by the Scrollbar.
    The position of the Scrollbar’s `Handle` is tied to the **Value** property of
    the **Scrollbar** component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: The Rect Transform component on the Handle GameObject](img/B18327_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: The Rect Transform component on the Handle GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Direction** property allows you to select the orientation of the Scrollbar.
    The available options are the same as with a Slider and translate accordingly:
    **Left To Right**, **Right To Left**, **Bottom To Top**, and **Top** **To Bottom**.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Sliding Area` taken up by the Scrollbar’s `Handle`. This can be any `float`
    value from `0` to `1`. I recommend that you choose a value relative to the size
    of the objects being scrolled so that the Scrollbar’s movement feels more intuitive.
    This means that the larger the scrollable area is, the smaller the Scrollbar `Handle`
    becomes.
  prefs: []
  type: TYPE_NORMAL
- en: The **Number of Of Steps** property is used if you want the Scrollbar to have
    staggered, discrete steps and don’t want it to have continuously controlled movement.
    This is used if you want your scrollbar to move the scrolling objects to specific
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you will see a scroll area represented by dots (like the dots that identify
    which home screen you are viewing on an iOS device). This can be achieved using
    a `0`. Setting this value to `0` will allow for continuously controlled movement
    rather than staggered discrete steps.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of creating continuous and discrete Scrollbars are provided in the
    *Examples* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scrollbar default event – On Value Changed (Single)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Handle` is moved. It can accept a `float` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a public function has a `float` parameter, it will appear twice within
    the function’s dropdown list of **On Value Changed (Single)** events: once within
    a **Static Parameters** list and again within the **Dynamic float** list, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: Static Parameters and Dynamic float methods](img/B18327_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Static Parameters and Dynamic float methods'
  prefs: []
  type: TYPE_NORMAL
- en: If the function is selected from the `float` as an argument within the event.
    The event will then only send the value within that box. In the example shown
    in the following screenshot, the only value that will ever be sent to the `ScrollbarWithParameter()`
    function will be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Example of a Static Parameters method in the Inspector](img/B18327_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Example of a Static Parameters method in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: If you want the Scrollbar’s value to be sent as an argument to a function that
    has a parameter, you must select the function from the **Dynamic** **float** list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions and image represent the Scrollbar example found in
    the `Chapter12` scene that triggers events that call functions with and without
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, the third option shows the function chosen from
    the **Dynamic float** list and will send the value of the **Value** property as
    an argument to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: Events on Scrollbar Example in the Chapter12 scene](img/B18327_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Events on Scrollbar Example in the Chapter12 scene'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed how to implement a UI Scrollbar in Unity, let’s look
    at UI Scroll Views.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UI Scroll View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **UI Scroll View** object creates a scrollable area along with two child
    UI Scrollbars. The scrollable area can be scrolled using the scrollbars, by dragging
    the area within the Scroll View, or using the scroll wheel on the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: To create a UI Scroll View, select `Viewport`, `Scrollbar Horizontal`, and `Scrollbar
    Vertical`. The `Viewport` object also has a child named `Content`. The `Scrollbar
    Horizontal` and `Scrollbar Vertical` children have the same parent/child relationship
    as default UI Scrollbars, as discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the UI Scroll View comes with two `Scrollbar` children by default,
    you don’t have to use both Scrollbars with your `Scroll View`. In fact, you don’t
    have to use Scrollbars at all! Refer to the *Scroll Rect component* section for
    further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Viewport` child object is a UI Image with a `Viewport` has the `Viewport`
    applies a mask to an area within the `Scroll View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18327_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: A UI Scroll View Viewport'
  prefs: []
  type: TYPE_NORMAL
- en: This will make the items within the `Scroll View` only viewable within the defined
    area (between the Scrollbars). You cannot change most of the `Viewport`, because
    this area is set based on how you have the settings of your `Scroll View` set
    in its **Scroll Rect** component (refer to the *Implementing UI Scrollbar* section
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: The child of `Viewport` is an empty `Rect Transform` named `Content`. This will
    act as the holder of all the items you wish to place within `Scroll View`. You
    can think of the `Content` as the things that will be moving around within the
    `Scroll View`. As you can see from the following image, the Rect Transform of
    `Content` is larger than the viewable area defined by `Viewport`, since the objective
    of a `Scroll View` is to have items outside of the viewable area.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: A UI Scroll View Content](img/B18327_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: A UI Scroll View Content'
  prefs: []
  type: TYPE_NORMAL
- en: To add items to the `Scroll View`, you simply add children to the `Content`
    object. Since `Content` is a child of `Viewport`, any of its children will also
    be affected by the `Viewport`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows four images added as children of `Content`. `Content`
    has also been given a **Vertical Layout** **Group** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: A Scroll View example in the Chapter13 scene](img/B18327_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: A Scroll View example in the Chapter13 scene'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, you can see that when the `Viewport`, all items are
    visible. When you are setting up your `Scroll View`, I highly recommend that you
    disable the `Viewport` so that you can see the general layout of the items you
    are placing and re-enable it when you are done laying out all the items.
  prefs: []
  type: TYPE_NORMAL
- en: You should also adjust the Rect Transform area of `Content` to enclose all of
    its child items or use a `Content` does not fully encompass all the items, scrolling
    the `Scroll View` may not show the items outside of its viewable area.
  prefs: []
  type: TYPE_NORMAL
- en: '`Scroll View` contains an `Scroll View` (the gray rectangle that encapsulates
    everything), change the `Scroll View`. You can change the appearance of the Scrollbars
    by adjusting the appearance of the `Scrollbar Horizontal` and `Scrollbar Vertical`
    children, as described in the *Implementing UI* *Scrollbar* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the intent and setup of a Scroll Rect, let’s look at
    the individual properties of the Scroll Rect component.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll Rect component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The behavior of the `Scroll View` is determined by the Scroll Rect component
    on the Scroll View parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: The Scroll Rect component](img/B18327_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: The Scroll Rect component'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Scroll Rect component doesn’t have the **Interactable**, **Transition**,
    or **Navigation** properties that all the other UI components in this chapter
    (and previous chapters) have!
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss the properties slightly out of order to make them easier to discuss.
  prefs: []
  type: TYPE_NORMAL
- en: The `Content` by default. The `Viewport` by default.
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating a scrollable area without using the UI Scroll View, the
    **Viewport** and **Content** properties must be assigned and the Rect Transform
    assigned to **Viewport** must be a parent of the Rect Transform assigned to **Content**,
    for the **Scroll Rect** component to function property.
  prefs: []
  type: TYPE_NORMAL
- en: Movement properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three properties related to how the `Content` in the `Scroll View`
    will move. The `Scroll View` moves at its boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: There are three `Content`.
  prefs: []
  type: TYPE_NORMAL
- en: When `Content`. The `Content` once the edges of Rect Transform of `Content`
    have been reached. However, when `Content`.
  prefs: []
  type: TYPE_NORMAL
- en: When `Content` is dragged past its boundary, it will bounce into place once
    the player stops dragging. This will also bounce if the scroll wheel is used.
    When **Elastic** is selected, the subproperty **Elasticity** becomes accessible.
    The **Elasticity** property determines the intensity of the bounce.
  prefs: []
  type: TYPE_NORMAL
- en: When **Clamped** is selected as the **Movement Type**, the Content will not
    be draggable past its boundary and no bounce will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Properties concerning scrolling speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selecting the `Content` continue to move after the player has stopped dragging.
    `Content` movement initialized by the Scrollbars or mouse scroll wheel. When `Content`
    will stop moving after the player has ceased dragging. A `0` will stop the `Content`
    the instant the player stops dragging, and a `1` will never stop. By default,
    `0.135`.
  prefs: []
  type: TYPE_NORMAL
- en: The **Scroll Sensitivity** property determines how far the Content will move
    with each turn of the scroll wheel. The higher the number, the further the content
    will move with a turn, making it appear to move more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to disable the use of the mouse scroll wheel for the Scroll View,
    set `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of the Scrollbars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can set properties for the way your horizontal and vertical scrollbars react
    separately. The `Scrollbar Horizontal` child and `Scrollbar Vertical` child, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you only want to use drag on the Scroll View area and don’t want scrollbars,
    you can simply set the `None` or delete the `Scrollbar Horizontal` and `Scrollbar
    Vertical` objects from the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Under each Scrollbar assignment, you can set the **Visibility** and **Spacing**
    properties of the respective Scrollbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Visibility** property has three options: **Permanent**, **Auto Hide**,
    and **Auto Hide And Expand Viewport**. When **Permanent** is selected for the
    **Visibility** property, the respective Scrollbar will remain visible, even if
    it is not needed, if its corresponding movement is allowed. For example, as shown
    in the following screenshot, if **Horizontal** movement is allowed, and the **Horizontal
    Scrollbar**’s **Visibility** is set to **Permanent**, the respective scrollbar
    will be visible, even though it is not necessary (no horizontal movement can be
    achieved):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15: Adjusting the Scrollbars in the Scroll Rect](img/B18327_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.15: Adjusting the Scrollbars in the Scroll Rect'
  prefs: []
  type: TYPE_NORMAL
- en: However, referencing the same image, you can see that if **Horizontal** movement
    is deactivated, setting the **Horizontal Scrollbar**’s **Visibility** to **Permanent**
    removes it from the Scroll View entirely. It is also deactivated in the **Hierarchy**.
  prefs: []
  type: TYPE_NORMAL
- en: When **Auto Hide** is selected for the **Visibility** property, the respective
    Scrollbar will become invisible and deactivate in the **Hierarchy** when the game
    is played if it is not needed (meaning that there is no movement in that direction
    required) or if the respective axis movement is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: The `Viewport` object has a **Mask** component, this will cause the mask’s area
    to expand to cover the area that was initially being taken up by the Scrollbar.
  prefs: []
  type: TYPE_NORMAL
- en: The `-3`, which means the two Rect Transforms overlap slightly. If you want
    to change the position of the **Viewport**, you have to do so with this property,
    since the properties related to the **Viewport**’s position are disabled in its
    Rect Transform component.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll Rect default event – On Value Changed (Vector2)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Scroll Rect component’s default event is the `Content` area of the `Scroll
    View` is moved by dragging, scrolling with the mouse scroll wheel, or scrolling
    with one of the Scrollbars. It accepts a `Vector2` position as an argument and,
    as with the other events discussed in this chapter, you can choose to pass no
    argument, a static argument, or a dynamic argument.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to send the `Vector2` position of `Content` to a function, you’d
    send it to a function with a `Vector2` parameter from the `1.0` in the corresponding
    coordinate and the last position having a value of `0.0` in the corresponding
    coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the previous function is selected from the `Vector2` values printed in the
    **Console**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16: Values of the Scroll Rect based on position](img/B18327_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.16: Values of the Scroll Rect based on position'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at the various UI elements, let’s look at some examples
    of implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned earlier in this chapter that a common usage of masks and scroll
    views is a menu with multiple items in it. So, for this chapter, we’ll only create
    one example, a scroll view from a pre-existing menu, by mimicking the layout of
    the Scroll View UI object.
  prefs: []
  type: TYPE_NORMAL
- en: Making a scroll view from a pre-existing menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help organize the project, duplicate the `Chapter11-Examples` scene that
    you created in the last chapter; rename it `Chapter12-Examples`. Open `Chapter12-Examples`
    and complete the following example within that scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to be able to add more items to my `Inventory Panel` and allow the player
    to scroll through the items. I could create a new UI Scroll View item and update
    it to look like my current `Inventory Panel`, but that would be more hassle than
    it’s worth. So, instead, I will convert the current `Inventory Panel` to a scrollable
    view. After it is complete, it will look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17: The scrollable menu we will build](img/B18327_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.17: The scrollable menu we will build'
  prefs: []
  type: TYPE_NORMAL
- en: This Panel can have its view adjusted by dragging the area beside the food items.
    I could have added a vertical scrollbar to control the movement, but I wanted
    to show you how simple it is to make a draggable area without one. It also just
    looks a little nicer without a scrollbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the `Inventory Panel` scrollable, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the `Pause Panel` is in the way. Let’s disable it by deselecting
    the checkbox in its `Inventory Panel` more easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the scrollable view to really work, we need more items in our inventory.
    Select all the children of `Inventory Holder` named `Item Holder` and duplicate
    them with *Ctrl* + *D*. Now, with all the duplicates selected, rename them `Item
    Holder`, so we don’t have the numbered suffix added to each of them. You should
    now have twice as many items in your `Inventory Holder`, and you should see the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.18: The result after Step 2](img/B18327_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.18: The result after Step 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a scrollable view, we need to add a few more items to the scene that
    can be parents of the content we want to scroll. There is a very specific parent/child
    relationship you want to follow with each item having the specific components
    to create a scrollable view, as demonstrated in the following diagram:![Figure
    12.19: The Hierarchy layout to create a scrollable menu](img/B18327_12_19.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.19: The Hierarchy layout to create a scrollable menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s start with the object that will hold the `Inventory Panel`, right-click,
    and select `Inventory Panel`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rename the new item `Scroll Rect` and reposition it in the `Inventory Banner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the `Scroll Rect` GameObject the **Scroll Rect** component, with **Add
    Component** | **UI** | **Scroll Rect** in its Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s create the item that will hold the `Scroll Rect` and select `Scroll
    Rect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new Image `Viewport`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Inventory Holder` is visually in the way right now, so disable it momentarily.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `uiElements_38` image to the `Viewport`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the Rect Transform of `Scroll Rect` so that it stretches to fill its
    parent’s Rect Transform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.20: The Rect Transform of the Scroll Rect object](img/B18327_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.20: The Rect Transform of the Scroll Rect object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjust the Rect Transform properties of `Viewport`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.21: The Rect Transform of the Scroll Rect object](img/B18327_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.21: The Rect Transform of the Scroll Rect object'
  prefs: []
  type: TYPE_NORMAL
- en: Give `Viewport` the **Mask** component, with **Add Component** | **UI** | **Mask**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-enable `Inventory Holder` and rename it `Content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the alpha of the `Content` to `0` so that the background is invisible.
    You should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.22: The results of Step 11](img/B18327_12_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.22: The results of Step 11'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag `Content` in the `Viewport`. Doing so should make the mask instantly
    apply to all of the children of `Content`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.23: The results of Step 12](img/B18327_12_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.23: The results of Step 12'
  prefs: []
  type: TYPE_NORMAL
- en: 'Position `Content` so that the food at the top of the list appears fully within
    the Mask area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.24: How to position the Content](img/B18327_12_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.24: How to position the Content'
  prefs: []
  type: TYPE_NORMAL
- en: Now, all that is left to do is to have a properly functioning scrollable area
    to set up the properties on the `Scroll Rect` and drag `Content` and `Viewport`
    into their appropriate slots on the `Scroll` `Rect` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Disable **Horizontal** movement because we only want the menu to move vertically.
    Set **Movement Type** to **Clamped** so that the menu doesn’t stretch and bounce
    and stays within the appropriate bounds. Your **Scroll Rect** component should
    now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.25: Assigning the Content and Viewport](img/B18327_12_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.25: Assigning the Content and Viewport'
  prefs: []
  type: TYPE_NORMAL
- en: Re-enable the `Pause Menu` object so that our `Pause Menu` will function in
    the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play the game, the `Inventory Panel` should now have items that scroll
    when you drag beside them. Remember that you bring up the `Inventory Panel` by
    pressing the *I* key on your keyboard. As we have drag and drop functionality
    on our individual items, to scroll, we have to drag the area of `Content` that
    does not have a food item on it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered how to hide the visibility of UI elements as well as use
    Scroll Views to create containers that hold more items than the screen can hold
    at one time. There are still quite a few more interactable UI elements, however.
    In the next chapter, we will look at the remaining interactive UI elements provided
    by the Unity UI system.
  prefs: []
  type: TYPE_NORMAL
