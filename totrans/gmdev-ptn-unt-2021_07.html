<html><head></head><body>
        

                            
                    Managing Character States with the State Pattern
                
            
            
                
<p class="mce-root">In video games, entities continually transition from one state to another depending on player inputs or events. An enemy character might go from an idle state to an attack state depending on whether it spots the player moving across the map. A player character is constantly blending from one animation to another as it responds to the player inputs. In this chapter, we will review a pattern that permits us to define the individual states of an entity and its stateful behaviors.</p>
<p class="mce-root">To start, we will use the traditional State pattern to manage the individual finite states of our main character. In the context of our racing game project, the main character is a motorcycle, so it has a set of mechanical behaviors and animations. As we progress in our implementation of the State pattern, we will soon see its limitations, which we will overcome by introducing FSM (Finite State Machine) concepts.</p>
<p class="mce-root">We will not write an FSM by hand, but instead explore the native state machine implementation in Unity's native animation system. Therefore, this chapter will provide a two-fold approach, an introduction to the core concepts of the State pattern, and how to repurpose Unity's animation system to manage character states and animations.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>An overview of the State pattern</li>
<li>Implementation of the State pattern to manage the main character's states</li>
</ul>
<h1 id="uuid-7bdda008-ce21-4331-954a-f88df217df5a">Technical requirements</h1>
<p class="mce-root">This chapter is hands-on. You will need to have a basic understanding of Unity and C#. </p>
<p class="mce-root">The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05</a>.<a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2020"/></p>
<p class="mce-root">Check out the following video to see the code in action: <a href="https://bit.ly/36EbbHe">https://bit.ly/36EbbHe</a></p>
<h1 id="uuid-9a3798b7-72b2-4ddb-b1e7-392e6404aba2">An overview of the State pattern</h1>
<p>We use the State design pattern to implement a system that will permit an object to change its behavior based on its internal state. Thus, a change of context will bring on a change of behavior.</p>
<p>The State pattern has three core participants in its structure:</p>
<ul>
<li>The <kbd>Context</kbd> class defines an interface that permits a client to request a change in the internal state of an object. It also holds a pointer to the current state.</li>
<li>The <kbd>IState</kbd> interface establishes an implementation contract for the concrete state classes.</li>
<li>The <kbd>ConcreteState</kbd> classes implement the <kbd>IState</kbd> interface and expose a public method named <kbd>handle()</kbd> that the <kbd>Context</kbd> object can call to trigger the state's behavior.</li>
</ul>
<p class="CDPAlignLeft CDPAlign">Let's now review a diagram of this pattern definition, but in the context of an actual implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e7163ee9-b7f9-4b58-8e2f-190b406eab17.png" style="width:52.83em;height:29.25em;"/></p>
<p>Figure 5.1 – UML diagram of the State pattern</p>
<p class="CDPAlignLeft CDPAlign">To update an object's state, the client can set the expected state through the <kbd>Context</kbd> object and request a transition to the new state. Thus, the context is always aware of the current state of the object it handles. However, it doesn't need to be acquainted with each of the concrete state classes that exist. We can add as many state classes as we wish without modifying a single line of code in the <kbd>Context</kbd> class.</p>
<p class="mce-root">For example, this approach scales better than defining all our states in a single class and managing the transition between them with a switch case, as we can see in the following pseudo-code example:</p>
<pre>public class BikeController<br/>{<br/>  ....  <br/>    switch (state)<br/>    {<br/>        case StopState:<br/>            ...<br/>            break;<br/>        case StarState:<br/>            ...<br/>            break;<br/>        case TurnState:<br/>            ...<br/>            break;<br/>}</pre>
<p>Now that we have a basic understanding of the structure of the State pattern, we can start defining the states and behaviors of our main character, in this case, the bike, as we are going to see in the next section.</p>
<h1 id="uuid-e3ef7afc-9c34-4a9e-a227-c9eee1803b34">Defining character states</h1>
<p>In our game, the entity that will transition between states the most is our racing bike. It's under the player's control; it interacts with almost every element in the environment, including obstacles and enemy drones. Therefore, it will never stay in the same state for long. </p>
<p>The following diagram showcases a shortlist of finite states for our bike:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/25554af1-79f0-40a6-8a49-e3e7e94b8da8.png" style="width:51.50em;height:23.75em;"/></p>
<p>Figure 5.2 – Diagram illustrating the finite states of the bike</p>
<p>And now let's define some expected behaviors for some of the listed states:</p>
<ul>
<li><strong>Stop</strong>: In this state, the bike is not moving. Its current speed is at zero. Its gears are set to neutral. If we decide that the engine should be on, but running in idle mode in that state, we could have an animation of the chassis of the bike vibrating to show that the motor is running.</li>
<li><strong>Start</strong>: In this state, the bike moves at full speed, and the wheels turn to match the forward motion.</li>
<li><strong>Turn</strong>: In the turning state, the bike turns to the left or to the right, depending on the player's input. </li>
<li><strong>Crash</strong>: If the bike is in a crash state, it means it's on fire and on its side. The vehicle will no longer respond to the player's input.</li>
</ul>
<p>These are just unpolished definitions of potential states for our vehicle. We could go as granular and specific as we wish, but for our use case, it's enough.</p>
<p>It is necessary to keep in mind that each definition of a state contains the description of behavior and animations. These requirements will be essential to consider when we write and review our implementation of the State pattern in the next section of this chapter.</p>
<h1 id="uuid-3d9aa39a-db14-4944-846b-fd5ac496195b">Implementing the State pattern</h1>
<p>In this part of the chapter, we will implement the State pattern with the explicit goal of encapsulating the expected behaviors of each of the vehicle's finite states that we defined in the previous section.</p>
<p class="mce-root">We are going to focus on writing minimalist skeleton classes for reasons of brevity and clarity. This approach will permit us to focus on the pattern's structure without being bogged down by implementation details.</p>
<p class="mce-root">It's also important to note that the version of the State pattern presented in this book might be slightly unorthodox as it deviates somewhat from traditional approaches. Therefore, it should be considered a permutation of the State pattern adapted to the context of a Unity project and for a specific use case.</p>
<h2 id="uuid-fa9bfa43-48b9-460c-94a6-d5fc524b728d">Implementing the State pattern</h2>
<p>We are going to review our code example in several steps:</p>
<ol>
<li>Let's start by writing down the main interface that each of our concrete state classes will implement:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.State<br/>{<br/>    public interface IBikeState<br/>    {<br/>        void Handle(BikeController controller);<br/>    }<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">We should note that we are passing an instance of <kbd>BikeController</kbd> in the <kbd>Handle()</kbd> method. This approach permits state classes to access public properties of <kbd>BikeController</kbd>. This approach might deviate slightly from tradition as usually, it's the <kbd>Context</kbd> object that gets passed to the states.</p>
<p style="padding-left: 60px" class="mce-root">However, nothing stops us from passing both the <kbd>Context</kbd> object and the instance of <kbd>BikeController</kbd> to the state classes. Alternatively, we could set an instance reference to <kbd>BikeController</kbd> when we initialize each state class.</p>
<p style="padding-left: 60px" class="mce-root">However, it was just simpler to do, as we are going to do for this use case.</p>
<ol start="2">
<li>Now that we have our interface, let's implement the context class:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.State<br/>{<br/>    public class BikeStateContext<br/>    {<br/>        public IBikeState CurrentState<br/>        {<br/>            get; set;<br/>        }<br/><br/>        private readonly BikeController _bikeController;<br/><br/>        public BikeStateContext(BikeController bikeController)<br/>        {<br/>            _bikeController = bikeController;<br/>        }<br/><br/>        public void Transition()<br/>        {<br/>            CurrentState.Handle(_bikeController);<br/>        }<br/><br/>        public void Transition(IBikeState state)<br/>        {<br/>            CurrentState = state;<br/>            CurrentState.Handle(_bikeController);<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As we can see, the <kbd>BikeStateContext</kbd> class exposes a public property that points to the current state of the bike; thus, it's aware of any state change. Therefore, we could update the current state of our entity through its property and transition into it by calling the <kbd>Transition()</kbd> method.</p>
<p style="padding-left: 60px" class="mce-root">For instance, this mechanism is beneficial if we wanted to link states together by letting each state class declare the next one in the chain. Then, we could cycle through the linked states by simply calling the <kbd>Transition()</kbd> method of the <kbd>Context</kbd> object. However, this approach won't be necessary for our use case, as we will call the overloaded <kbd>Transition()</kbd> method and simply pass the state in which we want to transition.</p>
<ol start="3">
<li>Next up is <kbd>BikeController</kbd>. This class initializes the <kbd>Context</kbd> object and the states, and it also triggers state changes:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.State {<br/>    public class BikeController : MonoBehaviour {<br/><br/>        public float maxSpeed = 2.0f;<br/>        public float turnDistance = 2.0f;<br/><br/>        public float CurrentSpeed { get; set; }<br/><br/>        public Direction CurrentTurnDirection {<br/>            get; private set;<br/>        }<br/><br/>        private IBikeState <br/>            _startState, _stopState, _turnState;<br/><br/>        private BikeStateContext _bikeStateContext;<br/><br/>        private void Start() {<br/>            _bikeStateContext = <br/>                new BikeStateContext(this);<br/><br/>            _startState = <br/>                gameObject.AddComponent&lt;BikeStartState&gt;();<br/>            _stopState = <br/>                gameObject.AddComponent&lt;BikeStopState&gt;();<br/>            _turnState = <br/>                gameObject.AddComponent&lt;BikeTurnState&gt;();<br/><br/>            _bikeStateContext.Transition(_stopState);<br/>        }<br/><br/>        public void StartBike() {<br/>            _bikeStateContext.Transition(_startState);<br/>        }<br/><br/>        public void StopBike() {<br/>            _bikeStateContext.Transition(_stopState);<br/>        }<br/><br/>        public void Turn(Direction direction) {<br/>            CurrentTurnDirection = direction;<br/>            _bikeStateContext.Transition(_turnState);<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">If we didn't encapsulate the behaviors of the bike inside individual state classes, we would probably implement them inside <kbd>BikeController</kbd>. This approach would have likely resulted in a bloated controller class that's difficult to maintain. Therefore, by using the State pattern, we are making our classes smaller and easier to maintain.</p>
<p style="padding-left: 60px" class="mce-root">And we are also giving back to <kbd>BikeController</kbd> its original responsibilities of controlling the bike's core components. It exists to offer an interface to control the bike, expose its configurable properties, and manage its structural dependencies.</p>
<ol start="4">
<li>The following three classes are going to be our states; they are quite self-explanatory. Notice that each implements the <kbd>IBikeState</kbd> interface. Let's start with <kbd>BikeStopState</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.State<br/>{<br/>    public class BikeStopState : MonoBehaviour, IBikeState<br/>    {<br/>        private BikeController _bikeController;<br/><br/>        public void Handle(BikeController bikeController)<br/>        {<br/>            if (!_bikeController)<br/>                _bikeController = bikeController;<br/><br/>            _bikeController.CurrentSpeed = 0;<br/>        }<br/>    }<br/>}</pre>
<ol start="5">
<li>The next state class is <kbd>BikeStartState</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.State<br/>{<br/>    public class BikeStartState : MonoBehaviour, IBikeState<br/>    {<br/>        private BikeController _bikeController;<br/><br/>        public void Handle(BikeController bikeController)<br/>        {<br/>            if (!_bikeController)<br/>                _bikeController = bikeController;<br/><br/>            _bikeController.CurrentSpeed = <br/>                _bikeController.maxSpeed;<br/>        }<br/><br/>        void Update()<br/>        {<br/>            if (_bikeController)<br/>            {<br/>                if (_bikeController.CurrentSpeed &gt; 0)<br/>                {<br/>                    _bikeController.transform.Translate(<br/>                        Vector3.forward * (<br/>                            _bikeController.CurrentSpeed * <br/>                            Time.deltaTime));<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>And lastly, there is <kbd>BikeTurnState</kbd>, which makes the bike turn left or right:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.State<br/>{<br/>    public class BikeTurnState : MonoBehaviour, IBikeState<br/>    {<br/>        private Vector3 _turnDirection;<br/>        private BikeController _bikeController;<br/><br/>        public void Handle(BikeController bikeController)<br/>        {<br/>            if (!_bikeController)<br/>                _bikeController = bikeController;<br/><br/>            _turnDirection.x = <br/>                (float) _bikeController.CurrentTurnDirection;<br/><br/>            if (_bikeController.CurrentSpeed &gt; 0)<br/>            {<br/>                transform.Translate(_turnDirection *<br/>                                    _bikeController.turnDistance);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<ol start="7">
<li>For our final class, <kbd>BikeController</kbd> references an enum named <kbd>Direction</kbd>, which we will implement here:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.State<br/>{<br/> public enum Direction<br/> {<br/> Left = -1,<br/> Right = 1<br/> }<br/>}</pre>
<p>We now have all our ingredients ready to test our State pattern implementation.</p>
<h2 id="uuid-82f2683c-5520-4e1d-9189-14d5758e1daa">Testing the State pattern implementation</h2>
<p>To quickly test our implementation of the State pattern in your own instance of Unity, you need to follow these steps:</p>
<ol>
<li>Copy all the scripts we just reviewed inside your Unity project.</li>
<li>Create a new empty scene.</li>
<li>Add a 3D GameObject to the scene, such as a cube, ensuring that it's visible to the main camera.</li>
<li>Attach the <kbd>BikeController</kbd> script to the GameObject.</li>
<li>Also attach the following client script to the GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.State<br/>{<br/>    public class ClientState : MonoBehaviour<br/>    {<br/>        private BikeController _bikeController;<br/><br/>        void Start()<br/>        {<br/>            _bikeController =<br/>                (BikeController)<br/>                FindObjectOfType(typeof(BikeController));<br/>        }<br/><br/>        void OnGUI() <br/>        {<br/>            if (GUILayout.Button("Start Bike"))<br/>                _bikeController.StartBike();<br/>            <br/>            if (GUILayout.Button("Turn Left"))<br/>                _bikeController.Turn(Direction.Left);<br/>            <br/>            if (GUILayout.Button("Turn Right"))<br/>                _bikeController.Turn(Direction.Right);<br/>            <br/>            if (GUILayout.Button("Stop Bike"))<br/>                _bikeController.StopBike();<br/>        }<br/>    }<br/>}</pre>
<p>Once you start the scene, you should see the following GUI buttons on your screen, which you can use to control the GameObject by triggering state changes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f5ed8b4c-d1d7-4a42-a1ce-d2f84c6d4ed1.png" style="width:63.08em;height:38.50em;"/></p>
<p>Figure 5.3 – Screenshot of the code example in action</p>
<p>In the next section of the book, we are going to review the benefits of the State pattern, but also its limitations.</p>
<h1 id="uuid-76fc51b1-550e-4d24-9440-885d6354ee15">Benefits and drawbacks of the State pattern</h1>
<p>The following are the benefits of using the State pattern: </p>
<ul>
<li><strong>Encapsulation</strong>: The State pattern allows us to implement an entity's stateful behaviors as a collection of components that can be assigned dynamically to an object when it changes states. </li>
<li><strong>Maintenance</strong>: We can easily implement new states without having to modify long conditional statements or bloated classes.</li>
</ul>
<p>However, the State pattern does have its limitations when we use it to manage an animated character.</p>
<p>Here's a shortlist of potential limitations:</p>
<ul>
<li><strong>Blending</strong>: In its native form, the State pattern doesn't offer a solution to blend animations. This limitation can become an issue when you want to achieve a smooth visual transition between the animated states of a character.</li>
<li><strong>Transitioning</strong>: In our implementation of the pattern, we can easily switch between states, but we are not defining the relation between them. Therefore, if we wish to define transitions between states based on relationships and conditions, we will have to write a lot more code; for instance, if I want the idle state to transition to the walk state, and then the walk state to transition to the run state. And this happens automatically and smoothly, back and forth, depending on a trigger or condition. This could be time-consuming to do in code.</li>
</ul>
<p>However, the limitations listed above can be overcome by using the Unity animation system and its native state machine. We can easily define animation states and attach animation clips and scripts to each of the configured states. But its more important feature is that it lets us define and configure a set of transitions between states with conditions and triggers through a visual editor, as we can see here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b87b4fc2-6426-4513-98f8-6a9224524a71.png" style="width:72.42em;height:36.08em;"/></p>
<p>Figure 5.4 – Screenshot of the Unity animation system editor</p>
<p>The rectangles present represent individual animation states, and the arrows indicate relationships and transitions. A deep dive into how to use Unity animation is beyond the scope of this book. The goal of this chapter was to get introduced to the State pattern in the context of the Unity engine. As we see, Unity offers us a native solution that we can leverage to manage the animation states of our characters.</p>
<p>It's essential to keep in mind that this tool is not limited to animating humanoid characters. We could use it for mechanical entities such as cars or even background ingredients, such as a vending machine; hence, anything that has states, animations, and behaviors.</p>
<p>In the next section, we will review a shortlist of alternative patterns to consider before using the State pattern.</p>
<p>For more information on Unity's animation system, you can read the official documentation at the following link:<br/>
<a href="https://docs.unity3d.com/Manual/AnimationSection.html">https://docs.unity3d.com/Manual/AnimationSection.html</a>.<a href="https://docs.unity3d.com/Manual/AnimationSection.html"/></p>
<h1 id="uuid-9aef4c3b-17fa-4f9b-a33f-708338f0fd4e">Reviewing alternative solutions</h1>
<p>The following is a list of patterns that are related or alternatives to the State pattern:</p>
<ul>
<li><strong>Blackboard/Behavior Trees</strong>:<strong> </strong>If you are planning to implement complex AI behaviors for NPC characters, I would recommend considering patterns such as the Blackboard or concepts such as <strong>Behavior Trees</strong> (<strong>BT</strong>). For example, if you need to implement AI with dynamic decision-making behaviors, then BT is a more appropriate approach because it permits you to implement behavior using a tree of actions.</li>
<li><strong>FSM</strong>:<strong> </strong>A question that often arises when discussing the State pattern is the core difference between an FSM and the State pattern. The quick answer is that the State pattern is concerned with encapsulating an object's state-dependent behaviors. However, FSM is more deeply involved with transitioning between finite states based on specific input triggers. And so, FSM is often considered more suited for the implementation of automaton-like systems.</li>
<li><strong>Memento</strong>: Memento is similar to the State pattern, but with an extra feature that gives objects the ability to roll back to a previous state. This pattern could be useful in implementing a system that needs the ability to undo a change made to itself.</li>
</ul>
<h1 id="uuid-65177342-1f6a-4b5e-b7f8-dc7bf146f5bb">Summary</h1>
<p>In this chapter, we were able to leverage the State pattern to define and implement stateful behaviors of our main character. In our case, the character is a vehicle. After reviewing its structure in the context of a specific code example, we saw its limits when dealing with animated entities. However, Unity offers us a native solution that permits us to manage the states of animated characters with a sophisticated state machine and a visual editor.</p>
<p class="mce-root">However, it doesn't mean that the State pattern in itself is useless in Unity. We could easily use it as a foundation to build stateful systems or mechanics.</p>
<p class="mce-root">In the next chapter, we will define the global states of our racing game and manage them with Event Bus.</p>


            

            
        
    </body></html>