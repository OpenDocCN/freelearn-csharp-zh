- en: 15 Object Mappers, Aggregate Services, and Façade
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 个对象映射器、聚合服务和外观
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file93.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file93.png)'
- en: 'In this chapter, we explore object mapping. As we saw in the previous chapter,
    working with layers often leads to copying models from one layer to another. Object
    mappers solve that problem. We first look at manually implementing an object mapper.
    Then, we improve our design by regrouping the mappers under a mapper service,
    exploring the Aggregate Services, and Mapping façade patterns along the way. Finally,
    we replace that manual work with two open-source tools that helps us generate
    business value instead of writing mapping code.In this chapter, we cover the following
    topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨对象映射。正如我们在上一章中看到的，与层一起工作通常会导致从一层复制模型到另一层。对象映射器解决了这个问题。我们首先手动实现一个对象映射器。然后，通过重新组合映射器到映射服务中，探索聚合服务模式和映射外观模式，我们改进了我们的设计。最后，我们用两个开源工具替换了这项手动工作，这些工具帮助我们生成业务价值而不是编写映射代码。在本章中，我们涵盖了以下主题：
- en: Overview of object mapping and object mappers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象映射和对象映射器的概述
- en: Implementing a simple object mapper
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个简单的对象映射器
- en: Exploring the too-many-dependencies code smell
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索过多的依赖代码异味
- en: Exploring the Aggregate Services pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索聚合服务模式
- en: Implementing a Mapping Façade by leveraging the Façade pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用外观模式实现映射外观
- en: Using the Service Locator pattern to create a flexible Mapping Service in front
    of our mappers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务定位器模式在映射器前面创建一个灵活的映射服务
- en: Using AutoMapper to map an object to another, replacing our homebrewed code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AutoMapper 将对象映射到另一个对象，替换我们自制的代码
- en: Using Mapperly instead of AutoMapper
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mapperly 而不是 AutoMapper
- en: Object mapper
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象映射器
- en: What is object mapping? In a nutshell, it is the action of copying the value
    of an object’s properties into the properties of another object. But sometimes,
    properties’ names do not match; an object hierarchy may need to be flattened and
    transformed. As we saw in the previous chapter, each layer can own its own model,
    which can be a good thing, but that comes at the price of copying objects from
    one layer to another. We can also share models between layers, but even then,
    we usually need to map one object into another. Even if it’s just to map your
    models to **Data Transfer Objects** (**DTOs**), it is almost inevitable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是对象映射？简单来说，它是将一个对象属性的值复制到另一个对象的属性中的动作。但有时，属性名称不匹配；可能需要将对象层次结构扁平化并转换。正如我们在上一章中看到的，每一层都可以拥有自己的模型，这可能是好事，但这也需要以从一层到另一层复制对象为代价。我们也可以在层之间共享模型，但即使这样，我们通常也需要将一个对象映射到另一个对象。即使只是将你的模型映射到**数据传输对象**（**DTOs**），这也是不可避免的。
- en: Remember that DTOs define our API’s contract. Independent contract classes help
    maintain the system, making us choose when to modify them. If you skip that part,
    each time you change your model, it automatically updates your endpoint’s contract,
    possibly breaking some clients. Moreover, if you input your model directly, a
    malicious user could try to bind the values of properties that they should not,
    leading to potential security issues (known as **over-posting** or **over-posting
    attacks**). Having good data exchange contracts is one of the keys to designing
    robust systems.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住 DTOs 定义了我们的 API 合同。独立的合同类有助于维护系统，让我们选择何时修改它们。如果你跳过这部分，每次你更改模型时，它都会自动更新你的端点合同，可能会破坏一些客户端。此外，如果你直接输入模型，恶意用户可能会尝试绑定他们不应该绑定的属性值，导致潜在的安全问题（称为**过度提交**或**过度提交攻击**）。拥有良好的数据交换合同是设计健壮系统的一个关键。
- en: In the previous projects, the mapping logic was hardcoded, sometimes duplicated
    and adding additional responsibilities to the class doing the mapping. In this
    chapter, we extract the mapping logic into object mappers to fix that issue.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的项目中，映射逻辑是硬编码的，有时是重复的，并为执行映射的类添加了额外的职责。在本章中，我们将映射逻辑提取到对象映射器中，以解决这个问题。
- en: Goal
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The object mapper’s goal is to copy the value of an object’s properties into
    the properties of another object. It encapsulates the mapping logic away from
    where the mapping takes place. The mapper is also responsible for transforming
    the values from the original format to the destination format when both objects
    do not follow the same structure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对象映射器的目标是复制一个对象属性值到另一个对象的属性中。它将映射逻辑封装在映射发生的地方之外。映射器还负责在两个对象不遵循相同结构时，将值从原始格式转换为目标格式。
- en: Design
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'We can design object mappers in many ways. Here is the most basic object mapper
    design:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式设计对象映射器。以下是最基本的对象映射器设计：
- en: '![Figure 15.1: Basic design of the object mapper](img/file94.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1：对象映射器的基本设计](img/file94.png)'
- en: 'Figure 15.1: Basic design of the object mapper'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：对象映射器的基本设计
- en: 'In the diagram, the **Consumer** uses the `IMapper` interface to map an object
    of `Type1` to an object of `Type2`. That’s not very reusable, but it illustrates
    the concept. By using the power of **generics**, we can upgrade that simple design
    to this more reusable version:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，**消费者**使用`IMapper`接口将`Type1`类型的对象映射到`Type2`类型的对象。这并不是非常可重用，但它说明了概念。通过使用**泛型**的力量，我们可以将这个简单的设计升级到更可重用的版本：
- en: '![Figure 15.2: Generic object mapper design](img/file95.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2：泛型对象映射器设计](img/file95.png)'
- en: 'Figure 15.2: Generic object mapper design'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：泛型对象映射器设计
- en: 'This design lets us map any `TSource` to any `TDestination` by implementing
    the `IMapper<TSource, TDestination>` interface once per mapping rule. One class
    could also implement multiple mapping rules. For example, we could implement the
    mapping of `Type1` to `Type2` and `Type2` to `Type1` in the same class (a bidirectional
    mapper).Another way would be to use the following design and create an `IMapper`
    interface with a single method that handles all of the application’s mapping:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计允许我们通过为每个映射规则实现一次`IMapper<TSource, TDestination>`接口，将任何`TSource`映射到任何`TDestination`。一个类也可以实现多个映射规则。例如，我们可以在同一个类中实现`Type1`到`Type2`和`Type2`到`Type1`的映射（双向映射器）。另一种方式是使用以下设计，创建一个具有单个方法处理应用程序所有映射的`IMapper`接口：
- en: '![Figure 15.3: Object mapping using a single IMapper as the entry point](img/file96.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3：使用单个IMapper作为入口点的对象映射](img/file96.png)'
- en: 'Figure 15.3: Object mapping using a single IMapper as the entry point'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：使用单个IMapper作为入口点的对象映射
- en: 'The biggest advantage of this last design is the ease of use. We always inject
    a single `IMapper` instead of one `IMapper<TSource, TDestination>` per type of
    mapping, which reduces the number of dependencies and the complexity of consuming
    such a mapper.You can implement object mapping in any way your imagination allows,
    but the critical part is that the mapper is responsible for mapping an object
    to another. A mapper should avoid complex processes, such as loading data from
    a database and whatnot. It should copy the values of one object into another:
    that’s it. Think about the **Single Responsibility Principle** (**SRP**) here:
    the class must have a single reason to change, and since it’s an object mapper,
    that reason should be object mapping.Let’s jump into some code to explore the
    designs in more depth with each project.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此最后设计的最大优点是易于使用。我们总是注入一个单一的`IMapper`，而不是为每种映射类型注入一个`IMapper<TSource, TDestination>`，这减少了依赖项的数量和消费此类映射器的复杂性。你可以以任何你想象的方式实现对象映射，但关键部分是映射器负责将一个对象映射到另一个对象。映射器应避免复杂的过程，例如从数据库加载数据等。它应该将一个对象的值复制到另一个对象中：仅此而已。考虑一下**单一职责原则**（**SRP**）：类必须有单一的理由进行更改，并且由于它是一个对象映射器，这个理由应该是对象映射。让我们通过一些代码深入了解每个项目的设计。
- en: Project – Mapper
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 映射器
- en: 'This project is an updated version of the Clean Architecture code from the
    previous chapter. The project aims to demonstrate the design’s versatility of
    encapsulating entity mapping logic into mapper classes, moving that logic away
    from the consumers. Of course, the project is again focused on the use case at
    hand, making learning the topics easier.First, we need an interface that resides
    in the `Core` project so the other projects can implement the mapping they need.
    Let’s adopt the second design that we saw:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目是前一章中Clean Architecture代码的更新版本。该项目旨在展示将实体映射逻辑封装到映射器类中的设计灵活性，将此逻辑从消费者那里移开。当然，项目再次专注于当前用例，使学习这些主题变得更容易。首先，我们需要一个接口，它位于`Core`项目中，以便其他项目可以实施它们所需的映射。让我们采用我们看到的第二个设计：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this interface, we can start by creating the data mappers. But first,
    let’s start by creating record classes instead of anonymous types to name the
    DTOs returned by the endpoints. Here are all the DTOs (from the `Program.cs` file):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个接口，我们可以先创建数据映射器。但首先，让我们先创建记录类而不是匿名类型来命名端点返回的 DTO。以下是所有 DTO（来自 `Program.cs`
    文件）：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Three of the four output DTOs need mapping:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 四个输出 DTO 中的三个需要映射：
- en: '`Product` to `ProductDetails`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product` 到 `ProductDetails`'
- en: '`ProductNotFoundException` to `ProductNotFound`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductNotFoundException` 到 `ProductNotFound`'
- en: '`NotEnoughStockException` to `NotEnoughStock`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotEnoughStockException` 到 `NotEnoughStock`'
- en: Why not map the `StockLevel` DTO? In our case, the `StockService` returns an
    `int` when we add or remove stocks, so converting a primitive value like an `int`
    into a `StockLevel` object does not require an object mapper. Moreover, creating
    such an object mapper adds no value and makes the code more complex. If the service
    had returned an object, creating a mapper that maps an object to `StockLevel`
    would have made more sense.
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么不映射 `StockLevel` DTO？在我们的案例中，当我们添加或移除库存时，`StockService` 返回一个 `int`，因此将原始值如
    `int` 转换为 `StockLevel` 对象不需要对象映射器。此外，创建这样的对象映射器没有任何价值，并且会使代码更复杂。如果服务返回了一个对象，创建一个将对象映射到
    `StockLevel` 的映射器将更有意义。
- en: 'Let’s start with the product mapper (from the `Program.cs` file):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从产品映射器开始（来自 `Program.cs` 文件）：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code is straightforward; the `ProductMapper` class implements
    the `IMapper<Product,` `ProductDetails>` interface. The `Map` method returns a
    `ProductDetails` instance. The highlighted code ensures the `Id` property is not
    `null`, which should not happen. We could also add a guard clause to ensure the
    `Id` property is not `null`.All in all, the `Map` method takes a `Product` as
    input and outputs a `ProductDetails` instance containing the same values.Then
    let’s continue with the exception mappers (from the `Program.cs` file):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码很简单；`ProductMapper` 类实现了 `IMapper<Product, ProductDetails>` 接口。`Map` 方法返回一个
    `ProductDetails` 实例。高亮显示的代码确保 `Id` 属性不是 `null`，这不应该发生。我们也可以添加一个保护子句来确保 `Id` 属性不是
    `null`。总的来说，`Map` 方法接收一个 `Product` 作为输入，并输出一个包含相同值的 `ProductDetails` 实例。然后让我们继续处理异常映射器（来自
    `Program.cs` 文件）：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compared to the `ProductMapper` class, the `ExceptionsMapper` class implements
    the two remaining use cases by implementing the `IMapper` interface twice. The
    two `Map` methods handle mapping an exception to its DTO, leading to one class
    being responsible for mapping exceptions to DTOs.Let’s look at the `products`
    endpoint (original value from the `clean-architecture` project of *Chapter 14*,
    *Layering and Clean Architecture*):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ProductMapper` 类相比，`ExceptionsMapper` 类通过两次实现 `IMapper` 接口来处理剩余的两个用例。两个 `Map`
    方法处理将异常映射到其 DTO，导致一个类负责将异常映射到 DTO。让我们看看 `products` 端点（来自 *第 14 章*，*分层和整洁架构*的 `clean-architecture`
    项目的原始值）：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before analyzing the code, let’s look at the updated version (from the `Program.cs`
    file):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析代码之前，让我们看看更新后的版本（来自 `Program.cs` 文件）：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, the request delegate uses the mapper to replace the
    copy logic (the highlighted lines of the original code). That simplifies the handler,
    moving the mapping responsibility into mapper objects instead (highlighted in
    the preceding code)—one more step toward the SRP.Let’s skip the add stocks endpoint
    since it is very similar to the remove stocks endpoint but simpler, and let’s
    focus on the later (original value from the `clean-architecture` project of *Chapter
    14*, *Layering and Clean Architecture*):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请求委托使用映射器替换了复制逻辑（原始代码中的高亮行）。这简化了处理器，将映射责任移动到映射对象中（前面代码中的高亮显示）——这是向 SRP（单一职责原则）迈出的又一步。让我们跳过添加库存端点，因为它与移除库存端点非常相似，但更简单，让我们关注后面的（来自
    *第 14 章*，*分层和整洁架构*的 `clean-architecture` 项目的原始值）：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once again, before analyzing the code, let’s look at the updated version (from
    the `Program.cs` file):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在分析代码之前，让我们看看更新后的版本（来自 `Program.cs` 文件）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same thing happened for this request delegate, but we injected two mappers
    instead of just one. We moved the mapping logic from inline using an anonymous
    type to the mapper objects. Nevertheless, a code smell is emerging here; can you
    smell it? We will investigate this after we are done with this project; meanwhile,
    keep thinking about the number of injected dependencies.Now that the delegates
    depend on interfaces with object mappers encapsulating the mapping responsibility,
    we must configure the composition root and bind the mapper implementations to
    the `IMapper<TSource, TDestination>` interface. The service bindings look like
    this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个请求代理也发生了同样的事情，但我们注入了两个映射器而不是一个。我们将映射逻辑从使用匿名类型内联移动到映射器对象。尽管如此，这里出现了一个代码异味；你能闻到吗？我们将在完成这个项目后进行调查；同时，继续思考注入依赖项的数量。现在，由于代理依赖于封装映射责任的映射器接口，我们必须配置组合根并将映射器实现绑定到`IMapper<TSource,
    TDestination>`接口。服务绑定看起来像这样：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since `ExceptionsMapper` implements two interfaces, we bind both to that class.
    That is one of the beauties of abstractions; the remove stocks delegate asks for
    two mappers but receives an instance of `ExceptionsMapper` twice without even
    knowing it.We could also register the classes so the same instance is injected
    twice, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ExceptionsMapper`实现了两个接口，我们将它们都绑定到该类上。这是抽象之美之一；移除股票的代理请求需要两个映射器，但即使不知道，它也两次接收了`ExceptionsMapper`的实例。我们也可以注册这些类，以便相同的实例被注入两次，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Yes, I did that double registration of the same class on purpose. That proves
    we can compose an application as we want without impacting the **consumers**.
    That is done by depending on abstractions instead of implementations, as per the
    **Dependency Inversion Principle** (**DIP**—the “D” in SOLID). Moreover, the division
    into small interfaces, as per the **Interface Segregation Principle** (**ISP**—the
    “I” in SOLID), makes that kind of scenario possible. Finally, we can glue all
    those pieces together using the power of **Dependency Injection** (**DI**).
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的，我故意进行了相同类的双重注册。这证明了我们可以按照我们的意愿组合应用程序，而不会影响**消费者**。这是通过依赖于抽象而不是实现来实现的，正如**依赖倒置原则**（**DIP**——SOLID中的“D”）所要求的。此外，根据**接口隔离原则**（**ISP**——SOLID中的“I”），将接口划分为小块，使得这种场景成为可能。最后，我们可以利用**依赖注入**（**DI**）的力量将这些碎片粘合在一起。
- en: Conclusion
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'Before exploring more alternatives, let’s see how object mapping can help us
    follow the **SOLID** principles:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索更多替代方案之前，让我们看看对象映射如何帮助我们遵循**SOLID**原则：
- en: '**S**: Using mapper objects helps to separate the responsibility of mapping
    types from the consumers, making it easier to maintain and refactor the mapping
    logic.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：使用映射器对象有助于将映射类型的责任从消费者中分离出来，使得维护和重构映射逻辑更容易。'
- en: '**O**: By injecting mappers, we can change the mapping logic without changing
    the code of their consumers.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：通过注入映射器，我们可以更改映射逻辑，而无需更改消费者代码。'
- en: '**L**: N/A'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: We explored different designs that provide a small mapper interface
    that reduces the dependencies between the components.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我**：我们探索了不同的设计，这些设计提供了一个小的映射器接口，减少了组件之间的依赖性。'
- en: '**D**: The consumers depend only on abstractions, moving the implementation’s
    binding to the composition root and inverting the dependency flow.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：消费者只依赖于抽象，将实现的绑定移动到组合根，并反转了依赖流。'
- en: Now that we’ve explored how to extract and use mappers, let’s look at the code
    smell that emerged.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何提取和使用映射器，让我们看看出现的代码异味。
- en: Code smell – Too many dependencies
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码异味——过多的依赖
- en: 'Using this kind of mapping could become tedious in the long run, and we would
    rapidly see scenarios such as injecting three or more mappers into a single request
    delegate or controller. The consumer would likely already have other dependencies,
    leading to four or more.That should raise the following flag:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 长期来看，使用这种映射可能会变得繁琐，我们很快就会看到将三个或更多映射器注入单个请求代理或控制器的情况。消费者可能已经拥有其他依赖项，导致依赖项增加到四个或更多。这应该会引发以下警示：
- en: Does the class do too much and have too many responsibilities?
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类是否做得太多，承担了太多的责任？
- en: In this case, the fine-grained `IMapper` interface pollutes our request delegates
    with tons of dependencies on mappers, which is not ideal and makes our code harder
    to read.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，细粒度的`IMapper`接口使我们的请求代理充满了对映射器的依赖，这并不理想，也使得我们的代码更难阅读。
- en: The preferred solution would be to move the exception-handling responsibility
    away from the delegates or controllers, leveraging a middleware or an exception
    filter, for example. This tactic would move boilerplate code away from the endpoints.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最佳解决方案是将异常处理责任从代理或控制器中移除，利用中间件或异常过滤器等。这种策略会将样板代码从端点移除。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since we are talking about mappers, we will explore more object mapping concepts
    to help us with this problem instead, which applies to many use cases.
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于我们正在讨论映射器，我们将探索更多对象映射概念，以帮助我们解决这个问题，这适用于许多用例。
- en: As a rule of thumb, you want to **limit the number of dependencies to three
    or less**. Over that number, ask yourself if there is a problem with that class;
    does it have too many responsibilities? Having more than three dependencies is
    not inherently wrong; it just indicates that you should investigate the design.
    If nothing is wrong, keep it at 4 or 5, or 10; it does not matter. If you find
    a way to reduce the number of dependencies or that the class actually does too
    many things refactor the code.If you don’t like having that many dependencies,
    you could extract service aggregates that encapsulate two or more dependencies
    and inject that aggregate instead. Beware that moving your dependencies around
    does not fix anything; it just moves the problem elsewhere if there was a problem
    in the first place. Using aggregates could increase the readability of the code,
    though.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，你希望**将依赖项的数量限制在三个或更少**。超过这个数量，问问自己这个类是否有问题；它是否承担了太多的责任？拥有超过三个依赖项本身并不是错误的；它只是表明你应该调查设计。如果没有问题，保持4个或5个，或者10个；这并不重要。如果你找到了减少依赖数量的方法，或者发现该类实际上做了太多事情，那么重构代码。如果你不喜欢有那么多依赖项，你可以提取封装两个或更多依赖项的服务聚合，并注入该聚合。请注意，移动你的依赖项并不能解决问题；如果最初存在问题，它只是将问题转移到别处。使用聚合可能会提高代码的可读性。
- en: Instead of blindly moving dependencies around, analyze the problem to see if
    you could create classes with actual logic that could do something useful to reduce
    the number of dependencies.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而不是盲目地移动依赖项，分析问题以查看是否可以创建具有实际逻辑的类，从而对减少依赖数量有所贡献。
- en: Next, let’s have a quick look at aggregating services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们快速看一下聚合服务。
- en: Pattern – Aggregate Services
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 聚合服务
- en: Even if the Aggregate Services pattern is not a magic problem-solving pattern,
    it is a viable alternative to injecting too many dependencies into another class.
    Its goal is to aggregate many dependencies in a class to reduce the number of
    injected services in other classes, grouping dependencies together. The way to
    manage aggregates would be to group them by concern or responsibility. Putting
    a bunch of services in another service just for the sake of it is rarely the way
    to go; aim for cohesion.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使聚合服务模式不是一个神奇的解决问题的模式，它也是向另一个类注入过多依赖项的一个可行的替代方案。其目标是聚合一个类中的许多依赖项，以减少其他类中注入的服务数量，将依赖项分组在一起。管理聚合的方式是将它们按关注点或责任分组。仅仅为了将一堆服务放入另一个服务中通常不是正确的做法；目标是内聚性。
- en: Creating one or more aggregation services that expose other services can be
    a way to implement service discovery in a project. Like always, analyze if the
    problem is not elsewhere first. Loading a service that exposes other services
    can be handy. However, this may create issues, so don’t put everything into an
    aggregate firsthand either.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个或多个暴露其他服务的聚合服务可以是实现项目中的服务发现的一种方式。像往常一样，首先分析问题是否不在于其他地方。加载暴露其他服务的服务可能很有用。然而，这可能会产生问题，所以一开始也不要把所有东西都放入一个聚合中。
- en: 'Here is an example of a mapping aggregate to reduce the number of dependencies
    of a **Create-Read-Update-Delete** (**CRUD**) controller that allows the creation,
    updating, deletion, and reading of one, many, or all products. Here’s the aggregate
    service code and a usage example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将映射聚合用于减少**创建-读取-更新-删除**（**CRUD**）控制器依赖数量的示例，该控制器允许创建、更新、删除和读取一个、多个或所有产品。以下是聚合服务代码和使用示例：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `IProductMappers` aggregate could be logical in this example as it groups
    the mappers used by the `ProductsController` class under its umbrella. It is responsible
    for mapping `ProductsController`-related domain objects to DTOs and vice versa
    while the controller gives up this responsibility.You can create aggregate services
    with anything, not just mappers. That’s a fairly common pattern in DI-heavy applications
    (which can also point to some design flaws).Now that we’ve explored the Aggregate
    Services pattern, let’s explore how to make a mapping façade instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`IProductMappers` 聚合可能是有逻辑性的，因为它将 `ProductsController` 类使用的映射器归入其旗下。它负责将
    `ProductsController` 相关的领域对象映射到 DTO 并反之，而控制器放弃了这一责任。你可以用任何东西创建聚合服务，而不仅仅是映射器。这在依赖注入（DI）密集型应用中是一个相当常见的模式（这也可以指向一些设计缺陷）。现在我们已经探讨了聚合服务模式，让我们来看看如何制作一个映射外观。
- en: Pattern – Mapping Façade
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 – 映射外观
- en: 'We studied façades already; here, we explore another way to organize our many
    mappers by leveraging that design pattern.Instead of what we just did, we will
    create a mapping façade to replace our aggregate services. The code consuming
    the façade will be more elegant because it uses the `Map` methods directly instead
    of the properties. The responsibility of the façade is the same as the aggregate,
    but it implements the interfaces instead of exposing them as properties.Let’s
    look at the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了外观；在这里，我们通过利用该设计模式探索另一种组织我们众多映射器的方法。我们不会像刚才那样做，而是创建一个映射外观来替换我们的聚合服务。使用外观的代码将更加优雅，因为它直接使用
    `Map` 方法而不是属性。外观的责任与聚合相同，但它实现接口而不是将其作为属性公开。让我们看看代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, the `ProductMapperService` class implements the `IMapper`
    interfaces through the `IProductMapperService` interface and delegates the mapping
    logic to each injected mapper: a façade wrapping multiple individual mappers.
    Next, we look at the `ProductsController` that consumes the façade:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ProductMapperService` 类通过 `IProductMapperService` 接口实现 `IMapper` 接口，并将映射逻辑委托给每个注入的映射器：一个封装多个单个映射器的外观。接下来，我们看看消费外观的
    `ProductsController`：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the consumer standpoint (the `ProductsController` class), I find it cleaner
    to write`_mapper.Map(...)` instead of `_mapper.SomeMapper.Map(...)`. The consumer
    does not want to know what mapper is doing what mapping; it only wants to map
    what needs mapping. If we compare the Mapping Façade with the Aggregate Services
    of the previous example, the façade takes the responsibility of choosing the mapper
    and moves it away from the consumer. This design distributes the responsibilities
    between the classes better.This was an excellent opportunity to review the Façade
    design pattern. Nonetheless, now that we've gone through multiple mapping options
    and examined the issue of having too many dependencies, it's time to move forward
    on our object mapping adventure with an enhanced version of our mapping façade.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从消费者角度来看（`ProductsController` 类），我发现写 `_mapper.Map(...)` 而不是 `_mapper.SomeMapper.Map(...)`
    更干净。消费者不关心映射器在做什么映射；它只想映射需要映射的内容。如果我们将映射外观与前面例子中的聚合服务进行比较，外观承担了选择映射器的责任，并将其从消费者那里移开。这种设计更好地在类之间分配了责任。这是一个审查外观设计模式的绝佳机会。尽管如此，现在我们已经探讨了多种映射选项并检查了过多依赖的问题，是时候带着我们映射外观的增强版本继续我们的对象映射冒险了。
- en: Project – Mapping service
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – 映射服务
- en: 'The goal is to simplify the implementation of the Mapper façade with a universal
    interface. To achieve this, we are implementing the diagram shown in *Figure 13.3*.
    Here’s a reminder:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是简化具有通用接口的映射外观实现。为了实现这一点，我们正在实现如图 *图13.3* 所示的图。这里有一个提醒：
- en: '![Figure 15.4: Object mapping using a single IMapper interface](img/file97.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4：使用单个 IMapper 接口进行对象映射](img/file97.png)'
- en: 'Figure 15.4: Object mapping using a single IMapper interface'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：使用单个 IMapper 接口进行对象映射
- en: 'Instead of naming the interface `IMapper`, we will use the name `IMappingService`.
    This name is more suitable because it is not mapping anything; it is a dispatcher
    servicing the mapping request to the right mapper. Let’s take a look:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将接口命名为 `IMapper`，而是使用 `IMappingService` 这个名字。这个名字更合适，因为它不是映射任何东西；它是一个服务映射请求到正确映射器的调度器。让我们看看：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That interface is self-explanatory; it maps any `TSource` to any `TDestination`.On
    the implementation side, we are leveraging the **Service Locator** pattern, so
    I called the class `ServiceLocatorMappingService`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该界面是自我解释的；它将任何 `TSource` 映射到任何 `TDestination`。在实现方面，我们正在利用 **服务定位器** 模式，所以我将类命名为
    `ServiceLocatorMappingService`：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The logic is simple:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：
- en: Find the appropriate `IMapper<TSource, TDestination>` service, then map the
    entity with it
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到适当的 `IMapper<TSource, TDestination>` 服务，然后使用它来映射实体
- en: If you don’t find any, throw a `MapperNotFoundException`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你找不到任何，则抛出 `MapperNotFoundException`
- en: The key to that design is to register the mappers with the IoC container instead
    of the service itself. Then we use the mappers without knowing every single one
    of them, like in the previous example. The `ServiceLocatorMappingService` class
    doesn’t know any mappers; it just dynamically asks for one whenever needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该设计的关键是将映射器注册到 IoC 容器中，而不是服务本身。然后我们使用映射器，而不需要知道它们中的每一个，就像上一个例子中那样。`ServiceLocatorMappingService`
    类不知道任何映射器；它只是在需要时动态地请求一个。
- en: The Service Locator pattern should not be part of the application’s code. However,
    it can be helpful at times. For example, we are not trying to cheat DI in this
    case. On the contrary, we are leveraging its power.
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务定位器模式不应该成为应用程序代码的一部分。然而，有时它可能很有帮助。例如，我们并不是试图在这个案例中欺骗依赖注入（DI）。相反，我们正在利用它的力量。
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using a service locator is wrong when acquiring dependencies in a way that removes
    the possibility of controlling the program’s composition from the composition
    root, which breaks the IoC principle.
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当以去除从组合根控制程序组合的可能性的方式来获取依赖项时，使用服务定位器是错误的，这违反了 IoC 原则。
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case, we load mappers dynamically from the IoC container, limiting the
    container’s ability to control what to inject which is acceptable since it has
    little to no negative impact on the program’s maintainability, flexibility, and
    reliability. For example, we can replace the `ServiceLocatorMappingService` implementation
    with another class without affecting the `IMappingService` interface consumers.
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，我们从 IoC 容器中动态加载映射器，限制了容器控制要注入的内容的能力，这是可以接受的，因为它对程序的维护性、灵活性和可靠性几乎没有负面影响。例如，我们可以替换
    `ServiceLocatorMappingService` 实现为另一个类，而不会影响 `IMappingService` 接口消费者。
- en: 'Now, we can inject that service everywhere we need mapping and use it directly.
    We already registered the mappers, so we only need to bind the `IMappingService`
    to its `ServiceLocatorMappingService` implementation and update the consumers.
    Here’s the DI binding:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在需要映射的任何地方注入该服务并直接使用它。因为我们已经注册了映射器，所以我们只需要将 `IMappingService` 绑定到其 `ServiceLocatorMappingService`
    实现并更新消费者。以下是 DI 绑定：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we look at the new implementation of the remove stocks endpoint, we can
    see we reduced the number of mapper dependencies to one:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看移除股票端点的新实现，我们可以看到我们减少了映射器依赖项的数量到一个：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is similar to the previous sample, but we replaced the mappers
    with the new service (the highlighted lines). And that’s it; we now have a universal
    mapping service that delegates the mapping to any mapper we register with the
    IoC container.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与上一个示例类似，但我们用新的服务（突出显示的行）替换了映射器。就是这样；我们现在有一个通用的映射服务，它将映射委托给我们在 IoC 容器中注册的任何映射器。
- en: Even if you are not likely to implement object mappers manually often, exploring
    and revisiting those patterns and a code smell is very good and will help you
    craft better software.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使你不太可能经常手动实现对象映射器，探索和重新审视这些模式和代码异味是非常好的，并将帮助你编写更好的软件。
- en: This is not the end of our object mapping exploration. We have two tools to
    explore, starting with AutoMapper, which does all the object mapping work for
    us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们对象映射探索的终点。我们有两个工具要探索，首先是 AutoMapper，它为我们完成所有的对象映射工作。
- en: Project – AutoMapper
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – AutoMapper
- en: 'We just covered different ways to implement object mapping, but here we leverage
    an open-source tool named AutoMapper that does it for us instead of implementing
    our own.Why bother learning all of that if a tool already does it? There are a
    few reasons to do so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了实现对象映射的不同方法，但在这里我们利用一个名为 AutoMapper 的开源工具来为我们完成这项工作，而不是自己实现。如果已经有工具做了这件事，为什么还要费心学习所有这些？这样做有几个原因：
- en: It is important to understand the concepts; you don’t always need a full-fledged
    tool like AutoMapper.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解这些概念很重要；你并不总是需要一个完整的工具，比如 AutoMapper。
- en: It allowed us to cover multiple patterns we can use in other contexts and apply
    them to components with different responsibilities. So, all in all, you should
    have learned multiple new techniques during this object mapping progression.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使我们能够涵盖多个在其他上下文中可以使用并应用于具有不同职责的组件的模式。所以，总的来说，你应该在这次对象映射过程中学习了多种新技术。
- en: Lastly, we dug deeper into applying the SOLID principles to write better programs.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们深入研究了将SOLID原则应用于编写更好的程序。
- en: The AutoMapper project is also a copy of the Clean Architecture sample. The
    biggest difference between this project and the others is that we don’t need to
    define any interface because AutoMapper exposes an `IMapper` interface with all
    the methods we need and more.To install AutoMapper, you can install the `AutoMapper`
    NuGet package using the CLI (`dotnet add package AutoMapper`), Visual Studio’s
    NuGet package manager, or by updating your `.csproj` manually.The best way to
    define our mappers is by using AutoMapper’s profile mechanism. A profile is a
    simple class that inherits from `AutoMapper.Profile` and contains maps from one
    object to another. We use profiles to group mappers together, but in our case,
    with only three maps, I decided to create a single `WebProfile` class.Finally,
    instead of manually registering our profiles, we can scan one or more assemblies
    to load all of the profiles into AutoMapper by using the `AutoMapper.Extensions.Microsoft.DependencyInjection`
    package.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper项目也是Clean Architecture示例的副本。这个项目和其它项目最大的不同之处在于我们不需要定义任何接口，因为AutoMapper提供了一个包含所有所需方法的`IMapper`接口。要安装AutoMapper，你可以使用CLI（`dotnet
    add package AutoMapper`）、Visual Studio的NuGet包管理器或手动更新`.csproj`文件来安装`AutoMapper`
    NuGet包。定义我们的映射器最好的方式是使用AutoMapper的配置文件机制。配置文件是一个简单的类，它继承自`AutoMapper.Profile`并包含一个对象到另一个对象的映射。我们使用配置文件来分组映射器，但在我们的情况下，只有三个映射，我决定创建一个单独的`WebProfile`类。最后，我们不再手动注册配置文件，而是可以使用`AutoMapper.Extensions.Microsoft.DependencyInjection`包扫描一个或多个程序集，将所有配置文件加载到AutoMapper中。
- en: When installing the `AutoMapper.Extensions.Microsoft.DependencyInjection` package
    you don’t have to load the `AutoMapper` package.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当安装`AutoMapper.Extensions.Microsoft.DependencyInjection`包时，你不需要加载`AutoMapper`包。
- en: 'There is more to AutoMapper than what we cover here, but it has enough resources
    online, including the official documentation, to help you dig deeper into the
    tool. The goal of this project is to do basic object mapping.In the *Web* project,
    we must create the following maps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper的内容远不止我们在这里所涵盖的，但网上有足够的资源，包括官方文档，可以帮助你深入了解这个工具。这个项目的目标是进行基本的对象映射。在*Web*项目中，我们必须创建以下映射：
- en: Map `Product` to `ProductDetails`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Product`映射到`ProductDetails`
- en: Map `NotEnoughStockException` to `NotEnoughStock`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`NotEnoughStockException`映射到`NotEnoughStock`
- en: Map `ProductNotFoundException` to `ProductNotFound`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ProductNotFoundException`映射到`ProductNotFound`
- en: 'To do that, we create the following `WebProfile` class (in the `Program.cs`
    file, but could live anywhere):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们创建以下`WebProfile`类（位于`Program.cs`文件中，但可以存在于任何位置）：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A profile in AutoMapper is nothing more than a class where you create maps in
    the constructor. The `Profile` class adds the required methods for you to do that,
    such as the `CreateMap` method. What does that do?Invoking the method `CreateMap<Product,
    ProductDetails>()` tells AutoMapper to register a mapper that maps `Product` to
    `ProductDetails`. The other two `CreateMap` calls are doing the same for the other
    two maps. That’s all we need for now because AutoMapper maps properties using
    conventions, and both our model and DTO classes have the same sets of properties
    with the same names.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper中的配置文件不过是一个在构造函数中创建映射的类。`Profile`类为你添加了执行此操作所需的方法，例如`CreateMap`方法。这会做什么？调用`CreateMap<Product,
    ProductDetails>()`方法告诉AutoMapper注册一个将`Product`映射到`ProductDetails`的映射器。其他两个`CreateMap`调用为其他两个映射执行相同的操作。目前我们只需要这些，因为AutoMapper使用约定来映射属性，并且我们的模型和DTO类具有相同名称的属性集合。
- en: In the preceding examples, we defined some mappers in the `Core` layer. In this
    example, we rely on a library, so it is even more important to consider the dependency
    flow. We are mapping objects only in the `Web` layer, so there is no need to put
    the dependency on AutoMapper in the `Core` layer. Remember that all layers depend
    directly or indirectly on `Core`, so having a dependency on AutoMapper in that
    layer means all layers would also depend on it.
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在 `Core` 层定义了一些映射器。在这个例子中，我们依赖于一个库，因此考虑依赖流就更加重要。我们仅在 `Web` 层映射对象，因此没有必要在
    `Core` 层放置对 AutoMapper 的依赖。记住，所有层都直接或间接依赖于 `Core`，所以在那一层有对 AutoMapper 的依赖意味着所有层也会依赖它。
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Therefore, in this example, we created the `WebProfile` class in the `Web` layer
    instead, limiting the dependency on AutoMapper to only that layer. Having only
    the `Web` layer depend on AutoMapper allows all outer layers (if we were to add
    more) to control how they do object mapping, giving more independence to each
    layer. It is also a best practice to limit object mapping as much as possible.
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，我们在 `Web` 层创建了 `WebProfile` 类，将对 AutoMapper 的依赖限制在该层。仅让 `Web` 层依赖
    AutoMapper 允许所有外部层（如果我们添加更多的话）控制它们如何进行对象映射，从而为每一层提供更多的独立性。尽可能限制对象映射也是一个最佳实践。
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’ve added a link to *AutoMapper Usage Guidelines* in the *Further reading*
    section at the end of the chapter.
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在章节末尾的“进一步阅读”部分添加了一个链接到 *AutoMapper 使用指南*。
- en: 'Now that we have one profile, we need to register it with the IoC container,
    but we don’t have to do this by hand; we can scan for profiles from the composition
    root by using one of the `AddAutoMapper` extension methods to scan one or more
    assemblies:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有一个配置文件，我们需要将其注册到 IoC 容器中，但不必手动操作；我们可以通过使用 `AddAutoMapper` 扩展方法之一从组合根扫描配置文件，以扫描一个或多个程序集：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding method accepts a `params Assembly[] assemblies` argument, meaning
    we can pass multiple `Assembly` instances to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法接受一个 `params Assembly[] assemblies` 参数，这意味着我们可以向它传递多个 `Assembly` 实例。
- en: That `AddAutoMapper` extension method comes from the `AutoMapper.Extensions.Microsoft.DependencyInjection`
    package.
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`AddAutoMapper` 扩展方法来自 `AutoMapper.Extensions.Microsoft.DependencyInjection`
    包。'
- en: 'Since we have only one profile in one assembly, we leverage that class to access
    the assembly by passing the `typeof(WebProfile).Assembly` argument to the `AddAutoMapper`
    method. From there, AutoMapper scans for profiles in that assembly and finds the
    `WebProfile` class. If there were more than one, it would register all it finds.The
    beauty of scanning for types like this is that once you register AutoMapper with
    the IoC container, you can add profiles in any registered assemblies, and they
    get loaded automatically; there’s no need to do anything else afterward but to
    write useful code. Scanning assemblies also encourages composition by convention,
    making it easier to maintain in the long run. The downside of assembly scanning
    is that debugging can be hard when something is not registered because the registration
    process is less explicit.Now that we’ve created and registered the profiles with
    the IoC container, it is time to use AutoMapper. Let’s look at the three endpoints
    we created initially:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个配置文件在一个程序集中，我们利用这个类通过传递 `typeof(WebProfile).Assembly` 参数到 `AddAutoMapper`
    方法来访问该程序集。从那里，AutoMapper 在该程序集中扫描配置文件并找到 `WebProfile` 类。如果有多个，它会注册所有找到的。扫描这种类型的好处是，一旦将
    AutoMapper 注册到 IoC 容器中，你可以在任何已注册的程序集中添加配置文件，它们会自动加载；之后无需做任何事情，只需编写有用的代码。扫描程序集也鼓励约定式组合，从长远来看更容易维护。程序集扫描的缺点是，当某些内容未注册时，调试可能很困难，因为注册过程不够明确。现在我们已经创建并注册了配置文件到
    IoC 容器中，是时候使用 AutoMapper 了。让我们看看最初创建的三个端点：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code shows how similar it is to use AutoMapper to the other options.
    We inject an `IMapper` interface, then use it to map the entities. Instead of
    explicitly specifying both `TSource` and `TDestination` like in the previous example,
    when using AutoMapper, we must specify only the `TDestination` generic parameter,
    reducing the code's complexity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了使用 AutoMapper 与其他选项的相似性。我们注入一个 `IMapper` 接口，然后使用它来映射实体。与上一个例子中显式指定 `TSource`
    和 `TDestination` 不同，当使用 AutoMapper 时，我们只需指定 `TDestination` 泛型参数，从而简化代码的复杂性。
- en: Suppose you are using AutoMapper on an `IQueryable` collection returned by EF
    Core. In that case, you should use the `ProjectTo` method, which limits the number
    of fields that EF will query to those you need. In our case, that changes nothing
    because we need the whole entity.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设您正在使用EF Core返回的`IQueryable`集合上的AutoMapper。在这种情况下，您应该使用`ProjectTo`方法，该方法将EF查询的字段数量限制为您需要的那些。在我们的情况下，这不会改变什么，因为我们需要整个实体。
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is an example that fetches all products from EF Core and projects them
    to `ProductDto` instances:'
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里有一个示例，它从EF Core获取所有产品并将它们投影到`ProductDto`实例：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Performance-wise, this is the recommended way to use AutoMapper with EF Core.
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在性能方面，这是推荐的方式使用AutoMapper与EF Core。
- en: 'One last yet significant detail is that we can assert whether our mapper configurations
    are valid when the application starts. This does not identify missing mappers
    but validates that the registered ones are configured correctly. The recommended
    way of doing this is in a unit test. To make this happen, I made the autogenerated
    `Program` class public by adding the following line at the end:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们可以在应用程序启动时断言我们的映射器配置是否有效。这并不识别缺失的映射器，但验证已注册的映射器配置是否正确。推荐的做法是在单元测试中这样做。为了实现这一点，我在末尾添加了以下行，使自动生成的`Program`类公开：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then I created a test project named `Web.Tests` that contain the following
    code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我创建了一个名为`Web.Tests`的测试项目，其中包含以下代码：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we validate that all the AutoMapper maps are valid.
    To make the test fail, you can uncomment the following line of the `WebProfile`
    class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们验证了所有的AutoMapper映射是否有效。要使测试失败，您可以在`WebProfile`类的以下行取消注释：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `AutoMapperAppWebApplication` class is there to centralize the initialization
    of the test cases when there is more than one.In the test project, I created a
    second test case ensuring the `products` endpoint is reachable. For both tests
    to work together, we must change the database name to avoid seeding conflicts
    so each test runs on its own database. This has to do with how we seed the database
    in the `Program.cs` file, which is not something we usually do except for development
    or proofs of concept. Nonetheless, testing against multiple databases can come
    in handy to isolate tests.Here’s that second test case and updated `AutoMapperAppWebApplication`
    class to give you an idea:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoMapperAppWebApplication`类存在是为了在存在多个测试用例时集中初始化测试。在测试项目中，我创建了一个第二个测试用例，确保`products`端点是可到达的。为了使这两个测试一起工作，我们必须更改数据库名称以避免播种冲突，这样每个测试都在自己的数据库上运行。这与我们在`Program.cs`文件中播种数据库的方式有关，这通常不是我们通常做的事情，除非是开发或概念验证。尽管如此，针对多个数据库的测试可以很有用，以便隔离测试。以下是第二个测试用例和更新的`AutoMapperAppWebApplication`类，以供您参考：'
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Running the tests ensures that the mapping in our application works and that
    one of the endpoints is reachable. We could add more tests, but those two cover
    about 50% of our code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试确保我们的应用程序中的映射正常工作，并且有一个端点是可到达的。我们可以添加更多测试，但这两个测试覆盖了我们代码的大约50%。
- en: The `CallerMemberNameAttribute` used in the preceding code is part of the `System.Runtime.CompilerServices`
    namespace and allows its decorated member to access the name of the method that
    called it. In this case, the `databaseName` parameter receives the test method
    name.
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的`CallerMemberNameAttribute`是`System.Runtime.CompilerServices`命名空间的一部分，允许其装饰的成员访问调用它的方法的名称。在这种情况下，`databaseName`参数接收测试方法名称。
- en: And this closes the AutoMapper project. At this point, you should begin to be
    familiar with object mapping. I’d recommend you evaluate whether AutoMapper is
    the right tool for the job whenever a project needs object mapping. You can always
    load another tool or implement your own mapping logic if AutoMapper does not suit
    your needs. If too much mapping is done at too many levels, maybe another application
    architecture pattern would be better, or some rethinking is in order.AutoMapper
    is convention-based and does a lot on its own without any configuration from us.
    It is also configuration-based, caching the conversions to improve performance.
    We can also create **type converters**, **value resolvers**, **value converters**,
    and more. AutoMapper keeps us away from writing that boring mapping code.Yet,
    AutoMapper is old, feature complete, and is almost unavoidable due to the number
    of projects that uses it. However, it is not the fastest, which is why we are
    exploring Mapperly next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了 AutoMapper 项目。此时，你应该开始熟悉对象映射。我建议每次项目需要对象映射时，都评估一下 AutoMapper 是否是合适的工具。如果
    AutoMapper 不符合你的需求，你总是可以加载另一个工具或实现自己的映射逻辑。如果映射在太多层级上完成，可能另一种应用程序架构模式会更好，或者需要重新思考。AutoMapper
    是基于约定的，并且在我们没有进行任何配置的情况下做了很多工作。它也是基于配置的，通过缓存转换来提高性能。我们还可以创建 **类型转换器**、**值解析器**、**值转换器**等等。AutoMapper
    让我们远离编写无聊的映射代码。然而，AutoMapper 已经很老了，功能完善，由于许多项目都在使用它，几乎不可避免。但是，它并不是最快的，这就是为什么我们接下来要探索
    Mapperly。
- en: Project – Mapperly
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – Mapperly
- en: Mapperly is a newer object mapper library that leverages source generation to
    make it lightning-fast. To get started, we must add a dependency on the `Riok.Mapperly`
    NuGet package.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Mapperly 是一个较新的对象映射库，它利用源生成技术使其运行速度极快。要开始使用，我们必须添加对 `Riok.Mapperly` NuGet 包的依赖。
- en: Source generators were introduced with .NET 5, allowing developers to generate
    C# code during compilation.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 源生成器是在 .NET 5 中引入的，允许开发者在编译时生成 C# 代码。
- en: 'There are many ways to create object mappers with Mapperly and many options
    to adjust the mapping process. The following code sample is similar to the others
    but using Mapperly. We cover the following ways to use Mapperly:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mapperly 创建对象映射有许多方法，调整映射过程也有许多选项。以下代码示例与其他示例类似，但使用了 Mapperly。我们介绍了以下使用 Mapperly
    的方法：
- en: Injecting a mapper class.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入映射器类。
- en: Using a static method.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态方法。
- en: Using an extension method.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展方法。
- en: 'Let’s start with the injected mapper. First, the class must be `partial` for
    the source generator to extend it (that is how source generators work). Decorate
    the class with the `[Mapper]` attribute (highlighted). Then, in that partial class,
    we must create one or more `partial` methods that have the signature of the mappers
    we want to create (like the `MapToProductDetails` method), like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从注入的映射器开始。首先，类必须是 `partial` 的，这样源生成器才能扩展它（这就是源生成器的工作方式）。用 `[Mapper]` 属性（突出显示）装饰这个类。然后，在那个
    `partial` 类中，我们必须创建一个或多个具有我们想要创建的映射器签名的 `partial` 方法（如 `MapToProductDetails` 方法），如下所示：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Upon compilation, the code generator creates the following class (I formatted
    the code to make it easier to read):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，代码生成器会创建以下类（我已格式化代码以便于阅读）：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Mapperly writes the boilerplate code for us in a generated `partial` class,
    which is why it is so fast.To use the mapper, we must register it with the IoC
    Container and inject it into our endpoint. Let’s make it a singleton once again:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Mapperly 在生成的 `partial` 类中为我们编写了样板代码，这就是它为什么运行得如此之快。要使用映射器，我们必须将其注册到 IoC 容器中，并将其注入到我们的端点。让我们再次将其设置为单例：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we can inject and use it like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样注入和使用它：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The highlighted code in the preceding block shows we can use our mapper like
    any other class. The biggest drawback is that we may end up injecting many mappers
    into a single class or endpoint if we do not consider how we create them wisely.Moreover,
    we must register all of our mappers with the IoC container, which creates a lot
    of boilerplate code but makes the process explicit. On the other hand, we could
    scan the assembly for all classes decorated with the `[Mapper]` attribute.If you
    want an abstraction layer like an interface for your mapper, you must design that
    yourself because Mapperly only generates the mappers. Here is an example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码块中突出显示的代码表明我们可以像使用任何其他类一样使用我们的映射器。最大的缺点是，如果我们没有明智地创建它们，我们可能会将许多映射器注入到单个类或端点中。此外，我们必须将所有映射器注册到IoC容器中，这会创建大量的样板代码，但使过程更加明确。另一方面，我们可以扫描程序集以查找所有带有`[Mapper]`属性的类。如果你想为你的映射器提供一个类似于接口的抽象层，你必须自己设计它，因为Mapperly只生成映射器。以下是一个示例：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code centralizes all the mapper methods under the same class and
    interface, allowing you to inject an interface similar to AutoMapper. In subsequent
    chapters, we explore ways to organize mappers and app code that does not involve
    creating a central mapper class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将所有映射方法集中在一个类和接口下，允许你注入一个类似于AutoMapper的接口。在随后的章节中，我们将探讨组织映射器和应用程序代码的方法，这些方法不涉及创建中央映射器类。
- en: 'To inspect the generated code, you can add the `EmitCompilerGeneratedFiles`
    property in a `PropertyGroup` tag inside your project file and set its value to
    `true` like this:'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要检查生成的代码，你可以在项目文件中的`PropertyGroup`标签内添加`EmitCompilerGeneratedFiles`属性，并将其值设置为`true`，如下所示：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then the generated C# files will be available under the `obj\Debug\net8.0\generated`
    directory. Change the `net8.0` subdirectory to the SDK version and `Debug` by
    your configuration.
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，生成的C#文件将在`obj\Debug\net8.0\generated`目录下可用。根据你的配置将`net8.0`子目录更改为SDK版本和`Debug`。
- en: 'Next, we explore how to make a static mapper, which follows a very similar
    process, but we must make both the class and the method `static` like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何创建一个静态映射器，其过程非常相似，但我们必须将类和方法都设置为`static`，如下所示：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Mapperly takes the preceding code and generates the following (formatted for
    improved readability):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Mapperly将前面的代码生成以下内容（格式化以提高可读性）：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once again, the code generator writes the boilerplate code. The difference
    is that we don’t have to inject any dependency since it is a static method. We
    can use it this way (I only included the catch block, the rest of the code is
    unchanged):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，代码生成器编写了样板代码。区别在于我们不需要注入任何依赖，因为这是一个静态方法。我们可以这样使用它（我只包括了捕获块，其余代码保持不变）：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is pretty straightforward but creates a strong bond between the generated
    class and its consumers. You can use those static methods if having a hard dependency
    on a static class is acceptable for your project.The last way to map objects we
    are exploring is very similar, but we create an extension method in the same class
    instead of just a static method. Here’s the new method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接，但会在生成的类及其消费者之间建立强大的联系。如果你的项目可以接受对静态类的硬依赖，你可以使用这些静态方法。我们正在探索的将对象映射的最后一種方法非常相似，但我们是在同一个类中创建一个扩展方法，而不是仅仅一个静态方法。下面是新的方法：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The generated code for that method looks like the following (formatted):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的生成代码如下（格式化）：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The only difference is the addition of the `this` keyword, making a regular
    static method into an extension method that we can use like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是添加了`this`关键字，将常规静态方法转换为扩展方法，我们可以这样使用它：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An extension method is more elegant than a static method, yet it creates a
    bond similar to the static method. Once again, choosing how you want to proceed
    with your mapping is up to you.One noteworthy thing about Mapperly is that its
    analyzers yield information, warnings, or errors when the mapping code is incorrect
    or potentially incorrect. The severity of the messages is configurable. For example,
    if we add the following method in the `ExceptionMapper` class, Mapperly yields
    the `RMG013` error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法比静态方法更优雅，但仍然创建了一个类似于静态方法的联系。再次强调，选择如何进行映射完全取决于你。关于Mapperly的一个值得注意的事情是，当映射代码不正确或可能不正确时，其分析器会提供信息、警告或错误。消息的严重性是可以配置的。例如，如果我们向`ExceptionMapper`类添加以下方法，Mapperly会生成`RMG013`错误：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Error message:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Moreover, the two exception mapper methods yield messages about properties
    that do not exist on the target class as information. Here’s an example of such
    a message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，两个异常映射方法会提供关于目标类上不存在属性的信息。以下是一个此类消息的示例：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With those in place, we know when something is or can be wrong, which safeguards
    us from misconfigurations.Let’s wrap this chapter up.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基础上，我们知道何时某些事情是错误的或可能出错，这保护我们免受配置错误的影响。让我们结束这一章。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Object mapping is an unavoidable reality in many cases. However, as we saw in
    this chapter, there are several ways of implementing object mapping, taking that
    responsibility away from the other components of our applications or simply coding
    it inline manually.At the same time, we took the opportunity to explore the Aggregate
    Services pattern, which gives us a way to centralize multiple dependencies into
    one, lowering the number of dependencies needed in other classes. That pattern
    can help with the too-many-dependencies code smell, which, as a rule of thumb,
    states that we should investigate objects with more than three dependencies for
    design flaws. When moving dependencies into an aggregate, ensure there is cohesion
    within the aggregate to avoid adding unnecessary complexity to your program and
    just moving the dependencies around.We also explored leveraging the Façade pattern
    to implement a mapping façade, which led to a more readable and elegant mapper.Afterward,
    we implemented a mapper service that mimicked the façade. Despite being less elegant
    in its usage, it was more flexible.We finally explored is AutoMapper and Mapperly,
    two open-source tools that do object mapping for us, offering us many options
    to configure the mapping of our objects. As we explored, just using the default
    convention of AutoMapper allowed us to eliminate all of our mapping code. On Mapperly’s
    side, we had to define the mapper contracts using partial classes and methods
    to let its code generator implement the mapping code for us. You can choose from
    many existing object mapper libraries, AutoMapper being one of the oldest, most
    famous, and hated at the same time, while Mapperly is one of the newest and fastest
    but yet in its infancy.Hopefully, as we are putting more and more pieces together,
    you are starting to see what I had in mind at the beginning of this book when
    stating this was an architectural journey.Now that we are done with object mapping,
    we explore the Mediator and CQRS patterns in the next chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，对象映射是一个不可避免的现实。然而，正如我们在本章中看到的，有几种实现对象映射的方法，这可以从我们应用程序的其他组件中移除这一责任，或者简单地手动内联编码。同时，我们有机会探索聚合服务模式，它为我们提供了一种将多个依赖项集中到一个地方的方法，从而降低了其他类中所需的依赖项数量。这种模式可以帮助解决“过多的依赖项”代码异味，这是一种经验法则，指出我们应该调查具有超过三个依赖项的对象以查找设计缺陷。当将依赖项移动到聚合中时，请确保聚合内部具有内聚性，以避免向程序添加不必要的复杂性，并仅仅移动依赖项。我们还探讨了利用外观模式来实现映射外观，这导致了一个更易于阅读和优雅的映射器。之后，我们实现了一个模仿外观的映射器服务。尽管在用法上不够优雅，但它更加灵活。我们最终探索了
    AutoMapper 和 Mapperly，这两个开源工具为我们执行对象映射，为我们提供了许多配置对象映射的选项。在我们探索的过程中，仅使用 AutoMapper
    的默认约定就允许我们消除所有的映射代码。在 Mapperly 方面，我们必须使用部分类和方法定义映射器合约，以便其代码生成器为我们实现映射代码。你可以从许多现有的对象映射库中选择，AutoMapper
    是其中最古老、最著名同时也是最被憎恨的一个，而 Mapperly 是最新且最快的，但仍然处于起步阶段。希望随着我们越来越多地将各个部分组合在一起，你现在开始看到我在本书开头提到这是架构之旅时的心思。现在我们已经完成了对象映射，下一章我们将探讨中介者和
    CQRS 模式。
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习问题：
- en: Is it true that injecting an Aggregate Service instead of multiple services
    improves our system?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入聚合服务而不是多个服务是否真的能提高我们的系统？
- en: Is it true that using mappers helps us extract responsibilities from consumers
    to mapper classes?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用映射器是否真的有助于我们从消费者中提取责任到映射器类中？
- en: Is it true that you should always use AutoMapper?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的是应该始终使用 AutoMapper 吗？
- en: When using AutoMapper, should you encapsulate your mapping code into profiles?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 AutoMapper 时，你应该将你的映射代码封装到配置文件中吗？
- en: How many dependencies should start to raise a flag telling you that you are
    injecting too many dependencies into a single class?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该有多少依赖项开始引起你的注意，告诉你你正在向单个类注入过多的依赖项？
- en: Further reading
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build upon what we learned in the chapter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'If you want more information on object mapping, I wrote an article about that
    in 2017, titled *Design Patterns: ASP.NET Core Web API, Services, and Repositories
    | Part 9: the NinjaMappingService and the Façade Pattern*: [https://adpg.link/hxYf](https://adpg.link/hxYf)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于对象映射的信息，我在2017年写过一篇关于这个主题的文章，标题为 *设计模式：ASP.NET Core Web API、服务和仓储
    | 第9部分：NinjaMappingService 和外观模式*：[https://adpg.link/hxYf](https://adpg.link/hxYf)
- en: 'AutoMapper official website: [https://adpg.link/5AUZ](https://adpg.link/5AUZ)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AutoMapper 官方网站：[https://adpg.link/5AUZ](https://adpg.link/5AUZ)
- en: '*AutoMapper Usage Guidelines* is an excellent do/don’t list to help you do
    the right thing with AutoMapper, written by the library’s author: [https://adpg.link/tTKg](https://adpg.link/tTKg)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AutoMapper 使用指南* 是一份优秀的“做/不做”清单，可以帮助你正确使用 AutoMapper，由库的作者编写：[https://adpg.link/tTKg](https://adpg.link/tTKg)'
- en: 'Mapperly (GitHub): [https://adpg.link/Dwcj](https://adpg.link/Dwcj)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mapperly（GitHub）：[https://adpg.link/Dwcj](https://adpg.link/Dwcj)
- en: Answers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: Yes, an Aggregate Service can improve a system, but not necessarily. Moving
    dependencies around does not fix design flaws; it just moves those flaws elsewhere.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，聚合服务可以改进系统，但并不一定总是如此。移动依赖关系并不能修复设计缺陷；它只是将这些缺陷移动到其他地方。
- en: Yes, mappers help us follow the SRP. However, they are not always needed.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，映射器帮助我们遵循单一职责原则（SRP）。然而，它们并不总是必需的。
- en: No, it is not suitable for every scenario. For example, when the mapping logic
    becomes complex, consider not using AutoMapper. Too many mappers may also mean
    a flaw in the application design itself.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，它并不适合每个场景。例如，当映射逻辑变得复杂时，考虑不使用 AutoMapper。过多的映射器也可能意味着应用程序设计本身存在缺陷。
- en: Yes, use profiles to organize your mapping rules cohesively.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，使用配置文件来组织你的映射规则是有益的。
- en: Four or more dependencies should start to raise a flag. Once again, this is
    just a guideline; injecting four or more services into a class can be acceptable.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个或更多的依赖项应该开始引起注意。再次强调，这只是一个指导原则；将四个或更多的服务注入到类中可能是可接受的。
