- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Interactive CLI Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式命令行应用程序
- en: So far, the interaction with our CLI application (*Bookmarkr*) has mostly been
    text-based, meaning that the application responds to a text input with a text
    output. In a sense, it was mostly a request-response kind of application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与我们的CLI应用程序（*Bookmarkr*）的交互主要是基于文本的，这意味着应用程序对文本输入做出文本输出。从某种意义上说，它主要是一种请求-响应类型的应用程序。
- en: Yes, we’ve also added some colors to the text output so that the user can easily
    and instantly know whether the request was processed successfully or it ended
    with errors or warnings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们还在文本输出中添加了一些颜色，以便用户可以轻松地立即知道请求是否成功处理，或者它以错误或警告结束。
- en: However, even though CLI applications don’t provide a **graphical user interface**
    (**GUI**), that doesn’t mean they can’t be fun to use! 😉
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管命令行应用程序不提供**图形用户界面**（**GUI**），但这并不意味着它们不能有趣！ 😉
- en: 'In this chapter, we’ll learn how to enhance the output of our CLI application
    to make it more user-friendly. We’ll learn how to add the following elements:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何增强我们的CLI应用程序的输出，使其更易于使用。我们将学习如何添加以下元素：
- en: Progress bars and checkmarks to let the user know of the progress of their request.
    This is especially useful for time-consuming, long-running operations (such as
    downloading or encoding a file).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进度条和勾选标记，让用户知道他们请求的进度。这对于耗时较长的长时间运行操作（如下载或编码文件）特别有用。
- en: Lists of items to make it easier to pick a selection from a list of predefined
    items. Note that this list doesn’t have to be static; it can dynamically adapt
    to the current context of the user (for example, their permissions) and the request
    (for example, the requested command and the values of its options).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表项的列表，使其更容易从预定义项中选择。请注意，此列表不必是静态的；它可以动态地适应用户的当前上下文（例如，他们的权限）和请求（例如，请求的命令及其选项的值）。
- en: By relying on such enhancements, not only are we making our CLI application
    more fun to use, but we’re also making it more **interactive** as it can have
    a conversation with the user, keeping them updated on the progress of their operations
    or presenting them with a list of options to choose from that are tailored to
    their specific context.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖这些增强功能，我们不仅使我们的命令行界面（CLI）应用程序更易于使用，而且使其更具**交互性**，因为它可以与用户进行对话，向他们更新操作进度，或向他们展示针对其特定上下文定制的选项列表。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter07](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在与本书配套的GitHub存储库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter07](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter07)。
- en: Building interactive command-line applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建交互式命令行应用程序
- en: 'As you may have noticed – and I’m sure that you did 😉 – we’ve already created
    some helper methods to display text in different colors for different scenarios:
    green for success messages, yellow for warnings, and red for errors. The code
    for these helper methods can be found in the `Helper.cs` file.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的——我相信你确实做到了 😉——我们已经创建了一些辅助方法来在不同场景中以不同颜色显示文本：绿色用于成功消息，黄色用于警告，红色用于错误。这些辅助方法的代码可以在`Helper.cs`文件中找到。
- en: We could certainly add more methods to this file to support other features,
    such as progress bars and drop-down lists. However, as I mentioned earlier, I
    trust that you’re smart, so you won’t want to reinvent the wheel and rather rely
    on an existing library that fits the job 😊.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以向此文件添加更多方法以支持其他功能，例如进度条和下拉列表。然而，正如我之前提到的，我相信你很聪明，所以你不会想要重新发明轮子，而是依赖一个适合这项工作的现有库
    😊。
- en: Although multiple libraries may exist to fit this purpose, the one we’ll be
    using in this chapter is `Spectre.Console`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能存在多个库来满足这一目的，但我们在本章中将使用的是`Spectre.Console`。
- en: The `Spectre.Console` library is designed to enhance the creation of visually
    appealing console applications by going way beyond colored text. It also allows
    you to render trees, drop-down lists, tables, progress bars, and many other graphical
    elements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spectre.Console`库旨在通过超越彩色文本来增强创建视觉上吸引人的控制台应用程序。它还允许您渲染树、下拉列表、表格、进度条以及许多其他图形元素。'
- en: This wide range of features allows us to create rich user interfaces within
    the console environment of our CLI applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这广泛的特性允许我们在 CLI 应用程序的控制台环境中创建丰富的用户界面。
- en: 'For more details about `Spectre.Console`, you can visit its GitHub page at
    [https://github.com/spectreconsole/spectre.console](https://github.com/spectreconsole/spectre.console).
    In particular, I recommend checking out the two following repositories:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Spectre.Console` 的更多详细信息，您可以访问其 GitHub 页面 [https://github.com/spectreconsole/spectre.console](https://github.com/spectreconsole/spectre.console)。特别是，我推荐查看以下两个存储库：
- en: '`spectre.console`: The official repository of the project, which means it contains
    the code of the library'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spectre.console`：项目的官方存储库，这意味着它包含库的代码'
- en: '`Examples`: This repository contains various examples of using the library'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`示例`：此存储库包含使用库的各种示例'
- en: 'So, let’s start by adding the `Spectre.Console` library to our application.
    This can be achieved with the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先将 `Spectre.Console` 库添加到我们的应用程序中。这可以通过以下命令实现：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s start by adding a new command that we’ll call `interactive`. This command
    will be a child of the `root` command. Let’s also add a handler for the command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个名为 `interactive` 的新命令开始。这个命令将是 `root` 命令的子命令。同时，我们也为这个命令添加一个处理器：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s add the handler method for this new command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个新命令添加处理器方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since we are using the `Spectre.Console` library, let’s reference it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 `Spectre.Console` 库，让我们引用它：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding a FIGlet
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个 FIGlet
- en: A FIGlet is a way to generate large text banners using ordinary screen characters,
    in the form of ASCII art. Originally released in 1991, it became popular for creating
    eye-catching text in terminal sessions. So, it’s perfect for making our CLI applications
    more user-friendly!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: FIGlet 是一种使用普通屏幕字符生成大型文本横幅的方式，以 ASCII 艺术的形式。最初于 1991 年发布，它因在终端会话中创建引人注目的文本而变得流行。因此，它非常适合使我们的
    CLI 应用程序更易于使用！
- en: So, let’s add a FIGlet to *Bookmarkr*!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们向 *Bookmarkr* 添加一个 FIGlet！
- en: We don’t need to create the ASCII art ourselves since `Spectre.Console` alreadyprovides
    this capability. So, let’s take advantage of it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Spectre.Console` 已经提供了这个功能，我们不需要自己创建 ASCII 艺术作品。所以，让我们利用它。
- en: 'Let’s update our command handler method, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的命令处理器方法，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code creates some FIGlet text, centers it, and displays it in
    a shade of blue.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一些 FIGlet 文本，将其居中，并以蓝色色调显示。
- en: 'Now, let’s run the application and see what we’ve got so far:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序并查看我们目前所拥有的内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We should be presented with the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下输出：
- en: '![Figure 7.1 – A FIGlet for Bookmarkr](img/B22400_07_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – Bookmarkr 的一个 FIGlet](img/B22400_07_01.jpg)'
- en: Figure 7.1 – A FIGlet for Bookmarkr
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Bookmarkr 的一个 FIGlet
- en: Wow! This is awesome. This is a great start for our interactive CLI application,
    isn’t it? 😊
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这太棒了。这是我们交互式 CLI 应用程序的一个很好的开始，不是吗？😊
- en: AnsiConsole versus Console
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: AnsiConsole 与 Console 的比较
- en: 'As you may have noticed, we aren’t using the `Console.Write` method provided
    by .NET but the one provided by the `AnsiConsole` class, which is part of the
    `Spectre.Console` library. This is due to the following reasons:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，我们不是使用 .NET 提供的 `Console.Write` 方法，而是使用 `AnsiConsole` 类提供的，它是 `Spectre.Console`
    库的一部分。这是由于以下原因：
- en: 1\. `AnsiConsole` class provides a much richer set of features compared to the
    `Console` class, such as advanced text formatting, colors, styles, and interactive
    elements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. `AnsiConsole` 类相比 `Console` 类提供了一套更丰富的功能，例如高级文本格式化、颜色、样式和交互元素。
- en: 2\. `AnsiConsole` class is designed to work consistently across different operating
    systems and terminal emulators. It automatically detects the capabilities of the
    current terminal and adjusts its output accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. `AnsiConsole` 类旨在在不同操作系统和终端仿真器之间保持一致性。它自动检测当前终端的功能并根据其输出进行调整。
- en: 3\. `AnsiConsole` class offers support for 24-bit colors, text styling (such
    as bold and italic), and various widgets, such as tables, trees, and even ASCII
    images.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. `AnsiConsole` 类支持 24 位颜色、文本样式（如粗体和斜体）以及各种小部件，如表格、树形图，甚至 ASCII 图像。
- en: 4\. `AnsiConsole` class enables the creation of interactive prompts, selection
    menus, and other user input mechanisms that are more sophisticated than what’s
    possible with the standard `Console` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. `AnsiConsole` 类使创建交互式提示、选择菜单和其他比标准 `Console` 类更复杂的用户输入机制成为可能。
- en: 5\. `AnsiConsole` class supports live-rendering capabilities, allowing you to
    dynamically update content such as progress bars and status indicators.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 5. `AnsiConsole` 类支持实时渲染功能，允许你动态更新内容，如进度条和状态指示器。
- en: 6\. `AnsiConsole` class provides a rich markup language that makes it easy to
    apply colors and styles to text without complex code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 6. `AnsiConsole` 类提供了一种丰富的标记语言，使得在不复杂的代码中应用颜色和样式到文本变得容易。
- en: 7\. `IAnsiConsole` interface instead of the static `AnsiConsole` class, it becomes
    possible to unit test command handlers and other console-related code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 使用`IAnsiConsole`接口而不是静态的`AnsiConsole`类，使得对命令处理程序和其他与控制台相关的代码进行单元测试成为可能。
- en: At this point, we’ve laid the foundations for an interactive version of our
    CLI application. In the next section, we’ll add more features to make *Bookmarkr*
    even more user-friendly!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经为我们的 CLI 应用程序的交互式版本打下了基础。在下一节中，我们将添加更多功能，使 *Bookmarkr* 更加用户友好！
- en: Designing user-friendly CLI applications
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计用户友好的CLI应用程序
- en: Although tons of features are provided by `Spectre.Console` (and I encourage
    you to check them out by visiting the documentation at [https://spectreconsole.net](https://spectreconsole.net)),
    we’ll be focusing on a subset of these capabilities to add more interactivity
    to our *Bookmarkr* application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Spectre.Console`提供了许多功能（并且我鼓励您通过访问[https://spectreconsole.net](https://spectreconsole.net)上的文档来查看它们），但我们将专注于这些功能的一个子集，以增加我们的
    *Bookmarkr* 应用程序的交互性。
- en: Enhancing text display using markup
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标记增强文本显示
- en: Let’s improve our `Helper.cs` class by leveraging the markup capabilities provided
    by `Spectre.Console`. These capabilities allow us to style and format text and
    even render emojis! However, note that some terminal environments (especially
    older systems or restricted environments, such as CI/CD systems) might not support
    emoji rendering.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过利用`Spectre.Console`提供的标记功能来改进我们的`Helper.cs`类。这些功能允许我们样式化和格式化文本，甚至渲染表情符号！然而，请注意，某些终端环境（尤其是较旧的系统或受限环境，如CI/CD系统）可能不支持表情符号渲染。
- en: 'First, let’s review our three methods: `ShowErrorMessage`, `ShowWarningMessage`,
    and `ShowSuccessMessage`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾我们的三个方法：`ShowErrorMessage`、`ShowWarningMessage` 和 `ShowSuccessMessage`。
- en: 'These methods differ in the color in which they display the text that’s received
    as a parameter, but they’re similar in the way that they all follow the same process:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在显示接收到的文本参数的颜色上有所不同，但它们在遵循相同过程的方式上是相似的：
- en: First, they save the current foreground color to a temporary variable.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它们将当前的前景色保存到一个临时变量中。
- en: Then, they change the foreground color to the intended color (red, yellow, or
    green).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，他们将前景色更改为预期的颜色（红色、黄色或绿色）。
- en: Next, they display the received text using that color.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接着，它们使用该颜色显示接收到的文本。
- en: Finally, they restore the foreground color to the saved color.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它们将前景色恢复到保存的颜色。
- en: This is made easier by the `Spectre.Console` library. We don’t have to save
    and restore the current foreground color (the library does this for us). It also
    opens some new possibilities. Let’s explore some while redefining these methods!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这得益于`Spectre.Console`库。我们不必保存和恢复当前的前景色（库会为我们做这件事）。它还打开了一些新的可能性。让我们在重新定义这些方法的同时探索一些！
- en: The ShowErrorMessage method
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ShowErrorMessage`方法'
- en: We still want the error message to be displayed in red, but we also want to
    use emojis to make it more eye-catching.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然希望错误信息以红色显示，但我们还想使用表情符号使其更加引人注目。
- en: 'The code looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是这样的：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are many things worth mentioning in this code sample:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中有许多值得提及的地方：
- en: First, we set the encoding to UTF-8\. This ensures that emojis are rendered
    properly. Otherwise, they’ll be replaced by question marks.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将编码设置为UTF-8。这确保了表情符号能够正确渲染。否则，它们将被问号替换。
- en: 'Speaking about emojis, notice that we can display them in two ways: we can
    either use the `Known` enumeration under the `Emoji` class or use markup code
    (here, we used`:cross_mark:`). The full list of supported emojis, along with their
    markup codes and enumeration constants, can be found at [https://spectreconsole.net/appendix/emojis](https://spectreconsole.net/appendix/emojis).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说到表情符号，请注意我们可以用两种方式显示它们：我们既可以使用`Emoji`类下的`Known`枚举，也可以使用标记代码（这里我们使用了`:cross_mark:`）。支持的完整表情符号列表，包括它们的标记代码和枚举常量，可以在[https://spectreconsole.net/appendix/emojis](https://spectreconsole.net/appendix/emojis)找到。
- en: We use `AnsiConsole.MarkupLine(…)` to display the word *ERROR* in bold and red
    surrounded by cross marks. The syntax is based on `BBCode` ([https://en.wikipedia.org/wiki/BBCode](https://en.wikipedia.org/wiki/BBCode)).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `AnsiConsole.MarkupLine(…)` 来显示带交叉标记的粗体和红色单词 *ERROR*。语法基于 `BBCode` ([https://en.wikipedia.org/wiki/BBCode](https://en.wikipedia.org/wiki/BBCode))。
- en: Since the `ShowErrorMessage` method receives an array of strings, we display
    each string in red. However, this time, we rely on the `MarkupLineInterpolated`
    method of the `AnsiConsole` class because we’re performing string interpolation.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `ShowErrorMessage` 方法接收一个字符串数组，我们以红色显示每个字符串。然而，这次，我们依赖于 `AnsiConsole` 类的
    `MarkupLineInterpolated` 方法，因为我们正在进行字符串插值。
- en: 'Let’s see what happens if we call the `ShowErrorMessage` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调用 `ShowErrorMessage` 方法会发生什么：
- en: '![Figure 7.2 – The updated ShowErrorMessage method in action](img/B22400_07_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 更新的 ShowErrorMessage 方法执行效果](img/B22400_07_02.jpg)'
- en: Figure 7.2 – The updated ShowErrorMessage method in action
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 更新的 ShowErrorMessage 方法执行效果
- en: Notice that the *Hello!* message isn’t displayed in red but rather in the previous
    foreground color of the terminal, without us having to handle this.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，*Hello!* 消息没有以红色显示，而是在终端的先前前景色中显示，我们无需处理这一点。
- en: Now, let’s update the `ShowWarningMessage` and `ShowSuccessMessage` methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新 `ShowWarningMessage` 和 `ShowSuccessMessage` 方法。
- en: The ShowWarningMessage method
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ShowWarningMessage 方法
- en: We still want to display the warning message in yellow, but let’s also align
    it so that it’s in the center of the screen (and, yes, we’ll use emojis too 😊).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然希望以黄色显示警告消息，但让我们也使其居中显示在屏幕中央（是的，我们也会使用表情符号 😊）。
- en: 'The updated code looks like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码看起来是这样的：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code is very similar to the code for `ShowErrorMessage`. However, there’s
    a slight difference: instead of calling the `MarkupLine` method to display the
    *Warning* text surrounded by emojis, we instantiate an object of the `Markup`
    type, then call its `Centered()` method before passing it as a parameter to the
    `Write` method. This is required so that we can center that text on the screen.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 `ShowErrorMessage` 的代码非常相似。然而，有一个细微的差别：我们不是调用 `MarkupLine` 方法来显示带表情符号的
    *Warning* 文本，而是实例化一个 `Markup` 类型的对象，然后在其 `Centered()` 方法之前调用它，然后再将其作为参数传递给 `Write`
    方法。这是必要的，以便我们可以将文本居中显示在屏幕上。
- en: Also, notice that just after that, we call the `WriteLine` method without any
    parameter. This ensures that a line break is performed before the warning information
    is displayed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意在那之后，我们调用 `WriteLine` 方法而没有任何参数。这确保在显示警告信息之前执行换行。
- en: 'Let’s see what happens if we call the `ShowWarningMessage` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调用 `ShowWarningMessage` 方法会发生什么：
- en: '![Figure 7.3 – The updated ShowWarningMessage method in action](img/B22400_07_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 更新的 ShowWarningMessage 方法执行效果](img/B22400_07_03.jpg)'
- en: Figure 7.3 – The updated ShowWarningMessage method in action
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 更新的 ShowWarningMessage 方法执行效果
- en: Once again, notice that the *Hello!* message isn’t displayed in red but rather
    in the previous foreground color of the terminal, without us having to handle
    this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，*Hello!* 消息没有以红色显示，而是在终端的先前前景色中显示，我们无需处理这一点。
- en: The ShowSuccessMessage method
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ShowSuccessMessage 方法
- en: We still want to display the success message in green.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然希望以绿色显示成功消息。
- en: 'The updated code looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码看起来是这样的：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There’s absolutely nothing worth mentioning here, except maybe that we decided
    to use heart emojis to celebrate the success of the operation! 😊 Congratulations
    – you’re starting to master the skills of styling and formatting text using `Spectre.Console`!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里绝对没有什么值得提及的，也许只是我们决定使用心形表情符号来庆祝操作的顺利完成！😊 恭喜你 – 你开始掌握使用 `Spectre.Console` 风格化和格式化文本的技能了！
- en: 'Let’s see what happens if we call the `ShowSuccessMessage` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调用 `ShowSuccessMessage` 方法会发生什么：
- en: '![Figure 7.4 – The updated ShowSuccessMessage method in action](img/B22400_07_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 更新的 ShowSuccessMessage 方法执行效果](img/B22400_07_04.jpg)'
- en: Figure 7.4 – The updated ShowSuccessMessage method in action
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 更新的 ShowSuccessMessage 方法执行效果
- en: Once again, notice that the *Hello!* message isn’t displayed in red but rather
    in the previous foreground color of the terminal, without us having to handle
    this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，*Hello!* 消息没有以红色显示，而是在终端的先前前景色中显示，我们无需处理这一点。
- en: Now that we can make our text more eye-catching, let’s improve our interactive
    command by adding more features.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让我们的文本更加引人注目，让我们通过添加更多功能来改进我们的交互式命令。
- en: Offering choices to the user using selection prompts
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择提示向用户提供选项
- en: Showing text in a visually pleasant manner is important, but interacting with
    the user and getting their input is equally important. Fortunately, `Spectre.Console`
    provides many ways to interact with the user. Let’s explore one of these.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以视觉上令人愉悦的方式显示文本很重要，但与用户交互并获取他们的输入同样重要。幸运的是，`Spectre.Console`提供了许多与用户交互的方式。让我们探索其中的一种。
- en: For now, our interactive command only shows a FIGlet. It’s certainly great,
    but let’s make it more valuable to the user. One thing we can add is a list of
    all operations a user can perform. To do so, we will use a **selection prompt**.
    This will allow the user to navigate the list using the up and down arrows on
    their keyboard and confirm the operation to be executed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的交互式命令只显示一个FIGlet。这当然很棒，但让我们让它对用户更有价值。我们可以添加的一件事是列出用户可以执行的所有操作。为此，我们将使用**选择提示**。这将允许用户使用键盘上的上下箭头导航列表，并确认要执行的操作。
- en: 'Here’s what it looks like in action:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它在实际操作中的样子：
- en: '![Figure 7.5 – The selection prompt in action](img/B22400_07_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 选择提示在实际操作中的应用](img/B22400_07_05.jpg)'
- en: Figure 7.5 – The selection prompt in action
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 选择提示在实际操作中的应用
- en: 'Here’s the updated code of the `OnInteractiveCommand` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`OnInteractiveCommand`方法的更新代码：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s take a closer look at this code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这段代码：
- en: We want the user to be able to keep picking up operations until they decide
    to exit the program (by selecting the *Exit Program* option from the selection
    prompt). That’s why we placed our code inside a `while` loop that relies on the
    value of a Boolean variable that’s initially set to `true`. When the user selects
    *Exit Program*, the Boolean variable is set to `false` and the program is exited.
    Otherwise, the selection prompt is displayed to the user after each completed
    operation.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望用户能够继续选择操作，直到他们决定退出程序（通过从选择提示中选择*退出程序*选项）。这就是为什么我们将代码放在一个依赖于初始设置为`true`的布尔变量的`while`循环中。当用户选择*退出程序*时，布尔变量被设置为`false`，程序退出。否则，在每次完成操作后，选择提示都会显示给用户。
- en: We instantiate the `SelectionPrompt` class (provided by `Spectre.Console`),
    specifying a title and a list of available options that will be displayed to the
    user. The user can then navigate this list using the up and down arrows and confirm
    their selection by hitting the *Enter* key. When they do, the `selectedOperation`
    variable is set to the selected value.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实例化了`SelectionPrompt`类（由`Spectre.Console`提供），指定了一个标题和将显示给用户的可用选项列表。用户可以使用上下箭头导航此列表，并通过按下*Enter*键确认他们的选择。当他们这样做时，`selectedOperation`变量被设置为所选值。
- en: Finally, we use a `switch` statement to call a specific method, depending on
    the value of the `selectedOperation` variable. That method will process the requested
    operation. Note that these methods haven’t been implemented yet – we’ll focus
    on them in the upcoming sections.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用`switch`语句根据`selectedOperation`变量的值调用一个特定方法。该方法将处理请求的操作。请注意，这些方法尚未实现——我们将在接下来的章节中关注它们。
- en: Multi-selection
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 多选
- en: The `Spectre.Console` library also provides multi-selection prompts, which allow
    the user to select more than one item from a list of possible choices. You can
    find an illustrative example, along with a code sample, at [https://spectreconsole.net/prompts/multiselection](https://spectreconsole.net/prompts/multiselection).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spectre.Console`库还提供了多选提示，允许用户从可能的选项列表中选择多个项目。您可以在[https://spectreconsole.net/prompts/multiselection](https://spectreconsole.net/prompts/multiselection)找到一个说明性的示例，以及一个代码示例。'
- en: Showing live progress of the export command
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示导出命令的实时进度
- en: The previous iteration of our export command was a little bit… dry! It certainly
    exported the bookmarks to the specified output file as expected, but it didn’t
    give us information on the progress of the operation. We couldn’t know whether
    it was halfway done or whether it was still at the very first few items out of
    a thousand. Thanks to the capabilities of `Spectre.Console`, we can display live
    progress along the way.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前导出命令的迭代有点……枯燥！它确实按照预期将书签导出到指定的输出文件，但它没有提供关于操作进度的信息。我们无法知道它是否已经完成了一半，或者它是否仍然在千个项目的最前面几个。多亏了`Spectre.Console`的功能，我们可以在过程中显示实时进度。
- en: There’s both a synchronous and an asynchronous method for showing live progress.
    Since our export code is asynchronous, we’ll use the latter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 展示实时进度的方法有两种：同步和异步。由于我们的导出代码是异步的，我们将使用后者。
- en: 'So, let’s implement the `ExportBookmarks` method we saw in the previous section.
    Here’s the code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现上一节中看到的 `ExportBookmarks` 方法。以下是代码：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s take a closer look at this code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这段代码：
- en: First, we ask the user for the filename. We achieved this by using `AnsiConsole.Prompt`
    and passing an instance of `TextPrompt`. This class also allows us to specify
    a default value if no value has been provided by the user or if they’re fine with
    it.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们要求用户输入文件名。我们通过使用 `AnsiConsole.Prompt` 并传递一个 `TextPrompt` 实例来实现这一点。此类还允许我们指定默认值，如果用户没有提供值或对此满意的话。
- en: 'Next, we display the progress bar by calling `AnsiConsole.Progress`. The processing
    of the export operation is implemented as a delegate within the `Start` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用 `AnsiConsole.Progress` 来显示进度条。导出操作的处理在 `Start` 方法内作为委托实现：
- en: We start by retrieving the list of bookmarks to be exported.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检索要导出的书签列表。
- en: Next, we create an instance of the `Task` class, which will be responsible for
    tracking the processing of the export operation and incrementing the progress
    bar’s percentage. We also set the maximum value for that task to the number of
    bookmarks to be exported.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `Task` 类的实例，该实例将负责跟踪导出操作的处理并增加进度条的百分比。我们还设置了该任务的最大值为要导出的书签数量。
- en: Then, we open a stream writer to the export file. While the task hasn’t been
    completed (indicated by the `ctx.IsFinished` Boolean value), we serialize each
    bookmark as JSON and write it to the file, increment the task (which, in turn,
    will update the progress bar), and wait 1.5s (this is optional, but since the
    export operation isn’t that time-consuming, adding a delay allows us to see the
    animation of the progress bar 😊).
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开一个流写入器到导出文件。在任务未完成（由 `ctx.IsFinished` 布尔值指示）时，我们将每个书签序列化为 JSON 并将其写入文件，增加任务（这将反过来更新进度条），并等待
    1.5 秒（这是可选的，但由于导出操作并不耗时，添加延迟可以让我们看到进度条的动画 😊）。
- en: 'You may have noticed some lines of code before the `Start` method is called.
    These are here to configure the look and behavior of the progress bar:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到了在调用 `Start` 方法之前的一些代码行。这些代码在这里是为了配置进度条的外观和行为：
- en: '`AutoRefresh(true)`: We enable auto-refresh of the progress bar. Otherwise,
    even if we increment the value of the task, the progress bar won’t be animated
    to reflect the updated value.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoRefresh(true)`: 我们启用了进度条的自动刷新。否则，即使我们增加任务的值，进度条也不会动画化以反映更新的值。'
- en: '`AutoClear(false)`: This prevents the task from being removed once completed.
    This is especially useful if we display the progress of multiple, concurrent operations.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoClear(false)`: 这将防止任务完成后被移除。这在显示多个并发操作的进度时特别有用。'
- en: '`HideCompleted(false)`: This prevents the task from being hidden once completed.
    This is especially useful if we display the progress of multiple, concurrent operations.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HideCompleted(false)`: 这将防止任务完成后被隐藏。这在显示多个并发操作的进度时特别有用。'
- en: '`Columns`: This collection controls the look of the progress bar. In this case,
    we decided to display the description of the task, the progress bar, the current
    percentage of the operation, the remaining time to complete the operation, and
    a spinner indicating that the operation is ongoing (this proves helpful in situations
    where dealing with time-consuming operations for which the progress bar may be
    updated at longer intervals but since the spinner keeps, well… spinning, the user
    has that sentiment that the operation is still ongoing).'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Columns`: 这个集合控制进度条的外观。在这种情况下，我们决定显示任务的描述、进度条、当前操作百分比、完成操作剩余时间以及一个指示操作正在进行的旋转器（这在处理进度条可能更新间隔较长的耗时操作时很有帮助，因为旋转器会一直旋转，用户就会有一种操作仍在进行的感受）。'
- en: 'Now that the code has been implemented, let’s run the program and see what
    we get:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经实现，让我们运行程序看看我们得到什么结果：
- en: '![Figure 7.6 – Showing live progress while exporting bookmarks](img/B22400_07_06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 导出书签时显示实时进度](img/B22400_07_06.jpg)'
- en: Figure 7.6 – Showing live progress while exporting bookmarks
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 导出书签时显示实时进度
- en: Now, our export operation is more user-friendly (and, let’s face it, more fun
    to use 😊). The user is informed of the progress of the export operation as it
    continues to run.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的导出操作更加用户友好（坦白说，使用起来更有趣 😊）。用户会被告知导出操作的进度，随着操作的继续运行。
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the terminal isn’t considered interactive (for example, when running in a
    continuous integration system), any progress will be displayed in a simpler way
    (such as the current percentage value being displayed on a new line).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果终端不被认为是交互式的（例如，在持续集成系统中运行时），任何进度将以更简单的方式显示（例如，当前百分比值显示在新行上）。
- en: With that, we’ve exported our bookmarks to a file and we can view them from
    there. Awesome! But what if we wanted to view them right from within the CLI application?
    Let’s see how we can have a visually pleasant representation of these bookmarks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经将书签导出到文件中，并且可以从中查看它们。太棒了！但如果我们想直接在 CLI 应用程序中查看它们怎么办？让我们看看我们如何能够有一个视觉上令人愉悦的书签表示。
- en: Displaying bookmarks in a tree view
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以树形视图显示书签
- en: The `Spectre.Console` library provides various options to display a list of
    elements. We can use tables, trees, layouts, panels, grids, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spectre.Console` 库提供了各种选项来显示元素列表。我们可以使用表格、树、布局、面板、网格等等。'
- en: Since we want to display the list of our bookmarks based on the categories to
    which they belong, we’ll use a tree representation. So, let’s implement the `ViewBookmarks`
    method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要根据书签所属的类别显示书签列表，我们将使用树表示。因此，让我们实现 `ViewBookmarks` 方法。
- en: 'Here’s the code for this method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个方法的代码：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s explain this code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下这段代码：
- en: First, we create the root element of the tree, and we label it *Bookmarks*.
    This label will be displayed to indicate what elements this tree is presenting.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建树的根元素，并将其标记为 *Bookmarks*。这个标签将显示出来，以指示这个树展示了哪些元素。
- en: Next, we add four nodes (one for each category). These labels are children of
    the root node, and their labels are displayed in yellow.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加四个节点（每个类别一个）。这些标签是根节点的子节点，它们的标签以黄色显示。
- en: Then, we call the `GetBookmarksByCategory` method of `BookmarkService` to retrieve
    the list of bookmarks associated with the specified category (in this case, *Tech
    Books*). After, we iterate over this list and add each bookmark as a child node
    to the `techBooksCategory` node.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用 `BookmarkService` 的 `GetBookmarksByCategory` 方法来检索与指定类别（在这种情况下，*Tech
    Books*）关联的书签列表。之后，我们遍历这个列表，并将每个书签作为子节点添加到 `techBooksCategory` 节点。
- en: We do the same thing for the other categories. The preceding code sample has
    been simplified and only shows the code for the *Tech Books* category for clarity.
    However, the complete code can be found in this book’s GitHub repository.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对其他类别做同样的事情。前面的代码示例已经简化，只显示了 *Tech Books* 类别的代码以供清晰。然而，完整的代码可以在本书的 GitHub
    仓库中找到。
- en: Finally, we display the label in the console.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在控制台中显示标签。
- en: Pretty straightforward, isn’t it?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 很直接，不是吗？
- en: 'Now, let’s run the program and see how it looks:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行程序并看看它的样子：
- en: '![Figure 7.7 – Showing bookmarks as a tree view, grouped by categories](img/B22400_07_07.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 以树形视图显示书签，按类别分组](img/B22400_07_07.jpg)'
- en: Figure 7.7 – Showing bookmarks as a tree view, grouped by categories
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 以树形视图显示书签，按类别分组
- en: Wow. What an improvement! The interactive version of our CLI application looks
    great and is more user-friendly and engaging, don’t you think? 😉
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 哇。多么大的改进！我们的 CLI 应用程序的交互式版本看起来很棒，更用户友好且更具吸引力，不是吗？😉
- en: To be or not to be interactive?
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要交互还是不要交互？
- en: Providing an interactive version of a CLI application certainly enhances the
    user experience. So, shouldn’t we always provide it? Shouldn’t it be the default
    version? These are great questions. Thanks for asking! 😊
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个 CLI 应用的交互式版本无疑增强了用户体验。那么，我们难道不应该总是提供它吗？它难道不应该成为默认版本吗？这些问题很棒。感谢提问！😊
- en: 'Let’s start with the first one: **shouldn’t we always provide it?** We certainly
    should as it (as mentioned previously) improves the user experience and engagement.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个问题开始：**我们难道不应该总是提供它吗？** 我们当然应该提供，因为它（如前所述）可以改善用户体验和参与度。
- en: '**Shouldn’t it be the default version?** It could! It depends on your target
    audience:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**它难道不应该成为默认版本吗？** 它可以！这取决于你的目标受众：'
- en: If your CLI application is primarily intended to be run by humans, then yes!
    You should make the interactive version the default one. In this case, your commands
    could provide a `--non-interactive` option to disable this interactive behavior
    when that command is executed by a program (in a CI/CD pipeline, for example).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的 CLI 应用程序主要是为了由人类运行，那么是的！你应该将交互式版本设置为默认版本。在这种情况下，你的命令可以提供一个 `--non-interactive`
    选项，以便在程序执行该命令时（例如在 CI/CD 管道中）禁用此交互行为。
- en: If your CLI application is primarily intended to be run by programs (such as
    one for processing a large batch of files or a CI/CD pipeline), your commands
    could provide a `--interactive` option to enable interactive behavior when they’re
    executed by humans.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的 CLI 应用程序主要是为了由程序运行（例如用于处理大量文件或 CI/CD 管道），你的命令可以提供一个 `--interactive` 选项，以便在由人类执行时启用交互式行为。
- en: In other words, interactivity is fantastic, but use it wisely!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，交互性非常棒，但请明智地使用它！
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we made *Bookmarkr* more user-friendly and graphically appealing
    by introducing progress bars, checkmarks, and lists of items for easier user selection
    and ensuring that only valid values are selected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过引入进度条、勾选标记和项目列表，使 *Bookmarkr* 更加用户友好和图形化，以便于用户选择，并确保只选择有效值。
- en: We learned that these additions, in combination with text coloring, help make
    our CLI applications more compelling and fun to use and showed that CLI applications
    have nothing to be ashamed of in front of GUI applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，这些添加功能与文本着色相结合，有助于使我们的 CLI 应用程序更具吸引力和趣味性，并表明 CLI 应用程序在 GUI 应用程序面前没有任何可羞愧之处。
- en: But that’s not all! We also learned that these additions help make our CLI applications
    more conversational (that is, interactive) with the user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部！我们还了解到，这些添加功能有助于使我们的 CLI 应用程序与用户更加对话式（即交互式）。
- en: In the next chapter, we’ll learn how to make our CLI application have a more
    modular design so that it’s easier to extend.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使我们的 CLI 应用程序具有更模块化的设计，以便更容易扩展。
- en: Your turn!
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码是一种通过实践学习的好方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding various features.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你通过添加各种功能来改进 *Bookmarkr* 应用程序。
- en: Task 1 – present a bookmark in a user-friendly way
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务 1 – 以用户友好的方式展示书签
- en: You’ve been asked to add a `show` command that takes the name of a bookmark
    and displays it in a three-column grid – one for the name, one for the URL, and
    one for the category.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求添加一个 `show` 命令，该命令接受书签的名称，并以三列网格的形式显示它 – 一列用于名称，一列用于 URL，一列用于分类。
- en: The grid should contain a row for the headers (name, URL, and category).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网格应包含一行用于标题（名称、URL 和分类）。
- en: The name should be displayed in yellow and bold; the URL should be presented
    as a link; and the category should be presented in italics and green.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 名称应以黄色和粗体显示；URL 应作为链接呈现；分类应以斜体和绿色显示。
- en: 'The syntax of the command should be as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的语法应如下所示：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Task 2 – change the category of a bookmark interactively
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务 2 – 交互式更改书签的分类
- en: You’ve been asked to implement a new command called `category change` that changes
    the category of an existing URL.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求实现一个名为 `category change` 的新命令，该命令更改现有 URL 的分类。
- en: The command must display the list of existing categories as a selection menu;
    the user will have to select which one will be set as the new category for that
    bookmark based on its URL. This update will then be saved to the database.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 命令必须显示现有分类的列表作为选择菜单；用户将不得不根据其 URL 选择将其设置为该书签的新分类。然后，此更新将被保存到数据库中。
- en: 'The syntax of the command should be as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的语法应如下所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
