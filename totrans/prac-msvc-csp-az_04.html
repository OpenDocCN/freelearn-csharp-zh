<html><head></head><body>
		<div><h1 id="_idParaDest-93" class="chapter-number"><a id="_idTextAnchor092"/>4</h1>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Creating Libraries for Client Applications</h1>
			<p>With the updates from the last chapter, the Game API is available to use – including access to the database. In this chapter, we’ll create a .NET library that can be used by all .NET client applications to access the service. Instead of the need to create HTTP requests with every client application, we create a library that can be shared.</p>
			<p>In this chapter, you’ll do the following:</p>
			<ul>
				<li>Create a library to send HTTP requests</li>
				<li>Create a client console application to play a game using the library</li>
				<li>Use the Microsoft Kiota tool to generate code based on the OpenAPI document</li>
			</ul>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository at <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>. The source code folder <code>ch04</code> contains the code samples for this chapter.</p>
			<p>The service implementation from the previous chapter is stored in the <code>server</code> folder. There’s just a small change to the previous chapter with the models. The models contain annotations (<code>Required</code>, <code>MinLength</code>, and <code>MaxLength</code> attributes). This information shows up in the OpenAPI document and can be used on creating the client. You can use the file <code>Chapter04.server.sln</code> to open and run the solution. You need to start the service when running the client application. Based on your preference, you need to configure SQL Server or Azure Cosmos DB as discussed in the previous chapter. You can also use the in-memory repository instead so that you don’t need to have a database running. Change the configuration with the <code>appsettings.json</code> file based on your needs.</p>
			<p>The new code is in the <code>client</code> folder. Here, you will find these projects:</p>
			<ul>
				<li><code>Codebreaker.GameApis.Client</code>: This is the new library that includes custom models and the <code>GamesClient</code> class, which sends HTTP requests to the service</li>
				<li><code>Codebreaker.Client.Console</code>: This is a new console application that references the client library and can be used to play the game</li>
				<li><code>Codebreaker.GamesApis.Kiota</code>: This is a client library that can be used as an alternative to <code>Codebreaker.GameApis.Client</code> with generated code</li>
				<li><code>Codebreaker.Kiota.Console</code>: This is a console application that uses the Kiota client library</li>
			</ul>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Creating a library to create HTTP requests</h1>
			<p>With a microservices team, a good practice is when the team is not only responsible to develop the complete service including the database access code, but also at least one of the client applications. With traditional development teams, client and server development is often spread across different teams. The issue with that is that the client and service are best created in collaboration. Creating the client, you’ll find answers missing from the services API. Here, a fast communication between the client and service developers helps.</p>
			<p>Creating a library for the client allows us to reuse this functionality from all .NET clients; you can create clients with any .NET client technology, such as Blazor, WinUI, .NET MAUI, and others. In this chapter, we will just create a console application, but you can find clients using Blazor, WinUI, .NET MAUI, WPF, and Platform Uno in the GitHub organization at <a href="https://github.com/codebreakerapp">https://github.com/codebreakerapp</a>.</p>
			<p>To create<a id="_idIndexMarker211"/> the library to be used by client applications, we do the following:</p>
			<ol>
				<li>Create a library with multi-targeting support to support different .NET versions with the clients</li>
				<li>Inject the <code>HttpClient</code> with the main class the client interacts with.</li>
				<li>Send HTTP requests to the games service.</li>
				<li>Create a NuGet package<a id="_idIndexMarker212"/> for easier use.</li>
			</ol>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Creating a library with multi-targeting support</h2>
			<p>We create the library<a id="_idIndexMarker213"/> for the client<a id="_idIndexMarker214"/> using the <code>dotnet</code> CLI:</p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.GameApis.Client</pre>
			<p>With this library, we need the model types for the data to transfer between the client and the service and a client class that does the HTTP requests to invoke the services API.</p>
			<p>To support clients using different .NET versions, the library is configured with multi-targeting support:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Codebreaker.GameAPIs.Client.csproj</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
<strong class="bold">  &lt;TargetFrameworks&gt;net7.0;net8.0&lt;/TargetFrameworks&gt;</strong>
  &lt;!-- code removed for brevity --&gt;
&lt;/PropertyGroup&gt;</pre>
			<p>Instead of the default entry, <code>TargetFramework</code>, an <code>s</code> is appended to contain a list of frameworks. With multiple frameworks added, multiple binaries are added when creating a NuGet package. It might be okay for you to create a library with .NET 6, which can also be used from .NET 7 and .NET 8 clients. Using multiple frameworks you can create optimized code based on the client version.</p>
			<p>An optimization is shown with the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs</p>
			<pre class="source-code">
<strong class="bold">#if NET8_0_OR_GREATER</strong>
<strong class="bold">[JsonConverter(typeof(JsonStringEnumConverter&lt;GameType&gt;))]</strong>
<strong class="bold">#else</strong>
<strong class="bold">[JsonConverter(typeof(JsonStringEnumConverter))]</strong>
<strong class="bold">#endif</strong>
public enum GameType
{
    Game6x4,
    Game6x4Mini,
    Game8x5,
    Game5x5x4,
}</pre>
			<p>Generic attributes are new since C# 11. The generic type of the <code>JsonStringEnumConverter</code> is new with .NET 8. This generic version supports Native AOT compilation. The older version and the non-generic <code>JsonStringEnumConverter</code> uses reflection. Using the C# preprocessor directive <code>#if</code> and the predefined symbol <code>NET8_0_OR_GREATER</code>, different code gets compiled based on the framework version.</p>
			<p>The models are mainly<a id="_idIndexMarker215"/> the same between the client <a id="_idIndexMarker216"/>and the service. Here, you might choose to move the models from the service-only library to a common library that is referenced both from the client and service applications. However, with client technologies, you might have other requirements based on validating and change notification. With the models of the client library, you can implement the interface <code>INotifyPropertyChanged</code>, which is used by different client technologies to update the user interface automatically if a change is notified. Later in this chapter, we’ll also create a library from the OpenAPI document created in <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, which can be another reason not to create a shared library.</p>
			<p><code>CreateGameRequest</code> is the class we need to send the request when starting the game:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs</p>
			<pre class="source-code">
[JsonConverter(typeof(JsonStringEnumConverter&lt;GameType&gt;))]
public enum GameType
{
  Game6x4,
  Game6x4Mini,
  Game8x5,
  Game5x5x4,
}
public record class CreateGameRequest(
  GameType,
  string PlayerName);</pre>
			<p>The <code>CreateGameRequest</code> contains<a id="_idIndexMarker217"/> the properties <code>GameType</code> and <code>PlayerName</code>, which are required<a id="_idIndexMarker218"/> to start the game. The <code>GamesQuery</code> class is used to send different query parameters to retrieve a filtered list of games based on the query:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/Models/GamesQuery.cs</p>
			<pre class="source-code">
public record class GamesQuery(
  GameType? GameType = default,
  string? PlayerName = default,
  DateOnly? Date = default,
  bool? Ended = false)
{
  public string AsUrlQuery()
  {
    var queryString = "?";
    if (GameType != null)
    {
      queryString += $"gameType={GameType}&amp;";
    }
    if (PlayerName != null)
    {
      queryString += $"playerName={Uri.EscapeDataString(PlayerName)}&amp;";
    }
    // code removed for brevity
    queryString = queryString.TrimEnd('&amp;');
    return queryString;
  }
}</pre>
			<p>The <code>AsUrlQuery</code> method converts<a id="_idIndexMarker219"/> the properties of the record<a id="_idIndexMarker220"/> to create HTTP query parameters as specified with the games API service and returns the combined query string. You might think about adding this method to the <code>Game</code> class. The <code>Game</code> class just defines the structure of the data representing a game. The <code>GamesQuery</code> class controls how its data can be converted into a URL query string.</p>
			<p>Additionally, <code>CreateGameResponse</code>, <code>UpdateGameRequest</code>, <code>UpdateGameResponse</code>, <code>Game</code>, and <code>Move</code> are needed with this library. Check these types with the GitHub repo.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Injecting the HttpClient class</h2>
			<p>The <code>GamesClient</code> class we create<a id="_idIndexMarker221"/> next is used to send requests to the games service. To use the <code>HttpClient</code> class, an object of this class can be injected. With the application using the library, this <code>HttpClient</code> needs to be configured with the base address (in <a href="B21217_09.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a>, this will be extended with authentication).</p>
			<p>The implementation of the constructor of the <code>GamesClient</code> class is shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public class GamesClient(HttpClient httpClient)
{
  private readonly HttpClient _httpClient = httpClient;
  private readonly JsonSerializerOptions _jsonOptions = new()
  {
    PropertyNameCaseInsensitive = true
  };
  // code removed for brevity</pre>
			<p>With the constructor of the <code>GamesClient</code>, the injected <code>HttpClient</code> instance is assigned to a variable, and <code>JsonOptions</code> is configured. ASP.NET Core maps properties on JSON serialization to lowercase. With the options as defined here, casing is ignored, so the lowercase map is transferred to uppercase properties.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Don’t create a new instance of the <code>HttpClient</code> class with every request. Instead, injecting the client will shift the responsibility to creating instances to the calling application. With the dependency injection container, we’ll configure the <code>HttpClient</code> to be created from a factory.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Sending HTTP requests</h2>
			<p>Let’s send some requests<a id="_idIndexMarker222"/> to the service to retrieve information about games, start games, and set moves.</p>
			<p>The first methods are used to retrieve game information:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public async Task&lt;Game?&gt; GetGameAsync(bool id, CancellationToken cancellationToken = default)
{
  Game game = default;
  try
  {
    game = await <strong class="bold">_httpClient.GetFromJsonAsync&lt;Game&gt;(</strong>
<strong class="bold">      $"/games/{id}", _jsonOptions, cancellationToken);</strong>
  }
  catch (HttpRequestException ex) when (ex.StatusCode = 
  HttpStatusCode.NotFound)
  {
    return default;
  }
  return game;
}
public async Task&lt;IEnumerable&lt;Game&gt;&gt; GetGamesAsync(GamesQuery query, CancellationToken cancellationToken = default)
{
  IEnumerable&lt;Game&gt; games = (
    await <strong class="bold">_httpClient.GetFromJsonAsync&lt;IEnumerable&lt;Game&gt;&gt;(</strong>
<strong class="bold">      $"/games/{query.AsUrlQuery()}", _jsonOptions, </strong>
<strong class="bold">      cancellationToken))</strong> ?? Enumerable.Empty&lt;Game&gt;();
  return games;
}</pre>
			<p>The <code>GetGameAsync</code> method retrieves<a id="_idIndexMarker223"/> one game passing the identifier of the game. <code>GetGamesAsync</code> uses the previously created <code>GamesQuery</code> to create the URI for the service to send the HTTP GET request. <code>GetFromJsonAsync</code> is an extension method for the <code>HttpClient</code> class to send an HTTP GET request, checks for a successful status code using <code>EnsureSuccessStatusCode</code> with <code>HttpResponseMessage</code> (which throws an <code>HttpRequestException</code> if not successful), and uses the <code>System.Text.Json</code> deserializer to deserialize the stream from the response. When the <code>game-id</code> passed was not found, we want to return <code>null</code> instead of throwing an exception so this exception is caught.</p>
			<p>Sending a request to start a game is implemented with the <code>StartGameAsync</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public async Task&lt;(Guid id, int numberCodes, int maxMoves, IDictionary&lt;string, string[]&gt; FieldValues)&gt;
  StartGameAsync(GameType gameType, string playerName, 
  CancellationToken cancellationToken = default)
{
  CreateGameRequest createGameRequest = new(_gameType, _playerName);
<strong class="bold">  var response = await _httpClient.PostAsJsonAsync("/games", </strong>
    <strong class="bold">createGameRequest, cancellationToken);</strong>
  response.EnsureSuccessStatusCode();
  var gameResponse = await response.Content.
    ReadFromJsonAsync&lt;CreateGameResponse&gt;(
    _jsonOptions, cancellationToken);
  if (gameResponse is null)
    throw new InvalidOperationException();
  return (gameResponse.Id, gameResponse.NumberCodes, gameResponse.
    MaxMoves, gameResponse.FieldValues);
}</pre>
			<p>The <code>StartGamesAsync</code> method sends an HTTP POST request<a id="_idIndexMarker224"/> after creating the data that should be sent with the HTTP body: <code>CreateGameRequest</code>. After receiving a success response, the <code>ReadFromJsonAsync</code> extension method deserializes the returned HTTP body and returns the methods result using a tuple.</p>
			<p>To send a games move, the game is updated using an HTTP PATCH request:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Client/GamesClient.cs</p>
			<pre class="source-code">
public async Task&lt;(string[] Results, bool Ended, bool IsVictory)&gt; SetMoveAsync(Guid id, string playerName, GameType gameType, int moveNumber, string[] guessPegs, CancellationToken cancellationToken = default)
{
  UpdateGameRequest updateGameRequest = new(id, gameType, playerName, 
    moveNumber)
  {
    GuessPegs = guessPegs
  };
<strong class="bold">  var response = await _httpClient.PatchAsJsonAsync($"/games/{id}", </strong>
    <strong class="bold">updateGameRequest, _jsonOptions, cancellationToken);</strong>
  response.EnsureSuccessStatusCode();
<strong class="bold">  var moveResponse = await response.Content.ReadFromJsonAsync&lt;UpdateGameResponse&gt;(_jsonOptions, cancellationToken)</strong>
    ?? throw new InvalidOperationException();
  (_, _, _, bool ended, bool isVictory, string[] results) = 
    moveResponse;
  return (results, ended, isVictory);
}</pre>
			<p>Sending an HTTP PATCH request is very similar to sending a POST request: the <code>UpdateGameRequest</code> object is created to send this JSON-serialized  information to the server. Receiving the result, the body<a id="_idIndexMarker225"/> is deserialized to an <code>UpdateGameResponse</code> object.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">With REST APIs, a HTTP PUT request is usually used to update a resource, while HTTP PATCH is used for a partial update. Here, the game resource is updated, but not by sending the complete game and just some partial data.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Creating a NuGet Package</h2>
			<p>To create a NuGet package<a id="_idIndexMarker226"/> from the library, you can use the <code>dotnet</code> CLI:</p>
			<pre class="console">
cd Codebreaker.GameAPIs.Client
dotnet pack --configuration Release</pre>
			<p>To see the content of the NuGet package, you can rename it to <code>zip</code>. For easy use of this package, you can add it to a shared folder and configure the Visual Studio NuGet Package manager to reference this folder. You can also publish the package to Azure DevOps Artifacts. Referencing this, you can create a <code>nuget.config</code> file:</p>
			<pre class="console">
dotnet new nugetconfig</pre>
			<p>With the generated <code>nuget.config</code> file, you need to specify the shared folder or the link to your Azure DevOps Artifacts feed.</p>
			<p>This is a <code>nuget.config</code> file created using <code>dotnet new</code> with one additional entry for a custom feed:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;packageSources&gt;
    &lt;clear /&gt;
    &lt;add key="nuget" value="https://api.nuget.org/v3/index.json" /&gt;
<strong class="bold">    </strong><strong class="bold">&lt;add key="custom" value="https://pkgs.dev.azure.com/</strong>
      <strong class="bold">MyOrganization/_packaging/MyFeed/nuget/v3/index.json" /&gt;</strong>
  &lt;/packageSources&gt;
&lt;/configuration&gt;</pre>
			<p>With this NuGet configuration file, the entry <code>&lt;clear /&gt;</code> removes all the default feeds. The <code>nuget</code> key with the first <code>add</code> element references the default feed of the NuGet server. Similarly, you can add custom feeds with other keys and links to the package feeds on the server.</p>
			<p>For the Codebreaker solution, you can look for the NuGet package <code>Cninnovation.Codebreaker.Client</code>, which is available on the NuGet server. After making NuGet packages available on NuGet, a readme file, a license, and some more metadata should be added<a id="_idIndexMarker227"/> to the package. See further readings for more information.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Creating a client application</h1>
			<p>Having the library in place, let’s create<a id="_idIndexMarker228"/> a client application. A simple console application fulfils the purpose to play the game. With the sample application of this chapter, the NuGet packages <code>Microsoft.Extensions.Hosting</code>, <code>Microsoft.Extensions.Http.Resiliency</code>, and <code>Spectre.Console.Cli</code> are added. Navigate to the folder of the solution file before invoking these commands:</p>
			<pre class="console">
dotnet new console –framework net8.0 -o Codebreaker.Console
cd Codebreaker.Console
dotnet add package Microsoft.Extensions.Hosting
dotnet add package Microsoft.Extensions.Http.Resilience
dotnet add package Spectre.Console.Cli
dotnet add reference ../Codebreaker.GameAPIs.Client</pre>
			<p><code>Microsoft.Extensions.Hosting</code> will be used for a dependency injection container and configuration support and <code>Microsoft.Extensions.Http.Resilience</code> is the package offering an <code>HttpClientFactory</code>. Of course, the library created previously needs to be referenced as well.</p>
			<p>To interact with the user, you can<a id="_idIndexMarker229"/> use simple <code>Console.ReadLine</code> and <code>Console.WriteLine</code> statements. With the sample application available in the books GitHub repo, the NuGet package <code>Spectre.Console.Cli</code> is used. Just check the source code for more information.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Configuring the dependency injection container</h2>
			<p>The top-level statements<a id="_idIndexMarker230"/> of the application<a id="_idIndexMarker231"/> are shown with the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Console/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var builder = Host.CreateApplicationBuilder(args);</strong>
<strong class="bold">builder.Services.AddHttpClient&lt;GamesClient&gt;(client =&gt;</strong>
{
  <strong class="bold">string gamesUrl = builder.Configuration["GamesApiUrl"]</strong> ??<strong class="bold"> </strong>throw new 
    InvalidOperationException("GamesApiUrl not found");
  <strong class="bold">client.BaseAddress = new Uri(gamesUrl);</strong>
});
builder.Services.AddTransient&lt;Runner&gt;();
var app = builder.Build();
var runner = app.Services.GetRequiredService&lt;Runner&gt;();
await runner.RunAsync();</pre>
			<p>The <code>CreateApplicationBuilder</code> of the <code>Host</code> class configures<a id="_idIndexMarker232"/> the dependency injection<a id="_idIndexMarker233"/> container and has default configuration for the application configuration providers and the logging providers. The <code>AddHttpClient</code> extension method is implemented with the HttpClient factory. Here, the generic method overload is used to specify the <code>GamesClient</code> class that will receive the <code>HttpClient</code> injected as specified with the <code>configureClient</code> lambda expression. The <code>BaseAddress</code> of the <code>HttpClient</code> is configured to have the <code>GamesApiUrl</code> configuration value.</p>
			<p>For the configuration, we create the <code>appsettings.json</code> configuration file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Console/appsettings.json</p>
			<pre class="source-code">
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "GamesApiUrl": "http://localhost:9400"
}</pre>
			<p>The <code>GamesApiUrl</code> key is configured to contain<a id="_idIndexMarker234"/> the address of the Games API<a id="_idIndexMarker235"/> service. To not mess up logging with the console output for the game play, the log level is configured to only log warning, error, and critical error messages.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Interacting with the user</h2>
			<p>The interaction<a id="_idIndexMarker236"/> with the user<a id="_idIndexMarker237"/> and the invocation of the service happens via the <code>Runner</code> class. Here, the previously created <code>GamesClient</code> is injected into the primary constructor:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Console/Runner.cs</p>
			<pre class="source-code">
internal class Runner(GamesClient client)
{
  private readonly CancellationTokenSource _cancellationTokenSource = new();
  public async Task RunAsync()
  {
    bool ended = false;
    while (!ended)
    {
<strong class="bold">      var selection = Inputs.GetMainSelection();</strong>
      switch (selection)
      {
        case MainOptions.Play:
<strong class="bold">          await PlayGameAsync();</strong>
          break;
        case MainOptions.Exit:
          ended = true;
          break;
        case MainOptions.QueryGame:
<strong class="bold">          await ShowGameAsync();</strong>
          break;
        case MainOptions.QueryList:
<strong class="bold">          </strong><strong class="bold">await ShowGamesAsync();</strong>
          break;
        case MainOptions.Delete:
<strong class="bold">          await DeleteGameAsync();</strong>
          break;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }
  }
  // code removed for brevity
}</pre>
			<p>The <code>RunAsync</code> method first asks the user<a id="_idIndexMarker238"/> what to do next. The main options are to play<a id="_idIndexMarker239"/> a game, to show the status of a single game, to show a list of games, or to delete a game. This code snippet makes use of the <code>Inputs</code> class, which in turn uses the <code>AnsiConsole</code> class from the mentioned NuGet package <code>Spectre.Console.Cli</code>. With this, you get a nice console user interface, as shown in <em class="italic">Figure 4</em><em class="italic">.1</em>, with easy selections. Depending on what you used for interacting with the user, your user interface might look different.</p>
			<ol>
				<li>To run a game, first start the server before starting the client. With the client, select <strong class="bold">Play</strong> (<em class="italic">Figure 4</em><em class="italic">.1</em>).</li>
			</ol>
			<div><div><img src="img/B21217_04_01.jpg" alt="Figure 4.1 – Console output to select a main task"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Console output to select a main task</p>
			<ol>
				<li value="2">Next, select a game<a id="_idIndexMarker240"/> type (<em class="italic">Figure 4</em><em class="italic">.2</em>), for <a id="_idIndexMarker241"/>example, <strong class="bold">Game6x4</strong>.</li>
			</ol>
			<div><div><img src="img/B21217_04_02.jpg" alt="Figure 4.2 – Selecting the game type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Selecting the game type</p>
			<ol>
				<li value="3">Enter a player name (<em class="italic">Figure 4</em><em class="italic">.3</em>) and enter all the colors needed for a single move.</li>
			</ol>
			<div><div><img src="img/B21217_04_03.jpg" alt="Figure 4.3 – Entering the name and selecting the colors depending on the game type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Entering the name and selecting the colors depending on the game type</p>
			<ol>
				<li value="4"><em class="italic">Figure 4</em><em class="italic">.4</em> shows the result<a id="_idIndexMarker242"/> of the move (here with three colors correct<a id="_idIndexMarker243"/> but in the wrong positions) and the start of the next move. Repeat this until you solve the codes.</li>
			</ol>
			<div><div><img src="img/B21217_04_04.jpg" alt="Figure 4.4 – Moving the result and the next move"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Moving the result and the next move</p>
			<p>The result of a successful move is shown in <em class="italic">Figure 4</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B21217_04_05.jpg" alt="Figure 4.5 – Game results"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Game results</p>
			<p>From there, you can repeat<a id="_idIndexMarker244"/> this to play another game or query for the list<a id="_idIndexMarker245"/> of games. From the list of games, you can get a game identifier and query for a single game passing the identifier.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Using Microsoft Kiota to create a client</h1>
			<p>Running the API service<a id="_idIndexMarker246"/> generating the<a id="_idIndexMarker247"/> OpenAPI document (this was done in <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>), we can leverage this information, and create the client code automatically. With the sample code of this chapter, the OpenAPI document is stored with the file <code>gamesapi-swagger.json</code>, which you can reference without starting the service.</p>
			<p>One option with Visual Studio is to use <strong class="bold">Add</strong> | <strong class="bold">Connected Client</strong> and add a service reference to an OpenAPI document. But this option (at the time of this writing) has some limitations:</p>
			<ul>
				<li>It still uses the Newtonsoft Json serializer, whereas the new <code>System.Text.Json</code> one is faster and uses less memory</li>
				<li>The client implementation makes use of strings instead of streams, which can result in objects in the large object heap</li>
			</ul>
			<p>As you’ve seen in this chapter, creating a custom library to create HTTP requests is not that hard and can be optimized for your own domain.</p>
			<p>But now there’s another option<a id="_idIndexMarker248"/> that should be considered: Microsoft Kiota<em class="italic"> </em>(https://learn.microsoft.com/openapi/kiota/). Microsoft Kiota is a command-line tool that offers code generation from the OpenAPI for several languages including Java, PHP, Python, Typescript, C#, and many others. Let’s give this a chance.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Installing Kiota</h2>
			<p>Kiota is available<a id="_idIndexMarker249"/> as a <code>dotnet</code> tool. We install this tool as part of the new library for another class library project.</p>
			<p>The library is created with the following commands. Run these commands from the <code>solution</code> folder:</p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.GameApis.KiotaClient
cd Codebreaker.GameApis.KiotaClient
dotnet add package Microsoft.Kiota.Http.HttpClientLibrary
dotnet add package Microsoft.Kiota.Serialization.Json
dotnet add package Microsoft.Kiota.Serialization.Form
dotnet add package Microsoft.Kiota.Serialization.Multipart
dotnet add package Microsoft.Kiota.Serialization.Text</pre>
			<p>Using Kiota, we also need to add some Kiota NuGet packages for different serializers and a Kiota HTTP client library. The Kiota<a id="_idIndexMarker250"/> tool is installed with the project:</p>
			<pre class="console">
dotnet new tool-manifest
dotnet tool install microsoft.openapi.kiota</pre>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Generating Code with Kiota</h2>
			<p>After the Kiota tool is installed, we can<a id="_idIndexMarker251"/> generate the code using<a id="_idIndexMarker252"/> the OpenAPI document <code>gamesapi-swagger.json</code>. This file is available in the <code>ch04</code> folder:</p>
			<pre class="console">
dotnet kiota generate --openapi ..\..\gamesapi-swagger.json --output codebreaker --language CSharp --class-name GamesAPIClient --namespace-name Codebreaker.Client</pre>
			<p>Using these options, source code is generated using the referenced OpenAPI document <code>gamesapi-swagger.json</code>, the generated files are stored in the subdirectory <code>codebreaker</code>, C# is used for the code generation, the main class to do the HTTP requests is named <code>GamesAPIClient</code>, and the namespace for all the generated code is <code>Codebreaker.Client</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Looking at the generated code, you’ll see that Kiota-generated code is not using the same coding convention as used in this book or as the .NET team is using. For example, the opening of curly braces is done in the same line as the method name, which is a convention used with many JavaScript programs. If you use Visual Studio, you can easily change this with the complete program using the context menu in Solution Explorer, navigating to <strong class="bold">Analyze and Code Cleanup</strong> | <strong class="bold">Run Code Cleanup</strong>. You might need to configure your preferences with code cleanup first.</p>
			<p>The types created using Kiota<a id="_idIndexMarker253"/> are the models (using the <code>schemas</code> within OpenAPI) and request<a id="_idIndexMarker254"/> builders (using the <code>paths</code> where the requests are defined). Check the book repository for the generated code files.</p>
			<h3>Exploring the Kiota-generated models</h3>
			<p>For all the requests<a id="_idIndexMarker255"/> and responses and all the types specified within the schemas, Kiota generates classes in the <code>Models</code> directory. Let’s have a look at the <code>CreateGameRequest</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GamesAPIs.KiotaClient/codebreaker/Models/CreateGameRequest.cs</p>
			<pre class="source-code">
public class CreateGameRequest : <strong class="bold">IParsable</strong>
{
  public Codebreaker.Client.Models.GameType? GameType { get; set; }
  public string? PlayerName { get; set; }
  public static CreateGameRequest 
    CreateFromDiscriminatorValue(IParseNode parseNode)
  {
    _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
    return new CreateGameRequest();
  }
  public virtual IDictionary&lt;string, Action&lt;IParseNode&gt;&gt; 
    <strong class="bold">GetFieldDeserializers</strong>()
  {
    return new Dictionary&lt;string, Action&lt;IParseNode&gt;&gt; {
      {"gameType", n =&gt; { GameType = n.GetEnumValue&lt;GameType&gt;(); } },
      {"playerName", n =&gt; { PlayerName = n.GetStringValue(); } },
    };
  }
  public virtual void <strong class="bold">Serialize</strong>(ISerializationWriter writer)
  {
    _ = writer ?? throw new ArgumentNullException(nameof(writer));
    writer.WriteEnumValue&lt;GameType&gt;("gameType", GameType);
    writer.WriteStringValue("playerName", PlayerName);
  }
}</pre>
			<p>The model types implement<a id="_idIndexMarker256"/> the <code>IParsable</code> interface. This is not the <code>System.IParsable</code> interface, but a version from the Kiota library in the namespace <code>Microsoft.Kiota.Abstractions.Serialization</code>. This interface defines instance members <code>GetFieldDeserializers</code> and <code>Serialize</code>. With this, Kiota offers an abstraction layer, which allows for the use of different serializers.</p>
			<p>Another important aspect that needs mentioning is that all the properties of the model types are declared to be nullable. While EF Core supports nullability to map non-nullable members to be required in the database, this annotation is not used when generating the OpenAPI document using the minimal APIs. Adding the <code>Required</code> attribute to the models on the server adds <code>required</code>. Other annotations such as <code>MaxLength</code> and <code>MinLength</code> are mapped as well with <code>maxLength</code> and <code>minLength</code>, as you can see with <code>gamesapi-swagger.json</code>.</p>
			<p>However, many APIs don’t pay attention to nullability. With the OpenAPI definition too, it’s also not exlpicitly specified how strict nullability should be enforced. Depending on the context where the model is used, information can still be left out from the server, and the data is not sent.</p>
			<p>Here is a discussion about the Kiota implementation: https://github.com/microsoft/kiota/issues/2594</p>
			<p>With the next major version<a id="_idIndexMarker257"/> of the OpenAPI specification, this might change. With the decisions made for the current Kiota implementation, Kiota is on the safe side to declare all the model properties as nullable, but this also means that we need to check for <code>null</code>.</p>
			<h3>Exploring the Kiota-generated request builders</h3>
			<p>The goal of request builders<a id="_idIndexMarker258"/> is to easily create requests. Let’s look at some of the generated code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GamesAPIs.KiotaClient/codebreaker/GamesAPIClient.cs</p>
			<pre class="source-code">
public class GamesAPIClient : <strong class="bold">BaseRequestBuilder</strong>
{
  public GamesRequestBuilder Games
  {
    get =&gt; new GamesRequestBuilder(PathParameters, RequestAdapter);
  }
  public GamesAPIClient(IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}", new Dictionary&lt;string, object&gt;())
  {
     ApiClientBuilder.
       RegisterDefaultSerializer&lt;JsonSerializationWriterFactory&gt;();
     ApiClientBuilder.
       RegisterDefaultSerializer&lt;TextSerializationWriterFactory&gt;();
     ApiClientBuilder.
       RegisterDefaultDeserializer&lt;JsonParseNodeFactory&gt;();
  // code removed for brevity
  }
}</pre>
			<p>All the request builders derive<a id="_idIndexMarker259"/> from the base class, <code>BaseRequestBuilder</code>. The <code>GamesApiClient</code> class, where the name was specified with the code generation, is the request builder that needs to be initiated to communicate with the Games API. In the constructor, you can see default serializers and deserializers<a id="_idIndexMarker260"/> configured. Here, Kiota gives another flexibility.</p>
			<p>The <code>Games</code> property of <code>GamesApiClient</code> returns another request builder: <code>GamesRequestBuilder</code>. This builder is in the <code>GamesRequestBuilder.cs</code> source file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GamesAPIs.KiotaClient/codebreaker/Games/GamesRequestBuilder.cs</p>
			<pre class="source-code">
public class <strong class="bold">GamesRequestBuilder</strong> : BaseRequestBuilder
{
  <strong class="bold">public GamesItemRequestBuilder this[Guid position]</strong>
  {
    get
    {
      // code removed for brevity
      return new GamesItemRequestBuilder(urlTplParams, 
        RequestAdapter);
    }
  }
<strong class="bold">  public async Task&lt;List&lt;Game&gt;?&gt; GetAsync(Action&lt;RequestConfiguration</strong>
    <strong class="bold">&lt;GamesRequestBuilderGetQueryParameters&gt;&gt;? requestConfiguration = </strong>
    <strong class="bold">default, CancellationToken cancellationToken = default)</strong>
  {
    var requestInfo = ToGetRequestInformation(requestConfiguration);
    var collectionResult = await RequestAdapter.
      SendCollectionAsync&lt;Game&gt;(requestInfo, Game.
      CreateFromDiscriminatorValue, default, cancellationToken).
      ConfigureAwait(false);
    return collectionResult?.ToList();
  }
<strong class="bold">  public async Task&lt;CreateGameResponse?&gt; PostAsync(CreateGameRequest </strong>
    <strong class="bold">body, Action&lt;RequestConfiguration&lt;DefaultQueryParameters&gt;&gt;? </strong>
    <strong class="bold">requestConfiguration = default, CancellationToken </strong>
    <strong class="bold">cancellationToken = default)</strong>
  {
    // code removed for brevity
  }</pre>
			<p>This request builder is then used to invoke requests of the games API. Methods implemented by this request builder are <code>GetAsync</code> and <code>PostAsync</code>. The <code>GetAsync</code> method is used to retrieve a list of games with query parameters. <code>PostAsync</code> sends a POST request with the generated <code>CreateGameRequest</code> model.</p>
			<p>To get a single game, update a game by sending a game move, and delete a game, the games API needs a game identifier. With Kiota, this is solved by offering an indexer with <code>GamesRequestBuilder</code>, which in turn returns another request builder, <code>GameItemsRequestBuilder</code>. Here, a fluent API<a id="_idIndexMarker261"/> can be used to pass a game identifier and invoke the <code>GetAsync</code> and <code>PutAsync</code> methods.</p>
			<p>Let’s implement another console application to use this generated code in the next section.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Using the Kiota-generated code</h2>
			<p>The Kiota-generated code<a id="_idIndexMarker262"/> is used with the console application <code>Codebreaker.KiotaConsole</code>. With big parts, the code of this application is similar to the console application from before. Mainly the invocations to the service, which are done with the <code>Runner</code> class, are now replaced and the dependency injection container configuration is changed.</p>
			<p>The HttpClient factory is no longer registered with the DI container, as shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Program.cs</p>
			<pre class="source-code">
var builder = Host.CreateApplicationBuilder(args);
<strong class="bold">builder.Services.Configure&lt;RunnerOptions&gt;(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">  </strong><strong class="bold">options.GamesApiUrl = builder.Configuration["GamesApiUrl"] ??</strong>
<strong class="bold">    throw new InvalidOperationException("GamesApiUrl not found");</strong>
<strong class="bold">});</strong>
builder.Services.AddTransient&lt;Runner&gt;();
var app = builder.Build();
var runner = app.Services.GetRequiredService&lt;Runner&gt;();
await runner.RunAsync();</pre>
			<p>Other than removing the code<a id="_idIndexMarker263"/> for the <code>HttpClient</code> configuration, the base address is now configured to supply values for the <code>RunnerOptions</code> class. This class just defines the <code>GamesApiUrl</code> property to specify the base address for the games service.</p>
			<p>The constructor of the <code>Runner</code> class where the options are passed is shown in the next code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
internal class Runner
{
  private readonly GamesAPIClient _client;
  private readonly CancellationTokenSource _cancellationTokenSource = new();
  public Runner(IOptions&lt;RunnerOptions&gt; options)
  {
<strong class="bold">    AnonymousAuthenticationProvider authenticationProvider = new();</strong>
<strong class="bold">    HttpClientRequestAdapter adapter = new(authenticationProvider)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      BaseUrl = options.Value.GamesApiUrl ?? throw new </strong>
        <strong class="bold">InvalidOperationException("Could not read GamesApiUrl")</strong>
<strong class="bold">    };</strong>
<strong class="bold">    _client = new GamesAPIClient(adapter);</strong>
  }</pre>
			<p>With the implementation<a id="_idIndexMarker264"/> of the <code>Runner</code> constructor, the <code>GamesAPIClient</code> class is instantiated. This class receives <code>HttpClientRequestAdapter</code>, which has the base address of the service configured. The constructor of <code>HttpClientRequestAdapter</code> receives an object implementing the <code>IAuthenticationProvider</code> interface. Here, <code>AnonymousAuthenticationProvider</code> is used as no authentication is needed. Kiota offers various authentication providers.</p>
			<p>Sending a GET request with query parameters to get a list of games, you invoke the <code>GetAsync</code> method of <code>GamesRequestBuilder</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
private async Task ShowGamesAsync()
{
<strong class="bold">  var games = await _client.Games.GetAsync(config =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    config.QueryParameters.Date = new Date(DateTime.Today);</strong>
<strong class="bold">  }, _cancellationTokenSource.Token);</strong>
  // code removed for brevity</pre>
			<p>The <code>Games</code> property returns the generated <code>GamesRequestBuilder</code>, which allows us to invoke the <code>GetAsync</code> method passing query parameters. Kiota offers its own <code>Date</code> type within the <code>Microsoft.Kiota.Abstractions</code> namespace, which represents the date-only<a id="_idIndexMarker265"/> part of <code>DateTime</code>. Today, .NET offers <code>DateOnly</code>, but this type is not available with .NET Standard 2.0, which is also supported by Kiota.</p>
			<p>Starting a game is done by sending a POST request, as shown in the next snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
private async Task PlayGameAsync()
{
  // code removed for brevity
<strong class="bold">  CreateGameRequest request = new()</strong>
<strong class="bold">  {</strong>
<strong class="bold">    PlayerName = playerName,</strong>
<strong class="bold">    GameType = gameType</strong>
<strong class="bold">  };</strong>
<strong class="bold">  </strong><strong class="bold">var response = await _client.Games.PostAsync(request, </strong>
    <strong class="bold">cancellationToken: _cancellationTokenSource.Token);</strong></pre>
			<p>Starting the game, the user input for the player name and the game type are assigned to the <code>CreateGameRequest</code> object. This model type is then passed with the invocation of the <code>PostAsync</code> method to start a game and to receive <code>CreateGameResponse</code>.</p>
			<p>Retrieving a single game passing the game identifier is shown in the next code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.KiotaConsole/Runner.cs</p>
			<pre class="source-code">
private async Task ShowGameAsync()
{
  // code removed for brevity
<strong class="bold">  var game = await _client.Games[id.ToString()].GetAsync(</strong>
<strong class="bold">    cancellationToken: _cancellationTokenSource.Token);</strong>
  // code removed for brevity</pre>
			<p>Retrieving a single game, updating the game with a HTTP PATCH request, and deleting a game with the HTTP DELETE request all need the game identifier as the query parameter. To use this, Kiota offers an indexer passing <code>game-id</code> and continuing with a fluent API. To retrieve a single game, the <code>GetAsync</code> method is used. Patching and deleting games are very similar.</p>
			<p>With this information, you can use the Kiota-generated code and write the implementation to update the game<a id="_idIndexMarker266"/> by sending a game move with the <code>PostAsync</code> method.</p>
			<p>Using the new client, you can run the game in the same way as shown before!</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Summary</h1>
			<p>Working through this chapter, you’ll have a running client console application to run the game. We used the <code>HttpClient</code> class to send requests to the games service. To reuse this with different client technologies, we created a library. For efficient use of the <code>HttpClient</code> class, you learned to use the HttpClient factory.</p>
			<p>Instead of implementing the models on your own, you learned using Microsoft Kiota to create code from the OpenAPI definition. With your own scenarios, you can now decide what’s the best option for you.</p>
			<p>Before reading the next chapter, you can reuse this newly created library and create clients of your choice such as Blazor, WinUI, or .NET MAUI. While these frameworks are outside of the scope of this book, you can check <a href="https://github.com/codebreakerapp">https://github.com/codebreakerapp</a> for more clients available.</p>
			<p>No matter what client you implement, before diving into the next chapter, it’s well deserved to play one more game—this time with your own created client application.</p>
			<p>In the next chapter, the focus will be on the services again; we’ll host the service application (and another service) with a Docker container. This new service will also use the HTTP client created in this chapter.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li><code>HttpClient</code> guidelines: https://learn.microsoft.com/dotnet/fundamentals/networking/http/httpclient-guidelines</li>
				<li>NuGet packages best practices: https://learn.microsoft.com/nuget/create-packages/package-authoring-best-practices</li>
				<li>The large object heap on Windows systems: https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap</li>
				<li>Microsoft Kiota documentation: <a href="https://learn.microsoft.com/openapi/kiota/">https://learn.microsoft.com/openapi/kiota/</a></li>
				<li>Kiota GitHub repository: <a href="https://github.com/microsoft/kiota">https://github.com/microsoft/kiota</a></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-110" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor109"/>Part 2: Hosting and Deploying</h1>
			<p>This part focuses on essential aspects of hosting and deploying microservices. You will begin by gaining a comprehensive understanding of Docker fundamentals, such as creating Dockerfiles, building Docker images using the .NET CLI, and running Docker containers with .NET Aspire on your development environment. You will then proceed to publish Docker images to the Azure Container Registry, deploy them to the Azure Container Apps environment (based on Kubernetes), and incorporate Azure services like Azure App Configuration and Azure Key Vault.</p>
			<p>Throughout this part, you will utilize Azure resources for local application execution, deploy applications to Azure using the Azure Developer CLI, and establish GitHub Actions for automated deployment to Azure upon code updates in the repository. To ensure seamless operation in both on-premises and Azure environments, authentication will be implemented with Azure Active Directory B2C and Microsoft Entra, alongside ASP.NET Core Identities.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">Containerization of Microservices</em></li>
				<li><a href="B21217_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>, <em class="italic">Microsoft Azure for Hosting Applications</em></li>
				<li><a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a><em class="italic">, Flexible Configuration</em></li>
				<li><a href="B21217_08.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a><em class="italic">, CI/CD – Publishing with GitHub Actions</em></li>
				<li><a href="B21217_09.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a><em class="italic">, Authentication and Authorization with Services and Clients</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>