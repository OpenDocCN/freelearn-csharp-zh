- en: Deploying Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务部署
- en: Both monolith and microservice architectural styles come with different deployment challenges.
    In the case of .NET monolithic applications, more often, deployments are a flavor
    of Xcopy deployments. Microservice deployments present a different set of challenges.
    Continuous integration and continuous deployment are the key practices when delivering
    microservice applications. Also, container technologies and toolchain technology,
    which promise greater isolation boundaries, are essential for microservice deployment
    and scaling.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单体和微服务架构风格都伴随着不同的部署挑战。在.NET单体应用的情况下，部署通常是一种Xcopy部署的变体。微服务部署则带来了一组不同的挑战。持续集成和持续部署是交付微服务应用时的关键实践。此外，承诺提供更大隔离边界的容器技术和工具链技术对于微服务部署和扩展至关重要。
- en: In this chapter, we will discuss the fundamentals of microservice deployment
    and the influence of emerging practices, such as CI/CD tools and containers, on
    microservice deployment. We will also walk through the deployment of a simple
    .NET Core service in a Docker container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论微服务部署的基本原理以及CI/CD工具和容器等新兴实践对微服务部署的影响。我们还将演示如何在Docker容器中部署一个简单的.NET
    Core服务。
- en: 'By the end of the chapter, you will have an understanding of the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解以下主题：
- en: Deployment terminology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署术语
- en: What are the factors for successful microservice deployments?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功微服务部署的因素有哪些？
- en: What is continuous integration and continuous deployment?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是持续集成和持续部署？
- en: Isolation requirements for microservice deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务部署的隔离要求
- en: Containerization technology and its need for microservice deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化技术及其在微服务部署中的需求
- en: Quick introduction to Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker快速入门
- en: How to package an application as a Docker container using Visual Studio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Visual Studio将应用程序打包为Docker容器
- en: Before proceeding further, we should first learn why we are talking about the
    deployment of microservices. The deployment cycle is one that has a specific flow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论之前，我们首先应该了解为什么我们要讨论微服务的部署。部署周期是一个具有特定流程的过程。
- en: Monolithic application deployment challenges
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体应用部署的挑战
- en: 'Monolithic applications are applications where all of the database and business
    logic is tied together and packaged as a single system. Since, in general, monolithic
    applications are deployed as a single package, deployments are somewhat simple
    but painful due to the following reasons:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用是所有数据库和业务逻辑都绑定在一起并打包为一个单一系统的应用。由于通常单体应用以单个包的形式部署，因此部署相对简单，但以下原因使得部署变得痛苦：
- en: Deployment and release as a single concept: There is no differentiation between
    deploying build artifacts and actually making features available to the end user.
    More often, releases are coupled to their environment. This increases the risk
    of deploying new features.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和发布作为一个单一概念：部署构建工件和实际上向最终用户提供功能之间没有区别。更常见的是，发布与其环境相关联。这增加了部署新功能的风险。
- en: All or nothing deployment:All or nothing deployment increases the risk of application
    downtime and failure. In the case of rollbacks, teams fail to deliver expected
    new features and hotfixes or service packs have to be released to deliver the
    right kind of functionality.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全有或全无部署：全有或全无部署增加了应用停机时间和失败的风险。在回滚的情况下，团队未能交付预期的新的功能或热修复，或者必须发布服务包以提供正确类型的功能。
- en: A **Hotfix**, also known as a **Quickfix**, is a single or cumulative package
    (generally called a **patch**). It contains fixes for issues/bugs found in production
    that must be fixed before the next major release.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**热修复**，也称为**快速修复**，是一个单一或累积的包（通常称为**补丁**）。它包含对生产中发现的问题/错误进行的修复，这些错误必须在下一个主要版本发布之前得到解决。'
- en: Central databases as a single point of failure:In monolithic applications, a big,
    centralized database is a single point of failure. This database is often quite
    large and difficult to break down. This results in an increase in **mean time
    to recover** (**MTTR**) and **mean time between failures** (**MTBF**).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央数据库作为单一故障点：在单体应用中，一个庞大且集中的数据库是单一故障点。这个数据库通常相当大且难以分解。这导致**平均恢复时间**（**MTTR**）和**平均故障间隔时间**（**MTBF**）的增加。
- en: Deployment and releases are big events:Due to small changes in the application,
    the entire application could get deployed. This comes with a huge time and energy
    investment for developers and ops teams. Needless to say, a collaboration between
    the various teams involved is the key to a successful release. This becomes even
    harder when many teams spread globally are working on the development and release.
    These kinds of deployments/releases need a lot of hand-holding and manual steps.
    This impacts end customers who have to face application downtime. If you are familiar
    with these kinds of deployments, then you'll also be familiar with marathon sessions
    in the so-called war rooms and endless sessions of defect triage on conference
    bridges.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和发布是重大事件：由于应用程序中的微小变化，整个应用程序可能会被部署。这对开发者和运维团队来说需要巨大的时间和精力投入。不用说，涉及到的各个团队之间的协作是成功发布的关键。当许多分布在全球的团队在进行开发和发布工作时，这变得更加困难。这类部署/发布需要大量的指导和手动步骤。这影响了最终用户，他们必须面对应用程序的停机。如果你熟悉这类部署，那么你也会熟悉所谓的“战室”中的马拉松会议和会议桥上的缺陷分类无休止的会议。
- en: Time to market:Carrying out any changes to the system in such cases becomes
    harder. In such environments, executing any business change takes time. This makes
    responding to market forces difficult—the business can also lose its market share.
    With microservice architecture, we are addressing some of these challenges. This
    architecture provides greater flexibility and isolation for service deployment.
    It has proven to deliver much faster turnaround time and much-needed business
    agility.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场投放时间：在这种情况下，对系统进行任何更改都变得更加困难。在这种环境中，执行任何业务变更都需要时间。这使得对市场力量的反应变得困难——企业也可能失去其市场份额。使用微服务架构，我们正在解决这些挑战之一。这种架构为服务部署提供了更大的灵活性和隔离性。它已被证明可以提供更快的周转时间和急需的业务敏捷性。
- en: Understanding the deployment terminology
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解部署术语
- en: 'Microservices deployment terminology simply includes steps that start with
    code changes till release. In this section, we will discuss all these steps of
    deployment terminology as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务部署术语仅包括从代码更改开始直到发布的步骤。在本节中，我们将按以下方式讨论所有这些部署术语的步骤：
- en: '**Build**: In the build stage, the service source gets compiled without any
    errors along with the passing of all corresponding unit tests. This stage produces
    build artifacts.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：在构建阶段，服务源代码在没有错误的情况下编译，并且所有相应的单元测试都通过。这一阶段产生构建工件。'
- en: '**Continuous Integration** (**CI**): CI forces the entire application to build
    again every time a developer commits any change—the application code gets compiled and
    a comprehensive set of automated tests are run against it. This practice emerged
    from the problems of frequent integration of code in large teams. The basic idea
    is to keep the delta, or change to the software, small. This provides confidence that
    the software is in a workable state. Even if a check-in made by a developer breaks
    the system, it is easy to fix it this way.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）：每次开发者提交任何更改时，CI都会强制整个应用程序重新构建——应用程序代码被编译，并对其运行一系列全面的自动化测试。这种做法源于大型团队中频繁集成代码的问题。基本思想是保持软件更改的增量或更改尽可能小。这提供了软件处于可工作状态的信心。即使开发者的提交破坏了系统，也可以通过这种方式轻松修复。'
- en: '**Deployment**: Hardware provisioning and installing the base OS and correct
    version of the .NET framework are prerequisites for deployment. The next part
    of it is to promote these build artifacts in production through various stages.
    The combination of these two parts is referred to as the deployment stage. There
    is no distinction between the deployment and release stage in most monolithic
    applications.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：硬件配置和安装基础操作系统以及正确的.NET框架版本是部署的先决条件。接下来是将其构建工件在生产环境中通过各个阶段进行推广。这两部分的组合被称为部署阶段。在大多数单体应用程序中，部署阶段和发布阶段之间没有区别。'
- en: '**Continuous Deployment** (**CD**): In CD, each successful build gets deployed
    to production. CD is more important from a technical team''s perspective. Under
    CD, there are several other practices, such as automated unit testing, labeling,
    versioning of build numbers, and traceability of changes. With continuous delivery,
    the technical team ensures that the changes pushed to production through various
    lower environments work as expected in production. Usually, these are small and
    deployed very quickly.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续部署**（**CD**）：在持续部署中，每个成功的构建都会被部署到生产环境中。从技术团队的角度来看，CD更为重要。在持续部署的框架下，还有其他一些实践，例如自动单元测试、标记、构建号的版本控制和变更的可追溯性。通过持续交付，技术团队确保通过各个低级环境推送到生产环境中的变更能够按预期工作。通常，这些变更很小，部署速度很快。'
- en: '**Continuous delivery:** Continuousdelivery is different from CD. CD comes
    from a technical team''s perspective, whereas continuous delivery is more focused
    on providing the deployed code as early as possible to the customer. To make sure
    that customers get the right defect-free product, in continuous delivery, every
    build must pass through all the quality assurance checks. Once the product passes
    the satisfactory quality verification, it is the business stakeholders'' decision
    when to release it.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付**：持续交付与CD不同。CD来自技术团队的角度，而持续交付更侧重于尽可能早地将部署的代码提供给客户。为了确保客户获得无缺陷的正确产品，在持续交付中，每个构建都必须通过所有的质量保证检查。一旦产品通过满意的质量验证，何时发布就是业务利益相关者的决定。'
- en: '**Build and deployment pipelines**: The build and deployment pipeline is part
    of implementing continuous delivery through automation. It is a workflow of steps
    through which the code is committed in the source repository. At the other end
    of the deployment pipeline, the artifacts for release are produced. Some of the
    steps that may make up the build and deployment pipeline are as follows:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和部署管道**：构建和部署管道是自动化实现持续交付的一部分。它是一系列步骤的流程，代码通过源代码库提交。在部署管道的另一端，生成发布所需的工件。构建和部署管道可能包含的步骤如下：'
- en: Unit tests
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Code coverage and static analysis
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖率与静态分析
- en: Regression tests
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回归测试
- en: Deployments to staging environment
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到预发布环境
- en: Load/stress tests
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压力/负载测试
- en: Deployment to release repository
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到发布仓库
- en: '**Release**: A business feature made available to the end user is referred
    to as the release of a feature. To release a feature or service, the relevant
    build artifacts should be deployed beforehand. Usually, the feature toggle manages
    the release of a feature. If the feature flag (also called feature toggle) is
    not switched on in production, it is called a dark release of the specified feature.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：提供给最终用户的企业功能被称为功能的发布。为了发布功能或服务，应事先部署相关的构建工件。通常，功能开关管理功能的发布。如果功能标志（也称为功能切换）在生产环境中未开启，则称为指定功能的暗色发布。'
- en: Prerequisites for successful microservice deployments
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功部署微服务的先决条件
- en: 'Any architectural style comes with a set of associated patterns and practices
    to follow. The microservice architectural style is no different. Microservice
    implementation has more chances of being successful with the adoption of the following
    practices:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 任何架构风格都伴随着一系列要遵循的关联模式和惯例。微服务架构风格也不例外。采用以下实践，微服务实现成功的可能性更大：
- en: 'Self-sufficient teams: Amazon, who is a pioneer of SOA and microservice architectures,
    follow the *Two Pizza Teams* paradigm. This means usually a microservice team
    will have no more than 7-10 team members. These team members will have all the
    necessary skills and roles; for example, development, operations, and business
    analyst. Such a service team handles the development, operations, and management of
    a microservice.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自给自足的团队：作为SOA和微服务架构的先驱，亚马逊遵循**两披萨团队**模式。这意味着一个微服务团队通常不会超过7-10名成员。这些团队成员将拥有所有必要的技能和角色；例如，开发、运维和业务分析师。这样的服务团队负责微服务的开发、运维和管理。
- en: 'CI and CD: CI and CD are prerequisites for implementing microservices. Smaller
    self-sufficient teams, who can integrate their work frequently, are precursors
    to the success of microservices. This architecture is not as simple as a monolith.
    However, automation and the ability to push code upgrades regularly enables teams
    to handle complexity. Tools, such as **Team Foundation Online Services** (**TFS**),
    TeamCity, and Jenkins, are quite popular toolchains in this space.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成和持续部署：CI和CD是实现微服务的先决条件。能够频繁集成工作的较小、自给自足的团队是微服务成功的前提。这种架构并不像单体架构那样简单。然而，自动化和定期推送代码升级的能力使团队能够处理复杂性。Team
    Foundation Online Services（**TFS**）、TeamCity和Jenkins等工具在这个领域非常受欢迎。
- en: Infrastructure as code: The idea of representing hardware and infrastructure
    components, such as networks with code, is new. It helps you make deployment environments,
    such as integration, testing, and production, look exactly identical. This means developers
    and test engineers will be able to easily reproduce production defects in lower
    environments. With tools such as CFEngine, Chef, Puppet, Ansible, and Powershell
    DSC, you can write your entire infrastructure as code. With this paradigm shift,
    you can also put your infrastructure under a version control system and ship it
    as an artifact in deployment.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码：将硬件和基础设施组件，如网络，用代码表示的想法是新的。这有助于使部署环境，如集成、测试和生产，看起来完全相同。这意味着开发人员和测试工程师将能够在较低的环境中轻松地重现生产缺陷。使用CFEngine、Chef、Puppet、Ansible和PowerShell
    DSC等工具，您可以编写整个基础设施的代码。随着这种范式转变，您还可以将基础设施置于版本控制系统之下，并以部署工件的形式进行分发。
- en: 'Utilization of cloud computing: Cloud computing is a big catalyst for adopting
    microservices. It is not mandatory as such for microservice deployment though. Cloud
    computing comes with near infinite scale, elasticity, and rapid provisioning capability.
    It is a no-brainer that the cloud is a natural ally of microservices. So, knowledge
    and experience with the Azure cloud will help you adopt microservices.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算的应用：云计算是采用微服务的强大催化剂。尽管如此，它对于微服务部署并不是强制性的。云计算具有近乎无限的规模、弹性和快速供应能力。云是微服务的天然盟友。因此，对Azure云的知识和经验将帮助您采用微服务。
- en: Isolation requirements for microservice deployment
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务部署的隔离要求
- en: 'In 2012, Adam Wiggins, co-founder of the Heroku platform, presented 12 basic
    principles. These principles talk about defining new modern web applications from
    an idea to deployment. This set of principles is now known as the *12-factor app*.
    These principles paved the way for new architectural styles, which evolved into
    microservice architectures. One of the principles of the 12-factor app was as
    follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，Heroku平台联合创始人亚当·威金斯提出了12项基本原则。这些原则讨论了从想法到部署定义新的现代Web应用程序。这套原则现在被称为**12因子应用**。这些原则为新架构风格铺平了道路，这些风格演变成了微服务架构。12因子应用的原则之一如下：
- en: '"Execute the app as one or more stateless processes"'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “将应用程序作为一个或多个无状态进程执行”
- en: '- Adam Wiggins ([https://12factor.net/](https://12factor.net/))'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '- 亚当·威金斯 ([https://12factor.net/](https://12factor.net/))'
- en: So, services will be essentially stateless (except the database, which acts
    as the state store). The *shared nothing* principle is also applied across the
    entire spectrum of patterns and practices. This is nothing more than the isolation
    of components in order to achieve scale and agility.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务将基本上是无状态的（除了数据库，它充当状态存储）。*无共享*原则也应用于整个模式和惯例的范围内。这不过是组件隔离以实现规模和敏捷性的手段。
- en: 'In the microservice world, this principle of isolation is applied in the following
    ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，这一隔离原则被应用于以下方式：
- en: 'Service teams: There will be self-sufficient teams built around services. In
    effect, the teams will be able to take all the decisions necessary to develop
    and support the microservices they are responsible for.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务团队：将围绕服务建立自给自足的团队。实际上，这些团队将能够做出所有必要的决策，以开发和支持他们负责的微服务。
- en: Source control isolation: The source repository of every microservice will be
    separate. It will not share any source code, files, and so on. It is okay to duplicate
    a few bits of code in the microservice world across services.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码隔离：每个微服务的源代码库将是独立的。它不会共享任何源代码、文件等。在微服务世界中，跨服务复制少量代码是可以接受的。
- en: 'Build stage isolation: Build and deploy pipelines for every microservice should
    be kept isolated. Build and deploy pipelines can even run in parallel, isolated,
    and deployed services. Due to this, CI-CD tools should be scaled to support different
    services and pipelines at a much faster speed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建阶段隔离：每个微服务的构建和部署管道应该保持隔离。构建和部署管道甚至可以并行运行，独立部署服务。因此，CI-CD工具应该扩展以支持不同服务和管道，速度要快得多。
- en: 'Release stage isolation: Every microservice should be released in isolation
    with other services. It is also possible that the same service with different
    versions is in the production environment.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布阶段隔离：每个微服务都应该与其他服务隔离发布。也可能存在同一服务不同版本在生产环境中的情况。
- en: Deploy stage isolation: This is the most important part of isolation. Traditional
    monolith deployment is done with bare metal servers. With the advancement in virtualization,
    virtual servers have replaced bare metal servers.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署阶段隔离：这是隔离最重要的部分。传统的单体部署使用裸金属服务器。随着虚拟化的进步，虚拟服务器已经取代了裸金属服务器。
- en: 'In general, a monoliths'' standard release process looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单体应用程序的标准发布流程如下：
- en: '![](img/9ce0073e-8ec4-4502-ae59-6e78b1352ddd.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ce0073e-8ec4-4502-ae59-6e78b1352ddd.png)'
- en: 'Considering these isolation levels, the microservice build and deployment pipeline
    may look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些隔离级别，微服务的构建和部署管道可能看起来是这样的：
- en: '![](img/a15dd6e7-0dcb-46cf-ab77-ddff584621ef.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a15dd6e7-0dcb-46cf-ab77-ddff584621ef.png)'
- en: Need for a new deployment paradigm
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要新的部署范式
- en: The highest level of isolation for an application can be achieved by adding
    a new physical machine or bare metal server, so there is a server with its own
    operating system managing all system resources. This was regular stuff in legacy
    applications but it is not practical for modern applications. Modern applications
    are massive systems. Some examples of these systems are Amazon, Netflix, and Nike,
    or even traditional financial banks, such as ING. These systems are hosted on
    tens of thousands of servers. These kinds of modern applications demand ultra-scalability
    to serve their millions of users. For a microservice architecture, it does not
    make any sense to set up a new server just to run a small service on top of it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加新的物理机或裸金属服务器，可以实现应用程序的最高隔离级别，因此有一个拥有自己操作系统的服务器来管理所有系统资源。这在传统应用程序中是常规操作，但对于现代应用程序来说并不实用。现代应用程序是庞大的系统。这些系统的例子包括亚马逊、Netflix和耐克，甚至是传统的金融机构，如ING。这些系统托管在成千上万的服务器上。这类现代应用程序需要超强的可扩展性来服务数百万用户。对于微服务架构，仅仅为了在上面运行一个小服务而设置新的服务器是没有意义的。
- en: With new CPU architectural breakthroughs, one of the options that emerged was
    virtual machines. Virtual machines abstract out all the hardware interactions
    of an operating system through the hypervisor technology. Hypervisors enabled
    us to run many machines or servers on a single physical machine. One significant
    point to note is that all the virtual machines get their piece of an isolated
    system resource from physical host resources.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的CPU架构突破，出现的一个选项是虚拟机。虚拟机通过虚拟化技术抽象出操作系统的所有硬件交互。虚拟化技术使我们能够在单个物理机上运行多个机器或服务器。需要注意的是，所有虚拟机都从物理主机资源中获取其独立系统资源的一部分。
- en: This is still a good isolated environment to run an application. Virtualization
    brought the rationale of raising servers for entire applications. While doing
    so, it kept the components fairly isolated; this helped us utilize spare computer
    resources in our data centers. It improved the efficiency of our data centers
    while satisfying applications' fair isolation needs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个良好的隔离环境来运行应用程序。虚拟化带来了为整个应用程序提升服务器的合理性。在这样做的同时，它保持了组件的相对隔离；这有助于我们利用数据中心中的备用计算机资源。它提高了我们数据中心的效率，同时满足了应用程序的合理隔离需求。
- en: 'However, virtualization on its own is not able to support some of a microservice''s
    needs. Under the 12-factors principles, Adam also talks about this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅虚拟化本身并不能满足微服务的一些需求。根据12要素原则，亚当也谈到了这一点：
- en: '"The twelve-factor app’s processes are disposable, meaning they can be started
    or stopped at a moment’s notice. This facilitates fast elastic scaling, rapid
    deployment of code or config changes, and robustness of production deploys."'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “十二要素应用程序的过程是可丢弃的，这意味着它们可以随时启动或停止。这促进了快速弹性扩展、代码或配置更改的快速部署，以及生产部署的健壮性。”
- en: '- Adam Wiggins ([https://12factor.net/](https://12factor.net/))'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '- 亚当·威金斯 ([https://12factor.net/](https://12factor.net/))'
- en: This principle is important for the microservice architectural style. So, with
    microservices, we must ensure that the services start up faster. In this case,
    let's assume that there is one service per virtual machine. If we want to spin
    this service, it first needs to spin the virtual machine; however, the boot time
    of a virtual machine is long. Another thing is that with such applications, we
    are talking about a lot of cluster deployments. So services will definitely be
    distributed in clusters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则对于微服务架构风格非常重要。因此，在使用微服务时，我们必须确保服务能够更快地启动。在这种情况下，让我们假设每个虚拟机运行一个服务。如果我们想启动这个服务，首先需要启动虚拟机；然而，虚拟机的启动时间很长。还有一点是，对于这类应用程序，我们谈论的是大量的集群部署。因此，服务肯定会在集群中分布。
- en: This also implies that virtual machines might need to be raised up on one of
    the nodes in the clusters and booted. This is again a problem with virtual machines'
    boot-up time. This does not bring the kind of efficiency that we are expecting
    for microservices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着虚拟机可能需要在集群中的某个节点上启动。这又是虚拟机启动时间的问题。这并没有带来我们期望的微服务效率。
- en: Now, the only option left is to use the operating system process model, which
    comes with a quicker boot time. The process programming model has been well-known
    for ages but even processes come at a cost. They are not well isolated and share
    system resources as well as the kernel of the operating system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的选择是使用操作系统进程模型，这具有更快的启动时间。进程编程模型早已为人所知，但即使是进程也有成本。它们没有很好地隔离，并且共享系统资源以及操作系统的内核。
- en: 'For microservices, we need a better isolation deployment model and a new paradigm
    of deployment. The answer is this: innovation of the container technology. A good
    consideration factor is that the container technology sits well between virtualization
    and the operating system''s process model.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务，我们需要更好的隔离部署模型和新的部署范式。答案是：容器技术的创新。一个值得考虑的因素是，容器技术很好地位于虚拟化和操作系统进程模型之间。
- en: Containers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: Container technology is not new to the Linux world. Containers are based on
    Linux's LXC technology. In this section, let's see how containers are important
    in the case of microservices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术在 Linux 世界中并不新鲜。容器基于 Linux 的 LXC 技术。在本节中，让我们看看容器在微服务场景中的重要性。
- en: What are containers?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器是什么？
- en: A container is a piece of software in a complete filesystem. It contains everything
    that is needed to run code, runtime, system tools, and system libraries—anything
    that can be installed on a server. This guarantees that the software will always
    run in the same way, regardless of its environment. Containers share their host
    operating system and kernel with other containers on the same host. The technology
    around containers is not new. It has been a part of the Linux ecosystem for a
    long time. Due to the recent microservice-based discussions surrounding it, container
    technology came into the limelight again. Also, it is the technology on which
    Google, Amazon, and Netflix run.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个包含完整文件系统的软件组件。它包含运行代码、运行时、系统工具和系统库所需的一切——任何可以安装在服务器上的东西。这保证了软件将始终以相同的方式运行，无论其环境如何。容器与同一主机上的其他容器共享宿主操作系统和内核。容器周围的技术并不新鲜。它已经很长时间是
    Linux 生态系统的一部分。由于最近围绕基于微服务的讨论，容器技术再次受到关注。此外，它是谷歌、亚马逊和 Netflix 运行的技术。
- en: Suitability of containers over virtual machines
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器相对于虚拟机的适用性
- en: Let's understand the difference between containers and virtual machines—at the
    surface level, both are tools to achieve isolation and virtualization.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解容器和虚拟机之间的区别——在表面层面上，两者都是实现隔离和虚拟化的工具。
- en: 'The architectural difference between virtual machines and containers is quite
    evident from the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下图表中可以清楚地看出虚拟机和容器之间的架构差异：
- en: '![](img/573dff2c-d1dd-458f-a502-0ca9441871e5.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/573dff2c-d1dd-458f-a502-0ca9441871e5.png)'
- en: By looking at the virtual machine internals, we can see that there is a host
    operating system along with a kernel, and on top of it, the hypervisor layer.
    Hosted applications have to bring in their own operating system and environment.
    In containers though, the containerization technology layer serves as a single
    layer and is shared across different applications. This removes the need for a guest
    operating system. Thus, applications in a container come with a smaller footprint
    and strong isolation levels. Another aspect that will encourage you to use containers
    for microservice deployment is that we can pack more applications on the same
    physical machine when compared to the same applications deployed on a virtual
    machine. This helps us achieve greater economy of scale benefits and provides
    a comparison of the benefits of virtual machines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看虚拟机的内部结构，我们可以看到有一个宿主操作系统以及内核，在其之上是虚拟化层。托管的应用程序必须引入它们自己的操作系统和环境。然而，在容器中，容器化技术层作为一个单独的层，被不同应用程序共享。这消除了对客户操作系统的需求。因此，容器中的应用程序具有更小的占用空间和强大的隔离级别。另一个鼓励你使用容器进行微服务部署的方面是，与在虚拟机上部署相同的应用程序相比，我们可以在同一台物理机器上打包更多的应用程序。这有助于我们实现更大的规模经济优势，并提供了虚拟机优势的比较。
- en: One more thing to note with containers is that they can be run on virtual machines
    as well. So it is okay to have a physical server with a virtual machine on it.
    This virtual machine serves as a host to a number of containers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于容器，还有一点需要注意，那就是它们也可以在虚拟机上运行。因此，拥有一个物理服务器并在其上运行虚拟机是可以的。这个虚拟机作为多个容器的宿主。
- en: Transformation of the operation team's mindset
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运营团队思维模式的转变
- en: Microsoft's Bill Baker came up with an analogy of pets and cattle and he applied
    it to servers in a data center. Okay, honestly, we care for our pets. We love
    them and show affection towards them, we name them as well. We think of their
    hygiene; if they fall sick, we take them to the vet. Do we take such care of our
    cattle? Of course, we don't; this is because we do not care that much about cattle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的比尔·贝克提出了宠物和牛的类比，并将其应用于数据中心的服务器。好吧，说实话，我们关心我们的宠物。我们爱它们，对它们表示关爱，我们还给它们起名字。我们考虑它们的卫生；如果它们生病了，我们会带它们去看兽医。我们会这样关心我们的牛吗？当然不会；这是因为我们对牛并不那么关心。
- en: The same analogy is true with respect to servers and containers. In pre-DevOps
    days, server admins cared about servers. They used to name those server machines
    and also have dedicated maintenance downtime and so on. With DevOps practices,
    such as infrastructure as code and containerization, containers can be treated
    as cattle. As the operations team, we do not need to care for them since containers
    are meant for a short lifespan. They can be booted up quickly in clusters and
    torn down quickly as well. When you are dealing with containers, always keep in
    mind this analogy. As far as daily operations go, expect the spinning up of and
    teardown of containers to be normal practice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比在服务器和容器方面也是适用的。在DevOps之前的日子，服务器管理员关心服务器。他们过去会给那些服务器机器起名字，并且有专门的维护停机时间等等。随着DevOps实践，如基础设施即代码和容器化，容器可以被当作牛来对待。作为运维团队，我们不需要关心它们，因为容器意味着短暂的寿命。它们可以在集群中快速启动，也可以快速拆除。当你处理容器时，始终记住这个类比。在日常工作运营中，预期容器的启动和拆除是正常做法。
- en: This analogy changes the perspective towards microservice deployment and how
    it supports containerization.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比改变了我们对微服务部署及其如何支持容器化的看法。
- en: Containers are new binaries
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器是新的二进制文件
- en: 'This is a new reality you will face as a .NET developer: working with microservices.
    Containers are new binaries. With Visual Studio, we compile the .NET program and
    after compilation, Visual Studio produces .NET assemblies, namely DLLs or EXEs.
    We take this set of associated DLLs and EXEs emitted by the compiler and deploy
    them on the servers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你作为.NET开发者将面临的新现实：与微服务一起工作。容器是新的二进制文件。使用Visual Studio，我们编译.NET程序，编译后，Visual
    Studio生成.NET程序集，即DLL或EXE文件。我们收集编译器生成的这些相关的DLL和EXE文件，并将它们部署到服务器上。
- en: '"Containers are new binaries of deployment"'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '"容器是新的部署二进制文件"'
- en: '- Steve Lasker, Principal Program Manager at Microsoft'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '- 史蒂夫·拉斯克，微软高级项目经理'
- en: So, in short, our deployment unit was in the form of assemblies. Not anymore!
    Well, we still have .the NET program generating EXEs and DLLs, but our deployment
    unit has changed in the microservice world. It is a container now. We will still
    be compiling programs into assemblies. These assemblies will be pushed to the container
    and made ready to be shipped.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们的部署单元以前是以程序集的形式存在的。现在不再是了！好吧，我们仍然有 .NET 程序生成 EXEs 和 DLLs，但在微服务世界中，我们的部署单元已经改变。现在它是一个容器。我们仍然会将程序编译成程序集。这些程序集将被推送到容器中，并准备好进行部署。
- en: When we look at the code walkthrough in the following section of this chapter
    you will understand this point. We, as .NET developers, have the ability (and
    may I say necessity) to ship the containers. Along with this, another advantage
    of container deployment is that it removes the barrier between different operating
    systems and even different languages and runtimes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章下一节查看代码遍历时，你会理解这个观点。作为 .NET 开发者，我们有能力（也许可以说必要性）来部署容器。此外，容器部署的另一个优点是它消除了不同操作系统甚至不同语言和运行时之间的障碍。
- en: Does it work on your machine? Let's ship your machine!
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它在你的机器上工作吗？让我们把你的机器也运走吧！
- en: 'Usually, we hear this a lot from developers: *Well, it works on my machine!* This
    usually happens when there is a defect that is not reproducible in production.
    Since containers are immutable and composable, it is quite possible to eliminate
    the configuration impedance between the development and production environment.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们经常从开发者那里听到这样的话：“嗯，在我的机器上它工作得很好！”这通常发生在生产环境中无法复制的缺陷出现时。由于容器是不可变和可组合的，消除开发和生产环境之间的配置阻抗是完全可能的。
- en: Introducing Docker
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Docker
- en: Docker (www.docker.com) has been a major force behind popularizing the containerization
    of applications. Docker is to containers what Google is to search engines. Sometimes,
    people even use containers and Docker as synonyms. Microsoft has partnered with
    Docker and is actively contributing to the Docker platform and tools in open source.
    This makes Docker important for us as .NET developers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（www.docker.com）是推动应用程序容器化普及的主要力量。Docker 对于容器来说，就像 Google 对于搜索引擎一样。有时，人们甚至将容器和
    Docker 视为同义词。微软与 Docker 合作，并积极为 Docker 平台和开源工具做出贡献。这使得 Docker 对于我们这些 .NET 开发者来说非常重要。
- en: Docker is a very important topic and will be significant enough to learn for
    any serious .NET developer. However, due to time and scope constraints, we will
    just scratch the surface of the ecosystem of Docker here. We strongly recommend
    that you read through the Docker books made available by Packt Publishing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个非常重要的主题，对于任何严肃的 .NET 开发者来说都足够重要。然而，由于时间和范围的限制，我们在这里只会对 Docker 生态系统进行简要介绍。我们强烈建议你阅读
    Packt 出版公司提供的 Docker 书籍。
- en: If you want to safely try and learn Docker without even installing it on your
    machine, you can do so with [https://KataCoda.com](https://www.katacoda.com/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不需要在机器上安装 Docker 的情况下安全地尝试和学习 Docker，你可以通过 [https://KataCoda.com](https://www.katacoda.com/)
    来实现。
- en: 'Now let''s focus on some of the terminologies and tools of the Docker platform.
    This will be essential for our next section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注 Docker 平台的一些术语和工具。这将是我们的下一节所必需的：
- en: 'Docker image: A Docker *image* is a read-only template with instructions for
    creating a Docker container. A Docker image consists of a separate filesystem,
    associated libraries, and so on. Here, an image is always read-only and can run
    exactly the same abstracting, underlying, host differences. A Docker image can
    be composed of one layer on top of another. This composability of the Docker image
    can be compared with the analogy of layered cake. Docker images that are used
    across different containers can be reused. This also helps reduce the deployment
    footprint of applications that use the same base images.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像：Docker 的 *镜像* 是一个只读模板，包含创建 Docker 容器的指令。Docker 镜像由一个独立的文件系统、相关库等组成。在这里，镜像始终是只读的，并且可以运行完全相同的抽象、底层、主机差异。Docker
    镜像可以由一个层叠加在另一个层之上。Docker 镜像的可组合性可以与分层蛋糕的类比相比较。用于不同容器的 Docker 镜像可以被重用。这也帮助减少了使用相同基础镜像的应用程序的部署足迹。
- en: Docker registry: A Docker registry is a library of images. A registry can be
    either public or private. Also, it can be on the same server as the Docker daemon
    or Docker client or on a totally separate server.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 仓库：Docker 仓库是一个镜像库。仓库可以是公开的，也可以是私有的。此外，它可以是与 Docker 守护进程或 Docker 客户端在同一服务器上，或者完全在不同的服务器上。
- en: Docker hub: This is a public registry and it stores images. It is located at [http://hub.docker.com](http://hub.docker.com/).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker hub：这是一个公共仓库，它存储镜像。它位于 [http://hub.docker.com](http://hub.docker.com/)。
- en: 'Dockerfile: Dockerfile is a build or scripting file that contains instructions
    to build a Docker image. There can be multiple steps documented in a Dockerfile,
    starting with getting the base image.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile：Dockerfile 是一个包含构建 Docker 镜像指令的构建或脚本文件。Dockerfile 中可以记录多个步骤，从获取基础镜像开始。
- en: Docker container: A Docker container is a runnable instance of a Docker image.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器：Docker 容器是 Docker 镜像的可运行实例。
- en: Docker compose: Docker compose allows you to define an application’s components—their
    containers, configuration, links, and volumes—in a single file. Then, a single
    command will set everything up and start your application. It is an architecture/dependency
    map for your application.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker compose：Docker compose 允许您在单个文件中定义应用程序的组件——它们的容器、配置、链接和卷。然后，一个命令将设置一切并启动您的应用程序。它是您应用程序的架构/依赖关系图。
- en: Docker swarm: Swarm is the Docker service by which container nodes work together.
    It runs a defined number of instances of a replica task, which is itself a Docker
    image.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker swarm：Swarm 是 Docker 服务，通过它容器节点协同工作。它运行一个副本任务的定义实例，该任务本身是一个 Docker 镜像。
- en: Let's look into the individual components of the Docker ecosystem; let's try
    to understand one of the ways in which the Docker workflow makes sense in the
    software development life cycle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Docker 生态系统中的各个组件；让我们尝试理解 Docker 工作流程在软件开发生命周期中合理性的其中一种方式。
- en: Microservice deployment with Docker overview
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 微服务部署概述
- en: 'In order to support this workflow, we need a CI tool and a configuration management
    tool. For illustration purposes, we have taken the **Visual Studio Team Services**
    (**VSTS**) build service as CI and VSTS release management for continuous delivery.
    The workflow would remain the same for any other tools or modes of deployment.
    The following is one of the flavors of microservice deployment with Docker:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持此工作流程，我们需要一个 CI 工具和一个配置管理工具。为了说明目的，我们选择了 **Visual Studio Team Services**
    (**VSTS**) 构建服务作为 CI 和 VSTS 发布管理以实现持续交付。对于任何其他工具或部署模式，工作流程都将保持不变。以下是一种 Docker
    微服务部署的变体：
- en: The code is checked into the VSTS repository. If this is the project's first
    check-in, it is done along with Dockerfile for the project.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码已提交到 VSTS 仓库。如果这是项目的第一次提交，它将与项目的 Dockerfile 一起完成。
- en: The preceding check-in triggers VSTS to build the service from the source code
    and run unit/integration tests.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的检查触发 VSTS 从源代码构建服务并运行单元/集成测试。
- en: If tests are successful, VSTS builds a Docker image that is pushed to a *Docker
    registry*. VSTS release services deploy the image to the Azure container service.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试成功，VSTS 将构建一个 Docker 镜像，并将其推送到 *Docker 仓库*。VSTS 发布服务将镜像部署到 Azure 容器服务。
- en: If QA tests pass as well, VSTS is used to promote the container to deploy and
    start it in production.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 QA 测试也通过，则使用 VSTS 将容器提升到部署并启动它在生产中。
- en: 'The following diagram depicts the steps in detail:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表详细描述了步骤：
- en: '![](img/d7114146-d0cb-4056-9907-dc417ff590fe.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7114146-d0cb-4056-9907-dc417ff590fe.png)'
- en: Note that the usual .NET CI-CD tools, such as TeamCity and Octopus Deploy (capabilities
    are in alpha stage), have features to produce a Docker container as a build artifact
    and deploy it to production.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通常的 .NET CI-CD 工具，如 TeamCity 和 Octopus Deploy（功能处于 alpha 阶段），具有生成 Docker
    容器作为构建工件并将其部署到生产的特性。
- en: Microservice deployment example using Docker
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 的微服务部署示例
- en: Now we have all the essentials required to move toward coding and see for ourselves
    how things work. We have taken the product catalog service example here to be
    deployed as a Docker container. After running the accompanying source code, you
    should be able to successfully run the product catalog service in the Docker container.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了迈向编码并亲自查看事物如何工作的所有必需品。我们在这里选择了产品目录服务示例，以作为 Docker 容器部署。在运行相关的源代码之后，您应该能够在
    Docker 容器中成功运行产品目录服务。
- en: Setting up Docker on your machine
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的机器上设置 Docker
- en: This tutorial doesn't require any existing knowledge of Docker and should take
    about 20 or 30 minutes to complete.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程不需要任何现有的 Docker 知识，并且应该花费大约 20 或 30 分钟来完成。
- en: Prerequisites
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前置条件
- en: 'You will need to do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下操作：
- en: Install Microsoft Visual Studio 2017 Update 3 ([https://www.visualstudio.com/downloads/download-visual-studio-vs](https://www.visualstudio.com/downloads/download-visual-studio-vs))
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Microsoft Visual Studio 2017 Update 3 ([https://www.visualstudio.com/downloads/download-visual-studio-vs](https://www.visualstudio.com/downloads/download-visual-studio-vs))
- en: Install .NET Core 2.0 ([https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)[)](https://go.microsoft.com/fwlink/?LinkID=827546)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 .NET Core 2.0 ([https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)[)](https://go.microsoft.com/fwlink/?LinkID=827546)
- en: Install Docker For Windows to run your Docker containers locally ([https://www.docker.com/products/docker#/windows](https://www.docker.com/products/docker#/windows))
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Docker For Windows 以在本地运行 Docker 容器 ([https://www.docker.com/products/docker#/windows](https://www.docker.com/products/docker#/windows))
- en: We are using Docker Community Edition for Windows to demonstrate the example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Docker Community Edition for Windows 来演示示例。
- en: After installation, your system will require restarting to complete the installation.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您的系统需要重启以完成安装。
- en: 'After restarting, Docker for Windows will prompt you to enable the Hyper-V
    feature if not enabled on your system. Click OK to enable the Hyper-V feature
    on your system (a system restart will be required). Refer to the following screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启后，如果您的系统尚未启用 Hyper-V 功能，Docker for Windows 将提示您启用该功能。点击“确定”以在您的系统上启用 Hyper-V
    功能（需要重启系统）。参考以下截图：
- en: '![](img/2c544f4d-910c-43c9-8c82-55a51c290387.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c544f4d-910c-43c9-8c82-55a51c290387.png)'
- en: 'Once Docker for Windows is installed, right-click on the Docker icon in the
    system tray and click on Settings and select Shared Drives:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker for Windows 安装完成后，在系统托盘中的 Docker 图标上右键单击，然后点击“设置”并选择“共享驱动器”：
- en: '![](img/15af9b53-4213-451e-b3ae-e71b91c71d02.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15af9b53-4213-451e-b3ae-e71b91c71d02.png)'
- en: Creating an ASP.NET Core web application
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ASP.NET Core Web 应用程序
- en: 'Following are the simple steps to get started:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开始使用的简单步骤：
- en: 'Create a new project by navigating to File | New Project | .NET Core | select
    ASP.NET Core Web Application, refer to the following screenshot:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到“文件”|“新建项目”|“.NET Core”|选择 ASP.NET Core Web 应用程序来创建一个新项目，参考以下截图：
- en: '![](img/27b5d3b3-d1b6-4c2d-a0e1-31752a7c10a4.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27b5d3b3-d1b6-4c2d-a0e1-31752a7c10a4.png)'
- en: From the New ASP.NET Core Web Application window, select .NET Core and ASP.NET
    Core 2.0.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“新建 ASP.NET Core Web 应用程序”窗口中，选择 .NET Core 和 ASP.NET Core 2.0。
- en: Select Web Application (Model-View-Controller) from available templates.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的模板中选择 Web 应用程序（模型-视图-控制器）。
- en: Check Enable Docker support.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查“启用 Docker 支持”。
- en: As we are demonstrating it for Windows select OS as Windows (if you did not
    install Docker as mentioned in the previous section, here you need to install
    Docker for Windows).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们是在 Windows 上进行演示，请选择操作系统为 Windows（如果您没有按照上一节所述安装 Docker，那么您需要安装 Docker for
    Windows）。
- en: 'Click Ok to proceed, refer to the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”继续，参考以下截图：
- en: '![](img/f53a167d-af7a-4ec0-ae9e-cfca32f11edf.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f53a167d-af7a-4ec0-ae9e-cfca32f11edf.png)'
- en: 'The preceding steps will create the `FlixOne.BookStore.ProductService` project with
    Docker support. Following is the screenshot showing our project structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤将创建具有 Docker 支持的 `FlixOne.BookStore.ProductService` 项目。以下是我们项目结构的截图：
- en: '![](img/c34b34a9-ebc3-4241-97c6-21e07ca4d291.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c34b34a9-ebc3-4241-97c6-21e07ca4d291.png)'
- en: 'The following files are added to the project:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件被添加到项目中：
- en: '`Dockerfile`: The Dockerfile for ASP.NET Core applications is based on the microsoft/aspnetcore image
    ([https://hub.docker.com/r/microsoft/aspnetcore/](https://hub.docker.com/r/microsoft/aspnetcore/)).
    This image includes the ASP.NET Core NuGet packages, which have been prejitted,
    improving startup performance. When building ASP.NET Core applications, the Dockerfile
    FROM instruction (command) points to the most recent microsoft/dotnet image ([https://hub.docker.com/r/microsoft/dotnet/](https://hub.docker.com/r/microsoft/dotnet/))
    on the Docker hub. Following is the default code-snippet provided by the template:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile`：ASP.NET Core 应用程序的 Dockerfile 基于 `microsoft/aspnetcore` 镜像 ([https://hub.docker.com/r/microsoft/aspnetcore/](https://hub.docker.com/r/microsoft/aspnetcore/))。此镜像包含预编译的
    ASP.NET Core NuGet 包，这提高了启动性能。当构建 ASP.NET Core 应用程序时，Dockerfile 的 FROM 指令（命令）指向
    Docker Hub 上的最新 `microsoft/dotnet` 镜像 ([https://hub.docker.com/r/microsoft/dotnet/](https://hub.docker.com/r/microsoft/dotnet/))）。以下是由模板提供的默认代码片段：'
- en: '[PRE0]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is basically a set of instructions and these instructions
    are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码基本上是一组指令，这些指令如下：
- en: '`FROM` tells Docker that to pull the base image on the existing image, call `microsoft/aspnetcore:2.0`.
    This image already contains all the dependencies for running the ASP.NET Core
    on Linux, so we don''t have to set it.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 告诉 Docker 从现有镜像中拉取基础镜像，调用 `microsoft/aspnetcore:2.0`。这个镜像已经包含了在 Linux
    上运行 ASP.NET Core 所需的所有依赖项，因此我们不需要设置它。'
- en: '`COPY` and `WORKDIR` copy the current directory''s contents to a new directory
    inside the called/app container and set it to the working directory for subsequent
    instructions.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 和 `WORKDIR` 将当前目录的内容复制到被调用/app 容器内部的新目录中，并将其设置为后续指令的工作目录。'
- en: '`EXPOSE` tells Docker to expose the product catalog service on port 80 of the
    container.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 告诉 Docker 在容器的 80 端口上公开产品目录服务。'
- en: '`ENTRYPOINT` specifies the command to execute when the container starts up.
    In this case, it''s .NET.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 指定了容器启动时执行的命令。在这种情况下，是 .NET。'
- en: '`Docker-compose.yml`: This is the base Compose file used to define the collection
    of images to be built and run with `Docker-compose` build/run.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker-compose.yml`：这是用于定义要使用 `Docker-compose` build/run 构建和运行的镜像集合的基本 Compose
    文件。'
- en: '`Docker-compose.dev.debug.yml`: This is an additional Compose file for iterative
    changes when your configuration is set to debug. Visual Studio will call `-f docker-compose.yml` and
    `-f docker-compose.dev.debug.yml` to merge them. This Compose file is used by
    Visual Studio development tools.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker-compose.dev.debug.yml`：这是一个额外的 Compose 文件，用于在配置设置为调试时进行迭代更改。Visual
    Studio 将调用 `-f docker-compose.yml` 和 `-f docker-compose.dev.debug.yml` 来合并它们。此
    Compose 文件由 Visual Studio 开发工具使用。'
- en: '`Docker-compose.dev.release.yml`: This is an additional Compose file to debug
    your release definition. It will load the debugger in isolation so it does not
    change the content of the production image.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker-compose.dev.release.yml`：这是一个额外的 Compose 文件，用于调试您的发布定义。它将在隔离模式下加载调试器，因此不会更改生产镜像的内容。'
- en: The `docker-compose.yml` file contains the name of the image that is created
    when the project is run.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml` 文件包含在项目运行时创建的镜像名称。'
- en: 'We now have everything we need to run/launch our service in the Docker container.
    Before we go further, please refer to [Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml),
    *Implementing Microservices*, and add the complete code (that is, controller,
    repositories, and so on) so the project structure looks like the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有运行/启动 Docker 容器中我们的服务所需的一切。在继续之前，请参阅[第 2 章](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml)，*实现微服务*，并添加完整的代码（即控制器、存储库等），以便项目结构看起来像以下截图：
- en: '![](img/ade370fb-7585-4a16-936b-d23a1afa3f33.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ade370fb-7585-4a16-936b-d23a1afa3f33.png)'
- en: Now all you have to do is press *F5* and launch your service in the container.
    This is the simplest and easiest way to put your service in the container. Once
    your microservice is containerized, you can use Visual Studio team services and
    Azure container services to deploy your container to the Azure cloud ([https://docs.microsoft.com/en-us/azure/container-service/dcos-swarm/container-service-deployment](https://docs.microsoft.com/en-us/azure/container-service/dcos-swarm/container-service-deployment)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需按 *F5* 键并在容器中启动你的服务。这是将服务放入容器中最简单、最直接的方法。一旦你的微服务被容器化，你可以使用 Visual Studio
    团队服务和 Azure 容器服务将容器部署到 Azure 云中（[https://docs.microsoft.com/en-us/azure/container-service/dcos-swarm/container-service-deployment](https://docs.microsoft.com/en-us/azure/container-service/dcos-swarm/container-service-deployment)）。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Microservice deployment is an exciting journey for us. For successful microservice
    delivery, deployment best practices should be followed. We need to focus on implementing
    isolation requirements for microservices even before we talk about deployment
    using automated tools. With successful microservice deployment practices, we can
    deliver business changes rapidly. The different isolation, requirements from self-sufficient
    teams to continuous delivery, give the scale and agility that are fundamental
    promises of microservices. Containerization is by far one of the most important
    innovative technologies we have, and we must take advantage of it for microservice
    deployment. Combining the Azure cloud with Docker will help us deliver the scale
    and isolation we are expecting from microservices. With Docker, we can easily
    achieve greater application density, which means a reduction in our cloud infrastructure
    cost. We also saw how easy it is to start these deployments with Visual Studio
    and Docker tools for Windows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务部署对我们来说是一次激动人心的旅程。为了成功交付微服务，应遵循部署的最佳实践。在我们讨论使用自动化工具进行部署之前，我们需要关注实现微服务的隔离要求。通过成功的微服务部署实践，我们可以快速交付业务变更。从自给自足的团队到持续交付的不同隔离要求，为微服务提供了基本承诺的规模和敏捷性。容器化到目前为止是我们拥有的最重要的创新技术之一，我们必须利用它来进行微服务部署。将Azure云与Docker结合使用将帮助我们实现我们期望的微服务的规模和隔离。有了Docker，我们可以轻松实现更高的应用程序密度，这意味着我们云基础设施成本的降低。我们还看到了如何使用Visual
    Studio和Windows的Docker工具轻松启动这些部署。
- en: In our next chapter, we will look at microservice security. We will discuss
    the Azure active directory for authentication, how to leverage OAuth 2.0, and
    how to secure an API gateway with Azure API Management.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的章节中，我们将探讨微服务安全。我们将讨论用于身份验证的Azure活动目录，如何利用OAuth 2.0，以及如何使用Azure API管理来保护API网关。
