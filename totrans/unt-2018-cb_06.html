<html><head></head><body>
        

                            
                    <h1 class="header-title">Shader Graphs and Video Players</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<p class="mce-root"/>
<ul>
<li>Playing videos by manually adding a VideoPlayer component to a GameObject</li>
<li>Using scripting to control video playback on scene textures</li>
<li>Using scripting to play a sequence of videos back-to-back</li>
<li>Creating and using a simple Shader Graph</li>
<li>Using a Shader Graph to create a color glow effect</li>
<li>Toggling a Shader Graph color glow effect through C# code</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Two powerful recent additions to Unity have been the Video Player component (and API), and the Shader Graph tool. Between them, they offer easier and more configurable ways to work with visual content in games. For example, they help with the loading and playing of videos on different visible objects, and provide a comprehensive way for non-shader programmers to construct sophisticated shader transformations using a visual graphing approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>The two core new Unity features discussed in this chapter are <strong>Shader Graphs</strong> and the <strong>Video Player</strong>. Each has its own section below.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The new Shader Graph tool</h1>
                
            
            
                
<p>In 2018, Unity published details about the exciting new <strong>Shader Graph</strong> feature. <strong>Shader Graph</strong> is a tool that allows <strong>visual</strong> building of shaders, by creating and connecting inputs and output of nodes. Currently, it only works with the Lightweight Scriptable Render Pipeline, but should eventually work with many pipelines.</p>
<p>Unity's <strong>Scriptable Render Pipeline</strong> allow different, and customizable, rending pipelines, that can be efficiently targeted for specific projects and hardware settings (for example, exploiting GPUs in powerful desktop computers, or reducing performance requirements for less powerful mobile devices).</p>
<p>Some great <strong>Shader Graph</strong> features include the following:</p>
<ul>
<li>An instant, visual preview of each node in the graph, so that you can see how different nodes are contributing to the final <strong>Master</strong> output node.</li>
<li>Properties can be publicly exposed in the graph (via the <strong>Blackboard</strong>), so that they become customizable values in the <strong>Inspector</strong> for the <strong>Material</strong> using the <strong>Shader Graph</strong>.</li>
<li>Publicly exposed properties can also be accessed and changed via scripts.</li>
<li>The output of one node can become one of the inputs to another node, so a sophisticated shader can be created from many combined, simple component nodes:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/190af154-9f0f-4288-95be-c62117a37765.png"/></p>
<p>This screenshot illustrates how Shader Graphs are composed of a graph of connected nodes, where the output of one node becomes the input to another node. Node input/outputs can be numeric values, Textures, noise, Boolean true/false values, Colors etc.</p>
<p><strong>Shader Graph</strong> files are created in the Project panel, and can be selected as a graph shader in the <kbd>Shader</kbd> property of a <strong>Material</strong>.</p>
<p>Several recipes are presented in this chapter to introduce some of the powerful <strong>Shader Graph</strong> features and workflow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing videos with the new Video Player</h1>
                
            
            
                
<p>In 2017, Unity replaced the old <kbd>MovieTexture</kbd> with the VideoPlayer component (as well as the associated VideoClip asset file type). Playing videos is as simple as manually adding a VideoPlayer component in the Inspector to a GameObject at design time, and associating a VideoClip asset file from the Project panel, or providing the URL of a online resource.</p>
<p>Videos can be played on the camera's far plane (appearing behind the scene content), or near plane (appearing in front of content – often with semi-transparency). Video content can also be directed to a <kbd>RenderTexture</kbd> asset, which can then (via a Material) be displayed on a 2D or 3D object in the scene. The internal texture used by a VideoPlayer can also be mapped to a texture on screen – such as UI Raw Image.</p>
<p>Scripting can be used to manage video playback for single and arrays (sequence) of video clips. Several recipes are presented in this chapter to introduce these different ways to work with the VideoPlayer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Online references materials</h1>
                
            
            
                
<p>The following are useful sources of information for the topics of this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shader Graph online resources</h1>
                
            
            
                
<p>Unity documentation and third-party articles about the Shader Graphs can be found online at the following links:</p>
<ul>
<li>The Shader Graph blog introduction: <a href="https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/" target="_blank">https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/</a></li>
<li>The Unity Shader Graph overview: <a href="https://unity3d.com/shader-graph" target="_blank">https://unity3d.com/shader-graph</a></li>
<li>The Unity GitHub Shader Graph wiki: <a href="https://github.com/Unity-Technologies/ShaderGraph/wiki" target="_blank">https://github.com/Unity-Technologies/ShaderGraph/wiki</a></li>
<li>The Shader Graph example library on GitHub: <a href="https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary" target="_blank">https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary</a></li>
<li>Great video tutorial of Shader Graph from Unity Technology's Andy Tough at GDC 2018: <a href="https://www.youtube.com/watch?v=NsWNRLD-FEI" target="_blank">https://www.youtube.com/watch?v=NsWNRLD-FEI</a></li>
<li>Unity's manual page about the Scriptable Render Pipeline: <a href="https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html" target="_blank">https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Video Player online resources</h1>
                
            
            
                
<p>Unity documentation and third-party articles about the Video Player can be found online at the following links:</p>
<ul>
<li>The Unity Video Player manual page: <a href="https://docs.unity3d.com/Manual/class-VideoPlayer.html" target="_blank">https://docs.unity3d.com/Manual/class-VideoPlayer.html</a></li>
<li>The Unity Scripting reference for the VideoPlayer class: <a href="https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html" target="_blank">https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html</a></li>
<li>Creative Chris' blog post about the Video Player: <a href="https://creativechris.me/2017/02/07/unitys-new-video-playback-component/" target="_blank">https://creativechris.me/2017/02/07/unitys-new-video-playback-component/</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing videos by manually adding a VideoPlayer component to a GameObject</h1>
                
            
            
                
<p>TV sets, projectors, monitors.... If you want complex animated materials in your level, you can play video files as texture maps. In this recipe, we will learn how to add and use VideoPlayer components on the main camera.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>If you need a video file so that you can follow this recipe, please use the <kbd>videoTexture.mov</kbd> file included in the <kbd>13_01</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To place videos manually with a VideoPlayer component, follow these steps:</p>
<ol>
<li>Import the provided <kbd>videoTexture.mov</kbd> file.</li>
<li>Add a 3D Cube to the scene by choosing menu: GameObject | 3D Object | Cube.</li>
</ol>
<ol start="3">
<li>Select the Main Camera GameObject, and in the Inspector, add a Video Player component by clicking Add Component, and choosing Video | Video Player. Unity will have noticed that we are adding the Video Player component to a camera, and so should have set up the default properties correctly for us:
<ul>
<li>Play On Awake (Checked)</li>
<li>Wait For First Frame (Checked)</li>
<li>Render Mode: Camera Far Plane</li>
<li>Camera: Main Camera (Camera)</li>
</ul>
</li>
<li>Drag the video clip asset file videoTexture from the Project panel into the Video Clip property slot in the Inspector, like so:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/94eec315-4dc5-4382-afce-fd3a7e7575e1.png" style="width:38.67em;height:18.25em;"/></p>
<ol start="5">
<li>Test your scene. You should be able to see the movie being played behind the scene content.</li>
<li>You can choose whether to stretch the video content by changing the Aspect Ratio property in the Inspector (for example, you can change it to Stretch in order to fill in the complete background of the screen).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We gave the Video Player component a reference to a Video Clip asset file. Since we added the Video Player component to a Camera (the Main Camera, in this example), it automatically chose the Camera Far Play Render Mode linked to the Main Camera.</p>
<p>The default setting is Play On Awake, so as soon as the first frame has loaded (since Wait For First Frame is also checked by default), the video will start playing. The video is displayed behind all main camera content (the far plane). Because of this, we see our 3D Cube in the scene, with the video playing in the background.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some additional ways to work with the Video Player component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Semi-transparent video and Camera Near Plane</h1>
                
            
            
                
<p>Sometimes, we may want to play a video so that it's the user's main focus, but allow them to see scene objects in the background.</p>
<p>To achieve this with the Video Player component, we just need to make two changes:</p>
<ol>
<li>Change the Render Mode to Near Camera Plane (so that the video content is played in front of the scene content).</li>
<li>To allow the user to partially see through the video, we need to make the Video Player semi-transparent. Change its Alpha property to 0.5.</li>
</ol>
<p>Now, when you run the scene, you'll see the video playing in front of scene content, but now you will be able to see the 3D cube in the background.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Audio issues and AudioSource solution</h1>
                
            
            
                
<p>At the time of writing this book, there seem to be issues with the Direct option for Audio Output Mode audio playback for some non-Apple systems. One solution is to add an AudioSource component to the same GameObject that has the VideoPlayer component, and to set the Audio Output Mode to AudioSource.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using scripting to control video playback on scene textures</h1>
                
            
            
                
<p>While the last recipe demonstrated how we can plan videos using the Video Player component that's set up at design time, much more is possible when controlling video playback through scripting.</p>
<p>In this recipe, we'll using scripting to play/pause the playback of a video rendered onto a 3D cube:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d4333282-1119-4ece-94ac-4daf280a1f0d.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>If you need a video file to follow this recipe, please use the <kbd>videoTexture.mov</kbd> file included in the <kbd>13_01</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To use scripting to control video playback, follow these steps:</p>
<ol>
<li>Import the provided <kbd>videoTexture.mov</kbd> file.</li>
<li>Create a 3D cube by choosing menu: Create | 3D | Cube.</li>
</ol>
<ol start="3">
<li>Create a C# script class named <kbd>PlayPauseMainTexture</kbd>, and attach an instance object as a component to your 3D cube GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>     using UnityEngine.Video;<br/> <br/>     [RequireComponent(typeof(VideoPlayer))]<br/>     [RequireComponent(typeof(AudioSource))]<br/> <br/>     public class PlayPauseMainTexture : MonoBehaviour {<br/>         public VideoClip videoClip;<br/> <br/>         private VideoPlayer videoPlayer;<br/>         private AudioSource audioSource;<br/> <br/>         void Start() {<br/>             videoPlayer = GetComponent&amp;lt;VideoPlayer&amp;gt;();<br/>             audioSource = GetComponent&amp;lt;AudioSource&amp;gt;();<br/> <br/>             videoPlayer.playOnAwake = false;<br/>             audioSource.playOnAwake = false;<br/> <br/>             videoPlayer.source = VideoSource.VideoClip;<br/>             videoPlayer.clip = videoClip;<br/> <br/>             videoPlayer.audioOutputMode = VideoAudioOutputMode.AudioSource;<br/>             videoPlayer.SetTargetAudioSource(0, audioSource);<br/> <br/>             videoPlayer.renderMode = VideoRenderMode.MaterialOverride;<br/>             videoPlayer.targetMaterialRenderer = GetComponent&amp;lt;Renderer&amp;gt;();<br/>             videoPlayer.targetMaterialProperty = "_MainTex";<br/>         }<br/> <br/>         void Update() {<br/>             if (Input.GetButtonDown("Jump"))<br/>                 PlayPause();<br/>         }<br/> <br/>         private void PlayPause() {<br/>             if (videoPlayer.isPlaying)<br/>                     videoPlayer.Pause();<br/>             else<br/>                 videoPlayer.Play();<br/>         }<br/>     } </pre>
<ol start="4">
<li>Ensure that your 3D cube is selected in the Project panel. Then, drag the Video Clip asset file <kbd>videoTexture</kbd> from the Project panel into the Video Clip property slot of the <kbd>PlayPauseMainTexture</kbd> component (script) in the Inspector.</li>
<li>Run your scene. Pressing the spacebar should play/pause playback of the video on the surfaces of the 3D cube. You should also hear the beeping audio for video.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We added the instance object of our scripted class to the 3D cube, and dragged a reference to a Video Clip asset file to the public slot. In our code, we are telling the VideoPlayer component to override the Material of the object it is a component of (in this case, the 3D cube) so that the Video Player will render (display) onto the main texture of the 3D cube:</p>
<pre>videoPlayer.renderMode = VideoRenderMode.MaterialOverride;<br/> videoPlayer.targetMaterialRenderer = GetComponent&amp;lt;Renderer&amp;gt;();<br/> videoPlayer.targetMaterialProperty = "_MainTex";<br/> </pre>
<p class="SourceCode">The basics to using scripting and the VideoPlayer is as follows. As well as defining and setting up where the Video Player will render, we also need to do the following each time:</p>
<ol>
<li>Create or get references to the VideoPlayer and AudioSource components (we will automatically have both components for this recipe since we have the <kbd>RequireComponent(...)</kbd> script instructions immediately before our class declaration):</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">videoPlayer = GetComponent&amp;lt;VideoPlayer&amp;gt;();<br/> audioSource = GetComponent&amp;lt;AudioSource&amp;gt;();</pre>
<ol start="2">
<li>Set their Play On Awake to <kbd>true</kbd>/<kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 60px">videoPlayer.playOnAwake = false;<br/> audioSource.playOnAwake = false; </pre>
<ol start="3">
<li>Define where the Video Player will find a reference to the Video Clip to play:</li>
</ol>
<pre style="padding-left: 60px">videoPlayer.source = VideoSource.VideoClip;<br/> videoPlayer.clip = videoClip; </pre>
<ol start="4">
<li>Define the audio settings (so that you can output to the AudioSource component):</li>
</ol>
<pre style="padding-left: 60px">videoPlayer.audioOutputMode = VideoAudioOutputMode.AudioSource;<br/> videoPlayer.SetTargetAudioSource(0, audioSource); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some additional ways to work with Video Player scripting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ensuring that a movie's prepared before playing it with the prepareCompleted event</h1>
                
            
            
                
<p>In the preceding recipe, the movie has time to prepare since the game waits until we press the jumo/space key. If we are using scripting to set up a Video Player for a video clip, we need to do some initial work before the video is ready to play. Unity provides the <kbd>prepareCompleted</kbd> event, which allows us to register a method to be invoked once a VideoPlayer is ready to play.</p>
<p>Do the following:</p>
<ol>
<li>Add a UI Raw Image to the scene by choosing menu: Create | UI | Raw Image.</li>
<li>Create a new empty GameObject named video-object.</li>
<li>Create a C# script class named <kbd>PrepareCompleted</kbd>, and attach an instance object as a component to GameObject's video-object:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/>     using UnityEngine.Video;<br/> <br/>     public class PrepareCompleted: MonoBehaviour {<br/>         public RawImage image;<br/>         public VideoClip videoClip;<br/> <br/>         private VideoPlayer videoPlayer;<br/>         private AudioSource audioSource;<br/> <br/>         void Start() {<br/>             SetupVideoAudioPlayers();<br/>             videoPlayer.prepareCompleted += PlayVideoWhenPrepared;<br/>             videoPlayer.Prepare();<br/>             Debug.Log("A - PREPARING");<br/>         }<br/> <br/>         private void SetupVideoAudioPlayers() {<br/>             videoPlayer = gameObject.AddComponent&amp;lt;VideoPlayer&amp;gt;();<br/>             audioSource = gameObject.AddComponent&amp;lt;AudioSource&amp;gt;();<br/> <br/>             videoPlayer.playOnAwake = false;<br/>             audioSource.playOnAwake = false;<br/> <br/>             videoPlayer.source = VideoSource.VideoClip;<br/>             videoPlayer.clip = videoClip;<br/> <br/>             videoPlayer.audioOutputMode = VideoAudioOutputMode.AudioSource;<br/>             videoPlayer.SetTargetAudioSource(0, audioSource);<br/>         }<br/> <br/>         private void PlayVideoWhenPrepared(VideoPlayer theVideoPlayer) {<br/>             Debug.Log("B - IS PREPARED");<br/> <br/>             image.texture = theVideoPlayer.texture;<br/> <br/>             Debug.Log("C - PLAYING");<br/>             theVideoPlayer.Play();<br/>         }<br/>     } </pre>
<ol start="4">
<li>Ensure that video-object is selected in the Project panel. Now, drag the Raw Image from the Hierarchy into the Raw Image slot. Then, drag the Video Clip asset file <kbd>videoTexture</kbd> from the Project panel into the Video Clip property slot of the <kbd>PrepareCompleted</kbd> component (script) in the Inspector.</li>
<li>Test your scene. You should be able to see the movie being played behind the scene content.</li>
</ol>
<p>You can see that, in the <kbd>Start()</kbd> method, we first register a method named <kbd>PlayVideoWhenPrepared</kbd> with the <kbd>videoPlayer.prepareCompleted</kbd> event, before invoking the <kbd>Prepare()</kbd> method of the <kbd>videoPlayer</kbd> component:</p>
<pre>videoPlayer.prepareCompleted += PlayVideoWhenPrepared;<br/> videoPlayer.Prepare(); </pre>
<p>The <kbd>PlayVideoWhenPrepared(...)</kbd> method has to accept a parameter as a reference to a VideoPlayer object. We first directly assign the VideoPlayer's texture property to the Raw Image's texture. Then, we send the <kbd>Play()</kbd> message.</p>
<p>Directly working with the VideoPlayer texture works for this example, but usually setting up a separate Render Texture is more reliable and flexible - see the following subsection for how to do this.</p>
<p>You can track progress of clip preparation and so on through the Log messages in the Console panel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Outputting video playback to a Render Texture asset</h1>
                
            
            
                
<p>A flexible way to work with Video Players is to output their playback to a Render Texture asset file. A Material can be created to get input from the Render Texture, and GameObjects using that Material will display the video. Also, some GameObjects can directly have the Render Texture assigned as their texture.</p>
<p>Do the following:</p>
<ol>
<li>In the Project panel, create a new Render Texture asset file named <kbd>myRenderTexture</kbd> (menu: Create | Render Texture).</li>
<li>Select the UI Raw Image in the Hierarchy, and assign its Raw Image (Script) texture property to the <kbd>myRenderTexture</kbd> asset file.</li>
<li>In the Project panel, create a new Material asset file named <kbd>m_video</kbd>. For this Material, in the Inspector, set its Albedo Texture property to <kbd>myRenderTexture</kbd> (drag it from the Project panel into the Inspector).</li>
<li>Create a new 3D capsule in the scene, and assign it the Material m_video.</li>
<li>Edit the C# script class <kbd>PrepareCompleted</kbd> by replacing the public <kbd>rawImage</kbd> variable with a public <kbd>renderTexture</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">  public VideoClip videoClip;<br/>   public RenderTexture renderTexture; </pre>
<ol start="6">
<li>Edit the C# script class <kbd>PrepareCompleted</kbd> by adding the following statements at the end of the <kbd>SetupVideoAudioPlayers()</kbd> method to output video to <kbd>RenderTexture</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    videoPlayer.renderMode = VideoRenderMode.RenderTexture;<br/>     videoPlayer.targetTexture = renderTexture; </pre>
<ol start="7">
<li>Edit the C# script class PrepareCompleted in the <kbd>PlayVideoWhenPrepared()</kbd> method. Remove the statement that directly assigns the VideoPlayer's texture property to the Raw Image's Texture:</li>
</ol>
<pre style="padding-left: 60px">    private void PlayVideoWhenPrepared(VideoPlayer theVideoPlayer) {<br/>         Debug.Log("B - IS PREPARED");<br/> <br/>         // Play video<br/>         Debug.Log("C - PLAYING");<br/>         theVideoPlayer.Play();<br/>     } </pre>
<ol start="8">
<li>Ensure that the GameObject video-object is selected in the Project panel. Now, drag the <kbd>myRenderTexture</kbd> asset from the Project panel into the Render Texture public property of the Prepare Completed (Script) in the Inspector.</li>
<li>Run the scene. You should now see the video playing both in the UI Raw Image and also rendered over the 3D Capsule object:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cd64a526-f7d8-4f1a-97b7-073c95a49bdb.png" style="width:28.33em;height:15.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ensuring that the movie is prepared before playing with coroutines</h1>
                
            
            
                
<p>Many Unity programmers are very used to working with coroutines, so instead of using the <kbd>prepareCompleted</kbd> event, we can rewrite the preceding script by using a coroutine.</p>
<p>Do the following:</p>
<ol>
<li>Remove the <kbd>PlayVideoWhenPrepared()</kbd> method.</li>
<li>Add a new using statement at the top of the script (so that we can refer to IEnumerator interface):</li>
</ol>
<pre style="padding-left: 60px">    using System.Collections; </pre>
<ol start="3">
<li>Replace the existing <kbd>Start()</kbd> method with the following:</li>
</ol>
<pre style="padding-left: 60px">    private IEnumerator Start() {<br/>         SetupVideoAudioPlayers();<br/>         videoPlayer.Prepare();<br/> <br/>         while (!videoPlayer.isPrepared)<br/>             yield return null;<br/> <br/>         videoPlayer.Play();<br/>     } </pre>
<p>As we can see, our <kbd>Start()</kbd> method has become a coroutine (returning an IEnumerator), which means that it can yield control back to Unity during its execution. In the next frame, it will resume execution at that same statement.</p>
<p>There is a while loop that will continue running until the isPrepared property is true for VideoPlayer. So, each frame of Unity will return to this while loop, and if the VideoPlayer is still not prepared, it enters the loop again and yields execution until the next frame. When VideoPlayer isPrepared is finally true, the loop condition is false, so the statement after the loop is executed (<kbd>videoPLayer.Play()</kbd>), and the method finally completes its execution.</p>
<p>For a single video, there is little to choose from between the <kbd>isPrepared</kbd> event and the preceding coroutine. However, for a sequence of videos, the use of the <kbd>isPrepared</kbd> and <kbd>loopPointReached</kbd> events helps us make much simpler logic for preparing and then waiting to play the next video in a sequence (see the next recipe for more information).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Downloading an online video (rather than a clip)</h1>
                
            
            
                
<p>Rather than dragging an existing Video Clip asset file to specify which video to play, the Video Player can also download Video Clips from an online source. We need to assign a string URL to the Video Player's URL property.</p>
<p>Do the following:</p>
<ol>
<li>Declare a public array of strings, in which one or more URLs can be defined:</li>
</ol>
<pre style="padding-left: 60px">    public string[] urls = {<br/>         "http://mirrors.standaloneinstaller.com/video-sample/grb_2.mov",<br/>         "http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mov"<br/>     }; </pre>
<ol start="2">
<li>Declare a new method that returns one URL string, randomly chosen from the array:</li>
</ol>
<pre style="padding-left: 60px">    public string RandomUrl(string[] urls)<br/>     {<br/>         int index = Random.Range(0, urls.Length);<br/>         return urls[index];<br/>     } </pre>
<ol start="3">
<li>Finally, in the <kbd>SetupVideoAudioPlayers()</kbd> method, we need to get the random URL string, and assign it to the Video Player's <kbd>url</kbd> property:</li>
</ol>
<pre style="padding-left: 60px">    private void SetupVideoAudioPlayers()<br/>     {<br/>         ... as before<br/> <br/>         // assign video clip<br/>         string randomUrl = RandomUrl(urls);<br/>         videoPlayer.url = randomUrl;<br/> <br/>         ... as before<br/>     } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using scripting to play a sequence of videos back-to-back</h1>
                
            
            
                
<p>One of the advantages of scripting is that it allows us to easily work with multiple items through loops and arrays, and so on. In this recipe, we'll work with an array of Video Clip assets and use scripting to play them back-to-back (one starts as soon as the previous clip finishes), illustrating the use of the isPrepared and loopPointReached events to avoid complicated loops and coroutines.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>If you need video files in order to follow this recipe, please use the <kbd>videoTexture.mov</kbd> file included in the <kbd>13_01</kbd> folder.</p>
<div><strong>NOTE:</strong> The Standalone Installer website provides a good online source of test videos: http://standaloneinstaller.com/blog/big-list-of-sample-videos-for-testers-124.html.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To play a sequence of videos using scripting, follow these steps:</p>
<ol>
<li>Import the provided <kbd>videoTexture.mov</kbd> file, and perhaps a second video clip, so that we can have a sequence of two different videos to test (although you can run the same one twice if you wish).</li>
<li>In the Project panel, create a new Render Texture asset file named myRenderTexture (menu: Create | Render Texture).</li>
<li>Add a UI Raw Image to the scene by choosing menu: Create | UI | Raw Image.</li>
<li>Select the UI Raw Image in the Hierarchy, and assign its Raw Image (Script) Texture property to the myRenderTexture asset file.</li>
<li>In the Project panel, create a new Material asset file named m_video. For this Material, in the Inspector, set its Albedo Texture property to myRenderTexture (drag it from the Project panel into the Inspector).</li>
<li>Create a 3D cube by choosing menu: Create | 3D | Cube. Assign the m_video Material to your 3D cube.</li>
<li>Create a new empty GameObject named video-object.</li>
<li>Create a C# script class named VideoSequenceRenderTexture, and attach an instance object as a component to the GameObject's video-object:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using UnityEngine.Video;<br/> <br/>     public class VideoSequenceRenderTexture : MonoBehaviour {<br/>         public RenderTexture renderTexture;<br/>         public VideoClip[] videoClips;<br/> <br/>         private VideoPlayer[] videoPlayers;<br/>         private int currentVideoIndex;<br/> <br/>         void Start() {<br/>             SetupObjectArrays();<br/>             currentVideoIndex = 0;<br/>             videoPlayers[currentVideoIndex].prepareCompleted += PlayNextVideo;<br/>             videoPlayers[currentVideoIndex].Prepare();<br/>             Debug.Log("A - PREPARING video: " + currentVideoIndex);<br/>         }<br/> <br/>         private void SetupObjectArrays() {<br/>             videoPlayers = new VideoPlayer[videoClips.Length];<br/>             for (int i = 0; i &amp;lt; videoClips.Length; i++)<br/>                 SetupVideoAudioPlayers(i);<br/>         }<br/> <br/>         private void PlayNextVideo(VideoPlayer theVideoPlayer) {<br/>             VideoPlayer currentVideoPlayer = videoPlayers[currentVideoIndex];<br/> <br/>             Debug.Log("B - PLAYING Index: " + currentVideoIndex);<br/>             currentVideoPlayer.Play();<br/> <br/>             currentVideoIndex++;<br/>             bool someVideosLeft = currentVideoIndex &amp;lt; videoPlayers.Length;<br/> <br/>             if (someVideosLeft) {<br/>                 VideoPlayer nextVideoPlayer = videoPlayers[currentVideoIndex];<br/>                 nextVideoPlayer.Prepare();<br/>                 Debug.Log("A - PREPARING video: " + currentVideoIndex);<br/>                 currentVideoPlayer.loopPointReached += PlayNextVideo;<br/>             } else {<br/>                 Debug.Log("(no videos left)");<br/>             }<br/>         }<br/> <br/>         private void SetupVideoAudioPlayers(int i) {<br/>             string newGameObjectName = "videoPlayer_" + i;<br/>             GameObject containerGo = new GameObject(newGameObjectName);<br/>             containerGo.transform.SetParent(transform);<br/>             containerGo.transform.SetParent(transform);<br/> <br/>             VideoPlayer videoPlayer = containerGo.AddComponent&amp;lt;VideoPlayer&amp;gt;();<br/>             AudioSource audioSource = containerGo.AddComponent&amp;lt;AudioSource&amp;gt;();<br/> <br/>             videoPlayers[i] = videoPlayer;<br/> <br/>             videoPlayer.playOnAwake = false;<br/>             audioSource.playOnAwake = false;<br/> <br/>             videoPlayer.source = VideoSource.VideoClip;<br/>             videoPlayer.clip = videoClips[i];<br/> <br/>             videoPlayer.audioOutputMode = VideoAudioOutputMode.AudioSource;<br/>             videoPlayer.SetTargetAudioSource(0, audioSource);<br/> <br/>             videoPlayer.renderMode = VideoRenderMode.RenderTexture;<br/>             videoPlayer.targetTexture = renderTexture;<br/>         }<br/>     } </pre>
<ol start="9">
<li>Ensure that the GameObject video-object is selected in the Project panel. Now, drag the myRenderTexture asset from the Project panel into the Render Texture public property of the PrepareCompleted (Script) in the Inspector. For the Video Clips property, set the size to 2 – you should now see two video clip elements (elements 0 and 1). From the Project panel, drag in a video clip to each slot.</li>
</ol>
<ol start="10">
<li>Run the scene. You should now see the first video clip playing both for the UI Raw Image and the 3D cube surface. Once the the first video clip has finished playing, the second video clip should immediately start playing.</li>
</ol>
<p>You can track the progress of clip preparation and so on through the Log messages in the Console panel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This script class makes the Video Player objects output their videos to Render Texture's asset file, myRenderTexture. This is used by both 3D cube and the UI Raw Image for their surface display.</p>
<p>The videoClips variable is a public array of video clip references.</p>
<p>The instance object of the C# script class VideoSequenceRenderTexture was added as a component to GameObject's video-object. This script will create child GameObjects of GameObject video-object, each containing a VideoPlayer and AudioSource component, ready to play each of the video clips assigned in the public array's videoClips variables.</p>
<p>The <kbd>SetupObjectArrays()</kbd> method initializes videoPlayers to be an array the same length as videoClips. It then loops for each item, invoking <kbd>SetupVideoAudioPlayers(...)</kbd> by passing the current integer index.</p>
<p>The <kbd>SetupVideoAudioPlayers(...)</kbd> method creates a new child GameObject for GameObject's video-object, and adds VideoPlayer and AudioSource components to that GameObject. It sets the Video Player clip property to the corresponding element in the public videoClips array variable. It also adds a reference to the new VideoPlayer component to the appropriate location in the videoPlayers array. It then sets the Video Player to output audio to the new AudioSource component, and to output its video to the renderTexture public variable.</p>
<p>The <kbd>Start()</kbd> method does the following:</p>
<ul>
<li>It invokes <kbd>SetupObjectArrays()</kbd></li>
<li>It sets the currentVideoIndex variable to 0 (for the first item in the arrays)</li>
<li>It registers <kbd>PlayNextVideo</kbd> method for the prepareCompleted event of the first videoPlayers object (currentVideoIndex = 0)</li>
<li>It invokes the <kbd>Prepare()</kbd> method for the videoPlayers object (currentVideoIndex = 0)</li>
<li>Finally, it logs a debug message stating that the item is preparing</li>
</ul>
<p>The <kbd>PlayNextVideo(...)</kbd> method does the following:</p>
<ul>
<li>It gets a reference to the Video Player element of the videoPlayers array that corresponds to the currentVideoIndex variable</li>
</ul>
<p>This method ignores the reference to the videoPlayer argument it receives – this parameter is required in the method declaration since it is the required signature to allow this method to register for the prepareCompleted and loopPointReached events.</p>
<ul>
<li>It sends a <kbd>Play()</kbd> message to the current Video Player</li>
<li>It then increments the value of currentVideoIndex, and tests whether there are any remaining video clips in the array</li>
<li>If there are remaining clips, then it gets a reference to the next clip, and sends it a <kbd>Prepare()</kbd> message; also the currently playing Video Player has its loopPointReached event registered for the PlayNextVideo method<br/> (If there are no videos left, then a simple debug log message is printed and the method ends)</li>
</ul>
<p>The clever bit is when the currently playing Video Player has its loopPointReached event registered for the PlayNextVideo method. The loopPointReached event occurs when a video clip has finished playing, and will start to look again (if its loop property is true). What we are doing with this script is say that when the current Video Player video clip has finished, the <kbd>PlayNextVideo(...)</kbd> method should be invoked again – once again using the value of currentVideoIndex to send a <kbd>Play()</kbd> message to the next Video Player, and then testing for any remaining Video Players, and so on until the end of the array has been reached.</p>
<p>This is a good example of conditions (if statements) being used with events, rather than coroutine while loops. As long as you're happy with how methods can be registered with C# events, then this approach allows our code to be less complex by avoiding loops and coroutine yield null statements.</p>
<p>In the following screenshot, we can see how our video-object GameObject, at runtime, ends up with videoPlayer_&amp;lt;n&amp;gt; child GameObjects – one for each element in the array. This allows one VideoPlayer to be playing while the next is preparing, and so on:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4a699930-958c-44a4-a501-da55667644ec.png" style="width:44.17em;height:17.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and using a simple Shader Graph</h1>
                
            
            
                
<p>The new Shader Graph feature in Unity 2018 is a powerful and exciting feature, opening up shader creation and editing to everyone, without any need for complex mathematics or coding skills. In this recipe, we'll create a simple Shader Graph to generate a checkerboard pattern, and create a Material that uses that shader, and apply it to a 3D cube. The end result will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e3659fae-9246-4166-b56f-ec293e82a3f3.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create and use a simple Shader Graph, follow these steps:</p>
<ol>
<li>First, we need to set up the Lightweight Rendering Pipeline. Use the Package Manager to import the Lightweight Rendering Pipeline package.</li>
<li>In the Project panel, create a new Lightweight Pipeline Asset file named myLightweightAsset. Choose menu: Create | Rendering | Lightweight Pipeline Asset.</li>
<li>In the Inspector, display the project's graphics settings by choosing menu: Edit | Project Settings | Graphics. Then, drag myLightweightAsset from the Project panel into the Scriptable Render Pipeline Settings property:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/29679a07-63e1-4157-8965-841f8d891138.png" style="width:38.00em;height:8.33em;"/></p>
<ol start="4">
<li>Use the Package Manager to import the Shader Graph package.</li>
<li>In the Project panel, create a new Physically-Based Rendering (PBR) Shader Graph, named myShaderGraph. Choose menu: Create | Shader | PBR Graph.</li>
<li>In the Project panel, create a new Material named m_cube. Choose menu: Create | Material.</li>
<li>With the m_cube selected, in the Inspector, set its Shader property to myShaderGraph. For the Material's Shader property, choose menu: graphs | myShaderGraph:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/016a978c-ae54-4e8f-ac9b-294a86f8b7a9.png" style="width:20.42em;height:9.08em;"/></p>
<ol start="8">
<li>Add a 3D cube to the scene (menu: GameObject | 3D Object | Cube). Set the Material for this 3D Cube to m_Cube.</li>
</ol>
<ol start="9">
<li>In the Project panel, double click myShaderGraph to open the Shader Graph editing panel. A new PRB Shader Graph will open with three components: (1) the BlackBoard (for publically exposing parameters); (2) the Master PRB node; (3) the output previewer node:</li>
</ol>
<p>It is easiest, when editing a Shader Graph, to maximize the Shader Graph panel.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f836663f-0dfa-4550-b7e5-d8e519d5972e.png" style="width:37.58em;height:12.67em;"/></p>
<ol start="10">
<li>Right-click the output previewer, and select Cube:</li>
</ol>
<p>You can zoom and rotate the preview mesh. You can also choose a custom mesh from within your project, allowing a preview of the Shader Graph on the intended destination's 3D object.</p>
<div><img src="img/a07de4f3-176a-4c94-a72a-552cccc7a5e4.png"/></div>
<ol start="11">
<li>Let's flood the shader with a red color. Choose red from the color picker for the top property of the PRB Master node Albedo.</li>
<li>Create a new graph node by right-clicking the mouse and choosing menu: Create Node | Procedural | Checkerboard. You'll see the checkerboard patter in the preview for this node. Set the X property to 2, and the Y property to 3.</li>
<li>Now, drag a link from the checkerboard note output Out(3), to the Emission (3) input for the PRB Master node. You should now see a red/pink checkerboard patter in the PBR Master node preview, and you'll also see the following output applied to the Cube mesh in the output previewer node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a3af4a4-8c12-4c7d-ab3c-0d772d2968dd.png"/></p>
<ol start="14">
<li>You must save the changes to your Shader Graph before you can see them applied to the scene. Click the Save Asset button on the top-left of the Shader Graph panel.</li>
<li>Save and run your scene. You should see a red/pink checkerboard 3D cube being displayed.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You enabled the Lightweight Rending Pipeline by installing the package, creating an asset, and choosing that asset for the Project's Scriptable Rending Pipeline Graphics property.</p>
<p>You then created a new Shader Graph asset file, and a new Material that uses your shader.</p>
<p>Your Shader Graph feeds a procedurally generated checkerboard into the Emission property of the PBR Master output node, and also tints the output by choosing a red Color value for the Albedo property. You saved the changes to your Shader Graph asset so that they will be available when the scene runs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a glow effect with Shader Graph</h1>
                
            
            
                
<p>In the previous recipe, a simple Shader Graph was created by using a Material for a primitive 3D Cube mesh. In this recipe, we'll take things further, creating a Shader Graph that applies a parameterized glow effect to a 3D object. The end result will look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c62fbcaf-c6c6-447a-814c-575c4dbab0d6.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds on the previous one, so make a copy of that project and use the copy for this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a glow effect with a Shader Graph, follow these steps:</p>
<ol>
<li>In the Project panel, create a new Physically-Based Rendering (PBR) Shader Graph, named glowShaderGraph. Choose menu: Create | Shader | PBR Graph.</li>
<li>In the Project panel, create a new Material named <kbd>m_glow</kbd>. Choose menu: Create | Material.</li>
<li>3. With the m_glow selected, in the Inspector, set its Shader property to glowShaderGraph. For the Material's Shader property, choose menu: graphs | glowShaderGraph.</li>
</ol>
<ol start="4">
<li>We now need a 3D mesh object in the scene that uses <kbd>m_glow</kbd>. While we could just use a 3D Cube again, it's more fun to add a low-polygon textured character to the scene. For this recipe, we've used the free Unity Asset Store character pack Fantasy Mushroom Mon(ster) from AmusedArt. Once the package has been added, drag the Mushroom Monster Prefab into the scene from Project panel folder: amusedART | Mushroom Monster | Prefab:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b9aa2515-d5dc-4aec-8a50-c8df9d2206d8.png" style="width:37.08em;height:9.50em;"/></p>
<ol start="5">
<li>In the Project panel, double click glowShaderGraph to open the Shader Graph editing panel.</li>
<li>Right-click the output previewer, select Custom Mesh, and choose MushroomMon from the selection dialog.</li>
<li>Add a new <strong>Texture</strong> exposed property to your <strong>Shader Graph</strong> by creating a new property texture in the <strong>Shader Graph</strong> Blackboard. Click the plus + button and choose property type Texture.</li>
<li>In the Blackboard, change the Default value of the property Texture from None to Mushroom Green.</li>
<li>To use a publically exposed Blackboard property in our <strong>Shader Graph</strong>, we need to drag a reference to the property from the Blackboard into the Graph area. Drag the Blackboard property Texture into the Graph area. You should see a new node with the title Property, and value Texture (T):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ac0e71ae-d4d4-4c3a-89e8-73b48b600156.png" style="width:22.83em;height:7.33em;"/></p>
<ol start="10">
<li>There is no <strong>Texture</strong> input to the Master PDB Node, so we need to add a converter node that can take (sample) data from a <strong>2D Texture</strong> image, and turn it into RBG values that can be sent to the Albedo input of the <strong>PBR Master Node</strong>. Create a new Sample Texture 2D node in your <strong>Shader Graph</strong> by right-clicking the mouse, then choose menu: Create Node | Input | Texture | Sample Texture 2D.</li>
<li>Now, let's send the <strong>Texture</strong> Mushroom Green into the Master PRB Node via the Sample Texture 2D converter node. Link the Texture (T) output from the Property node to the Texture (T) input of the Sample Texture 2D node. You should now see the Mushroom Green Texture image appear in the 2D rectangular preview at the bottom of the Sample Texture 2D node.</li>
<li>Next, link the RGBA (4) output of the Sample Texture 2D node to the Albedo (3) input of the Master PRB node (Unity will intelligently just ignore the 4th Alpha (A) values). You should now see the Mushroom Green Texture image appear in the preview at the bottom of the Master PRB node. You should also see the Mushroom Green Texture being applied to the 3D Mushroom Monster Mesh in the <strong>Shader Graph</strong> output previewer node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/135b7f81-4e15-4b0e-a312-6c7fd035e885.png"/></p>
<ol start="13">
<li>One way to create a glow effect is by applying a Fresnel Effect. Create a new Fresnel Effect node in our <strong>Shader Graph</strong>. Link the Out (3) output from the Fresnel Effect node to the Emission (3) input of the<strong> </strong><strong>PRB Master</strong> node. You should now see a brighter glow outline effect in the <strong>Shader Graph</strong> output previewer node.</li>
</ol>
<p>Augustin-Jean Fresnel (1788-1827) studied and documented how an object's reflection depends on the viewing angle – for example, looking straight down into still water, there is little sunlight reflected and we can see into the water clearly. But if our eyes are closer to the level of the water (for example, if we are swimming), then much more light is reflected by the water. Simulating this effect in a digital shader is a way to make the edges of an object lighter, since light is glancing off the edges of the object and reflected to our game camera.</p>
<ol start="14">
<li>Let's tint our Fresnel Effect by combining it with a publicly exposed Color property, which can be set by game designers either in the Inspector or through C# code.</li>
<li>First, delete the link from the Out (3) output from the Fresnel Effect node to the Emission (3) input of the PBR Master node.</li>
<li>Add a new Color exposed property to your <strong>Shader Graph</strong> by creating a new property Color in the <strong>Shader Graph</strong> Blackboard. Click the plus + button and choose the Color property type.</li>
<li>In the Blackboard, set the Default value of the Color property to red (using the Color picker).</li>
<li>Drag the Blackboard's Color property into the Graph area. You should see a new node with the title Property and a value of  <strong>Color(4)</strong>.</li>
<li>Create a new <strong>Multiply</strong> node in your <strong>Shader Graph</strong> by right-clicking the mouse and then choosing menu: Create Node | Math | Basic | Multiply.</li>
</ol>
<p>The mathematical Multiply node is an easy way to combine values from two nodes, which are then to be passed to a single input of a third node.</p>
<ol start="20">
<li>Let's combine the Color and Fresnel Effect by making both inputs to the Multiply node. Link the Color (4) output from the Property (Color) node to the A (4) input of the Multiply node. Next, link the Out (3) output from the Fresnel Effect node to the B (4) input of the Multiply node. Finally, link the Out (3) output from the Fresnel Effect node to the Emission (3) input of the PRB Master node. You should now see a red tinted glow outline effect in the <strong>Shader Graph</strong> output previewer node: The overview screenshot below shows these node connections completed for our Shader Graph</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/aec5981c-5feb-4025-a7a2-c4c7bdabd1c3.png"/></p>
<ol start="21">
<li>Save your updated <strong>Shader Graph</strong> by clicking the Save Asset button at the top-right of the <strong>Shader Graph</strong> panel.</li>
<li>Save and run your Scene. You should see a red glow around the character.</li>
<li>In the Project panel, locate the <strong>Material</strong> that your 3D GameObject uses (for the Green Mushroom Monster, it is folder: Project | amusedART | Mushroom_Monster | Materials | MusroomMonGreen). The publicly exposed properties of the <strong>Shader Graph</strong> Blackboard should appear in the <strong>Inspector</strong> as customizable properties. Change the Color property to blue. Run the scene again. The glow effect around the 3D GameObject should now be blue:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6a7a69b0-5269-4459-becb-ca27edd6f3a2.png" style="width:39.25em;height:10.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a new <strong>Shader Graph</strong>, which has several connected nodes. The output(s) of one node become the input(s) of another node.</p>
<p>You created publicly exposed properties for Color and Texture using the <strong>Shader Graph</strong> Blackboard, and introduced those properties as inputs in your Graph.</p>
<p>You used a Sample Texture 2D node to convert the <strong>2D Texture</strong> image into RBG values suitable for the <strong>Albedo</strong> input for the <strong>PBR Master</strong> node.</p>
<p>You created a Fresnel Effect node, and combined this, via a Multiply node, with the publicly exposed Color property, sending the output into the Emission input of the PRB Master node.</p>
<p>You then learned how to change the publicly exposed property for Color in the Inspector via the Material's properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Toggling a Shader Graph color glow effect through C# code</h1>
                
            
            
                
<p>Effects such as the glow effect from the previous recipe are often features we wish to toggle on and off under different circumstances. The effect could be turned on or off during a game to visually communicate the status of a GameObject—for example, an <em>angry</em> character might glow red, while a <em>happy</em> monster might glow green, and so on.</p>
<p>We'll add to the previous recipe to create a new publicly exposed <strong>Shader Graph</strong> Blackboard property named Power, and write code that can be used to set this value to zero or five in order to turn the glow effect on and off. We'll also access the Color property so that we're able to set what color the glow effect displays.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds on the previous one, so make a copy of that project and use the copy for this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To toggle the glow effect from the Shader Graph, follow these steps:</p>
<ol>
<li>First, delete the link from the Out (3) output from the Multiply node to the Emission (3) input of the PBR Master node. We are doing this because the output of this Multiply node will become an input for a second Multiple node that we are about to create.</li>
<li>Create a new Multiply node in your <strong>Shader Graph</strong> by right-clicking the mouse and then choosing menu: Create Node | Math | Basic | Multiply.</li>
<li>Link the Out (4) output from the original Multiply node to the A (4) input of your new Multiply node. Also, link the Out (3) output from the new Multiply node to the Emission (3) input of the PBR Master node.</li>
<li>Add a new <kbd>float</kbd> (decimal number), exposed to the Power property, to your <strong>Shader Graph</strong> by creating a new property in the <strong>Shader Graph</strong> Blackboard. Click the plus + button and choose property type <kbd>Vector 1</kbd>, and rename this <kbd>Power</kbd>.</li>
<li>In the Blackboard, set the Default value of the Power property to <kbd>5</kbd>. Also, set the display Mode to Slider with the values of Min 0 and Max 5.</li>
<li>Drag the Blackboard Power property into the Graph area. You should see a new node with the title Property, and a value of Power(1).</li>
<li>Finally, link the Power(1) output from Property node (Power) to the B (4) input of the new Multiply node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/05d4056a-9c21-44ab-99cb-16c4d235c537.png"/></p>
<ol start="8">
<li>Save your updated <strong>Shader Graph</strong> by clicking the Save Asset button at the top-right of the <strong>Shader Graph</strong> panel.</li>
<li>Create a new C# script class named <kbd>GlowManager</kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/> <br/>     public class GlowManager : MonoBehaviour {<br/>         private string powerId = "Vector1_AA07C639";<br/>         private string colorId = "Color_466BE55E";<br/> <br/>         void Update () {<br/>             if (Input.GetKeyDown("0"))<br/>                 GetComponent&amp;lt;Renderer&amp;gt;().material.SetFloat(powerId, 0);<br/> <br/>             if (Input.GetKeyDown("1"))<br/>                 SetGlowColor(Color.red);<br/> <br/>             if (Input.GetKeyDown("2"))<br/>                 SetGlowColor(Color.blue);<br/>         }<br/> <br/>         private void SetGlowColor(Color c) {<br/>             GetComponent&amp;lt;Renderer&amp;gt;().material.SetFloat(powerId, 5);<br/>             GetComponent&amp;lt;Renderer&amp;gt;().material.SetColor(colorId, c);<br/>         }<br/>     } </pre>
<ol start="10">
<li>Select <strong>Shader Graph</strong> glowShaderGraph in the Project panel, and view its properties in the Inspector:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/513e2e16-bfd0-4367-8b45-7d0a1294baa9.png" style="width:34.83em;height:10.33em;"/></p>
<ol start="11">
<li>Find the internal IDs of the publicly exposed properties Power and Color – they will be something like Vector1_AA07C639 and Color_466BE55E. Copy these IDs into C# script statements by setting the ID strings:</li>
</ol>
<pre>    private string powerId = "Vector1_AA07C639";<br/>    private string colorId = "Color_466BE55E"; </pre>
<p>At the time of writing this book, the current version of <strong>Shader Graph</strong> doesn't provide a convenient way to access exposed properties using the names chosen in the Shader Graph Blackboard, hence the need to look up the internal ID needed for the <kbd>material.SetFloat(powerId, power)</kbd> statement when changing the value. It is likely that Unity will soon update the <strong>Shader Graph</strong> scripting API to make this action more straightforward.</p>
<ol start="12">
<li>In the Hierarchy, locate the component of your 3D GameObject that contains the Mesh Renderer component (for our Mushroom Monster example, this is the Mushroom Mon child of the Mushroom Monster GameObject). Add an instance object of the <kbd>GlowManager</kbd> script class as a component to this <strong>GameObject</strong>.</li>
<li>Save and run your Scene. Pressing the <em>1</em> key should turn on the red glow effect, pressing the <em>2</em> key should turn on the blue glow effect, and pressing the <em>0</em> key should turn off the glow effect.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a new Power exposed property for your <strong>Shader Graph</strong> that combined with the Fresnel color effect so that a value of zero will turn off the effect. You looked up the internal IDs of the Power and Color exposed properties, and updated the C# script so that it can update these properties.</p>
<p>The scriptclass checks for the 0/1/2 keys, and correspondingly turns the effect off/to a red glow/to a blue glow.</p>
<p>By combining publicly exposed properties with code, you are able to change <strong>Shader Graph</strong> values at runtime through events detected by code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to take your <strong>Shader Graph</strong> features even further.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Sine Time to create a pulsating glow effect</h1>
                
            
            
                
<p>You could make the glow effect <em>pulse</em> by creating a Time node, and linking the Sine Time (1) output to the Fresnel Effect input Power (1). As the Sine Time value changes between - 1/0/+1, it will influence how strong the Fresnel Effect is, changing the brightness of the glow effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Compile and Show Code button as another way to find exposed property IDs</h1>
                
            
            
                
<p>When you are viewing the properties of a <strong>Shader Graph</strong> asset in the <strong>Inspector</strong>, you'll see a button entitled Compile and Show Code. If you click this, you'll then see a generated ShaderLab code file in your script editor.</p>
<p>It isn't the actual code used by Unity, but it provides a good idea of the code that is generated from your <strong>Shader Graph</strong>. The internal IDs for your publicly exposed Blackboard properties are listed in the Properties section, which is at the beginning of the generated code:</p>
<pre>Shader "graphs/glowShaderGraph" {<br/>    Properties { 

     [NoScaleOffset]  Texture_C5AA766B ("Texture", 2D) = "white" { }<br/>      Vector1_AA07C639 ("Power", Range(0.000,5.000)) = 5.000 

     Color_466BE55E ("Color", Color) = (1.000,0.000,0.038368,0.000)<br/>    } 

   etc. </pre>


            

            
        
    </body></html>