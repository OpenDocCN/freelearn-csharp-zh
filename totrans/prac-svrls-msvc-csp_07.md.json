["```cs\n    docker run -e \"ACCEPT_EULA=Y\" -e \"MSSQL_SA_PASSWORD=yourStrong(!)Password\" -p 1433:1433 -d mcr.microsoft.com/mssql/server:2022-latest \n    ```", "```cs\nRoutesPlanning Program.cs file:\n```", "```cs\nbuilder.Services.AddOpenApi();\n//Code snippet start\nbuilder.Services.AddApplicationServices();\nbuilder.Services.AddDbDriver(\n    builder.Configuration?.GetConnectionString(\"DefaultConnection\") ?? string.Empty);\n//Code snippet end \n```", "```cs\ndocker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management \n```", "```cs\ndocker stop rabbitmq \n```", "```cs\nVOLUME /var/lib/rabbitmq \n```", "```cs\n-e RABBITMQ_DEFAULT_USER=my_user_name -e RABBITMQ_DEFAULT_PASS=my_password \n```", "```cs\npublic class GeoLocalizationMessage\n{\n    public double Latitude { get; set; }\n    public double Longitude { get; set; }\n}\npublic class TimeIntervalMessage\n{\n    public DateTime Start {  get; set; }\n    public DateTime End { get; set; }\n}\npublic class UserBasicInfoMessage\n{\n    public Guid Id { get; set; }\n    public string? DisplayName { get; set; }\n}\npublic class TownBasicInfoMessage\n{\n    public Guid Id { get; set; }\n    public string? Name { get; set; }\n    public GeoLocalizationMessage? Location { get; set; }\n} \n```", "```cs\npublic class TimedMessage\n{\n    public long TimeStamp { get; set; }\n} \n```", "```cs\n    public class RouteRequestMessage: TimedMessage\n    {\n        public Guid Id { get; set; }\n        public TownBasicInfoMessage? Source { get; set; }\n        public TownBasicInfoMessage? Destination { get; set; }\n        public TimeIntervalMessage? When { get; set; }\n        public UserBasicInfoMessage? User { get; set; }\n    } \n    ```", "```cs\n    public class RouteOfferMessage: TimedMessage\n    {\n        public Guid Id { get; set; }\n        public IList<TownBasicInfoMessage>? Path { get; set; }\n        public DateTime? When { get; set; }\n        public UserBasicInfoMessage? User { get; set; }\n    } \n    ```", "```cs\n    public class RouteClosedAbortedMessage: TimedMessage\n    {\n        public Guid RouteId { get; set; }\n        public bool IsAborted { get; set; }\n    } \n    ```", "```cs\n    public class RouteExtendedMessage: TimedMessage\n    {\n        public RouteOfferMessage? ExtendedRoute {  get; set; }\n        public IList<RouteRequestMessage>? AddedRequests { get; set; }\n        public bool Closed { get; set; }\n    } \n    ```", "```cs\npublic class RouteExtensionProposalsMessage: TimedMessage\n{\n    public Guid RouteId { get; set; }\n    public IList<RouteRequestMessage>? Proposals { get; set; }\n} \n```", "```cs\nbuilder.Configuration.AddEnvironmentVariables(prefix: \"MyCustomPrefix_\"); \n```", "```cs\n\"Container (Dockerfile)\": {\n\"commandName\": \"Docker\",\n\"launchUrl\": \"{Scheme}://{ServiceHost}:{ServicePort}\",\n\"environmentVariables\": {\n\"ASPNETCORE_HTTP_PORTS\": \"8080\"\n//place here your application specific environment variables\n}, \n```", "```cs\n\"environmentVariables\": {\n\"ASPNETCORE_HTTP_PORTS\": \"8080\",\n//place here your environment variables\n\"ConnectionStrings__DefaultConnection\": \"\",\n\"ConnectionStrings__RabbitMQConnection\":\n\"host=localhost:5672;username=guest;password=guest;publisherConfirms=true;\ntimeout=10\",\n\"Messages__SubscriptionIdPrefix\": \"routesPlanning\",\n\"Topology__MaxDistanceKm\": \"50\",\n\"Topology__MaxMatches\": \"5\"\n}, \n```", "```cs\nbuilder.Services.AddHostedService<MyHostedService>(); \n```", "```cs\npublic class MainService() : BackgroundService\n{\n    protected override Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        throw new NotImplementedException();\n    }\n} \n```", "```cs\npublic class MainService(IConfiguration configuration, IServiceProvider services) : BackgroundService \n```", "```cs\nbuilder.Services.AddHostedService<MainService>(); \n```", "```cs\npublic class MessageCommand<T>(T message): ICommand\n{\n    public T Message => message;\n} \n```", "```cs\nprotected async Task ProcessMessage<T>(T message)\n{\n    using (var scope = services.CreateScope()) \n    {\n    var handler=scope.ServiceProvider.GetRequiredService<ICommandHandler<\n                                                    MessageCommand<T>>>();\n        await handler.HandleAsync(new MessageCommand<T>(message));\n    }\n} \n```", "```cs\nprivate readonly Lock _countErrorsLock = new();\nprivate static int _errorCount = 0;\npublic static int ErrorsCount => _errorCount;\nprivate void DeclareSuccessFailure(bool isFailure=false)\n{\n    using (_countErrorsLock.EnterScope())\n    {\n        if (isFailure) _errorCount++;\n        else _errorCount = 0;\n    }\n} \n```", "```cs\nprotected async Task SafeProcessMessage<T>(T message)\n{\n    try\n    {\n        await ProcessMessage(message);\n        DeclareSuccessFailure();\n    }\n    catch \n    {\n        DeclareSuccessFailure(true);\n        throw;\n    }\n} \n```", "```cs\nstring SubscriptionId<T>()\n{\n    return string.Format(\"{0}_{1}\",\n        configuration[\"Messages__SubscriptionIdPrefix\"],\n        typeof(T).Name);\n} \n```", "```cs\nbuilder.Services.AddEasyNetQ(\n    builder.Configuration?.GetConnectionString(\n\"RabbitMQConnection\")??string.Empty)\n    .UseAlwaysNackWithRequeueConsumerErrorStrategy();; \n```", "```cs\npublic class MainService(IConfiguration configuration, IBus bus,  \nIServiceProvider services): BackgroundService \n```", "```cs\nTask PublishAsync(T message, CancelationToken cancel = default)\nTask PublishAsync(T message, string topic, \n    CancelationToken cancel = default)\nTask PublishAsync(T message, Action<IPublishConfiguration > configuration, \n    CancelationToken cancel = default) \n```", "```cs\nSubscriptionResult Subscribe<T>(string subscriptionId,  \nFunc<T, Task> messageHandler, CancelationToken cancel = default)\nSubscriptionResult Subscribe<T>(string subscriptionId,  \nFunc<T, CancelationToken , Task> messageHandler, \nAction<IsubscriptionConfiguration> configuration, \n    CancelationToken cancel = default) \n```", "```cs\nprotected override async Task ExecuteAsync(CancellationToken stoppingToken)\n{\n    var routeOfferSubscription = await bus.PubSub.\n        SubscribeAsync<RouteOfferMessage>(\n        SubscriptionId<RouteOfferMessage>(),SafeProcessMessage, \n        stoppingToken);\n    var routeClosedAbortedSubscription = await bus.PubSub.SubscribeAsync<\n        RouteClosedAbortedMessage>(\n        SubscriptionId<RouteClosedAbortedMessage>(), SafeProcessMessage, \n            stoppingToken);\n    var routeExtendedSubscription = \n    await bus.PubSub.SubscribeAsync<RouteExtendedMessage>(\n        SubscriptionId<RouteExtendedMessage>(), SafeProcessMessage, \n           stoppingToken);\n    var routeRequestSubscription = await bus.PubSub.\n        SubscribeAsync<RouteRequestMessage>(\n        SubscriptionId<RouteRequestMessage>(), SafeProcessMessage, \n           stoppingToken);\n\n    stoppingToken.WaitHandle.WaitOne();\n    routeRequestSubscription.Dispose();\n    routeExtendedSubscription.Dispose();\n    routeClosedAbortedSubscription.Dispose();\n    routeOfferSubscription.Dispose();\n} \n```", "```cs\nTask<TResponse> bus.Rpc.RequestAsync<TRequest, TResponse>(\nTRequest request, CancelationToken cancel = default)\nTask<TResponse> bus.Rpc.RequestAsync<TRequest, TResponse>(\nTRequest request,  Action<IRequestConfiguration> configuration, \nCancelationToken cancel = default) \n```", "```cs\nTask<IDisposable> bus.Rpc.RequestAsync<TRequest, TResponse>(\n    Func<TRequest, Task< TResponse >> handler, \n    CancelationToken cancel = default);\nTask<IDisposable> bus.Rpc.RequestAsync<TRequest, TResponse>(\n    Func<TRequest, Task< TResponse >> handler, \n    Action<IResponderConfiguration> configuration,\n    CancelationToken cancel = default); \n```", "```cs\npublic class HouseKeepingService(IConfiguration configuration, IBus bus, \n    IServiceProvider services): BackgroundService\n{\n    protected override Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        throw new NotImplementedException();\n    }\n} \n```", "```cs\nbuilder.Services.AddHostedService<HouseKeepingService>(); \n```", "```cs\npublic record HouseKeepingCommand(int DeleteDelay): ICommand; \n```", "```cs\n\"Topology__MaxDistanceKm\": \"50\",\n//new environment variables\n\"Timing__HousekeepingIntervalHours\": \"4\",\n\"Timing__HousekeepingDelayDays\": \"10\" \n```", "```cs\nprotected override async Task ExecuteAsync(CancellationToken stoppingToken)\n{\n    //update interval in milliseconds\n    int updateInterval = configuration.GetValue<int>(\n        \"Timing:HousekeepingIntervalHours\")*3600000;\n    int deleteDelayDays = configuration.GetValue<int>(\n        \"Timing:HousekeepingDelayDays\");\n    while (!stoppingToken.IsCancellationRequested)\n    {\n        try\n        {\n            using (var scope = services.CreateScope())\n            {\n                var handler = scope.ServiceProvider\n                    .GetRequiredService<\n                        ICommandHandler<HouseKeepingCommand>>();\n                await handler.HandleAsync(new HouseKeepingCommand(\n                    deleteDelayDays));\n            }\n        }\n        catch { \n          // actual production application should log the error\n        }\n        await Task.Delay(updateInterval, stoppingToken);\n    }\n} \n```", "```cs\npublic class OutputSendingService(IConfiguration configuration, IBus bus,\n    IServiceProvider services) : BackgroundService\n{\n    protected override Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        throw new NotImplementedException();\n    }\n} \n```", "```cs\nbuilder.Services.AddHostedService<OutputSendingService>(); \n```", "```cs\npublic class OutputSendingCommand<T>(Func<T, Task> sender, \nint batchCount, TimeSpan requeueDelay): ICommand\n{\n    public Func<T, Task> Sender => sender;\n    public int BatchCount => batchCount;\n    public TimeSpan RequeueDelay => requeueDelay;\n    public bool OutPutEmpty { get; set; } = false;\n} \n```", "```cs\n\"Timing__OutputEmptyDelayMS\": \"500\" \n```", "```cs\n\"Timing__OutputBatchCount\": \"10\",\n\"Timing__OutputRequeueDelayMin\": \"5\" \n```", "```cs\nprotected Task<bool> SafeInvokeCommand()\n{\n    throw new NotImplementedException();\n} \n```", "```cs\nreadonly int updateBatchCount =\n        configuration.GetValue<int>(\"Timing:OutputBatchCount\");\nreadonly TimeSpan requeueDelay = TimeSpan.FromMinutes(\n        configuration.GetValue<int>(\"Timing:OutputRequeueDelayMin\"));\nprotected override async Task ExecuteAsync(CancellationToken stoppingToken)\n{\n    //update interval in milliseconds\n    int updateInterval =\n        configuration.GetValue<int>(\"Timing:HousekeepingIntervalHours\") ;\n    bool queueEmpty = false;\n    while (!stoppingToken.IsCancellationRequested)\n    {\n        while (!queueEmpty && !stoppingToken.IsCancellationRequested)\n        {\n            queueEmpty=await SafeInvokeCommand();\n        }\n        await Task.Delay(updateInterval, stoppingToken);\n        queueEmpty = false;\n    }\n} \n```", "```cs\nprotected  Task SendMessage(RouteExtensionProposalsMessage message)\n{\n    return bus.PubSub.PublishAsync<\n        RouteExtensionProposalsMessage>(message);\n} \n```", "```cs\nprotected async Task<bool> InvokeCommand()\n{\n    using (var scope = services.CreateScope())\n    {\n        var handler = scope.ServiceProvider.GetRequiredService<\n            ICommandHandler<OutputSendingCommand<\n                RouteExtensionProposalsMessage>>>();\n        var command = new OutputSendingCommand<\n            RouteExtensionProposalsMessage>(\n                SendMessage,updateBatchCount, requeueDelay);\n        await handler.HandleAsync(command);\n        return command.OutPutEmpty;\n    }\n}\nprotected async Task<bool> SafeInvokeCommand()\n{\n    try\n    {\n        return await InvokeCommand();\n    }\n    catch\n    {\n        return true;\n    };\n} \n```", "```cs\nvar myPolicy = Policy\n  .Handle<HttpRequestException>()\n  .Or<OperationCanceledException>()\n  .RetryAsync(3);\n....\n....\nawait myPolicy.ExecuteAsync(()=>{\n//your code here\n}); \n```", "```cs\nvar retryPolicy= Policy\n...\n//Exceptions to handle here\n.WaitAndRetryAsync(6,retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))); \n```", "```cs\nvar breakerPolicy =Policy\n.Handle<SomeExceptionType>()\n.CircuitBreakerAsync (6, TimeSpan.FromMinutes(1)); \n```", "```cs\nPolicy\n.BulkheadAsync(10, 15) \n```", "```cs\nvar combinedPolicy = Policy\n.WrapAsync(retryPolicy, breakerPolicy); \n```", "```cs\nprotected  Task SendMessage(RouteExtensionProposalsMessage message)\n{\n    var retryPolicy = Policy\n            .Handle<Exception>()\n            .WaitAndRetryAsync(4,\n               retryAttempt => TimeSpan.FromSeconds(Math.Pow(1,\n                retryAttempt)));\n    var circuitBreakerPolicy = Policy\n        .Handle<Exception>()\n        .CircuitBreakerAsync(4, circuitBreakDelay);\n    var combinedPolicy = Policy\n        .WrapAsync(retryPolicy, circuitBreakerPolicy);\n    return combinedPolicy.ExecuteAsync(\n        async () => await bus.PubSub.PublishAsync<\nRouteExtensionProposalsMessage>(message));\n\n} \n```", "```cs\n\"Timing:OutputCircuitBreakMin\": \"4\" \n```", "```cs\nreadonly TimeSpan circuitBreakDelay = TimeSpan.FromMinutes(\n        configuration.GetValue<int>(\"Timing:OutputCircuitBreakMin\")); \n```", "```cs\nnamespace RoutesPlanningDomainLayer\n{\n    public static class GeometryConstants\n    {\n        public static int DefaultSRID => 4326;\n    }\n} \n```", "```cs\n    public enum RouteStatus { Open=0, Closed=1, Aborted=2 }; \n    ```", "```cs\n    public record TimeInterval\n    {\n        public DateTime Start { get; init; }\n        public DateTime End { get; init; }   \n    } \n    ```", "```cs\n    public record TownBasicInfo\n    {\n        public Guid Id { get; init; }\n        public string Name { get; init; } = null!;\n        public Point Location { get; init; } = null!;\n    } \n    ```", "```cs\n    public record UserBasicInfo()\n    {\n        public Guid Id { get; init; }\n        public string DisplayName { get; init; } = null!;\n    } \n    ```", "```cs\npublic interface IRouteRequestState\n{\n    Guid Id { get; }\n    TownBasicInfo Source { get; }\n    TownBasicInfo Destination { get;  }\n    DateTime WhenStart { get; }\n    DateTime WhenEnd { get; }\n    UserBasicInfo User { get; }\n    Guid? RouteId { get; set; }\n    public long TimeStamp { get; set; }\n} \n```", "```cs\npublic class RouteRequestAggregate(IRouteRequestState state): \n    Entity<Guid>\n{\n    public override Guid Id => state.Id;\n    public TownBasicInfo Source => state.Source;\n    public TownBasicInfo Destination => state.Destination;\n    TimeInterval _When = null!;\n    public TimeInterval When => _When ?? \n        (_When=new TimeInterval {Start = state.WhenStart, End = state.\n                                 WhenEnd });    \n    public UserBasicInfo User => state.User;\n    public bool Open => state.RouteId == null; \n    public long TimeStamp => state.TimeStamp;\n    public void DetachFromRoute() => state.RouteId = null;\n    public void AttachToRoute(Guid routeId) => state.RouteId = routeId;\n} \n```", "```cs\npublic interface IRouteRequestRepository : IRepository\n{\n    RouteRequestAggregate New(\n        Guid id,\n        TownBasicInfo source, \n        TownBasicInfo destination,\n        TimeInterval when,\n        UserBasicInfo user\n        );\n    Task<RouteRequestAggregate?> Get(Guid id);\n    Task<IList<RouteRequestAggregate>> Get(Guid[] ids);\n    Task<IList<RouteRequestAggregate>> GetInRoute(Guid routeId);\n    Task<IList<RouteRequestAggregate>> GetMatch(IEnumerable<Coordinate> \n        geometry, \n       DateTime when, double distance, int maxResults);\n    Task DeleteBefore(DateTime milestone);\n} \n```", "```cs\npublic interface IRouteOfferState\n{\n    Guid Id { get; }\n    LineString Path { get; set; }\n    DateTime When { get; }\n    UserBasicInfo User { get; }\n    RouteStatus Status { get; set; }\n    public long TimeStamp { get; set; }\n} \n```", "```cs\npublic class RouteOfferAggregate\n    (IRouteOfferState state): Entity<Guid>\n{\n    public override Guid Id => state.Id;\n    IReadOnlyList<Coordinate>? _Path=null;\n    public IReadOnlyList<Coordinate> Path => _Path != null ? _Path : (\n        _Path = state.Path.Coordinates.ToImmutableList());\n    public DateTime When => state.When;\n    public UserBasicInfo User => state.User;\n    public RouteStatus Status => state.Status;\n    public long TimeStamp => state.TimeStamp;\n    …\n    …\n} \n```", "```cs\npublic void Extend(long timestamp, \nIEnumerable<Guid> addedRequests, \nCoordinate[] newRoute, bool closed)\n{\n    if (timestamp > TimeStamp)\n    {\n        state.Path = new LineString(newRoute)\n            { SRID = GeometryConstants.DefaultSRID };\n        _Path = null;\n        state.TimeStamp = timestamp;\n    }\n    if(state.Status != RouteStatus.Aborted)\n        AddDomainEvent(new AttachedRequestEvent { \n            AddedRequests = addedRequests,\n            RouteOffer = Id\n        });\n    Close();\n} \n```", "```cs\npublic class AttachedRequestEvent : IEventNotification\n{\n    public IEnumerable<Guid> AddedRequests { get; set; } = new List<Guid>();\n    public Guid RouteOffer { get; set; } \n} \n```", "```cs\npublic void Close()\n{\n    state.Status = RouteStatus.Closed;\n} \n```", "```cs\npublic void Abort()\n{\n    state.Status = RouteStatus.Aborted;\n    AddDomainEvent(new ReleasedRequestsEvent\n    {\n        AbortedRoute = Id\n    });\n} \n```", "```cs\npublic class ReleasedRequestsEvent:IEventNotification\n{\n    public Guid AbortedRoute {  get; set; }\n} \n```", "```cs\npublic interface IRouteOfferRepository : IRepository\n{\n    RouteOfferAggregate New(Guid id, Coordinate[] path, UserBasicInfo \n        user, DateTime When);\n    Task<RouteOfferAggregate?> Get(Guid id);\n    Task<IList<RouteOfferAggregate>> GetMatch(\n        Point source, Point destination, TimeInterval when, \n        double distance, int maxResults);\n    Task DeleteBefore(DateTime milestone);\n} \n```", "```cs\npublic  interface IQueueItemState\n{\n    Guid Id { get; }\n    int MessageCode { get; }\n    public string MessageContent { get; }\n} \n```", "```cs\npublic class QueueItem(IQueueItemState state): Entity<Guid>\n{\n    public override Guid Id => state.Id;\n    public int MessageCode => state.MessageCode;\n    public T? GetMessage<T>() \n    {\n        if (string.IsNullOrWhiteSpace(state.MessageContent)) \n        return default;\n        return JsonSerializer.Deserialize<T>(state.MessageContent);\n    }\n} \n```", "```cs\npublic interface IOutputQueueRepository: IRepository\n{\n    Task<IList<QueueItem>> Take(int N, TimeSpan requeueAfter);\n    void Confirm(Guid[] ids);\n    QueueItem New<T>(T item, int messageCode);\n} \n```", "```cs\noptions.UseSqlServer(connectionString, \n    b => {\n        b.MigrationsAssembly(\"DBDriver\");\n       // added code\n        b.UseNetTopologySuite();\n     })); \n```", "```cs\n    internal class RouteOffer: IRouteOfferState\n    {\n        public Guid Id { get; set; }\n        public LineString Path { get; set; } = null!;\n        public DateTime When { get; set; }\n        public UserBasicInfo User { get; set; } = null!;\n        public RouteStatus Status { get; set; }\n        public ICollection<RouteRequest> Requests { get; set; } = null!;\n        public long TimeStamp { get; set; }\n    } \n    ```", "```cs\n    internal class RouteRequest: IRouteRequestState\n    {\n        public Guid Id { get; set; }\n        public TownBasicInfo Source { get; set; }=null!;\n        public TownBasicInfo Destination { get; set; } = null!;\n        public DateTime WhenStart { get; set; }\n        public DateTime WhenEnd { get; set; }\n        public long TimeStamp { get; set; }\n        public UserBasicInfo User { get; set; } = null!;\n        public Guid? RouteId { get; set; }\n        public RouteOffer? Route { get; set; }\n\n    } \n    ```", "```cs\n    internal class OutputQueueItem: IQueueItemState\n    {\n        public Guid Id { get; set; }\n        public int MessageCode { get; set; }\n        public string MessageContent { get; set; } = null!;\n        public DateTime ReadyTime { get; set; }\n    } \n    ```", "```cs\npublic DbSet<RouteRequest> RouteRequests { get; set; } = null!;\npublic DbSet<RouteOffer> RouteOffers { get; set; } = null!;\npublic DbSet<OutputQueueItem> OutputQueueItems { get; set; } = null!; \n```", "```cs\nbuilder.Entity<RouteOffer>().HasMany(m => m.Requests)\n    .WithOne(m => m.Route)\n    .HasForeignKey(m => m.RouteId)\n    .OnDelete(DeleteBehavior.Cascade); \n```", "```cs\nbuilder.Entity<RouteRequest>().OwnsOne(m => m.Source);\nbuilder.Entity<RouteRequest>().OwnsOne(m => m.Destination);\nbuilder.Entity<RouteRequest>().OwnsOne(m => m.User);\nbuilder.Entity<RouteRequest>().HasIndex(m => m.WhenStart);\nbuilder.Entity<RouteRequest>().HasIndex(m => m.WhenEnd);\nbuilder.Entity<RouteOffer>().OwnsOne(m => m.User);\nbuilder.Entity<RouteOffer>().HasIndex(m => m.When);\nbuilder.Entity<RouteOffer>().HasIndex(m => m.Status);\nbuilder.Entity<OutputQueueItem>().HasIndex(m => m.ReadyTime); \n```", "```cs\ninternal class OutputQueueRepository(IUnitOfWork uow) : IOutputQueueRepository\n{\n    readonly MainDbContext ctx = (uow as MainDbContext)!;\n    public void Confirm(Guid[] ids)\n    …\n    public QueueItem New<T>(T item, int messageCode)\n    …\n    public async Task<IList<QueueItem>> Take(int N, TimeSpan requeueAfter)\n    …\n    }\n} \n```", "```cs\npublic QueueItem New<T>(T item, int messageCode)\n{\n    var entity = new OutputQueueItem()\n    {\n        Id = Guid.NewGuid(),\n        MessageCode = messageCode,\n        MessageContent = JsonSerializer.Serialize(item)\n    };\n    var res = new QueueItem(entity);\n    ctx.OutputQueueItems.Add(entity);\n    return res;\n} \n```", "```cs\npublic void Confirm(Guid[] ids)\n{\n    var entities = ctx.ChangeTracker.Entries<OutputQueueItem>()\n        .Where(m => ids.Contains(m.Entity.Id)).Select(m => m.Entity);\n    ctx.OutputQueueItems.RemoveRange(entities);\n} \n```", "```cs\npublic async Task<IList<QueueItem>> Take(int N, TimeSpan requeueAfter)\n{\n    List<OutputQueueItem> entities;\n    using (var tx = \n        await ctx.Database.BeginTransactionAsync(IsolationLevel.\n            Serializable))\n    {\n        var now = DateTime.Now;\n        entities = await ctx.OutputQueueItems.Where(m => m.ReadyTime <= \n                                                    now)\n            .OrderBy(m => m.ReadyTime)\n            .Take(N)\n            .ToListAsync();\n        if (entities.Count > 0)\n        {\n            foreach (var entity in entities) \n                { entity.ReadyTime = now + requeueAfter; }\n            await ctx.SaveChangesAsync();\n            await tx.CommitAsync();\n        }\n        return entities.Select(m => new QueueItem(m)).ToList();\n    }\n} \n```", "```cs\ninternal class RouteRequestRepository(IUnitOfWork uow) : IRouteRequestRepository\n{\n    readonly MainDbContext ctx = (uow as MainDbContext)!;\n    public async Task DeleteBefore(DateTime milestone)\n    …\n    public async Task<RouteRequestAggregate?> Get(Guid id)\n    …\n    public async Task<IList<RouteRequestAggregate>> GetInRoute(Guid \n        routeId)\n    …\n    public async Task<IList<RouteRequestAggregate>> GetMatch(\n        IEnumerable<Coordinate> geometry, DateTime when, \n        double distance, int maxResults)\n    …\n    public RouteRequestAggregate New(Guid id, \n        TownBasicInfo source, TownBasicInfo destination, \n        TimeInterval when, UserBasicInfo user)\n    …\n} \n```", "```cs\npublic async Task DeleteBefore(DateTime milestone)\n{\n    await ctx.RouteRequests.Where(m => m.WhenEnd < milestone).ExecuteDeleteAsync(); \n} \n```", "```cs\npublic RouteRequestAggregate New(Guid id, TownBasicInfo source, \nTownBasicInfo destination, TimeInterval when, UserBasicInfo user)\n{\n    var entity = new RouteRequest()\n    {\n        Id = id,\n        Source = source,\n        Destination = destination,\n        WhenStart = when.Start,\n        WhenEnd = when.End,\n        User = user\n    };\n    var res = new RouteRequestAggregate(entity);\n    res.AddDomainEvent(new NewMatchCandidateEvent<RouteRequestAggregate>(res));\n    ctx.RouteRequests.Add(entity);\n    return res;\n} \n```", "```cs\npublic class NewMatchCandidateEvent<T>(T matchCandidate):\n    IEventNotification\n{\n    public T MatchCandidate => matchCandidate;\n} \n```", "```cs\npublic async Task<IList<RouteRequestAggregate>> GetMatch(\n    IEnumerable<Coordinate> geometry, DateTime when, \n    double distance, int maxResults)\n{\n    var lineString = new LineString(geometry.ToArray())\n        { SRID = GeometryConstants.DefaultSRID };\n    var entities = await ctx.RouteRequests.Where(m =>\n        m.RouteId == null &&\n        when <= m.WhenEnd && when >= m.WhenStart &&\n        lineString.Distance(m.Source.Location) < distance &&\n        lineString.Distance(m.Destination.Location) < distance)\n        .Select(m => new\n        {\n            Distance = lineString.Distance(m.Source.Location),\n            Entity = m\n        })\n        .OrderBy(m => m.Distance)\n        .Take(maxResults).ToListAsync();\n    return entities\n       .Select(m => new RouteRequestAggregate(m.Entity))\n       .ToList();\n} \n```", "```cs\ninternal class RouteOfferRepository(IUnitOfWork uow) : IRouteOfferRepository\n{\n    readonly MainDbContext ctx = (uow as MainDbContext)!;\n    public async Task DeleteBefore(DateTime milestone)\n    …\n    public async Task<RouteOfferAggregate?> Get(Guid id)\n    …\n    public async Task<IList<RouteOfferAggregate>> GetMatch(\n        Point source, Point destination, TimeInterval when, \n double distance, int maxResults)\n    …\n    public RouteOfferAggregate New(Guid id, Coordinate[] path, \n        UserBasicInfo user, DateTime When)\n    …   \n} \n```", "```cs\npublic async Task DeleteBefore(DateTime milestone)\n{\n    await ctx.RouteOffers.Where(m => m.When < milestone).ExecuteDeleteAsync();\n} \n```", "```cs\npublic async Task<IList<RouteOfferAggregate>> GetMatch(\n    Point source, Point destination, \n    TimeInterval when, double distance, int maxResults)\n{\n    var entities = await ctx.RouteOffers.Where(m => \n         m.Status == RouteStatus.Open &&\n        m.When <= when.End && m.When >= when.Start &&\n        source.Distance(m.Path) < distance)\n        .Select(m => new\n        {\n            Distance = source.Distance(m.Path),\n            Entity = m\n        })\n        .OrderBy(m => m.Distance)\n        .Take(maxResults).ToListAsync();\n            return entities\n        .Select(m => new RouteOfferAggregate(m.Entity))\n        .ToList();\n} \n```", "```cs\ninternal class LibraryDesignTimeDbContextFactory : \n    IDesignTimeDbContextFactory<MainDbContext>\n{\n    private const string connectionString =\n        @\"Server=<your sql server instance name>;Database=RoutesPlanning;\n        User Id=sa;Password=<your password>;Trust Server Certificate=True;\n        MultipleActiveResultSets=true \";\n    public MainDbContext CreateDbContext(string[] args)\n    {\n        var builder = new DbContextOptionsBuilder<MainDbContext>();\n        builder.UseSqlServer(\n            connectionString, \n            x => x.UseNetTopologySuite());\n        return new MainDbContext(builder.Options);\n    }\n} \n```", "```cs\n\"ConnectionStrings__DefaultConnection\":\n \"Server=host.docker.internal;Database=RoutesPlanning;User Id=sa;\n    Password=<our password>;Trust Server Certificate=True;MultipleActiveResultSets=true\" \n```", "```cs\nAdd-Migration initial \n```", "```cs\nUpdate-Database \n```", "```cs\ninternal class RouterOfferMessageHandler(\n    IRouteOfferRepository repo,\n    IUnitOfWork uow,\n    EventMediator mediator\n    ) : ICommandHandler<MessageCommand<RouteOfferMessage>>\n{\n    public async Task HandleAsync(MessageCommand<RouteOfferMessage> \n        command)\n    {\n        var message = command.Message;\n        var toCreate = repo.New(message.Id,\n          message.Path!.Select(m =>\nnew Coordinate(m.Location!.Longitude, m.Location.Latitude)).\n                           ToArray(),\n            new UserBasicInfo { Id = message.User!.Id, \n                DisplayName = message.User.DisplayName! },\n            message.When!.Value\n           );\n        if (toCreate.DomainEvents != null && toCreate.DomainEvents.Count > \n 0)\n            await mediator.TriggerEvents(toCreate.DomainEvents);\n        try\n        {\n            await uow.SaveEntitiesAsync();\n        }\n        catch (ConstraintViolationException) { }\n    }\n} \n```", "```cs\n public async Task HandleAsync(MessageCommand<RouteClosedAbortedMessage> command)\n    {\n        var message = command.Message;\n        await uow.StartAsync(System.Data.IsolationLevel.Serializable);\n        try\n        {\n            var route = await repo.Get(message.RouteId);\n            if (route is not null)\n            {\n                if(!message.IsAborted)\n                {\n                    if(route.Status != RouteStatus.Open)\n                    {\n                        await uow.RollbackAsync();\n                        return;\n                    }\n                    else route.Close();\n                }\n                else\n                {\n                    if(route.Status == RouteStatus.Aborted)\n                    {\n                        await uow.RollbackAsync();\n                        return;\n                    }\n                    else route.Abort();\n                }\n                if (route.DomainEvents != null && route.DomainEvents.Count \n                    > 0)\n                    mediator.Equals(route.DomainEvents);\n                await uow.SaveEntitiesAsync();\n                await uow.CommitAsync();\n            }\n            else\n            {\n                await uow.RollbackAsync();\n                return;\n            }\n        }\n        catch\n        {\n            await uow.RollbackAsync();\n            throw;\n        }\n\n    }\n} \n```", "```cs\ninternal class RouteExtendedMessageHandler(\n    IRouteOfferRepository repo,\n    IUnitOfWork uow,\n    EventMediator mediator\n    ) : ICommandHandler<MessageCommand<RouteExtendedMessage>>\n{\n    public async Task HandleAsync(MessageCommand<RouteExtendedMessage> command)\n    {\n        var message = command.Message;\n        await uow.StartAsync(System.Data.IsolationLevel.Serializable);\n        try\n        {\n            var route = await repo.Get(message.ExtendedRoute!.Id);\n            if (route is not null && route.TimeStamp != message.TimeStamp)\n            {\n                route.Extend(message.TimeStamp,\n                    message.AddedRequests!.Select(m => m.Id),\n                    message.ExtendedRoute.Path!\n                        .Select(m => new Coordinate(m.Location!.Longitude,\n                            m.Location.Latitude)).ToArray(),message.\n                              Closed);\n                if (route.DomainEvents != null && route.DomainEvents.Count \n                    > 0)\n                    mediator.Equals(route.DomainEvents);\n                await uow.SaveEntitiesAsync();\n                await uow.CommitAsync();\n            }\n            else\n            {\n                await uow.RollbackAsync();\n                return;\n            }\n        }\n        catch\n        {\n            await uow.RollbackAsync();\n            throw;\n        }\n    }\n} \n```", "```cs\ninternal class HouseKeepingCommandHandler(\n    IRouteRequestRepository requestRepo,\n    IRouteOfferRepository offerRepo\n    ) : ICommandHandler<HouseKeepingCommand>\n{\n    public async Task HandleAsync(HouseKeepingCommand command)\n    {\n        var deleteTrigger = DateTime.Now.AddDays( -command.DeleteDelay );\n        await offerRepo.DeleteBefore(deleteTrigger);\n        await requestRepo.DeleteBefore(deleteTrigger);\n    }\n} \n```", "```cs\ninternal class OutputSendingCommandHandler(\n    IOutputQueueRepository repo,\n    IUnitOfWork uow\n    ): ICommandHandler<\n        OutputSendingCommand<RouteExtensionProposalsMessage>>\n{\n    public async Task HandleAsync(OutputSendingCommand<\n        RouteExtensionProposalsMessage> command)\n    {\n        var aggregates =await repo.Take\n            (command.BatchCount, command.RequeueDelay);\n        if(aggregates.Count==0)\n        {\n            command.OutPutEmpty = true;\n            return;\n        }\n        var allTasks = aggregates.Select(\n            m => (m, command.Sender(m.GetMessage<\n                RouteExtensionProposalsMessage>()!)))\n            .ToDictionary(m => m.Item1!, m => m.Item2 );\n        try\n        {\n            await Task.WhenAll(allTasks.Values.ToArray());\n        }\n        catch\n        {\n        }\n        repo.Confirm(aggregates\n            .Where(m =>!allTasks[m].IsFaulted && !allTasks[m].IsFaulted)\n            .Select(m => m.Id).ToArray());\n        await uow.SaveEntitiesAsync();\n    } \n```", "```cs\ninternal class AttachedRequestEventHandler(\n    IRouteRequestRepository repo\n    ) : IEventHandler<AttachedRequestEvent>\n{\n    public async Task HandleAsync(AttachedRequestEvent ev)\n    {\n        var requests = await repo.Get(ev.AddedRequests.ToArray());\n        foreach (var request in requests) request.AttachToRoute(\n            ev.RouteOffer);\n    }\n} \n```", "```cs\ninternal class ReleasedRequestsEventHandler(\n    IRouteRequestRepository repo\n    ) : IEventHandler<ReleasedRequestsEvent>\n{\n    public async Task HandleAsync(ReleasedRequestsEvent ev)\n    {\n        var requests=await repo.GetInRoute(ev.AbortedRoute);\n        foreach(var request in requests) request.DetachFromRoute();\n    }\n} \n```", "```cs\ninternal class RequestMatchCandidateEventHandler(\n    IRouteOfferRepository offerRepo,\n    IOutputQueueRepository queueRepo,\n    IConfiguration configuration) : \n        IEventHandler<NewMatchCandidateEvent<RouteRequestAggregate>>\n{\n    private RouteRequestMessage PrepareMessage(RouteRequestAggregate m)\n        => new RouteRequestMessage\n        …\n         …\n    public async Task HandleAsync(\nNewMatchCandidateEvent<RouteRequestAggregate> ev)\n    {\n        double maxDistance = configuration\n            .GetValue<double>(\"Topology:MaxDistanceKm\") * 1000d;\n        int maxResults = configuration\n            .GetValue<int>(\"Topology:MaxMatches\");\n        var offers = await offerRepo.GetMatch(\n            ev.MatchCandidate.Source.Location, \n            ev.MatchCandidate.Destination.Location,\n            ev.MatchCandidate.When, maxDistance, maxResults);\n        var proposals = Enumerable.Repeat(ev.MatchCandidate, 1)\n            .Select(m => PrepareMessage(m)).ToList();\n        foreach (var offer in offers)\n        {\n            var message = new RouteExtensionProposalsMessage\n            {\n                RouteId = offer.Id,\n                Proposals = proposals,\n            };\n            queueRepo.New<RouteExtensionProposalsMessage>(message, 1);\n        }\n    }\n} \n```"]