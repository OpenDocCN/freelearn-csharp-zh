- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Testing in ASP.NET Core (Part 1 – Unit Testing)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 测试（第 1 部分 – 单元测试）
- en: Testing is an essential part of any software development process, including
    ASP.NET Core web API development. Testing helps to ensure that the application
    works as expected and meets the requirements. It also helps to ensure that any
    changes made to the code don’t break existing functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何软件开发过程的重要组成部分，包括 ASP.NET Core Web API 开发。测试有助于确保应用程序按预期工作并满足要求。它还有助于确保对代码所做的任何更改都不会破坏现有功能。
- en: In this chapter, we’ll look at the different types of testing that are available
    in ASP.NET Core and how to implement unit tests in ASP.NET Core web API applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 ASP.NET Core 中可用的不同测试类型以及如何在 ASP.NET Core Web API 应用程序中实现单元测试。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to testing in ASP.NET Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 测试简介
- en: Writing unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Testing the database access layer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据库访问层
- en: By the end of this chapter, you will be able to write unit tests for your ASP.NET
    Core web API application to ensure that the code unit is functioning correctly.
    You will also learn how to use some libraries, such as `Moq` and `FluentAssertions`,
    to make your tests more readable and maintainable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够为你的 ASP.NET Core Web API 应用程序编写单元测试，以确保代码单元正确运行。你还将学习如何使用一些库，例如 `Moq`
    和 `FluentAssertions`，使你的测试更易于阅读和维护。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9).
    You can use VS Code or VS 2022 to open the solutions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可在 [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9)
    找到。你可以使用 VS Code 或 VS 2022 打开解决方案。
- en: Introduction to testing in ASP.NET Core
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 测试简介
- en: 'Different types of testing can be performed on an ASP.NET Core web API application,
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对 ASP.NET Core Web API 应用程序执行不同类型的测试，如下所示：
- en: '**Unit testing**: This is the process of testing individual units of code,
    such as methods and classes, to ensure that they work as expected. Unit tests
    should be small, fast, and isolated from other units of code. Mocking frameworks
    can be used to isolate units of code from their dependencies, such as databases
    and external services.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这是测试单个代码单元的过程，例如方法和类，以确保它们按预期工作。单元测试应该是小的、快速的，并且与其他代码单元隔离。可以使用模拟框架来隔离代码单元与其依赖项，例如数据库和外部服务。'
- en: '**Integration testing**: This involves testing the integration between different
    components of the application to ensure that they work together as expected. This
    type of testing helps to identify issues that may arise when the application is
    deployed to a production environment. Generally, integration tests are slower
    than unit tests. Integration tests may use mock objects or real objects, depending
    on the scenario. For example, if the integration test is to test the integration
    between the application and a database, then a real database instance should be
    used. But if the integration test is to test the application’s integration with
    an external service, such as a payment service, then we should use a mock object
    to simulate the external service. In the microservices architecture, integration
    tests are more complicated, as they may involve multiple services. Besides the
    integration tests for each service, there should also be integration tests for
    the entire system.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这涉及测试应用程序不同组件之间的集成，以确保它们按预期一起工作。此类测试有助于识别在应用程序部署到生产环境时可能出现的任何问题。通常，集成测试比单元测试慢。根据场景，集成测试可能使用模拟对象或真实对象。例如，如果集成测试是为了测试应用程序与数据库的集成，则应使用真实数据库实例。但如果集成测试是为了测试应用程序与外部服务（如支付服务）的集成，则应使用模拟对象来模拟外部服务。在微服务架构中，集成测试更复杂，因为它们可能涉及多个服务。除了每个服务的集成测试之外，还应该有针对整个系统的集成测试。'
- en: '**End-to-end testing**: This is the process of testing the application from
    the user’s perspective to ensure that the entire system from start to finish,
    including the user interface, the web API, the database, and more, is working
    as expected. End-to-end testing typically involves simulating user interactions
    with the application, such as clicking buttons and entering data into forms.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这是从用户的角度测试应用程序的过程，以确保整个系统从开始到结束，包括用户界面、Web API、数据库等，都按预期工作。端到端测试通常涉及模拟用户与应用程序的交互，例如点击按钮和将数据输入表单。'
- en: '**Regression testing**: This involves testing whether the application still
    works as expected after new features are added or bugs are fixed. Regression testing
    is usually performed after the application is deployed to a production environment.
    It helps to ensure that the new features or bug fixes don’t break existing functionality.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：这涉及到在添加新功能或修复错误后测试应用程序是否仍然按预期工作。回归测试通常在应用程序部署到生产环境后执行。它有助于确保新功能或错误修复不会破坏现有功能。'
- en: '**Load testing**: This involves testing whether the application can handle
    a normal load of users and requests. It helps to set the baseline for the performance
    of the application.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：这涉及到测试应用程序是否能够处理正常负载的用户和请求。它有助于设定应用程序性能的基线。'
- en: '**Stress testing**: This involves testing whether the application can handle
    extreme conditions, such as a sudden spike in the number of users and requests,
    or gradually increasing the load over a long period. It also determines whether
    the application can recover from failures and how long it takes to recover.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：这涉及到测试应用程序是否能够处理极端条件，例如用户数量和请求的突然增加，或者逐渐增加长期负载。它还确定应用程序是否能够从故障中恢复以及恢复所需的时间。'
- en: '**Performance testing**: This is a type of testing that evaluates the performance
    of the application under different workloads, including response time, throughput,
    resource usage, and more. Performance testing is a superset of load testing and
    stress testing. Generally, unit testing and integration testing are performed
    in the development environment and the staging environment, while performance
    testing is performed in a production-like environment, such as a **user acceptance
    testing** (**UAT**) environment, which closely mirrors the production environment
    in terms of infrastructure and configuration. This ensures that the performance
    tests are accurate and reliable. In some cases, limited performance testing can
    be performed in a development environment during scheduled maintenance windows
    to validate real-world performance scenarios.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：这是一种评估应用程序在不同工作负载下性能的测试，包括响应时间、吞吐量、资源使用等。性能测试是负载测试和压力测试的超集。通常，单元测试和集成测试在开发环境和预发布环境中执行，而性能测试则在类似生产环境的环境中执行，例如**用户验收测试**（**UAT**）环境，该环境在基础设施和配置方面与生产环境非常相似。这确保了性能测试的准确性和可靠性。在某些情况下，可以在计划维护窗口期间在开发环境中进行有限的性能测试，以验证实际性能场景。'
- en: Unit testing and integration testing are the most common types of testing that
    are written in .NET by developers. In this chapter, we will focus on unit testing;
    we will discuss integration testing in [*Chapter 10*](B18971_10.xhtml#_idTextAnchor404).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和集成测试是 .NET 开发者编写的最常见的测试类型。在本章中，我们将重点关注单元测试；我们将在[*第 10 章*](B18971_10.xhtml#_idTextAnchor404)中讨论集成测试。
- en: Writing unit tests
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Unit tests are written to test individual units of code, such as methods and
    classes. Unit tests are typically written by developers who are familiar with
    the code. When developers develop new features or fix bugs, they should also write
    unit tests to ensure that the code works as expected. There are many unit testing
    frameworks available for .NET, including NUnit, xUnit, and MSTest. In this chapter,
    we will use xUnit to write unit tests since it is one of the most popular unit
    testing frameworks for modern .NET applications at present.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是为了测试代码的各个独立单元，例如方法和类。通常由熟悉代码的开发者编写单元测试。当开发者开发新功能或修复错误时，他们也应该编写单元测试以确保代码按预期工作。.NET
    提供了许多单元测试框架，包括 NUnit、xUnit 和 MSTest。在本章中，我们将使用 xUnit 编写单元测试，因为它是目前最流行的 .NET 应用程序单元测试框架之一。
- en: Preparing the sample application
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备示例应用程序
- en: 'The sample application, `InvoiceApp`, is a simple ASP.NET Core web API application
    that exposes a set of RESTful APIs for managing invoices. The sample application
    uses EF Core to store and retrieve data from a SQL Server database. It has the
    following endpoints:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/invoices`: Retrieves a list of invoices'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/invoices/{id}`: Retrieves an invoice by ID'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/invoices`: Creates a new invoice'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /api/invoices/{id}`: Updates an existing invoice'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /api/invoices/{id}`: Deletes an invoice'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /api/invoices/{id}/status`: Updates the status of an invoice'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/invoices/{id}/send`: Sends an invoice email to the contact'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/contacts`: Retrieves a list of contacts*   `GET /api/contacts/{id}`:
    Retrieves a contact by ID*   `POST /api/contacts`: Creates a new contact*   `PUT
    /api/contacts/{id}`: Updates an existing contact*   `DELETE /api/contacts/{id}`:
    Deletes a contact*   `GET /api/contacts/{id}/invoices`: Retrieves a list of invoices
    for a contact'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the preceding endpoints are not enough to build a complete invoice
    management application. It is just a sample application to demonstrate how to
    write unit tests and integration tests for ASP.NET Core web API applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the sample application has a Swagger UI that can be used to test
    the APIs. *Figure 9**.1* shows the Swagger UI for the sample application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The sample application API endpoints](img/B18971_09_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The sample application API endpoints
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: After you run the sample application using the `dotnet run` command, you can
    access the Swagger UI at [http://localhost:5087/swagger/index.html](http://localhost:5087/swagger/index.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use this sample application to demonstrate how to write unit tests
    for ASP.NET Core web API applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the unit tests project
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use xUnit to write unit tests for the sample application. xUnit is a
    popular unit testing framework for .NET applications. It is a free, open-source
    project that has been around for many years. It is also the default unit testing
    framework for .NET Core and .NET 5+ applications. You can find more information
    about xUnit at [https://xunit.net/](https://xunit.net/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the test project, you can use VS 2022 or the .NET CLI. If you use
    VS 2022, you can create a new xUnit test project by right-clicking on the solution
    and selecting `InvoiceApp.UnitTests` and click **Create** to create the project:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Creating a new xUnit test project in VS 2022](img/B18971_09_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Creating a new xUnit test project in VS 2022
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'After you create the project, add a project reference to the `InvoiceApp.WebApi`
    project so that the test project can access the classes in the main web API project.
    You can do this by right-clicking on the `InvoiceApp.WebApi` project from the
    list of projects and click **OK** to add the project reference:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Adding a project reference to the test project in VS 2022](img/B18971_09_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Adding a project reference to the test project in VS 2022
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 在VS 2022中将项目引用添加到测试项目中
- en: 'If you use the .NET CLI, you can create a new xUnit test project by running
    the following commands in the terminal:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用.NET CLI，您可以在终端中运行以下命令来创建一个新的xUnit测试项目：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can add the test project to the solution by running the following
    commands:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过运行以下命令将测试项目添加到解决方案中：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You also need to add the reference to the main project by running the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要通过运行以下命令将引用添加到主项目中：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The default xUnit test project template contains a sample unit test. You can
    delete the sample unit test named `UnitTest1.cs`; we will write our own unit tests
    in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的xUnit测试项目模板包含一个示例单元测试。您可以删除名为`UnitTest1.cs`的示例单元测试；我们将在下一节编写自己的单元测试。
- en: 'If you create the test project starting from a blank .NET library project,
    you need to add the following packages to the test project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从空白.NET库项目开始创建测试项目，您需要将以下包添加到测试项目中：
- en: '`Microsoft.NET.Test.Sdk`: This is required for running unit tests'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.NET.Test.Sdk`：这是运行单元测试所必需的'
- en: '`xunit`: This is the xUnit framework that we will use to write unit tests'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xunit`：这是我们用来编写单元测试的xUnit框架'
- en: '`xunit.runner.visualstudio`: This is required for running unit tests in Visual
    Studio'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xunit.runner.visualstudio`：这是在Visual Studio中运行单元测试所必需的'
- en: '`coverlet.collector`: This is an open-source project that provides code coverage
    analysis for .NET applications'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coverlet.collector`：这是一个开源项目，为.NET应用程序提供代码覆盖率分析'
- en: When we write unit tests, keep in mind that one unit test should test one unit
    of code, such as a method or a class. The unit test should be isolated from other
    units of code. If one method depends on another method, we should mock the other
    method to isolate the unit of code to ensure that we focus on the behavior of
    the unit of code that we are testing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写单元测试时，请记住，一个单元测试应该测试一个代码单元，例如一个方法或一个类。单元测试应该与其他代码单元隔离。如果一个方法依赖于另一个方法，我们应该模拟其他方法以隔离代码单元，确保我们专注于我们正在测试的代码单元的行为。
- en: Writing unit tests without dependencies
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无依赖项编写单元测试
- en: 'Let’s see the first example. In the sample application, you can find a `Services`
    folder, which includes the `IEmailService` interface and its implementation, `EmailService`.
    The `EmailService` class has a method named `GenerateInvoiceEmail()`. This method
    is a simple function that generates an email according to the `Invoice` entity.
    The following code shows the `GenerateInvoiceEmail()` method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个例子。在示例应用程序中，您可以找到一个名为`Services`的文件夹，其中包含`IEmailService`接口及其实现`EmailService`。`EmailService`类有一个名为`GenerateInvoiceEmail()`的方法。该方法是一个简单的函数，根据`Invoice`实体生成电子邮件。以下代码显示了`GenerateInvoiceEmail()`方法：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Raw string literal
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量
- en: The `body` variable is a raw string literal, which is a new feature that was
    introduced in C# 11\. Raw string literals are enclosed in triple quotes (`"""`).
    They can span multiple lines and can contain double quotes without escaping them.
    You can find more information about raw string literals at [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string).
    Raw strings can also be used with interpolated strings, which is convenient for
    generating strings with variables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`变量是一个原始字符串字面量，这是C# 11中引入的新特性。原始字符串字面量用三重引号（`"""`）包围。它们可以跨越多行，并且可以包含双引号而不需要转义。您可以在[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string)找到有关原始字符串字面量的更多信息。原始字符串也可以与插值字符串一起使用，这对于生成包含变量的字符串来说很方便。'
- en: 'There is no dependency in the `GenerateInvoiceEmail()` method, so we can write
    a unit test for this method without mocking any other methods. Create a class
    named `EmailServiceTests` in the `InvoiceApp.UnitTests` project. Then, add the
    following code to the class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GenerateInvoiceEmail()`方法中没有依赖项，因此我们可以不模拟任何其他方法就为该方法编写单元测试。在`InvoiceApp.UnitTests`项目中创建一个名为`EmailServiceTests`的类。然后，将以下代码添加到该类中：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Fact` attribute indicates that the `GenerateInvoiceEmail_Should_Return_Email()`
    method is a unit test so that xUnit can discover and run this method as a unit
    test. In the `GenerateInvoiceEmail_Should_Return_Email()` method, we created an
    `Invoice` object and passed it to the `GenerateInvoiceEmail()` method. Then, we
    used the `Assert` class to verify that the `GenerateInvoiceEmail()` method returns
    the expected email.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fact` 属性表示 `GenerateInvoiceEmail_Should_Return_Email()` 方法是一个单元测试，这样 xUnit
    就可以检测并运行这个方法作为单元测试。在 `GenerateInvoiceEmail_Should_Return_Email()` 方法中，我们创建了一个
    `Invoice` 对象并将其传递给 `GenerateInvoiceEmail()` 方法。然后，我们使用 `Assert` 类验证 `GenerateInvoiceEmail()`
    方法返回预期的电子邮件。'
- en: 'When writing unit tests, we follow the *Arrange-Act-Assert* pattern:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试时，我们遵循 *安排-执行-断言* 模式：
- en: '**Arrange**: This is where we prepare the data and set up the environment for
    the unit test'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：这是准备数据和设置单元测试环境的地方'
- en: '**Act**: This is where we call the method that we want to test'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：这是调用我们想要测试的方法的地方'
- en: '**Assert**: This is where we verify that the method returns the expected result
    or that the method behaves as expected'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这是验证方法返回预期结果或方法行为符合预期的地方'
- en: 'To run the unit test in VS 2022, you can right-click on the `InvoiceApp.UnitTests`
    project or the `EmailServiceTest.cs` file and select **Run Tests**. You can also
    use the **Test Explorer** window to run the unit test by clicking the **Test**
    menu and selecting **Run** **all tests**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 VS 2022 中运行单元测试，您可以右键单击 `InvoiceApp.UnitTests` 项目或 `EmailServiceTest.cs`
    文件，并选择 **运行测试**。您也可以使用 **测试资源管理器** 窗口通过点击 **测试** 菜单并选择 **运行** **所有测试** 来运行单元测试：
- en: '![Figure 9.4 – Running unit tests in VS 2022](img/B18971_09_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 在 VS 2022 中运行单元测试](img/B18971_09_04.jpg)'
- en: Figure 9.4 – Running unit tests in VS 2022
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 在 VS 2022 中运行单元测试
- en: 'VS Code supports running unit tests as well. Click the **Testing** icon on
    the left-hand side of the VS Code window to open the **Test** view; you will see
    the unit tests, as shown in *Figure 9**.5*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 也支持运行单元测试。点击 VS Code 窗口左侧的 **测试** 图标以打开 **测试** 视图；您将看到单元测试，如图 *图 9**.5*
    所示：
- en: '![Figure 9.5 – Running unit tests in VS Code](img/B18971_09_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 在 VS Code 中运行单元测试](img/B18971_09_05.jpg)'
- en: Figure 9.5 – Running unit tests in VS Code
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 在 VS Code 中运行单元测试
- en: 'If you use the .NET CLI, you can run the unit tests by running the following
    command in the terminal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 .NET CLI，您可以在终端中运行以下命令来运行单元测试：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will see the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output shows that the unit test passed. If you want to see the detailed
    test results, you can run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示单元测试已通过。如果您想查看详细的测试结果，您可以运行以下命令：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will see detailed test results that show the test name, the result, the
    duration, and the output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到详细的测试结果，显示测试名称、结果、持续时间和输出。
- en: Writing unit tests with dependencies
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用依赖项编写单元测试
- en: 'Let’s look at another example. In the `EmailService` class, there is a method
    named `SendEmailAsync()`, which sends an email to the recipient. In real-world
    applications, we usually use a third-party email service to send emails. To make
    the `EmailService` class testable, we can create an `IEmailSender` interface and
    its implementation, `EmailSender`. The `EmailSender` class is a wrapper of the
    `SmtpClient` class, which is used to send emails. The following code shows the
    updated `EmailService` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。在 `EmailService` 类中，有一个名为 `SendEmailAsync()` 的方法，该方法向收件人发送电子邮件。在实际应用中，我们通常使用第三方电子邮件服务来发送电子邮件。为了使
    `EmailService` 类可测试，我们可以创建一个 `IEmailSender` 接口及其实现 `EmailSender`。`EmailSender`
    类是 `SmtpClient` 类的包装器，用于发送电子邮件。以下代码显示了更新的 `EmailService` 类：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, now, `EmailService` has a dependency on the `IEmailSender` interface. To
    test the behavior of the `SendEmailAsync()` method of the `EmailService` class,
    we need to mock the `IEmailSender` interface to isolate the `EmailService` class
    from the `EmailSender` class. Otherwise, if any error occurs in the unit test,
    we cannot say for sure whether the error is caused by the `EmailService` class
    or the `EmailSender` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，`EmailService` 依赖于 `IEmailSender` 接口。为了测试 `EmailService` 类中 `SendEmailAsync()`
    方法的行为，我们需要模拟 `IEmailSender` 接口以隔离 `EmailService` 类和 `EmailSender` 类。否则，如果单元测试中发生任何错误，我们无法确定错误是由
    `EmailService` 类还是 `EmailSender` 类引起的。
- en: 'We can use the `Moq` library to mock the `IEmailSender` interface. `Moq` is
    a popular mocking library for .NET. It is available as a NuGet package. To install
    `Moq`, you can use **NuGet Package Manager** in VS 2022 or run the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Moq`库来模拟`IEmailSender`接口。`Moq`是.NET中流行的模拟库。它作为一个NuGet包提供。要安装`Moq`，您可以在VS
    2022中使用**NuGet包管理器**，或者运行以下命令：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we can create the unit tests for the `SendEmailAsync()` method. Because
    the `SendEmailAsync()` method may throw an exception if the email-sending process
    fails, we need to write two unit tests to test the success and failure scenarios.
    The following code shows the unit test for the success scenario:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为`SendEmailAsync()`方法创建单元测试。因为如果邮件发送过程失败，`SendEmailAsync()`方法可能会抛出异常，所以我们需要编写两个单元测试来测试成功和失败场景。以下代码显示了成功场景的单元测试：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we use the `Mock` class to create mock objects of the
    `IEmailSender` interface and the `ILogger` interface. We need to set up the behavior
    of the methods for the mock objects. If the methods used in the unit test are
    not set up, the unit test will fail. For example, we use the `SetUp()` method
    to mock the `SendEmailAsync` method of the `IEmailSender` interface:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`Mock`类来创建`IEmailSender`接口和`ILogger`接口的模拟对象。我们需要设置模拟对象的方法行为。如果单元测试中使用的方
    法没有被设置，单元测试将会失败。例如，我们使用`SetUp()`方法来模拟`IEmailSender`接口的`SendEmailAsync`方法：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `SetUp()` method takes a lambda expression as the parameter, which is used
    to configure the behavior of the `SendEmailAsync()` method. In the preceding code,
    we use the `It.IsAny<string>()` method to specify that the `SendEmailAsync()`
    method can accept any string value as the parameter. Then, we use the `Returns()`
    method to specify the return value of the `SendEmailAsync()` method. In this case,
    we use the `Task.CompletedTask` property to specify that the `SendEmailAsync()`
    method will return a completed task. If you need to return a specific value, you
    can also use the `Returns()` method to return a specific value. For example, if
    the `SendEmailAsync()` method returns a `bool` value, you can use the following
    code to return a `true` value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetUp()`方法接受一个lambda表达式作为参数，用于配置`SendEmailAsync()`方法的行为。在前面的代码中，我们使用`It.IsAny<string>()`方法指定`SendEmailAsync()`方法可以接受任何字符串值作为参数。然后，我们使用`Returns()`方法指定`SendEmailAsync()`方法的返回值。在这种情况下，我们使用`Task.CompletedTask`属性指定`SendEmailAsync()`方法将返回一个完成的任务。如果您需要返回一个特定的值，您也可以使用`Returns()`方法返回一个特定的值。例如，如果`SendEmailAsync()`方法返回一个`bool`值，您可以使用以下代码返回一个`true`值：'
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Mocking the ILogger interface
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟`ILogger`接口
- en: The `EmailService` class uses the `ILogger` interface to log the information
    and errors. We use the `LogInformation()` method to log the information and `LogError()`
    method to log the errors. However, we cannot mock the `LogInformation()` or `LogError()`
    method directly because they are extension methods on top of the `ILogger` interface.
    These extension methods, such as `LogInformation()`, `LogError()`, `LogDebug()`,
    `LogWarning()`, `LogCritical()`, `LogTrace()`, and others, all call the `Log()`
    method of the `ILogger` interface. Therefore, to verify that a given log message
    is logged, it is necessary to mock only the `Log()` method of the `ILogger` interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmailService`类使用`ILogger`接口来记录信息和错误。我们使用`LogInformation()`方法记录信息，使用`LogError()`方法记录错误。然而，我们无法直接模拟`LogInformation()`或`LogError()`方法，因为它们是建立在`ILogger`接口之上的扩展方法。这些扩展方法，如`LogInformation()`、`LogError()`、`LogDebug()`、`LogWarning()`、`LogCritical()`、`LogTrace()`等，都调用`ILogger`接口的`Log()`方法。因此，为了验证给定的日志消息是否被记录，有必要仅模拟`ILogger`接口的`Log()`方法。'
- en: 'If the `SendEmailAsync()` method throws an exception, we need to ensure the
    logger will log the exception when the exception occurs. To test the failure scenario,
    we need to mock the `SendEmailAsync()` method so that it throws an exception.
    We can use the `ThrowsAsync()` method to mock the `SendEmailAsync()` method to
    throw an exception explicitly. The following code shows how to mock the `SendEmailAsync()`
    method to throw an exception:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`SendEmailAsync()`方法抛出异常，我们需要确保当异常发生时，记录器会记录异常。为了测试失败场景，我们需要模拟`SendEmailAsync()`方法，使其抛出异常。我们可以使用`ThrowsAsync()`方法显式地模拟`SendEmailAsync()`方法抛出异常。以下代码显示了如何模拟`SendEmailAsync()`方法抛出异常：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can verify whether the `LogError()` method of the `ILogger` interface
    is called when the `SendEmailAsync()` method throws an exception, as shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以验证当`SendEmailAsync()`方法抛出异常时，`ILogger`接口的`LogError()`方法是否被调用，如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this way, we can ensure that the `SendEmailAsync()` method will log the exception
    when the exception occurs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以确保当发生异常时，`SendEmailAsync()`方法将记录异常。
- en: When we write unit tests, note that the test method name should be descriptive
    and should indicate the purpose of the test. For example, `SendEmailAsync_ShouldLogError_WhenEmailSendingFails()`
    is a good name because it indicates that the `SendEmailAsync` method should log
    an error when the email sending fails. However, `SendEmailAsyncTest()` is not
    a good name because it does not indicate the purpose of the test.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写单元测试时，请注意测试方法名称应该是描述性的，并且应该表明测试的目的。例如，`SendEmailAsync_ShouldLogError_WhenEmailSendingFails()`是一个好的名称，因为它表明当电子邮件发送失败时，`SendEmailAsync`方法应该记录错误。然而，`SendEmailAsyncTest()`不是一个好的名称，因为它没有表明测试的目的。
- en: For more information about how to use the `Mock` library to create mock objects,
    see [https://github.com/moq/moq](https://github.com/moq/moq).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用`Mock`库创建模拟对象的更多信息，请参阅[https://github.com/moq/moq](https://github.com/moq/moq)。
- en: Using FluentAssertions to verify the test results
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FluentAssertions验证测试结果
- en: '`xUnit` provides a set of static assertion methods to verify the test results.
    For example, we can use the `Assert.Equal()` method to verify if two objects are
    equal. These methods cover most of the scenarios, such as verifying objects, collections,
    exceptions, events, equality, types, and more. Here is a list of the assertion
    methods provided by xUnit:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`xUnit`提供了一套静态断言方法来验证测试结果。例如，我们可以使用`Assert.Equal()`方法来验证两个对象是否相等。这些方法涵盖了大多数场景，例如验证对象、集合、异常、事件、相等性、类型等。以下是xUnit提供的断言方法列表：'
- en: '| **xUnit** **Assertion Methods** | **Explanation** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **xUnit** **断言方法** | **说明** |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Assert.Equal(expected, actual)` | Verifies that the `expected` value is
    equal to the `actual` value |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Equal(expected, actual)` | 验证`expected`值等于`actual`值 |'
- en: '| `Assert.NotEqual(expected, actual)` | Verifies that the `expected` value
    is not equal to the `actual` value |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotEqual(expected, actual)` | 验证`expected`值不等于`actual`值 |'
- en: '| `Assert.StrictEqual(expected, actual)` | Verifies that the `expected` value
    is strictly equal to the `actual` value, using the type’s default comparer |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.StrictEqual(expected, actual)` | 验证`expected`值严格等于`actual`值，使用类型的默认比较器
    |'
- en: '| `Assert.NotStrictEqual(expected, actual)` | Verifies that the `expected`
    value is strictly not equal to the `actual` value, using the type’s default comparer
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotStrictEqual(expected, actual)` | 验证`expected`值严格不等于`actual`值，使用类型的默认比较器
    |'
- en: '| `Assert.Same(expected, actual)` | Verifies that the `expected` object is
    the same instance as the `actual` object |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Same(expected, actual)` | 验证`expected`对象是与`actual`对象相同的实例 |'
- en: '| `Assert.NotSame(expected, actual)` | Verifies that the `expected` object
    is not the same instance as the `actual` object |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotSame(expected, actual)` | 验证`expected`对象不是与`actual`对象相同的实例 |'
- en: '| `Assert.True(condition)` | Verifies that the `condition` is true |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.True(condition)` | 验证`condition`为真 |'
- en: '| `Assert.False(condition)` | Verifies that the `condition` is false |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.False(condition)` | 验证`condition`为假 |'
- en: '| `Assert.Null(object)` | Verifies that the `object` is null |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Null(object)` | 验证`object`是null |'
- en: '| `Assert.NotNull(object)` | Verifies that the `object` is not null |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotNull(object)` | 验证`object`不是null |'
- en: '| `Assert.IsType(expectedType, object)` | Verifies that the `object` is exactly
    `expectedType`, and not a derived type |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsType(expectedType, object)` | 验证`object`确实是`expectedType`，而不是派生类型
    |'
- en: '| `Assert.IsNotType(unexpectedType, object)` | Verifies that the `object` is
    not exactly `unexpectedType` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsNotType(unexpectedType, object)` | 验证`object`不是确切的`unexpectedType`
    |'
- en: '| `Assert.IsAssignableFrom(expectedType, object)` | Verifies that the `object`
    is assignable to `expectedType`, which means that `object` is the given type or
    a derived type |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsAssignableFrom(expectedType, object)` | 验证`object`可以分配给`expectedType`，这意味着`object`是给定类型或其派生类型
    |'
- en: '| `Assert.Contains(expected, collection)` | Verifies that `collection` contains
    the `expected` object |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Contains(expected, collection)` | 验证`collection`包含`expected`对象 |'
- en: '| `Assert.DoesNotContain(expected, collection)` | Verifies that `collection`
    does not contain the `expected` object |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.DoesNotContain(expected, collection)` | 验证`collection`不包含`expected`对象
    |'
- en: '| `Assert.Empty(collection)` | Verifies that `collection` is empty |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Empty(collection)` | 验证`collection`为空 |'
- en: '| `Assert.NotEmpty(collection)` | Verifies that `collection` is not empty |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotEmpty(collection)` | 验证`collection`不为空 |'
- en: '| `Assert.Single(collection)` | Verifies that `collection` contains exactly
    one element of the given type |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Single(collection)` | 验证`collection`是否恰好包含一个给定类型的元素 |'
- en: '| `Assert.InRange(actual,` `low, high)` | Verifies that the `actual` value
    is within the range of `low` and `high` (inclusive) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.InRange(actual, low, high)` | 验证`actual`值是否在`low`和`high`（包含）的范围内
    |'
- en: '| `Assert.NotInRange(actual,` `low, high)` | Verifies that the `actual` value
    is not within the range of `low` and `high` (inclusive) |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotInRange(actual, low, high)` | 验证`actual`值不在`low`和`high`（包含）的范围内
    |'
- en: '| `Assert.Throws<exceptionType>(action)` | Verifies that `action` throws an
    exception of the specified `exceptionType`, and not a derived exception type |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Throws<exceptionType>(action)` | 验证`action`抛出指定`exceptionType`的异常，而不是派生异常类型
    |'
- en: '| `Assert.ThrowsAny<exceptionType>(action)` | Verifies that `action` throws
    an exception of the specified `exceptionType` or a derived exception type |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.ThrowsAny<exceptionType>(action)` | 验证`action`抛出指定`exceptionType`或派生异常类型的异常
    |'
- en: Table 9.1 – List of assertion methods provided by xUnit
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 – xUnit提供的断言方法列表
- en: 'Note this list is not complete. You can find more assertion methods in xUnit’s
    GitHub repository: [https://github.com/xunit/assert.xunit](https://github.com/xunit/assert.xunit).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个列表并不完整。你可以在xUnit的GitHub仓库中找到更多断言方法：[https://github.com/xunit/assert.xunit](https://github.com/xunit/assert.xunit)。
- en: Although the assertion methods provided by xUnit are enough for most scenarios,
    they are not very readable. A good way to make the unit tests more natural and
    readable is to use `FluentAssertions`, an open-source assertion library for .NET.
    It provides a set of extension methods that allow us to write assertions fluently.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然xUnit提供的断言方法对于大多数场景已经足够，但它们并不是非常易读。使单元测试更自然、易读的一个好方法是使用`FluentAssertions`，这是一个为.NET提供的开源断言库。它提供了一组扩展方法，允许我们流畅地编写断言。
- en: 'To install `FluentAssertions`, we can use the following .NET CLI command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`FluentAssertions`，我们可以使用以下.NET CLI命令：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also use NuGet Package Manager to install the `FluentAssertions` package
    if you use VS 2022.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用VS 2022，也可以使用NuGet包管理器安装`FluentAssertions`包。
- en: Then, we can use the `Should()` method to verify the test results. For example,
    we can use the `Should().Be()` method to verify whether two objects are equal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`Should()`方法来验证测试结果。例如，我们可以使用`Should().Be()`方法来验证两个对象是否相等。
- en: 'The following code shows how to use the `Should().Be()` method to verify whether
    the `GetInvoicesAsync()` method returns a list of invoices:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用`Should().Be()`方法来验证`GetInvoicesAsync()`方法是否返回发票列表：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `FluentAssertions` method is more intuitive and readable than the `Assert.Equal()`
    method. For most scenarios, you can easily replace the assertion methods provided
    by xUnit with the `FluentAssertions` methods without searching the documentation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`FluentAssertions`方法比`Assert.Equal()`方法更直观、易读。对于大多数场景，你可以轻松地将xUnit提供的断言方法替换为`FluentAssertions`方法，而无需查阅文档。'
- en: 'Let’s see how to verify the exception using `FluentAssertions`. In the `EmailServiceTests`
    class, there is a `SendEmailAsync_Should_Log_SmtpException()` method. This method
    verifies whether the `SendEmailAsync()` method will log the exception when the
    `SendEmailAsync()` method throws an exception. The following code shows how to
    use `xUnit` to verify the exception:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`FluentAssertions`来验证异常。在`EmailServiceTests`类中，有一个`SendEmailAsync_Should_Log_SmtpException()`方法。此方法验证当`SendEmailAsync()`方法抛出异常时，`SendEmailAsync()`方法是否会记录异常。以下代码展示了如何使用`xUnit`来验证异常：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can use the `Should().ThrowAsync<>()` method of `FluentAssertions` to verify
    the exception, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`FluentAssertions`的`Should().ThrowAsync<>()`方法来验证异常，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using `FluentAssertions` is more readable and intuitive than the xUnit way.
    Here is a table comparing some common assertion methods provided by xUnit and
    `FluentAssertions`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FluentAssertions`比使用xUnit的方式更易读、直观。以下是一个表格，比较了xUnit和`FluentAssertions`提供的某些常见断言方法：
- en: '| **xUnit** **Assertion Method** | **FluentAssertions** **Assertion Method**
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **xUnit** **断言方法** | **FluentAssertions** **断言方法** |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Assert.Equal(expected, actual)` | `.``Should().Be(expected)` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Equal(expected, actual)` | `.``Should().Be(expected)` |'
- en: '| `Assert.NotEqual(expected, actual)` | `.``Should().NotBe(expected)` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotEqual(expected, actual)` | `.``Should().NotBe(expected)` |'
- en: '| `Assert.True(condition)` | `.``Should().BeTrue()` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.True(condition)` | `.``Should().BeTrue()` |'
- en: '| `Assert.False(condition)` | `.``Should().BeFalse()` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.False(condition)` | `.``Should().BeFalse()` |'
- en: '| `Assert.Null(object)` | `.``Should().BeNull()` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Null(object)` | `.``Should().BeNull()` |'
- en: '| `Assert.NotNull(object)` | `.``Should().NotBeNull()` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotNull(object)` | `.``Should().NotBeNull()` |'
- en: '| `Assert.Contains(expected, collection)` | `.``Should().Contain(expected)`
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Contains(expected, collection)` | `.``Should().Contain(expected)`
    |'
- en: '| `Assert.DoesNotContain(expected, collection)` | `.``Should().NotContain(expected)`
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.DoesNotContain(expected, collection)` | `.``Should().NotContain(expected)`
    |'
- en: '| `Assert.Empty(collection)` | `.``Should().BeEmpty()` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Empty(collection)` | `.``Should().BeEmpty()` |'
- en: '| `Assert.NotEmpty(collection)` | `.``Should().NotBeEmpty()` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.NotEmpty(collection)` | `.``Should().NotBeEmpty()` |'
- en: '| `Assert.Throws<TException>(action)` | `.``Should().Throw<TException>()` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Throws<TException>(action)` | `.``Should().Throw<TException>()` |'
- en: '| `Assert.DoesNotThrow(action)` | `.``Should().NotThrow()` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.DoesNotThrow(action)` | `.``Should().NotThrow()` |'
- en: Table 9.2 – Comparison of common assertion methods provided by xUnit and FluentAssertions
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 – xUnit 和 FluentAssertions 提供的常见断言方法的比较
- en: 'Note that the preceding table is not an exhaustive list. You can find more
    extension methods in the official documentation of `FluentAssertions`: [https://fluentassertions.com/introduction](https://fluentassertions.com/introduction).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的表格并不是一个详尽的列表。你可以在 `FluentAssertions` 的官方文档中找到更多扩展方法：[https://fluentassertions.com/introduction](https://fluentassertions.com/introduction)。
- en: 'Besides the fluent assertion methods, `FluentAssertions` also provides better
    error messages if the test fails. For example, if we use the `Assert.Equal()`
    method to verify whether `returnResult` contains two invoices, the code will look
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了流畅断言方法之外，如果测试失败，`FluentAssertions` 还提供了更好的错误信息。例如，如果我们使用 `Assert.Equal()`
    方法来验证 `returnResult` 是否包含两个发票，代码将如下所示：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the test fails, the error message will be as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，错误信息将如下所示：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we have multiple `Assert.Equal()` methods in the test method, which is not
    recommended but something we have to do occasionally, we cannot immediately know
    which `Assert.Equal()` method fails. We need to check the line number of the error
    message to find the failing assertion. This is not very convenient.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试方法中有多个 `Assert.Equal()` 方法，虽然不推荐但有时不得不这样做，我们无法立即知道哪个 `Assert.Equal()` 方法失败。我们需要检查错误信息的行号以找到失败的断言。这并不很方便。
- en: 'If we use `FluentAssertions`, the assertion code will look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `FluentAssertions`，断言代码将如下所示：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the test fails with the same reason, the error message will be as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试因相同原因失败，错误信息将如下所示：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, the error message is more detailed and intuitive and tells us which assertion
    fails. This is very helpful when we have multiple assertions in the test method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，错误信息更加详细和直观，并告诉我们哪个断言失败。这对于我们在测试方法中有多个断言时非常有帮助。
- en: 'You can even enrich the error message by adding a custom message to the assertion
    method. For example, we can add a custom message to the `Should().Be()` method,
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过向断言方法添加自定义消息来丰富错误信息。例如，我们可以向 `Should().Be()` 方法添加自定义消息，如下所示：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, the error message will be as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，错误信息将如下所示：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Therefore, it is highly recommended to use `FluentAssertions` in your tests.
    It makes your tests more readable and maintainable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，强烈建议在测试中使用 `FluentAssertions`。它可以使你的测试更易于阅读和维护。
- en: Testing the database access layer
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据库访问层
- en: In many web API applications, we need to access the database to perform CRUD
    operations. In this section, we will learn how to test the database access layer
    in unit tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多 Web API 应用程序中，我们需要访问数据库以执行 CRUD 操作。在本节中，我们将学习如何在单元测试中测试数据库访问层。
- en: How can we test the database access layer?
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何测试数据库访问层？
- en: 'Currently, we inject `InvoiceDbContext` into controllers to access the database.
    This approach is easy for development, but it tightly couples the controllers
    with the `InvoiceDbContext` class. When we test the controllers, we need to create
    a real `InvoiceDbContext` object and use it to test the controllers, which means
    controllers are not tested in isolation. This problem can be addressed in a variety
    of ways:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将 `InvoiceDbContext` 注入到控制器中以访问数据库。这种方法对开发来说很容易，但它将控制器与 `InvoiceDbContext`
    类紧密耦合。当我们测试控制器时，我们需要创建一个真实的 `InvoiceDbContext` 对象并使用它来测试控制器，这意味着控制器不是独立测试的。这个问题可以通过多种方式解决：
- en: Use the `InMemoryDatabase` provider of EF Core to create an in-memory database
    as the fake database
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EF Core 的 `InMemoryDatabase` 提供者创建内存数据库作为模拟数据库
- en: Use the SQLite in-memory database as the fake database
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLite 内存数据库作为模拟数据库
- en: Create a separate repository layer to encapsulate the database access code,
    inject the repository layer into controllers (or services that need to access
    databases), and then use `Mock` objects to mock the repository layer
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单独的仓库层来封装数据库访问代码，将仓库层注入到控制器（或需要访问数据库的服务）中，然后使用`Mock`对象来模拟仓库层
- en: Use the real database for testing
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真实数据库进行测试
- en: 'Each approach has its pros and cons:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优缺点：
- en: The `InMemoryDatabase` provider was originally designed for internal testing
    of EF Core. However, it is not a good choice for testing other applications because
    it does not behave like a real database. For example, it does not support transactions
    and raw SQL queries. So, it is not a good choice for testing the database access
    code.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InMemoryDatabase`提供者最初是为EF Core的内部测试设计的。然而，它不是测试其他应用程序的好选择，因为它不像真实数据库那样运行。例如，它不支持事务和原始SQL查询。因此，它不是测试数据库访问代码的好选择。'
- en: SQLite also provides an in-memory database feature that can be used for testing.
    However, it has similar limitations to EF Core’s `InMemoryDatabase` provider.
    If the production database is SQL Server, EF Core cannot guarantee that the database
    access code will work correctly on SQL Server if we use SQLite for testing.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite也提供了一个可用于测试的内存数据库功能。然而，它具有与EF Core的`InMemoryDatabase`提供者类似的限制。如果生产数据库是SQL
    Server，如果我们使用SQLite进行测试，EF Core无法保证数据库访问代码在SQL Server上正确工作。
- en: Creating a separate repository layer is to decouple the controllers from the
    `DbContext` class. In this pattern, a separate `IRepository` interface is created
    between the application code and `DbContext`, and the implementation of the `IRepository`
    interface is injected into controllers or services. In this way, we can use `Mock`
    objects to mock the `IRepository` interface to test controllers or services, which
    means controllers or services can be tested in isolation. However, this approach
    requires a lot of work to create the repository layer. Also, the `DbContext` class
    is already a repository pattern, so creating another repository layer is redundant
    if you do not need to change the database provider. But this pattern still has
    its advantages. Tests can focus on the application logic without worrying about
    the database access code. Also, if you need to change the database provider, you
    only need to change the implementation of the `IRepository` interface, and there
    is no need to change the controllers or services.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单独的仓库层是为了将控制器与`DbContext`类解耦。在这个模式中，在应用程序代码和`DbContext`之间创建了一个单独的`IRepository`接口，并将`IRepository`接口的实现注入到控制器或服务中。这样，我们可以使用`Mock`对象来模拟`IRepository`接口以测试控制器或服务，这意味着控制器或服务可以在隔离状态下进行测试。然而，这种方法需要大量工作来创建仓库层。此外，`DbContext`类已经是仓库模式，所以如果你不需要更改数据库提供者，创建另一个仓库层是多余的。但这个模式仍然有其优点。测试可以专注于应用程序逻辑，而不必担心数据库访问代码。此外，如果你需要更改数据库提供者，你只需更改`IRepository`接口的实现，无需更改控制器或服务。
- en: Testing against a real database provides more benefits. One of the most important
    benefits is that it can ensure that the database access code works correctly on
    the database in production. Using a real database is also fast and reliable. However,
    one challenge is that we need to ensure the isolation for tests because some of
    them may change the data in the database. So, we need to make sure the data can
    be restored or recreated after the tests are completed.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对真实数据库进行测试提供了更多好处。其中最重要的好处之一是它可以确保数据库访问代码在生产数据库上正确工作。使用真实数据库也是快速且可靠的。然而，一个挑战是我们需要确保测试的隔离性，因为其中一些测试可能会更改数据库中的数据。因此，我们需要确保测试完成后数据可以被恢复或重新创建。
- en: In this section, we will use a separate local database for testing, such as
    a LocalDB database. If your application will run on SQL Server, you can use another
    SQL Server for testing rather than LocalDB since LocalDB does not behave the same
    as SQL Server. If your application will run in the cloud, such as Azure, you may
    use an Azure SQL database. You can use another Azure SQL database for testing
    but you will need to allocate a small amount of resources for it to save the cost.
    Keep in mind that the database for testing should keep the same environment as
    much as possible to avoid unexpected behaviors in production.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个单独的本地数据库进行测试，例如 LocalDB 数据库。如果你的应用程序将在 SQL Server 上运行，你可以使用另一个 SQL
    Server 进行测试而不是 LocalDB，因为 LocalDB 的行为与 SQL Server 不相同。如果你的应用程序将在云中运行，例如 Azure，你可以使用
    Azure SQL 数据库。你可以为测试使用另一个 Azure SQL 数据库，但你需要为其分配少量资源以节省成本。请记住，测试数据库应尽可能保持与生产环境相同的环境，以避免在生产中出现意外的行为。
- en: Regarding the controllers, we will use the `InvoiceDbContext` class directly
    for simplicity; we will learn the repository pattern in future chapters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关于控制器，我们将直接使用 `InvoiceDbContext` 类以简化操作；我们将在未来的章节中学习仓储模式。
- en: Creating a test fixture
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试固定点
- en: When we test the CRUD methods against the database, we need to prepare the database
    before the tests are executed, and then clean up the database after the tests
    are completed so that the changes made by the tests will not affect other tests.
    xUnit provides the `IClassFixture<T>` interface to create a test fixture, which
    can be used to prepare and clean up the database for each test class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对数据库进行 CRUD 方法测试时，需要在测试执行之前准备数据库，并在测试完成后清理数据库，以确保测试所做的更改不会影响其他测试。xUnit 提供了
    `IClassFixture<T>` 接口来创建测试固定点，这可以用于为每个测试类准备和清理数据库。
- en: 'First, we need to create a test fixture class in the `InvoiceApp.UnitTests`
    project, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `InvoiceApp.UnitTests` 项目中创建一个测试固定点类，如下所示：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `TestDatabaseFixture` class, we define a connection string to the local
    database. Using a `const` string is for simplicity only. In a real application,
    you may want to use the configuration system to read the connection string from
    other sources, such as the `appsettings.json` file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TestDatabaseFixture` 类中，我们定义了一个连接到本地数据库的连接字符串。使用 `const` 字符串只是为了简化。在实际应用程序中，你可能希望使用配置系统从其他来源读取连接字符串，例如
    `appsettings.json` 文件。
- en: 'Then, we add a method to create the database context object, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个创建数据库上下文对象的方法，如下所示：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need a method to initialize the database, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个初始化数据库的方法，如下所示：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `InitializeDatabase()` method, we create a new `InvoiceDbContext` object
    and then use the `EnsureDeleted()` method to delete the database if it exists.
    Then, we use the `EnsureCreated()` method to create the database. After that,
    we seed some data into the database. In this example, we create a few `Contact`
    and `Invoice` objects and add them to the database. Finally, we call the `SaveChanges()`
    method to save the changes to the database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `InitializeDatabase()` 方法中，我们创建一个新的 `InvoiceDbContext` 对象，然后使用 `EnsureDeleted()`
    方法删除数据库（如果存在）。然后，我们使用 `EnsureCreated()` 方法创建数据库。之后，我们在数据库中填充一些数据。在这个例子中，我们创建了一些
    `Contact` 和 `Invoice` 对象并将它们添加到数据库中。最后，我们调用 `SaveChanges()` 方法将更改保存到数据库中。
- en: 'Now, we need to call the `InitializeDatabase()` method to initialize the database
    in the constructor of the `TestDatabaseFixture` class, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `TestDatabaseFixture` 类的构造函数中调用 `InitializeDatabase()` 方法来初始化数据库，如下所示：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To avoid initializing the database multiple times, we use a static field, `_databaseInitialized`,
    to indicate whether the database has been initialized. We also define a static
    object, `Lock`, to ensure that the database is initialized only once. The `InitializeDatabase()`
    method is used to initialize the database. It will only be called once before
    the tests are executed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免多次初始化数据库，我们使用一个静态字段 `_databaseInitialized` 来指示数据库是否已初始化。我们还定义了一个静态对象 `Lock`，以确保数据库只初始化一次。`InitializeDatabase()`
    方法用于初始化数据库。它将在测试执行之前只调用一次。
- en: 'There are several important things to note:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点重要的事情需要注意：
- en: xUnit creates a new instance of the test class for every test. So, the constructor
    of the test class is called for every test.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit 为每个测试创建测试类的新的实例。因此，测试类的构造函数会在每个测试中调用。
- en: Deleting and recreating the database for each test run may slow down the tests
    and may not be necessary. If you do not want to delete and recreate the database
    for each test run, you can comment out the `EnsureDeleted()` method to allow the
    database to be reused. However, if you need to frequently change the database
    schema in the development phase, you may need to delete and recreate the database
    for each test run to ensure the database schema is up to date.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个测试运行删除和重新创建数据库可能会减慢测试速度，并且可能不是必要的。如果您不想在每次测试运行时删除和重新创建数据库，您可以取消注释`EnsureDeleted()`方法以允许数据库重用。然而，如果在开发阶段需要频繁更改数据库模式，您可能需要在每次测试运行时删除和重新创建数据库以确保数据库模式是最新的。
- en: We use a lock object to ensure the `InitializeDatabase()` method is only called
    once for each test run. The reason is that the `TextDatabaseFixture` class can
    be used in multiple test classes, and xUnit can run multiple test classes in parallel.
    Using a lock can help us ensure the seed method is only called once. We will learn
    more about parallel test execution in the next section.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一个锁对象来确保`InitializeDatabase()`方法在每个测试运行中只被调用一次。原因是`TextDatabaseFixture`类可以在多个测试类中使用，xUnit可以并行运行多个测试类。使用锁可以帮助我们确保种子方法只被调用一次。我们将在下一节中了解更多关于并行测试执行的内容。
- en: Now that the test fixture is ready, we can use it in the test classes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试固定装置已经准备好了，我们可以在测试类中使用它。
- en: Using the test fixture
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试固定装置
- en: 'Next, we will use the test fixture in the test classes. First, let’s test the
    `GetAll()` method of the `InvoiceController` class. Create a new test class named
    `InvoiceControllerTests` in the `InvoiceApp.UnitTests` project, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在测试类中使用测试固定装置。首先，让我们测试`InvoiceController`类的`GetAll()`方法。在`InvoiceApp.UnitTests`项目中创建一个名为`InvoiceControllerTests`的新测试类，如下所示：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We use dependency injection to inject the `TestDatabaseFixture` object into
    the test class. Then, we can use the text fixture to create the `InvoiceDbContext`
    object in the test methods, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用依赖注入将`TestDatabaseFixture`对象注入到测试类中。然后，我们可以在测试方法中使用文本固定装置来创建`InvoiceDbContext`对象，如下所示：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `GetInvoices_ShouldReturnInvoices()` method, we use the fixture to create
    the `InvoiceDbContext` object, and then create the `InvoiceController` object
    with some mocked dependencies. Then, we call the `GetInvoicesAsync()` method to
    get the invoices from the database. Finally, we use the `Assert` class to verify
    the result.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetInvoices_ShouldReturnInvoices()`方法中，我们使用固定装置创建`InvoiceDbContext`对象，然后使用一些模拟依赖项创建`InvoiceController`对象。然后，我们调用`GetInvoicesAsync()`方法从数据库中获取发票。最后，我们使用`Assert`类来验证结果。
- en: The data we use to verify the controller is the data we seed into the database
    in the `TestDatabaseFixture` class. If you change the data in the `TestDatabaseFixture`
    class, you also need to change the expected data in the test class.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来验证控制器的数据是我们将数据种入`TestDatabaseFixture`类数据库中的数据。如果您更改`TestDatabaseFixture`类中的数据，您也需要更改测试类中的预期数据。
- en: 'The `GetInvoices_ShouldReturnInvoices()` method is a simple `Fact` test method.
    We can also use the `Theory` test method to test the `GetInvoicesAsync()` method
    with different parameters. For example, we can test whether the controller can
    return correct invoices when we pass the `status` parameter. The test method is
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInvoices_ShouldReturnInvoices()`方法是一个简单的`Fact`测试方法。我们也可以使用`Theory`测试方法来测试具有不同参数的`GetInvoicesAsync()`方法。例如，我们可以测试在传递`status`参数时，控制器是否可以返回正确的发票。测试方法如下：'
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, we use the `Theory` attribute to indicate that the
    test method is a `Theory` test method. A `Theory` test method can have one or
    more `InlineData` attributes. Each `InlineData` attribute can pass one value or
    multiple values to the test method. In this case, we use the `InlineData` attribute
    to pass the `InvoiceStatus` value to the test method. You can use multiple `InlineData`
    attributes to pass multiple values to the test method. The test method will be
    executed multiple times with different values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`Theory`属性来指示测试方法是`Theory`测试方法。一个`Theory`测试方法可以有一个或多个`InlineData`属性。每个`InlineData`属性可以向测试方法传递一个或多个值。在这种情况下，我们使用`InlineData`属性将`InvoiceStatus`值传递给测试方法。您可以使用多个`InlineData`属性向测试方法传递多个值。测试方法将使用不同的值多次执行。
- en: The tests we introduced in this chapter are used to test read-only methods.
    They do not change the database, so we do not need to worry about the database
    state. In the next section, we will introduce how to write tests for methods that
    change the database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的所有测试都是用来测试只读方法的。它们不会更改数据库，所以我们不需要担心数据库的状态。在下一节中，我们将介绍如何为更改数据库的方法编写测试。
- en: Writing tests for methods that change the database
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为更改数据库的方法编写测试
- en: If a method changes the database, we need to ensure that the database is in
    a known state before we run the test, and also ensure that the database is restored
    to its original state so that the change will not affect other tests.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法更改数据库，我们需要确保在运行测试之前数据库处于已知状态，并且确保在测试后数据库恢复到原始状态，这样更改就不会影响其他测试。
- en: For example, a method may delete a record from the database. If the test method
    deletes a record from the database but does not restore the database after the
    test, the next test method may fail because the record is missing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个方法可能从数据库中删除一条记录。如果测试方法从数据库中删除了一条记录但在测试后没有恢复数据库，那么下一个测试方法可能会失败，因为记录缺失。
- en: 'Let’s create a test method for the `CreateInvoiceAsync()` method of the `InvoiceController`
    class. The `CreateInvoiceAsync()` method creates a new invoice in the database.
    The test method is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`InvoiceController`类的`CreateInvoiceAsync()`方法创建一个测试方法。`CreateInvoiceAsync()`方法在数据库中创建一个新的发票。测试方法如下：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this test method, we create a new invoice and pass it to the `CreateInvoiceAsync()`
    method. Then, we use the `Assert` class to verify the result. Finally, we remove
    the invoice from the database and save the changes. Note that the result of the
    `CreateInvoiceAsync()` method is a `CreatedActionResult` object, which contains
    the created invoice. So, we should convert the result into a `CreatedAtActionResult`
    object, and then get the created invoice from the `Value` property. Also, in this
    test method, we have asserted that the `Amount` property of the created invoice
    is correct based on the invoice items.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们创建了一个新的发票并将其传递给`CreateInvoiceAsync()`方法。然后，我们使用`Assert`类来验证结果。最后，我们从数据库中删除发票并保存更改。请注意，`CreateInvoiceAsync()`方法的结果是一个`CreatedAtActionResult`对象，它包含创建的发票。因此，我们应该将结果转换为`CreatedAtActionResult`对象，然后从`Value`属性中获取创建的发票。此外，在这个测试方法中，我们已经断言创建的发票的`Amount`属性基于发票项是正确的。
- en: 'When we run the test, an error may occur because the contact ID is incorrect,
    as shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，可能会出现错误，因为联系人ID不正确，如下所示：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The error says that the `CreateInvoiceAsync()` method does not behave as expected.
    We can debug the application to find out why the contact ID is not saved correctly.
    The reason is that when we created `Invoice`, we only specified the `ContactId`
    property, not the `Contact` property. So, EF Core could not find the contact with
    the specified ID, and then it created a new contact with a new ID. To fix this
    issue, we need to specify the `Contact` property when we create the `Invoice`
    object. Add the following code before calling the `dbContext.Invoices.AddAsync()`
    method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息表明`CreateInvoiceAsync()`方法的行为不符合预期。我们可以调试应用程序以找出为什么联系人ID没有正确保存。原因是当我们创建`Invoice`时，我们只指定了`ContactId`属性，而没有指定`Contact`属性。因此，EF
    Core找不到指定ID的联系人，然后它创建了一个具有新ID的新联系人。为了解决这个问题，我们需要在创建`Invoice`对象时指定`Contact`属性。在调用`dbContext.Invoices.AddAsync()`方法之前，添加以下代码：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we can run the test again. This time, the test should pass. That is why
    unit tests are so important. They can help us find bugs early and fix them before
    we deploy the application to production.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次运行测试。这次，测试应该会通过。这就是单元测试如此重要的原因。它们可以帮助我们在将应用程序部署到生产之前及早发现并修复错误。
- en: 'In the preceding example, the data was created in the test method and then
    removed from the database after the test. There is another way to manage this
    scenario: using a transaction. We can use a transaction to wrap the test method,
    and then roll back the transaction after the test. So, the data created in the
    test method will not be saved to the database. In this way, we do not need to
    manually remove the data from the database.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，数据是在测试方法中创建的，然后在测试结束后从数据库中删除。还有另一种管理这种场景的方法：使用事务。我们可以使用事务来包装测试方法，然后在测试结束后回滚事务。这样，在测试方法中创建的数据就不会保存到数据库中。这样，我们就不需要手动从数据库中删除数据。
- en: 'Let’s create a test for the `UpdateInvoiceAsync()` method of the `InvoiceController`
    class. The `UpdateInvoiceAsync()` method updates an invoice in the database. The
    test method is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `InvoiceController` 类的 `UpdateInvoiceAsync()` 方法创建一个测试。`UpdateInvoiceAsync()`
    方法更新数据库中的发票。测试方法如下：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `UpdateInvoice_ShouldUpdateInvoice()` method, before we call the `UpdateInvoiceAsync()`
    method, we start a transaction. After the test method is executed, we do not commit
    the transaction, so the transaction will roll back. The changes that are made
    in the test method will not be saved to the database. In this way, we do not need
    to manually remove the data from the database.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UpdateInvoice_ShouldUpdateInvoice()` 方法中，在我们调用 `UpdateInvoiceAsync()` 方法之前，我们启动一个事务。在测试方法执行后，我们不提交事务，因此事务将回滚。在测试方法中做出的更改将不会保存到数据库中。这样，我们就不需要手动从数据库中删除数据。
- en: We also use the `ChangeTracker.Clear()` method to clear the change tracker.
    The change tracker is used to track the changes made to the entities. If we do
    not clear the change tracker, we will get the tracked entities instead of querying
    the database. So, we need to explicitly clear the change tracker before we query
    the database.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `ChangeTracker.Clear()` 方法来清除更改跟踪器。更改跟踪器用于跟踪对实体的更改。如果我们不清除更改跟踪器，我们将得到跟踪的实体而不是查询数据库。因此，在查询数据库之前，我们需要显式清除更改跟踪器。
- en: 'This approach is convenient when we test the methods that change the database.
    However, it can lead to a problem: what if the controller (or the service) method
    already starts a transaction? We cannot wrap a transaction in another transaction.
    In this case, we must explicitly clean up any changes made to the database after
    the test method is executed.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试更改数据库的方法时，这种方法很方便。然而，它可能会导致一个问题：如果控制器（或服务）方法已经启动了一个事务？我们不能在另一个事务中包装一个事务。在这种情况下，我们必须显式清理测试方法执行后对数据库所做的任何更改。
- en: 'We can use the `IDisposable` interface to clean up the database in our tests.
    To do this, we can create a test class that implements the `IDisposable` interface,
    and then clean up the database in the `Dispose()` method. To set up the test context,
    let’s create a class called `TransactionalTestDatabaseFixture`, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `IDisposable` 接口在我们的测试中清理数据库。为此，我们可以创建一个实现 `IDisposable` 接口的测试类，然后在 `Dispose()`
    方法中清理数据库。为了设置测试上下文，让我们创建一个名为 `TransactionalTestDatabaseFixture` 的类，如下所示：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we create a database called `InvoiceTransactionalTestDb`
    and initialize it. This file is similar to the `InvoiceTestDatabaseFixture` class,
    except that it has a `Cleanup` method, which is used to clean up the database.
    In the `Cleanup` method, we delete all the contacts and invoices from the database
    and then initialize the database to restore the data.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `InvoiceTransactionalTestDb` 的数据库并初始化它。此文件与 `InvoiceTestDatabaseFixture`
    类类似，但它有一个 `Cleanup` 方法，用于清理数据库。在 `Cleanup` 方法中，我们从数据库中删除所有联系人和发票，然后初始化数据库以恢复数据。
- en: 'In the `InvoiceController.cs` file, the `UpdateInvoiceStatusAsync` method uses
    a transaction to update the status of an invoice. It is not required; this is
    purely for demonstration purposes. Let’s create a test class called `TransactionalInvoiceControllerTests`
    to test this method, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `InvoiceController.cs` 文件中，`UpdateInvoiceStatusAsync` 方法使用事务来更新发票的状态。这不是必需的；这纯粹是为了演示目的。让我们创建一个名为
    `TransactionalInvoiceControllerTests` 的测试类来测试这个方法，如下所示：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we use the `TransactionalTestDatabaseFixture` class to
    create the database context. This class implements the `IDisposable` interface
    and calls the `Cleanup()` method in the `Dispose()` method. If we have multiple
    test methods in one test class, xUnit will create a new instance of the test class
    for each test method and run them in sequence. Therefore, the `Dispose()` method
    will be called after each test method is executed to clean up the database, which
    will ensure that the changes made in the test methods will not affect other test
    methods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `TransactionalTestDatabaseFixture` 类创建数据库上下文。此类实现了 `IDisposable`
    接口，并在 `Dispose()` 方法中调用 `Cleanup()` 方法。如果我们在一个测试类中有多个测试方法，xUnit 将为每个测试方法创建测试类的实例，并按顺序运行它们。因此，`Dispose()`
    方法将在每个测试方法执行后调用以清理数据库，这将确保测试方法中做出的更改不会影响其他测试方法。
- en: What if we want to share `TransactionalTestDatabaseFixture` in multiple test
    classes? By default, xUnit will run the test classes in parallel. If other test
    classes also need to use this fixture to clean up the database, it may cause a
    concurrency issue when xUnit initializes the test context. To avoid this problem,
    we can use the `Collection` attribute to specify that the test classes that use
    this fixture belong to the same test collection so that xUnit will not run them
    in parallel. We’ll discuss the parallelism of xUnit in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在多个测试类中共享`TransactionalTestDatabaseFixture`，会怎样呢？默认情况下，xUnit会并行运行测试类。如果其他测试类也需要使用此固定装置来清理数据库，当xUnit初始化测试上下文时可能会引起并发问题。为了避免这个问题，我们可以使用`Collection`属性来指定使用此固定装置的测试类属于同一个测试集合，这样xUnit就不会并行运行它们。我们将在下一节讨论xUnit的并行性。
- en: Parallelism of xUnit
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xUnit的并行性
- en: By default, the latest version of xUnit (v2+) runs tests in parallel. This is
    because parallelism can improve the performance of the test. If we have a lot
    of tests, running them in parallel can save a lot of time. Also, it can leverage
    the multi-core CPU to run the tests. However, we need to understand how xUnit
    runs tests in parallel, just in case it causes problems.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，xUnit（v2+）的最新版本会并行运行测试。这是因为并行化可以提高测试的性能。如果我们有很多测试，并行运行它们可以节省大量时间。此外，它还可以利用多核CPU来运行测试。然而，我们需要了解xUnit如何并行运行测试，以防它引起问题。
- en: xUnit uses a concept called **test collection** to represent a group of tests.
    By default, each test class is a unique test collection. Note that the tests in
    the same test class will not run in parallel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit使用一个称为**测试集合**的概念来表示一组测试。默认情况下，每个测试类是一个唯一的测试集合。请注意，同一测试类中的测试不会并行运行。
- en: For example, in the sample project, we can find an `InvoiceControllerTests.cs`
    file and a `ContactControllerTests.cs` file. So, xUnit will run these two test
    classes in parallel, but the tests in the same test class will not run in parallel.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在示例项目中，我们可以找到一个`InvoiceControllerTests.cs`文件和一个`ContactControllerTests.cs`文件。因此，xUnit将并行运行这两个测试类，但同一测试类中的测试不会并行运行。
- en: We also introduced a `TestDatabaseFixture` class in the *Creating a test fixture*
    section. A class fixture is used to share a single test context among all the
    tests in the same test class. So, if we use a class fixture to create a database
    context, the database context will be shared among all the tests in the same test
    class. Currently, we have two test classes that use the `TestDatabaseFixture`
    class to provide the database context. Will xUnit create only one instance of
    the `TestDatabaseFixture` class for these two test classes?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在*创建测试固定装置*部分中引入了`TestDatabaseFixture`类。类固定装置用于在同一个测试类中的所有测试之间共享单个测试上下文。因此，如果我们使用类固定装置来创建数据库上下文，数据库上下文将共享给同一个测试类中的所有测试。目前，我们有两个测试类使用`TestDatabaseFixture`类来提供数据库上下文。xUnit将为这两个测试类创建`TestDatabaseFixture`类的一个实例吗？
- en: 'The answer is no. We can set up a breakpoint in the constructor of the `TestDatabaseFixture`
    class, and then debug the tests by right-clicking `InvoiceApp.UnitTests` in the
    **Test Explorer** window of VS 2022 and then clicking **Debug**, as shown in *Figure
    9**.6*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。我们可以在`TestDatabaseFixture`类的构造函数中设置一个断点，然后在VS 2022的**测试资源管理器**窗口中右键单击`InvoiceApp.UnitTests`，然后点击**调试**来调试测试，如图*图9.6*所示。6*：
- en: '![Figure 9.6 – Debug tests in VS 2022](img/B18971_09_06.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 在VS 2022中调试测试](img/B18971_09_06.jpg)'
- en: Figure 9.6 – Debug tests in VS 2022
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 在VS 2022中调试测试
- en: You will find that the constructor of the `TestDatabaseFixture` class is called
    twice (or more, depending on how many tests use this text fixture). So, we know
    that xUnit will create a new instance of the `TestDatabaseFixture` class for each
    test class as well. That is why we use a lock to ensure that the database is only
    created once. If we do not use the lock, multiple test classes will try to initialize
    the database at the same time, which potentially causes problems.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`TestDatabaseFixture`类的构造函数被调用两次（或更多，取决于使用此测试固定装置的测试数量）。因此，我们知道xUnit将为每个测试类创建`TestDatabaseFixture`类的新实例。这就是我们使用锁来确保数据库只创建一次的原因。如果我们不使用锁，多个测试类将同时尝试初始化数据库，这可能会引起潜在的问题。
- en: In the *Writing tests for methods that change the database* section, we created
    a `TransactionalTestDatabaseFixture` class that can clean up the database. If
    we apply it to one test class, such as `TransactionalInvoiceControllerTests`,
    it will work fine. But what if we want to use it for multiple test classes? By
    default, xUnit will run these test classes in parallel, which means that multiple
    test classes will try to clean up the database at the same time. In this case,
    we do not want to run these test classes in parallel. To do this, we can use the
    `Collection` attribute to group these test classes into one collection so that
    xUnit will not run them in parallel. This can help us avoid the concurrency issue.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在*编写更改数据库的方法的测试*部分，我们创建了一个可以清理数据库的`TransactionalTestDatabaseFixture`类。如果我们将其应用于一个测试类，例如`TransactionalInvoiceControllerTests`，它将正常工作。但如果我们想将其用于多个测试类呢？默认情况下，xUnit将并行运行这些测试类，这意味着多个测试类将同时尝试清理数据库。在这种情况下，我们不希望并行运行这些测试类。为了做到这一点，我们可以使用`Collection`属性将这些测试类分组到一个集合中，这样xUnit就不会并行运行它们。这可以帮助我们避免并发问题。
- en: 'Let’s see an example. In the sample project, you will find that the `ContactController`
    file has a method named `UpdateContactAsync()` that uses a transaction. Again,
    this is not required and is just for demonstration purposes. To use the collection
    fixture, we need to create a definition for the collection. Let’s create a `TransactionalTestsCollection`
    class in the `InvoiceApp.UnitTests` project, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。在示例项目中，你会找到一个名为`UpdateContactAsync()`的方法，它使用事务。这并不是必需的，只是为了演示目的。要使用集合固定件，我们需要为集合创建一个定义。让我们在`InvoiceApp.UnitTests`项目中创建一个`TransactionalTestsCollection`类，如下所示：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this class, we declare that the `TransactionalTestDatabaseFixture` class
    is a collection fixture that uses the `CollectionDefinition` attribute. We also
    specify a name for this collection, which is `TransactionalTests`. Then, we use
    the `ICollectionFixture<T>` interface to specify that the `TransactionalTestDatabaseFixture`
    class is a collection fixture.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，我们声明`TransactionalTestDatabaseFixture`类是一个使用`CollectionDefinition`属性的集合固定件。我们还为这个集合指定了一个名称，即`TransactionalTests`。然后，我们使用`ICollectionFixture<T>`接口来指定`TransactionalTestDatabaseFixture`类是一个集合固定件。
- en: 'After that, we add the `Collection` attribute to the test classes, which specifies
    that the `TransactionalInvoiceControllerTests` and `TransactionalContactControllerTests`
    classes belong to the `TransactionalTests` collection, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在测试类中添加了`Collection`属性，指定`TransactionalInvoiceControllerTests`和`TransactionalContactControllerTests`类属于`TransactionalTests`集合，如下所示：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, if we debug the tests, we will find that the constructor of the `TransactionalTestDatabaseFixture`
    class is only called once, which means that xUnit will only create one instance
    of the `TransactionalTestDatabaseFixture` class for these two test classes. Also,
    xUnit will not run these two test classes in parallel, which means that the `Cleanup`
    method of the `TransactionalTestDatabaseFixture` class will not be called at the
    same time. So, we can use the `TransactionalTestDatabaseFixture` class to clean
    up the database for each test method in multiple test classes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调试测试，我们会发现`TransactionalTestDatabaseFixture`类的构造函数只被调用一次，这意味着xUnit将为这两个测试类只创建一个`TransactionalTestDatabaseFixture`类的实例。此外，xUnit不会并行运行这两个测试类，这意味着`TransactionalTestDatabaseFixture`类的`Cleanup`方法不会同时被调用。因此，我们可以使用`TransactionalTestDatabaseFixture`类为多个测试类中的每个测试方法清理数据库。
- en: 'Let’s summarize the key points of this section:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结本节的关键点：
- en: By default, each test class is a unique test collection
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，每个测试类都是一个唯一的测试集合
- en: The tests in the same test class will not run in parallel
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一测试类中的测试不会并行运行
- en: 'If we want to share a single test context among all the tests within the same
    test class, we can use a class fixture:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在同一测试类中的所有测试之间共享一个单独的测试上下文，我们可以使用类固定件：
- en: xUnit creates a new instance of the test class for each test method
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit为每个测试方法创建一个新的测试类实例
- en: xUnit creates a new instance of the class fixture for each test class and shares
    the same instance among all the tests in the same test class
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit为每个测试类创建一个新的类固定件实例，并在同一测试类中的所有测试之间共享相同的实例
- en: By default, xUnit runs test classes in parallel if they are not in the same
    test collection
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，如果测试类不在同一测试集合中，xUnit将并行运行测试类
- en: If we do not want to run multiple test classes in parallel, we can use the `Collection`
    attribute to group them into one test collection
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不想并行运行多个测试类，可以使用`Collection`属性将它们分组到一个测试集合中
- en: 'If we want to share a single test context among several test classes and clean
    up the test context after each test method, we can use a collection fixture, and
    implement the `IDisposable` interface in each test class to clean up the test
    context:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在几个测试类之间共享单个测试上下文，并在每个测试方法之后清理测试上下文，我们可以使用集合固定实例，并在每个测试类中实现`IDisposable`接口以清理测试上下文：
- en: xUnit creates a new instance of the test class for each test method
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit为每个测试方法创建一个新的测试类实例
- en: xUnit creates only one instance of the collection fixture for the test collection
    and shares the same instance among all the tests in the collection
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit只为测试集合创建一个集合固定实例，并在集合中的所有测试之间共享该实例
- en: xUnit does not run multiple test classes in parallel if they belong to the same
    test collection
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试类属于同一个测试集合，xUnit不会并行运行多个测试类
- en: xUnit provides a lot of features to customize the test execution. If you want
    to learn more about xUnit, you can check out the official documentation at [https://xunit.net/](https://xunit.net/).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit提供了许多功能来自定义测试执行。如果您想了解更多关于xUnit的信息，可以查看官方文档，网址为[https://xunit.net/](https://xunit.net/)
- en: Using the repository pattern
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用存储库模式
- en: So far, you have learned how to use a real database to test the database access
    layer. There is another way to test the database access layer, which is to use
    a repository pattern to decouple the controllers from the `DbContext` class. In
    this section, we will show you how to use the repository pattern to test the database
    access layer.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了如何使用真实数据库来测试数据库访问层。还有另一种测试数据库访问层的方法，即使用存储库模式将控制器与`DbContext`类解耦。在本节中，我们将向您展示如何使用存储库模式来测试数据库访问层。
- en: 'The repository pattern is a common pattern that’s used to separate the application
    and the database access layer. Instead of using `DbContext` directly in the controllers,
    we can add a separate repository layer to encapsulate the database access logic.
    The controllers will use the repository layer to access the database, as shown
    in *Figure 9**.7*:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式是一种常用的模式，用于将应用程序和数据库访问层分离。我们可以在控制器中不直接使用`DbContext`，而是添加一个单独的存储库层来封装数据库访问逻辑。控制器将使用存储库层来访问数据库，如图9.7所示：
- en: '![Figure 9.7– Using the repository pattern](img/B18971_09_07.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7– 使用存储库模式](img/B18971_09_07.jpg)'
- en: Figure 9.7– Using the repository pattern
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7– 使用存储库模式
- en: In *Figure 9**.7*, we can see that the application now has no dependency on
    EF Core. The application (controllers) only depends on the repository layer, and
    the repository layer depends on EF Core. Therefore, the repository layer can be
    mocked in the tests, and the controllers can be tested without a real database.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.7*中，我们可以看到应用程序现在没有对EF Core的依赖。应用程序（控制器）只依赖于存储库层，而存储库层依赖于EF Core。因此，在测试中可以模拟存储库层，而无需真实数据库即可测试控制器。
- en: To learn how to use the repository pattern for testing, you can look at the
    sample project in the `UnitTestsDemo\UnitTest-v2` folder. This project is based
    on the `v1` project, and we have added a repository layer to the project.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用存储库模式进行测试，您可以查看`UnitTestsDemo\UnitTest-v2`文件夹中的示例项目。该项目基于`v1`项目，我们已向项目中添加了存储库层。
- en: 'The `IInvoiceRepository` interface defines the methods of the `Invoice` repository,
    as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`IInvoiceRepository`接口定义了`Invoice`存储库的方法，如下所示：'
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The implementation of the `IInvoiceRepository` interface is in the `InvoiceRepository`
    class; it uses the `DbContext` class to access the database. First, we inject
    the `InvoiceDbContext` class into the `InvoiceRepository` class using the constructor
    injection, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`IInvoiceRepository`接口的实现位于`InvoiceRepository`类中；它使用`DbContext`类来访问数据库。首先，我们使用构造函数注入将`InvoiceDbContext`类注入到`InvoiceRepository`类中，如下所示：'
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we can implement the `IInvoiceRepository` interface in the `InvoiceRepository`
    class. Here is an example of the `GetInvoicesAsync` method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`InvoiceRepository`类中实现`IInvoiceRepository`接口。以下是一个`GetInvoicesAsync`方法的示例：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the `GetInvoiceAsync()` method, we use a `LINQ` query to get the invoice
    by the specified ID. Note that we use the `Include` method to include the `Contact`
    property in the query result. This is because we want to get the contact information
    of the invoice. If we do not want to include the navigation property in the query
    result, we can remove the `Include()` method, or add a parameter to the `GetInvoiceAsync()`
    method to specify whether to include the navigation property. The `Include()`
    method is defined in the `Microsoft.EntityFrameworkCore` namespace, so we need
    to add the `using Microsoft.EntityFrameworkCore;` statement to the `InvoiceRepository.cs`
    file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetInvoiceAsync()`方法中，我们使用`LINQ`查询根据指定的ID获取发票。请注意，我们使用`Include`方法将`Contact`属性包含在查询结果中。这是因为我们想要获取发票的联系人信息。如果我们不希望在查询结果中包含导航属性，我们可以删除`Include()`方法，或者向`GetInvoiceAsync()`方法添加一个参数来指定是否包含导航属性。`Include()`方法定义在`Microsoft.EntityFrameworkCore`命名空间中，因此我们需要在`InvoiceRepository.cs`文件中添加`using
    Microsoft.EntityFrameworkCore;`语句。
- en: 'The implementation of the `GetInvoicesAsync()` method is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInvoicesAsync()`方法的实现如下：'
- en: '[PRE43]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding `GetInvoicesAsync()` method, we use some `LINQ` methods, such
    as `Where()`, `OrderByDescending()`, `Skip()`, and `Take()`, to implement the
    pagination feature. Note that the `ToListAsync()` method is defined in the `Microsoft.EntityFrameworkCore`
    namespace, so do not forget to add the `using` `Microsoft.EntityFrameworkCore;`
    statement.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`GetInvoicesAsync()`方法中，我们使用了一些`LINQ`方法，例如`Where()`、`OrderByDescending()`、`Skip()`和`Take()`来实现分页功能。请注意，`ToListAsync()`方法定义在`Microsoft.EntityFrameworkCore`命名空间中，所以不要忘记添加`using
    Microsoft.EntityFrameworkCore;`语句。
- en: You can find the complete implementation of the `InvoiceRepository` class in
    the `InvoiceRepository.cs` file in the `UnitTestsDemo\UnitTest-v2` folder.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`UnitTestsDemo\UnitTest-v2`文件夹中的`InvoiceRepository.cs`文件中找到`InvoiceRepository`类的完整实现。
- en: The implementation of the repository interface is just a class that uses the
    `DbContext` class to implement the CRUD operations. Generally, this layer does
    not contain any business logic. Also, we should note that the `GetInvoicesAsync()`
    method returns `IEnumerable<Invoice>` instead of `IQueryable<Invoice>`. This is
    because the `IQueryable` interface involves EF Core, but the purpose of using
    the repository pattern is to decouple the application from EF Core. So, we can
    easily mock the repository layer in the tests.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库接口的实现只是一个使用`DbContext`类来实现CRUD操作的类。通常，这一层不包含任何业务逻辑。此外，我们应该注意，`GetInvoicesAsync()`方法返回`IEnumerable<Invoice>`而不是`IQueryable<Invoice>`。这是因为`IQueryable`接口涉及EF
    Core，但使用存储库模式的目的是将应用程序与EF Core解耦。因此，我们可以在测试中轻松模拟存储库层。
- en: 'The controllers now depend on the repository layer, as shown here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器现在依赖于存储库层，如下所示：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, the controller is much cleaner, and there is no dependency on EF Core.
    We can update the tests so that they use the repository layer instead of the `DbContext`
    class. Similar to that in the previous `InvoiceControllerTests`, we may need a
    class fixture to manage the test context, as shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，控制器变得更加简洁，不再依赖于EF Core。我们可以更新测试，使它们使用存储库层而不是`DbContext`类。类似于之前的`InvoiceControllerTests`，我们可能需要一个类固定器来管理测试上下文，如下所示：
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this class fixture, we have added two lists to mock the database tables.
    Next, we can mock the tests, like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类固定器中，我们添加了两个列表来模拟数据库表。接下来，我们可以模拟测试，如下所示：
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this test method, we mock the repository layer and pass it to the controller.
    It follows the concept of the unit tests: focus on the unit under test and mock
    the dependencies. You can check the other tests in the source code and try to
    add more tests to cover the other scenarios, such as creating invoices, updating
    invoices, deleting invoices, and so on. Note that we use two instances of `List<T>`
    to mock the database tables. If the test methods change the data, do not forget
    to restore the data after the test methods are executed.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们模拟存储库层并将其传递给控制器。这遵循了单元测试的概念：关注被测试的单元并模拟依赖项。你可以检查源代码中的其他测试，并尝试添加更多测试以覆盖其他场景，例如创建发票、更新发票、删除发票等。请注意，我们使用两个`List<T>`实例来模拟数据库表。如果测试方法更改了数据，不要忘记在测试方法执行后恢复数据。
- en: The repository pattern is a good practice for decoupling the application from
    the data access layer, and it also makes it possible to replace the data access
    layer with another one. It allows us to mock the database access layer for testing
    purposes. However, it increases the complexity of the application. Also, if we
    use the repository pattern, we may lose some features of EF Core, such as `IQueryable`.
    Finally, the mock behavior may be different from the real behavior. So, we should
    consider the trade-offs before using it.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式是一种将应用程序与数据访问层解耦的良好实践，它还使得用另一个数据访问层替换现有数据访问层成为可能。它允许我们在测试目的下模拟数据库访问层。然而，它增加了应用程序的复杂性。此外，如果我们使用仓库模式，我们可能会丢失EF
    Core的一些功能，例如`IQueryable`。最后，模拟行为可能与实际行为不同。因此，在使用它之前，我们应该考虑权衡利弊。
- en: Testing the happy path and the sad path
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试快乐路径和悲伤路径
- en: 'So far, we have written some tests to cover the happy path. However, we should
    also test the sad path. In testing, the terms **happy path** and **sad path**
    are used to describe different scenarios or test cases:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了一些测试来覆盖快乐路径。然而，我们也应该测试悲伤路径。在测试中，术语**快乐路径**和**悲伤路径**用于描述不同的场景或测试用例：
- en: '`GetInvoiceAsync(Guid id)` method, the happy path is that the invoice with
    the specified ID exists in the database, and the method returns the invoice.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetInvoiceAsync(Guid id)`方法，快乐路径是数据库中存在指定ID的发票，并且方法返回该发票。'
- en: '`GetInvoiceAsync(Guid id)` method, the sad path is that the invoice with the
    specified ID does not exist in the database, and the method returns the `404 Not`
    `Found` error.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetInvoiceAsync(Guid id)`方法，悲伤路径是数据库中不存在指定ID的发票，并且方法返回`404 Not Found`错误。'
- en: 'By combining both happy path and sad path tests, we can ensure that the code
    unit works as expected in different scenarios. Here is an example of a happy path
    for `the GetInvoiceAsync(Guid` `id)` method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合快乐路径和悲伤路径测试，我们可以确保代码单元在不同场景下按预期工作。以下是为`GetInvoiceAsync(Guid id)`方法的快乐路径示例：
- en: '[PRE47]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this test method, we pass the ID of the first invoice in the `Invoices` list
    to the `GetInvoiceAsync(Guid id)` method. Since the invoice with the specified
    ID exists in the database, the method should return the invoice.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们将`Invoices`列表中第一张发票的ID传递给`GetInvoiceAsync(Guid id)`方法。由于指定ID的发票在数据库中存在，该方法应返回该发票。
- en: 'Let’s create a sad path test for the `GetInvoiceAsync(Guid` `id)` method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`GetInvoiceAsync(Guid id)`方法创建一个悲伤路径测试：
- en: '[PRE48]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this test method, we pass a new GUID to the `GetInvoiceAsync(Guid id)` method.
    Since the invoice with the specified ID does not exist in the database, the method
    should return a `404 Not Found` error. We can also create sad path tests for other
    methods.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们将一个新的GUID传递给`GetInvoiceAsync(Guid id)`方法。由于指定ID的发票在数据库中不存在，该方法应返回`404
    Not Found`错误。我们还可以为其他方法创建悲伤路径测试。
- en: Tip
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: What is the difference between `as` and `is` in C#?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: C#中`as`和`is`的区别是什么？
- en: The `as` operator is used to perform conversions between compatible types. If
    the conversion is not possible, the `as` operator returns `null` instead of raising
    an exception. So, in the preceding test, if `result` is not `null`, we can see
    that the result from the controller is `NotFoundResult`, which is the expected
    result.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`运算符用于在兼容类型之间执行转换。如果转换不可行，则`as`运算符返回`null`而不是抛出异常。因此，在前面的测试中，如果`result`不是`null`，我们可以看到控制器返回的结果是`NotFoundResult`，这是预期的结果。'
- en: The `is` operator is used to determine whether an object is compatible with
    a given type. If the object is compatible, the operator will return `true`; otherwise,
    it will return `false`. This is a useful tool for verifying the type of an object
    before performing an operation on it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符用于确定一个对象是否与给定的类型兼容。如果对象兼容，则运算符将返回`true`；否则，它将返回`false`。在执行操作之前验证对象类型是一个有用的工具。'
- en: From C# 7, we can use `is` to check and convert the type at the same time. For
    example, we can use `if (result is NotFoundResult notFoundResult)` to check whether
    `result` is `NotFoundResult`, and convert it into `NotFoundResult` at the same
    time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7开始，我们可以使用`is`同时检查和转换类型。例如，我们可以使用`if (result is NotFoundResult notFoundResult)`来检查`result`是否为`NotFoundResult`，并同时将其转换为`NotFoundResult`。
- en: With that, we have learned how to write unit tests for the controller. You can
    check the other tests in the source code and try to add more tests to cover the
    other scenarios, such as creating invoices, updating invoices, deleting invoices,
    and so on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何为控制器编写单元测试。你可以检查源代码中的其他测试，并尝试添加更多测试以覆盖其他场景，例如创建发票、更新发票、删除发票等。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the fundamentals of unit tests for ASP.NET web
    API applications. We discussed the use of xUnit as the testing framework and `Moq`
    as the mocking framework. We learned how to configure test fixtures with xUnit,
    and how to manage the test data with the test fixture. We also learned how to
    write unit tests to test the data access layer and the controller.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 ASP.NET Web API 应用程序的单元测试基础。我们讨论了使用 xUnit 作为测试框架以及 `Moq` 作为模拟框架。我们学习了如何使用
    xUnit 配置测试固定，以及如何使用测试固定管理测试数据。我们还学习了如何编写单元测试来测试数据访问层和控制器。
- en: Unit tests are a great way to ensure that your code unit is working as expected.
    These tests often use mock objects to isolate the code unit from its dependencies,
    but this cannot guarantee that the code unit works well with its dependencies.
    Therefore, we also need to write integration tests to test if the code units can
    work together with their dependencies. For example, can the controllers handle
    the requests correctly?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是确保你的代码单元按预期工作的一种很好的方式。这些测试通常使用模拟对象来隔离代码单元与其依赖项，但这并不能保证代码单元与其依赖项能良好地协同工作。因此，我们还需要编写集成测试来测试代码单元是否能够与其依赖项协同工作。例如，控制器能否正确处理请求？
- en: In the next chapter, we will learn how to write integration tests for ASP.NET
    web API applications.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何为 ASP.NET Web API 应用程序编写集成测试。
