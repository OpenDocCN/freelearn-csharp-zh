<html><head></head><body>
        

                            
                    <h1 class="header-title">State</h1>
                
            
            
                
<p>In video games, objects continually transition from one state to another depending on events that might be triggered by the player or the game's mechanics.</p>
<p>So, one of the primary responsibilities of a game programmer is to implement a list of finite states and behaviors for entities, ranging from <strong>non-player characters</strong> (<strong>NPCs</strong>) to weapons. These tasks must be accomplished in a way that's maintainable and configurable so that a team of designers can tweak each stateful behavior individually until the game feels balanced.</p>
<p>The State pattern was designed precisely to accomplish this by offering a simple way to encapsulate behaviors into individual classes that represent the specific states of an object.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>The basics of the State pattern</li>
<li>Implementing a collection of finite states for a game involving a spaceship</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The following chapter is hands-on, so you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following Unity-specific engine and C# language concept:</p>
<ul>
<li>Interfaces</li>
</ul>
<p>If you are unfamiliar with this concept, please review it before moving forward with this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2UfzpTD">http://bit.ly/2UfzpTD</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">The basics of the State pattern</h1>
                
            
            
                
<p>The State pattern is very similar to the Strategy pattern in the sense that it permits us to apply behaviors at runtime to a specific object. The core difference is that the State pattern is used when we need to manage an object's internal states, while the Strategy pattern focuses on choosing the right algorithm to execute, depending on the runtime context.</p>
<p>In the context of a class structure for a spaceship project, the following diagram shows how state classes (<kbd>NormalShipState</kbd>, <kbd>AlertShipState</kbd>, and <kbd>DisabledShipState</kbd>) have a standard interface that permits the <kbd>Ship</kbd> class to invoke the behavior of a specific state:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/23d448b1-a72a-4f10-8443-02abb2a98e78.png"/></p>
<p>As we will see in the code example, the concept behind the State pattern is as simple as its actual implementation, because it offers us a way to encapsulate behaviors and apply them, without resorting to long conditional statements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p>It can be challenging to pinpoint the common drawbacks of the State pattern, because managing states are fundamental to game development, so we could say that this pattern is essential and cannot be disregarded.<br/>
<br/>
The following are the benefits of using the State pattern:</p>
<ul>
<li><strong>Encapsulated behaviors</strong>: The State pattern allows us to implement an entity's behaviors as a collection of self-contained components that can be attached dynamically to an object when it changes states.</li>
<li><strong>Reduction of condition blocks</strong>: Using the State pattern reduces the need for huge chunks of <kbd>if-else</kbd> conditions or switching cases, because behaviors can be dynamically assigned depending on an object's internal or global state change.</li>
</ul>
<p>There is only one drawback:</p>
<ul>
<li><strong>Code complexity</strong>: Implementing patterns sometimes results in verbose code bases with a higher number of classes because of encapsulation and highly defined structures</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p>Imagine we are working on a game in which the player controls a spaceship. Our lead designer is still brainstorming ideas on what exactly the spaceship will be able to do in our game. But they ask us to implement at least three core states that our spaceship could be in depending on the result of a space battle against an enemy ship:</p>
<ul>
<li><strong>Normal</strong>: The player's spaceship is running as normal</li>
<li><strong>Alert</strong>: An enemy spaceship is approaching and is ready to attack</li>
<li><strong>Disabled</strong>: The player's spaceship has been defeated in battle and currently cannot move or fight back</li>
</ul>
<p>In each state, there's a specific set of behaviors and actions for the crew members to perform:</p>
<ul>
<li><strong>Normal</strong>: The crew members go into their default positions and perform their assigned duties</li>
<li><strong>Alert</strong>: The crew members run to their assigned combat positions</li>
<li><strong>Disabled</strong>: The crew members run to the escape pods and abandon the ship</li>
</ul>
<p>The most important thing about this list is that it's very generic, which means that we could write those states and behaviors so, we can attach them to any type of ship in our game, including enemy ships. As we will see in the following code example, the State pattern permits us to decouple behaviors from entities, and this is why we can easily have an entity switch between states.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>As described in the use case example, we are going to implement a finite series of states for our spaceship:</p>
<ol>
<li>Let's start by implementing the interface that will be used to define our states:</li>
</ol>
<pre style="padding-left: 60px">public interface IShipState<br/>{<br/>    void Execute(Ship ship);<br/>}</pre>
<p style="padding-left: 60px">As you can see, the <kbd>Execute</kbd> function receives an entity of the <kbd>Ship</kbd> type. This declaration means that we will able to attach and execute our state on any ship, making our code very modular and extendable.</p>
<ol start="2">
<li>Now we are going to define each state and add some contextual code to the <kbd>Execute()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">public class NormalShipState : IShipState<br/>{<br/>    public void Execute(Ship ship)<br/>    {<br/>        ship.LogStatus("NORMAL: ship operating as normal.");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>Normal</kbd> state is our default one, which executes the behaviors of a normally operating ship.</p>
<ol start="3">
<li>Next is the <kbd>Alert</kbd> state. In this context, the crew of the ship and its system are alerted:</li>
</ol>
<pre style="padding-left: 60px">public class AlertShipState : IShipState<br/>{<br/>    public void Execute(Ship ship)<br/>    {<br/>        ship.LogStatus("ALERT: all hands on deck.");<br/>    }<br/>}</pre>
<ol start="4">
<li>Finally, there is the <kbd>Disabled</kbd> state. This means that the ship is unable to move and the crew is fleeing:</li>
</ol>
<pre style="padding-left: 60px">public class DisabledShipState : IShipState<br/>{<br/>    public void Execute(Ship ship)<br/>    {<br/>        ship.LogStatus("DISABLED: crew jumping ship.");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">For our code example, we are making things straightforward by merely implementing some console outputs to indicate the current state, but in a real project, we could easily trigger sound cues, particles, and animations for every state change.</p>
<ol start="5">
<li>Now that we have a collection of states that we can attach to a ship. For the next step, let's write a concrete implementation of the <kbd>Ship</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Ship : MonoBehaviour<br/>{<br/>    private IShipState m_CurrentState;<br/><br/>    void Awake ()<br/>    {<br/>        m_CurrentState = new NormalShipState();<br/>        m_CurrentState.Execute(this);<br/>    }<br/><br/>    public void Normalize()<br/>    {<br/>        m_CurrentState = new NormalShipState();<br/>        m_CurrentState.Execute(this);<br/>    }<br/><br/>    public void TriggerRedAlert()<br/>    {<br/>        m_CurrentState = new AlertShipState();<br/>        m_CurrentState.Execute(this);<br/>    }<br/><br/>    public void DisableShip()<br/>    {<br/>        m_CurrentState = new DisabledShipState();<br/>        m_CurrentState.Execute(this);<br/>    }<br/><br/>    public void LogStatus(string status)<br/>    {<br/>        Debug.Log(status);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Let's review a short list of what we have accomplished with this pattern:</p>
<ul>
<li style="padding-left: 30px">We have eliminated the need for switch cases or <kbd>if-elses</kbd> to manage the transition between the ship's stateful behaviors.</li>
<li style="padding-left: 30px">We have decoupled the ship's behaviors into self-contained components that we can attach dynamically to any type of ship.</li>
</ul>
<p style="padding-left: 60px">These small benefits have given us a considerable amount of flexibility, and we can now write behaviors as individual components. This means we could have one colleague working on the <kbd>Alert</kbd> state while another refactors the <kbd>Disabled</kbd> state, without interfering with each other's work.</p>
<ol start="6">
<li>And the final part of our code example is our <kbd>Client</kbd>, a class that we will use to test each state by triggering them with the user's input:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    public Ship ship;<br/><br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown("n"))<br/>        {<br/>            ship.Normalize();<br/>        }<br/>        <br/>        if (Input.GetKeyDown("a"))<br/>        {<br/>            ship.TriggerRedAlert();<br/>        }<br/><br/>        if (Input.GetKeyDown("d"))<br/>        {<br/>            ship.DisableShip();<br/>        }<br/>    }<br/>}</pre>
<p>In this example, we are manually triggering the ship's finite states, but we could have easily used events or a health system to trigger them. In other words, by using the State pattern, we have been given the flexibility to attach multiple stateful behaviors to any entity and trigger them dynamically through any type of mechanism, without having to write long and complex conditional statements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we reviewed a pattern that's the cornerstone of game development. We now have the ability to encapsulate stateful behaviors into individual components that can be assigned dynamically to an object depending on its state. We have reduced our dependency on long conditional statements and have a consistent approach to structuring our code that's related to behaviors and state management.</p>
<p>In the next chapter, we are going to review the Visitor pattern, a unique pattern that gives us the ability to decouple algorithms from an object's structure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<p class="mce-root">A conventional technique in video games to make entities feel less mechanical in the way they behave is to ease out the transition between states. For example: instead of having a patrolling enemy character transitioning immediately from a passive to an aggressive state when they detect the player's character, there could be a short animation sequence in between states, showing the enemy going into an alert stance before attacking.<br/>
<br/>
As an exercise, I would recommend experimenting with the concept of integrating transitional states between each finite state of the spaceship and find a solution to make the transition between them blend seamlessly.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p><em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, by Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm<br/>
(<a href="http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610">http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610</a>)<a href="http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610"/></p>


            

            
        
    </body></html>