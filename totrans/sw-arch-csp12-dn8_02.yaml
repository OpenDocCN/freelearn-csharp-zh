- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-Functional Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have gathered the system requirements, it is time to think about the
    impact they have on the architectural design. Scalability, availability, resiliency,
    performance, multithreading, interoperability, security, and other aspects need
    to be analyzed so that we can meet user needs. We refer to these aspects as non-functional
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling scalability, availability, and resiliency with Azure and .NET 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance issues that need to be considered when programming in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Software usability: how to design effective user interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability with .NET 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving security by design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main purpose of discussing non-functional requirements here is that they
    are highly relevant to software architects: even though they are not so important
    to getting the software working in terms of functionality, they can make all the
    difference when comparing good software and bad software.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The samples provided in this chapter require Visual Studio 2022 Community Edition
    with the .NET 8 SDK installed.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling scalability, availability, and resiliency with Azure and .NET 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick search online for a definition of “scalability” returns something along
    the lines of “the ability of a system to keep working well when there is an increase
    in demand.” When developers go by this definition, many of them incorrectly conclude
    that scalability only means adding more hardware to keep things working without
    stopping their apps.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability relies on hardware solutions to some extent. However, as a software
    architect, you need to be aware that good software will keep scalability in a
    sustainable model, which means that well-architected software can save a lot of
    money. Hence, scalability is not just a matter of hardware but also a matter of
    overall software design. The point here is that the running costs of a system
    should also be a factor in architectural decisions.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Understanding the Importance of Software Architecture*, while
    discussing software performance, we presented some good tips to overcome performance
    issues. The same tips will help you with scalability, too. The fewer resources
    we spend on each process, the more users an application can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Although scalability is important, cloud computing applications must be designed
    to work with system failures. Every time you guarantee that your application can
    recover from a failure without exposing the failure to the end user, you are creating
    a resilient application.
  prefs: []
  type: TYPE_NORMAL
- en: You may find cloud architecture resiliency patterns at [https://docs.microsoft.com/en-us/azure/architecture/framework/resiliency/reliability-patterns#resiliency](https://docs.microsoft.com/en-us/azure/architecture/framework/resiliency/reliability-patterns#resiliency).
  prefs: []
  type: TYPE_NORMAL
- en: The reason why resiliency is especially important in cloud scenarios is that
    the infrastructure provided to you may need a small amount of time to manage updates,
    resets, and even hardware upgrades. You are also more likely to have to work with
    multiple systems, and transient errors are likely to occur in communicating with
    them. That is why the non-functional requirement of resiliency has gained a higher
    profile in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: The possibility of having scalable and resilient solutions gets more exciting
    when you can enable high availability in the system. All the approaches presented
    in this book will help you to design solutions with good availability, but in
    some cases, you will need to design specific alternatives to achieve your specific
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth knowing that Azure and .NET 8 web apps can be configured to achieve
    these non-functional requirements. Let us check this out in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scalable web app in Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is simple to create a web app in Azure that is ready for scaling. The reason
    why you must do so is to be able to maintain different numbers of users during
    different seasons. The more users you have, the more hardware you will need. Let
    us show you how to create a scalable web application in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you log in to your Azure account, you will be able to create a new
    resource (web app, database, virtual machine, and so on), as you can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Microsoft Azure – Create a resource'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you can select **App Services in Popular Options** or even type
    it into the **Search the Marketplace** textbox. Then, you can choose to create
    a **web app**. This action will take you to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Microsoft Azure – Creating a web app'
  prefs: []
  type: TYPE_NORMAL
- en: 'The required **Project Details** are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subscription**: This is the account that will be charged for all application
    costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Group**: This is the collection of resources you can define to organize
    policies and permissions. You may specify a new resource group name or add the
    web app to a group specified during the definition of other resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides these, the **Instance Details** are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: As you can see, the web app name is the URL that your solution will
    assume after its creation. The name must be globally unique and is checked to
    ensure it is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish**: This parameter indicates whether the web app will be delivered
    directly, a static web app, or whether it is going to use Docker technology to
    publish content. Docker will be discussed in more detail in *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*. If you opt for the
    Docker container publication, you will be able to configure the **Image Source**,
    **Access Type**, and **Image** and tag information to have it deployed to the
    web app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime stack**: This option is obviously only available when you decide
    to deliver code directly. You could define stacks for .NET, Go, Java, Node.js,
    PHP, Python, and Ruby.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating System**: This is the option for defining the OS that will host
    the web app. Both Windows and Linux may be used for .NET projects in the newest
    versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Region**: You may consider where you want to deploy your application; Azure
    has many different data centers all over the world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing Plans**: This is where you define the hardware plan that is used
    to handle the web app and the region of the servers. This choice defines application
    scalability, performance, and costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone redundancy:** Starting with premium pricing plans, you will be able
    to activate zone redundancy, which will increase the availability of the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment:** It is possible to define the GitHub repository that is responsible
    for continuously deploying the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking:** You may select the network behavior of the application according
    to its requirements and proposal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: This is a useful Azure toolset for monitoring and troubleshooting
    web apps. In this section, you can enable **Application Insights**. It is always
    recommended that you keep the same regions for the different components of your
    solution since this will save costs in terms of traffic exchange from one data
    center to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have created your web app, this application may be scaled in two conceptually
    different ways: vertically (**scale up**) and horizontally (**scale out**). Both
    are available in the web app settings, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Scaling options for web apps'
  prefs: []
  type: TYPE_NORMAL
- en: Let us check out the two types of scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scaling (scaling up)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scaling up means changing the specification of the hardware that will host
    your application. In Azure, you have the opportunity to start with free, shared
    hardware and move to an isolated machine in a few clicks. The following screenshot
    shows the user interface for scaling up a web app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Vertical scaling options'
  prefs: []
  type: TYPE_NORMAL
- en: By choosing one of the options provided, you can select more powerful hardware
    (machines with more CPUs, storage, and RAM). Monitoring your application and its
    App Service plan will guide you on how to decide the best infrastructure for running
    your solution. It will also offer key insights, such as possible CPU, memory,
    and I/O bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling (scaling out)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scaling out means splitting requests between more servers and using the same
    capacity instead of using more powerful machines. The load on all the servers
    is automatically balanced by the Azure infrastructure. This solution is advised
    when the overall load may change considerably in the future since horizontal scaling
    can automatically adapt to a given load. The following screenshot shows an automatic
    **Scale out** strategy defined by two simple rules, triggered by CPU usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Horizontal scaling sample'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth highlighting that you can choose to have a hardcoded instance count
    or implement rules for automatic scale in/out.
  prefs: []
  type: TYPE_NORMAL
- en: A complete description of all the available autoscale rules is beyond the scope
    of this book. However, they are quite self-explanatory, and the *Further reading*
    section contains links to the full documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The **Scale out** feature is only available in paid service plans.
  prefs: []
  type: TYPE_NORMAL
- en: In general, horizontal scaling is a way to guarantee availability in an application
    even with several simultaneous accesses. For sure, its use is not the only way
    to keep a system available, but it does help.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scalable web app with .NET 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among all the available frameworks for implementing web apps, running web apps
    with ASP.NET Core in .NET 8 ensures good performance, together with low production
    and maintenance costs. The union of C#, a strongly typed and advanced general-purpose
    language, and continuous performance improvements achieved in ASP.NET Core distinguish
    this option as one of the best for enterprise development.
  prefs: []
  type: TYPE_NORMAL
- en: The steps in this section will guide you through the creation of an ASP.NET
    Core Runtime 8-based web app. All the steps are quite simple, but some details
    require particular attention.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that .NET 8 gives you the opportunity to develop for
    any platform – desktops (WPF, Windows Forms, and UWP), web (ASP.NET), cloud (Azure),
    mobile (Xamarin), gaming (Unity), IoT (ARM32 and ARM64), or AI (ML.NET and .NET
    for Apache Spark). So, the recommendation from now on is to only use .NET 8\.
    In this scenario, you can run your web app on either Windows servers or cheaper
    Linux servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, Microsoft recommends classic .NET, just in case the features you
    need are not available in .NET Core/5+ or you are deploying your web app in an
    environment that does not support .NET Core. In any other case, you should prefer
    .NET Core/5+ because it allows you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run your web app in Windows, Linux, macOS, or Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design your solution with microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have high-performance and scalable systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers and microservices will be covered in *Chapter 11*, *Applying a Microservice
    Architecture to Your Enterprise Application*. There, you will get a better understanding
    of the advantages of these technologies. For now, it is enough to say that .NET
    8 and microservices were designed for performance and scalability, which is why
    you should prefer .NET 8 in all your new projects. Besides, .NET 8 is guaranteed
    by Microsoft as a Long Term Support version, which means three years of patches
    and free support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: .NET 8 support policy'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following procedure will show you how to create an ASP.NET Core web app
    in Visual Studio 2022 with .NET 8:'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you start VS 2022, you will be able to click on **Create a new project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you select **ASP.NET Core Web App**, you will be directed to a screen
    where you will be asked to set up **Project name**, **Location**, and **Solution
    name**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Creating an ASP.NET Core web application'
  prefs: []
  type: TYPE_NORMAL
- en: After that, you will be able to select the .NET version to use. Select **.NET
    8.0** to get the most advanced and up-to-date platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** to create your ASP.NET Core 8 web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you are done with adding the basic details, you can connect your web
    app project to your Azure account and publish it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you right-click the project you created in Solution Explorer, you have the
    option to **Publish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will find different targets in terms of where to publish your web app.
    Select **Azure** as the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Targeting Azure to publish the app'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will be able to decide the specific target to publish. Select **Azure
    App Service (Windows)** for this demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may be required to define your Microsoft Account credentials at this time.
    This is because there is full integration between Visual Studio and Azure. This
    gives you the opportunity to view all the resources you created in the Azure portal
    in your development environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Integration between Visual Studio and Azure'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create a new web app using Visual Studio, make sure to select
    the **Free Size** tier of pricing during the App Service creation process so that
    this does not incur any costs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Creating a New Hosting Plan'
  prefs: []
  type: TYPE_NORMAL
- en: The usual way to deploy using Visual Studio is by selecting **Publish Profile**,
    which generates a `.pubxml` file, which is a Visual Studio publish profile. In
    this case, you currently have two modes for deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first, **Framework-dependent**, will require a web app configured with
    the target framework. The second, **Self-contained**, will not need this feature
    since the binaries of the framework will be published together with the application.
    Once the file is created and the options are selected, you just click on the **Publish**
    button, and the process will start:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B19820_02_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2.11: Publish profile web deploy'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is worth mentioning that to publish ASP.NET Preview versions in **Framework-dependent**
    mode, you must add an extension in the web app setup panel in the Azure portal,
    as shown in the following screenshot. However, consider using **Self-contained**
    mode, especially when you are under preview versions and using Windows apps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Adding extensions in Azure App Service'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on deploying ASP.NET Core 8.0 to Azure App Service, please
    refer to the following link: [https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-8.0&tabs=visual-studio](https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-8.0&tabs=visual-studio).'
  prefs: []
  type: TYPE_NORMAL
- en: Although publishing using Visual Studio 2022 may be considered a good option
    for demonstration, in the real world, it is almost impossible to keep your publishing
    strategy using it. For this reason, you might consider using a CI/CD flow based
    on GitHub Actions, which automatically enables deployment on the code being pushed
    to a GitHub repo. It is worth mentioning that you must be connected to a GitHub
    repo to access this new function. Let us use this new feature for this demonstration.
    We will discuss it in more depth in *Chapter 8**, Understanding DevOps Principles
    and CI/CD*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Deploying a web app using GitHub actions'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have pushed your code, you can go to the GitHub Actions pane and select
    the way you want to deploy the web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this second demo, you can select **Deploy a .NET Core app to an Azure Web
    App**. With this option, you will have a YAML file created with all the instructions
    needed to connect your code to the web app.![](img/B19820_02_14.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.14: YAML file used to deploy the application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on the web app you want to deploy, you will need a different script.
    These scripts are documented at [https://github.com/Azure/webapps-deploy](https://github.com/Azure/webapps-deploy).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have set the correct script, you will be able to check the execution
    of the GitHub Action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_02_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: GitHub Actions tab'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we described two ways to deploy a web app. In *Chapter 8**, Understanding
    DevOps Principles and CI/CD*, we will go further into **Continuous Integration/Continuous
    Delivery** (**CI/CD**) strategies to guarantee all the steps required to get an
    application to production, that is, building, testing, deployment to staging,
    and deployment to production.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned a great way to make your web apps run on Azure, using
    Visual Studio as a helpful tool, it is essential to understand some performance
    issues that may cause struggles while creating a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Performance issues that need to be considered when programming in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, C# is one of the most used programming languages in the world, so
    awareness of C# programming best practices is fundamental for the design of good
    architectures that satisfy the most common non-functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections mention a few simple but effective tips – the associated
    code samples are available in this book’s GitHub repository. It is worth mentioning
    that .NET Foundation has developed a library dedicated to benchmarking called
    BenchmarkDotNet. You may find it useful for your scenarios. Check it out at [https://benchmarkdotnet.org/](https://benchmarkdotnet.org/).
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a classic one! A naive concatenation of strings with the `+` string
    operator may cause serious performance issues since every time two strings are
    concatenated; their contents are copied into a new string.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we concatenate, for instance, 10 strings that have an average length
    of 100, the first operation has a cost of 200, the second one has a cost of `200+100=300`,
    the third one has a cost of `300+100=400`, and so on. It is not difficult to convince
    yourself that the overall cost grows as `m*n`², where `n` is the number of strings
    and `m` is their average length. `n`² is not too big for small `n` (say, `n <
    10`), but it becomes quite big when `n` reaches the magnitude of 100-1,000 and
    is unacceptable for magnitudes of 10,000-100,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at this with some test code that compares naive concatenation with
    the same operation but performed with the help of the `StringBuilder` class (the
    code is available in this book’s GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19820_02_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Concatenation test code result'
  prefs: []
  type: TYPE_NORMAL
- en: If you create a `StringBuilder` class with something like `var sb = new System.Text.StringBuilder()`,
    and then you add each string to it with `sb.Append(currString)`, the strings are
    not copied; instead, their pointers are queued in a list. They are copied in the
    final string just once when you call `sb.ToString()` to get the final result.
    Accordingly, the cost of `StringBuilder`-based concatenation grows simply as `m*n`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you will probably never find a piece of software with a function
    like the preceding one that concatenates 100,000 strings. However, you need to
    recognize pieces of code like these where the concatenation of some 20-100 strings,
    say, in a web server that handles several requests simultaneously might cause
    bottlenecks that damage your non-functional requirements for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Always remember that exceptions are much slower than normal code flow! So, the
    usage of `try-catch` needs to be concise and essential; otherwise, you will have
    big performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two samples compare the usage of `try-catch` and `Int32.TryParse`
    to check whether a string can be converted into an integer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function does not look dangerous, but it is thousands of times slower
    than the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19820_02_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Exception test code result'
  prefs: []
  type: TYPE_NORMAL
- en: To sum this up, exceptions must be used to deal with exceptional cases that
    break the normal flow of control, for instance, situations when operations must
    be aborted for some unexpected reasons, and control must be returned several levels
    up in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading environments for better results – dos and don’ts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to take advantage of all the hardware that the system you are building
    provides, you must use multithreading. This way, when a thread is waiting for
    an operation to complete, the application can leave the CPU to other threads instead
    of wasting CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, no matter how hard Microsoft works to help with this, parallel
    code is not as simple as eating a piece of cake: it is error-prone and difficult
    to test and debug. The most important thing to remember as a software architect
    when you start considering using threads is *does your system require them?* Non-functional
    and some functional requirements will answer this question for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you are sure that you need a multithreading system, you should decide
    on which technology is more adequate. There are a few options here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an instance of** `System.Threading.Thread`: This is a classic way
    of creating threads in C#. The entire thread life cycle will be in your hands.
    This is good when you are sure about what you are going to do, but you need to
    worry about every single detail of the implementation. The resulting code is hard
    to conceive and debug/test/maintain. So, to keep development costs acceptable,
    this approach should be confined to a few fundamental, performance-critical modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing threads using** `System.Threading.ThreadPool`: You can reduce the
    complexity of this implementation by using the `ThreadPool` class. Especially
    if you intend to develop a solution in which you will have many threads being
    executed, this could be a good option. It is worth mentioning that the .NET thread
    pool has been re-implemented in .NET 6 as a C# class, which will bring new possibilities
    for experimentation or customization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming using** `System.Threading.Tasks.Parallel` classes: Since .NET
    Framework 4.0, you can use parallel classes to enable threads in a simpler way.
    This is good because you do not need to worry about the life cycle of the threads
    you create, but it will give you less control over what is happening in each thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developing using asynchronous programming**: This is, for sure, the easiest
    way to develop multithreaded applications since the compiler takes on most of
    the work. Depending on the way you call an asynchronous method, you may have the
    `Task` created running in parallel with the `Thread` that was used to call it
    or even keep that `Thread` waiting without suspending for the `Task` that was
    created to conclude. This way, asynchronous code mimics the behavior of classical
    synchronous code while keeping most of the performance advantages of general parallel
    programming:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overall behavior is deterministic and does not depend on the time taken
    by each task to complete, so non-reproducible bugs are less likely to happen,
    and the resulting code is easy to test/debug/maintain. Defining a method as an
    asynchronous task or not is the only choice left to the programmer; everything
    else is automatically handled by the runtime. The only thing you should be concerned
    about is which methods should have asynchronous behavior. It is worth mentioning
    that defining a method as `async` does not mean it will execute on a separate
    thread. You may find useful information in a great sample at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this book, we will provide some simple examples of asynchronous programming.
    For more information about asynchronous programming and its related patterns,
    please check out *Task-Based Asynchronous Patterns* in the Microsoft documentation
    ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TAP** is the evolution of **EAP** (**Event-Based Asynchronous Pattern**),
    which, in turn, is the successor to **APM** (**Asynchronous Programming Model
    Pattern**).'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'No matter the option you choose, there are some dos and don’ts that, as a software
    architect, you must pay attention to. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do use concurrent collections** (`System.Collections.Concurrent`): As soon
    as you start a multithreading application, you have to use these collections.
    The reason for this is that your program will probably manage the same list, dictionary,
    and so on from different threads. The use of concurrent collections is the most
    convenient option for developing thread-safe programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do worry about static variables**: It is not possible to say that static
    variables are prohibited in multithreading development, but you should pay attention
    to them. Again, multiple threads taking care of the same variable can cause a
    lot of trouble. If you decorate a static variable with the `[ThreadStatic]` attribute,
    each thread will see a different copy of that variable, hence solving the problem
    of several threads competing on the same value. However, `ThreadStatic` variables
    cannot be used for extra-thread communications since values written by a thread
    cannot be read by other threads. In asynchronous programming, `AsyncLocal<T>`
    is the option for doing something like that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do test system performance after multithreading implementations**: Threads
    give you the ability to take full advantage of your hardware, but in some cases,
    badly written threads can waste CPU time just doing nothing! Similar situations
    may result in almost 100% CPU usage and unacceptable system slowdowns. In some
    cases, the problem can be mitigated or solved by adding a simple `Thread.Sleep(1)`
    call in the main loop of some threads to prevent them from wasting too much CPU
    time, but you need to test this. A use case for this implementation is a Windows
    service with many threads running in the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not consider multithreading easy**: Multithreading is not as simple as
    it seems in some syntax implementations. While writing a multithreading application,
    you should consider things such as the synchronization of the user interface,
    threading termination, and coordination. In many cases, programs just stop working
    well due to bad implementation of multithreading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not forget to plan the number of threads your system should have**: This
    is especially important for 32-bit programs. There is a limitation regarding how
    many threads you can have in any environment. You should consider this when you
    are designing your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not forget to end your threads**: If you do not have the correct termination
    procedure for each thread, you will probably have trouble with memory and handling
    leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability, performance tips, and multithreading are the main tools we can
    use to tune machine performance. However, the effectiveness of the system you
    design depends on the overall performance of the entire processing pipeline, which
    includes both humans and machines. For this reason, in the next section, we will
    discuss how to design effective user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software usability: how to design effective user interfaces'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a software architect, you cannot improve the performance of humans, but
    you can improve the performance of human-machine interaction by designing an effective
    **user interface** (**UI**), that is, a UI that ensures fast interaction with
    humans, which, in turn, means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The UI must be easy to learn to reduce the time that is needed for the target
    users to learn how to operate it. This constraint is fundamental if UI changes
    are frequent and for public websites that need to attract the greatest possible
    number of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI must not cause any kind of slowdown in data insertion; data entry speed
    must be limited only by the user’s ability to type, not by system delays or additional
    gestures that could be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we must also consider the accessibility aspects of our solutions since
    doing so allows us to include more users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is worth mentioning that we have UX experts in the market. As a software
    architect, you must decide when they are essential to the success of the project.
    The following are a few simple tips when it comes to designing *easy-to-learn*
    user interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Each input screen must state its purpose clearly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the language of the user, not the language of developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid complications. Design the UI with the average case in mind; more complicated
    cases can be handled with extra inputs that appear only when needed. Split complex
    screens into more input steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use past inputs to understand user intentions and to put users on the right
    path with messages and automatic UI changes, for instance, cascading drop-down
    menus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error messages are not bad notes that the system gives to the users who do something
    that’s wrong, but they must explain how to insert the correct input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fast UIs result from efficacious solutions to the following three requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Input fields must be placed in the order they are usually filled, and it should
    be possible to move to the next input with the *Tab* or *Enter* key. Moreover,
    fields that often remain empty should be placed at the bottom of the form. Simply
    put, the usage of the mouse while filling in a form should be minimized. This
    way, the number of user gestures is kept to a minimum. In a web application, once
    the optimal placement of input fields has been decided, it is enough to use the
    `tabindex` attribute to define the right way for users to move from one input
    field to the next with the *Tab* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System reactions to user input must be as fast as possible. Error messages (or
    information ones) must appear as soon as the user leaves the input field. The
    simplest way to achieve this is to move most of the help and input validation
    logic to the client side so that system reactions do not need to pass through
    both communication lines and servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Efficacious selection logic: Selecting an existing item should be as easy as
    possible; for example, selecting one out of some thousands of products in an offer
    must be possible with a few gestures and with no need to remember the exact product
    name or its barcode. The next subsection analyzes techniques we can use to decrease
    complexity to achieve fast selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Chapter 19**, Client Frameworks: Blazor*, we will discuss how this Microsoft
    technology can help us with the challenges of building web-based applications
    with C# code in the frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing fast selection logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When all possible choices are in the order of magnitude of 1-50, the usual
    drop-down menu is enough. For instance, take this currency selection drop-down
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing calendar  Description automatically generated](img/B19820_02_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Simple drop-down menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the order of magnitude is higher but less than a few thousand, an autocomplete
    that shows the names of all the items that start with the characters typed by
    the user is usually a good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B19820_02_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Complex drop-down menu'
  prefs: []
  type: TYPE_NORMAL
- en: A similar solution can be implemented with a low computational cost since all
    the main databases can efficiently select strings that start with a given substring.
  prefs: []
  type: TYPE_NORMAL
- en: When names are quite complex, when searching for the characters that were typed
    in by the user, they should be extended inside each item string. This operation
    cannot be performed efficiently with the usual databases and requires ad hoc data
    structures, nor can we forget the debouncing aspect that can happen while typing
    as a performance issue.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we are searching inside descriptions composed of several words,
    more complex search patterns are needed. This is the case, for instance, with
    product descriptions. If the chosen database supports full-text search, the system
    can efficiently search for the occurrence of several words that have been typed
    by the user inside all the descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: However, when descriptions are made up of names instead of common words, it
    might be difficult for the user to remember a few exact names contained in the
    target description. This happens, for instance, with multi-country company names.
    In these cases, we need algorithms that find the best match for the character
    that was typed by the user. Substrings of the string that was typed by the user
    must be searched in different places of each description. In general, similar
    algorithms cannot be implemented efficiently with databases based on indexes but
    require all the descriptions to be loaded in memory and ranked somehow against
    the string that was typed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The most famous algorithm in this class is probably the **Levenshtein** algorithm,
    which is used by most spellcheckers to find a word that best fits the one that
    was mistyped by the user. This algorithm minimizes the Levenshtein distance between
    the description and the string typed by the user, that is, the minimum number
    of character removals and additions needed to transform one string into another.
  prefs: []
  type: TYPE_NORMAL
- en: The Levenshtein algorithm works great but has a very high computational cost.
    Here, we use a faster algorithm that works well for searching character occurrences
    in descriptions. Characters typed by the user do not need to occur consecutively
    in the description but must occur in the same order. Some characters may be missing.
    Each description is given a penalty that depends on the missing characters and
    on how far the occurrences of the characters typed by the user are from the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, the algorithm ranks each description with two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of characters typed by the user that occurs in the description:
    the more characters contained in the description, the higher its rank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each description is given a penalty equal to the total distance among the occurrences
    of the characters typed by the user in the description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the word **Ireland** is ranked against the
    string **ilad**, which was typed by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B19820_02_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: Sample of Levenshtein usage'
  prefs: []
  type: TYPE_NORMAL
- en: The number of occurrences is four, while the total distance between character
    occurrences is three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the descriptions have been rated, they are sorted according to the
    number of occurrences. Descriptions with the same number of occurrences are sorted
    according to the lowest penalties. The following is an autocomplete that implements
    the preceding algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B19820_02_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: Levenshtein algorithm UI experience'
  prefs: []
  type: TYPE_NORMAL
- en: The full class code, along with a test console project, is available in this
    book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from a huge number of items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, *huge* does not refer to the amount of space needed to store the data
    but to the difficulty the user has in remembering the features of each item. When
    an item must be selected from among more than 10,000-100,000 items, there is no
    hope of finding it by searching for character occurrences inside a description.
    Here, the user must be driven toward the right item through a hierarchy of categories.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, several user gestures are needed to perform a single selection.
    In other words, each selection requires interaction with several input fields.
    Once it is decided that the selection can’t be done with a single input field,
    the simplest option is cascading drop-down menus, that is, a chain of drop-down
    menus whose selection list depends on the values that were selected in the previous
    drop-down menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the user needs to select a town located anywhere in the world,
    we may use the first drop-down menu to select the country, and once the country
    has been chosen, we may use this choice to populate a second one with all the
    towns in the selected country. A simple example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.22: Cascading drop-down menu example'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, each drop-down menu can be replaced by an autocomplete when required
    due to having a high number of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If making the right selection can be done by intersecting several different
    hierarchies, cascading drop-down menus become inefficient too, and we need a filter
    form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_02_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.23: Filter form sample'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us understand interoperability with .NET 6.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability with .NET 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since .NET Core, Microsoft has brought to C# developers the ability to deliver
    their software to various platforms. And you, as a software architect, need to
    pay attention to this, considering developing for Linux and macOS as a great opportunity
    to deliver new features to your customers. Therefore, we need to ensure performance
    and multi-platform support, two common non-functional requirements for many systems.
  prefs: []
  type: TYPE_NORMAL
- en: Both console applications and web apps designed with .NET 8 in Windows are almost
    completely compatible with Linux and macOS, too. This means you do not have to
    build the app again to run it on these platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft offers scripts to help you install .NET on Linux and macOS. You can
    find them at [https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script).
    Once you have the SDK installed, you just need to call `dotnet` the same way you
    do in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: However, you must be aware of some features that are not fully compatible with
    Linux and macOS systems. For instance, no equivalent to the Windows Registry exists
    in these OSes, and you must develop an alternative yourself. If needed, an encrypted
    JSON config file can be a good option.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is that Linux is case-sensitive, while Windows is not.
    Please remember this when you work with files. Another important thing is that
    the Linux path separator is different from the Windows separator. You can use
    the `Path.PathSeparator` field and all the other `Path` class members to ensure
    your code is multi-platform. `Environment.NewLine` can also be useful in some
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, you can also adapt your code to the underlying OS by using the runtime
    checks provided by .NET 8, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip – creating a service in Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some good ways to create a service when you are developing on Windows,
    but how can we get the same result if we are developing for the Linux platform?
    The following script can be used to encapsulate a command-line .NET 8 app in Linux.
    The idea is that this service works like a Windows service. This can be useful,
    considering that most Linux installations are command-line-only and run without
    a user logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a file that will run the command-line app. The
    name of the app is `app.dll`, and it is installed in `appfolder`. The application
    will be checked every 5,000 milliseconds. This service was created on a CentOS
    7 system. Using a Linux terminal, you can type this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the file has been created, you must copy the service file to a system
    location. After that, you must reload the system and enable the service so that
    it will restart on reboots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Done! Now, you can start, stop, and check the service using the following commands.
    The whole input that you need to provide in your command-line app is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have learned about a few concepts, let us learn how to implement
    them in our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving security by design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen up to this point in the book, the opportunities and techniques
    we have for developing software are incredible. If you add all the information
    you will read about in relation to cloud computing in the next chapters, you will
    see that the opportunities just increase, as does the complexity involved in maintaining
    this computing environment.
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must understand that these opportunities come with
    many responsibilities. The world has changed a lot in recent years. The second
    decade of the 21st century has required lots of technology. Apps, social media,
    Industry 4.0, big data, and artificial intelligence are no longer future objectives
    but current projects that you will lead and deal with within your daily routine.
    However, the third decade of our century will require much more attention when
    it comes to cybersecurity.
  prefs: []
  type: TYPE_NORMAL
- en: The world now regulates companies that manage personal data. For instance, the
    GDPR – the General Data Protection Regulation – is mandatory not only for European
    territory but also for the whole world; it has changed the way software is developed.
    There are many initiatives comparable to the GDPR that must be added to your glossary
    of techniques and regulations, considering that the software you design will be
    impacted by them.
  prefs: []
  type: TYPE_NORMAL
- en: Security by design must be one of your areas of focus for designing new applications.
    This subject is huge, and it is not going to be completely covered in this book,
    but as a software architect, you must understand the necessity of having a specialist
    in the information security area in your team to guarantee the policies and practices
    needed to avoid cyber-attacks and maintain the confidentiality, privacy, integrity,
    authenticity, and availability of the services you architect.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to protecting your ASP.NET Core application, it is worth mentioning
    that the framework has many features to help you out with that. For instance,
    it includes authentication and authorization patterns. In the OWASP Cheat Sheet
    Series, you can read about many other .NET practices.
  prefs: []
  type: TYPE_NORMAL
- en: The **Open Web Application Security Project**® (**OWASP**) is a nonprofit foundation
    that works to improve the security of software. Check it out at [https://owasp.org/](https://owasp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core also provides features to help us out with the GDPR. Basically,
    there are APIs and templates to guide you in the implementation of policy declaration
    and cookie usage consent.
  prefs: []
  type: TYPE_NORMAL
- en: List of practices for achieving a safe architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following list of practices related to security certainly does not cover
    the entirety of the subject. However, these practices will help you, as a software
    architect, to explore some solutions related to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define an authentication method for your web app. There are many authentication
    options available nowadays, from ASP.NET Core Identity to external provider authentication
    methods, such as Facebook or Google. As a software architect, you must consider
    who the target audience of the application is. It would also be worth considering
    using Azure **Active Directory** (**AD**) as a starting point if you choose to
    go down this route.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it useful to design authentication associated with Azure AD, a
    component for managing the Active Directory of the company you are working for.
    This alternative is pretty good in some scenarios, especially for internal usage.
    Azure currently offers Active Directory for usage as **B2B** (**Business to Business**)
    or **B2C** (**Business to Consumer**).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the scenario of the solution you are building, you might need to
    implement **MFA** – **Multi-Factor Authentication**. The idea of this pattern
    is to ask for at least two forms of proof of identity before allowing the solution
    to be used. It is worth mentioning that Azure AD facilitates this for you.
  prefs: []
  type: TYPE_NORMAL
- en: You may also find it useful to implement authentication to your platform using
    as basis **Microsoft Identity Platform**. In this case, the usage of the **Microsoft
    Authentication Library** (**MSAL**) will facilitate your work hugely. Check how
    to implement it by reading its documentation at [https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview](https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview).
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget that you must determine an authentication method for the APIs
    you provide. JSON Web Token is a pretty good pattern, and its usage is totally
    cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must determine the authorization model you will use in your web app. There
    are four model options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple**, where you just use the `[Authorize]` attribute in the class or
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role-based**, in which you may declare `Roles` for accessing the `Controller`
    you are developing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Claims-based**, where you can define values that must be received during
    the authentication to indicate that the user is authorized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy-based**, in which there is a policy established to define the access
    in that `Controller`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also define a controller or method in a class as being fully accessible
    to any user by defining the `[AllowAnonymous]` attribute. Be sure this kind of
    implementation will not cause any vulnerabilities in the system you are designing.
  prefs: []
  type: TYPE_NORMAL
- en: The model you decide to use will define exactly what each user will be able
    to do in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While designing, you, as a software architect, will have to decide which part
    of the data you store is sensitive, and it will need to be protected. By connecting
    to Azure, your web app will be able to store protected data in components such
    as Azure Storage and Azure Key Vault. Storage in Azure will be discussed in *Chapter
    12*, *Choosing Your Data Storage in the Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended to check the **Data Protection Framework** that your
    solution will need to deal with, considering where it will be placed.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that Azure Key Vault is used to protect secrets your
    app may have. Consider using this solution when you have this kind of requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Web security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is totally unacceptable to have a production solution deployed without the
    HTTPS protocol enabled. Azure Web Apps and ASP.NET Core solutions have various
    options to not only use but enforce the usage of this security protocol.
  prefs: []
  type: TYPE_NORMAL
- en: There are many known attacks and malicious patterns, such as cross-site request
    forgery, open redirect, and cross-site scripting. ASP.NET Core provides APIs to
    solve them. You need to find the ones that are useful for your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Good programming practices, such as avoiding SQL injection by using parameters
    in your queries, is another important goal to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: You may find cloud architecture security patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security).
  prefs: []
  type: TYPE_NORMAL
- en: To finish, it is worth mentioning that security needs to be treated using the
    onion approach, which means that there are many layers of security to be implemented.
    You must have determined a policy to guarantee a process to access the data, including
    physical access for people who use the system you are developing. In addition,
    you also must develop a disaster recovery solution in case the system is attacked.
    The disaster recovery solution will depend on your cloud solution. We will discuss
    this later, in *Chapter 10*, *Deciding on the Best Cloud-Based Solution*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional requirements that describe system behavior must be complemented with
    non-functional requirements that constrain system performance, scalability, availability,
    resilience, interoperability, usability, and security.
  prefs: []
  type: TYPE_NORMAL
- en: Performance requirements come from response time and system load requirements.
    As a software architect, you should ensure you have the required performance at
    the minimum cost, building efficient algorithms and taking full advantage of the
    available hardware resources with multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability is the ability of a system to be adapted to an increasing load.
    Systems can be scaled vertically by providing more powerful hardware or horizontally
    by replicating and load balancing the same hardware, which increases the availability.
    The cloud, in general, and Azure can help us implement strategies dynamically,
    with no need to stop your application.
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as .NET 8 that run on several platforms can ensure interoperability,
    that is, the capability of your software to run on different target machines and
    with different operating systems (Windows, Linux, macOS, Android, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Usability is ensured by taking care of input field order, the effectiveness
    of the item selection logic, and how easy your system is to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, the more complex your solution is, the better resilience it should
    have. The idea of resilience is not to guarantee that the solution does not fail.
    Instead, the idea is to guarantee that the solution has an action defined when
    each part of the software fails.
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must consider security from the very beginning
    of the design. Following the guidelines to determine the correct patterns and
    having a security specialist on your team is the best way to comply with all the
    current regulations we have.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how Azure DevOps and GitHub can help us
    when it comes to collecting, defining, and documenting our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two conceptual ways to scale a system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you deploy your web app automatically from Visual Studio to Azure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is multithreading useful for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main advantages of the asynchronous pattern over other multithreading
    techniques?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the order of input fields so important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `Path` class so important for interoperability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of a .NET standard class library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the *most-used* types of .NET Visual Studio projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some books and links you may consider reading to gather more
    information in relation to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud computing models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance improvements in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://benchmarkdotnet.org/](https://benchmarkdotnet.org/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Security aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview](https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Service consistency aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dotnet support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dotnet.microsoft.com/platform/support/policy](https://dotnet.microsoft.com/platform/support/policy)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
