<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating and Using Types in C#</h1>
                </header>
            
            <article>
                
<p>Types are the building blocks of a C# program. Even while writing a basic C# program, we must use the right types while creating our program. In <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a>, <em>Understanding Classes, Structures, and Interfaces</em>, we learned the basics of types in a C# program. We learned about the value and reference type variables that are present in a C# program.</p>
<p> </p>
<p>In addition to awareness of the different types, we should also understand that it's quite important for us to use each type in the best possible circumstance or situation. We also should be aware of the best practices regarding the creation and usage of these types. We will be going through this in this chapter. </p>
<p>We will walk through the following topics in this chapter:</p>
<ul>
<li>Creating types</li>
<li>Consuming types</li>
<li>How to use properties to enforce encapsulation</li>
<li>Using of optional and named parameters</li>
<li>Creating indexed properties</li>
<li>Different operations related to string manipulation in C#</li>
</ul>
<p>We will have an overview of <strong>reflection </strong>and try to understand how it can help us find, execute, and create types at runtime. In <a href="b7bdae98-fc5b-4430-bb0d-b8541ca64f8d.xhtml">Chapter 10</a>, <em>Find, Execute, and Create Types at Runtime Using Reflection</em>, we will do a deep dive into reflection.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Like in the previous chapters covered in this book, the programs explained in this book will be developed in Visual Studio 2017.</p>
<p><span>The sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples">https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating types</h1>
                </header>
            
            <article>
                
<p>When we create a variable in C#, it provides us with plenty of options to choose the appropriate type of the variable. For example, we can choose the following:</p>
<ul>
<li>We can choose an <kbd>enum</kbd> type if we would like the variable to acquire a defined set of variables. For example, if we define <kbd>Day</kbd> as an <kbd>enum</kbd> type, it can acquire the values <kbd>Monday</kbd>, <kbd>Tuesday</kbd>, <kbd>Wednesday</kbd>, <kbd>Thursday</kbd>, <kbd>Friday</kbd>, <kbd>Saturday</kbd>, and <kbd>Sunday</kbd>. </li>
<li>Similarly, if we choose an <kbd>int</kbd> type, we tell <strong>common language runtime</strong> (<strong><span>CLR</span></strong>) that it cannot have decimal digits.</li>
</ul>
<p>Hence, while defining types for any variables, we have to analyze the usage of the variable logically and then declare its type in C#. In the next section, we will just do a brief revision of the different types that we covered in the <em>Data types in C#</em> <span>section </span>in <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a><span>, </span><em>Understanding Classes, Structures, and Interfaces</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types in C# </h1>
                </header>
            
            <article>
                
<p class="mce-root">In <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a><span>, </span><em>Understanding Classes, Structures, and Interfaces</em>, we learned that a variable can acquire the following types of values:</p>
<ul>
<li class="mce-root"><strong>Value types</strong>: <span><span>In value types, the variables contain the actual value of the variable. This basically implies that if any change is made to a value type variable in a different scope of the program, the change is not reflected back once the control shifts to the calling function. </span></span></li>
<li class="mce-root"><strong>Reference types</strong><span>: T</span><span>he data member contains the exact address of the variable in memory. </span><span>As the variable just contains a reference to a memory address, two separate reference type variables can point to the same memory address. </span><span>Therefore, if a change is made in a reference type variable, the change is made directly at the memory location of the variable and hence is carried forward to the different scopes present in the program execution. </span></li>
<li class="mce-root"><strong>Pointer types</strong><span>: Pointers are </span>another type of variable possible in C#. The pointer type is used to save the memory address of variable allowing us to any operation involving the memory location of the variable.</li>
</ul>
<p>In the next section, we will do a deep dive into pointers and understand the implications and benefits of using them in our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsafe code and the use of pointer types</h1>
                </header>
            
            <article>
                
<p>In languages such as C or C++, developers have the features to create <em>pointers</em> or <kbd>*</kbd>, which is an object that stores the memory address of another variable. This object allowed very low-level access of the memory to the application. However, due to the possibility of <em>dangling pointers,</em> the performance of the application suffers greatly. A dangling pointer is a potential situation that could exist in C when a pointer object is still pointing to a memory location that is no longer allocated in the application. Please refer to the following diagram:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/802e881c-7877-43ee-bb98-865128cbac44.png" style=""/></div>
<p>In the diagram, we have an application running in C or C++ that declared <span class="packt_screen">Pointer B</span> and pointed it to the memory address of variable <span class="packt_screen">A</span>. The pointer saves the memory address of the variable. Hence, in other words, <span class="packt_screen">Pointer B</span> will not contain the memory address of variable <span class="packt_screen">A</span>. Now, at some point during the program run, memory location <span class="packt_screen">A</span> was released by the application. Even though the memory was released, there could be circumstances when we do not explicitly clear out the contents of the pointers containing the respective memory address. Due to this mistake or oversight, <span class="packt_screen">Pointer B</span> was not updated to point to a new block of memory or pointing it to null. As a result, the pointer is still referring to a memory location that no longer exists in the application. This situation is called <strong>dangling pointers</strong>.</p>
<p>C# removes the possibility of dangling pointers because, explicitly, it does not allow the use of pointers. Instead, it encourages people to use <em>reference types</em>. The memory management of <em>reference types</em> is managed by a garbage collector.</p>
<div class="packt_infobox">In <a href="b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml">Chapter 9</a>, <em>Managing the Object Life Cycle</em>, we will look further at how the <span>garbage collector</span> works in .NET. </div>
<p>However, there are still some circumstances when developers feel the need to use pointers in their C# application. This is useful in scenarios where we need to do some operations with the underlying operating system, such as Windows or Linux, in which the application is running. In such circumstances, we will need pointers. To cater to such scenarios, C# has the concept of <kbd>unsafe</kbd> <em>code</em> in which it allows developers to use pointers in their code. The code that uses pointers must be classified clearly with an identifier of <kbd>unsafe</kbd>. This keyword conveys the message to <strong>Common Language Runtime</strong> (<strong>CLR</strong>) that the code block is unmanaged or unsafeâ€”or, in other words, has used pointers. Let's go through a code example to see how we use pointer types in C#.</p>
<p>In the code example, we are creating a function block in which we are using a pointer variable. We will be saving the address of an <kbd>int</kbd> type in an <kbd>int</kbd> pointer type variable. Please refer to the following screenshot. Note that the user gets an error when they try to compile the program:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/510e540a-326a-4c58-aedf-aa5e70fec8a2.png" style=""/></div>
<p>The reason is that, by default, the C# compiler will not allow any code containing a pointer or <kbd>unsafe</kbd> code block to be executed. We can override this behavior of C# by using the <kbd>unsafe</kbd> keyword in the function block:</p>
<pre>class Program<br/> {<br/>     static void Main(string[] args)<br/>     {<br/>         UnSafeExample();<br/>     }<br/>     unsafe static private void UnSafeExample()<br/>     {<br/>         int i = 23;<br/>         int* pi = &amp;i;<br/>         Console.WriteLine(i);<br/>         Console.WriteLine(*pi);<br/>         Console.ReadLine();<br/>     }<br/> }</pre>
<p class="mce-root"/>
<p><span>To allow the compilation of <kbd>unsafe</kbd> code, we will need to change the build setting in Visual Studio. To update the settings, we need to right-click on the <span class="packt_screen">Project</span> and click on <span class="packt_screen">Properties</span>. Now, navigate to the <span class="packt_screen">Build</span> section. </span>Please refer to the <span>following </span>screenshot, which highlights the Visual Studio setting that we need to specify to allow compilation of <kbd>unsafe</kbd> code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8ace30ca-abea-4c55-9fe6-ed2b5b31f0ee.png" style=""/></div>
<p>Now we have revisited the different types possible in C#. The next section explains the guiding principles that help us select a particular variable type over another.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing the type of variable</h1>
                </header>
            
            <article>
                
<p>In <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a><span>, </span><em>Understanding Classes, Structures, and Interfaces</em><span>,</span> in the <em>Data types in C# </em><span>section</span>, we saw the different data types that are possible for both value and reference types. We also did a code implementation to see the difference in the behavior of <kbd>Struct</kbd>, which is a value type, and <kbd>Class</kbd>, which is a reference type. In this section, we will do a deep dive and see this difference in behavior and how it can help us to choose the correct type for our variable.</p>
<p class="mce-root"/>
<p>Let's analyze how the <span>following </span>code statements for value and reference types and see how they differ in implementation:</p>
<pre>// Value Type<br/>int x = 10;<br/>int y = x <br/><br/>// Reference Type<br/>Car c = new Car();<br/>Car c2 = c;</pre>
<p>In the preceding code, we have declared the value type variables <kbd>x</kbd> and <kbd>y</kbd>. While declaring, the <kbd>x</kbd> <span>variable </span>has been assigned a value. In the next step, we are assigning <kbd>x</kbd> to <kbd>y</kbd>. Similarly, we have a class named <kbd>Class</kbd> and we have created an object of <kbd>c</kbd>. In the next statement, we have declared another object of the same class and have assigned <kbd>c</kbd> to <kbd>c2</kbd>. </p>
<p>Please refer to the following diagram, <span>which shows how these types are implemented and managed inside memory:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73206554-2d6c-496d-be16-c0840aab7814.png" style=""/></div>
<p>In the preceding diagram, we have declared variable <kbd>x</kbd> as an <kbd>int</kbd> data type and <kbd>c</kbd> as an object of the <kbd>Car</kbd> class. Now, we know that <kbd>int</kbd> is a value type, while <kbd>Class</kbd> is a reference type. So let's try to analyze why the behavior differs for both of them:</p>
<ul>
<li>For <kbd>x</kbd>, in the first statement, that is, <kbd>int x = 10</kbd>, a block of memory is reserved by the application. The rectangular block below the declaration conveys that.</li>
<li>Now, when we execute the <kbd>int y = x</kbd> <span>statement,</span> we are declaring another variable, <kbd>y</kbd>, and it is assigned the value currently in <kbd>x</kbd>. What it does internally is it allocates another block of memory for <kbd>y</kbd> in memory. Therefore, as <kbd>x</kbd> and <kbd>y</kbd> are not pointing to the same memory location, they will hold different values.</li>
<li>On the other hand, if we look at the <kbd>Car</kbd> <span>class, </span>we have just declared two attributes in it: the registration number and color. Now, when we use the <kbd>new</kbd> <span>statement, </span>what it does is that it creates an object for the class and allocates it memory. However, as against the value type implementation, it does not save the value in the object. Instead, in the object, it just saves a reference to the allocated memory block. In the rectangular shape in the preceding diagram, you will see that, once the <kbd>c</kbd> <span>object </span>is created for the <kbd>Car</kbd> <span>class, </span>a pointer is saved in the created object.</li>
<li>Now, when we execute the <kbd>Car c2 = c;</kbd> <span>statement,</span> internally, it creates a new object, <kbd>c2</kbd>, but does not allocate a new memory block for the object. Instead, it just saves a reference to the memory location shared with the object, <kbd>c</kbd>. </li>
</ul>
<p>As illustrated by the preceding implementation, whenever a new value type variable is declared, a new block of memory is reserved by the application, which is different from reference type variables.</p>
<p>Hence, in much simpler terms, the <span>following </span>factors can help us to choose between value and reference type:</p>
<ul>
<li><strong>A value type variable is logically immutable</strong>: In very simple terms, it means that on every declaration of the value type, a new block of memory is reserved by the application. As they are different memory allocations, it implies that if we execute any operation on one memory location, the change is not transmitted across to the other memory location.</li>
<li><strong>Whether there are lots of objects</strong><span><span>: If there lots of objects being created in the application, it might be better to not create them as value type as it would exponentially increase the memory requirements of the application.</span></span></li>
<li><strong>Whether the object is small</strong><span>: If the object is small, then it may make sense to have them as value type variables. However, if we think that the object is bound to have too many properties, a reference type variable will make more sense.</span></li>
<li><strong>Memory management</strong><span>: Value type variables are managed on a stack whereas reference type variables are managed on a heap. When we move to <a href="b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml">Chapter 9</a>, <em>Manage the Object Life Cycle</em>,</span> we will look further<span> into memory management and how</span> the <span>garbage collector</span> <span>works.</span></li>
</ul>
<p>Now that we have a fair understanding of how we can create and consume different data types in a C# application, we will be looking at some of the features of C# that help us to set correct behavior for the different types we use in the application. In the next section, we will be looking at static variables and how they are implemented in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static variables</h1>
                </header>
            
            <article>
                
<p>When we went over the section on value type versus reference type, we understood that all of the objects created in C# have a definite scope in the program execution. However, there could be some circumstances when we would like to have a variable acquire a constant value that is consistent across all instances of the objects. We can do this using the <kbd>Static</kbd> keyword. A <kbd>Static</kbd> keyword in a modifier in C# ensures that just one instance of the variable is created and its scope is throughout the entire run of the program. We can use a <kbd>Static</kbd> variable against a class, its member variable, and its member methods and constructors. </p>
<p>Let's now look at code examples involving the <kbd>Static</kbd> keyword.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static member variables</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at how we can use the <kbd>Static</kbd> keyword against a class and its member variables. In the <span>following </span>code example, we have created a <kbd>Static</kbd> class called <kbd>Configuration</kbd>. Just for the sake of explanation, we will not be using the <kbd>Static</kbd> keyword for a member variable present in it:</p>
<pre>internal static class Configuration<br/>{<br/>     public string ConnectionString;<br/>}</pre>
<p class="mce-root"/>
<p>Let's try to compile the program. We get an error stating that the <kbd>ConnectionString</kbd> <span>member variable </span>must be declared <kbd>static</kbd> as well:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6928a105-8aa5-4b1c-8cd7-77d02081d970.png" style=""/></div>
<p>Once we use the <kbd>static</kbd> keyword against the <kbd>ConnectionString</kbd> <span>member variable </span>as well, the error goes away. This is the correct representation of the class:</p>
<pre>internal static class Configuration<br/>{<br/>    public static string ConnectionString;<br/>}</pre>
<p>If we need to use <kbd>Set</kbd>/<kbd>Get</kbd> value in the member variable, we can access it directly by using the name of the class. Here is the code snippet for this:</p>
<pre>Configuration.ConnectionString = "Sample Connection String";</pre>
<p>In the preceding code example, we had a <kbd>Static</kbd> class <kbd>Configuration</kbd> in which it was mandatory to have the <kbd>static</kbd> modifier against all of the member variables and properties. However, there could be some circumstances when we don't want the entire class to be static but just a particular member variable present inside it. </p>
<p>We can achieve this in C# by using the <kbd>static</kbd> modifier not against the class but against the particular member variable. If we need to use this in the preceding code, the following would be the updated code:</p>
<pre>internal class Configuration<br/>{<br/>    public static string ConnectionString;<br/>}</pre>
<p>However, there will be no change in the way we access this property. It can still be done by using the name of the class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static methods</h1>
                </header>
            
            <article>
                
<p>In C#, a class can have two types of methods: static methods and non-static methods. Static methods are shared across the different instances of the class objects, whereas non-static methods are unique for each instance. Just like static member variables, we can declare a method as static by the use of the <kbd>static</kbd> <span>keyword </span>and can access them by directly using the class name.</p>
<p>The <span>following </span>code example indicates how we create a <kbd>static</kbd> method in a class:</p>
<pre>internal class Configuration<br/>{<br/>    public static string ConnectionString;<br/>    public static void CreateConnectionString()<br/>    {      <br/>    }<br/>}</pre>
<p>To execute a static method, we can use the <span>following </span>code snippet:</p>
<pre>Configuration.CreateConnectionPath(); </pre>
<p>In the next section, we will look at constructors and how they are implemented in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructors</h1>
                </header>
            
            <article>
                
<p class="mce-root">Constructors are called whenever an object is created for a <kbd>class</kbd> or <kbd>struct</kbd> type. They can help us to set some default values against the member variables present in these types. </p>
<p class="mce-root">In <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a><span>, </span><em>Understanding Classes, Structures, and Interfaces</em>, while understanding the difference between a <kbd>class</kbd> and <kbd>struct</kbd> type, we mentioned that, unlike classes, structs do now have a default constructor. That constructor, in programming terms, is known as a <strong>parameter less constructor</strong>. If a programmer does not specify any constructor for the class, then whenever an object is created for the class the default constructor triggers and sets default values against the member variables present in the class. The default values are set in accordance with the default values of the type of those member variables. </p>
<p>In terms of syntax, a constructor is just a method the name of which is the same as that of its respective type. In the method signature, it has got a parameter list that can be mapped to the member variables present in the type. It does not have any return type. </p>
<p class="mce-root"/>
<div class="packt_infobox">Please note that a class or struct can have multiple constructors each differing with each other based on the parameter list present in the method. </div>
<p>Let's look at a code example in which we will implement constructors:</p>
<pre>public class Animal<br/>{<br/>     public string Name;<br/>     public string Type;<br/> <br/>     public Animal(string Name, string Type)<br/>     {<br/>         this.Name = Name;<br/>         this.Type = Type;<br/>     }<br/> }</pre>
<p>In the preceding code example, we have declared an <kbd>Animal</kbd> <span>class </span>with two member variables, <kbd>Name</kbd> and <kbd>Type</kbd>. We have also declared a two-parameter constructor in which we are passing <kbd>Name</kbd> and <kbd>Type</kbd> as string parameters. Using the <kbd>this</kbd> operator, we are then assigning the values passed to the member variables present in the class. </p>
<p>We can use the following code implementation to call this constructor:</p>
<pre>Animal animal = new Animal("Bingo", "Dog"); </pre>
<p>In the next section, we will look at how named parameters are implemented in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named parameters</h1>
                </header>
            
            <article>
                
<p>Named parameters were introduced in C# 4.0, and they allow us to pass arguments to a method/constructor/delegate/indexer using parameter names instead of the sequence in which the parameters are passed. </p>
<p>Using named parameters, developers no longer need to be concerned about the sequence in which they need to pass parameters. As long as they associate the values being passed with the right parameter name, the sequence will not matter. The parameter names are compared against the names of the parameters in the method definition. Let's look at the <span>following </span>code example to understand how it works:</p>
<pre>internal Double CalculateCompoundInterest(Double principle, Double interestRate, int noOfYears)<br/>{<br/>     Double simpleInterest = (principle) * Math.Pow((1 + <br/>      (interestRate)/100), noOfYears);<br/>     return simpleInterest;<br/>}</pre>
<p>In the preceding code example, we are calculating compound interest by passing the principal amount, interest rate, and number of years for which the amount was put in the bank. </p>
<p>If we call the method without using named parameters, we would use the <span>following </span>code snippet:</p>
<pre>Double interest = CalculateCompoundInterest(500.5F, 10.5F, 1);            </pre>
<p>If we look closely at the preceding example, while calling the function, the developer will need to be fully aware of the sequence of the principle and interest rate parameters. That's because if the developer makes a mistake while calling the function, the resultant output will be incorrect. </p>
<p>With named parameters, we can call the method using the <span>following </span>syntax:</p>
<pre>Double namedInterest = CalculateCompoundInterest(interestRate: 10.5F, noOfYears: 1, principle: 500.5F); </pre>
<p>Note that, in the preceding code, we are not passing values to the parameters in the sequence there are defined in the method. Instead, we are using parameter names to map the passing values with the parameters declared in the method. In the next section, we will look at another feature, <em>optional parameters,</em> which was introduced in C# 4.0 along with named parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optional parameters</h1>
                </header>
            
            <article>
                
<p>Optional parameters in C# allow us to define a method in such a way that some of the parameters are optional. In other words, while defining the function for the optional parameters, a default value is specified. </p>
<p>If, while calling the method, no value is passed for the optional parameter, it assumes a default value. Let's look at a code example to understand how optional parameters work in C#:</p>
<pre>static float MultiplyNumbers(int num1, int num2 = 2, float num3 = 0.4f)<br/>{<br/>     return num1 * num2 * num3;<br/>}</pre>
<p>In the preceding code example, we have defined a <kbd>MultiplyNumbers</kbd> <span>method </span>with three parameters, <kbd>num1</kbd>, <kbd>num2</kbd>, and <kbd>num3</kbd>. The <kbd>num1</kbd> <span>parameter </span>is mandatory, while the other two parameters, <kbd>num2</kbd> and <kbd>num3</kbd>, are optional.</p>
<div class="packt_infobox">Please note that, while defining the function, the optional parameters, if any, must come after all of the required parameters have been specified in the sequence.</div>
<p>If we need to execute the preceding method, we can use any of the <span>following </span>code snippets:</p>
<pre>float result = MultiplyNumbers(2); // output = 1.6f<br/>float result1 = MultiplyNumbers(2, 5); // output = 4f<br/>float result2 = MultiplyNumbers(2, 4, 5); // output = 40f<br/> </pre>
<p>Note that there would be no compiler errors and if any optional parameters are not passed, the default value defined in the function declaration would be used. In the next section, we will look at how generic types are implemented in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generics types</h1>
                </header>
            
            <article>
                
<p>Generics allow us to design classes and methods without the notion of data types. In simpler terms, when we talk about methods, generics allow us to define methods without specifying the type of the input variables. </p>
<p>Let's go through the <span>following </span>code implementation and see how it can help us. In the <span>following </span>example, we have created a function that compares the values between two <kbd>int</kbd> variables, <kbd>A</kbd> and <kbd>B</kbd>. If the value is the same, it returns <kbd>true</kbd>; however, if the value is not same, it returns <kbd>false</kbd>:</p>
<pre>static private bool IsEqual(int A, int B)<br/>{<br/>     if(A== B)<br/>     {<br/>         return true;<br/>     }<br/>     else<br/>     {<br/>         return false;<br/>     }<br/> }</pre>
<p class="mce-root"/>
<p>Now, let's say we try to pass a variable with a data type that is not <kbd>int</kbd>. In the following screenshot, we are trying to pass <kbd>string</kbd> instead of <kbd>int</kbd>, to which the compiler gives us an error:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/584e7232-e0d1-4df1-9649-492b26818b65.png" style=""/></div>
<p><span>As illustrated in the following screenshot, it will give us the following error:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ff83eaec-b056-4d41-a548-7d51c30582fe.png" style=""/></div>
<p>As illustrated by the preceding screenshot, the <kbd>IsEqual</kbd> <span>function </span>is accepting inputs of the <kbd>int</kbd> <span>type.</span> However, while calling the function, we are passing variables of the <kbd>string</kbd> <span>type.</span> Due to the type mismatch, the compiler is showing the error.</p>
<p>To correct this error, we need to make the <kbd>IsEqual</kbd> function generic. We can do this by altering the function so that instead of accepting the input variables of the <kbd>int</kbd> type, it can accept the input variables of the <kbd>object</kbd> type.</p>
<div class="packt_infobox">Please note that all of the variables in C# inherit from <kbd>object</kbd>. </div>
<p class="mce-root"/>
<p>In this<span> </span>code example, we are calling the <kbd>IsEqual</kbd> function twice and are passing different input parameters. In the first call, we are passing <kbd>string</kbd>; however, in the second call, we are passing <kbd>int</kbd>. Note that when we compile the project, no compile time error is retrieved and the function compares the passed variables irrespective of type:</p>
<pre>static void Main(string[] args)<br/>{<br/>     UnSafeExample();<br/>     IsEqual("string", "string");<br/>     IsEqual(10, 10);<br/>}<br/><br/>static private bool IsEqual(object A, object B)<br/>{<br/>     if (A == B)<br/>     {<br/>         return true;<br/>     }<br/>     else<br/>     {<br/>         return false;<br/>     }<br/> }</pre>
<p>Although the preceding code implementation will be generic for all of the data types, it will lead to the <span>following </span>issues:</p>
<ul>
<li><strong>Performance degradation</strong>:<strong> </strong>In the <kbd>IsEqual</kbd> function definition, the data types of variables is <kbd>object</kbd>. Due to this, for all calls being made to this function, the variables will need to be converted from their original type, that is, <kbd>int</kbd> or <kbd>string</kbd>, into <kbd>object</kbd>. This conversion will be an extra load for the application, which will lead to performance degradation. In programming terms, this conversion is known as <strong>boxing and unboxing</strong>, which we will cover shortly in this chapter. </li>
<li><strong>Type unsafe</strong>: This approach will not be type unsafe. For example, I will call the function by passing the following variables:</li>
</ul>
<pre style="padding-left: 60px">IsEqual(10, "string");</pre>
<p>If I do so, the compiler will not give any error, even though we understand that the call makes no sense. To avoid these issues while still providing us with the capability of making the calls generic, C# provides us with the tool of using <em>generic types</em>.</p>
<p class="mce-root"/>
<p>Using generic types, we can avoid specifying any data type to the input variables of the functions. Hence, the implementation of <kbd>IsEqual</kbd> will look like this:</p>
<pre>static private bool IsEqual&lt;T&gt;(T A, T B)<br/>{<br/>     if (A.Equals(B))<br/>     {<br/>         return true;<br/>     }<br/>     else<br/>     {<br/>         return false;<br/>     }<br/> }</pre>
<p>In the preceding code example, please note that we are using <kbd>T</kbd> to illustrate the data type, hence making it generic for all data types. </p>
<p>As we are not using <kbd>object</kbd>, there will be no boxing and unboxing of variables. If we still try to pass incorrect data types to this function, as illustrated in the <span>following </span>screenshot, the compiler will give us an error:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dce39b3e-cc88-4d9e-bc76-a67b944712cc.png" style=""/></div>
<p class="mce-root"/>
<p>In the next topic, we will not go through the different concepts C# uses to work on the types of the data variables. We will go through how we can use boxing and unboxing in C# to convert one data type into another and the different things we should keep in mind when we are consuming variables of different types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming data types in C#</h1>
                </header>
            
            <article>
                
<p>C# is a strongly-typed language. This basically means that, when we declare a variable with a particular data type, as in the following example, <span>we cannot declare the</span> <kbd>x</kbd><span> variable again</span>:</p>
<pre>int x = 5;</pre>
<p>In addition to this, we cannot assign to this <kbd>x</kbd> <span>variable </span>any value that is not an integer. Hence, the <span>following </span>statement <span>will give us an error</span>:</p>
<pre>x = "Hello";</pre>
<p>To overcome this strongly typed feature, C# provides some capabilities when we are consuming a type. This includes boxing and unboxing of value type variables, use of the dynamics keyword, and implicit and explicit conversion of a variable of one data type to a variable of a different data type. Let's go through each of these concepts and understand how they work in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Boxing and unboxing </h1>
                </header>
            
            <article>
                
<p>In C#, boxing means converting a value type variable into a reference type variable. Unboxing is the opposite of boxing. It refers to the conversion of a reference type variable into a value type variable. Boxing and unboxing are detrimental to the performance of the application as they are an overhead to the compiler. As developers, we should try to avoid them as much as possible; however, it's not always possible and there are several instances that we encounter during programming that make us use this concept.</p>
<p>Let's look at the <span>following </span>example to see how boxing and unboxing works:</p>
<pre>static private void BoxAndUnBox()<br/>{<br/>     int i = 3;<br/>     // Boxing conversion from value to reference type<br/>     object obj = i;<br/>     // Unboxing conversion from reference type to value type<br/>     i = (int)obj;<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the code implementation, we can see the following:</p>
<ul>
<li>We have declared a variable, <kbd>i</kbd>, of the <kbd>int</kbd> <span>type </span>and have assigned it a value of <kbd>3</kbd>. Now we know that, being <kbd>int</kbd>, this is a value type reference. </li>
<li>Next, we declare an <kbd>obj</kbd> <span>variable </span>of the <kbd>object</kbd> <span>type </span>and have assigned it the value in <kbd>i</kbd>. We know that <kbd>object</kbd> is a reference type variable. Therefore, internally, the CLR will undergo boxing and convert the value into the <kbd>i</kbd> <span>variable </span>into a reference type variable.</li>
<li>Next, in the third statement, we are doing the reverse. We are trying to assign the value in a reference type variable, that is, <kbd>obj</kbd>, to a value type variable, <kbd>i</kbd>. At this stage, the CLR will do the unboxing of the value. </li>
</ul>
<p>Please note that, while doing boxing, we do not need to explicitly cast the value type to a reference type. However, when we are doing the unboxing, we need to explicitly specify the type into which we are converting the variable. <span>This approach of explicitly specifying the type into which we are converting a variable is known as casting. </span>To do casting, we can use the <span>following </span>syntax:</p>
<pre>i = (int)obj;</pre>
<p>What it basically means is that there are possibilities that this conversion can lead to an exception of the <kbd>InvalidCastException</kbd> <span>type.</span> For example, in the preceding example, we know that the value in <kbd>obj</kbd> is <kbd>10</kbd>. However, if it were to acquire a value that cannot be cast to an <kbd>int</kbd> value, for example, <kbd>string</kbd>, the compiler will give us a runtime error. </p>
<p>Now, in the next section, we will look at the different techniques C# provides us with for converting between data types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type conversions in C#</h1>
                </header>
            
            <article>
                
<p>Type conversion in C# basically implies converting a variable from one data type into another. Now we will look into the different types of conversions available in C#.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit conversion</h1>
                </header>
            
            <article>
                
<p>Implicit conversion is done by the compiler automatically. It's done by the compiler without any intervention or command from the developer. The following two conditions must be fulfilled for a compiler to execute implicit type conversion:</p>
<ul>
<li>
<p> <strong>No data</strong> <strong>l</strong><strong>oss</strong>: The compiler must determine that if it executes the conversion implicitly, there will be no data loss. In <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a><span>, </span><em>Understanding Classes, Structures, and Interfaces</em><span>,</span> in the <em>Data Types </em><span>section</span>, we saw that each data type acquires a space in memory. Therefore, if we try to assign a variable with the type as <kbd>float</kbd>, which acquires 32 bytes of memory, to double, which acquires 64 bytes of memory, we can be sure that there won't be any data loss in the conversion.</p>
</li>
<li>
<p><strong>No chance of cast exception</strong>: The compiler must determine that there is no chance of an exception during the casting of the value from one data type to another. For example, if we try to set a <kbd>string</kbd> value to a <kbd>float</kbd> variable, the compiler will not do the implicit conversion as it would be an invalid cast.</p>
</li>
</ul>
<p>Now, let's look at the following code implementation to see how implicit conversion works in C#:</p>
<pre> int i = 100;<br/> float f = i;</pre>
<p>In the preceding code example, we have declared a variable, <kbd>i</kbd>, of the <kbd>int</kbd> <span>type</span> and have assigned it a value of <kbd>100</kbd>. In the next statement, we have declared a variable, <kbd>f</kbd>, of the <kbd>float</kbd> <span>type </span>and have assigned it the value in <kbd>i</kbd>. </p>
<p>Now, the compiler would determine that both the required conditions for implicit conversions are being met, that is, <kbd>float</kbd> acquires more memory than <kbd>int</kbd> and there is no chance of an invalid cast exceptionâ€”an <kbd>int</kbd> value is also a valid value in a <kbd>float</kbd> variable. Hence, the compiler gives no error and does the implicit conversion. </p>
<p class="mce-root"/>
<p>However, if we do the reverse, which is trying to assign a <kbd>float</kbd> value in <kbd>int</kbd>, the compiler will determine that the conditions are not being fulfilled and will give us a compile-time error. Please refer to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dcd025b4-b567-4c1f-8397-14a238c0ad19.png" style=""/></div>
<p>However, in certain circumstances, even if there is a chance of data loss, we would still like to have those conversions. C# provides us with <em>explicit conversion</em>, which allows us to explicitly instruct the compiler to let the conversion take place. Let's go through how <em>explicit conversion</em> takes place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explicit conversion</h1>
                </header>
            
            <article>
                
<p>When the compiler is not able to implicitly change the type of variables, but we still want the conversion to happen, we need to explicitly instruct the compiler to convert the value. This is referred to as <em>explicit conversion</em>.</p>
<p>There are two ways to do explicit conversion in C#:</p>
<ul>
<li><strong>Using a type cast operation</strong>: In this, we use the base data type to instruct the compiler to do explicit conversion. For example, for the code implementation that we were trying in the preceding example, the <span>following </span>would be the syntax:</li>
</ul>
<pre style="padding-left: 60px">float k = 100.0F;<br/>int j = (int)k;</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">In the preceding code, we are explicitly telling the compiler to do type conversion by using the <kbd>int</kbd> class conversion before the float variable.</p>
<ul>
<li><strong>Using the</strong> <kbd>Convert</kbd> <strong>class</strong>: C# provides us with the <kbd>Convert</kbd> class, which we can use to do type casting between multiple data types. If we were to use the <kbd>Convert</kbd> class instead of the <kbd>int</kbd> keyword, the following would be the syntax:</li>
</ul>
<pre style="padding-left: 60px">float k = 100.0F;<br/>int j = Convert.ToInt32(k);</pre>
<p>Convert class can be used for type casting among different data types. Please refer to the <span>following </span>screenshot to get an idea of the different options that are available in the <kbd>Convert</kbd> class. Depending on the usage, we can use the appropriate method in the <kbd>Convert</kbd> class:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3f5171d1-5c82-499b-85c0-85c8a71d192d.png" style=""/></div>
<p class="mce-root">Hence, the overall implementation of the program will look like this:</p>
<pre>float k = 100.67F;<br/>int j = (int)k;<br/>int a = Convert.ToInt32(k);<br/>Console.WriteLine(j);<br/>Console.WriteLine(a);<br/>Console.ReadLine();<br/> </pre>
<p>Now, let's try to run this program to see the output it gives:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/54cf7e2a-e0a1-420a-8833-6692490ed6f2.png" style=""/></div>
<p class="mce-root"/>
<p>It implies that when we use the type cast keyword, that is, <kbd>(int)k</kbd>, the compiler tried to extract the integer component from the <kbd>float</kbd> variable, <kbd>k</kbd>, which turned out to be <kbd>100</kbd>.</p>
<p>On the other hand, when we used the <kbd>Convert</kbd> class, that is, <kbd>Convert.ToInt32(k)</kbd>, it tried to extract the nearest integer to the float variable, <kbd>k</kbd>, which turned out to be <kbd>101</kbd>. This is one of the key differences that developers need to be aware of while deciding between using type casting and the <kbd>Convert</kbd> class. </p>
<p class="mce-root">While we are looking at explicit type conversions, we need to be aware of two helper methods that help us do conversions:</p>
<ul>
<li><kbd>Parse</kbd></li>
<li><kbd>TryParse</kbd></li>
</ul>
<p>Both the <kbd>Parse</kbd> and <kbd>TryParse</kbd> methods are used to convert <kbd>string</kbd> into a different data type. However, there is a slight difference in the way invalid case exceptions are handled. Let's look at the <span>following </span>example to see how they work and the difference between them:</p>
<pre>string number = "100";<br/>int num = int.Parse(number); </pre>
<p>In the preceding example, we have declared a string object and have assigned it a value of <kbd>100</kbd>. Now, we are trying to convert the value into an integer using the <kbd>Parse</kbd> method. When we run the program, we see the <span>following </span>output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f3d439ed-e0cf-44b3-9532-2f306ed94e51.png" style=""/></div>
<p>It implies that the parse method converts the string into its integer equivalent and assigns the value to another variable, <kbd>num</kbd>. </p>
<p>Now, let's suppose the value in the number is <kbd>100wer</kbd>. Now, it's evident that the value in the <kbd>number</kbd> <span>string </span>cannot be converted into <kbd>int</kbd> because it has some characters that cannot be categorized in an integer object. When we run this program, we get the following exception:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f5cbe848-768a-4b09-9e8b-09bc6c571ba4.png" style=""/></div>
<p>To avoid such situations, we use <kbd>TryParse</kbd>. In <kbd>TryParse</kbd>, CLR tries to convert the string object into the specified data type. However, if the conversion returns an error, <kbd>TryParse</kbd> returns <kbd>false</kbd> or, in other words, <em>the conversion failed</em>. In other cases, it returns true. Hence, if we were to write the same implementation with <kbd>TryParse</kbd>, we would do the following:</p>
<pre> string number = "100wer"; <br/> int num;<br/> bool parse = int.TryParse(number, out num);<br/> if(parse)<br/> {<br/>     Console.WriteLine(num);<br/> }<br/> else<br/> {<br/>     Console.WriteLine("Some error in doing conversion");<br/> }<br/> Console.ReadLine(); </pre>
<p>In the preceding program, we have declared a variable of the <kbd>string</kbd> <span>type </span>and we are using <kbd>TryParse</kbd> to convert this value into a variable of the <kbd>int</kbd> <span>type</span><span>.</span> We are checking whether the conversion is a success. If it's a success, we print out the number and in other cases, we print a statement to show that there was an error during the type conversion. When we run the program, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d07724f-5c34-4655-b6b4-a5936b275a7e.png" style=""/></div>
<p class="mce-root"/>
<p>As we see from the output, the compiler tells us that there was an error doing the <kbd>TryParse</kbd>; however, it does not throw an exception in the application as opposed to the <kbd>Parse</kbd> method, which threw an invalid case exception in the same scenario.</p>
<p>In the next section, we will do a quick recap of encapsulation, which we covered in <a href="8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml">Chapter 3</a><span>, </span><em>Understanding Object-Oriented Programming</em>, and we'll see how to implement properties for class member variables objects, allowing us to consume them without worrying about the hidden complexities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enforcing encapsulation</h1>
                </header>
            
            <article>
                
<p>Previously, we went through the <span>following </span>concepts in <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a><span>, </span><em>Understanding Classes, Structures, and Interfaces</em><span>,</span> and  <a href="8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml">Chapter 3</a>, <em>Understanding Object-Oriented Programming</em>:</p>
<ul>
<li>Accessing modifiers and how they help us to control access to methods and fields in the same class, in the same assembly, and in the derived classes</li>
<li>Encapsulation and how it helps us to group together related fields and methods together in the same object</li>
</ul>
<p>However, there is another concept in encapsulation called properties, which makes sure that no one can have direct access to the data fields outside the class. This helps us to make sure that we have control over the modification of the data fields. </p>
<p>A property is very similar to the field of a class. Just like the field of a class, it has a type, name, and access modifier. However, what makes it different is the presence of accessors. Accessors are the <kbd>get</kbd> and <kbd>set</kbd> keywords that allow us to set and retrieve values from a field.</p>
<p>The <span>following </span>is what the syntax of a property looks like:</p>
<pre>class SampleProperty<br/>{ <br/>     private string name;<br/>     public string Name<br/>     {<br/>         set { if(value != null)<br/>                 {<br/>                     this.name = value;<br/>                 }<br/>               else<br/>                 {<br/>                     throw new ArgumentException();<br/>                 }    <br/>             }<br/>         get { return this.name; }<br/>     }<br/> }</pre>
<p><span>In the preceding code, please note the following:</span></p>
<ul>
<li><span>For the <kbd>SampleProperty</kbd> class, we have declared a <kbd>name</kbd> field and a <kbd>Name</kbd> property.</span></li>
<li>The <kbd>name</kbd> f<span>ield </span>has been marked <kbd>private</kbd>, hence it won't be accessed outside the <kbd>SampleProperty</kbd> <span>class.</span></li>
<li>The <kbd>Name</kbd> property has been marked <kbd>public</kbd> and has the <kbd>get</kbd> and <kbd>set</kbd> accessors.</li>
<li>In the <kbd>set</kbd> method, we are checking whether the value passed is null or not. If it's null, we are raising an argument exception. Therefore, we are putting rules around the value that can be set on the <kbd>name</kbd> field.</li>
</ul>
<p>In this way, properties help us in consume the fields of a class. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating strings</h1>
                </header>
            
            <article>
                
<p>Strings are a very important data type in C#. The string data type is used for saving text as <kbd>string</kbd>. In programming terms, it's a sequence of characters. String is a reference type variable unlike other basic data type variables, such as <kbd>int</kbd>, <kbd>float</kbd>, and <kbd>double</kbd>, which are value type variables. Also, strings are immutable in nature, that is, the values present in them cannot change. <span>In this section,</span><span> we will look at different operations related to this data type.</span></p>
<p>So, look at the <span>following </span>code example:</p>
<pre>string s = "Hello";<br/>s = "world";</pre>
<p>When we are assigning a <kbd>Test</kbd> <span>value </span>to the already declared <kbd>string</kbd> objects, internally, CLR allocates a new memory block for the modified <kbd>string</kbd> object. Hence, for every operation that we do on a string, instead of modifying of the same <kbd>string</kbd> object, a new <kbd>string</kbd> object is declared in CLR. Due to this, we need to be very careful while doing operations on <kbd>string</kbd>, for example, if we execute the <span>following </span>loop operation on a string object:</p>
<pre>string s = String.Empty;<br/>for(int z = 0; z &lt; 100; z++)<br/>{<br/>    s = + "a";<br/>}</pre>
<p>In the preceding code, we are concatenating the string object, <kbd>s</kbd>, with a character, <kbd>a</kbd>, in the loop. This loop will run <kbd>100</kbd> times. Therefore, the CLR will go on allocating more and more memory for the <kbd>string</kbd> object. Hence, due to memory usage, performance-wise, the preceding operation is not good. </p>
<p>To help to improve this feature in <kbd>string</kbd>, C# provides us with two built-in classes, <kbd>Stringbuilder</kbd> and <kbd>StringWriter</kbd>, which we will discuss next. We will also look at some of the features available with us for executing string searching in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StringBuilder</h1>
                </header>
            
            <article>
                
<p><kbd>Stringbuilder</kbd> is an internal class provided by C# that helps us to improve <kbd>string</kbd> manipulation functions. To explain the idea, we will be executing a <kbd>for</kbd> loop from <kbd>0</kbd> to <kbd>100</kbd> and will be concatenating the resultant output in each loop with the letter <kbd>a</kbd>. Internally, a string builder uses a buffer to modify the string value instead of allocating memory on every string manipulation. The following code example shows how we can use string builder for string manipulation operations:</p>
<pre>StringBuilder sb = new StringBuilder(string.Empty);<br/>for (int z = 0; z &lt; 100; z++)<br/>{<br/>     sb.Append("a"); <br/>}</pre>
<p>In the preceding code, we are declaring a <kbd>StringBuilder</kbd> object, <kbd>sb</kbd>, and are appending its value with <kbd>a</kbd> in the loop. Internally, instead of allocating memory on every concatenation, <kbd><span>StringBuilder</span></kbd> will use an internal buffer to manage these operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StringReader and StringWriter</h1>
                </header>
            
            <article>
                
<p>The <kbd>StringReader</kbd> and <kbd>StringWriter</kbd> classes derive from the <kbd>TextReader</kbd> and <kbd>TextWriter</kbd> classes respectively. <kbd>TextReader</kbd> and <kbd>TextWriter</kbd> are used for dealing with APIs such as reading from an XML file, generating an XML file, or reading from a file.</p>
<div class="packt_infobox">We will study the <kbd>TextReader</kbd> and <kbd>TextWriter</kbd> classes more in <a href="ed867897-1e3b-47fe-b646-28484f783f37.xhtml">Chapter 14</a>, <em>Performing I/O Operations</em>. </div>
<p>Using the <kbd>StringReader</kbd> and <kbd>StringWriter</kbd> classes, we can interact with these I/O operations by manipulating the objects of strings and string builders. </p>
<p>Let's go through the <span>following </span>example in order to understand the methods better. In the <span>following </span>example, using <kbd><span>StringWriter</span></kbd>, we are firstly creating an extract of an XML file and then we will pass the resultant XML representation to <span><kbd>StringReader</kbd>, </span>which will try to read an element present in it.</p>
<p>In the <span>following </span><span>code</span><span> example, we are using <kbd>XMLWriter</kbd> to create an XML file with the start element as <kbd>Student</kbd> and an attribute of <kbd>Name</kbd>. We are saving the string representation of the XML file using <kbd>StringWriter</kbd>:</span></p>
<pre>static private string CreateXMLFile()<br/>{<br/>     string xmlOutput = string.Empty;<br/>     var stringWriter = new StringWriter();<br/>     using (XmlWriter writer = XmlWriter.Create(stringWriter))<br/>     {<br/>         writer.WriteStartElement("Student");<br/>         writer.WriteElementString("Name", "Rob");<br/>         writer.WriteEndElement();<br/>         writer.Flush();<br/>     }<br/>     xmlOutput = stringWriter.ToString();<br/>     return xmlOutput;<br/>}</pre>
<p> Suppose we print the output of the program; we will get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a68b5ea5-6854-4116-92f4-e517e562ee0d.png"/></div>
<p>Now, in the <span>following </span>code snippet, we will use <kbd>StringReader</kbd> to read through this XML file:</p>
<pre>static private void ReadXMLFile(string xml)<br/>{<br/>     var stringReader = new StringReader(xml);<br/>     using (XmlReader reader = XmlReader.Create(stringReader))<br/>     {<br/>         reader.ReadToFollowing("Name");<br/>         string studentName = reader.ReadInnerXml();<br/>         Console.WriteLine(studentName);<br/>     }<br/> }</pre>
<p><span>Please note that we are passing a string parameter to the function, which is first converted into a <kbd>StringReader</kbd> object. From that <kbd>StringBuilder</kbd> object, we are creating an <kbd>XmlReader</kbd> object.</span></p>
<p><span>The <kbd>ReadToFollowing</kbd> function reads the XML file until it finds an element with the respective name, which is passed as a parameter to the function. In the preceding code example, we are passing a parameter of <kbd>Name</kbd> to the <kbd>XmlReader</kbd> object. Based upon the XML file we have passed to it, it will take us to the element <kbd>Rob</kbd>. To read the text representation of the element, we can use the  <kbd>ReadInnerXml</kbd> function on the <kbd>reader</kbd> object. Hence, in the preceding example, the <kbd>studentName</kbd> variable will be assigned the value of <kbd>Rob</kbd>. </span><span>If we execute the code snippet, we will get the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ca8789ae-ce24-45c5-8943-a61418924161.png"/></div>
<p><span>In the next section, we will go through some functions we can use to search for particular characters in a string object.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">String searching </h1>
                </header>
            
            <article>
                
<p>As the name suggests, string searching involves searching the presence of a particular letter or string in another string. C# provides several methods for doing this. </p>
<div class="packt_infobox">Please note that C# is a case-sensitive language. Therefore, searching for a character, let's suppose <em>C</em>, is not the same as searching for the character <em>c</em> in the string.</div>
<p><span>Please refer to the </span><span>following </span><span>different types of searching that are possible with the </span><kbd>string</kbd><span> object:</span></p>
<ul>
<li><kbd>Contains</kbd>: When we want to check whether a particular character exists in the string, we use the <kbd>Contains</kbd> function. The following example checks whether a character, <kbd>z</kbd>, exists in the string object. If it exists, it returns <kbd>true</kbd>; otherwise, it returns <kbd>false</kbd>.</li>
</ul>
<p style="padding-left: 60px">Let's take a look at the following example:</p>
<pre style="padding-left: 60px">string s = "hello australia";<br/>var contains = s.Contains("z");<br/>if(contains)<br/>{<br/>   Console.WriteLine(" z is present in it.");<br/>}<br/>else<br/>{<br/>   Console.WriteLine(" z is not present");<br/>}  </pre>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 60px">In the preceding code, using the <kbd>Contains</kbd> <span>function, </span>we are checking whether <kbd>z</kbd> occurs in the string against which we are calling the function. As we are calling it for a variable with the value <kbd>hello australia</kbd>, it will return the <kbd>false</kbd> value as <kbd>z</kbd> does not occur in the string. Hence, we get the following output when the code is executed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e726d1e7-4fb5-4bbc-8a35-05a8f098a627.png"/> </p>
<ul>
<li><kbd>IndexOf</kbd>: We use this function if we want to find out the index in the string at which a particular character is present.</li>
</ul>
<p style="padding-left: 60px">For example, in the <span>following </span>code example, we are finding the first and the last index of occurrence of the <kbd>a</kbd> <span>character </span>in the string <kbd>hello australia</kbd>:  </p>
<pre style="padding-left: 60px"> string s = "hello australia";<br/> var firstIndexOfA = s.IndexOf("a");<br/> Console.WriteLine(firstIndexOfA);<br/> var lastIndexOfA = s.LastIndexOf("a");<br/> Console.WriteLine(lastIndexOfA);</pre>
<p style="padding-left: 60px">When we execute the program, we will get the first occurrence as <span class="packt_screen">6</span> and the last occurrence as <span class="packt_screen">14</span>. The <kbd>IndexOf</kbd> <span>function </span>retrieves the index the first appearance of a character or a string in the string against which we are using the function. Please also note that it does not ignore spaces. Hence, the whitespace is also counted as a character. Similarly, the <kbd>LastIndexOf</kbd> <span>function </span>retrieves the last index of the appearance of the respective character or string:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad91476c-0e17-41d2-8c33-6ccd430b106c.png"/></div>
<p class="mce-root"/>
<div class="packt_infobox">Please note that in C#, for any array or string, the index of the first character is zero. </div>
<ul>
<li><kbd>StartsWith</kbd>/<kbd>EndsWith</kbd>: We use this function if we want to check whether a string starts or ends with a particular character.</li>
</ul>
<p style="padding-left: 60px">The following code example shows a scenario in which we are checking whether the same string object used previously starts with <kbd>h</kbd> and ends with <kbd>h</kbd>. In the following code, in the first statement, we are checking whether the <kbd>s</kbd> <span>string variable </span>starts with <kbd>h</kbd>. Based on the evaluation, we print the output in the console window. Similarly, in the next statement, we are checking whether the same string variable ends with <kbd>h</kbd>. Based on the evaluation, we print the output in the console window again:</p>
<pre style="padding-left: 60px">if(s.StartsWith("h"))<br/>{<br/>     Console.WriteLine("It Starts with h.");<br/>}<br/>else<br/>{<br/>     Console.WriteLine("It does not starts with h.");<br/>}<br/><br/>if (s.EndsWith("h"))<br/>{<br/>     Console.WriteLine("It ends with h.");<br/>}<br/>else<br/>{<br/>     Console.WriteLine("It does not ends with h.");<br/>}</pre>
<p style="padding-left: 60px">Please refer to the <span>following </span>output for the preceding code example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d1b02d4e-a82a-4a9e-82e7-ff5db9ae53ef.png" style=""/></div>
<ul>
<li><kbd>Substring</kbd>: We use this function if we want to extract a substring from a particular string object. There are two variants of substring possible in C#. In one, we specify just the start index and extract the substring from that particular index. In another variant, we specify both the start and end index and extract the characters present in that substring.</li>
</ul>
<p style="padding-left: 60px">Here is a code example of this:</p>
<pre style="padding-left: 60px"> string subString = s.Substring(3, 6);<br/> string subString2 = s.Substring(3);<br/> Console.WriteLine(subString);<br/> Console.WriteLine(subString2);</pre>
<p>In the preceding code example, we are finding two substrings of a string object, <kbd>hello australia</kbd>.</p>
<p>In the first substring, we have passed the start index as 3 and the end index as 6. Therefore, the substring will return us the values, <kbd>lo aus</kbd>. </p>
<p>In the second substring, we are just passing the start index, 3. Hence, it will return the entire string from this index. The <span>following </span>is the screenshot of the output from this execution:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6ce71ca3-d860-434c-b634-e699c5b69c1a.png"/></div>
<p class="mce-root">These are the different string manipulation functions available in C#. In the next section, we will go through an overview of reflection and learn how it helps us to get structureâ€”in other words, classes and their methods and propertiesâ€”from an assembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of reflection</h1>
                </header>
            
            <article>
                
<p>Reflection in C# means inspecting the contents of an assembly at run time. It returns the metadata for each class present in the assemblyâ€”so, it returns the following:</p>
<ul>
<li>The name of the class</li>
<li>All of the properties present in the class</li>
<li>All of the methods along with their return types and function parameters</li>
<li>All of the attributes present in the class</li>
</ul>
<p>In <a href="b7bdae98-fc5b-4430-bb0d-b8541ca64f8d.xhtml">Chapter 10</a><span>, </span><em>Find, Execute, and Create Types at Runtime Using Reflection</em>, we will do a deep dive on reflection; however, in this chapter, we will just go through a code sample of how we can implement reflection in C# to decode all of the metadata present in the assembly.</p>
<p class="mce-root"/>
<p>To use reflection, we need to include the <kbd>System.Reflection</kbd> <span>namespace,</span> which helps us to use required classes such as <kbd>Assembly</kbd>. Please refer to the <span>following </span>function, which reads a particular assembly based on its path and reads all of the classes, methods, and parameters present in the assembly:</p>
<pre>static private void ReadAssembly()<br/>{<br/>     string path = @"C:\UCN Code Base\Programming-in-C-Exam-70-483-<br/>      MCSD-Guide\Book70483Samples\Chapter8\bin\Debug\ABC.dll";<br/>     Assembly assembly = Assembly.LoadFile(path);<br/>     Type[] types = assembly.GetTypes();<br/>     foreach(var type in types)<br/>     {<br/>         Console.WriteLine("Class : " + type.Name);<br/>         MethodInfo[] methods = type.GetMethods();<br/>         foreach(var method in methods)<br/>         {<br/>             Console.WriteLine("--Method: " + method.Name);<br/>             ParameterInfo[] parameters = method.GetParameters();<br/>             foreach (var param in parameters)<br/>             {<br/>                 Console.WriteLine("--- Parameter: " + param.Name + " : <br/>                  " + param.ParameterType); <br/>             }<br/>         }<br/>     }<br/>    Console.ReadLine();<br/>}</pre>
<p>In the preceding code base, we have declared a fully qualified path for an assembly in C#. Next, we have declared an object of the <kbd>Assembly</kbd> <span>class </span>and have retrieved an array of all <kbd>Types</kbd> present in the assembly. Then, <span>we are looping through each type and finding out the methods in each of those types. Once we have a list of metho</span><span>ds for each of the types, we retrieve the list of parameters present in that method and their parameter types</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to manage types in C#. We had a recap of the different data types available in C#. We did a deep dive into value and reference types in C#. We also had a review of the pointer data type and learned how it works. We had a look at some of the practices a user can use to choose the type of a variable. We had a look at generic types and learned how they help us to improve the performance of a system. </p>
<p class="mce-root"/>
<p>Then, we looked at the different techniques we use to consume a type declared in C#. We learned how boxing and unboxing work in C#. We then had a look at how to we consume these data types. We also looked at type conversions, both implicit and explicit, and learned how they help us to convert one data type into another. </p>
<p>Then, we had a look at <kbd>Properties</kbd> and how it helps us to have more control over setting and retrieving values from the field attributes of a class. Then, we worked on strings and learned how they work. We looked at the immutable nature of strings. We looked at using <kbd>StringBuilder</kbd>, <kbd>StringWriter</kbd>, and <kbd>StringReader</kbd>, which help us to improve the performance aspect of using strings. We then looked at the different functions in C# that help us to do different manipulation functions on a string. Finally, we did a high-level review of reflection and, using a code example, we learned how we can retrieve the metadata present in an assembly.</p>
<p><span>In the next chapter, we will look at how garbage collection is performed in C#. We will look at how the CLR manages memory for different data types in C#. We will look at how C# allows us to manage "unmanaged resources" or the "pointer types" that we saw in this chapter. We will also look at how we implement the <kbd>IDisposable</kbd> interface to manage unmanaged resources.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the keyword we use in the program function when we are using a pointer declaration?
<ol>
<li>Sealed</li>
<li>Safe</li>
<li>Internal protected</li>
<li>Unsafe</li>
</ol>
</li>
<li>What would be the output of the <span>following </span>code snippet?</li>
</ol>
<pre style="padding-left: 60px"> float f = 100.23f;<br/> int i = f;<br/> Console.WriteLine(i);</pre>
<ul>
<li style="list-style-type: none">
<ol>
<li>100</li>
<li>Compile-time error</li>
<li>101</li>
<li>Runtime error</li>
</ol>
</li>
</ul>
<ol start="3">
<li>What would be the output of the <span>following </span>code snippet?</li>
</ol>
<pre style="padding-left: 60px">string s = "hello australia";<br/>var contains = s.Contains("A");<br/>if(contains)<br/>{<br/>     Console.WriteLine("it's present");<br/>}<br/>else<br/>{<br/>     Console.WriteLine("it's not present");<br/>}</pre>
<ol>
<li style="padding-left: 30px">It's present</li>
<li style="padding-left: 30px">It's not present</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Unsafe</strong></li>
<li><strong>Compile-time error</strong></li>
<li><strong>It's not present</strong></li>
</ol>


            </article>

            
        </section>
    </body></html>