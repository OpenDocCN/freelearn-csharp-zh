<html><head></head><body>
  <div id="_idContainer098">
   <h1 class="chapter-number" id="_idParaDest-170">
    <a id="_idTextAnchor200">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     14
    </span>
   </h1>
   <h1 id="_idParaDest-171">
    <a id="_idTextAnchor201">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Unit Testing, Compatibility, and Deployment of Minimal APIs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     It’s an exciting time when you’re preparing to deploy an application to production.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Before that can happen, there are many questions to be answered, namely, “Is this quality code?”, “Is everything going to work as intended?”, and “Will it be sustainable over a long period
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      of time?”.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     To help set our minimal APIs up for success, testing is required before they go into the hands of users or become responsible for any critical
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      business operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     This statement is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.8.1">
      really
     </span>
    </em>
    <span class="koboSpan" id="kobo.9.1">
     obvious.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     Of course we need to test, but in some cases, what is less obvious is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.10.1">
      how
     </span>
    </em>
    <span class="koboSpan" id="kobo.11.1">
     we will be testing.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     Unit and integration testing can help us in this area, offering an automated solution to testing our acceptance criteria, checking for new bugs introduced by code changes, often
    </span>
    <a id="_idIndexMarker571">
    </a>
    <span class="koboSpan" id="kobo.12.1">
     referred to as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.13.1">
      regression
     </span>
    </strong>
    <span class="koboSpan" id="kobo.14.1">
     , and giving us (in some IDEs literally) a red or green light
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      for deployment.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.16.1">
     There is also compatibility to consider before deployment.
    </span>
    <span class="koboSpan" id="kobo.16.2">
     What operating system are we deploying to?
    </span>
    <span class="koboSpan" id="kobo.16.3">
     What kind of web server will be in use?
    </span>
    <span class="koboSpan" id="kobo.16.4">
     Are we hosting in the cloud
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.17.1">
      or on-premises?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.18.1">
     Finally, the appropriate method of deployment can be dictated by all of the preceding considerations.
    </span>
    <span class="koboSpan" id="kobo.18.2">
     It seems like a lot, but it will be worth it when we inevitably deploy our minimal APIs with confidence that they will bring the intended value, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.19.1">
      hopefully more.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     In this chapter, we will cover
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.21.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      Unit testing and integration testing for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       minimal APIs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Compatibility and migrating minimal APIs to .
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       NET 9
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.26.1">
      Deploying
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.27.1">
       minimal APIs
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-172">
    <a id="_idTextAnchor202">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     Visual Studio 2022 or the latest version of Visual Studio code is recommended in order to run the code from this chapter.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     The code examples for this chapter are available in the GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      at:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.31.1">
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     To follow along with all deployment methods in this chapter, you will need to have access to an Azure subscription and be able to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.34.1">
      install Docker.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-173">
    <a id="_idTextAnchor203">
    </a>
    <span class="koboSpan" id="kobo.35.1">
     Unit testing and integration testing for minimal APIs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     It’s highly likely that you’ve come across the terms unit testing and integration testing, but by way of a refresher, let’s briefly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      define them.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.38.1">
      Unit testing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.39.1">
     involves testing individual components of functions of a code base in isolation, whereas integration testing checks how different components of modules of a system interact.
    </span>
    <span class="koboSpan" id="kobo.39.2">
     In a minimal API, a unit
    </span>
    <a id="_idIndexMarker572">
    </a>
    <span class="koboSpan" id="kobo.40.1">
     test may simply test that a service does what it
    </span>
    <a id="_idIndexMarker573">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     should, while an integration test would confirm that an HTTP request to the endpoint uses the services and other components
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      together correctly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     In short, you’re either testing a single unit of code, or you’re testing how different units interact with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      each other.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     Let’s create a unit test for a
    </span>
    <a id="_idIndexMarker574">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     service that does something very simple: calculate the sum of given
    </span>
    <a id="_idIndexMarker575">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     numerical values.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     Here is the service as it looks in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.48.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     , where it is registered for dependency injection and used as part of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      POST endpoint:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.51.1">
public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);
        builder.Services.AddTransient&lt;CalculatorService&gt;();
        var app = builder.Build();
        app.MapPost(
            "/SumIntegers",
            (int[] integers,
             CalculatorService calculatorService) =&gt;
        {
            var result = calculatorService.Sum(integers);
            return Results.Ok(result);
        });
        app.Run();
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     There are
    </span>
    <a id="_idIndexMarker576">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     several testing frameworks
    </span>
    <a id="_idIndexMarker577">
    </a>
    <span class="koboSpan" id="kobo.54.1">
     we can implement, but to keep
    </span>
    <a id="_idIndexMarker578">
    </a>
    <span class="koboSpan" id="kobo.55.1">
     things simple, I’m
    </span>
    <a id="_idIndexMarker579">
    </a>
    <span class="koboSpan" id="kobo.56.1">
     going to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      use xUnit:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.58.1">
      Right-click your solution in Visual Studio and select
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.59.1">
       Add
      </span>
     </strong>
     <span class="koboSpan" id="kobo.60.1">
      |
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.61.1">
        New Project…
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.62.1">
       .
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer084">
     <span class="koboSpan" id="kobo.63.1">
      <img alt="Figure 14.1: Add a new project from within Solution Explorer" src="image/B20968_14_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.64.1">
     Figure 14.1: Add a new project from within Solution Explorer
    </span>
   </p>
   <ol>
    <li value="2">
     <span class="koboSpan" id="kobo.65.1">
      Then
     </span>
     <a id="_idIndexMarker580">
     </a>
     <span class="koboSpan" id="kobo.66.1">
      search for
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.67.1">
       xUnit
      </span>
     </strong>
     <span class="koboSpan" id="kobo.68.1">
      (or your
     </span>
     <a id="_idIndexMarker581">
     </a>
     <span class="koboSpan" id="kobo.69.1">
      preferred testing
     </span>
     <a id="_idIndexMarker582">
     </a>
     <span class="koboSpan" id="kobo.70.1">
      framework if you don’t wish to
     </span>
     <a id="_idIndexMarker583">
     </a>
     <span class="koboSpan" id="kobo.71.1">
      follow
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.72.1">
       along exactly).
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer085">
     <span class="koboSpan" id="kobo.73.1">
      <img alt="Figure 14.2: Creating a new xUnit project" src="image/B20968_14_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.74.1">
     Figure 14.2: Creating a new xUnit project
    </span>
   </p>
   <ol>
    <li value="3">
     <span class="koboSpan" id="kobo.75.1">
      If the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.76.1">
       Do not use top-level statements
      </span>
     </strong>
     <span class="koboSpan" id="kobo.77.1">
      option is shown, I recommend unchecking it so
     </span>
     <a id="_idIndexMarker584">
     </a>
     <span class="koboSpan" id="kobo.78.1">
      that you can
     </span>
     <a id="_idIndexMarker585">
     </a>
     <span class="koboSpan" id="kobo.79.1">
      clearly see the namespaces you’re using
     </span>
     <a id="_idIndexMarker586">
     </a>
     <span class="koboSpan" id="kobo.80.1">
      in each class.
     </span>
     <span class="koboSpan" id="kobo.80.2">
      It is a
     </span>
     <a id="_idIndexMarker587">
     </a>
     <span class="koboSpan" id="kobo.81.1">
      personal preference but it will make it easier for you to follow along with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.82.1">
       this example.
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer086">
     <span class="koboSpan" id="kobo.83.1">
      <img alt="Figure 14.3: Unchecking the Do not use top-level statements box" src="image/B20968_14_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.84.1">
     Figure 14.3: Unchecking the Do not use top-level statements box
    </span>
   </p>
   <ol>
    <li value="4">
     <span class="koboSpan" id="kobo.85.1">
      Once you’ve created your test project within the solution, right-click
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.86.1">
       Dependencies
      </span>
     </strong>
     <span class="koboSpan" id="kobo.87.1">
      for the test project and add a project reference to your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.88.1">
       API project.
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer087">
     <span class="koboSpan" id="kobo.89.1">
      <img alt="Figure 14.4: Adding a reference to another project" src="image/B20968_14_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.90.1">
     Figure 14.4: Adding a reference to another project
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     You now have two projects
    </span>
    <a id="_idIndexMarker588">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     in your solution.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     One is a minimal API project and the other is a testing project linked to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.93.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker589">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      former.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.95.1">
     We can now start writing some
    </span>
    <a id="_idIndexMarker590">
    </a>
    <span class="koboSpan" id="kobo.96.1">
     tests.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     Let’s start with a simple unit test
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      against
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.98.1">
       CalculatorService
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     In our test project, create
    </span>
    <a id="_idIndexMarker591">
    </a>
    <span class="koboSpan" id="kobo.100.1">
     a new class called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.101.1">
      CalculatorTests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.102.1">
     .
    </span>
    <span class="koboSpan" id="kobo.102.2">
     Then, update the code so that a method called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.103.1">
      Sum_Test()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     exists, with an attribute above the method
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.105.1">
      signature,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.106.1">
       [Fact]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.108.1">
[Fact]
public void Sum_Test()
{
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.110.1">
      [Fact]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.111.1">
     attribute is what xUnit uses to mark a method as a test.
    </span>
    <span class="koboSpan" id="kobo.111.2">
     I like to think of it in the sense that we are stating that the method represents something that should be fact; it should be objective.
    </span>
    <span class="koboSpan" id="kobo.111.3">
     In this case, we want a test that proves the fact that the sum of a given collection of integers is equal to the value we are expecting it to be.
    </span>
    <span class="koboSpan" id="kobo.111.4">
     Let’s explore this in more detail by writing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      test logic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     In the body of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.114.1">
      Sum_Test()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.115.1">
     , instantiate a new instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.116.1">
      CalculatorService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.117.1">
     and create an array of integers that we can use during
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.118.1">
      our test:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.119.1">
var calculatorService = new CalculatorService();
int[] integers = [ 1, 1, 8 ];</span></pre>
   <p>
    <span class="koboSpan" id="kobo.120.1">
     Because we kept this simple, it is easy to see at a glance that the expected result for the sum of the values in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.121.1">
      integers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     must
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      be
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.124.1">
       10
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     Add a call to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.127.1">
      Sum()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.128.1">
     function within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.129.1">
      CalculatorService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.130.1">
     and store it in a variable.
    </span>
    <span class="koboSpan" id="kobo.130.2">
     Also, add a hardcoded
    </span>
    <a id="_idIndexMarker592">
    </a>
    <span class="koboSpan" id="kobo.131.1">
     variable of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      expected result:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.135.1">
var result = calculatorService.Sum(integers);
var expectedResult = 10;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     In unit testing, there is a principle
    </span>
    <a id="_idIndexMarker593">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     known as the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.138.1">
      three As
     </span>
    </em>
    <span class="koboSpan" id="kobo.139.1">
     , which stands
    </span>
    <a id="_idIndexMarker594">
    </a>
    <span class="koboSpan" id="kobo.140.1">
     for arrange, act,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      and assert:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.142.1">
      The first step, arrange, forces
     </span>
     <a id="_idIndexMarker595">
     </a>
     <span class="koboSpan" id="kobo.143.1">
      us to gather data and resources in a particular state so that testing
     </span>
     <a id="_idIndexMarker596">
     </a>
     <span class="koboSpan" id="kobo.144.1">
      is possible.
     </span>
     <span class="koboSpan" id="kobo.144.2">
      We have achieved this by creating an instance of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.145.1">
       CalculatorService
      </span>
     </strong>
     <span class="koboSpan" id="kobo.146.1">
      , an array of integers we know should add up to 10, which we have also hardcoded into a variable for reference.
     </span>
     <span class="koboSpan" id="kobo.146.2">
      Finally, we make the call to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.147.1">
       Sum()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.148.1">
      function to obtain the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.149.1">
       actual result.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.150.1">
      The second step is act.
     </span>
     <span class="koboSpan" id="kobo.150.2">
      This simply means that action is taken to enable the test to be evaluated.
     </span>
     <span class="koboSpan" id="kobo.150.3">
      For example, if you’re testing a calculation between two integer values, the actual calculation would take place at
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.151.1">
       this point.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.152.1">
      The final step is assert.
     </span>
     <span class="koboSpan" id="kobo.152.2">
      An assertion is the test itself.
     </span>
     <span class="koboSpan" id="kobo.152.3">
      In this, we will assert that our
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.153.1">
       [Fact]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.154.1">
      is true.
     </span>
     <span class="koboSpan" id="kobo.154.2">
      If the assertion is correct,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.155.1">
       [Fact]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.156.1">
      is true and the test will pass.
     </span>
     <span class="koboSpan" id="kobo.156.2">
      If the assertion is incorrect, the test
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.157.1">
       will fail.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.158.1">
     Different testing frameworks have their own implementation of an assertion, but the principle remains the same.
    </span>
    <span class="koboSpan" id="kobo.158.2">
     In xUnit, a static class,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.159.1">
      Assert
     </span>
    </strong>
    <span class="koboSpan" id="kobo.160.1">
     , holds various types of assertions that can be used during testing.
    </span>
    <span class="koboSpan" id="kobo.160.2">
     For example, an assertion that something is null or not null is represented via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.161.1">
      Assert.Null()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.162.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      Assert.NotNull()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     , respectively.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     Likewise, we can
    </span>
    <a id="_idIndexMarker597">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     assert that a statement is true
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.167.1">
       Assert.True()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.168.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.169.1">
     We want to assert that
    </span>
    <a id="_idIndexMarker598">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     the expected result of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      Sum()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     is equal to the actual result.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     For this, we can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.173.1">
      use
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.174.1">
       Assert.Equal()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.176.1">
[Fact]
public void Sum_Test()
{
    var calculatorService = new CalculatorService();
    int[] integers = { 1, 1, 8 };
    var result = calculatorService.Sum(integers);
    var expectedResult = 10;
    Assert.Equal(result, expectedResult);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.177.1">
     Running this test is as simple as right-clicking the method signature and selecting
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.178.1">
      Run Tests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     .
    </span>
    <span class="koboSpan" id="kobo.179.2">
     The test will run, and the
    </span>
    <a id="_idIndexMarker599">
    </a>
    <span class="koboSpan" id="kobo.180.1">
     test result will be shown by Visual Studio in Test
    </span>
    <a id="_idIndexMarker600">
    </a>
    <span class="koboSpan" id="kobo.181.1">
     Explorer.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     You should see a green circle next to the test to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      indicate success.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer088">
     <span class="koboSpan" id="kobo.183.1">
      <img alt="Figure 14.5: The Test Explorer screen, showing available tests and their results" src="image/B20968_14_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.184.1">
     Figure 14.5: The Test Explorer screen, showing available tests and their results
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.185.1">
     A similar approach to writing tests can be taken for integration tests, the main difference being the scope of the test.
    </span>
    <span class="koboSpan" id="kobo.185.2">
     For this example, a minimal API, a simple integration test’s scope could cover a whole endpoint.
    </span>
    <span class="koboSpan" id="kobo.185.3">
     Let’s put this into practice by writing an integration test for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.186.1">
      /sumintegers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.187.1">
     API endpoint that checks the resulting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      status code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     To run this test, we will need to be able to access an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.190.1">
      HttpClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.191.1">
     object and run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     in the test project, because
    </span>
    <a id="_idIndexMarker601">
    </a>
    <span class="koboSpan" id="kobo.194.1">
     the test needs to make a request against an endpoint.
    </span>
    <span class="koboSpan" id="kobo.194.2">
     To make
    </span>
    <a id="_idIndexMarker602">
    </a>
    <span class="koboSpan" id="kobo.195.1">
     this possible, you can make your test class implement
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.196.1">
      IClassFixture
     </span>
    </strong>
    <span class="koboSpan" id="kobo.197.1">
     of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      type
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.199.1">
       WebApplicationFactory
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      .
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.201.1">
     IClassFixture usage in a test class
    </span>
   </p>
   <p class="callout">
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      IClassFixture
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     is an interface that allows objects to share scope across a class.
    </span>
    <span class="koboSpan" id="kobo.203.2">
     In this case, we want to share the scope of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      WebApplicationFactory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     object so that an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      HttpClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     instance can be created for tests within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.208.1">
      the class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.209.1">
     Because
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      WebApplicationFactory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     needs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.212.1">
      Microsoft.AspNetCore.Mvc.Testing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.213.1">
     to be installed, use the NuGet package manager console to install
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      this
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker603">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      package:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.216.1">
dotnet add package Microsoft.AspNetCore.Mvc.Testing</span></pre>
   <p>
    <span class="koboSpan" id="kobo.217.1">
     Update the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.218.1">
      CalculatorTests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     class so that it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.220.1">
      implements
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.221.1">
       IClassFixture
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.222.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.223.1">
public class CalculatorTests :
    IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     This will require you to add a
    </span>
    <a id="_idIndexMarker604">
    </a>
    <span class="koboSpan" id="kobo.225.1">
     constructor for the class, in which you can inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.226.1">
      WebApplicationFactory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     .
    </span>
    <span class="koboSpan" id="kobo.227.2">
     You can also use this
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      WebApplicationFactory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     to create a new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      HttpClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     for use during tests.
    </span>
    <span class="koboSpan" id="kobo.231.2">
     Let’s store this in a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.232.1">
      readonly
     </span>
    </strong>
    <span class="koboSpan" id="kobo.233.1">
     field so that we can keep things clean by not reinitializing it after the constructor
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.234.1">
      has run:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.235.1">
private readonly HttpClient _httpClient;
public CalculatorTests(
    WebApplicationFactory&lt;Program&gt; applicationFactory)
{
    _httpClient = applicationFactory.CreateClient();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     Finally, we can write our tests.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     Let’s
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.237.1">
      arrange
     </span>
    </em>
    <span class="koboSpan" id="kobo.238.1">
     our test data by creating the required parameters as an array of
    </span>
    <a id="_idIndexMarker605">
    </a>
    <span class="koboSpan" id="kobo.239.1">
     integers and then serializing them to a JSON string so that they can be added to the
    </span>
    <a id="_idIndexMarker606">
    </a>
    <span class="koboSpan" id="kobo.240.1">
     body of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.241.1">
      the request:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.242.1">
[Fact]
public async Task SumIntegers_ShouldReturnOk()
{
    //Arrange
    var integers = new[] { 2, 4, 4 };
    var jsonContent = new
        StringContent(JsonSerializer.Serialize(integers),
        Encoding.UTF8,
        "application/json"
    );
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.243.1">
     Next, we can
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.244.1">
      act
     </span>
    </em>
    <span class="koboSpan" id="kobo.245.1">
     by making
    </span>
    <a id="_idIndexMarker607">
    </a>
    <span class="koboSpan" id="kobo.246.1">
     the POST request to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      target endpoint:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.248.1">
// Act
var response = await _httpClient.PostAsync(
    "/SumIntegers", jsonContent);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.249.1">
     Finally, we can
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.250.1">
      assert
     </span>
    </em>
    <span class="koboSpan" id="kobo.251.1">
     that the
    </span>
    <a id="_idIndexMarker608">
    </a>
    <span class="koboSpan" id="kobo.252.1">
     response code is the one we were expecting, in this case,
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       200 OK
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.255.1">
Assert.Equal(HttpStatusCode.OK, response.StatusCode);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     You could also assert that the result is the expected one by checking the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.257.1">
      response content:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.258.1">
Assert.Equal(10, JsonSerializer.Deserialize&lt;int&gt;(await response.Content.ReadAsStringAsync()));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     This integration test may look pretty similar to the original unit test we wrote earlier in this chapter, but it differs in the sense that it has a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      wider scope.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     By calling this test, we not only make a request to the target endpoint, but we also cover the testing of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.262.1">
      encapsulated
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.263.1">
       CalculatorService
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     In both of these examples, integration and unit testing were conducted on pre-existing logic.
    </span>
    <span class="koboSpan" id="kobo.265.2">
     If we were to adopt
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.266.1">
      Test-Driven Development
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.268.1">
      TDD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.269.1">
     ), we would augment our practices by writing the tests before any logic.
    </span>
    <span class="koboSpan" id="kobo.269.2">
     Obviously, we expect the tests to fail initially, but our goal is to write code
    </span>
    <a id="_idIndexMarker609">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     that allows the tests to pass.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     Assuming
    </span>
    <a id="_idIndexMarker610">
    </a>
    <span class="koboSpan" id="kobo.271.1">
     your tests make the same assertions as your acceptance criteria from an API
    </span>
    <a id="_idIndexMarker611">
    </a>
    <span class="koboSpan" id="kobo.272.1">
     requirements perspective, TDD is widely considered the optimal way to apply automated testing to a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      code base.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     TDD or not, however you approach
    </span>
    <a id="_idIndexMarker612">
    </a>
    <span class="koboSpan" id="kobo.275.1">
     unit and integration testing, having test coverage will help to increase the quality of your minimal API code, and hopefully reduce
    </span>
    <a id="_idIndexMarker613">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     the number of reported
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.277.1">
      bugs post-release.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     When it comes to the quality and stability of an API, testing the code’s logic is one aspect; but before moving to deployment, there is another aspect to be considered: that of compatibility.
    </span>
    <span class="koboSpan" id="kobo.278.2">
     Let’s explore compatibility, with a particular focus on the latest version of .NET at the time of writing – .
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      NET 9.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-174">
    <a id="_idTextAnchor204">
    </a>
    <span class="koboSpan" id="kobo.280.1">
     Compatibility and migrating minimal APIs to .NET 9
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.281.1">
     Let’s assume that you have already created a minimal API project, but the .NET version is not the latest.
    </span>
    <span class="koboSpan" id="kobo.281.2">
     You wish to deploy the API, but
    </span>
    <a id="_idIndexMarker614">
    </a>
    <span class="koboSpan" id="kobo.282.1">
     before you do so, you intend to bring the code base to the latest .NET version, which at the time of writing this book is 9.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     What
    </span>
    <a id="_idIndexMarker615">
    </a>
    <span class="koboSpan" id="kobo.283.1">
     factors do we need to consider to be confident that our application will run efficiently on this new version, and how can we migrate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      to it?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.285.1">
     Before any .NET migration, it is critical that you consult Microsoft’s documentation, where any known breaking changes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.286.1">
      are outlined.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.287.1">
     .NET breaking changes fall into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      three categories:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.289.1">
       Binary incompatible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.290.1">
      : Existing binaries
     </span>
     <a id="_idIndexMarker616">
     </a>
     <span class="koboSpan" id="kobo.291.1">
      may fail to load and may need to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.292.1">
       be recompiled.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.293.1">
       Source incompatible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.294.1">
      : Code may require
     </span>
     <a id="_idIndexMarker617">
     </a>
     <span class="koboSpan" id="kobo.295.1">
      change in order
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.296.1">
       to compile.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.297.1">
       Behavioral change
      </span>
     </strong>
     <span class="koboSpan" id="kobo.298.1">
      : Code and binaries may behave differently after update, meaning code changes would
     </span>
     <a id="_idIndexMarker618">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.299.1">
       be required.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     While Microsoft is usually pretty effective in avoiding major breaking changes, checking the documentation at
    </span>
    <a href="https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0">
     <span class="koboSpan" id="kobo.301.1">
      https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0
     </span>
    </a>
    <span class="koboSpan" id="kobo.302.1">
     ahead of time will provide valuable insight into any potential issues you may face.
    </span>
    <span class="koboSpan" id="kobo.302.2">
     On top of this, if a breaking change does find its way into the minimal API post-update, unit and integration tests will increase the chances of the breaking changes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      being caught.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     Microsoft outlines breaking changes for different
    </span>
    <a id="_idIndexMarker619">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     areas of .NET.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     For minimal APIs, you will be most concerned with changes
    </span>
    <a id="_idIndexMarker620">
    </a>
    <span class="koboSpan" id="kobo.306.1">
     in the area of ASP.NET, but ensure you review other areas, such as core .NET libraries, deployment, networking, SDK, MSBuild, and serialization, as these are secondary areas that are all relevant to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.307.1">
      minimal APIs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     At the time of writing, there are only two breaking changes outlined in ASP.NET for .NET 9, which are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.309.1">
      summarized here:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.310.1">
       DefaultKeyResolution.ShouldGenerateNewKey
      </span>
     </strong>
     <span class="koboSpan" id="kobo.311.1">
      : There is a different meaning behind Boolean (true/false) result returned in previous versions.
     </span>
     <span class="koboSpan" id="kobo.311.2">
      This breaking change is caused by a redefinition of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.312.1">
       true/false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.313.1">
      result returned by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.314.1">
       ShouldGenerateNewKey
      </span>
     </strong>
     <span class="koboSpan" id="kobo.315.1">
      .
     </span>
     <span class="koboSpan" id="kobo.315.2">
      Let’s delve into this in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.316.1">
       more detail:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.317.1">
        When managing keys in your minimal API, if you’re using ASP.NET’s default implementation to generate the key, there is a Boolean that is provided to tell you whether a new key should
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.318.1">
         be generated.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.319.1">
        Previously, the result of the Boolean was produced based on whether the default key was within two days
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.320.1">
         of expiration.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.321.1">
        It was decided that “within two days” of expiration was not appropriate on its own, as there are other factors that could influence whether the key should be regenerated.
       </span>
       <span class="koboSpan" id="kobo.321.2">
        Now, the result of
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.322.1">
         ShouldGenerateNewKey
        </span>
       </strong>
       <span class="koboSpan" id="kobo.323.1">
        is based on several factors related to
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.324.1">
         IdefaultKeyResolver
        </span>
       </strong>
       <span class="koboSpan" id="kobo.325.1">
        as well as whether or not a default key exists in the first place, rather than an arbitrary meaning based on whether the key is two days away
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.326.1">
         from expiry.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.327.1">
      When a minimal API application starts, you can specify in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.328.1">
       UseDefaultServiceProvider
      </span>
     </strong>
     <span class="koboSpan" id="kobo.329.1">
      whether validation should be run on registered services and
     </span>
     <a id="_idIndexMarker621">
     </a>
     <span class="koboSpan" id="kobo.330.1">
      service scopes.
     </span>
     <span class="koboSpan" id="kobo.330.2">
      Previously, validation was always turned off by default.
     </span>
     <span class="koboSpan" id="kobo.330.3">
      Let’s
     </span>
     <a id="_idIndexMarker622">
     </a>
     <span class="koboSpan" id="kobo.331.1">
      break down this change a little further to see whether it affects your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.332.1">
       existing code:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.333.1">
        The validation of services ensures that all services can be created
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.334.1">
         at startup.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.335.1">
        The validation of scopes checks that scoped services are not resolved from the root provider, which would violate
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.336.1">
         their scope.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.337.1">
        Overall, this meant that no validation was performed by default.
       </span>
       <span class="koboSpan" id="kobo.337.2">
        You had to turn on the previous validation for it to be executed when the application is loaded.
       </span>
       <span class="koboSpan" id="kobo.337.3">
        However, validation is now performed
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.338.1">
         by default.
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     Based on this, there are no major breaking changes when moving a minimal API to .NET 9 (at least where ASP.NET Core is concerned).
    </span>
    <span class="koboSpan" id="kobo.339.2">
     However, it is still important to be prepared for any potential change.
    </span>
    <span class="koboSpan" id="kobo.339.3">
     With that in mind, how would we mitigate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.340.1">
      these changes?
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.341.1">
      For
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.342.1">
       DefaultKeyResolution.ShouldGenerateNewKey
      </span>
     </strong>
     <span class="koboSpan" id="kobo.343.1">
      affecting key resolution, you only really need to act if you have written logic that is now redundant thanks to the way .NET 9 checks for an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.344.1">
       expired key.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.345.1">
       For example, if previously you were checking that a default key exists, you no longer need to do this, because .NET 9 does this for you.
      </span>
      <span class="koboSpan" id="kobo.345.2">
       The impact of this change is therefore
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.346.1">
        fairly minimal.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.347.1">
      For
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.348.1">
       UseDefaultServiceProvider
      </span>
     </strong>
     <span class="koboSpan" id="kobo.349.1">
      , the required changes are simple.
     </span>
     <span class="koboSpan" id="kobo.349.2">
      If by updating your minimal API to .NET 9 you start to see errors on startup owing to the fact that validation of services and scope is now enabled by default, you must address the outputted
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.350.1">
       validation errors.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     For most basic scenarios, it is unlikely that your minimal API is configured in such a way that services could not be resolved or
    </span>
    <a id="_idIndexMarker623">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     scoped services are being incorrectly resolved from the root provider, but it is
    </span>
    <a id="_idIndexMarker624">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     still important to be aware of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      these factors.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.355.1">
     Accuracy at the time of writing and other affected areas of .NET
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.356.1">
     It is important to emphasize that these changes were reported before the release of .NET 9, during its preview.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     Developers must consult Microsoft’s documentation before any migration to see whether any further breaking changes have been reported.
    </span>
    <span class="koboSpan" id="kobo.356.3">
     Moreover, the summary provided in this book is only targeting ASP.NET Core, which is the main area we are concerned with when writing minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.356.4">
     However, other areas mentioned, such as the .NET SDK, networking, and serialization, could all affect minimal API projects depending on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      use case.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.358.1">
     Now that we’ve explored the potential compatibility issues we face when publishing a minimal API application to .NET 9, let’s look at the various methods of deployment we have at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.359.1">
      our disposal.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-175">
    <a id="_idTextAnchor205">
    </a>
    <span class="koboSpan" id="kobo.360.1">
     Deploying minimal APIs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.361.1">
     There are many different
    </span>
    <a id="_idIndexMarker625">
    </a>
    <span class="koboSpan" id="kobo.362.1">
     ways to deploy a minimal API project, and exploring them all would be way out of the scope of this book.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     However, we can look at some of the most common
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      deployment targets.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-176">
    <a id="_idTextAnchor206">
    </a>
    <span class="koboSpan" id="kobo.364.1">
     Deploying to Microsoft Azure App Service (cloud deployment)
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.365.1">
     Deploying to Azure App Service is very straightforward and can be achieved using a publish profile in Visual Studio.
    </span>
    <span class="koboSpan" id="kobo.365.2">
     A
    </span>
    <a id="_idIndexMarker626">
    </a>
    <span class="koboSpan" id="kobo.366.1">
     publish profile is a configuration object that specifies how a project should be deployed.
    </span>
    <span class="koboSpan" id="kobo.366.2">
     It contains metadata about the type of runtime in play, the target architecture (x86, ARM, etc.), and the target host, which in this example will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      be Azure.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.368.1">
     For the purposes of this example, I’m assuming that an Azure App Service instance exists in your Azure subscription, to which you are allowed to deploy.
    </span>
    <span class="koboSpan" id="kobo.368.2">
     If an App Service instance does not exist in Azure, you will need to create one.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.369.1">
     The pricing for Azure app services can be calculated via Microsoft’s pricing calculator at https://azure.microsoft.com/en-gb/pricing/calculator/.
    </span>
    <span class="koboSpan" id="kobo.369.2">
     At the time of writing, there is a free tier that allows for basic testing which will probably be suitable for most people reading this book to practice their deployment.
    </span>
    <span class="koboSpan" id="kobo.369.3">
     A basic tier app service currently costs approx $55-60 per month, but this can increase depending on the use case and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      required specification.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.371.1">
     The creation of an App Service instance is out of the scope of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      this book:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.373.1">
      First, right-click on the project you wish to deploy in
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.374.1">
       Solution Explorer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.375.1">
      in Visual Studio and then
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.376.1">
       click
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.377.1">
        Publish…
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.378.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer089">
     <span class="koboSpan" id="kobo.379.1">
      <img alt="Figure 14.6: Publishing from Solution Explorer in Visual Studio" src="image/B20968_14_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.380.1">
     Figure 14.6: Publishing from Solution Explorer in Visual Studio
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.381.1">
     If you don’t have any publish profiles already set up, you will see the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.382.1">
      Publish
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     dialog.
    </span>
    <span class="koboSpan" id="kobo.383.2">
     If
    </span>
    <a id="_idIndexMarker627">
    </a>
    <span class="koboSpan" id="kobo.384.1">
     you don’t see this, it’s because you do already have a publish profile for another deployment.
    </span>
    <span class="koboSpan" id="kobo.384.2">
     You can select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.385.1">
      Add a publish profile
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     to open the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.387.1">
      Publish
     </span>
    </strong>
    <span class="koboSpan" id="kobo.388.1">
     dialog if this is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.389.1">
      the case.
     </span>
    </span>
   </p>
   <ol>
    <li value="2">
     <span class="koboSpan" id="kobo.390.1">
      Once you see the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.391.1">
       Publish
      </span>
     </strong>
     <span class="koboSpan" id="kobo.392.1">
      dialog,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.393.1">
       select
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.394.1">
        Azure
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.395.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer090">
     <span class="koboSpan" id="kobo.396.1">
      <img alt="Figure 14.7: Selecting a publish target in Visual Studio" src="image/B20968_14_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.397.1">
     Figure 14.7: Selecting a publish target in Visual Studio
    </span>
   </p>
   <ol>
    <li value="3">
     <span class="koboSpan" id="kobo.398.1">
      Then select
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.399.1">
       Azure App Service
      </span>
     </strong>
     <span class="koboSpan" id="kobo.400.1">
      , ensuring that you select the correct operating system running on the target App Service in Azure (Windows
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.401.1">
       or Linux).
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.402.1">
       The next screen will then request that you choose your Azure
      </span>
      <a id="_idIndexMarker628">
      </a>
      <span class="koboSpan" id="kobo.403.1">
       subscription.
      </span>
      <span class="koboSpan" id="kobo.403.2">
       If you’re not already logged in to Azure, you can connect using the option at the top right of
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.404.1">
        the dialog.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.405.1">
      Once connected, you should see your Azure subscription in the dropdown, along with the available App Service instances to deploy to.
     </span>
     <span class="koboSpan" id="kobo.405.2">
      Select the service you wish to target and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.406.1">
       click
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.407.1">
        Next
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.408.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer091">
     <span class="koboSpan" id="kobo.409.1">
      <img alt="Figure 14.8: Choosing the target Azure App Service resource" src="image/B20968_14_08.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.410.1">
     Figure 14.8: Choosing the target Azure App Service resource
    </span>
   </p>
   <ol>
    <li value="5">
     <span class="koboSpan" id="kobo.411.1">
      Finally, you will be
     </span>
     <a id="_idIndexMarker629">
     </a>
     <span class="koboSpan" id="kobo.412.1">
      asked whether you wish to publish using a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.413.1">
       .pubxml
      </span>
     </strong>
     <span class="koboSpan" id="kobo.414.1">
      file or via GitHub Actions.
     </span>
     <span class="koboSpan" id="kobo.414.2">
      We won’t be covering continuous integration/continuous delivery pipelines such as GitHub Actions in this book, so
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.415.1">
       select
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.416.1">
        Publish
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.417.1">
       .
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer092">
     <span class="koboSpan" id="kobo.418.1">
      <img alt="Figure 14.9: Choosing the publish output type" src="image/B20968_14_09.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.419.1">
     Figure 14.9: Choosing the publish output type
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.420.1">
     Once this is complete, the dialog will close and your new publish profile is created.
    </span>
    <span class="koboSpan" id="kobo.420.2">
     From there you can see and change the publish settings, such as what configuration you
    </span>
    <a id="_idIndexMarker630">
    </a>
    <span class="koboSpan" id="kobo.421.1">
     will be publishing (almost always
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.422.1">
      Release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     ), the framework which in our example is .NET9, the deployment mode, which is either
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.424.1">
      Framework - dependent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.426.1">
      Self - contained
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     (More on that below) and the target runtime which in my example is
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.428.1">
       64bit Linux
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer093">
     <span class="koboSpan" id="kobo.430.1">
      <img alt="Figure 14.10: The newly created publish profile" src="image/B20968_14_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.431.1">
     Figure 14.10: The newly created publish profile
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.432.1">
     Do this and your application
    </span>
    <a id="_idIndexMarker631">
    </a>
    <span class="koboSpan" id="kobo.433.1">
     will be built before being deployed to the target App Service.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     Once completed, Visual Studio will automatically open a browser window and navigate to the minimal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      API’s URL.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.435.1">
     Framework-dependent versus self-contained deployment modes
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.436.1">
     You have two choices of deployment mode.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.437.1">
      Framework-dependent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     requires that .NET 9 (or whichever version you are
    </span>
    <a id="_idIndexMarker632">
    </a>
    <span class="koboSpan" id="kobo.439.1">
     using) is installed on the target machine.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.440.1">
      Self-contained
     </span>
    </strong>
    <span class="koboSpan" id="kobo.441.1">
     will package the runtime with the application.
    </span>
    <span class="koboSpan" id="kobo.441.2">
     The former produces a smaller set of output files
    </span>
    <a id="_idIndexMarker633">
    </a>
    <span class="koboSpan" id="kobo.442.1">
     but has the drawback of requiring the specific .NET version to be installed on the target machine, whereas the latter has a larger output but has fewer prerequisites for the target machine for the application to run, making it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      more portable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.444.1">
     Next, let’s move on to deploying to a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.445.1">
      Docker container.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-177">
    <a id="_idTextAnchor207">
    </a>
    <span class="koboSpan" id="kobo.446.1">
     Deploying to a Docker container
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.447.1">
     ASP.NET and .NET Core are already well positioned to offer cross-platform functionality, but there are still subtle differences in
    </span>
    <a id="_idIndexMarker634">
    </a>
    <span class="koboSpan" id="kobo.448.1">
     configuration depending on the host operating system.
    </span>
    <span class="koboSpan" id="kobo.448.2">
     Containerizing your minimal API application with Docker can make it agnostic, meaning that it doesn’t care what operating system it’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.449.1">
      running on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     Firstly, you must ensure that Docker is installed on your system.
    </span>
    <span class="koboSpan" id="kobo.450.2">
     Documentation outlining this is available at
    </span>
    <a href="https://docs.docker.com/engine/install/">
     <span class="koboSpan" id="kobo.451.1">
      https://docs.docker.com/engine/install/
     </span>
    </a>
    <span class="koboSpan" id="kobo.452.1">
     .
    </span>
    <span class="koboSpan" id="kobo.452.2">
     For Windows, you will need to install Docker Desktop, documentation for which can be found here at
    </span>
    <a href="https://docs.docker.com/desktop/install/windows-install/">
     <span class="koboSpan" id="kobo.453.1">
      https://docs.docker.com/desktop/install/windows-install/
     </span>
    </a>
    <span class="koboSpan" id="kobo.454.1">
     , whereas for Linux, simply running Docker Engine
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      should suffice.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     Once you have completed the install, you need to create a Dockerfile, which will describe how your minimal API project should be packaged into a Docker container as well as how it should run on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      host machine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.458.1">
     You can create this file within your project as a new item in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.459.1">
      Visual Studio:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.460.1">
      Select the button at the top left of
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.461.1">
       Solution Explorer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.462.1">
      to change
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.463.1">
       the view:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer094">
     <span class="koboSpan" id="kobo.464.1">
      <img alt="Figure 14.11: Changing view options in Solution Explorer" src="image/B20968_14_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.465.1">
     Figure 14.11: Changing view options in Solution Explorer
    </span>
   </p>
   <ol>
    <li value="2">
     <span class="koboSpan" id="kobo.466.1">
      Select
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.467.1">
        Folder View
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.468.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer095">
     <span class="koboSpan" id="kobo.469.1">
      <img alt="Figure 14.12: Switching to Folder View" src="image/B20968_14_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.470.1">
     Figure 14.12: Switching to Folder View
    </span>
   </p>
   <ol>
    <li value="3">
     <span class="koboSpan" id="kobo.471.1">
      Then, right-click your project folder and select
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.472.1">
       Add
      </span>
     </strong>
     <span class="koboSpan" id="kobo.473.1">
      |
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.474.1">
        New File
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.475.1">
       .
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer096">
     <span class="koboSpan" id="kobo.476.1">
      <img alt="Figure 14.13: Creating a new file in the project within Folder View" src="image/B20968_14_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.477.1">
     Figure 14.13: Creating a new file in the project within Folder View
    </span>
   </p>
   <ol>
    <li value="4">
     <span class="koboSpan" id="kobo.478.1">
      A Docker file has no name, just an extension of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.479.1">
       .dockerfile
      </span>
     </strong>
     <span class="koboSpan" id="kobo.480.1">
      .
     </span>
     <span class="koboSpan" id="kobo.480.2">
      Create this file.
     </span>
     <span class="koboSpan" id="kobo.480.3">
      It should then open as a tab in Visual Studio.
     </span>
     <span class="koboSpan" id="kobo.480.4">
      (There are reports of issues with Docker files not working unless they are called
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.481.1">
       Dockerfile
      </span>
     </strong>
     <span class="koboSpan" id="kobo.482.1">
      , so you can try this if you are having
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.483.1">
       similar issues.)
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.484.1">
     Now we can write the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.485.1">
      Docker file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.486.1">
     First, we need to specify a
    </span>
    <a id="_idIndexMarker635">
    </a>
    <span class="koboSpan" id="kobo.487.1">
     base image to be used for the runtime environment of the minimal API application.
    </span>
    <span class="koboSpan" id="kobo.487.2">
     We can pull the official .NET 9 ASP.NET runtime image from Microsoft’s container registry
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.488.1">
      like so:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.489.1">
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base</span></pre>
   <p>
    <span class="koboSpan" id="kobo.490.1">
     Then, we can tell Docker that we want to set the working directory inside the container to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.491.1">
      /app
     </span>
    </strong>
    <span class="koboSpan" id="kobo.492.1">
     , so that any subsequent commands will be executed relative to this directory.
    </span>
    <span class="koboSpan" id="kobo.492.2">
     We will also specify that we wish to expose port
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.493.1">
      80
     </span>
    </strong>
    <span class="koboSpan" id="kobo.494.1">
     on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.495.1">
      the container:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.496.1">
WORKDIR /app
EXPOSE 80</span></pre>
   <p>
    <span class="koboSpan" id="kobo.497.1">
     Next, we add a section that downloads the .NET 9 SDK, which will be required as the full runtime necessary for compiling the minimal API application.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     We then set the working directory again, this time to a folder of our choice; we’ll
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      choose
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.499.1">
       /src
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     Following this, the entire content of the current directory is copied into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.502.1">
      /src
     </span>
    </strong>
    <span class="koboSpan" id="kobo.503.1">
     directory inside the container so that it can be built,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.504.1">
      dotnet restore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.505.1">
     is executed to add any NuGet packages required as dependencies, and the app is compiled in release mode to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.506.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.507.1">
       app
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.508.1">
      folder:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.509.1">
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY . </span><span class="koboSpan" id="kobo.509.2">.
</span><span class="koboSpan" id="kobo.509.3">RUN dotnet restore
RUN dotnet publish -c Release -o /app</span></pre>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     At this point in the execution, the container will have been built.
    </span>
    <span class="koboSpan" id="kobo.510.2">
     Finally, we can add a section to the Docker file that runs the built container by copying the container assemblies and running from the DLL output by .NET
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.511.1">
      after compilation:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.512.1">
FROM base AS final
WORKDIR /app
COPY --from=build /app .
</span><span class="koboSpan" id="kobo.512.2">ENTRYPOINT ["dotnet", "MyminimalAPIProject.dll"]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.513.1">
     So far, we have specified how the image for the container should be built, but we haven’t yet triggered the build.
    </span>
    <span class="koboSpan" id="kobo.513.2">
     To do this, open a terminal or command prompt window running from your project directory
    </span>
    <a id="_idIndexMarker636">
    </a>
    <span class="koboSpan" id="kobo.514.1">
     and run the following command, replacing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.515.1">
      MYAPINAME
     </span>
    </strong>
    <span class="koboSpan" id="kobo.516.1">
     with a suitable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.517.1">
      image name:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.518.1">
docker build -t MYAPINAME .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.519.1">
     In this command, we are creating a tag for the image being built with the given name, and then we use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.520.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     to indicate that the build context for the image is the current directory where the Docker file
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.522.1">
      is located.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     Once built, you can run the container to start the app, which should be available to receive requests on a port of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      your choosing:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.525.1">
docker run -d -p 8080:80 --name MYCONTAINERNAME MYAPINAME</span></pre>
   <p>
    <span class="koboSpan" id="kobo.526.1">
     In this command, we have told Docker Engine to run the container with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.527.1">
      -d
     </span>
    </strong>
    <span class="koboSpan" id="kobo.528.1">
     (detached mode), which
    </span>
    <a id="_idIndexMarker637">
    </a>
    <span class="koboSpan" id="kobo.529.1">
     allows it to run in the background.
    </span>
    <span class="koboSpan" id="kobo.529.2">
     We then used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      -p
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     to specify that port
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      80
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     on the container should be mapped to port
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      8080
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     on the host machine.
    </span>
    <span class="koboSpan" id="kobo.535.2">
     This means your minimal API will be available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.536.1">
      at
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.537.1">
       http://localhost:8080
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.538.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.539.1">
     Finally, there is one other method you can use that is extremely simple: deploying to the built-in Kestrel
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.540.1">
      web server.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-178">
    <a id="_idTextAnchor208">
    </a>
    <span class="koboSpan" id="kobo.541.1">
     Deploying on-premises with Kestrel
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.542.1">
     If you simply want to host your minimal API as an ASP.NET Core application on a Windows machine, you can
    </span>
    <a id="_idIndexMarker638">
    </a>
    <span class="koboSpan" id="kobo.543.1">
     create a new publish profile and then follow the publish
    </span>
    <a id="_idIndexMarker639">
    </a>
    <span class="koboSpan" id="kobo.544.1">
     profile wizard in Visual Studio outlined earlier in this chapter.
    </span>
    <span class="koboSpan" id="kobo.544.2">
     However, instead of choosing Azure as the target,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.545.1">
      choose
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.546.1">
       Folder
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.547.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer097">
     <span class="koboSpan" id="kobo.548.1">
      <img alt="Figure 14.14: Choosing Folder as the publish target" src="image/B20968_14_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.549.1">
     Figure 14.14: Choosing Folder as the publish target
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.550.1">
     On selection, the wizard will ask you to specify a target folder to deploy to.
    </span>
    <span class="koboSpan" id="kobo.550.2">
     This folder can be local, or it can be a network path on a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      remote server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     Once published, the resulting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.553.1">
      .EXE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.554.1">
     file can be double-clicked and the application will run using the Kestrel web server, which listens on port
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.555.1">
      5000
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      by default.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     If you wish to change the port, you can do so via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      appsettings.json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     file in your project by adding the following (e.g., change to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.560.1">
      port
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.561.1">
       8080
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.562.1">
      ):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.563.1">
"Kestrel": {
    "Endpoints": {
        "Http": {
            "Url": "http://*:8080"
        }
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.564.1">
     We’ve explored a high-level overview of how we can prepare our minimal APIs
    </span>
    <a id="_idIndexMarker640">
    </a>
    <span class="koboSpan" id="kobo.565.1">
     for their inevitable deployment
    </span>
    <a id="_idIndexMarker641">
    </a>
    <span class="koboSpan" id="kobo.566.1">
     and consumption by end users.
    </span>
    <span class="koboSpan" id="kobo.566.2">
     Now, we’re nearing the end of our journey.
    </span>
    <span class="koboSpan" id="kobo.566.3">
     Let’s summarize what we’ve learned in this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.567.1">
      final chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-179">
    <a id="_idTextAnchor209">
    </a>
    <span class="koboSpan" id="kobo.568.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.569.1">
     In this chapter, we’ve navigated through the crucial steps required to prepare minimal APIs for production, focusing on testing, compatibility with .NET 9, and deployment strategies.
    </span>
    <span class="koboSpan" id="kobo.569.2">
     Each of these aspects plays a pivotal role in ensuring that your APIs are robust, compatible, and seamlessly delivered to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.570.1">
      end users.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.571.1">
     We explored unit testing, which isolates and validates individual components, and integration testing, which ensures that different parts of the system work together correctly.
    </span>
    <span class="koboSpan" id="kobo.571.2">
     Through practical examples with xUnit, we demonstrated how to set up and execute these tests to validate functionality and performance.
    </span>
    <span class="koboSpan" id="kobo.571.3">
     The key takeaway is that thorough testing—whether through unit tests or integration tests—helps catch potential issues early, reducing the likelihood of bugs slipping into production and ensuring that your API meets its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.572.1">
      acceptance criteria.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.573.1">
     Compatibility with .NET 9 is crucial for maintaining the longevity and efficiency of your minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.573.2">
     We discussed the importance of understanding breaking changes and adapting your code base accordingly.
    </span>
    <span class="koboSpan" id="kobo.573.3">
     By keeping abreast of Microsoft’s documentation on .NET 9 changes, and leveraging unit and integration tests, you can mitigate the impact of any breaking changes.
    </span>
    <span class="koboSpan" id="kobo.573.4">
     This proactive approach ensures that your APIs continue to function correctly with the latest .NET version and provides a smoother transition
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.574.1">
      during migrations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.575.1">
     Deployment encompasses several methods tailored to different environments and needs.
    </span>
    <span class="koboSpan" id="kobo.575.2">
     We covered deployment to Microsoft Azure App Service, which offers a straightforward, scalable solution for cloud environments.
    </span>
    <span class="koboSpan" id="kobo.575.3">
     We also explored containerization with Docker, providing a portable, cross-platform deployment option.
    </span>
    <span class="koboSpan" id="kobo.575.4">
     For on-premises deployments, running minimal APIs directly with Kestrel offers a simple and effective approach.
    </span>
    <span class="koboSpan" id="kobo.575.5">
     Each deployment method has its own set of configurations and considerations, such as choosing between framework-dependent and self-contained deployments or managing container ports and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.576.1">
      environment settings.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.577.1">
     Ensuring that your minimal APIs are well tested, compatible with the latest .NET versions, and deployed using the most suitable method empowers you to deliver high-quality, reliable software.
    </span>
    <span class="koboSpan" id="kobo.577.2">
     By applying the practices outlined in this chapter, you set a solid foundation for successful deployment and long-term maintenance of your APIs, contributing to both immediate operational success and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.578.1">
      future scalability.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.579.1">
     We’re now at the end of our minimal API journey, and as the book ends, I hope you’ve gained a solid understanding of how to create minimal APIs in various use cases and that you’ve found the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.580.1">
      experience enjoyable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.581.1">
     The book has been a joy for me to write as someone who is passionate about the use of minimal APIs in varying use cases and contexts.
    </span>
    <span class="koboSpan" id="kobo.581.2">
     APIs are critical to nearly all modern software systems, and I think a good knowledge of minimal APIs and their advantages will give any .NET developer an edge in their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.582.1">
      programming career.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.583.1">
     Thanks for reading.
    </span>
    <span class="koboSpan" id="kobo.583.2">
     Now go and build some more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.584.1">
      minimal APIs!
     </span>
    </span>
   </p>
  </div>
 </body></html>