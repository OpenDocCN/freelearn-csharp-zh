<html><head></head><body>
<div id="_idContainer118">
<h1 class="chapter-number" id="_idParaDest-190"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.2.1">Advanced Unit Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As we’ve seen, testing is incredible and can give you the freedom to effectively refactor your code in relative safety. </span><span class="koboSpan" id="kobo.3.2">Sometimes, code is written in a way that makes testing difficult and you need a few more tools. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we’ll explore a handful of popular .NET libraries that can improve the readability of your tests and give you more options for testing code – including those tricky classes with complex data </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">or dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We’ll cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Creating readable tests </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">with Shouldly</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Generating test data </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">with Bogus</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Mocking dependencies with Moq </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and NSubstitute</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Pinning tests </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">with Snapper</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Experimenting with </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Scientist .NET</span></span></li>
</ul>
<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">The code for this chapter is available from GitHub at https://github.com/PacktPublishing/Refactoring-with-CSharp in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">Chapter09</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.20.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Libraries change with new releases and some of these changes may cause issues with code in this chapter. </span><span class="koboSpan" id="kobo.21.2">Because of this, here are the exact names and versions of the libraries that are used in this chapter at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">of writing:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.23.1">Bogus 34.0.2</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.24.1">FluentAssertions 6.11.0</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.25.1">Moq 4.20.2</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.26.1">NSubstitute 5.0.0</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.27.1">Scientist 2.0.0</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.28.1">Shouldly 4.2.1</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.29.1">Snapper 2.4.0</span></strong></span></li>
</ul>
<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.30.1">Creating readable tests with Shouldly</span></h1>
<p><span class="koboSpan" id="kobo.31.1">In </span><a href="B21324_06.xhtml#_idTextAnchor133"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.32.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.33.1">, we saw how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">Assert</span></strong><span class="koboSpan" id="kobo.35.1"> class is used to verify the behavior of existing classes through code</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.36.1"> such as </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.38.1">
Assert.Equal(35, passengerCount);</span></pre>
<p><span class="koboSpan" id="kobo.39.1">This code </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.40.1">verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">passengerCount</span></strong><span class="koboSpan" id="kobo.42.1"> is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">35</span></strong><span class="koboSpan" id="kobo.44.1"> and fails the test if it is a </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">different number.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Unfortunately, this code has </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">two problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.48.1">Assert methods take in the expected value first and the actual value second. </span><span class="koboSpan" id="kobo.48.2">This is different than how most people think about things and can lead to confusing test failure messages, as we saw in </span><a href="B21324_06.xhtml#_idTextAnchor133"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.50.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.51.1">The code doesn’t read incredibly well in English, which can slow you down as you are </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">reading tests.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.53.1">Several open-source libraries address this issue by providing an alternative syntax for writing assertions in unit tests through sets of extension methods </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">they introduce.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The most popular of these libraries are FluentAssertions and Shouldly. </span><span class="koboSpan" id="kobo.55.2">While FluentAssertions is by far the more popular library, I find Shouldly to read more naturally, so we’ll start </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">with that.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Let’s look at installing Shouldly and getting started with its syntax before looking at a similar example </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">with FluentAssertions.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.59.1">Installing the Shouldly NuGet package</span></h2>
<p><span class="koboSpan" id="kobo.60.1">Shouldly is not</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.61.1"> a library that is included by default in any project template built into Visual Studio. </span><span class="koboSpan" id="kobo.61.2">Because of this, we need to add it to </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">our project.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">In Visual Studio, we use a </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">package manager</span></strong><span class="koboSpan" id="kobo.65.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">NuGet Package Manager</span></strong><span class="koboSpan" id="kobo.67.1"> to install external dependencies from</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.68.1"> package sources such as the one </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">at </span></span><a href="http://nuget.org"><span class="No-Break"><span class="koboSpan" id="kobo.70.1">nuget.org</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.71.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">If you’ve programmed in JavaScript, this concept is very similar to JavaScript package managers such as Yarn or NPM. </span><span class="koboSpan" id="kobo.72.2">While other package managers download the code and have you compile it, NuGet downloads </span><em class="italic"><span class="koboSpan" id="kobo.73.1">compiled</span></em><span class="koboSpan" id="kobo.74.1"> versions of external code and allows your code to reference things</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.75.1"> defined in those projects without slowing your </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">build process.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">To install a package, right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">Chapter9Tests</span></strong><span class="koboSpan" id="kobo.79.1"> project in </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.81.1"> and choose </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">Manage </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.83.1">NuGet Packages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Next, click on the </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">Browse</span></strong><span class="koboSpan" id="kobo.87.1"> navigation link in the top-left corner and type </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Shouldly</span></strong><span class="koboSpan" id="kobo.89.1"> in the search bar. </span><span class="koboSpan" id="kobo.89.2">Your search results should look something like those in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.91.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.93.1"><img alt="Figure 9.1 – NuGet Package Manager showing results for Shouldly" src="image/B21324_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.94.1">Figure 9.1 – NuGet Package Manager showing results for Shouldly</span></p>
<p><span class="koboSpan" id="kobo.95.1">You should see an entry named Shouldly by Jake Ginnivan et al. </span><span class="koboSpan" id="kobo.95.2">in the list on the left. </span><span class="koboSpan" id="kobo.95.3">Select it by clicking on it. </span><span class="koboSpan" id="kobo.95.4">The details on the right will then list information about this package, including its license terms </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">and dependencies.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.97.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.98.1">Always check the author and the exact name of the package you are looking for as many have </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">similar names.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Using the </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Version</span></strong><span class="koboSpan" id="kobo.102.1"> dropdown in the details area on the right, you can choose the specific version of the library </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.103.1">to install. </span><span class="koboSpan" id="kobo.103.2">Usually, it’s fine to leave this as the latest stable version, but occasionally, you may need to select a prior version for </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">compatibility purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">When you click </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">Install</span></strong><span class="koboSpan" id="kobo.107.1">, Shouldly and anything it depends on will automatically be downloaded and installed into your project. </span><span class="koboSpan" id="kobo.107.2">When installing packages, a window may open showing you various license terms or dependencies, such as those shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.108.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.109.1">.2</span></em><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">Read these carefully, especially if you are using a library in </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">your workplace:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.112.1"><img alt="Figure 9.2 – Dependencies needed to install Shouldly" src="image/B21324_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.113.1">Figure 9.2 – Dependencies needed to install Shouldly</span></p>
<p><span class="koboSpan" id="kobo.114.1">Now that we have Shouldly installed, let’s learn how to work </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">with it.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.116.1">Writing readable assertions with Shouldly</span></h2>
<p><span class="koboSpan" id="kobo.117.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">PassengerTests.cs</span></strong><span class="koboSpan" id="kobo.119.1">, there’s an existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">PassengerFullNameShouldBeAccurate</span></strong><span class="koboSpan" id="kobo.121.1"> test that instantiates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Passenger</span></strong><span class="koboSpan" id="kobo.123.1"> object, grabs the</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.124.1"> value out of the object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">FullName</span></strong><span class="koboSpan" id="kobo.126.1"> field, and </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.127.1">makes sure the resulting name matches the expected value, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
[Fact]
public void PassengerFullNameShouldBeAccurate() {
    // Arrange
    Passenger passenger = new() {
        FirstName = "Dot",
        LastName = "Nette",
    };
    // Act
    string name = passenger.FullName;
    // Assert
    </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Assert.Equal("Dot Nette", name);</span></strong><span class="koboSpan" id="kobo.131.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.132.1">Using Shouldly, we can</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.133.1"> make this assertion a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">more readable.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">First, let’s</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.136.1"> add a </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">global using</span></strong><span class="koboSpan" id="kobo.138.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">Usings.cs</span></strong><span class="koboSpan" id="kobo.140.1"> file by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">using</span></strong><span class="koboSpan" id="kobo.142.1"> for Shouldly at the end of</span><a id="_idIndexMarker529"/> <span class="No-Break"><span class="koboSpan" id="kobo.143.1">that file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
global using Xunit;
</span><strong class="bold"><span class="koboSpan" id="kobo.145.1">global using Shouldly;</span></strong></pre>
<p><span class="koboSpan" id="kobo.146.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">global using</span></strong><span class="koboSpan" id="kobo.148.1"> directive allows you to work with things in the Shouldly namespace anywhere in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Chapter9Tests</span></strong><span class="koboSpan" id="kobo.150.1"> project. </span><span class="koboSpan" id="kobo.150.2">Put another way, it is the equivalent of if every file in the project had a </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">using Shouldly;</span></strong><span class="koboSpan" id="kobo.152.1"> statement at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">Now that we have Shouldly installed and its namespace imported, we can rewrite the assertion from earlier by using one of the many extension methods provided by Shouldly, as </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
[Fact]
public void PassengerFullNameShouldBeAccurate() {
    // Arrange
    Passenger passenger = new() {
        FirstName = "Dot",
        LastName = "Nette",
    };
    // Act
    string name = passenger.FullName;
    // Assert
    </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">name.ShouldBe("Dot Nette");</span></strong><span class="koboSpan" id="kobo.158.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.159.1">Here, Shouldly adds a </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">ShouldBe</span></strong><span class="koboSpan" id="kobo.161.1"> extension method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">string</span></strong><span class="koboSpan" id="kobo.163.1">, allowing us to call this method in a very readable </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.164.1">way. </span><span class="koboSpan" id="kobo.164.2">This code is functionally equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Assert.Equal</span></strong><span class="koboSpan" id="kobo.166.1">, but it is </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.167.1">significantly more readable. </span><span class="koboSpan" id="kobo.167.2">Additionally, you are far less likely to confuse which parameter is the expected value versus the actual value under this way of working </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">with things.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Shouldly has a wide variety of extension methods, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">ShouldBe</span></strong><span class="koboSpan" id="kobo.171.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">ShouldNotBe</span></strong><span class="koboSpan" id="kobo.173.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">ShouldBeGreaterThan</span></strong><span class="koboSpan" id="kobo.175.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">ShouldBeLessThan</span></strong><span class="koboSpan" id="kobo.177.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">ShouldContain</span></strong><span class="koboSpan" id="kobo.179.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">ShouldNotBeNull</span></strong><span class="koboSpan" id="kobo.181.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">ShouldBeNull</span></strong><span class="koboSpan" id="kobo.183.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">ShouldStartWith</span></strong><span class="koboSpan" id="kobo.185.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">ShouldEndWith</span></strong><span class="koboSpan" id="kobo.187.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">To illustrate this, let’s look at a more complex test written </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">without Shouldly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
[Fact]
public void ScheduleFlightShouldAddFlight() {
    // Arrange
    FlightScheduler scheduler = new();
    PassengerFlightInfo flight = _flightFaker.Generate();
    // Act
    scheduler.ScheduleFlight(flight);
    // Assert
    var result = scheduler.GetAllFlights();
</span><strong class="bold"><span class="koboSpan" id="kobo.192.1">    Assert.NotNull(result);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.193.1">    Assert.Equal(1, result.Count());</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.194.1">    Assert.Contains(flight, result);</span></strong><span class="koboSpan" id="kobo.195.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.196.1">This code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.198.1"> to schedule a flight using the Bogus library, which we’ll discuss later in this chapter. </span><span class="koboSpan" id="kobo.198.2">Once a flight has been scheduled, the code gets all the flights and asserts that the </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.199.1">resulting collection is not null, has only one item, and the flight we scheduled</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.200.1"> is in </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">that collection.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">This code isn’t too bad, but I still prefer the </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">Shouldly version:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
[Fact]
public void ScheduleFlightShouldAddFlight() {
    // Arrange
    FlightScheduler scheduler = new();
    PassengerFlightInfo flight = _flightFaker.Generate();
    // Act
    scheduler.ScheduleFlight(flight);
    // Assert
    var result = scheduler.GetAllFlights();
</span><strong class="bold"><span class="koboSpan" id="kobo.205.1">    result.ShouldNotBeNull();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.206.1">    result.Count().ShouldBe(1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.207.1">    result.ShouldContain(flight);</span></strong><span class="koboSpan" id="kobo.208.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.209.1">In general, I find the Shouldly library to have more consistent parameter ordering and result in more readable tests. </span><span class="koboSpan" id="kobo.209.2">Because of this, I find myself more productive and use Shouldly wherever </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">I can.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.211.1">Practice exercise</span></p>
<p class="callout"><span class="koboSpan" id="kobo.212.1">As an exercise, I’d encourage you to take the starting code for this chapter and convert the various tests so that they use Shouldly instead of standard assertions. </span><span class="koboSpan" id="kobo.212.2">Feel free to experiment with other assertions as you go. </span><span class="koboSpan" id="kobo.212.3">This chapter’s final code uses Shouldly if you want to check </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">your answers.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">Before we see </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.215.1">what else</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.216.1"> Shouldly can do, let’s look at FluentAssertions, a popular library fulfilling a similar role </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">as Shouldly.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.218.1">Writing readable assertions with FluentAssertions</span></h2>
<p><span class="koboSpan" id="kobo.219.1">FluentAssertions does the</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.220.1"> same thing that Shouldly does, but</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.221.1"> the approach of its syntax is less oriented on calling single methods like Shouldly’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">ShouldContain</span></strong><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">Instead, FluentAssertions prefers chaining together several method calls to produce a </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">similar result.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Let’s look at a test of the baggage pricing system as </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">an illustration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
[Fact]
public void CarryOnBaggageIsPricedCorrectly() {
    // Arrange
    BaggageCalculator calculator = new();
    int carryOnBags = 2;
    int checkedBags = 0;
    int passengers = 1;
    bool isHoliday = false;
    // Act
    decimal result = calculator.CalculatePrice(checkedBags,
        carryOnBags, passengers, isHoliday);
    // Assert
    </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">result.Should().Be(60m);</span></strong><span class="koboSpan" id="kobo.229.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.230.1">This code creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">BaggageCalculator</span></strong><span class="koboSpan" id="kobo.232.1"> and then sends a series of factors to that calculator’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">CalculatePrice</span></strong><span class="koboSpan" id="kobo.234.1"> method before performing its assertions via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Should().Be(60m)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1"> syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Before we explore this in more depth, I should point out that, like Shouldly, FluentAssertions does not </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.238.1">come pre-installed. </span><span class="koboSpan" id="kobo.238.2">You’ll need to install FluentAssertions with NuGet Package</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.239.1"> Manager, the same way you did earlier for Shouldly. </span><span class="koboSpan" id="kobo.239.2">You’ll also need to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">using FluentAssertions;</span></strong><span class="koboSpan" id="kobo.241.1"> statement to your code file to see the FluentAssertions </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">extension methods.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Now that we’ve established how to get started with FluentAssertions, let’s take a closer look at that </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">result.Should().Be(60m)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1"> syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">Most actions in FluentAssertions flow out of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Should</span></strong><span class="koboSpan" id="kobo.248.1"> methods. </span><span class="koboSpan" id="kobo.248.2">Notice that there are multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Should</span></strong><span class="koboSpan" id="kobo.250.1"> methods in FluentAssertions, with each one related to a specific type of data you might </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">work with.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Should</span></strong><span class="koboSpan" id="kobo.254.1"> methods return a strongly-typed object such </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">NumericAssertions&lt;decimal&gt;</span></strong></span><span class="koboSpan" id="kobo.257.1">
in the case of the calculator assertions. </span><span class="koboSpan" id="kobo.257.2">These assertion objects contain various constraint methods, allowing you to do targeted assertions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Be</span></strong><span class="koboSpan" id="kobo.259.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">NotBe</span></strong><span class="koboSpan" id="kobo.261.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">BeLessThan</span></strong><span class="koboSpan" id="kobo.263.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">BePositive</span></strong><span class="koboSpan" id="kobo.265.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">BeOneOf</span></strong><span class="koboSpan" id="kobo.267.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">and others.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">There are a few advantages to the </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">FluentAssertions approach:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.271.1">It’s easier to find assertion methods since they all go </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">through </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Should()</span></strong></span></li>
<li><span class="koboSpan" id="kobo.274.1">The constraint methods allow you to combine assertions such as </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">result.Should().BePositive().And.BeInRange(50, 70)</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.276.1">Unfortunately, FluentAssertions has a slightly higher learning curve and is a little more verbose than Shouldly, which might result in slightly less </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">readable tests.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">Ultimately, it’s up to you and your team as to what style you prefer, but both Shouldly and FluentAssertions can significantly improve the readability of your tests and your enjoyment of the test </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">writing experience.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Before we introduce our next new library, let’s talk about one more thing Shouldly can do that might </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">be helpful.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.282.1">Testing performance with Shouldly</span></h2>
<p><span class="koboSpan" id="kobo.283.1">One of the reasons people find themselves refactoring code is to look for ways of improving the </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.284.1">performance of code that is known to </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">be slow.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Imagine you are following </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.288.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.289.1">TDD</span></strong><span class="koboSpan" id="kobo.290.1">) and are investigating code that takes an unacceptably long time to</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.291.1"> iterate through a list </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">of items.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">The first step in TDD is to write a failing test, so you now need to write a test that fails if the performance of a method is </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">too slow.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">We’ll talk about reasons why you might not want to write a test around performance in a bit, but let’s explore how you would go about testing </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">performance first.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">In order to fail tests involving code that performs too slowly, you’d need to be able to measure how long that code took to run. </span><span class="koboSpan" id="kobo.297.2">To do that, you could create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">Stopwatch</span></strong><span class="koboSpan" id="kobo.299.1"> object, start it, stop it, and then verify the duration of that watch, as </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
[Fact]
public void ScheduleFlightShouldNotBeSlow() {
    // Arrange
    FlightScheduler scheduler = new();
    PassengerFlightInfo flight = _flightFaker.Generate();
    int maxTime = 100;
</span><strong class="bold"><span class="koboSpan" id="kobo.302.1">    Stopwatch stopwatch = new();</span></strong><span class="koboSpan" id="kobo.303.1">
    // Act
</span><strong class="bold"><span class="koboSpan" id="kobo.304.1">    stopwatch.Start();</span></strong><span class="koboSpan" id="kobo.305.1">
    scheduler.ScheduleFlight(flight);
</span><strong class="bold"><span class="koboSpan" id="kobo.306.1">    stopwatch.Stop();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.307.1">    long milliSeconds = stopwatch.ElapsedMilliseconds;</span></strong><span class="koboSpan" id="kobo.308.1">
    // Assert
</span><strong class="bold"><span class="koboSpan" id="kobo.309.1">    milliSeconds.ShouldBeLessThanOrEqualTo(maxTime);</span></strong><span class="koboSpan" id="kobo.310.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.311.1">This code will fail if it takes more than 100 milliseconds (0.1 seconds) to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">ScheduleFlight</span></strong><span class="koboSpan" id="kobo.313.1">, but this approach has a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">of disadvantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.315.1">There’s a lot </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.316.1">of setup code required for this approach. </span><span class="koboSpan" id="kobo.316.2">In this case, over half of the test method is devoted </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Stopwatch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.320.1">The test waits for the method to complete before the test is failed. </span><span class="koboSpan" id="kobo.320.2">If it takes 10 seconds to complete the method, the test waits the full time. </span><span class="koboSpan" id="kobo.320.3">This is inefficient because once the 100-millisecond threshold is crossed, the test will </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">never pass.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.322.1">Shouldly gives us a more compact </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Should.CompleteIn</span></strong><span class="koboSpan" id="kobo.324.1"> method that solves </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">both problems:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
[Fact]
public void ScheduleFlightShouldNotBeSlow() {
  // Arrange
  FlightScheduler scheduler = new();
  PassengerFlightInfo flight = _flightFaker.Generate();
  TimeSpan maxTime = TimeSpan.FromMilliseconds(100);
  // Act
  </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">Action testAction = () =&gt; scheduler.ScheduleFlight(flight);</span></strong><span class="koboSpan" id="kobo.328.1">
  // Assert
  </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">Should.CompleteIn(testAction, maxTime);</span></strong><span class="koboSpan" id="kobo.330.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.331.1">This code creates an action to schedule the flight that Shouldly will invoke as part of the test. </span><span class="koboSpan" id="kobo.331.2">This action isn’t invoked until it is passed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Should.CompleteIn</span></strong><span class="koboSpan" id="kobo.333.1"> method, which also requires a maximum amount of time to allow the method </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">to run.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">When Shouldly runs your action, it tracks the elapsed time internally and will cancel your action and fail the test once that threshold is reached. </span><span class="koboSpan" id="kobo.335.2">This results in more compact test code that won’t take longer than the maximum allowable amount </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">So, now that we know how to write simple performance tests using Shouldly or plain old .NET with </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Stopwatch</span></strong><span class="koboSpan" id="kobo.339.1">, let’s talk about why you might not want to </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Good tests should be fast and result in a repeatable result. </span><span class="koboSpan" id="kobo.341.2">Tests will be run by a variety of machines in a variety</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.342.1"> of different circumstances, such as when the processor has relatively little work to do or when the processor is completely overloaded. </span><span class="koboSpan" id="kobo.342.2">Tests may also be run in isolation or parallel, alongside, other tests. </span><span class="koboSpan" id="kobo.342.3">Additionally, with .NET, it is normal to see variations in performance from run </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">to run.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">All these things mean that performance testing is going to be more chaotic than you like and the maximum allowable duration is something you should consider carefully. </span><span class="koboSpan" id="kobo.344.2">If your tests are run in a </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">continuous integration/continuous delivery</span></strong><span class="koboSpan" id="kobo.346.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.347.1">CI/CD</span></strong><span class="koboSpan" id="kobo.348.1">) pipeline (which they should be, as we’ll talk </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.349.1">about in </span><em class="italic"><span class="koboSpan" id="kobo.350.1">Part 4</span></em><span class="koboSpan" id="kobo.351.1"> of this book), it’s likely that the build machine’s CPU and memory characteristics look nothing like a developer workstation. </span><span class="koboSpan" id="kobo.351.2">To combat this, you may need to pick a significantly higher number than you normally would to avoid random failures due to a slow test environment. </span><span class="koboSpan" id="kobo.351.3">On the other hand, if you make your timeout too long, you won’t detect legitimate </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">performance issues.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">My general stance is that performance testing is something that should rarely ever be codified into unit tests due to the chaotic nature of performance metrics and the wide variety of machines that</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.354.1"> might run tests. </span><span class="koboSpan" id="kobo.354.2">Instead, I tend to prefer periodic profiling using a dedicated tool such as </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">Visual Studio Enterprise</span></strong><span class="koboSpan" id="kobo.356.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">JetBrains dotTrace</span></strong><span class="koboSpan" id="kobo.358.1"> for those </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.359.1">areas that are truly critical </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">to performance.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">That said, there is value in performance tests, but you may spend more time than you’d expect finding a good maximum test </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">duration number.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Let’s move on to another library that makes your life easier when </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">testing: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.365.1">Bogus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.367.1">Generating test data with Bogus</span></h1>
<p><span class="koboSpan" id="kobo.368.1">In </span><a href="B21324_06.xhtml#_idTextAnchor133"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.369.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.370.1">, I mentioned</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.371.1"> that tests are a form of documentation that </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.372.1">explains how your system </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">should work.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">Keeping that in mind, look at the following test, which</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.375.1"> tests the</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.376.1"> interaction of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Passenger</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">BoardingProcessor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1"> classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.381.1">
[Fact]
public void BoardingMessageShouldBeAccurate() {
  // Arrange
  Passenger passenger = new() {
    BoardingGroup = 7,
    FirstName = "Dot",
    LastName = "Nette",
    MailingCity = "Columbus",
    MailingStateOrProvince = "Ohio",
    MailingCountry = "United States",
    MailingPostalCode = "43081",
    Email = "noreply@packt.com",
    RewardsId = "CSA88121",
    RewardMiles = 360,
    IsMilitary = false,
    NeedsHelp = false,
  };
  BoardingProcessor boarding =
    new(BoardingStatus.Boarding, group:3);
  // Act
  string message = boarding.BuildMessage(passenger);
  // Assert
  message.ShouldBe("Please Wait");
}</span></pre>
<p><span class="koboSpan" id="kobo.382.1">A lot of setup is needed in the </span><em class="italic"><span class="koboSpan" id="kobo.383.1">Arrange</span></em><span class="koboSpan" id="kobo.384.1"> phase before </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">BuildMessage</span></strong><span class="koboSpan" id="kobo.386.1"> can be called. </span><span class="koboSpan" id="kobo.386.2">But what aspects of that setup are important? </span><span class="koboSpan" id="kobo.386.3">Which parts of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Passenger</span></strong><span class="koboSpan" id="kobo.388.1"> object contribute to that person being allowed to board versus being told </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">to wait?</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">While it’s important to create</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.391.1"> test objects that look accurate, mixing irrelevant properties with vital </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.392.1">properties can lead to difficulties interpreting what’s important about test data or why a test should pass instead </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">of fail.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Bogus is a library that generates realistic random data of different types. </span><span class="koboSpan" id="kobo.394.2">Bogus helps solve this problem by giving you a good way of generating random data for those less critical parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">your objects.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">This has the simultaneous benefit of focusing your attention on the more critical portions of your tests while also generating random data to test your assertion that the values in the other properties truly </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">don’t matter.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Like the other libraries in this chapter, Bogus must be installed via NuGet and then referenced in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">using </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">Bogus;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.401.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">Let’s look at the </span><em class="italic"><span class="koboSpan" id="kobo.403.1">Arrange</span></em><span class="koboSpan" id="kobo.404.1"> section of the earlier test </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">using Bogus:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
// Arrange
Faker&lt;Passenger&gt; faker = new();
faker.RuleFor(p =&gt; p.FirstName, f =&gt; f.Person.FirstName)
 .RuleFor(p =&gt; p.LastName, f =&gt; f.Person.LastName)
 .RuleFor(p =&gt; p.Email, f =&gt; f.Person.Email)
 .RuleFor(p =&gt; p.MailingCity, f =&gt; f.Address.City())
 .RuleFor(p =&gt; p.MailingCountry, f =&gt; f.Address.Country())
 .RuleFor(p =&gt; p.MailingState, f =&gt;f.Address.State())
 .RuleFor(p =&gt; p.MailingPostalCode, f=&gt;f.Address.ZipCode())
 .RuleFor(p =&gt; p.RewardsId, f =&gt; f.Random.String2(8))
 .RuleFor(p =&gt; p.RewardMiles,
          f =&gt; f.Random.Number(int.MaxValue));
Passenger passenger = faker.Generate();
passenger.BoardingGroup = 7;
passenger.NeedsHelp = false;
passenger.IsMilitary = false;</span></pre>
<p><span class="koboSpan" id="kobo.407.1">As you’ve likely noticed, this code is significantly different than the earlier code. </span><span class="koboSpan" id="kobo.407.2">It uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">Faker&lt;Passenger&gt;</span></strong><span class="koboSpan" id="kobo.409.1"> object from Bogus that will generate a different random </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Passenger</span></strong><span class="koboSpan" id="kobo.411.1"> object every time</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.412.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Generate()</span></strong><span class="koboSpan" id="kobo.414.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">Passenger</span></strong><span class="koboSpan" id="kobo.418.1"> objects </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.419.1">will use Bogus’ library of random data to generate reasonable test data, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.420.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.421.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.423.1"><img alt="Figure 9.3 – A randomized passenger with somewhat realistic values" src="image/B21324_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.424.1">Figure 9.3 – A randomized passenger with somewhat realistic values</span></p>
<p><span class="koboSpan" id="kobo.425.1">The way this works is that you can set rules that </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Faker</span></strong><span class="koboSpan" id="kobo.427.1"> will follow when it sees a given property using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">RuleFor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.429.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">RuleFor</span></strong><span class="koboSpan" id="kobo.432.1">, you can specify the property you want to program a response to in the first argument and then specify a function to get a value in the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">second parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">As an example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">RuleFor(p =&gt; p.Email, f =&gt; f.Person.Email)</span></strong><span class="koboSpan" id="kobo.436.1"> line has two function parameters. </span><span class="koboSpan" id="kobo.436.2">The first one uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">p</span></strong><span class="koboSpan" id="kobo.438.1"> to represent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Passenger</span></strong><span class="koboSpan" id="kobo.440.1"> object and focuses on that object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Email</span></strong><span class="koboSpan" id="kobo.442.1"> property. </span><span class="koboSpan" id="kobo.442.2">The second parameter takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">Faker</span></strong><span class="koboSpan" id="kobo.444.1"> instance as </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">f</span></strong><span class="koboSpan" id="kobo.446.1"> and the function may choose to use it to generate a value that </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Faker</span></strong><span class="koboSpan" id="kobo.448.1"> will use when generating </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">a person.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Faker</span></strong><span class="koboSpan" id="kobo.451.1"> contains many different types of data, from fake company names to ZIP codes to product names, IP addresses, and even absurd things such as hacker speak and “rants” such </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">as reviews.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Now, if you look closely at the data </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Faker</span></strong><span class="koboSpan" id="kobo.455.1"> generates, it doesn’t always make sense. </span><span class="koboSpan" id="kobo.455.2">For example, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.456.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.457.1">.3</span></em><span class="koboSpan" id="kobo.458.1"> listed the person as living in Larsonland, Minnesota with a postal code of 78950 and a country of “Cocos (Keeling) Islands.” </span><span class="koboSpan" id="kobo.458.2">Individually, these things are fine, but these different properties conflict wildly with </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">one another.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">If you need your data to make sense, you’ll need to write more nuanced rules for how these properties interact. </span><span class="koboSpan" id="kobo.460.2">Despite these limitations, Bogus gives you a great way of adding randomness to</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.461.1"> your code for the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">inconsequential data.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">Often, when using </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.464.1">Bogus, you’ll create your </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Faker</span></strong><span class="koboSpan" id="kobo.466.1"> instance in a separate method or the test constructor, which simplifies your </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">code significantly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
[Fact]
public void BoardingMessageShouldBeAccurate() {
</span><strong class="bold"><span class="koboSpan" id="kobo.469.1">  Faker&lt;Passenger&gt; faker = BuildPersonFaker();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.470.1">  Passenger passenger = faker.Generate();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.471.1">  passenger.BoardingGroup = 7;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.472.1">  passenger.NeedsHelp = false;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.473.1">  passenger.IsMilitary = false;</span></strong><span class="koboSpan" id="kobo.474.1">
  BoardingProcessor boarding =
    new(BoardingStatus.Boarding, group: 3);
  // Act
  string message = boarding.BuildMessage(passenger);
  // Assert
  message.ShouldBe("Please Wait");
}</span></pre>
<p><span class="koboSpan" id="kobo.475.1">Notice how this approach minimizes Bogus’ role in things and focuses your attention on how the randomly generated person is further configured. </span><span class="koboSpan" id="kobo.475.2">This helps you see that the important factors for someone not boarding the plane yet are </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.477.1">They are in a higher boarding group than the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">current group</span></span></li>
<li><span class="koboSpan" id="kobo.479.1">They are </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">not military</span></span></li>
<li><span class="koboSpan" id="kobo.481.1">They do not</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.482.1"> need help boarding </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the plane</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.484.1">Bogus isn’t just </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.485.1">for tests. </span><span class="koboSpan" id="kobo.485.2">For example, I’ve used Bogus successfully for prototyping user interfaces and generating data for small game projects. </span><span class="koboSpan" id="kobo.485.3">However, Bogus is a valuable addition to your </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">testing toolbox.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">Let’s move on to look at ways of isolating dependencies with a pair of </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">mocking libraries.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.489.1">Mocking dependencies with Moq and NSubstitute</span></h1>
<p><span class="koboSpan" id="kobo.490.1">So far, we’ve looked at a few libraries that improve the readability of your tests. </span><span class="koboSpan" id="kobo.490.2">In this section, we’ll look at </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">mocking frameworks</span></strong><span class="koboSpan" id="kobo.492.1"> and </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.493.1">see how libraries can help you more effectively test </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">your code.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.495.1">Understanding the need for mocking libraries</span></h2>
<p><span class="koboSpan" id="kobo.496.1">Let’s discuss why mocking frameworks are</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.497.1"> necessary by revisiting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.499.1"> example we introduced in the previous chapter while discussing </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">dependency injection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.501.1">
public class FlightBookingManager {
</span><strong class="bold"><span class="koboSpan" id="kobo.502.1">  private readonly IEmailClient _email;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.503.1">  public FlightBookingManager(IEmailClient email) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.504.1">    _email = email;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.505.1">  }</span></strong><span class="koboSpan" id="kobo.506.1">
  public bool BookFlight(Passenger passenger,
    FlightInfo flight, string seat) {
    if (!flight.IsSeatAvailable(seat)) {
      return false;
    }
    flight.AssignSeat(passenger, seat);
    string message = "Your seat is confirmed";
    return </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">_email.SendMessage(passenger.Email, message)</span></strong><span class="koboSpan" id="kobo.508.1">;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.509.1">Here, this class requires </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.511.1"> when </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.513.1"> is created. </span><span class="koboSpan" id="kobo.513.2">The client is then stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">_email</span></strong><span class="koboSpan" id="kobo.515.1"> field and this is later used to send a message when a flight is booked. </span><span class="koboSpan" id="kobo.515.2">Passing in </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.517.1"> as a parameter to the constructor is an example of dependency injection and allows our class to work with anything that implements</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.518.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">IEmailClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1"> interface.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">Unfortunately, it also means that to test the class, we must provide an implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.523.1">, even if we’re not explicitly testing </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">something email-related.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">Since we generally don’t want to send emails when unit testing our code, that means we’d need a separate implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.527.1">. </span><span class="koboSpan" id="kobo.527.2">We could make one by declaring a class and implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.529.1"> interface with a </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">minimal implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">Let’s say that </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.533.1"> was defined </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
public interface IEmailClient {
  bool SendMessage(string email, string message);
}</span></pre>
<p><span class="koboSpan" id="kobo.536.1">You could create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">TestEmailClient</span></strong><span class="koboSpan" id="kobo.538.1"> that meets </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">this requirement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
public class TestEmailClient </span><strong class="bold"><span class="koboSpan" id="kobo.541.1">: IEmailClient</span></strong><span class="koboSpan" id="kobo.542.1"> {
  public bool SendMessage(string email, string message)
    =&gt; true;
}</span></pre>
<p><span class="koboSpan" id="kobo.543.1">Here, the implementation of the test client is very simple and does the minimum possible needed to compile the code, which in this case is returning true, indicating a message was successfully sent. </span><span class="koboSpan" id="kobo.543.2">This type of class is </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.544.1">sometimes called a </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">test double</span></strong><span class="koboSpan" id="kobo.546.1">, a </span><strong class="bold"><span class="koboSpan" id="kobo.547.1">test stub</span></strong><span class="koboSpan" id="kobo.548.1">, or simply a </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">mock object</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">These </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.551.1">names are due to these classes looking</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.552.1"> like real implementations for testing </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.553.1">purposes without having all their functionality. </span><span class="koboSpan" id="kobo.553.2">In this chapter, I will refer to these as mock objects since that will help mocking frameworks make more </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">sense later.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">This lets us write a test using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">TestEmailClient</span></strong><span class="koboSpan" id="kobo.557.1"> mock object </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">we created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
[Fact]
public void BookingFlightShouldSucceedForEmptyFlight() {
  // Arrange
</span><strong class="bold"><span class="koboSpan" id="kobo.560.1">  TestEmailClient emailClient = new();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.561.1">  FlightBookingManager manager = new(emailClient);</span></strong><span class="koboSpan" id="kobo.562.1">
  Passenger passenger = GenerateTestPassenger();
  FlightInfo flight = GenerateEmptyFlight("Paris",
    "Toronto");
  // Act
  bool booked = manager.BookFlight(passenger, flight,"2B");
  // Assert
  booked.ShouldBeTrue();
}</span></pre>
<p><span class="koboSpan" id="kobo.563.1">Here, we can safely test a flight without sending an email by providing </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">TestEmailClient</span></strong><span class="koboSpan" id="kobo.565.1"> instead of a real </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">email client.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">Unfortunately, mock objects have their drawbacks. </span><span class="koboSpan" id="kobo.567.2">Let’s say we wanted to write another test that verifies that trying to book a seat that’s already occupied doesn’t send an email. </span><span class="koboSpan" id="kobo.567.3">In that case, we’d need to create another mock object with a </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">different implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">In this case, we’d want to fail the test if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">SendMessage</span></strong><span class="koboSpan" id="kobo.571.1"> method was called, so that method should throw</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.572.1"> an exception or use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">Assert.Fail</span></strong><span class="koboSpan" id="kobo.574.1"> method to cause the test to fail, as </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
public class SendingNotAllowedEmailClient : IEmailClient {
  public bool SendMessage(string email, string message) {
    Assert.Fail("You should not have sent an email");
    return false;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.577.1">Let’s consider a more nuanced example. </span><span class="koboSpan" id="kobo.577.2">Let’s say you want to verify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">BookFlight</span></strong><span class="koboSpan" id="kobo.579.1"> method calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">SendMessage</span></strong><span class="koboSpan" id="kobo.581.1"> method on its </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.583.1"> one time and one </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">time only.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">We could test this by building a specialized mock object that had a counter of all the times it was called, but that’s yet more complexity in our test code that we don’t necessarily need. </span><span class="koboSpan" id="kobo.585.2">If the definition of what’s in </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.587.1"> ever changes, all our mock objects that implement that interface will also need to </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">be updated.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">Because so many tests need mock objects and each test tests something slightly different, writing and maintaining mock objects manually can be a lot of work. </span><span class="koboSpan" id="kobo.589.2">This is the core problem that mocking libraries exist </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">to solve.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">While there are several popular mocking libraries in .NET, the most popular for many years has been Moq. </span><span class="koboSpan" id="kobo.591.2">We’ll explore Moq next before looking at </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">an alternative.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.593.1">Creating mock objects with Moq</span></h2>
<p><span class="koboSpan" id="kobo.594.1">Moq, pronounced </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.595.1">either “Mock” or “Mock-you” in the words of its creator, </span><em class="italic"><span class="koboSpan" id="kobo.596.1">is a mocking library built around using LINQ to create, configure, and verify the behavior of </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.597.1">mock objects</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">Just like the other libraries in this chapter, you’ll need to install Moq from NuGet Package Manager and import it into your file via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">using </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">Moq;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">With Moq, you don’t create mock objects on your own; instead, you tell Moq the interface you want to implement or the class you want to inherit and Moq automatically creates an object that meets </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">these requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">Let’s revisit our flight </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.606.1">booking test from earlier in this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">using Moq:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.608.1">
[Fact]
public void BookingFlightShouldSucceedForEmptyFlight() {
  // Arrange
</span><strong class="bold"><span class="koboSpan" id="kobo.609.1">  Mock&lt;IEmailClient&gt; clientMock = new();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.610.1">  IEmailClient emailClient = clientMock.Object;</span></strong><span class="koboSpan" id="kobo.611.1">
  FlightBookingManager manager = new(emailClient);
  Passenger passenger = GenerateTestPassenger();
  FlightInfo flight = GenerateEmptyFlight("Hamburg",
    "Cairo");
  // Act
  bool booked = manager.BookFlight(passenger, flight,"2B");
  // Assert
  booked.ShouldBeTrue();
}</span></pre>
<p><span class="koboSpan" id="kobo.612.1">Here, we instantiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">Mock</span></strong><span class="koboSpan" id="kobo.614.1"> instance named </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">clientMock</span></strong><span class="koboSpan" id="kobo.616.1"> that will create a new mock object in the form of </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.618.1">. </span><span class="koboSpan" id="kobo.618.2">We then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Object</span></strong><span class="koboSpan" id="kobo.620.1"> property on </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">clientMock</span></strong><span class="koboSpan" id="kobo.622.1"> and the Moq library automatically generates an object that implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.624.1"> in the simplest </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">way possible.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">Since we don’t care how the email client works in this example, this is all we need to do to generate a simple mock object that we can pass to </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.628.1">. </span><span class="koboSpan" id="kobo.628.2">Not only is this less code, but we can stay in the test method while defining our mock object, and if the definition for </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.630.1"> ever changes, we don’t need to update the mock object since Moq takes care of that </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">Of course, there’s a lot more that Moq can do, so let’s see how you can use it to configure how your mock</span><a id="_idIndexMarker569"/> <span class="No-Break"><span class="koboSpan" id="kobo.633.1">objects behave.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.634.1">Programming Moq return values</span></h2>
<p><span class="koboSpan" id="kobo.635.1">By default, methods on </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.636.1">Moq’s mock objects will return the default value for that type. </span><span class="koboSpan" id="kobo.636.2">For example, a method returning a </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">bool</span></strong><span class="koboSpan" id="kobo.638.1"> object would return </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">false</span></strong><span class="koboSpan" id="kobo.640.1">, and a method returning an </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">int</span></strong><span class="koboSpan" id="kobo.642.1"> object would </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">Sometimes, you need Moq to return something different. </span><span class="koboSpan" id="kobo.646.2">In these cases, you can set up your mock object by calling Moq’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">Setup</span></strong><span class="koboSpan" id="kobo.648.1"> method. </span><span class="koboSpan" id="kobo.648.2">For example, if you needed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">SendMessage</span></strong><span class="koboSpan" id="kobo.650.1"> method to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">true</span></strong><span class="koboSpan" id="kobo.652.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">false</span></strong><span class="koboSpan" id="kobo.654.1"> for any value that was passed in, you could write the </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.656.1">
Mock&lt;IEmailClient&gt; mockClient = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.657.1">mockClient.Setup(c =&gt; c.SendMessage(It.IsAny&lt;string&gt;(),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.658.1">                                    It.IsAny&lt;string&gt;())</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.659.1">                 ).Returns(true);</span></strong><span class="koboSpan" id="kobo.660.1">
IEmailClient emailClient = mockClient.Object;</span></pre>
<p><span class="koboSpan" id="kobo.661.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Setup</span></strong><span class="koboSpan" id="kobo.663.1"> method requires you to tell it what method or property you are configuring. </span><span class="koboSpan" id="kobo.663.2">Since we’re configuring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">SendMessage</span></strong><span class="koboSpan" id="kobo.665.1"> method, we specify it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">arrow function.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">Next, Moq needs to know when it should apply this rule. </span><span class="koboSpan" id="kobo.667.2">You can program your mock objects to reply differently based on different parameters, so you could have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">Setup</span></strong><span class="koboSpan" id="kobo.669.1"> call for different parameter values to the </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">same method.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">In our case, we want the method to always return </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">true</span></strong><span class="koboSpan" id="kobo.673.1">, regardless of what is passed in, so we specify that with Moq’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">It.IsAny</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.675.1"> syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Before we finish our discussion of Moq, we’ll look at a final example and teach you how to verify how many times a given method was called on your </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">mock objects.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.678.1">Verifying Moq calls</span></h2>
<p><span class="koboSpan" id="kobo.679.1">Sometimes, you </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.680.1">want to test the behavior of a method and verify that calling one method causes it to call something on another object. </span><span class="koboSpan" id="kobo.680.2">Moq lets you do this by verifying that a method has been called a specific number </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">of times.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">This can include verifying that a method wasn’t called, which can be helpful for cases like the example we discussed earlier involving making sure emails aren’t sent out in cases where a seat couldn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">be reserved.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">To accomplish this, we can call Moq’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">Verify</span></strong><span class="koboSpan" id="kobo.686.1"> methods, as shown in the following case, which verifies that an</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.687.1"> email was sent once and only once when booking </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">a flight:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.689.1">
[Fact]
public void BookingFlightShouldSendEmails() {
    // Arrange
</span><strong class="bold"><span class="koboSpan" id="kobo.690.1">    Mock&lt;IEmailClient&gt; mockClient = new();</span></strong><span class="koboSpan" id="kobo.691.1">
    mockClient.Setup(c =&gt; c.SendMessage(It.IsAny&lt;string&gt;(),
        It.IsAny&lt;string&gt;())).Returns(true);
    IEmailClient emailClient = mockClient.Object;
    FlightBookingManager manager = new(emailClient);
    Passenger passenger = GenerateTestPassenger();
    FlightInfo flight = GenerateEmptyFlight("Sydney","LA");
    // Act
    bool result= manager.BookFlight(passenger,flight,"2C");
    // Assert
    result.ShouldBeTrue();
</span><strong class="bold"><span class="koboSpan" id="kobo.692.1">    mockClient.Verify(c =&gt; c.SendMessage(passenger.Email,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.693.1">        It.IsAny&lt;string&gt;()), Times.Once);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.694.1">    mockClient.VerifyNoOtherCalls();</span></strong><span class="koboSpan" id="kobo.695.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.696.1">Here, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Verify</span></strong><span class="koboSpan" id="kobo.698.1"> on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">Mock</span></strong><span class="koboSpan" id="kobo.700.1"> instance to verify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">SendMessage</span></strong><span class="koboSpan" id="kobo.702.1"> method was called exactly one time with the passenger’s email address and any email body. </span><span class="koboSpan" id="kobo.702.2">If the method wasn’t called or was called multiple times, this will fail </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">our test.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">In other words, this one </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">Verify</span></strong><span class="koboSpan" id="kobo.706.1"> line protects us from cases where the system didn’t email the user when it should have, as well as cases where it might have sent too </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">many emails.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Next, the code calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">VerifyNoOtherCalls</span></strong><span class="koboSpan" id="kobo.710.1">. </span><span class="koboSpan" id="kobo.710.2">This method will cause the test to fail if some other method on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.712.1"> was called that was not verified by a previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Verify</span></strong><span class="koboSpan" id="kobo.714.1"> statement. </span><span class="koboSpan" id="kobo.714.2">This can be handy for ensuring that the code is not doing unexpected things </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.715.1">with the objects you </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">provide it.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.717.1">A note on verifying behavior</span></p>
<p class="callout"><span class="koboSpan" id="kobo.718.1">The developer community has historically been divided on whether it is good practice to verify that calling code calls some other piece of code in your unit tests. </span><span class="koboSpan" id="kobo.718.2">The argument against verifying the behavior of your tests is that it shouldn’t matter how a method implements something if it produces the right results. </span><span class="koboSpan" id="kobo.718.3">The counter-argument is that sometimes, the desired result of your method is the callout to the external code, such as our code here, which calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">SendMessage</span></strong><span class="koboSpan" id="kobo.720.1"> call. </span><span class="koboSpan" id="kobo.720.2">You and your team will need to decide when it is appropriate to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">Verify</span></strong><span class="koboSpan" id="kobo.722.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">your tests.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">Moq can seem complex to work with initially, but you don’t need to use all its features to benefit from it. </span><span class="koboSpan" id="kobo.724.2">As we saw earlier, just using Moq to generate simple mock objects can save you significant work in maintaining a growing number of manually created mock objects </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">You won’t always need to use Moq’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">Setup</span></strong><span class="koboSpan" id="kobo.728.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">Verify</span></strong><span class="koboSpan" id="kobo.730.1"> methods, but they’re very helpful when you </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">want them.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">For years, Moq has been the dominant mocking library in .NET, but recently, NSubstitute has been gaining popularity. </span><span class="koboSpan" id="kobo.732.2">This results in a higher likelihood that you may encounter it in the workplace as a substitute for Moq. </span><span class="koboSpan" id="kobo.732.3">Let’s explore NSubstitute briefly and see how it accomplishes similar things to Moq using a </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">different syntax.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.734.1">Mocking with NSubstitute</span></h2>
<p><span class="koboSpan" id="kobo.735.1">NSubstitute is a similar </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.736.1">mocking library to Moq, but its approach is to avoid arrow functions where possible and prefer code that looks more like standard </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">method calls.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">Like other libraries in this chapter, you’ll need to install NSubstitute via NuGet Package Manager and then import it via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">using </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">NSubstitute;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.741.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.742.1">Once you have NSubstitute installed and imported, you can use it in code, </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.744.1">
[Fact]
public void BookingFlightShouldSendEmailsNSubstitute() {
  // Arrange
</span><strong class="bold"><span class="koboSpan" id="kobo.745.1">  IEmailClient emailClient= Substitute.For&lt;IEmailClient&gt;();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.746.1">  emailClient.SendMessage(Arg.Any&lt;string&gt;(),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.747.1">                          Arg.Any&lt;string&gt;()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.748.1">                         ).Returns(true);</span></strong><span class="koboSpan" id="kobo.749.1">
  FlightBookingManager manager = new(emailClient);
  Passenger passenger = GenerateTestPassenger();
  FlightInfo flight = GenerateEmptyFlight("Sydney","LA");
  // Act
  bool result = manager.BookFlight(passenger, flight,"2C");
  // Assert
  result.ShouldBeTrue();
</span><strong class="bold"><span class="koboSpan" id="kobo.750.1">  emailClient.Received()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.751.1">             .SendMessage(passenger.Email,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.752.1">                          Arg.Any&lt;string&gt;());</span></strong><span class="koboSpan" id="kobo.753.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.754.1">Note how NSubstitute’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">Substitute.For</span></strong><span class="koboSpan" id="kobo.756.1"> returns the object you’re creating instead of creating an object like </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">Mock&lt;IEmailClient&gt;</span></strong><span class="koboSpan" id="kobo.758.1"> did with Moq. </span><span class="koboSpan" id="kobo.758.2">This change makes your code a little simpler </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.759.1">to work with but also means you now need to call methods like </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">Received()</span></strong><span class="koboSpan" id="kobo.761.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">DidNotReceive()</span></strong><span class="koboSpan" id="kobo.763.1"> to get access to the method </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">to verify.</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">In general, NSubsitute is very similar to Moq but with a simpler syntax. </span><span class="koboSpan" id="kobo.765.2">This simplicity has its advantages, particularly in code readability and a lowered learning curve for new developers. </span><span class="koboSpan" id="kobo.765.3">Unfortunately, this sometimes comes at the price of NSubstitute not having the full range of</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.766.1"> features you’re used to </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">with Moq.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">Now that we’ve explored mocking libraries, let’s move on to completely different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">unit tests.</span></span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.770.1">Pinning tests with Snapper</span></h1>
<p><span class="koboSpan" id="kobo.771.1">Let’s say you’ve inherited some complex legacy code that returns an object with a lot of properties. </span><span class="koboSpan" id="kobo.771.2">Some</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.772.1"> of these properties may, in turn, contain other complex objects with their own nest of properties. </span><span class="koboSpan" id="kobo.772.2">You’re just starting to work with this code and need to make a change, but there aren’t any tests in place and you’re not even sure what properties are important </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">to verify.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">I’ve seen this scenario a few times now and can attest that a special testing library called Snapper is a fantastic solution to </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">this problem.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">What Snapper does is it creates a snapshot of an object and stores it to disk in a JSON file. </span><span class="koboSpan" id="kobo.776.2">When Snapper next runs, it generates another snapshot and then compares it to the snapshot it stored previously. </span><span class="koboSpan" id="kobo.776.3">If the snapshots differ at all, Snapper will fail the test and alert you to </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">that problem.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.778.1">Snapper and Jest</span></p>
<p class="callout"><span class="koboSpan" id="kobo.779.1">For those of you with a JavaScript background, Snapper</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.780.1"> was inspired by the snapshot testing capabilities found in JavaScript’s Jest </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">testing library.</span></span></p>
<p><span class="koboSpan" id="kobo.782.1">Let’s see what a sample test looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">with Snapper.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">As usual, first, we install Snapper via NuGet and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">using </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">Snapper;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.787.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">After that, we’ll write a test against a complex </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">object, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">FlightManifest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.792.1">
[Fact]
public void FlightManifestShouldMatchExpectations() {
  // Arrange
  FlightInfo flight = GenerateEmptyFlight("Alta", "Laos");
  Passenger p1 = new("Dot", "Netta");
  Passenger p2 = new("See", "Sharp");
  flight.AssignSeat(p1, "1A");
  flight.AssignSeat(p2, "1B");
  LegacyManifestGenerator generator = new();
  // Act
  FlightManifest manifest = generator.Build(flight);
  // Assert
</span><strong class="bold"><span class="koboSpan" id="kobo.793.1">  manifest.ShouldMatchSnapshot();</span></strong><span class="koboSpan" id="kobo.794.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.795.1">Here, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">ShouldMatchSnapshot</span></strong><span class="koboSpan" id="kobo.797.1"> to verify that the</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.798.1"> object matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">current snapshot.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">This will generate the snapshot the first time, but subsequent runs will compare the object’s snapshot to the stored snapshot. </span><span class="koboSpan" id="kobo.800.2">If the resulting snapshot is different, you’ll see a test failure with details about the difference, such as the one that occurs when a passenger’s name is changed, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.801.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.802.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<span class="koboSpan" id="kobo.804.1"><img alt="Figure 9.4 – A failing snapshot test showing the difference between two properties" src="image/B21324_09_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.805.1">Figure 9.4 – A failing snapshot test showing the difference between two properties</span></p>
<p><span class="koboSpan" id="kobo.806.1">Sometimes, you’ll add new properties or realize that the stored snapshot was based on buggy data and you’ll want to update</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.807.1"> your snapshots. </span><span class="koboSpan" id="kobo.807.2">You can do this by temporarily adding an </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">UpdateSnapshots</span></strong><span class="koboSpan" id="kobo.809.1"> attribute to your test method, as </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.811.1">
[Fact]
</span><strong class="bold"><span class="koboSpan" id="kobo.812.1">[UpdateSnapshots]</span></strong><span class="koboSpan" id="kobo.813.1">
public void FlightManifestShouldMatchExpectations() {</span></pre>
<p><span class="koboSpan" id="kobo.814.1">After this, re-run your test to update the stored snapshot, then remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">UpdateSnapshots</span></strong><span class="koboSpan" id="kobo.816.1"> attribute. </span><span class="koboSpan" id="kobo.816.2">This final step is important because the test with </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">UpdateSnapshots</span></strong><span class="koboSpan" id="kobo.818.1"> included will never fail a snapshot test but rather replace the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">every time.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">Snapshot testing is not for every project and not for every team. </span><span class="koboSpan" id="kobo.820.2">It is a very useful broad safety net that you can include as the first test for complex return values, but it is far less useful as a test that documents the behavior of a system. </span><span class="koboSpan" id="kobo.820.3">Additionally, snapshot tests can be very brittle and cause tests to fail for trivial things such as modified dates being different between two otherwise identical sets </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">of data.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">Still, I find that Snapper and snapshot testing can be an appropriate opening move while trying to bring tests to particularly complex areas of </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">legacy systems.</span></span></p>
<p><span class="koboSpan" id="kobo.824.1">Now, let’s close this chapter out with a similar library that helps you compare several different implementations with </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">each other.</span></span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.826.1">Experimenting with Scientist .NET</span></h1>
<p><span class="koboSpan" id="kobo.827.1">Scientist .NET is</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.828.1"> a library built by GitHub for scientifically refactoring the critical parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">Let’s say you have a portion of your application that is vital to what the business does but has a significant amount of technical debt. </span><span class="koboSpan" id="kobo.830.2">You want to refactor it, but you’re afraid of breaking anything and your existing tests are not sufficient to address those fears, but you’re not sure what tests you need to add. </span><span class="koboSpan" id="kobo.830.3">In your estimation, the only thing that will let you feel good about your new code is to see how it does </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.832.1">This is what Scientist .NET helps with. </span><span class="koboSpan" id="kobo.832.2">Scientist .NET lets you deploy your new code alongside the legacy code it hopes to replace and compares the results of the two pieces of code. </span><span class="koboSpan" id="kobo.832.3">Alternatively, Scientist .NET can be used in unit tests to verify that the old version of a component</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.833.1"> and the new version of the component achieves the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">same results.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">This concept will hopefully be a bit clearer in a moment. </span><span class="koboSpan" id="kobo.835.2">Let’s jump into a specific example that looks at replacing </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">LegacyManifestGenerator</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.837.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">RewrittenManifestGenerator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.840.1">Like before, we’ll need to install the Scientist package from NuGet and then add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">using GitHub;</span></strong><span class="koboSpan" id="kobo.842.1"> statement to the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">our file.</span></span></p>
<p><span class="koboSpan" id="kobo.844.1">Next, let’s look at the science experiment comparing the two </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">manifest generators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.846.1">
[Fact]
public void FlightManifestExperimentWithScientist() {
  FlightInfo flight = GenerateEmptyFlight("Alta", "Laos");
  Passenger p1 = new("Dot", "Netta");
  Passenger p2 = new("See", "Sharp");
</span><strong class="bold"><span class="koboSpan" id="kobo.847.1">  Scientist.Science&lt;FlightManifest&gt;("Manifest", exp =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.848.1">    exp.Use(() =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.849.1">      LegacyManifestGenerator generator = new();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.850.1">      return generator.Build(flight);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.851.1">    });</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.852.1">    exp.Try(() =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.853.1">      RewrittenManifestGenerator generator = new();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.854.1">      return generator.Build(flight);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.855.1">    });</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.856.1">    exp.Compare((a, b)=&gt; a.Arrival == b.Arrival &amp;&amp;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.857.1">                         a.Departure == b.Departure &amp;&amp;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.858.1">                         a.PassengerCount==b.PassengerCount</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.859.1">               );</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.860.1">    exp.ThrowOnMismatches = true;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.861.1">  });</span></strong><span class="koboSpan" id="kobo.862.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.863.1">That’s a lot of code, so let’s unpack everything here bit </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">by bit.</span></span></p>
<p><span class="koboSpan" id="kobo.865.1">First, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">Scientist.Science&lt;FlightManifest&gt;</span></strong><span class="koboSpan" id="kobo.867.1"> line tells Scientist you’re starting a new experiment that will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">FlightManifest</span></strong><span class="koboSpan" id="kobo.869.1">. </span><span class="koboSpan" id="kobo.869.2">In this example, we’re ignoring this result value, but in </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.870.1">a production scenario, you might assign the result to a variable and work with it after the call to </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">the Scientist.</span></span></p>
<p><span class="koboSpan" id="kobo.872.1">Scientist requires you to name every experiment in the first parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">Science</span></strong><span class="koboSpan" id="kobo.874.1"> call because you may be performing multiple experiments. </span><span class="koboSpan" id="kobo.874.2">This experiment is simply </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">named “Manifest.”</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">Next, the Scientist requires an action to configure the experiment you’re about to perform. </span><span class="koboSpan" id="kobo.876.2">You might configure a few things, but here, we’re specifying four different things that we’ll talk about </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">in sequence.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">First, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">Use</span></strong><span class="koboSpan" id="kobo.880.1"> method to tell the experiment what to use as the result of the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">Scientist.Science</span></strong><span class="koboSpan" id="kobo.882.1">. </span><span class="koboSpan" id="kobo.882.2">This should be the legacy implementation of the system you’re looking </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">at replacing.</span></span></p>
<p><span class="koboSpan" id="kobo.884.1">Next, we need to give Scientist one or more alternative implementations to consider and compare against the “control” version in the legacy system. </span><span class="koboSpan" id="kobo.884.2">We do this via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">Try</span></strong><span class="koboSpan" id="kobo.886.1"> method that looks very similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Use</span></strong><span class="koboSpan" id="kobo.888.1"> method, but it represents the </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">experimental version.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">What Scientist does with these two versions is it makes the call to both implementations, compares</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.891.1"> the two results, and sends metrics on to something called a result publisher. </span><span class="koboSpan" id="kobo.891.2">This process is illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.892.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.893.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<span class="koboSpan" id="kobo.895.1"><img alt="Figure 9.5 – Scientist .NET performing an experiment" src="image/B21324_09_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.896.1">Figure 9.5 – Scientist .NET performing an experiment</span></p>
<p><span class="koboSpan" id="kobo.897.1">Scientist always returns the result of the legacy version defined during </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">Use</span></strong><span class="koboSpan" id="kobo.899.1">, so your new implementation will not impact the existing logic and you’ll be able to identify cases where the new and old implementations do not match. </span><span class="koboSpan" id="kobo.899.2">This allows you to verify your new logic’s behavior without risking</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.900.1"> any logic bugs impacting </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">end users.</span></span></p>
<p><span class="koboSpan" id="kobo.902.1">Once you are satisfied that your new implementation is without issues, you can remove Scientist and the legacy implementation from your code and use the new implementation in </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">their place.</span></span></p>
<p><span class="koboSpan" id="kobo.904.1">For Scientist to tell if two results are equivalent, it needs to know how to compare them. </span><span class="koboSpan" id="kobo.904.2">You can configure this with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">Compare</span></strong><span class="koboSpan" id="kobo.906.1"> method, which takes in a function that will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">bool</span></strong><span class="koboSpan" id="kobo.908.1"> object indicating if the two objects should be </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">considered equivalent.</span></span></p>
<p><span class="koboSpan" id="kobo.910.1">Finally, our code sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">ThrowOnMismatches</span></strong><span class="koboSpan" id="kobo.912.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">true</span></strong><span class="koboSpan" id="kobo.914.1">. </span><span class="koboSpan" id="kobo.914.2">You can set this property in Scientist to have it throw an exception when the experiment and the control do not match for a given input. </span><span class="koboSpan" id="kobo.914.3">This is only intended for use in unit tests like our code here and is not intended for use if you’re using Scientist in a </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">production application.</span></span></p>
<p><span class="koboSpan" id="kobo.916.1">Instead, you would implement Scientist’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">IResultPublisher</span></strong><span class="koboSpan" id="kobo.918.1"> interface and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">Scientist.ResultPublisher</span></strong><span class="koboSpan" id="kobo.920.1"> equal to your custom result publisher. </span><span class="koboSpan" id="kobo.920.2">This would allow you to report mismatches to a database, App Insights on Azure, or some other mechanism you might consider using to capture these mismatches. </span><span class="koboSpan" id="kobo.920.3">Getting into result publishers is outside the scope of this book, but see the </span><em class="italic"><span class="koboSpan" id="kobo.921.1">Further reading</span></em><span class="koboSpan" id="kobo.922.1"> section in this chapter for </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">more resources.</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">Scientist .NET is a complex solution you won’t use frequently, but it allows you to compare how two different implementations of an algorithm perform against a variety of inputs, either in a unit testing scenario or in a production application. </span><span class="koboSpan" id="kobo.924.2">I’ve personally seen Scientist .NET enable teams to collect the data they needed to successfully refactor highly complex code without impacting </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">end users.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.926.1">Warning</span></p>
<p class="callout"><span class="koboSpan" id="kobo.927.1">It’s important to note that when you run an experiment in Scientist, both the original version in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">Use</span></strong><span class="koboSpan" id="kobo.929.1"> statement and any experiments you defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">Try</span></strong><span class="koboSpan" id="kobo.931.1"> calls will be called. </span><span class="koboSpan" id="kobo.931.2">This means that if your code has any side effects such as inserting into a database or sending an email, these things will occur twice. </span><span class="koboSpan" id="kobo.931.3">This might result in duplicate rows being inserted into a database or duplicate emails </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">being sent.</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">You can potentially </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.934.1">avoid this downside by providing the experimental versions of mock objects as their dependencies instead of real versions of a database client or an </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">email provider.</span></span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.936.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.937.1">In this chapter, we saw several different open-source libraries that can improve the readability and capabilities of </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">your tests.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.939.1">Shouldly and FluentAssertions give you the readable syntax for </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">writing assertions.</span></span></li>
<li><span class="koboSpan" id="kobo.941.1">Bogus allows you to generate randomized test data for values that </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">don’t matter.</span></span></li>
<li><span class="koboSpan" id="kobo.943.1">Moq and NSubstitute help you isolate dependencies and provide alternative implementations </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">for testing.</span></span></li>
<li><span class="koboSpan" id="kobo.945.1">Snapper and Scientist .NET help catch issues where complex objects change in </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">subtle ways.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.947.1">Not every project will benefit from each of these libraries. </span><span class="koboSpan" id="kobo.947.2">However, knowing the tools at your disposal will help you as you refactor and maintain your code and expand </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">your tests.</span></span></p>
<p><span class="koboSpan" id="kobo.949.1">While it’s possible to do all the things in this chapter without using these libraries, all of these libraries represent established community projects dedicated to solving specific </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">technical concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">In the next chapter, we’ll close out this section of this book with a discussion of defensive coding practices using </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">modern C#.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.953.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.954.1">What areas of your test code could be more readable? </span><span class="koboSpan" id="kobo.954.2">Are there any libraries in this chapter that </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">might help?</span></span></li>
<li><span class="koboSpan" id="kobo.956.1">How do mocking libraries such as Moq and NSubstitute help </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">in testing?</span></span></li>
<li><span class="koboSpan" id="kobo.958.1">Do you see any areas of your code where the complexity is high enough that Snapper or Scientist .NET might be able </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">to help?</span></span></li>
</ol>
<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.960.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.961.1">You can find more information about the libraries discussed in this chapter at </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">these URLs:</span></span></p>
<ul>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.963.1">Shouldly</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">: </span></span><a href="https://github.com/shouldly/shouldly"><span class="No-Break"><span class="koboSpan" id="kobo.965.1">https://github.com/shouldly/shouldly</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.966.1">FluentAssertions</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">: </span></span><a href="https://fluentassertions.com/"><span class="No-Break"><span class="koboSpan" id="kobo.968.1">https://fluentassertions.com/</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.969.1">Bogus</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">: </span></span><a href="https://github.com/bchavez/Bogus"><span class="No-Break"><span class="koboSpan" id="kobo.971.1">https://github.com/bchavez/Bogus</span></span></a><a href="https://github.com/bchavez/Bogus "/></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.972.1">Moq</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">: </span></span><a href="https://github.com/moq/moq"><span class="No-Break"><span class="koboSpan" id="kobo.974.1">https://github.com/moq/moq</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.975.1">NSubstitute</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">https://nsubstitute.github.io/</span></span></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.978.1">Snapper</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">: </span></span><a href="https://github.com/theramis/Snapper"><span class="No-Break"><span class="koboSpan" id="kobo.980.1">https://github.com/theramis/Snapper</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.981.1">Scientist .</span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.982.1">NET</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">: </span></span><a href="https://github.com/scientistproject/Scientist.net"><span class="No-Break"><span class="koboSpan" id="kobo.984.1">https://github.com/scientistproject/Scientist.net</span></span></a></li>
</ul>
</div>
</body></html>