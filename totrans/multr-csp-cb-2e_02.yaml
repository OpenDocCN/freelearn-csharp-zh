- en: Chapter 2. Thread Synchronization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 线程同步
- en: 'In this chapter, we will describe some of the common techniques of working
    with shared resources from multiple threads. You will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述一些从多个线程处理共享资源的常见技术。你将学习以下技巧：
- en: Performing basic atomic operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行基本的原子操作
- en: Using the `Mutex` construct
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Mutex`结构
- en: Using the `SemaphoreSlim` construct
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SemaphoreSlim`结构
- en: Using the `AutoResetEvent` construct
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AutoResetEvent`结构
- en: Using the `ManualResetEventSlim` construct
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ManualResetEventSlim`结构
- en: Using the `CountDownEvent` construct
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CountDownEvent`结构
- en: Using the `Barrier` construct
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Barrier`结构
- en: Using the `ReaderWriterLockSlim` construct
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ReaderWriterLockSlim`结构
- en: Using the `SpinWait` construct
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SpinWait`结构
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading
    Basics*, it is problematic to use a shared object simultaneously from several
    threads. However, it is very important to synchronize those threads so that they
    perform operations on that shared object in a proper sequence. In the *Locking
    with a C# lock keyword* recipe, we faced a problem called the race condition.
    The problem occurred because the execution of those multiple threads was not synchronized
    properly. When one thread performs increment and decrement operations, the other
    threads must wait for their turn. Organizing threads in such a way is often referred
    to as **thread synchronization**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第一章](ch01.html "第一章. 线程基础")中看到的，*线程基础*，从几个线程同时使用共享对象是有问题的。然而，同步这些线程以使它们按正确顺序对共享对象执行操作非常重要。在*使用C#
    lock关键字进行锁定*技巧中，我们遇到了一个称为竞争条件的问题。问题发生是因为这些多个线程的执行没有正确同步。当一个线程执行增加和减少操作时，其他线程必须等待它们的轮次。以这种方式组织线程通常被称为**线程同步**。
- en: There are several ways to achieve thread synchronization. First, if there is
    no shared object, there is no need for synchronization at all. Surprisingly, it
    is very often the case that we can get rid of complex synchronization constructs
    by just redesigning our program and removing a shared state. If possible, just
    avoid using a single object from several threads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实现线程同步有几种方法。首先，如果没有共享对象，就根本不需要同步。令人惊讶的是，我们经常可以通过重新设计我们的程序并删除共享状态来消除复杂的同步结构。如果可能的话，只需避免从多个线程使用单个对象。
- en: If we must have a shared state, the second approach is to use only **atomic**
    operations. This means that an operation takes a single quantum of time and completes
    at once, so no other thread can perform another operation until the first operation
    is complete. Therefore, there is no need to make other threads wait for this operation
    to complete and there is no need to use locks; this in turn, excludes the deadlock
    situation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须有一个共享状态，第二种方法就是只使用**原子**操作。这意味着一个操作只占用一个时间量子并立即完成，因此其他线程在第一个操作完成之前不能执行另一个操作。因此，没有必要让其他线程等待这个操作完成，也不需要使用锁；这反过来，排除了死锁的情况。
- en: If this is not possible and the program's logic is more complicated, then we
    have to use different constructs to coordinate threads. One group of these constructs
    puts a waiting thread into a `blocked` state. In a `blocked` state, a thread uses
    as little CPU time as possible. However, this means that it will include at least
    one so-called **context switch**—the thread scheduler of an operating system will
    save the waiting thread's state and switch to another thread, restoring its state
    by turn. This takes a considerable amount of resources; however, if the thread
    is going to be suspended for a long time, it is good. These kind of constructs
    are also called **kernel-mode** constructs because only the kernel of an operating
    system is able to stop a thread from using CPU time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不可能，并且程序的逻辑更复杂，那么我们必须使用不同的结构来协调线程。这些结构中的一组将等待的线程置于`阻塞`状态。在`阻塞`状态下，线程尽可能少地使用CPU时间。然而，这意味着它至少会包含一个所谓的**上下文切换**——操作系统的线程调度器将保存等待线程的状态并切换到另一个线程，然后依次恢复其状态。这需要相当多的资源；然而，如果线程将要长时间挂起，这是好的。这类结构也被称为**内核模式**结构，因为只有操作系统的内核能够停止线程使用CPU时间。
- en: In case, we have to wait for a short period of time, it is better to simply
    wait than switch the thread to a `blocked` state. This will save us the context
    switch at the cost of some wasted CPU time while the thread is waiting. Such constructs
    are referred to as **user-mode** constructs. They are very lightweight and fast,
    but they waste a lot of CPU time in case a thread has to wait for long.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须等待一段时间，最好是简单地等待而不是将线程切换到`阻塞`状态。这将节省我们上下文切换的开销，同时线程等待时会浪费一些CPU时间。这样的构造被称为**用户模式**构造。它们非常轻量级且快速，但当一个线程需要长时间等待时，会浪费大量的CPU时间。
- en: To use the best of both worlds, there are **hybrid** constructs; these try to
    use user-mode waiting first, and then, if a thread waits long enough, it switches
    to the `blocked` state, saving CPU resources.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用两者的优点，存在**混合**构造；这些尝试首先使用用户模式等待，然后，如果一个线程等待足够长的时间，它将切换到`阻塞`状态，从而节省CPU资源。
- en: In this chapter, we will look through the aspects of thread synchronization.
    We will cover how to perform atomic operations and how to use the existing synchronization
    constructs included in .NET Framework.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨线程同步的各个方面。我们将介绍如何执行原子操作，以及如何使用.NET Framework中包含的现有同步构造。
- en: Performing basic atomic operations
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行基本原子操作
- en: This recipe will show you how to perform basic atomic operations on an object
    to prevent the race condition without blocking threads.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将向您展示如何对一个对象执行基本原子操作，以防止竞态条件而不阻塞线程。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe1`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter2\Recipe1`中找到。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand basic atomic operations, perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解基本原子操作，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Below the `Main` method, add the following code snippet:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码片段：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码片段：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program runs, it creates three threads that will execute a code in
    the `TestCounter` method. This method runs a sequence of increment/decrement operations
    on an object. Initially, the `Counter` object is not thread-safe and we get a
    race condition here. So, in the first case, a counter value is not deterministic.
    We could get a zero value; however, if you run the program several times, you
    will eventually get some incorrect nonzero result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它创建三个线程，这些线程将在`TestCounter`方法中执行代码。此方法在对象上运行一系列增加/减少操作。最初，`Counter`对象不是线程安全的，我们在这里得到竞态条件。因此，在第一种情况下，计数器的值不是确定的。我们可能会得到零值；然而，如果您多次运行程序，最终会得到一些不正确的非零结果。
- en: In [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading Basics*,
    we resolved this problem by locking our object, causing other threads to be blocked
    while one thread gets the old counter value and then computes and assigns a new
    value to the counter. However, if we execute this operation in such a way, it
    cannot be stopped midway, we would achieve the proper result without any locking,
    and this is possible with the help of the `Interlocked` construct. It provides
    the `Increment`, `Decrement`, and `Add` atomic methods for basic math, and it
    helps us to write the `Counter` class without the use of locking.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。线程基础")，*线程基础*中，我们通过锁定我们的对象来解决这个问题，导致其他线程被阻塞，而一个线程获取旧的计数器值，然后计算并分配新的计数器值。然而，如果我们以这种方式执行此操作，它不能中途停止，我们可以在没有任何锁定的情况下实现正确的结果，这可以通过`Interlocked`构造来实现。它提供了`Increment`、`Decrement`和`Add`原子方法用于基本数学运算，并帮助我们编写`Counter`类而不使用锁定。
- en: Using the Mutex construct
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mutex构造
- en: This recipe will describe how to synchronize two separate programs using the
    `Mutex` construct. A `Mutex` construct is a synchronization primitive that grants
    exclusive access of the shared resource to only one thread.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将描述如何使用`Mutex`构造同步两个不同的程序。`Mutex`构造是一个同步原语，它只允许一个线程对共享资源进行独占访问。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe2`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter2\Recipe2`中找到。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the synchronization of two separate programs using the `Mutex`
    construct, perform the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用`Mutex`结构同步两个独立程序，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，添加以下代码片段：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the program.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines a mutex with a specific name, providing
    the `initialOwner` flag as `false`. This allows the program to acquire a mutex
    if it is already created. Then, if no mutex is acquired, the program simply displays
    **Running** and waits for any key to be pressed in order to release the mutex
    and exit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它使用特定名称定义一个互斥锁，并将`initialOwner`标志设置为`false`。这允许程序在互斥锁已创建的情况下获取互斥锁。然后，如果没有获取到互斥锁，程序将简单地显示**运行中**并等待按下任意键以释放互斥锁并退出。
- en: If we start a second copy of the program, it will wait for 5 seconds, trying
    to acquire the mutex. If we press any key in the first copy of a program, the
    second one will start the execution. However, if we keep waiting for 5 seconds,
    the second copy of the program will fail to acquire the mutex.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动程序的第二个副本，它将等待5秒钟，试图获取互斥锁。如果我们按下第一个程序副本中的任意键，第二个程序将开始执行。然而，如果我们继续等待5秒钟，程序的第二副本将无法获取互斥锁。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that a mutex is a global operating system object! Always close the mutex
    properly; the best choice is to wrap a mutex object into a `using` block.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，互斥锁是一个全局操作系统对象！始终正确关闭互斥锁；最佳选择是将互斥锁对象包装在`using`块中。
- en: This makes it possible to synchronize threads in different programs, which could
    be useful in a large number of scenarios.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在不同程序中同步线程成为可能，这在许多场景中可能很有用。
- en: Using the SemaphoreSlim construct
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`SemaphoreSlim`结构
- en: This recipe will show you how to limit multithreaded access to some resources
    with the help of the `SemaphoreSlim` construct. `SemaphoreSlim` is a lightweight
    version of `Semaphore`; it limits the number of threads that can access a resource
    concurrently.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将向您展示如何使用`SemaphoreSlim`结构限制对某些资源的多线程访问。`SemaphoreSlim`是`Semaphore`的一个轻量级版本；它限制了可以并发访问资源的线程数。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe3`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter2\Recipe3`中找到。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to limit a multithreaded access to a resource with the help
    of the `SemaphoreSlim` construct, perform the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用`SemaphoreSlim`结构限制对资源的多线程访问，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Below the `Main` method, add the following code snippet:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码片段：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，添加以下代码片段：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the program.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it creates a `SemaphoreSlim` instance, specifying
    the number of concurrent threads allowed in its constructor. Then, it starts six
    threads with different names and start times to run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它创建一个`SemaphoreSlim`实例，并在其构造函数中指定允许的并发线程数。然后，它启动六个具有不同名称和启动时间的线程来运行。
- en: Every thread tries to acquire access to a database, but we restrict the number
    of concurrent accesses to a database to four threads with the help of a semaphore.
    When four threads get access to a database, the other two threads wait until one
    of the previous threads finishes its work and signals to other threads by calling
    the `_semaphore.Release` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都试图获取访问数据库的权限，但我们通过使用信号量将并发访问数据库的线程数限制为四个。当四个线程获取到数据库的访问权限时，其他两个线程将等待，直到之前的某个线程完成其工作并通过调用`_semaphore.Release`方法向其他线程发出信号。
- en: There's more…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here, we use a hybrid construct, which allows us to save a context switch in
    cases where the wait time is very short. However, there is an older version of
    this construct called `Semaphore`. This version is a pure, kernel-time construct.
    There is no sense in using it, except in one very important scenario; we can create
    a named semaphore like a named mutex and use it to synchronize threads in different
    programs. `SemaphoreSlim` does not use Windows kernel semaphores and does not
    support interprocess synchronization, so use `Semaphore` in this case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个混合构造函数，它允许我们在等待时间非常短的情况下节省上下文切换。然而，这个构造函数有一个较老的版本，称为 `Semaphore`。这个版本是一个纯内核时间构造函数。除了在一个非常重要的场景之外，使用它没有意义；我们可以创建一个命名信号量，就像命名互斥锁一样，并使用它来在不同程序中同步线程。`SemaphoreSlim`
    不使用 Windows 内核信号量，也不支持进程间同步，所以在这种情况下使用 `Semaphore`。
- en: Using the AutoResetEvent construct
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `AutoResetEvent` 构造函数
- en: In this recipe, there is an example of how to send notifications from one thread
    to another with the help of an `AutoResetEvent` construct. `AutoResetEvent` notifies
    a waiting thread that an event has occurred.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，有一个示例，说明如何使用 `AutoResetEvent` 构造函数从线程发送通知。`AutoResetEvent` 通知等待的线程已发生事件。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe4`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要 Visual Studio 2015。没有其他先决条件。此配方的源代码可在 `BookSamples\Chapter2\Recipe4`
    中找到。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to send notifications from one thread to another with the
    help of the `AutoResetEvent` construct, perform the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 `AutoResetEvent` 构造函数在两个线程之间发送通知，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Below the `Main` method, add the following code snippet:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方，添加以下代码片段：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部，添加以下代码片段：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the program.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines two `AutoResetEvent` instances. One
    of them is for signaling from the second thread to the main thread, and the second
    one is for signaling from the main thread to the second thread. We provide `false`
    to the `AutoResetEvent` constructor, specifying the initial sate of both the instances
    as `unsignaled`. This means that any thread calling the `WaitOne` method of one
    of these objects will be blocked until we call the `Set` method. If we initialize
    the event state to `true`, it becomes `signaled` and the first thread calling
    `WaitOne` will proceed immediately. The event state then becomes `unsignaled`
    automatically, so we need to call the `Set` method once again to let the other
    threads calling the `WaitOne` method on this instance to continue.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个 `AutoResetEvent` 实例。其中一个是用于从第二个线程向主线程发送信号，另一个是用于从主线程向第二个线程发送信号。我们将
    `false` 传递给 `AutoResetEvent` 构造函数，指定这两个实例的初始状态为 `未发送信号`。这意味着任何调用这些对象之一的 `WaitOne`
    方法的线程都将被阻塞，直到我们调用 `Set` 方法。如果我们初始化事件状态为 `true`，它将变为 `已发送信号`，第一个调用 `WaitOne` 的线程将立即继续。然后事件状态将自动变为
    `未发送信号`，因此我们需要再次调用 `Set` 方法，以便其他调用此实例上 `WaitOne` 方法的线程继续。
- en: Then, we create a second thread, which executes the first operation for 10 seconds
    and waits for the signal from the second thread. The signal notifies that the
    first operation is completed. Now, the second thread waits for a signal from the
    main thread. We do some additional work on the main thread and send a signal by
    calling the `_mainEvent.Set` method. Then, we wait for another signal from the
    second thread.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个第二个线程，该线程执行第一个操作 10 秒并等待第二个线程的信号。信号通知第一个操作已完成。现在，第二个线程等待来自主线程的信号。我们在主线程上执行一些额外的工作，并通过调用
    `_mainEvent.Set` 方法发送信号。然后，我们等待来自第二个线程的另一个信号。
- en: '`AutoResetEvent` is a kernel-time construct, so if the wait time is not significant,
    it is better to use the next recipe with `ManualResetEventslim`, which is a hybrid
    construct.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoResetEvent` 是一个内核时间构造函数，所以如果等待时间不显著，最好使用带有 `ManualResetEventslim` 的下一个配方，它是一个混合构造函数。'
- en: Using the ManualResetEventSlim construct
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `ManualResetEventSlim` 构造函数
- en: This recipe will describe how to make signaling between threads more flexible
    with the `ManualResetEventSlim` construct.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将描述如何使用 `ManualResetEventSlim` 构造函数使线程之间的信号更加灵活。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe5`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步完成这个菜谱，你需要Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在`BookSamples\Chapter2\Recipe5`找到。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the use of the `ManualResetEventSlim` construct, perform the
    following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`ManualResetEventSlim`构造的使用，执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the program.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it first creates an instance of the `ManualResetEventSlim`
    construct. Then, we start three threads that wait for this event to signal them
    to continue the execution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它首先创建一个`ManualResetEventSlim`构造的实例。然后，我们启动三个线程，等待这个事件信号它们继续执行。
- en: The whole process of working with this construct is like letting people pass
    through a gate. The `AutoResetEvent` event that we looked at in the previous recipe
    works like a turnstile, allowing only one person to pass at a time. `ManualResetEventSlim`,
    which is a hybrid version of `ManualResetEvent`, stays open until we manually
    call the `Reset` method. Going back to the code, when we call `_mainEvent.Set`,
    we open it and allow the threads that are ready to accept this signal to continue
    working. However, thread number three is still sleeping and does not make it in
    time. We call `_mainEvent.Reset` and we thus close it. The last thread is now
    ready to go on, but it has to wait for the next signal, which will happen a few
    seconds later.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个构造的过程就像让人们通过一个门。我们在之前的菜谱中看到的`AutoResetEvent`事件就像一个旋转门，一次只允许一个人通过。`ManualResetEventSlim`是`ManualResetEvent`的混合版本，它保持开启状态，直到我们手动调用`Reset`方法。回到代码中，当我们调用`_mainEvent.Set`时，我们打开它，允许准备好接受这个信号的线程继续工作。然而，线程三还在睡眠中，没有及时到达。我们调用`_mainEvent.Reset`，因此关闭了它。最后一个线程现在可以继续前进，但它必须等待下一个信号，这个信号将在几秒钟后发生。
- en: There's more…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: As in one of the previous recipes, we use a hybrid construct that lacks the
    possibility to work at the operating system level. If we need to have a global
    event, we should use the `EventWaitHandle` construct, which is the base class
    for `AutoResetEvent` and `ManualResetEvent`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的菜谱中一样，我们使用了一个混合构造，它不具备在操作系统级别工作的可能性。如果我们需要一个全局事件，我们应该使用`EventWaitHandle`构造，它是`AutoResetEvent`和`ManualResetEvent`的基类。
- en: Using the CountDownEvent construct
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`CountDownEvent`构造
- en: This recipe will describe how to use the `CountdownEvent` signaling construct
    to wait until a certain number of operations complete.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将描述如何使用`CountdownEvent`信号构造来等待直到一定数量的操作完成。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe6`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步完成这个菜谱，你需要Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在`BookSamples\Chapter2\Recipe6`找到。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the use of the `CountDownEvent` construct, perform the following
    steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`CountDownEvent`构造的使用，执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the program.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, we create a new `CountdownEvent` instance, specifying
    that we want it to signal when two operations complete in its constructor. Then,
    we start two threads that signal to the event when they are complete. As soon
    as the second thread is complete, the main thread returns from waiting on `CountdownEvent`
    and proceeds further. Using this construct, it is very convenient to wait for
    multiple asynchronous operations to complete.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，我们创建一个新的`CountdownEvent`实例，在构造函数中指定我们希望在两个操作完成时发出信号。然后，我们启动两个线程，当它们完成时向事件发出信号。一旦第二个线程完成，主线程从等待`CountdownEvent`中返回，并继续执行。使用这个构造，等待多个异步操作完成非常方便。
- en: However, there is a significant disadvantage; `_countdown.Wait()` will wait
    forever if we fail to call `_countdown.Signal()` the required number of times.
    Make sure that all your threads complete with the `Signal` method call when using
    `CountdownEvent`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个显著的缺点；如果我们未能按照要求次数调用`_countdown.Signal()`，则`_countdown.Wait()`将永远等待。确保在使用`CountdownEvent`时，所有线程都通过`Signal`方法调用完成。
- en: Using the Barrier construct
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Barrier`构造
- en: This recipe illustrates another interesting synchronization construct called
    `Barrier`. The `Barrier` construct helps to organize several threads so that they
    meet at some point in time, providing a callback that will be executed each time
    the threads call the `SignalAndWait` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方演示了另一个有趣的同步构造，称为`Barrier`。`Barrier`构造有助于组织多个线程，以便它们在某个时间点相遇，提供一个在每次线程调用`SignalAndWait`方法时执行的回调。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe7`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter2\Recipe7`中找到。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the use of the `Barrier` construct, perform the following steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`Barrier`构造的使用，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，添加以下代码：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run the program.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create a `Barrier` construct, specifying that we want to synchronize two
    threads, and after each of those two threads call the `_barrier.SignalAndWait`
    method, we need to execute a callback that will print out the number of phases
    completed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Barrier`构造，指定我们想要同步两个线程，并且在这两个线程中的每一个调用`_barrier.SignalAndWait`方法之后，我们需要执行一个回调，该回调将打印出已完成的阶段数。
- en: Each thread will send a signal to `Barrier` twice, so we will have two phases.
    Every time both the threads call the `SignalAndWait` method, `Barrier` will execute
    the callback. It is useful for working with multithreaded iteration algorithms,
    to execute some calculations on each iteration end. The end of the iteration is
    reached when the last thread calls the `SignalAndWait` method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程将向`Barrier`发送两次信号，因此我们将有两个阶段。每次两个线程都调用`SignalAndWait`方法时，`Barrier`将执行回调。这对于与多线程迭代算法一起使用，在每个迭代结束时执行一些计算非常有用。迭代结束时，是最后一个线程调用`SignalAndWait`方法。
- en: Using the ReaderWriterLockSlim construct
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ReaderWriterLockSlim`构造
- en: This recipe will describe how to create a thread-safe mechanism to read and
    write to a collection from multiple threads using a `ReaderWriterLockSlim` construct.
    `ReaderWriterLockSlim` represents a lock that is used to manage access to a resource,
    allowing multiple threads for reading or exclusive access for writing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将描述如何使用`ReaderWriterLockSlim`构造创建一个线程安全的机制，以便从多个线程中读取和写入集合。`ReaderWriterLockSlim`代表一个锁，用于管理对资源的访问，允许多个线程进行读取或为写入提供独占访问。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe8`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter2\Recipe8`中找到。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to create a thread-safe mechanism to read and write to a
    collection from multiple threads using the `ReaderWriterLockSlim` construct, perform
    the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何使用`ReaderWriterLockSlim`构造来创建一个线程安全的机制，以便从多个线程中读取和写入集合，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE20]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，添加以下代码：
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it simultaneously runs three threads that read
    data from a dictionary and two threads that write some data into this dictionary.
    To achieve thread safety, we use the `ReaderWriterLockSlim` construct, which was
    designed especially for such scenarios.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它同时运行三个线程，从字典中读取数据，以及两个线程将一些数据写入这个字典。为了实现线程安全，我们使用`ReaderWriterLockSlim`构造，它专门为这种场景设计。
- en: 'It has two kinds of locks: a read lock that allows multiple threads to read
    and a write lock that blocks every operation from other threads until this write
    lock is released. There is also an interesting scenario when we obtain a read
    lock, read some data from the collection, and, depending on that data, decide
    to obtain a write lock and change the collection. If we get the write locks at
    once, too much time is spent, not allowing our readers to read the data because
    the collection is blocked when we get a write lock. To minimize this time, there
    are `EnterUpgradeableReadLock`/`ExitUpgradeableReadLock` methods. We get a read
    lock and read the data; if we find that we have to change the underlying collection,
    we just upgrade our lock using the `EnterWriteLock` method, then perform a write
    operation quickly and release a write lock using `ExitWriteLock`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两种类型的锁：一种读锁允许多个线程读取，一种写锁会阻塞其他线程的所有操作，直到这个写锁被释放。还有一个有趣的场景，当我们获得读锁，从集合中读取一些数据，并根据这些数据决定获得写锁并更改集合。如果我们一次性获得写锁，会花费太多时间，不允许我们的读者读取数据，因为当我们获得写锁时，集合被阻塞。为了最小化这种时间，有`EnterUpgradeableReadLock`/`ExitUpgradeableReadLock`方法。我们获得读锁并读取数据；如果我们发现我们需要更改底层集合，我们只需使用`EnterWriteLock`方法升级我们的锁，然后快速执行写操作，并使用`ExitWriteLock`释放写锁。
- en: In our case, we get a random number; we then get a read lock and check whether
    this number exists in the dictionary key collection. If not, we upgrade our lock
    to a write lock and then add this new key to a dictionary. It is a good practice
    to use `try`/`finally` blocks to make sure that we always release locks after
    acquiring them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们获取一个随机数；然后我们获得一个读锁并检查这个数字是否存在于字典键集合中。如果没有，我们将锁升级为写锁，然后将这个新键添加到字典中。使用`try`/`finally`块确保我们总是在获取锁后释放它们是一个好习惯。
- en: All our threads have been created as background threads, and after waiting for
    30 seconds, the main thread as well as all the background threads get completed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的所有线程都是作为后台线程创建的，在等待30秒后，主线程以及所有后台线程都将完成。
- en: Using the SpinWait construct
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`SpinWait`构造
- en: This recipe will describe how to wait on a thread without involving kernel-mode
    constructs. In addition, we introduce `SpinWait`, a hybrid synchronization construct
    designed to wait in the user mode for some time, and then switch to the kernel
    mode to save CPU time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将描述如何在不涉及内核模式构造的情况下等待一个线程。此外，我们引入了`SpinWait`，这是一种混合同步构造，设计用于在用户模式下等待一段时间，然后切换到内核模式以节省CPU时间。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter2\Recipe9`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter2\Recipe9`中找到。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to wait on a thread without involving kernel-mode constructs,
    perform the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在不涉及内核模式构造的情况下等待一个线程，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE23]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码：
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，添加以下代码：
- en: '[PRE25]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the program.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines a thread that will execute an endless
    loop for 20 milliseconds until the main thread sets the `_isCompleted` variable
    to `true`. We could experiment and run this cycle for 20-30 seconds instead, measuring
    the CPU load with the Windows task manager. It will show a significant amount
    of processor time, depending on how many cores the CPU has.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它会定义一个线程，该线程将执行一个持续20毫秒的无穷循环，直到主线程将`_isCompleted`变量设置为`true`。我们可以尝试将这个循环运行20-30秒，并用Windows任务管理器测量CPU负载。它将显示大量的处理器时间，这取决于CPU有多少核心。
- en: We use the `volatile` keyword to declare the `_isCompleted` static field. The
    `volatile` keyword indicates that a field might be modified by multiple threads
    being executed at the same time. Fields that are declared `volatile` are not subject
    to compiler and processor optimizations that assume access by a single thread.
    This ensures that the most up-to-date value is present in the field at all times.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`volatile`关键字来声明`_isCompleted`静态字段。`volatile`关键字表示该字段可能被同时执行的多线程修改。被声明为`volatile`的字段不受编译器和处理器优化影响，这些优化假设只有一个线程访问。这确保了字段中始终存在最新的值。
- en: Then, we use a `SpinWait` version, which on each iteration prints a special
    flag that shows us whether a thread is going to switch to a `blocked` state. We
    run this thread for 5 milliseconds to see that. In the beginning, `SpinWait` tries
    to stay in the user mode, and after about nine iterations, it begins to switch
    the thread to a blocked state. If we try to measure the CPU load with this version,
    we will not see any CPU usage in the Windows task manager.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个`SpinWait`版本，它在每次迭代中打印一个特殊标志，显示一个线程是否将要切换到`blocked`状态。我们运行这个线程5毫秒来观察这一点。一开始，`SpinWait`试图保持在用户模式，大约经过九次迭代后，它开始将线程切换到阻塞状态。如果我们尝试使用这个版本来测量CPU负载，我们在Windows任务管理器中将看不到任何CPU使用情况。
