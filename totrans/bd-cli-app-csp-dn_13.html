<html><head></head><body>
		<div id="_idContainer180">
			<h1 id="_idParaDest-216" class="chapter-number"><a id="_idTextAnchor220"/>13</h1>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor221"/>Security Considerations for CLI Applications</h1>
			<p>Security is <a id="_idIndexMarker498"/>one of the most critical concerns in any application development project. Itâ€™s interesting to see that, in many projects, development teams tend to think that because they implemented measures to prevent their applicationâ€™s code from being subject to SQL injection, XSS attacks, or similar, their application <span class="No-Break">is secure.</span></p>
			<p>However, it is important to keep in mind that security takes different forms and spans different areas, which means that it does not only concern the security of the applicationâ€™s code or its usage but also extends to the security of the whole <span class="No-Break">development lifecycle.</span></p>
			<p>In this chapter, we will discuss these different areas and how they are related to securing CLI applications, and we will cover the key areas that you need to consider in order to enhance the security of your CLI application and the security of your development lifecycle. More specifically, we will do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Discuss the different areas in which security should <span class="No-Break">be considered</span></li>
				<li>Learn how to assess the security posture of a <span class="No-Break">CLI application</span></li>
				<li>Learn how to implement authentication in order to secure access to <span class="No-Break">user data</span></li>
			</ul>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor222"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13</span></a></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor223"/>Security areas</h1>
			<p>As <a id="_idIndexMarker499"/>mentioned earlier, security is not only limited to the applicationâ€™s code, nor can it only be achieved by implementing authentication, although these areas are <span class="No-Break">very important.</span></p>
			<p>Letâ€™s first start by highlighting the key areas involved in securing an application throughout its lifecycle. It is important for me to make this point (or reminder) here as I still meet with customers who introduce security too late in the lifecycle of an application (typically after the application has been developed and released to production), expecting security professionals to do miracles and secure the application with minimal or no modification to the application, which is, <span class="No-Break">obviously, unrealistic.</span></p>
			<p>Always keep in mind that security should span the entire lifecycle of the application. In concrete terms, security should be a concern from the early stages of designing <span class="No-Break">the application:</span></p>
			<ul>
				<li><strong class="bold">In the design phase</strong>: It is important to define security<a id="_idIndexMarker500"/> requirements and objectives and to conduct threat modeling using methodologies such as STRIDE<a id="_idIndexMarker501"/> to identify potential security risks so we can incorporate the appropriate security controls into the initial design. STRIDE helps categorize threats into six groups: Spoofing, Tampering, Repudiation, Information disclosure, Denial of service, and Elevation of privilege. After identifying threats, we can use the DREAD model<a id="_idIndexMarker502"/> to quantitatively assess and prioritize them based on their Damage potential, Reproducibility, Exploitability, Affected users, and Discoverability. During this phase, we should also consider privacy and data protection measures, such as encryption, authentication, <span class="No-Break">and authorization.</span></li>
				<li><strong class="bold">In the architecture phase</strong>: We are <a id="_idIndexMarker503"/>not only talking about the software architecture here but also about the infrastructure and networking architecture. Of course, we need to design a secure architecture that includes defense-in-depth strategies and integrates security mechanisms such as authentication and authorization. But we also need to plan for secure communication channels and data storage, using techniques such as encryption at rest and in transit along with network segmentation to ensure only appropriate routes of communication, through the appropriate network <a id="_idIndexMarker504"/>addresses, ports, and domains, and using appropriate protocols <span class="No-Break">are allowed.</span></li>
				<li><strong class="bold">In the development phase</strong>: It is<a id="_idIndexMarker505"/> important to apply secure coding practices by relying on coding standards, such as implementing input validation and sanitization, and to ensure that our application is not vulnerable to common OWASP Top 10 security risks. It is equally important to ensure that secure coding practices are applied during code reviews. But this is not enough! You should use secure libraries and frameworks. In other words, ensure that your frameworks and libraries are still supported and receive security updates. Since we are using .NET 8 here, we know that it is still supported (and will receive security updates) until November 10, 2026 (Iâ€™m writing this in November 2024). As a framework or a library becomes unsupported, it is important to plan to migrate to a newer version (not necessarily the latest, by the <span class="No-Break">way </span><span class="No-Break">ðŸ˜‰</span><span class="No-Break">).</span><p class="list-inset">Suppose our application communicates with external dependencies, such as web services. In that case, we have to ensure that these communications happen in a secure manner (by leveraging authentication and authorization) and using the appropriate protocols (such <span class="No-Break">as HTTPS).</span></p></li>
				<li><strong class="bold">In the infrastructure configuration phase</strong>: All efforts to enhance the applicationâ€™s security could be in vain if<a id="_idIndexMarker506"/> the infrastructure on which it is running is unsecured. In the case of CLI applications, which run on the userâ€™s computer, this responsibility is delegated to them or their organizationâ€™s IT department, which usually controls <span class="No-Break">employeesâ€™ workstations.</span></li>
				<li><strong class="bold">In the testing phase</strong>: Security-specific <a id="_idIndexMarker507"/>testing, including penetration testing and vulnerability assessments, should be performed during the testing phase to ensure user data cannot leak, user accounts cannot be compromised, and the application cannot be diverted from its intended usage toward malicious activities. Performing security testing allows us to validate that security requirements are met. Mature DevSecOps teams perform such testing on a regular basis. However, security tests should at least be performed before<a id="_idIndexMarker508"/> releasing an application <span class="No-Break">to production.</span></li>
				<li><strong class="bold">In the deployment phase</strong>: Every <a id="_idIndexMarker509"/>DevSecOps engineer knows that your CI/CD pipelines can be a security threat if not properly secured. Secrets (such as passwords, API keys, service connections, connection strings, and so on) should be keptâ€¦ well, secret. Every CI/CD tool has its own secret management mechanism, which usually takes the form of a key vault, but we can also rely on external tools that are designed for such purposes, such as Azure Key Vault or HashiCorp Vault. Access to these secrets is usually restricted using roles <span class="No-Break">and permissions.</span></li>
				<li><strong class="bold">While the application is being used</strong>: It is<a id="_idIndexMarker510"/> a common mistake for immature teams and organizations to believe that once the application has been released to production, the job of security is done. Wrong! This is where it all starts. You may argue that we put a lot of effort into securing the application before releasing it to our users, and you would be right. However, by releasing our application into the wild, it will experience a wide range of usage patterns and user environments, way beyond what we could have expected, thought of, and planned for. We will hence have to monitor for security incidents and anomalies, by implementing logging and auditing mechanisms and by regularly updating and patching the application and <span class="No-Break">its dependencies.</span></li>
				<li><strong class="bold">While logging the applicationâ€™s behavior and data</strong>: We all know that logging is an <a id="_idIndexMarker511"/>essential part of monitoring and that it helps understand usage patterns for the application as well as coming in handy when debugging the application. However, it is a good security practice to avoid logging sensitive information, such as passwords, credit card information, or social security numbers, and if we have to do it (for auditing purposes, for example), these logs should be stored in a secure location with restricted and audited access. In <a href="B22400_06.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we<a id="_idIndexMarker512"/> introduced <strong class="bold">Serilog</strong> for logging. This tool provides ways to sanitize logs before they are stored. For example, when configuring the logger, we can call the <strong class="source-inline">Destructure.ByMaskingProperties</strong> method and pass a list of properties to be ignored <a id="_idIndexMarker513"/><span class="No-Break">when logging.</span></li>
				<li><strong class="bold">As new versions or bug fixes are released</strong>: Either when introducing new functionalities or<a id="_idIndexMarker514"/> fixing bugs, it is important to conduct a security impact analysis for the introduced changes. This can be done by performing regression testing to ensure existing security controls are still met and no vulnerability has <span class="No-Break">been introduced.</span></li>
			</ul>
			<p>Fortunately, there is a variety of tools to help at every stage. If your team or organization has adopted a DevSecOps culture, you will already be aware of many of <span class="No-Break">these tools.</span></p>
			<p>DevSecOps<a id="_idIndexMarker515"/> being way beyond the scope of this book, we will not be discussing the broad spectrum of tools you may use at every step. However, I do want to cover tools that will help us assess and enhance the security posture of a <span class="No-Break">CLI application.</span></p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor224"/>Assessing the security posture of a CLI application</h1>
			<p>There are <a id="_idIndexMarker516"/>multiple tools that help assess the security posture of an application (including a CLI application). Among the most widely used ones, we find <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">SonarQube</strong> (and its cloud edition, <strong class="bold">SonarCloud</strong>): This provides powerful static analysis for <a id="_idIndexMarker517"/>code quality and security vulnerabilities, including dependency checks. They can be <a id="_idIndexMarker518"/>integrated into CI/CD pipelines and scan <strong class="source-inline">.csproj</strong> files to detect vulnerabilities in <span class="No-Break">third-party libraries.</span></li>
				<li><strong class="bold">Snyk</strong>: This popular tool <a id="_idIndexMarker519"/>offers vulnerability reporting and scanning for .NET projects. It can be integrated into local development environments as well as into CI/CD pipelines for <span class="No-Break">continuous monitoring.</span></li>
				<li><strong class="bold">Mend Bolt</strong>: Previously<a id="_idIndexMarker520"/> known as <strong class="bold">WhiteSource Bolt</strong>, this security scanning <a id="_idIndexMarker521"/>tool<a id="_idIndexMarker522"/> integrates<a id="_idIndexMarker523"/> with <strong class="bold">Azure DevOps</strong> or <strong class="bold">GitHub</strong> pipelines, scanning .NET projects for open source vulnerabilities and generating <span class="No-Break">detailed reports.</span></li>
				<li><strong class="bold">OWASP Dependency-Check</strong>: This<a id="_idIndexMarker524"/> tool is effective for scanning third-party libraries and dependencies, which is crucial for .NET applications that often rely on <span class="No-Break">external packages.</span></li>
				<li><strong class="bold">GitHub Advanced Security</strong>: This<a id="_idIndexMarker525"/> tool integrates security features directly into GitHub or Azure DevOps workflows, performs code scanning (it uses static analysis to detect potential security vulnerabilities and coding errors) and secret scanning (it recognizes patterns for passwords, API keys, and other secrets and detects whether they are stored in clear text in the repository), and performs dependency reviews and highlights <span class="No-Break">vulnerable </span><span class="No-Break"><a id="_idIndexMarker526"/></span><span class="No-Break">ones.</span></li>
			</ul>
			<p>These tools have in<a id="_idIndexMarker527"/> common that they inform us about the vulnerable library, and give us detailed information about the vulnerability itself and the recommended fix <span class="No-Break">for it.</span></p>
			<p>These tools are either free (such as Mend Bolt and OWASP Dependency-Check) or offer a free plan but with limited functionality (such as SonarQube, Snyk, and GitHub <span class="No-Break">Advanced Security).</span></p>
			<p>They also vary in the level of complexity and effort required to set up and configure them. Hence, you will find SonarQube to be the most complex to set up, Snyk to be moderately easy to set up, and Mend Bolt, OWASP Dependency-Checker, and GitHub Advanced Security to be the easiest ones to <span class="No-Break">set up.</span></p>
			<p>I would recommend Mend Bolt<a id="_idIndexMarker528"/> as a good starting point since it comes as an Azure DevOps or GitHub free extension that can be obtained from their respective marketplaces. For these reasons, these tools are usually intended for organizations or <span class="No-Break">larger teams.</span></p>
			<p>However, the good news is that .NET already provides us with an out-of-the-box tool to serve this very purpose of assessing and enhancing the security posture of <span class="No-Break">our application.</span></p>
			<p>This tool, commonly <a id="_idIndexMarker529"/>known as dotnet-audit, focuses<a id="_idIndexMarker530"/> on detecting vulnerabilities in .NET project dependencies (namely, <strong class="source-inline">NuGet</strong> packages) by relying on the <strong class="source-inline">GitHub Advisory Database</strong>. For .NET-only projects, such<a id="_idIndexMarker531"/> as <strong class="bold">Bookmarkr</strong>, this tool is the perfect <span class="No-Break">starting point!</span></p>
			<p>To execute this tool, we simply need to type the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet list package --vulnerable</pre>			<p>The results will be shown in the terminal window, and will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B22400_13_01.jpg" alt="Figure 13.1 â€“ Listing vulnerable packages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 â€“ Listing vulnerable packages</p>
			<p>As you may have noticed in this figure, the command has not been executed on Bookmarkrâ€™s code but rather for another application. As it turns out, we are glad that no vulnerability has been detected for Bookmarkr (yeah!), but this might change over time as vulnerabilities in referenced libraries <span class="No-Break">are detected.</span></p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B22400_13_02.jpg" alt="Figure 13.2 â€“ No vulnerable packages for Bookmarkr"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 â€“ No vulnerable packages for Bookmarkr</p>
			<p>Keep in mind that this command may ask you to<a id="_idIndexMarker532"/> run <strong class="source-inline">dotnet restore</strong> before you can execute it. This is especially true if this is the first time you have cloned the <span class="No-Break">Git repository.</span></p>
			<p>There is another <a id="_idIndexMarker533"/>command that does not directly scan for vulnerabilities, but which I recommend. This command lists outdated packages. While these packages might not have known vulnerabilities, being outdated means that they will no longer receive security updates. My recommendation is that you consider upgrading these packages to newer supported versions (once again, not necessarily the latest version if this introduces <span class="No-Break">breaking changes).</span></p>
			<p>To run this command, simply type <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet list package --outdated</pre>			<p>As you can see from the result of executing this command, although no vulnerability has been detected in Bookmarkrâ€™s dependencies, some of them <span class="No-Break">are outdated:</span></p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B22400_13_03.jpg" alt="Figure 13.3 â€“ Listing outdated packages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 â€“ Listing outdated packages</p>
			<p>The appropriate way to upgrade these packages is to create a new branch, update the packages, test the application (both using manual and automated testing, as described in <a href="B22400_10.xhtml#_idTextAnchor155"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>) to ensure that the application still works as expected and that we did not introduce regressions, and finally, issue a pull request to merge the modifications into the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> branch.</span></p>
			<p>We now have the necessary knowledge and tools to assess, and ultimately enhance, the security posture of our CLI application. Letâ€™s focus our attention on securing communication between our CLI application and the external services it interacts with, to protect against <a id="_idIndexMarker534"/>unauthorized access and ensure proper user management. This can be achieved <span class="No-Break">through authentication.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor225"/>Securing remote communications using authentication</h1>
			<p>In <a href="B22400_09.xhtml#_idTextAnchor136"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we introduced the <strong class="source-inline">sync</strong> command, which <a id="_idIndexMarker535"/>allows Bookmarkr to back up local bookmarks to a remote location and retrieve them when needed. When doing so, the command also synchronizes local and <span class="No-Break">remote bookmarks.</span></p>
			<p>Until now, the communication between the local CLI application and the remote external service has happened in an insecure manner. This means that anyone who invokes the <strong class="source-inline">sync</strong> command may retrieve your personal bookmarks, which you clearly donâ€™t want, <span class="No-Break">do you?</span></p>
			<p>To address this issue, we need to <span class="No-Break">implement authentication.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor226"/>Why is authentication important?</h2>
			<p>You may be wondering why authentication<a id="_idIndexMarker536"/> should be required in the context of CLI applications. After all, a CLI application runs on the userâ€™s computer, which already requires that user to authenticate to <span class="No-Break">their session.</span></p>
			<p>In the context of CLI applications, authentication is usually required when communicating with external services (i.e., sending data to and retrieving data from these services). This ensures that users have access to their data at the remote location by proving who <span class="No-Break">they are.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor227"/>How to perform authentication</h2>
			<p>Authentication <a id="_idIndexMarker537"/>can be achieved in many ways. One of the most common ones is for the external service provider to provide you with <a id="_idIndexMarker538"/>a <strong class="bold">Personal Access Token</strong> (<strong class="bold">PAT</strong>). You can usually get or generate such tokens by visiting the service providerâ€™s website and logging in to your account. From there, on your accountâ€™s settings page, you should be able to get that token or to generate a new one. Such tokens are usually valid for a given period of time and expire <span class="No-Break">after that.</span></p>
			<p>Once you have this token, you can pass it as a parameter to a command that performs the call to the external service. An example of this would be the <strong class="source-inline">sync</strong> command, which could be invoked <span class="No-Break">as follows:</span></p>
			<pre class="console">
bookmarkr sync --pat YOUR_PAT</pre>			<p>Here, <strong class="source-inline">YOUR_PAT</strong> is most commonly a <span class="No-Break">GUID value.</span></p>
			<p>This call would then authenticate the user using the received PAT value before performing the <span class="No-Break">sync operation.</span></p>
			<p>As you may have noticed, this approach could quickly become tedious as it is not easy to remember the value of a <a id="_idIndexMarker539"/>PAT. For this reason, CLI applications usually store such values either in a local configuration file, in an environment variable, or in the operating systemâ€™s key vault. This allows the user to invoke the command without always having to pass the PAT as a parameter. The command will be smart enough to look for it in the local configuration file or in the<a id="_idIndexMarker540"/> environment variable and use it if it is present. If it is not present, the command should display an error message asking the user to provide it. If the PAT is invalid or expired, the command should also be able to inform the user <span class="No-Break">about that.</span></p>
			<p>This is the approach adopted by GitHub â€“ for example: you create a PAT within your GitHub account, which you can use to authenticate and access GitHub resources from external services or applications. In our use case, the external service is the one that provides and manages the tokens, whereas the CLI application is only responsible for sending these tokens to the <span class="No-Break">external service.</span></p>
			<p>Another commonly used <a id="_idIndexMarker541"/>approach is to authenticate the user against an <strong class="bold">identity provider</strong> (<strong class="bold">IdP</strong>) such as Google, Facebook, or Microsoft. With this approach, a CLI application will usually provide a specific command for authentication (such as <strong class="source-inline">auth</strong>). Invoking this command usually triggers the default web browser and redirects the user to the application providerâ€™s login page. After successful authentication, the IdP provides access and an ID token that the CLI can use for subsequent requests to the external service. These tokens are, as for the PAT, usually included in the HTTP headers when performing the requests to the external service. This approach leverages the <strong class="source-inline">OAuth 2.0</strong> and the <strong class="source-inline">OpenID </strong><span class="No-Break"><strong class="source-inline">Connect</strong></span><span class="No-Break"> protocols.</span></p>
			<p>In the remainder of this chapter, we will explore how to implement authentication for Bookmarkr to secure communications with the <strong class="bold">BookmarkrSyncr</strong> <span class="No-Break">external service.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor228"/>Implementing authentication</h1>
			<p>Here, we will leverage the PAT<a id="_idIndexMarker542"/> approach as it is more convenient and can work even in environments where no web browser can be launched, such as <span class="No-Break">CI/CD pipelines.</span></p>
			<p>To illustrate how this could be achieved, we will need to implement functionalities at <span class="No-Break">two levels:</span></p>
			<ul>
				<li><strong class="bold">BookmarkrSyncr</strong>: The<a id="_idIndexMarker543"/> external service will receive the PAT, validate it, and authenticate the user if it <span class="No-Break">is valid</span></li>
				<li><strong class="bold">Bookmarkr</strong>: The <a id="_idIndexMarker544"/>responsibility of the CLI application is to pass the token to the external service and act according to the response it gets from the <span class="No-Break">sent request</span></li>
			</ul>
			<p>Letâ€™s start by adding the required functionality <span class="No-Break">into BookmarkrSyncr.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor229"/>Authenticating external services using a PAT</h2>
			<p>To<a id="_idIndexMarker545"/> make things simple, we will assume that BookmarkrSyncr (the code for which can be found in the <strong class="source-inline">AppendixB</strong> folder) holds two PAT tokens: a valid one and an expired one. All other values that the user passes will be considered invalid and will be rejected for <span class="No-Break">this reason.</span></p>
			<p>The token validation service will also be a very <span class="No-Break">basic one.</span></p>
			<p>While most of the code remains as it was, we had to make the following changes to the parameters we pass to the <span class="No-Break"><strong class="source-inline">MapPost</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
app.MapPost("/sync", async ([FromHeader(Name = "X-PAT")] string pat, List&lt;Bookmark&gt; bookmarks, ITokenValidator tokenValidator, HttpContext context) =&gt;
{
Â Â Â Â Â â€¦
}</pre>			<p>Letâ€™s explain <span class="No-Break">these changes:</span></p>
			<ol>
				<li>We indicate that the value of the PAT token comes from an HTTP header named <strong class="source-inline">X-PAT</strong> and that this value will be stored in the input parameter <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">pat</strong></span><span class="No-Break">.</span></li>
				<li>We pass a parameter of type <strong class="source-inline">ITokenValidator</strong>, which is a service we have created to retrieve and validate <span class="No-Break">PAT tokens.</span></li>
				<li>We pass the current HTTP context that we will need to set HTTP headers for the HTTP response, especially to notify the client that the received PAT token is either invalid or expired. We use a different response header to ensure that the client knows exactly why the request was unauthorized, as this is good <span class="No-Break">programming practice.</span></li>
			</ol>
			<p>We then invoke <a id="_idIndexMarker546"/>methods of the <strong class="source-inline">TokenValidator</strong> service to check whether the PAT token is invalid or expired, and if so, we set the appropriate HTTP header in the response object. The code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
// Ensure the Personal Access Token (PAT) is valid
if (!tokenValidator.IsValid(pat))
{
Â Â Â Â context!.Response.Headers["X-Invalid-PAT"] = pat;
Â Â Â Â return Results.Unauthorized();
}
// Ensure the Personal Access Token (PAT) is not expired
if (tokenValidator.IsExpired(pat))
{
Â Â Â Â context!.Response.Headers["X-Expired-PAT"] = pat;
Â Â Â Â return Results.Unauthorized();
}</pre>			<p>Notice how <a id="_idIndexMarker547"/>we set the HTTP header. We use the indexer syntax. This will set the header. If the header already exists, it will replace the existing value with the <span class="No-Break">new one.</span></p>
			<p>The last thing we need to do is to register the <strong class="source-inline">TokenValidator</strong> service. This can be done for any service, using this widely <span class="No-Break">known syntax:</span></p>
			<pre class="source-code">
builder.Services.AddScoped&lt;ITokenValidator, TokenValidator&gt;();</pre>			<p>The <strong class="source-inline">TokenValidator</strong> service is very basic and its code looks <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public class TokenValidator : ITokenValidator
{
Â Â Â Â private readonly List&lt;PatToken&gt; _tokens = new();
Â Â Â Â public TokenValidator()
Â Â Â Â {
Â Â Â Â Â Â Â Â // we are simulating a token store here...
Â Â Â Â Â Â Â Â _tokens.Add(new PatToken { Value = "4de3b2b9-afaf-406c-ab0d-
Â Â Â Â Â Â Â Â d59ac534411d", IsExpired = false });
Â Â Â Â Â Â Â Â _tokens.Add(new PatToken { Value = "16652977-c654-431e-8f84-
Â Â Â Â Â Â Â Â bd53b4ccd47d", IsExpired = true });
Â Â Â Â }
Â Â Â Â public bool IsExpired(string token)
Â Â Â Â {
Â Â Â Â Â Â Â Â var retrievedToken = _tokens.FirstOrDefault(t =&gt; t.Value.
Â Â Â Â Â Â Â Â Equals(token, StringComparison.OrdinalIgnoreCase));
Â Â Â Â Â Â Â Â if(retrievedToken == null) return false;
Â Â Â Â Â Â Â Â return retrievedToken.IsExpired;
Â Â Â Â }
Â Â Â Â public bool IsValid(string token)
Â Â Â Â {
Â Â Â Â Â Â Â Â var retrievedToken = _tokens.FirstOrDefault(t =&gt; t.Value.
Â Â Â Â Â Â Â Â Equals(token, StringComparison.OrdinalIgnoreCase));
Â Â Â Â Â Â Â Â return retrievedToken != null;
Â Â Â Â }
}</pre>			<p>The only thing worth mentioning here is that we are simulating a token store (in the classâ€™s constructor). In a real-world scenario, we would have a persistent token store (such as a database). But for the purposes of this demonstration, storing these PAT tokens in memory makes the code easier to understand. I also want you to notice that, for the purpose of the demonstration, we have two tokens: one is a valid token, and the other represents an expired token. Any other value will be considered invalid since it cannot be found in the<a id="_idIndexMarker548"/> token store (which is realistic, by the way ðŸ˜‰). The client (the CLI application) will hence behave differently depending on the validity of <span class="No-Break">the token.</span></p>
			<p>Excellent! Now that we have our external service ready, itâ€™s time to update the client so that it can pass <span class="No-Break">the PAT.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor230"/>Passing the PAT from the CLI application to the external service</h2>
			<p>For <a id="_idIndexMarker549"/>this to happen, we will need to modify the code of both the <strong class="source-inline">sync</strong> command and the <span class="No-Break">service agent.</span></p>
			<p>More specifically, we will need to do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Add a <strong class="source-inline">--pat</strong> parameter to the <span class="No-Break"><strong class="source-inline">sync</strong></span><span class="No-Break"> command.</span></li>
				<li>Modify the request that the HTTP client makes to the external service so that it sends the <span class="No-Break">PAT token.</span></li>
				<li>Modify the code to store the PAT token in an environment variable and retrieve it from there if the <strong class="source-inline">--pat</strong> parameter is not specified when invoking the <span class="No-Break"><strong class="source-inline">sync</strong></span><span class="No-Break"> command.</span></li>
			</ol>
			<p>Letâ€™s start with the <span class="No-Break">first step.</span></p>
			<p>Letâ€™s go to the <strong class="source-inline">SyncCommand.cs</strong> file and, in the <strong class="source-inline">Options</strong> region, letâ€™s add an <strong class="source-inline">Option</strong> for the PAT <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
private Option&lt;string&gt; patOption = new Option&lt;string&gt;(
Â Â Â Â ["--pat", "-p"],
Â Â Â Â "The PAT used to authenticate to BookmarkrSyncr"
);</pre>			<p>This <strong class="source-inline">Option</strong> is optional, as we <span class="No-Break">mentioned earlier.</span></p>
			<p>Next, we need to <a id="_idIndexMarker550"/>make the command use this <strong class="source-inline">Option</strong>. For that matter, we need to add this instruction to the <span class="No-Break">classâ€™s constructor:</span></p>
			<pre class="source-code">
AddOption(patOption);</pre>			<p>Now, letâ€™s modify the commandâ€™s handler method so that the HTTP client can send the PAT to the BookmarkrSyncr service. For that matter, we need to modify the handler methodâ€™s signature to pass the PAT as a parameter, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
private async Task OnSyncCommand(string patValue)
{
Â Â Â Â ...
}</pre>			<p>Back to the classâ€™s constructor again, we need to modify the call to the <strong class="source-inline">SetHandler</strong> method to pass the PAT Option as a parameter. The modified method call looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
this.SetHandler(OnSyncCommand, patOption);</pre>			<p>Next, we need to pass this token to the service agent. For that matter, we first need to modify the call to the service agent in the handler method, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var mergedBookmarks = await _serviceAgent.Sync(patValue, retrievedBookmarks);</pre>			<p>Then, we need to update the code of the <strong class="source-inline">BookmarkrSyncrServiceAgent</strong> class to ensure the presence of the token before calling the <span class="No-Break">external service.</span></p>
			<p>The first thing we need to do is, obviously, pass the PAT value as a parameter to its <strong class="source-inline">Sync</strong> method, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public async Task&lt;List&lt;Bookmark&gt;&gt; Sync(string pat, List&lt;Bookmark&gt; localBookmarks)</pre>			<p>After that, the first thing the method should do is to ensure the presence of the PAT (i.e., ensure that we are not sending a null or an empty value to the external service). We do this by adding<a id="_idIndexMarker551"/> the following code at the beginning of <span class="No-Break">the method:</span></p>
			<pre class="source-code">
// ensure that the pat is present
if(string.IsNullOrWhiteSpace(pat))
{
Â Â Â Â string? value = Environment.GetEnvironmentVariable("BOOKMARKR_
Â Â Â Â PAT");
Â Â Â Â if(value == null) throw new PatNotFoundException(pat);
Â Â Â Â pat = value;
}</pre>			<p>A few things to <span class="No-Break">note here:</span></p>
			<ul>
				<li>We do not validate the token, nor do we check whether it is expired. This is the role of the BookmarkrSyncr <span class="No-Break">external service.</span></li>
				<li>The environment variable that is used to hold the PAT token is named <strong class="source-inline">BOOKMARKR_PAT</strong>. This name ensures that this variable does not conflict with any other variable set on the <span class="No-Break">userâ€™s computer.</span></li>
				<li>We have created a custom exception class, <strong class="source-inline">PatNotFoundException</strong>, to inform the client in case the PAT token has not <span class="No-Break">been found.</span></li>
			</ul>
			<p>Now, since the PAT token is retrieved, we need to send it to the external service. We hence need to modify the HTTP client to pass the token in the HTTP headers of the request, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var client = _clientFactory.CreateClient("bookmarkrSyncr");
// Add the PAT to the request header
client.DefaultRequestHeaders.Add("X-PAT", pat);
var response = await client.PostAsync("sync", content);</pre>			<p>If the request to the external service is successful, we know that the PAT token is valid. We will then save it to the environment variable if it is not already present there. The updated code is <a id="_idIndexMarker552"/>therefore <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if (response.IsSuccessStatusCode)
{
Â Â Â Â // saving the PAT to the environment variable, if not already
Â Â Â Â string? value = Environment.GetEnvironmentVariable("BOOKMARKR_
Â Â Â Â PAT");
Â Â Â Â if(value == null || !value.Equals(pat)) Environment.
Â Â Â Â SetEnvironmentVariable("BOOKMARKR_PAT", pat);
Â Â Â Â // remaining of the code
}</pre>			<p>However, if the PAT token is invalid or expired, we need to inform the client so that the proper error message is displayed to the user. We therefore need to modify the code block that handles the <strong class="source-inline">Unauthorized</strong> status code, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
switch(response.StatusCode)
{
Â Â Â Â case HttpStatusCode.Unauthorized:
Â Â Â Â Â Â Â Â if (response.Headers.TryGetValues("X-Invalid-PAT", out var 
Â Â Â Â Â Â Â Â headerValues))
Â Â Â Â Â Â Â Â Â Â Â Â throw new PatInvalidException(pat);
Â Â Â Â Â Â Â Â if (response.Headers.TryGetValues("X-Expired-PAT", out var 
Â Â Â Â Â Â Â Â headerValues2))
Â Â Â Â Â Â Â Â Â Â Â Â throw new PatExpiredException(pat);
Â Â Â Â Â Â Â Â throw new HttpRequestException($"Unauthorized access: 
Â Â Â Â Â Â Â Â {response.StatusCode}");
Â Â Â Â // remaining of the code
}</pre>			<p>This code is straightforward and easy to understand. One thing worth mentioning though is that here, again, we created custom exception classes, namely <strong class="source-inline">PatInvalidException</strong> and <strong class="source-inline">PatExpiredException</strong>, to clearly express the intent of an error when raising them. These exception classes can be found in the <strong class="source-inline">Exceptions.cs</strong> file located in the <span class="No-Break"><strong class="source-inline">BookmarkrSyncrServiceAgent</strong></span><span class="No-Break"> folder.</span></p>
			<p>The last step is to go back to the <strong class="source-inline">SyncCommand</strong> class, handle the responses from the service agent, and display the appropriate error messages to the user. For that matter, we need to modify<a id="_idIndexMarker553"/> the code of the <strong class="source-inline">OnSyncCommand</strong> handler method to catch the custom exceptions described previoulsy. The <strong class="source-inline">catch</strong> blocks are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
catch(PatNotFoundException ex)
{
Â Â Â Â Helper.ShowErrorMessage([$"The provided PAT value ({ex.Pat}) was 
Â Â Â Â not found."]);
}
catch(PatInvalidException ex)
{
Â Â Â Â Helper.ShowErrorMessage([$"The provided PAT value ({ex.Pat}) is 
Â Â Â Â invalid."]);
}
catch(PatExpiredException ex)
{
Â Â Â Â Helper.ShowErrorMessage([$"The provided PAT value ({ex.Pat}) is 
Â Â Â Â expired."]);
}</pre>			<p>And thatâ€™s it â€“ we have completed all the required code modifications for Bookmarkr to ensure secure communication with the external service, BookmarkrSyncr, by using a PAT (it was about time, <span class="No-Break">right? </span><span class="No-Break">ðŸ˜‰</span><span class="No-Break">).</span></p>
			<p>Letâ€™s see if <span class="No-Break">this works!</span></p>
			<p>The first test is to invoke the <strong class="source-inline">sync</strong> command without passing a PAT token. Knowing that it will not be <a id="_idIndexMarker554"/>found in the <strong class="source-inline">BOOKMARKR_PAT</strong> environment variable, the following error <span class="No-Break">is expected:</span></p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B22400_13_04.jpg" alt="Figure 13.4 â€“ The PAT token was not found"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 â€“ The PAT token was not found</p>
			<p>The second test is to invoke the <strong class="source-inline">sync</strong> command with an invalid PAT token. Here too, an error message <span class="No-Break">is expected:</span></p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B22400_13_05.jpg" alt="Figure 13.5 â€“ The PAT token is invalid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 â€“ The PAT token is invalid</p>
			<p>The next test is<a id="_idIndexMarker555"/> to invoke the <strong class="source-inline">sync</strong> command with an expired PAT token. Here too, an error message <span class="No-Break">is expected:</span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B22400_13_06.jpg" alt="Figure 13.6 â€“ The PAT token is expired"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 â€“ The PAT token is expired</p>
			<p>The final test is to invoke the <strong class="source-inline">sync</strong> command with a valid PAT token. We can see that the bookmarks have been synchronized and that the PAT token has been saved to the <strong class="source-inline">BOOKMARKR_PAT</strong> <span class="No-Break">environment variable:</span></p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B22400_13_07.jpg" alt="Figure 13.7 â€“ The PAT token is valid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 â€“ The PAT token is valid</p>
			<p>Wonderful! We now know all we need to know to assess and enhance the security of our <span class="No-Break">CLI applications.</span></p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor231"/>Summary</h1>
			<p>In this chapter, we explored the various forms security can take, and we learned that it is not limited to the security of the applicationâ€™s code but rather covers a broad spectrum of areas that span its entire lifecycle. We learned what tools and techniques we can use to assess and enhance the security posture of our CLI application. We also learned how to secure access to user data, especially when dealing with external services, by implementing authentication <span class="No-Break">and authorization.</span></p>
			<p>Congratulations! You have now all the necessary knowledge and skills to build, secure, test, package, and release your very own CLI applications to the world. Look at you â€“ what a milestone you have achieved. Take a moment to be proud of yourself and <span class="No-Break">to celebrate!</span></p>
			<p>My journey with you, throughout the pages of this book, is almost over. But before you turn the last page and gently close the cover of this book, there is one last thing I wanted to share with you, one final chapter whose purpose is to provide you with additional learning material to help you continue your journey as well as pointing you to some useful tools <span class="No-Break">and libraries.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor232"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the Bookmarkr application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor233"/>Task #1 â€“ Update dependency versions</h2>
			<p>We have seen how to list outdated packages that have reached their end of support and talked about the importance of updating these. However, I havenâ€™t <span class="No-Break">updated these.</span></p>
			<p>Your task is to clone the code into your GitHub or Azure DevOps account and to <span class="No-Break">update it.</span></p>
			<p>Once the dependencies have been updated, you will need to validate that the behavior of the application was not impacted, in other words, you need to ensure that the application still behaves as expected. This can be done by running the tests you <span class="No-Break">developed earlier.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor234"/>Task #2 â€“ Use Mend Bolt to scan the code for vulnerabilities</h2>
			<p>Your task is to clone the code into your GitHub or Azure DevOps account, enable Mend Bolt, and run a security scan. If any vulnerability is to be found, <span class="No-Break">fix it!</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor235"/>Task #3 â€“ Allow BookmarkrSyncr to manage multiple users</h2>
			<p>Although we updated BookmarkrSyncr to receive and validate a PAT, it does not use this token to retrieve and update the appropriate <span class="No-Break">userâ€™s data.</span></p>
			<p>You are tasked to update the code to make this happen. The easiest way to achieve this is to have a separate JSON file for every user whose name matches the value of the PAT. Hence, the bookmarks for every user can be stored and retrieved <span class="No-Break">from there.</span></p>
		</div>
	</body></html>