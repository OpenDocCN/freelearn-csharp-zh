<html><head></head><body>
        

                            
                    <h1 class="header-title">Adding Audio and Visual Effects to Our Game</h1>
                
            
            
                
<p class="mce-root">In <a href="7098e2ac-1871-4cb2-98ba-36f3acdb0515.xhtml" target="_blank">Chapter 11</a>, <em>Scripting Victory and Defeat</em>, we designed and scripted our game's victory and defeat conditions. We updated our game's scripts to manage the Cucumber Man's health, including updating the HUD's health bar. We implemented our victory and end-of-game logic through scripting. We also implemented the lives remaining and enabled dynamic on-screen indicators of those lives. Lastly, we scripted the random respawning of our player character.</p>
<p>In this chapter, we will plan and implement audio and visual effects to help enhance overall gameplay. Specifically, we will add audio to key events in our combat system and add several special effects using Unity's Particle System to enhance the game's visual appeal.</p>
<p>Specifically, we will cover the following in this chapter:</p>
<ul>
<li>An overview of Unity's audio system</li>
<li>Planning our game's audio</li>
<li>Implementing our game's audio</li>
<li>An introduction to Unity's lights and shadows</li>
<li>An overview of Unity's special effects</li>
<li>Adding visual effects to our game</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Discovering Unity's audio system</h1>
                
            
            
                
<p>Unity has an impressive array of audio capabilities. It supports 3D spatial sound, which provides a surround-sound effect. This gives our audio source a point and dimension. There are also extensive mixing and mastering capabilities in Unity.</p>
<p>In this section, we will explore the basics of audio in Unity and take a look at the Audio Mixer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity audio basics</h1>
                
            
            
                
<p>Unity supports several audio effects, including the Duck Volume Audio Effect, which allows us to manipulate an audio signal's volume.</p>
<p>The term <kbd>duck</kbd> refers to making the audio signal quieter.</p>
<p>We can use a variety of audio formats in Unity. You can see the four formats listed here:</p>
<ul>
<li><strong>Audio Interchange File Format</strong> (<strong>AIFF</strong>) </li>
<li>MP3</li>
<li><strong>Ogg Vorbis</strong> (<strong>OGG</strong>)</li>
<li>WAV</li>
</ul>
<p>If you have audio assets that are in a file format different from these four, you can probably use a free audio conversion tool to change the file format.</p>
<p>When we import an audio file into a Unity game, the file becomes an audio clip. Audio clips can also be created from within Unity by using your computer's microphone. You can even create audio clips via scripts during your game.</p>
<p>In Unity, audio sources are attached to objects. These audio sources emit, or play, sound and audio listener components do receive the sound emitted by audio sources. You can think of audio listeners as the player's ears inside the game world, hearing what's near them. Usually, one audio listener component is attached to the main camera so that the sounds it picks up on align well with what is displayed in the game view. Listeners are also attached to objects. Let's look at an example to see how a GameObject, an audio source, and listeners are related.</p>
<p>Let's say we are creating a zoo simulation and are working on the bovine section. There is a holding area for cows. Cows are generally quiet, but might be noisy eaters. The cow would be our GameObject and it would emit a <em>chewing</em> audio clip. The audio clip's RAW file (that is, <kbd>chewing.aiff</kbd>) would be identified as an audio source component attached to the cow GameObject. Now, let's say there is a farmer character. We can attach a listener to the farmer, which is also an object. That listener is a script that performs certain actions if it hears the sound from the cow. Perhaps, if the listener picks up the <em>chewing</em> sound, they will know that more hay is needed.</p>
<p>The following diagram illustrates the relationships between the various components:</p>
<div><img height="162" width="484" src="img/6475a6ed-0b1d-4cea-a6e9-e146cece8d05.png"/></div>
<p>You will learn how to use these components later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity's Audio Mixer</h1>
                
            
            
                
<p>Unity's Audio Mixer gives you the ability to mix and master audio sources and effects. To access the Audio Mixer, you select Window from the pull-down menu, and then select Audio Mixer.</p>
<p>When you first open the Audio Mixer window, you will see that there are no mixers in your project. As you can see in the following screenshot, there is a + icon on the far-right side of that window: </p>
<div><img height="116" width="661" src="img/b1731d2b-d6fe-4bd3-a0bb-a2006bedef64.png"/></div>
<p>Clicking that icon enables you to create a mixer.</p>
<p>When you have a mixer in your project, the Audio Mixer window reveals four sections on the left. As shown in the following screenshot, these are Mixers, Snapshots, Groups, and Views. All the mixers in your project will be listed here. The Snapshots are a collection of parameters that you can use in your mixer. An Audio Mixer Group can be used to modify audio source sounds prior to them reaching the listeners. The final section is Views. A View is just a saved state of the mixer groups:</p>
<div><img height="304" width="346" src="img/8906b466-1d78-4f4f-a0ff-8f5aede6ad93.png"/></div>
<p>To the right of the Audio Mixer window, you see a single mixer in our project. When you click the Add button, you will see a popup, shown here, that reveals several options: </p>
<div><img height="413" width="191" src="img/f84d98ad-13cf-4029-af9f-df0ea96abfa2.png"/></div>
<p>We will not use these options in our game, but they are worth exploring if you intend to implement advanced audio effects in your game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning our game's audio</h1>
                
            
            
                
<p>Planning a game's audio is an important part of game design. Just because we can do something with regards to audio, does not mean we should. Too much audio can be as off-putting as not enough. </p>
<p>The audio selected for the Cucumber Man game is intended to provide sufficient demonstration of how to import, configure, and script a game for various audio effects. To that end, the following audio will be implemented in our Cucumber Man game:</p>
<ul>
<li>Animations that require sounds:
<ul>
<li>Cucumber Man
<ul>
<li>Jump</li>
<li>Throw</li>
<li>Die</li>
<li>Respawn</li>
</ul>
</li>
<li>Cucumber Beetles
<ul>
<li>Eat</li>
<li>Standing Run</li>
<li>Die</li>
</ul>
</li>
</ul>
</li>
<li>Events that require sounds:
<ul>
<li>Player Defeat</li>
<li>Player Victory</li>
</ul>
</li>
</ul>
<p>We will perform the implementation in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing our game's audio</h1>
                
            
            
                
<p>In this section, we will implement the audio requirements listed in the previous section. We will import, configure, and script our game to complete the implementation. Before we get started, you should open your Unity game project. Alternatively, you can download the Starting-Chapter-12 Unity project available from the publisher's companion site.</p>
<p>We will implement our game's audio in three steps, each handled in subsequent sections:</p>
<ul>
<li>Importing audio assets</li>
<li>Implementing Cucumber Beetle audio</li>
<li>Implementing Cucumber Man audio</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Importing audio assets</h1>
                
            
            
                
<p>Our first task is to import the audio assets into our game project. Here are the steps:</p>
<ol>
<li>Open the game project.</li>
<li>In the Project panel, right-click Assets and select Create | Folder.</li>
<li>Name the new folder <kbd>Audio</kbd>.</li>
<li>Right-click the <kbd>Audio</kbd> folder and select Import Package | Custom Package.</li>
<li>Navigate to the <kbd>cucumber_man_audio.unitypackage</kbd> file available from the publisher's site for this book. You should see the following screenshot pop up in your Unity interface:</li>
</ol>
<div><img height="357" width="340" src="img/57ea928c-cf96-45c3-81f5-9748565bd9cb.png"/></div>
<ol start="6">
<li>In the Import Unity Package dialog window, ensure all audio files are selected and click the Import button.</li>
<li>In the Project panel, select the first audio file. Then, in the Inspector panel, use the interface to play the audio clip. </li>
</ol>
<p> </p>
<ol start="8">
<li>Repeat step 7 for each of the nine audio clips. This will familiarize you with each sound and ensure they can play on your computer.</li>
</ol>
<p>Now that we have our audio assets in our game project, let's review how each of them will be used. The following table maps each audio file to the appropriate in-game animation or event:</p>
<table>
<tbody>
<tr>
<td><strong>In-Game animation/Event</strong></td>
<td><strong>Related GameObject</strong></td>
<td><strong>Audio asset</strong></td>
</tr>
<tr>
<td>Jump animation</td>
<td>Cucumber Man</td>
<td><kbd>jump.wav</kbd></td>
</tr>
<tr>
<td>Throw animation</td>
<td>Cucumber Man</td>
<td><kbd>throw.wav</kbd></td>
</tr>
<tr>
<td>Die animation</td>
<td>Cucumber Man</td>
<td><kbd>cm_die.wav</kbd></td>
</tr>
<tr>
<td>Respawn event</td>
<td>Cucumber Man</td>
<td><kbd>respawn.wav</kbd></td>
</tr>
<tr>
<td>Eat animation</td>
<td>Cucumber Beetle</td>
<td><kbd>eating.wav</kbd></td>
</tr>
<tr>
<td>Standing Run animation</td>
<td>Cucumber Beetle</td>
<td><kbd>attack.wav</kbd></td>
</tr>
<tr>
<td>Die on Ground animation</td>
<td>Cucumber Beetle</td>
<td><kbd>beetle_die.wav</kbd></td>
</tr>
<tr>
<td>Die Standing animation</td>
<td>Cucumber Beetle</td>
<td><kbd>beetle_die.wav</kbd></td>
</tr>
<tr>
<td>Player Defeat event</td>
<td>Cucumber Man</td>
<td><kbd>game_over.wav</kbd></td>
</tr>
<tr>
<td>Player Victory event</td>
<td>Cucumber Man</td>
<td><kbd>victory.wav</kbd></td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Cucumber Beetle audio</h1>
                
            
            
                
<p>In this section, we will configure the Cucumber Beetle prefab so that it supports audio when the Cucumber Beetles eat, when they run while standing, and when they die. Here are the steps:</p>
<ol>
<li>Select the beetle prefab in the Project panel's <kbd>Assets</kbd> | <kbd>Prefabs</kbd> folder. If you have more than one prefab, be sure to use the one that is used in your game.</li>
<li>In the Inspector panel, scroll to the bottom and click the Add Component button.</li>
<li>Select Audio | Audio Source.</li>
<li>Uncheck the Play On Awake box. </li>
</ol>
<p style="padding-left: 60px">Normally, we would assign an <kbd>AudioClip</kbd> to our Audio Source component. Since our Cucumber Beetles will have more than one audio clip, we will not assign one here. </p>
<p style="padding-left: 60px">Our next step is to edit the <kbd>BeetleNPC</kbd> script. Open that script file and make the following modifications:</p>
<ol start="5">
<li>Add the following member variables:</li>
</ol>
<pre>      public AudioSource audioSource;<br/>      public AudioClip eating;<br/>      public AudioClip attack;<br/>      public AudioClip die; </pre>
<ol start="6">
<li>Add the following statement to the <kbd>Start()</kbd> method:</li>
</ol>
<pre>      audioSource = GetComponent&lt;AudioSource&gt; ();</pre>
<ol start="7">
<li>Edit the <kbd>OnTriggerEnter()</kbd> method as shown here. You will see two <kbd>audioSource.PlayOneShot()</kbd> statements, one each for the <kbd>eating</kbd> and <kbd>attack</kbd> audio clips:</li>
</ol>
<pre>      void OnTriggerEnter(Collider theObject) {<br/>         if (theObject.gameObject.CompareTag ("Cucumber")) {<br/>              cucumberToDestroy = theObject.gameObject;<br/>              BeetlePatrol.isEating = true;<br/>              animator.Play ("Eating on Ground");<br/>              audioSource.PlayOneShot (eating);<br/>              StartCoroutine ("DestroyCucumber");<br/>          } else if (theObject.gameObject.CompareTag ("Cherry")) {<br/>              _ptsManager = GameObject.Find <br/>              ("Score_Value").GetComponent&lt;PointsManager&gt;();<br/>              PointsManager.currentScore = PointsManager.currentScore + 10; <br/>              BeetlePatrol.isAttacking = true;<br/>              cherryHit = true;<br/>              animator.Play ("Stand");<br/>              audioSource.PlayOneShot (attack);<br/>          }<br/>      } </pre>
<ol start="8">
<li>Edit the <kbd>DestroySelfOnGround()</kbd> method, shown as follows. Here you can see that we added the <kbd>audioSource.PlayOneShot(die)</kbd> statement:</li>
</ol>
<pre>      IEnumerator DestroySelfOnGround() {<br/>          yield return new WaitForSecondsRealtime (4);<br/>          animator.Play ("Die on Ground");<br/>          audioSource.PlayOneShot (die);<br/>          Destroy (this.gameObject, 4);<br/>      }</pre>
<ol start="9">
<li>Edit the <kbd>DestroySelfStanding()</kbd> method as shown in the following code block. Here, you can see we added the <kbd>audioSource.PlayOneShot(die)</kbd> statement:</li>
</ol>
<pre>      IEnumerator DestroySelfStanding() {<br/>          yield return new WaitForSecondsRealtime (4);<br/>          animator.Play ("Die Standing");<br/>          audioSource.PlayOneShot (die);<br/>          Destroy (this.gameObject, 4);<br/>          cherryHit = false;<br/>      } </pre>
<p style="padding-left: 60px">Now that the scripting task is complete, we need to assign the designated audio clips to the variables we created:</p>
<ol start="10">
<li>In the Inspector panel, scroll until you see the Beetle NPC (Script) component.</li>
<li>Drag the <kbd>eating</kbd> audio clip from the Project panel's <kbd>Assets</kbd> | <kbd>Audio</kbd> folder to the appropriate spot in the Beetle NPC (Script) component.</li>
<li>Repeat step 11 for the <kbd>attack</kbd> and <kbd>beetle_die</kbd> audio clips. Your Beetle NPC (Script) component should look like the following:</li>
</ol>
<div><img height="181" width="372" src="img/dec5e8a0-a8ea-4e36-b977-9ec8c7241f8c.png"/></div>
<p>All that's left is for you to test this new functionality by playing the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Cucumber Man audio</h1>
                
            
            
                
<p>In this section, we will configure the Cucumber Man prefab so that it supports audio when the Cucumber Beetles eat, when they run while standing, and when they die. Here are the steps:</p>
<ol>
<li>Select the Cucumber Man in the Hierarchy panel.</li>
<li>In the Inspector panel, scroll to the bottom and click the Add Component button.</li>
<li>Select Audio | Audio Source.</li>
<li>Uncheck the Play On Awake box.</li>
</ol>
<p style="padding-left: 60px">Normally, we would assign an <kbd>AudioClip</kbd> to our Audio Source component. Since our Cucumber Man will have more than one audio clip, we will not assign one here. </p>
<p style="padding-left: 60px">Our next step is to edit the <kbd>BeetleNPC</kbd> script. Open that script file and make the following modifications:</p>
<ol start="5">
<li>Add the following member variables:</li>
</ol>
<pre>      public AudioSource audioSource;<br/>      public AudioClip dying;<br/>      public AudioClip respawning; <br/>      public AudioClip gameOver;</pre>
<ol start="6">
<li>Create a <kbd>Start()</kbd> method, shown as follows:</li>
</ol>
<pre>      void Start () {<br/>          audioSource = GetComponent&lt;AudioSource&gt; ();<br/>      } </pre>
<ol start="7">
<li>Edit the <kbd>Update()</kbd> method, as shown here, so that it includes the three <kbd>audioSource.PlayOneShot()</kbd> statements:</li>
</ol>
<pre>      if (livesRemaining == 2) {<br/>          Destroy (GameObject.Find ("Life3"));<br/>          anim = GetComponent&lt;Animator&gt; ();<br/>          anim.Play ("CM_Die");<br/>          audioSource.PlayOneShot (dying);<br/>          StartCoroutine ("ReSpawnCucumberMan");<br/>      }<br/>      if (livesRemaining == 1) {<br/>          Destroy (GameObject.Find ("Life2"));<br/>          anim = GetComponent&lt;Animator&gt; ();<br/>          anim.Play ("CM_Die");<br/>          audioSource.PlayOneShot (dying);<br/>          StartCoroutine ("ReSpawnCucumberMan");<br/>      }<br/>      if (livesRemaining == 0) {<br/>          Destroy (GameObject.Find ("Life1"));<br/>          anim = GetComponent&lt;Animator&gt; ();<br/>          anim.Play ("CM_Die");<br/>          audioSource.PlayOneShot (gameOver);<br/>      } </pre>
<ol start="8">
<li>Edit the <kbd>ReSpawnCucumberMan()</kbd> method as shown here. You can see that we added the <kbd>audioSource.PlayOneShot()</kbd> statement:</li>
</ol>
<pre>      IEnumerator ReSpawnCucumberMan() {<br/>          int randomNumber = Random.Range (1, 4);<br/>          if (randomNumber == 1) {<br/>              yield return new WaitForSecondsRealtime (4);<br/>              this.transform.position = SpawnPad1.transform.position;<br/>          } else if (randomNumber == 2) {<br/>              yield return new WaitForSecondsRealtime (4);<br/>              this.transform.position = SpawnPad2.transform.position;<br/>          } else {<br/>              yield return new WaitForSecondsRealtime (4);<br/>              this.transform.position = SpawnPad3.transform.position;<br/>          }<br/>          audioSource.PlayOneShot (respawning);<br/>          anim.Play ("CM_Idle");<br/>      } </pre>
<p style="padding-left: 60px">Now that our script changes for the <kbd>CucumberManManager</kbd> script file are complete, we need to assign the designated audio clips to the variables we created. Here are the steps:</p>
<ol start="9">
<li>In the Inspector panel, scroll until you see the Cucumber Man Manager (Script) component.</li>
<li>Drag the <kbd>cm_die</kbd> audio clip from the Project panel's <kbd>Assets</kbd> | <kbd>Audio</kbd> folder to the appropriate spot in the Cucumber Man Manager (Script) component.</li>
<li>Repeat step 10 for the <kbd>respawn</kbd> and <kbd>game_over</kbd> audio clips. Your Cucumber Man Manager (Script) component should look like this:</li>
</ol>
<div><img height="189" width="358" src="img/c0bcf2c8-12ed-4cd1-8075-33ccdc560616.png"/></div>
<p style="padding-left: 60px">So far, we have taking care of the dying, respawning, and game over audio clips. Next, we will handle the jumping and throwing audio clips:</p>
<ol start="12">
<li>Open the <kbd>PlayerController</kbd> script for editing.</li>
<li>Add the following member variables:</li>
</ol>
<pre>      public AudioSource audioSource;<br/>      public AudioClip jumping;<br/>      public AudioClip throwing; </pre>
<ol start="14">
<li>Add the following statement to the <kbd>Start()</kbd> method:</li>
</ol>
<pre>       audioSource = GetComponent&lt;AudioSource&gt; (); </pre>
<ol start="15">
<li>Add the following statement to the beginning of the <kbd>Jump()</kbd> method:</li>
</ol>
<pre>       audioSource.PlayOneShot (jumping); </pre>
<ol start="16">
<li>Add the following statement to the beginning of the <kbd>Throw()</kbd> method:</li>
</ol>
<pre>       audioSource.PlayOneShot (throwing); </pre>
<p style="padding-left: 60px">Now that our script changes for the <kbd>PlayerController</kbd> script file are complete, we need to assign the designated audio clips to the variables we created. Here are the steps:</p>
<ol start="17">
<li>In the Inspector panel, scroll until you see the Player Controller (Script) component.</li>
<li>Drag the <kbd>jump</kbd> audio clip from the Project panel's <kbd>Assets</kbd> | <kbd>Audio</kbd> folder to the appropriate spot in the Player Controller (Script) component.</li>
</ol>
<p> </p>
<ol start="19">
<li>Drag the <kbd>throw</kbd> audio clip from the Project pane's <kbd>Assets</kbd> | <kbd>Audio</kbd> folder to the appropriate spot in the Player Controller (Script) component. Your Player Controller (Script) component should look like the following:</li>
</ol>
<div><img height="173" width="389" src="img/0a6fc6ef-92ae-487c-a58b-3b3efd8b6b0a.png"/></div>
<p style="padding-left: 60px">The last audio clip for us to implement is the victory clip. We will start by editing the <kbd>VictoryManager</kbd> script. Open that script file and make the following modifications:</p>
<ol start="20">
<li>Add the following member variables:</li>
</ol>
<pre>      public AudioSource audioSource;<br/>      public AudioClip victory;  </pre>
<ol start="21">
<li>Create a  <kbd>Start()</kbd> method, as shown here:</li>
</ol>
<pre>      void Start () {<br/>          audioSource = GetComponent&lt;AudioSource&gt; ();<br/>      } </pre>
<ol start="22">
<li>Edit the <kbd>Update()</kbd> method, shown as follows. You will notice that we only added an audio clip playback for the victory condition, as we've already taken care of the defeat condition:</li>
</ol>
<pre>      void Update () {<br/>          beetleCount = BeetleManager.currentBeetleCount;<br/>          if (beetleCount == 0) {<br/>              Victory.text = ("You won!");<br/>              audioSource.PlayOneShot (victory);<br/>          }<br/><br/>          cucumberCount = CucumberManager.currentCucumberCount;<br/><br/>          if (cucumberCount == 0) {<br/>              Victory.text = ("You Lost!");<br/>          }<br/>      } </pre>
<p style="padding-left: 60px">Now that our script changes for the <kbd>VictoryManager</kbd> script file are completed, we need to assign the victory audio clip to the variable we created. Here are the steps:</p>
<ol start="23">
<li>In the Hierarchy panel, select <kbd>HUD_Canvas</kbd> | <kbd>EndOfGame</kbd> | Victory.</li>
<li>In the Inspector panel, scroll until you see the Victory Manager (Script) component.</li>
<li>Drag the <kbd>victory</kbd> audio clip from the Project panel's <kbd>Assets</kbd> | <kbd>Audio</kbd> folder to the appropriate spot in the Victory Manager (Script) component. Your Victory Manager (Script) component should look like the following screenshot:</li>
</ol>
<div><img height="74" width="422" src="img/9212a714-f234-4959-9246-ca31f91e0744.png"/></div>
<p>You are now ready to test this new functionality by playing the game.</p>
<p>This is an excellent time to save both your scene and your project. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to Unity's lights and shadows</h1>
                
            
            
                
<p>Lighting in games is important as it is what allows GameObjects to be seen. If we did not have lights in our game, the game screen would be completely black. In Unity, it is easy to take lighting for granted because, when we create a new scene, there is a default Main Camera and a Directional Light. </p>
<p>Shadows in game worlds are another component that can be taken for granted because Unity's default settings regarding shadows is often sufficient for games. </p>
<p>In this section, we will look at light sources and shadows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding light sources</h1>
                
            
            
                
<p>In Unity, lights are GameObjects and are available in several different types. Here are the most common types of light sources:</p>
<ul>
<li>Directional light</li>
<li>Point light</li>
<li>Spot light</li>
<li>Area light</li>
</ul>
<p>Let's look at each of these lights.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Directional light</h1>
                
            
            
                
<p>The Directional light is like the sun. As you can see from the following Inspector panel, there are several settings that can be adjusted for Directional lights beyond the Transform's Position, Rotation, and Scale:</p>
<div><img height="338" width="414" src="img/5aa1f7d5-0c20-4063-9842-d069f0f69bac.png"/></div>
<p>The following table provides information about key settings for Directional lights.</p>
<table>
<tbody>
<tr>
<td><strong>Setting</strong></td>
<td><strong>Details</strong></td>
</tr>
<tr>
<td>Color</td>
<td>You can select a color for the light to emit. For realistic outdoor scenes, you would probably use a light yellow color.</td>
</tr>
<tr>
<td>Mode</td>
<td>You can select from Realtime, Baked, or Mixed lighting modes. When Realtime is selected, the direct light is computed each frame during the game. This provides a realistic game experience and is the default mode.</td>
</tr>
<tr>
<td>Intensity</td>
<td>Adjust this to control brightness. </td>
</tr>
<tr>
<td>Shadow Type</td>
<td>There are three options here: Soft Shadows, Hard Shadows, and No Shadows. Soft Shadows cast soft edges and avoid the sharp-edged shadows that are cast using Hard Shadows. As you would expect, Soft Shadows is more processor-intensive than Hard Shadows.</td>
</tr>
<tr>
<td>Realtime Shadows</td>
<td>This area provides additional control over your shadows.</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Point light</h1>
                
            
            
                
<p>Point lights are like light bulbs without lampshades. In fact, they are the ideal type of light to use to simulate a small, local source of light such as a table lamp, wall sconce, or chandelier. As you can see in the following screenshot of the Inspector panel, you can modify the Range, Color, and Intensity. You can also select from Realtime, Baked, or Mixed render modes:</p>
<div><img height="263" width="386" src="img/7db0af5b-9b96-4196-aaa8-3b6d5b737ce7.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Spot light</h1>
                
            
            
                
<p>A Spot light is like a flashlight and provides cone-shaped illumination. This type of light is ideal for simulating flashlights, automobile headlights, plane lights, search lights, and Spot lights. As you can see in the following Inspector panel screenshot, there is a Spot Angle property. Spot lights also have properties in common with other types of lights.</p>
<div><img height="328" width="458" src="img/42ea7d07-aef9-4c88-aefa-fd81b77ea634.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Area light</h1>
                
            
            
                
<p>An Area (baked only) light is something that is used when you bake images into textures. This type of light is great for simulating light coming out of a building, such as from a window. Area lights are also good for LED stadium lighting. The properties Width and Height, shown in the following screenshot, are not present in Directional, Point, and Spot lights:</p>
<div><img height="242" width="453" src="img/6fd6f05f-5c13-49ff-92ad-8ea9b8277178.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Shadows</h1>
                
            
            
                
<p>Unity affords us great control over shadows in our game scenes. We can control which objects cast shadows, which objects can receive shadows, and various properties of the shadows. Shadows in Unity closely replicate the way shadows exist in the real world. As discussed earlier in this chapter, there are soft shadows and hard shadows. </p>
<p>Soft shadows result in greater realism, but at the cost of additional computations and processing. Hard shadows provide less realistic, but often acceptable, shadows during a game and are less processor intensive. Hard shadows are easy to identify in a game because the shadows cast will have sharp, blocky shadow edges.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Discovering Unity's special effects</h1>
                
            
            
                
<p>Unity has a great capabilities for special effects in three categories: Particle System, Trail Renderer, and Line Renderer. These are available via the GameObject | Effects top menu.</p>
<p>Adding an Effects component to a GameObject is accomplished by using the Add Component | Effects option in the Inspector panel. As you can see in the following screenshot, the Particle System, Trail Renderer, and Line Renderer options are available via this method. There are also additional options, such as Lens Flare and Halo:</p>
<div><img height="199" width="209" src="img/5c26c352-2b90-41c1-a868-731cbb611090.png"/></div>
<p>In this section, we will discuss the Particle System and Trail Renderer effects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Particle System</h1>
                
            
            
                
<p>Particle Systems use a vast number of tiny 2D images or meshes in a scene to simulate effects such as liquids, smoke, flames, pixie dust, fireworks, and clouds. The basic concept is that one simple 2D image or mesh can be used in large quantities to create a robust and dense visual effect. These 2D images or meshes are the particle, and they collectively form the Particle System. </p>
<p>Each particle in a Particle System is rendered from a specific point and has a limited lifespan. How long this lifespan lasts depends on your implementation, but it typically only lasts a few seconds.</p>
<p>As you can see from the following Inspector panel screenshot, there are several parameters that allow us to customize the behavior of Particle Systems. We will add a Particle System to our game later in this chapter:</p>
<div><img src="img/a37e9b8a-74bb-4d55-99bb-9d4ac63fec60.png"/></div>
<p>When we add a Particle System to our scene, Unity presents us with an interface, the Particle Effect panel, in the lower-right corner of the Scene view. This interface allows us to play, pause, and stop the Particle simulation, as well as adding additional parameter settings while observing the changes to the simulation:</p>
<div><img height="161" width="209" src="img/265fc7f7-165c-4482-855c-1a6fab6d88f3.png"/></div>
<p>Unity 2018, in beta at the time of this book's publication, has support for GPU instancing of Particle System mesh rendering, support for Orbital Velocity, and enables particle emitter shapes, which permits texture reading for masking and color tinting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trail Renderer</h1>
                
            
            
                
<p>A Trail Renderer is a visual effect that creates a trail behind a GameObject as it moves. Classic examples of this are a jet's afterburner, a car's exhaust, and the Tasmanian Devil's visual swoosh (dust cloud). The following Inspector panel screenshot illustrates the parameters that can be manipulated to customize a Trail Renderer:</p>
<div><img height="421" width="314" src="img/c0f6f962-5560-478e-914d-a572ebe494f9.png"/></div>
<p>The primary Trail Renderer settings are described here:</p>
<table>
<tbody>
<tr>
<td><strong>Setting</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>Cast Shadows</td>
<td>There are four options here: On, Off, Two-Sided, and Shadows Only. The default setting is On.</td>
</tr>
<tr>
<td>Receive Shadows</td>
<td>This is an on/off toggle.</td>
</tr>
<tr>
<td>Materials</td>
<td>You can select a particle shader for the material and adjust the size.</td>
</tr>
<tr>
<td>Time</td>
<td>This setting defines the length of the trail.</td>
</tr>
<tr>
<td>Autodestruct</td>
<td>You can select this option to have the trail GameObject destroyed once it has been idle for the number of seconds set in the Time setting.</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding visual effects to our game</h1>
                
            
            
                
<p>Our game already has a Directional light and, as discussed earlier in this chapter, it acts like the sun—shining light from high above our terrain. The shadows from our Cucumber Man, Cucumber Beetles, cherries, cherry trees, and cucumber patches can be seen on the grass. We do not need to make any changes to them.</p>
<p>The visual effects changes we will make in this section are:</p>
<ul>
<li>Adding a Point light to our cherry trees</li>
<li>Adding a special effect using the Particle System</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a Point light to our cherry trees</h1>
                
            
            
                
<p>Currently, the Cucumber Man can walk up to and under the cherry trees in our sandbox area. Those trees are very dense and, because the only source of light comes from our directional light, it is too dark for the Cucumber Man to see the cherries he is picking from the tree. This is just simulated for the sake of adding a point light. So, we will use the following steps to add a point light to our cherry trees in the sandbox area of our scene:</p>
<ol>
<li>In Scene view, navigate to a cherry tree and zoom in so that you can see the base of the tree</li>
<li>Using the top menu, select GameObject | Light | Point Light</li>
<li>Relocate the Point Light so that it is at the center of the tree trunk</li>
</ol>
<p> </p>
<ol start="4">
<li>In the Inspector panel, select a Color such as a light red</li>
<li>In the Inspector panel, change the Range to <kbd>11</kbd></li>
<li>In the Inspector panel, increase the Intensity to <kbd>30</kbd></li>
<li>Reposition the point light so that it looks similar to the following image:</li>
</ol>
<div><img height="351" width="563" src="img/01c70dce-f4e4-4ac1-a27d-094ac6884f9e.png"/></div>
<p>Repeat steps 1 through 7 for each cherry tree in your sandbox area. Test your game in game mode to see the results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Add a special effect using the Particle System</h1>
                
            
            
                
<p>In this section, we will add a particle system to our spawn pads so that a special effect is attached to them. Here are the steps:</p>
<ol>
<li>In Scene view, navigate to a spawn pad and zoom in so you can see the pad clearly.</li>
<li>Using the top menu, select GameObject | Effects | Particle System.</li>
<li>Relocate the Particle System so that it is at the center and base of the spawn pad.</li>
</ol>
<p> </p>
<ol start="4">
<li>In the Hierarchy panel, drag the Particle System so that it is subordinate to a spawn pad.</li>
<li>In the Inspector panel, click the settings cog in the Transform component and select Reset. This resets the position of the Particle System to the Transform of the spawn pad.</li>
<li>In the Inspector panel, select a Color that contrasts with the red of the spawn pad and the green of the terrain and cherry tree, such as blue.</li>
<li>In the Inspector panel, change the Max Particles to <kbd>10,000</kbd>.</li>
<li>In the Inspector panel, increase the Shape | Shape to Edge.</li>
<li>In the Inspector panel, increase the Shape | Radius to 1.5.</li>
</ol>
<p>When completed, your Particle System should look similar to the following screenshot:</p>
<div><img height="453" width="172" src="img/8df633b0-a375-41dd-bab2-486c31106a41.png"/></div>
<p>Repeat steps 1 through 9 for each spawn pad in your sandbox area.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we planned and implemented audio and visual effects to enhance the overall gameplay. Specifically, we added audio to key events in our combat system and added lighting and particle special effects. We started with an overview of Unity's Audio System, then planned and implemented our game's audio. We then shifted to an introduction to lights and shadows in Unity and covered selected special effects. We concluded by adding a Point light to our cherry trees and a special effect to our spawn pads.</p>
<p>In <a href="e8407796-3bbd-4f54-bbcc-e1bd89284de5.xhtml" target="_blank">Chapter 13</a>, <em>Optimizing Our Game for Deployment</em>, you will learn how to diagnose performance problems and how to optimize scripts and graphic rendering. You will also learn how to deploy your game to multiple platforms.</p>
<p class="mce-root"/>


            

            
        
    </body></html>