- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Real Unit Testing with Test Doubles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试替身进行真实单元测试
- en: A unit test differentiates itself from other test categories by using **test
    doubles**; actually, you would rarely see a unit test without a test double.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试与其他测试类别不同，因为它使用**测试替身**；实际上，你很少会看到没有测试替身的单元测试。
- en: There is a lot of confusion on the web about what that means. My aim in this
    chapter is to clarify this term so that you can use it in the right context and
    give you as many explained examples of the topic so you feel confident in selecting
    the right test double for the test at hand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网上关于这究竟意味着什么的混淆很多。在本章中，我的目标是澄清这个术语，以便你可以在正确的上下文中使用它，并为你提供尽可能多的关于这个主题的解释示例，让你在选择手头的测试替身时感到自信。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Explain the concepts and usage of test doubles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释测试替身的概念和用法
- en: Discuss more testing categories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论更多测试类别
- en: By the end of the chapter, you will understand what is special about unit testing
    and will be able to use test doubles to start writing realistic unit tests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解单元测试的特殊之处，并将能够使用测试替身开始编写真实的单元测试。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04)'
- en: Understanding and using test doubles
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和使用测试替身
- en: 'You would rarely write a unit test without using a **test double**. Think of
    the term *double* in the same sense as a Hollywood stunt, where a stunt takes
    the place of a real actor in some situations. *Test double* is an umbrella term
    for an object that is used to replace a dependency with a test equivalent (double)
    for the sake of testing a SUT. They are meant to satisfy one or more of the following
    requirements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会编写一个不使用**测试替身**的单元测试。将术语*替身*与好莱坞特技演员在某种情况下取代真实演员的行为视为相同。*测试替身*是一个总称，用于替换依赖项以测试SUT的测试等效物（替身）。它们旨在满足以下一个或多个需求：
- en: '**Requirement 1**: Enable the test code to compile.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求1**：使测试代码能够编译。'
- en: '**Requirement 2**: Eliminate side effects according to the unit test requirements.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求2**：根据单元测试要求消除副作用。'
- en: '**Requirement 3**: Embed a canned (predetermined) behavior that relates somehow
    to the real behavior.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求3**：嵌入与真实行为相关联的（预定）行为。'
- en: '**Requirement 4**: Take a note of and verify the activities that were exerted
    on a dependency within a unit test (we will name this requirement later as *spying*).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求4**：记录并验证在单元测试中对依赖项施加的活动（我们稍后将此需求命名为*间谍活动*）。'
- en: We will be referring to these four conditions when we discuss individual test
    double types, so you may want to bookmark this section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论单个测试替身类型时，我们将参考这四个条件，因此你可能想要将这一节添加到书签中。
- en: 'Do you want your method to call the payment gateway and execute a transaction
    while being unit tested? Do you want to call a third-party API that costs money
    while you are unit testing? Do you even want to go over the HTTP while you are
    testing? *Hint*: You don’t want, and you shouldn’t.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在单元测试时调用支付网关并执行交易吗？你想在单元测试时调用需要付费的第三方API吗？你甚至在测试时想通过HTTP吗？*提示*：你不想，也不应该。
- en: Let’s understand the different types of test doubles that can satisfy the four
    conditions mentioned earlier.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解可以满足前面提到的四个条件的不同类型的测试替身。
- en: Types of test doubles
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试替身的类型
- en: There are five major types of test doubles—each one is meant to satisfy one
    or more of the four requirements mentioned earlier. When unit testing, you may
    use zero or more types of test doubles to satisfy your tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种主要的测试替身类型——每一种都是为了满足前面提到的四个需求之一。在单元测试时，你可以使用零个或多个测试替身类型来满足你的测试。
- en: Next, we will discuss dummies, stubs, mocks, and fakes. These four types of
    test doubles are commonly used with TDD. The fifth type is isolation, which is
    not used with TDD and is only mentioned here for completeness.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论模拟器、存根、模拟和伪造。这四种类型的测试替身通常与TDD一起使用。第五种类型是隔离，它不与TDD一起使用，这里仅为了完整性而提及。
- en: Dummies
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dummies
- en: '`ConvertCToF` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertCToF`方法：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To test the `ConvertCToF`, we have to instantiate a `WeatherForecastController`
    class. The constructor expects multiple objects to be passed in to instantiate
    the controller class: `logger`, `client`, `nowWrapper`, and `randomWrapper`. But
    the `ConvertCToF` is only using `_logger`. Also, we did not want to test the side
    effect of `_logger` as we are testing another behavior. For this reason, we decided
    to use a `NullLogger<>`. We can pass all dummies to our controller, like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `ConvertCToF`，我们必须实例化一个 `WeatherForecastController` 类。构造函数期望传递多个对象以实例化控制器类：`logger`、`client`、`nowWrapper`
    和 `randomWrapper`。但是 `ConvertCToF` 只使用了 `_logger`。此外，我们不想测试 `_logger` 的副作用，因为我们正在测试另一种行为。因此，我们决定使用
    `NullLogger<>`。我们可以像这样将所有虚拟替身传递给我们的控制器：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When `logger` is used, it does nothing, and the other `null` values are just
    passed to make the code compile. In this case, `logger` and the `null` values
    are acting as dummy test doubles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `logger` 时，它什么都不做，其他 `null` 值只是传递过去以使代码编译。在这种情况下，`logger` 和 `null` 值充当了虚拟测试替身。
- en: Creating *intelligent* test doubles when dummies can be used can complicate
    and blur the intention of your unit test, so use dummies when you can.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当可以使用虚拟替身时创建 *智能* 测试替身可能会使单元测试变得复杂并模糊其意图，因此当可能时使用虚拟替身。
- en: Dummies satisfy the first and the second test double requirements that we’ve
    mentioned previously. They allow the code to compile and also create objects that
    do nothing when called.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟替身满足我们之前提到的第一个和第二个测试替身要求。它们允许代码编译，并在调用时创建不执行任何操作的对象。
- en: Stubs
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存根
- en: '`GetReal()` method of the WFA controller:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: WFA 控制器的 `GetReal()` 方法：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are using `_client`, a dependency service, and calling `OneCallAsync` to
    retrieve the weather data from *OpenWeather*. This saves the results in the `res`
    object. `OneCallResponse` is not what we want to return to the `GetReal()` API
    consumer. Instead, we want to present the consumer with a simple output collection
    of the type `WeatherForecast[]`. For this reason, we have a mapping process that
    takes the data coming from `_client.OneCallAsync` and maps it to `WeatherForecast[]`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `_client`，一个依赖服务，并调用 `OneCallAsync` 从 *OpenWeather* 获取天气数据。我们将结果保存在 `res`
    对象中。`OneCallResponse` 不是我们想要返回给 `GetReal()` API 消费者的内容。相反，我们希望向消费者提供一个简单的输出集合，其类型为
    `WeatherForecast[]`。因此，我们有一个映射过程，它将来自 `_client.OneCallAsync` 的数据映射到 `WeatherForecast[]`。
- en: 'In the preceding code, the point that links the mapping process to *OpenWeather*
    is the `OneCallAsync` call:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，将映射过程与 *OpenWeather* 连接起来的点是 `OneCallAsync` 调用：
- en: '![Figure 4.1 – The unit we need to test ](img/Figure_4.1_B18370.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 我们需要测试的单元](img/Figure_4.1_B18370.jpg)'
- en: Figure 4.1 – The unit we need to test
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 我们需要测试的单元
- en: 'We want to swap the implementation of `OneCallAsync` with our own stubbed implementation
    to avoid calling the real RESTful API because the unit that we are testing is
    the mapping business logic. Luckily, we can swap the implementation using *polymorphism*.
    This can be done through implementing `IClient` ourselves by creating a concrete
    class called `ClientStub` and writing our own `OneCallAsync` method. Our final
    design looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用我们自己的存根实现替换 `OneCallAsync` 的实现，以避免调用真实的 RESTful API，因为我们正在测试的是映射业务逻辑。幸运的是，我们可以使用
    *多态* 来替换实现。这可以通过创建一个名为 `ClientStub` 的具体类并编写我们自己的 `OneCallAsync` 方法来实现 `IClient`。我们的最终设计如下：
- en: '![Figure 4.2 – Client and ClientStub implementing IClient ](img/Figure_4.2_B18370.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 客户端和 ClientStub 实现 IClient](img/Figure_4.2_B18370.jpg)'
- en: Figure 4.2 – Client and ClientStub implementing IClient
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 客户端和 ClientStub 实现 IClient
- en: 'Let’s build our stub class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的存根类：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice the following in the preceding code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码中的内容：
- en: '`ClientStub` implements `IClient`, and it should provide an implementation
    for `OneCallAsync` to satisfy the contract.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientStub` 实现 `IClient`，并且它应该为 `OneCallAsync` 提供一个实现以满足契约。'
- en: The constructor allows the user of the class to provide the `DateTime` and the
    seven days temperature.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数允许类的用户提供 `DateTime` 和七天的温度。
- en: The `OneCallAsync` method has a made-up, stubbed implementation that generates
    a `OneCallResponse` return.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneCallAsync` 方法有一个虚构的、存根的实现，它生成一个 `OneCallResponse` 返回值。'
- en: 'Now that we have written the class, we can put it into practice. There are
    several test criteria that we want to test. Here is the first test with the first
    criteria:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了类，我们可以将其付诸实践。我们有几个测试标准想要测试。以下是第一个测试和第一个标准：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that we are deciding what day it is. This is our way of freezing the
    day so that the test can execute anytime. We are also deciding what the weather
    is going to be for the next 7 days, starting from our made-up day. We need to
    do this to be able to instantiate `ClientStub` so that it can respond according
    to these values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在决定今天是哪一天。这是我们冻结日期以便测试可以在任何时间执行的方式。我们也在决定从我们虚构的那一天开始未来7天的天气。我们需要这样做才能实例化
    `ClientStub`，以便它可以根据这些值做出响应。
- en: From the name of the test, which should be structured as `Method_Condition_Expectation`,
    we can figure out what we are trying to do in this test. The weather that we get
    in reality contains 7 days starting from today, but what we return in `WeatherForecast[]`
    is the forecast from the next day onward for the next 5 days. Therefore, we ignore
    today’s weather and use it nowhere.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试名称中，它应该被结构化为 `Method_Condition_Expectation`，我们可以推断出在这个测试中我们试图做什么。现实中我们得到的天气包含从今天开始的7天，但我们在
    `WeatherForecast[]` 中返回的是从下一天开始的未来5天的预报。因此，我们忽略今天的天气，并且没有在任何地方使用它。
- en: The stub has shielded us from reaching to the real weather service and provided
    the canned values that we included in the `Arrange` section. If we were to call
    the real service, we would get unpredictable weather, from a test point of view,
    for unpredictable days (depending on when we run the test), which wouldn’t make
    us able to write our `Assert` criteria.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 存根保护我们免于访问真实的天气服务，并提供了我们在 `Arrange` 部分中包含的预定义值。如果我们调用真实的服务，我们会得到不可预测的天气，从测试的角度来看，对于不可预测的日子（取决于我们何时运行测试），这不会使我们能够编写我们的
    `Assert` 标准。
- en: 'This test is not enough to have good coverage of all the criteria that should
    be tested. You can find more tests for the `GetReal` method using the `ClientStub`
    class in the source code for this chapter in the `WeatherForecastControllerTests`
    class. The tests are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试不足以覆盖所有应该测试的标准。你可以在本章的 `WeatherForecastControllerTests` 类的源代码中找到更多针对 `GetReal`
    方法的测试。这些测试是：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I encourage you to have a look at the companion code to familiarize yourself
    with other examples.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你查看配套代码，以便熟悉其他示例。
- en: Spies
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 间谍
- en: '**Spies** are extra functionality added to a stub class to reveal what happened
    inside the stub. For example, consider this business requirement where we need
    to ensure that we are only passing metric temperature (degrees Celsius) requests
    to *OpenWeather*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**间谍** 是添加到存根类中的额外功能，用于揭示存根内部发生了什么。例如，考虑这个业务需求，我们需要确保我们只向 *OpenWeather* 传递公制温度（摄氏度）请求。'
- en: 'We need to modify our stub to reveal what has been passed to `OneCallAsync`.
    The new code in the stub will look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们的存根以揭示传递给 `OneCallAsync` 的内容。存根中的新代码将看起来像这样：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have added a property called `LastUnitSpy` to store the last requested unit
    and ended it with the `Spy` suffix as a convention. Our unit test will look like
    this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `LastUnitSpy` 的属性来存储最后请求的单位，并以 `Spy` 后缀作为惯例。我们的单元测试将看起来像这样：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that in this test, we did not populate the forecast temperature with
    meaningful values and used default `DateTime`. This emphasized to future test
    readers (other developers reading the code) that we don’t care in this test for
    the variation of these parameters. We just wanted dummy objects to instantiate
    the `clientStub` object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个测试中，我们没有用有意义的值填充预报温度，并使用了默认的 `DateTime`。这强调了对于未来的测试读者（阅读代码的其他开发者）来说，我们在这个测试中不关心这些参数的变化。我们只是想要一些虚拟对象来实例化
    `clientStub` 对象。
- en: The last assert has validated receiving `Units.Metric`, which satisfies our
    business requirement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的断言验证了接收到了 `Units.Metric`，这满足了我们的业务需求。
- en: You can add spies on-demand according to your tests and you can organize them
    in the way you like and hopefully, by now, the idea behind calling it *spy* makes
    sense.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据你的测试按需添加间谍，你可以以你喜欢的任何方式组织它们，并且希望到现在为止，将它们称为 *间谍* 的想法已经变得有意义。
- en: Pros and cons of using stubs
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用存根的优缺点
- en: Using stubs is simple and leads to readable code. Not needing to learn any special
    stubbing framework is also an advantage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存根简单且代码易于阅读。不需要学习任何特殊的存根框架也是一个优点。
- en: The problem with stubbing is that the more sophisticated your scenarios are,
    the more stub classes you need (`ClientStub2` and `ClientStub3`) or the cleverer
    your stub implementation needs to be. Your stub should contain minimal *cleverness*
    and business logic. In real-life scenarios, your stubs will be chunky and harder
    to maintain if you and your team are not careful about maintaining them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存根的问题在于，你的场景越复杂，你需要更多的存根类（如 `ClientStub2` 和 `ClientStub3`），或者你的存根实现需要更加巧妙。你的存根应该包含最小的
    *巧妙性* 和业务逻辑。在现实场景中，如果你和你的团队不仔细维护，你的存根将会变得庞大且难以维护。
- en: Recap of the previous scenario
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 上一个场景的回顾
- en: 'We have followed these steps to unit test the `GetReal()` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循以下步骤对 `GetReal()` 方法进行单元测试：
- en: We realized that `_client` is a dependency used by our SUT.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们意识到 `_client` 是我们 SUT（系统单元）使用的依赖项。
- en: We want to isolate our `GetReal` method from calling the real OpenWeather, so
    we need to provide an alternative behavior for `_client`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望将 `GetReal` 方法与调用真实的 OpenWeather 服务隔离，因此我们需要为 `_client` 提供一种替代行为。
- en: '`_client` is an object of a class that implements the `IClient` interface.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_client` 是实现 `IClient` 接口的一个类的对象。'
- en: At runtime, the SUT is instantiated by the start up class. `Client`, which is
    provided by a third-party library, is passed to SUT. This `Client`, which implements
    `IClient`, provides a means for retrieving the real weather data from *OpenWeather*.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，SUT（系统单元）是由启动类实例化的。由第三方库提供的 `Client` 被传递给 SUT。这个实现了 `IClient` 的 `Client`
    提供了一种从 *OpenWeather* 获取真实天气数据的方式。
- en: Unit testing should not extend the test to a third party and should restrict
    the test to the SUT.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试不应该扩展到第三方，而应该限制在 SUT 上。
- en: To bypass calling the real service, we stubbed a class and called it `ClientStub`,
    and implemented `IClient`. `ClientStub` contains an implementation to generate
    made-up weather data.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了绕过调用真实服务，我们模拟了一个类，并将其命名为 `ClientStub`，并实现了 `IClient`。`ClientStub` 包含了一个生成虚构天气数据的实现。
- en: We wrote our unit test following the unit test name convention and the AAA structure.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们按照单元测试的命名规范和 AAA 结构编写了我们的单元测试。
- en: Our SUT constructor requires an instance of `IClient`, so we passed `ClientStub`
    to it.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们 SUT 构造函数需要一个 `IClient` 的实例，因此我们向其中传递了 `ClientStub`。
- en: We can now test our SUT.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的 SUT（系统单元）。
- en: Stubs satisfy the first three test double requirements of those we stated previously.
    Also, with the help of spies, they satisfy the fourth requirement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 存根满足了我们之前提到的那些测试替身的前三个要求。此外，借助间谍（spies）的帮助，它们还满足了第四个要求。
- en: The same stubbing process is used for the rest of the unit tests for the GetReal
    method. Some teams use stubs as the main type of test doubles and other teams
    prefer to use mocks, which naturally leads us to our next topic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GetReal` 方法的其余单元测试，使用了相同的存根过程。一些团队使用存根作为主要的测试替身类型，而其他团队则更喜欢使用模拟，这自然引出了我们下一个话题。
- en: Mocks
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟
- en: '**Mocks** have great similarities with stubs, but rather than having the implementation
    of stubs done in regular coding, they use a *trick* to generate a behavior without
    having to implement a complete class. Mocks use third-party libraries to reduce
    the amount of coding involved to create a test double.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**与存根有很强的相似性，但它们不是在常规编码中实现存根的实现，而是使用一种 *技巧* 来生成行为，而不需要实现一个完整的类。模拟使用第三方库来减少创建测试替身所需的编码量。'
- en: Mocking libraries
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟库
- en: With mocks, you have to use a third-party library or build your own—heaven forbid.
    Two popular libraries for .NET are **Moq** (pronounced *mock you*) and **NSubstitute**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟（mocks），你必须使用第三方库或者自己构建——但愿不要这样。对于 .NET，有两个流行的库是 **Moq**（发音为 *mock you*）和
    **NSubstitute**。
- en: Moq started gaining popularity in 2010\. It relies heavily on lambda expressions,
    which made it less verbose compared to its peers at that time. If you like lambda
    expressions, then Moq is for you.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moq 从 2010 年开始流行起来。它大量依赖于 lambda 表达式，这使得它在当时比同行更简洁。如果你喜欢 lambda 表达式，那么 Moq 就是你的选择。
- en: NSubstitute was also released near Moq time. Its focus is to provide a readable
    syntax for mocking.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSubstitute 也在 Moq 附近发布。它的重点是提供可读的模拟语法。
- en: Both libraries are mature in features and have a great online community. This
    book will use *NSubstitute*, but will also give you a quick introduction to Moq
    in the appendix.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库在功能上都很成熟，并且拥有庞大的在线社区。本书将使用 *NSubstitute*，但也会在附录中快速介绍 Moq。
- en: 'To install NSubstitute, you can go to the unit test project directory and execute
    the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 NSubstitute，你可以进入单元测试项目目录并执行以下代码：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second line is optional. It adds the C# NSubstitute analyzers, which uses
    Roslyn to add code analysis during compilation to detect possible errors. Also,
    it adds the capability for VS to give you hints to improve your mocks code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是可选的。它添加了C# NSubstitute分析器，该分析器使用Roslyn在编译期间添加代码分析，以检测可能的错误。它还添加了VS为你提供改进模拟代码提示的能力。
- en: You now have the NSubstitute library installed and ready to use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经安装并准备好使用NSubstitute库了。
- en: Example using mocks
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模拟的示例
- en: 'Mocks and stubs can be used interchangeably, so a good way of understanding
    them is to start from our previous stub implementation. Let’s take the same example
    that we used in the stubs, which is testing `GetReal`. In that example, we used
    stubbing as our test double. Now, we use mocking, so we take the same test above
    and replace the `Arrange` part with this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和存根可以互换使用，因此理解它们的一个好方法是从我们之前的存根实现开始。让我们以我们在存根中使用的相同示例为例，即测试`GetReal`。在那个例子中，我们使用存根作为测试替身。现在，我们使用模拟，所以我们取上面的相同测试，并将`Arrange`部分替换为以下内容：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When using stubs, we coded an entire class so that we can instantiate it, as
    you can see in the commented line. In mocking the magical method from NSubstitute,
    `Substitute.For` created a concrete class from `IClient` and instantiated it all
    in one simple line.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用存根时，我们编写了一个完整的类，以便我们可以实例化它，正如你可以在注释行中看到的那样。在模拟中，NSubstitute的神奇方法`Substitute.For`从`IClient`创建了一个具体类，并在一行中完成了实例化。
- en: 'However, the created object, `clientMock`, does not have any implementation
    for the `OneCallAsync`, so we have used NSubstitute methods to say: whichever
    parameter (`Is.Any<>`), that is passed to the `OneCallAsync` method, `Return`
    what is described in the provided lambda. The lambda content is the same content
    that was used in the `ClientStub` before.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建的对象`clientMock`没有为`OneCallAsync`提供任何实现，因此我们使用了NSubstitute方法来说明：无论传递给`OneCallAsync`方法的参数（`Is.Any<>`）是什么，都返回在提供的lambda中描述的内容。lambda的内容与之前在`ClientStub`中使用的内容相同。
- en: We have dynamically attached a method implementation to an object that we just
    created with a couple of lines of code. This is pretty impressive and has less
    code than its previous stub counterpart. Mocking libraries have the ability to
    create a concrete implementation of an abstraction and, in advanced scenarios,
    they can mock concrete classes and substitute part of their implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅用几行代码就动态地将一个方法实现附加到了我们刚刚创建的对象上。这相当令人印象深刻，并且比之前的存根对应物代码更少。模拟库有创建抽象的具体实现的能力，在高级场景中，它们可以模拟具体类并替换其部分实现。
- en: Of course, if you are using mocking, the `ClientStub` stubbing class that we
    used in the stubbing example is not needed. You only pick one or the other.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你正在使用模拟，那么在模拟示例中我们使用的`ClientStub`模拟类就不再需要了。你只需选择其中一个即可。
- en: I have created a test class called `WeatherForecastControllerTestsWithMocking`
    to differentiate from the one that uses a stub. In a real-life project, you wouldn’t
    do that as you will be typically using stubbing or mocking. This chapter and *Part
    2*, *Building an Application with TDD*, will have dozens of examples that use
    mocks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了一个名为`WeatherForecastControllerTestsWithMocking`的测试类，以区别于使用存根的那个。在实际项目中，你通常不会这样做，因为你将典型地使用存根或模拟。本章和*第2部分*，*使用TDD构建应用程序*，将包含数十个使用模拟的示例。
- en: Spies
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 间谍
- en: 'When it comes to mocking, we rarely use the term *spy* because the spy functionality
    is always embedded in the mocking framework. Spying in stubs is something you
    need to code, while for mocks, spying is built in. To illustrate this, it’s best
    to take the spying-with-a-stub example that we presented earlier and make it spying
    with mock:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到模拟时，我们很少使用术语*间谍*，因为间谍功能始终嵌入在模拟框架中。在存根中进行间谍活动是需要你编写的，而对于模拟，间谍功能是内置的。为了说明这一点，最好的方法是拿我们之前提供的带有存根的间谍示例，并将其改为使用模拟：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Arrange` and `Act` sections have not changed; we are only ignoring the
    output of the act stage. What has changed is our assertion. NSubstitute provides
    a method to spy on the passed parameters called `Received` and combines it with
    `Arg.Is` to verify what was passed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrange`和`Act`部分没有变化；我们只是忽略了`Act`阶段的输出。变化的是我们的断言。NSubstitute提供了一个名为`Received`的方法来监视传递的参数，并将其与`Arg.Is`结合，以验证传递了什么。'
- en: This is the first example where the `Assert` section does not use xUnit’s `Assert`
    class. This is perfectly legal, as the `Received()` method is an assertion method
    itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个`Assert`部分没有使用xUnit的`Assert`类的示例。这是完全合法的，因为`Received()`方法本身就是一个断言方法。
- en: Pros and cons of using mocks
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模拟的优缺点
- en: Mocks produce succinct code. They are slightly harder to read than plain code
    (code without a mocking library) if we compare them to stubs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象生成的代码简洁。如果我们把它们与存根比较，它们比普通代码（没有模拟库的代码）稍微难读一些。
- en: The drawback of mocks is that you depend on a library such as NSubstitute, and
    there is a learning curve associated with that. Also, some practitioners don’t
    like the magic that mock libraries employ to attach behavior dynamically and prefer
    to keep things more obvious by using plain code (stubs).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象的缺点是，你依赖于像NSubstitute这样的库，并且与这个库相关的学习曲线。此外，一些实践者不喜欢模拟库用来动态附加行为的魔法，他们更愿意通过使用普通代码（存根）来使事情更明显。
- en: Next, I summarize the differences between mocks and stubs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将总结模拟对象和存根之间的区别。
- en: Mocks versus stubs
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟对象与存根的比较
- en: 'The difference between mocks and stubs is important, as you need to be armed
    with logic to choose the best technique to suit you. Here is a quick list of differences:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象和存根之间的区别很重要，因为你需要具备逻辑来选择最适合你的最佳技术。以下是一个快速的区别列表：
- en: Both mocks and stubs are categorized as test doubles, and you can use one or
    the other in your project based on the project requirements or the team preference,
    although in the industry, mocks are used more often than stubs.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象和存根都被归类为测试替身，你可以根据项目需求或团队偏好选择使用其中之一，尽管在业界，模拟对象的使用频率比存根高。
- en: Mocks are implemented with the help of a third-party library such as Moq or
    NSubstitute, while stubs do not rely on a library.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象是通过像Moq或NSubstitute这样的第三方库实现的，而存根则不依赖于库。
- en: Mocks are less verbose than stubs, but their syntax is slightly harder to read
    than plain code.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象比存根更简洁，但它们的语法比普通代码稍微难读一些。
- en: Mocks are claimed to do some magic, which some practitioners believe corrupts
    the unit test, while stubs are plain code with no magic.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象被认为具有一些魔法，一些实践者认为这会破坏单元测试，而存根则是没有魔法的普通代码。
- en: Important Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The difference between mocks and stubs is a popular interview question. It is
    also important to expand on the answer and mention that both are test double types
    and are mainly used with unit testing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象和存根之间的区别是一个流行的面试问题。同时，也很重要扩展答案并提到它们都是测试替身类型，主要用于单元测试。
- en: Recap of the previous scenario
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 上一个场景的回顾
- en: To recap, we had the same scenario as of the stub, but when stubbing, we have
    added a class to contain our stub and used it in the unit test. In mocking, we
    have used a mocking framework that facilitated including our implementation within
    the body of the unit test.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们与存根有相同的场景，但在存根时，我们添加了一个类来包含我们的存根，并在单元测试中使用它。在模拟中，我们使用了模拟框架，它促进了在单元测试体中包含我们的实现。
- en: Mocks satisfy all test double requirements that we stated above. I hope the
    previous examples have given you a flavor of mocking. Next, we will explore another
    test double type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象满足了我们上面所提到的所有测试替身的要求。我希望之前的例子已经让你对模拟有了初步的了解。接下来，我们将探讨另一种测试替身类型。
- en: Fakes
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存根
- en: '**Fakes** are libraries that mimic part or all of a real-life equivalent, and
    they exist in order to facilitate testing.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**存根**是模仿现实生活等效部分或全部的库，它们的存在是为了方便测试。'
- en: Important Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The term *fake* has multiple definitions in the industry. This chapter is using
    the definition by Martin Fowler ([https://martinfowler.com/bliki/TestDouble.xhtml](https://martinfowler.com/bliki/TestDouble.xhtml)),
    as follows: “*Fake objects actually have working implementations, but usually
    take some shortcut which makes them not suitable for production (an InMemoryTestDatabase
    is a good example).*”'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: “存根”这个术语在业界有多个定义。本章使用Martin Fowler的定义（[https://martinfowler.com/bliki/TestDouble.xhtml](https://martinfowler.com/bliki/TestDouble.xhtml)），如下：“*存根对象实际上有工作实现，但通常采取一些捷径，使得它们不适合生产（内存测试数据库是一个很好的例子）。*”
- en: One confusing name is a .NETframework called Microsoft Fakes that does isolation!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个令人困惑的名称是.NET框架中的Microsoft Fakes，它实现了隔离！
- en: One of the most popular examples library called **FakeItEasy** that does mocks.
    Also, Microsoft has a framework called Microsoft Fakes that does isolation!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的示例库之一是**FakeItEasy**，它实现了模拟。此外，微软有一个名为Microsoft Fakes的框架，它实现了隔离！
- en: 'One of the most popular examples of a fake within the .NET library is *Entity
    Framework Core In-Memory Database Provider*. This is a quote from the Microsoft
    documentation ([https://docs.microsoft.com/en-us/ef/core/providers/in-memory](https://docs.microsoft.com/en-us/ef/core/providers/in-memory)):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 库中最受欢迎的模拟对象示例之一是 *Entity Framework Core 内存数据库提供者*。这是来自微软文档的引用（[https://docs.microsoft.com/en-us/ef/core/providers/in-memory](https://docs.microsoft.com/en-us/ef/core/providers/in-memory)）：
- en: '*This database provider allows Entity Framework Core to be used with an in-memory
    database. The in-memory database can be useful for testing, […]. The in-memory
    database is designed for testing only*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*此数据库提供者允许 Entity Framework Core 使用内存数据库。内存数据库对于测试很有用，……。内存数据库仅设计用于测试*。'
- en: When storing in memory, it is easy to wipe and recreate the storage while executing
    every individual unit test. That helps in repeating the tests without worrying
    about the changed state of the data. Although, if the storage was persisted on
    disk, say with a real database (SQL Server, Cosmos, Mongo or others), then resetting
    the data before every test is not a simple task. The volatile nature of an in-memory
    database is suitable for unit testing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中存储时，在执行每个单独的单元测试时很容易擦除和重新创建存储。这有助于在不担心数据状态变化的情况下重复测试。尽管如此，如果存储在磁盘上，例如使用真实的数据库（SQL
    Server、Cosmos、Mongo 或其他），则在每次测试之前重置数据并不是一个简单的任务。内存数据库的易失性特性非常适合单元测试。
- en: If *Test A* changed a username from `JohnDoe` to `JohnSmith` and *Test B* tried
    to change `JohnDoe` to `JaneSmith`, *Test B* will definitely fail if the changes
    that *Test A* had done were permanent (persisted to a physical disk database).
    Using a volatile in-memory database can make resetting the data easier in between
    every test. This is an important unit test principle known as **No Interdependency**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *测试 A* 将用户名从 `JohnDoe` 更改为 `JohnSmith`，而 *测试 B* 尝试将 `JohnDoe` 更改为 `JaneSmith`，如果
    *测试 A* 所做的更改是永久的（持久到物理磁盘数据库），则 *测试 B* 一定会失败。使用易失性内存数据库可以在每次测试之间更容易地重置数据。这是一个重要的单元测试原则，称为
    **无依赖性**。
- en: 'Fakes are meant to help provide an implementation of a complex system to try
    to make your unit tests more realistic. If you have a system that uses a relational
    database and relies on EF Core, then the previous provider might help when unit
    testing:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象旨在帮助提供一个复杂系统的实现，以尝试使你的单元测试更加真实。如果你有一个使用关系型数据库并依赖于 EF Core 的系统，那么之前的提供者可能在单元测试时有所帮助：
- en: '![Figure 4.3 – In-memory storage versus production storage ](img/Figure_4.3_B18370.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 内存存储与生产存储](img/Figure_4.3_B18370.jpg)'
- en: Figure 4.3 – In-memory storage versus production storage
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 内存存储与生产存储对比
- en: Fakes satisfy the first three test double requirements of those we stated earlier.
    If fakes were to embed spying behavior, they would satisfy the fourth requirement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象满足了我们之前提到的那些测试替身的前三个要求。如果模拟对象嵌入监视行为，它们将满足第四个要求。
- en: In *Part 2*, *Building an Application with TDD*, we will be using this provider
    and we will show the usage of fakes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 2 部分*，*使用 TDD 构建应用程序* 中，我们将使用此提供者，并展示模拟对象的使用。
- en: Isolation
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离
- en: '**Isolation** is not something you do with TDD, but I have added a limited
    introduction here for completeness. Isolation bypasses traditional DI all together
    and uses a different technique for DI known as **shim**. Shim involves modifying
    compiled code behavior at runtime for injection.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**隔离**不是你在 TDD 中做的事情，但我为了完整性在此添加了有限的介绍。隔离完全绕过传统的依赖注入，并使用一种称为 **shim** 的不同依赖注入技术。Shim
    涉及在运行时修改编译代码的行为以进行注入。'
- en: 'Owing to the complexity of the functionality of isolation frameworks, there
    aren’t many of them in .NET. Here are possibly the only two frameworks available
    for .NET **Core**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隔离框架的功能复杂，.NET 中这样的框架并不多。以下是可能仅有的两个可用于 .NET **Core** 的框架：
- en: '**Microsoft Fakes**: Available with the Enterprise version of Visual Studio'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Fakes**：随 Visual Studio 企业版提供'
- en: '**Telerik JustMock**: A third-party commercial tool. It also has an open source
    restricted implementation called **JustMock Lite**.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Telerik JustMock**：一个第三方商业工具。它还有一个名为 **JustMock Lite** 的开源受限实现。'
- en: I am unaware of a fully-featured isolation library that has a permissive, or
    free, license for .NET 5 and above.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道有一个功能齐全的隔离库具有针对 .NET 5 及以上版本的许可，且许可为宽松的或免费的。
- en: Isolation frameworks are primarily used to unit test legacy systems, where you
    cannot change the production code to support DI. Therefore, the isolation framework
    injects the dependencies into the SUT at runtime. The reason they are not used
    with TDD is that TDD is about adding tests while gradually *modifying* production
    code, but isolation is not meant to modify the production code. Despite the fact
    you can use isolation frameworks to unit test greenfield projects, they are not
    the best tools for the job.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离框架主要用于单元测试遗留系统，在这些系统中，你无法更改生产代码以支持依赖注入。因此，隔离框架在运行时将依赖项注入到SUT中。它们不用于TDD的原因是，TDD是关于在逐渐*修改*生产代码的同时添加测试，而隔离并不是为了修改生产代码。尽管你可以使用隔离框架来对绿色地带项目进行单元测试，但它们并不是这项工作的最佳工具。
- en: Although isolation frameworks exist to target legacy code, I don’t believe that
    applying unit tests to code that cannot change is the best use of a team’s time.
    I cover this in more detail in [*Chapter 12*](B18370_12.xhtml#_idTextAnchor279),
    *Dealing with Brownfield Projects*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在隔离框架来针对遗留代码，但我认为将单元测试应用于无法更改的代码并不是团队时间最佳的使用方式。我在[*第12章*](B18370_12.xhtml#_idTextAnchor279)《处理棕色地带项目》中对此进行了更详细的介绍。
- en: What should I use for TDD?
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该使用什么来进行TDD？
- en: Let’s start with the process of elimination. Isolation and isolation frameworks
    may not be used in the context of TDD as they are incompatible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从排除法开始。隔离和隔离框架在TDD的上下文中可能不会被使用，因为它们是不兼容的。
- en: Dummies can coexist with all types of test doubles. Using a `NullLogger<>` service
    where the logger is not used or passing null arguments is going to happen in most
    of your unit tests. So, use a dummy when you can; in fact, using dummies should
    take precedence over other types if this is possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符可以与所有类型的测试替身共存。在大多数单元测试中使用`NullLogger<>`服务（其中日志记录器未被使用）或传递null参数的情况将会发生。因此，当你能够使用占位符时，请使用它；实际上，如果可能的话，使用占位符应该优先于其他类型。
- en: Teams usually use mocks or stubs, but not both unless the project is in a transitional
    state from one to the other. The debate of which one is better cannot be resolved
    in this book, it is all over the internet. However, given that stubs are harder
    to maintain and they need to be built up manually, mocks can do better as a start.
    Begin with mocks, get experienced, and then you can decide whether stubs can serve
    you better.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 团队通常使用模拟或存根，但除非项目处于从一种状态过渡到另一种状态的过程中，否则不会同时使用两者。关于哪个更好的争论无法在本书中解决，它遍布整个互联网。然而，鉴于存根更难维护并且需要手动构建，模拟可以作为起点做得更好。从模拟开始，积累经验，然后你可以决定存根是否更适合你。
- en: Finding appropriate fakes is a hit and miss. Sometimes, you can find a well-implemented
    fake such as the EF Core In-Memory Database Provider, and sometimes you might
    find an open source fake for some popular system. Sometimes, you may be unfortunate
    and have to create one yourself. But fakes are used in conjunction with mocks
    or stubs; as we will see in *Part 2* of the book, they are not one or the other.
    They add value to your tests, and you need to decide when to use them on a case-by-case
    basis.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找合适的模拟对象往往是一种试错的过程。有时，你可以找到一个实现良好的模拟对象，比如 EF Core 内存数据库提供者，有时你可能会找到一个开源的模拟对象用于某些流行的系统。有时，你可能不幸，不得不自己创建一个。但是，模拟对象通常与模拟或存根一起使用；正如我们在本书的*第2部分*中将要看到的，它们不是单独使用一个或另一个。它们为你的测试增加了价值，你需要根据具体情况决定何时使用它们。
- en: '*In summary, for any object that should not be part of the SUT or for an unused
    dependency, use a dummy. To build and test dependencies, use mocks. Add fakes
    where it makes sense.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*总之，对于不应成为SUT（系统单元测试）一部分的对象或未使用的依赖项，使用占位符。为了构建和测试依赖项，使用模拟。在合适的地方添加模拟对象*。'
- en: The meaning of stubs, mocks, and fakes will vary, and the definitions are muddled.
    I have tried to use the most common terminology in the industry. What is important
    is understanding all the test double options that we can use and using them appropriately.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 存根、模拟和模拟对象的意义可能会有所不同，定义也模糊不清。我尽量使用了行业中最常见的术语。重要的是理解我们可以使用的所有测试替身选项，并适当地使用它们。
- en: Test doubles are what make unit testing different from other categories. This
    can be clarified further when we discuss other testing categories to better understand
    the uniqueness of unit testing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身是使单元测试与其他测试类别不同的因素。当我们讨论其他测试类别以更好地理解单元测试的独特性时，这一点可以进一步阐明。
- en: More testing categories
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多测试类别
- en: You’ve probably heard about plenty of testing categories other than unit testing.
    There is **integration testing**, **regression testing**, **automation testing**,
    **load testing**, **pen testing**, **component testing**—and the list goes on.
    Well, we won’t cover all these test categories, as explaining them all will not
    fit in this book. What we will do instead is discuss the two categories that have
    commonalities with unit testing. The first one is **integration testing** and
    the second one is what I call **Sintegration testing**. We will also have an honorable
    mention of **acceptance testing** due to its importance in building a full test
    categories suite.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过很多除了单元测试之外的测试类别。有 **集成测试**、**回归测试**、**自动化测试**、**负载测试**、**渗透测试**、**组件测试**——等等，清单还可以继续。好吧，我们不会涵盖所有这些测试类别，因为解释它们所有内容将不适合这本书。我们将要做的是讨论与单元测试有共同之处的两个类别。第一个是
    **集成测试**，第二个是我称之为 **S集成测试** 的测试。我们还将对 **验收测试** 表示敬意，因为它在构建完整的测试类别套件中非常重要。
- en: Unit testing, integration testing, and Sintegration testing have one major difference
    that sets them apart. It is how they deal with dependencies. Understanding the
    differences will help clarify how unit testing fits into the test ecosystem.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试、集成测试和S集成测试之间有一个主要区别，那就是它们处理依赖关系的方式。了解这些区别将有助于阐明单元测试如何在测试生态系统中定位。
- en: Integration testing
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is, fortunately, easy to understand. It is exactly like
    a unit test, but with real dependencies, not with test doubles. An integration
    test executes an endpoint, such as a method or an API, which will trigger all
    the real dependencies, including external systems such as a DB and tests the outcome
    against a criterion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，集成测试很容易理解。它就像单元测试一样，但使用的是真实依赖项，而不是测试替身。集成测试执行一个端点，例如一个方法或 API，这将触发所有真实依赖项，包括外部系统，如数据库，并针对标准测试结果。
- en: Example
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'The xUnit framework can also execute integration and Sintegration tests, so
    to show an example, we can create an integration test project in the same way
    we created a unit test project. From your console, go to your solution directory
    and execute the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit 框架也可以执行集成和 S集成测试，所以为了展示一个例子，我们可以以创建单元测试项目相同的方式创建一个集成测试项目。从你的控制台，进入你的解决方案目录，并执行以下操作：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have just created an integration test project using the *xUnit framework*
    and added it to our solution. Our integration test will be going over HTTP and
    will be deserializing the JSON values, so we will need to do this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个使用 *xUnit 框架* 的集成测试项目，并将其添加到我们的解决方案中。我们的集成测试将通过 HTTP 进行，并将反序列化 JSON
    值，因此我们需要这样做：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will add the .NET JSON NuGet package to your Integration test.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你的集成测试添加 .NET JSON NuGet 包。
- en: Important Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice that the integration test project is not referencing `Uqs.Weather`. This
    is because the integration test project will trigger the RESTful API through HTTP
    and does not need to use any type from `Uqs.Weather`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到集成测试项目没有引用 `Uqs.Weather`。这是因为集成测试项目将通过 HTTP 触发 RESTful API，不需要使用 `Uqs.Weather`
    中的任何类型。
- en: 'In this example, we want to test getting 5 days, starting from the next day:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要测试从第二天开始获取 5 天：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On the class level, we add these fields. They specify the address of the service,
    which is pointing to my local machine, and also specify the URI of the SUT. By
    looking at the `WeatherForecast` class from `Uqs.Weather`, I know that I am getting
    back an array of `WeatherForecast` of five fields. So, I have constructed a similar
    record to the expected data that will come from the RESTful API call.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在类级别上，我们添加这些字段。它们指定了服务的地址，指向我的本地机器，并指定了 SUT 的 URI。通过查看 `Uqs.Weather` 中的 `WeatherForecast`
    类，我知道我正在返回一个包含五个字段的 `WeatherForecast` 数组。因此，我构建了一个与从 RESTful API 调用中预期返回的数据相似的记录。
- en: 'My integration test looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我的集成测试看起来像这样：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We don’t know on which day the test is going to execute, so we are fetching
    today’s date and then calculating the dates of the next 5 days. We are creating
    and setting up an `HttpClient` to issue an HTTP call.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道测试将在哪一天执行，所以我们正在获取今天的日期，然后计算出接下来 5 天的日期。我们正在创建和设置一个 `HttpClient` 来发起 HTTP
    请求。
- en: In `Act`, we are calling the RESTful API’s endpoint.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Act` 中，我们正在调用 RESTful API 的端点。
- en: In `Assert`, we are converting the returned value from JSON to the `record`
    class that we created earlier and checking that we are getting the next 5 days.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assert` 中，我们将从 JSON 返回的值转换为之前创建的 `record` 类，并检查我们是否得到了接下来的 5 天。
- en: This test requires a different setup to run than the way we were running unit
    tests before. This is an out-of-process test, which means that the API is running
    on one process and the test is running on another process. The two processes are
    communicating with each other via HTTP. So, to run this test, we first need to
    initiate the REST API process. Right-click on **Uqs.Weather** | **Debug** | **Start
    Without Debugging**. Then this will launch Kestrel web server in a console window
    and make our API ready for an HTTP call.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试需要与之前运行单元测试的方式不同的设置来运行。这是一个进程外测试，这意味着API在一个进程中运行，而测试在另一个进程中运行。这两个进程通过HTTP相互通信。因此，要运行这个测试，我们首先需要启动REST
    API进程。右键单击**Uqs.Weather** | **调试** | **不调试启动**。然后这将在控制台窗口中启动Kestrel web服务器，并使我们的API准备好进行HTTP调用。
- en: Now, you can go ahead and execute the integration test in a similar fashion
    to executing unit tests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像执行单元测试一样执行集成测试。
- en: Activities triggered by this test
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 由这个测试触发的活动
- en: 'The API call that we have just executed in our integration test triggered multiple
    dependencies to generate the output. These are a few of the triggered dependencies:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在集成测试中刚刚执行的API调用触发了多个依赖项以生成输出。以下是触发的一些依赖项：
- en: The network, including the HTTPS connection, between the integration test and
    the ASP.NET Web API host
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试和ASP.NET Web API宿主之间的网络，包括HTTPS连接
- en: The ASP.NET Web API host, which spun a process and displayed in a console window
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动并显示在控制台窗口中的ASP.NET Web API宿主进程
- en: The routing code that analyzed the request and spun the right action method
    in the controller
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析请求并在控制器中触发正确操作方法的路由代码
- en: The DI container that decided which object to create and inject
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定创建和注入哪个对象的DI容器
- en: The HTTPS connection between `Uqs.Weather` and the *OpenWeather* API
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uqs.Weather`和*OpenWeather* API之间的HTTPS连接'
- en: 'We know that each of these dependencies works on its own. By executing this
    test, we made sure that all our components are integrated and work well together.
    The following diagram shows a hint of what happened when we executed the test:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道每个依赖项都能独立工作。通过执行这个测试，我们确保了所有组件都已集成并且能良好地协同工作。以下图表显示了执行测试时发生的一些情况：
- en: '![Figure 4.4 – Request/response going through the dependencies ](img/Figure_4.4_B18370.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 请求/响应通过依赖项](img/Figure_4.4_B18370.jpg)'
- en: Figure 4.4 – Request/response going through the dependencies
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 请求/响应通过依赖项
- en: These are not all the components, as I have missed some, but hopefully, you’ve
    got the idea.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是所有组件，因为我遗漏了一些，但希望你能理解这个概念。
- en: Points to note
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'This is our first integration test in this book (and the last one), and I would
    like to point out the differences between this test and its unit test equivalent:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中的第一个（也是最后一个）集成测试，我想指出这个测试与其单元测试等价物的区别：
- en: We do not know the day in advance—we have to determine the date dynamically,
    while in our unit test, we had a pre-configured day in the `Assert` section.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法提前知道日期——我们必须动态确定日期，而我们的单元测试中在`Assert`部分有一个预配置的日期。
- en: There are no test doubles, and everything is executing the real objects.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有测试替身，所有东西都在执行真实对象。
- en: We had two processes running; one is the web server that hosts the API, and
    the other is our integration test. Unit tests were calling directly, in-process.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们运行了两个进程；一个是托管API的web服务器，另一个是我们的集成测试。单元测试是直接、进程内调用的。
- en: 'There is a probability of failure that is not related to the test. The test
    could fail due to:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一种与测试无关的失败概率。测试可能会因为以下原因而失败：
- en: Firewall issues
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙问题
- en: The *OpenWeather* service is down
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenWeather*服务已关闭'
- en: Exceeding the number of calls permitted by our *OpenWeather* license
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出了我们*OpenWeather*许可证允许的调用次数
- en: ASP.NET Web server has not started
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Web服务器尚未启动
- en: The routing module is not configured properly
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由模块配置不正确
- en: Other environmental issues
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他环境问题
- en: This test, while not measured, will take a longer time as it is communicating
    between two processes, hitting multiple components, and then going over HTTPS,
    which includes serialization/deserialization and encryption/decryption. Although
    the execution time is unnoticeable, having 10 seconds of integration tests will
    add up.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个测试虽然未进行测量，但因为它需要在两个进程之间进行通信，击中多个组件，然后通过HTTPS进行，这包括序列化/反序列化和加密/解密，所以它将花费更长的时间。尽管执行时间不明显，但10秒的集成测试时间也会累积。
- en: Unit testing versus integration testing
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试与集成测试
- en: Integration tests and unit tests are great tools, and comparing them might imply
    using one over the other. This is not the case as both complement each other.
    Integration testing is good at testing a full cycle call, while unit testing is
    good at testing various scenarios of business logic. They have separate roles
    in quality assurance; the problem arises if they step on each other’s toes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和单元测试是优秀的工具，比较它们可能意味着使用其中一个而不是另一个。事实并非如此，因为它们是互补的。集成测试擅长测试完整周期的调用，而单元测试擅长测试业务逻辑的各种场景。它们在质量保证中扮演着不同的角色；问题出现在它们相互干扰时。
- en: Important Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The difference between unit and integration testing is a common interview question
    that allows the interviewer to assess whether the candidate understands dependency
    management, test doubles, unit testing, and integration testing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试与集成测试的区别是常见的面试问题，这允许面试官评估候选人是否理解依赖管理、测试替身、单元测试和集成测试。
- en: Advantages of integration tests over unit tests
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成测试相对于单元测试的优势
- en: 'Here are the advantages that might lead us to use integration tests over unit
    tests:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些优势可能会让我们选择使用集成测试而不是单元测试：
- en: Integration tests check the real behavior that mimics what the end client might
    do, while unit tests check what the developer thinks the system should do.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试检查的是真实的行为，这模仿了最终用户可能执行的操作，而单元测试检查的是开发者认为系统应该执行的操作。
- en: Integration tests are easier to write and understand as they are regular code
    that doesn’t use test doubles and doesn’t care about DI.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试更容易编写和理解，因为它们是常规代码，不使用测试替身，也不关心依赖注入（DI）。
- en: Integration tests can cover scenarios that unit tests cannot cover efficiently,
    such as the integration between the components of the whole system and DI container
    registration.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试可以覆盖单元测试无法高效覆盖的场景，例如整个系统组件之间的集成以及DI容器注册。
- en: Integration tests can be applied to legacy systems or greenfield systems. In
    fact, integration tests are one of the recommended ways to test legacy systems,
    while unit tests require code refactoring to be introduced into brownfield projects.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试可以应用于遗留系统或绿色系统。事实上，集成测试是测试遗留系统的一种推荐方法，而单元测试需要代码重构才能引入到棕色项目中。
- en: Some integration tests, like the example above, can be written in a language-agnostic
    way. So, the previous test could have been written in F#, Java, or Python, or
    by a tool such as Postman, while unit tests use the same language as the production
    code (C#, in our case).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些集成测试，如上面的例子，可以以语言无关的方式编写。因此，之前的测试可以是用F#、Java或Python编写的，或者由Postman等工具编写，而单元测试使用与生产代码相同的语言（在我们的例子中是C#）。
- en: Advantages of unit tests over integration tests
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试相对于集成测试的优势
- en: 'Here are some advantages that might lead us to use unit over integration tests:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些优势可能会让我们选择使用单元测试而不是集成测试：
- en: Unit tests are much faster to execute, and this is very important when running
    hundreds of tests and looking for a short feedback loop, especially before integrating
    the code or releasing to an environment.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试执行得更快，这在运行数百个测试并寻找短反馈循环时非常重要，尤其是在集成代码或发布到环境之前。
- en: Unit tests have predictable results and are not affected by time, third-party
    service availability, or environmental intermittent issues.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的结果可预测，不受时间、第三方服务可用性或环境间歇性问题的干扰。
- en: Unit tests are repeatable as they do not persist any data, while integration
    tests might change the data permanently, which may make subsequent tests unreliable.
    This happens when writing and editing. Our example above was reading (Getting),
    so it did not suffer from this problem.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试是可重复的，因为它们不会持久化任何数据，而集成测试可能会永久更改数据，这可能会使后续测试不可靠。这种情况发生在编写和编辑过程中。我们上面的例子是读取（获取），所以它没有受到这个问题的影响。
- en: Unit tests are easier to deploy to CI/CD pipelines (we will demonstrate this
    in [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous
    Integration with GitHub Actions*).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试更容易部署到CI/CD管道中（我们将在[*第11章*](B18370_11.xhtml#_idTextAnchor265)，*使用GitHub
    Actions实现持续集成）中演示这一点）。
- en: Spotting bugs in unit tests is done sooner and can be pinpointed faster than
    finding the same bug in integration tests.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中找到错误比在集成测试中找到相同的错误要早，并且可以更快地定位。
- en: Unit tests can run during feature development, while an integration test can
    only be added when a feature is fully ready.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试可以在功能开发期间运行，而集成测试只能在功能完全准备好时添加。
- en: Confusing unit and integration tests
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆单元测试和集成测试
- en: Frameworks such as xUnit or NUnit are used in various integration test implementations.
    The term *Unit* in the framework names might mislead some developers to think
    what is written in these projects is unit tests. Add to that using the *AAA convention*
    and the method name convention, and this might mislead as well. In fact, I used
    these conventions in the previous integration test, but using the same convention
    of a unit test does not make a test a unit test.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种集成测试实现中使用了诸如xUnit或NUnit之类的框架。框架名称中的“单元”一词可能会误导一些开发者，使他们认为这些项目中写的是单元测试。再加上使用*AAA约定*和方法名称约定，这也可能造成误导。实际上，我在之前的集成测试中使用了这些约定，但使用与单元测试相同的约定并不意味着测试就是单元测试。
- en: Setting up the infrastructure and building the CI pipeline will vary based on
    the type of test being implemented. Although they look the same, it is important
    to differentiate between them to understand the level of tasks and maintenance
    required.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要实施的测试类型，设置基础设施和构建CI管道会有所不同。尽管它们看起来相同，但区分它们对于理解所需的任务和维护级别非常重要。
- en: Given that they look the same, how do you spot one or the other? There is a
    telltale, if they are not relying on the real dependency, they are most likely
    to be unit tests. If they are using real objects that would trigger real external
    dependencies, chances are they are not unit tests.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们看起来相同，如何区分它们？有一个明显的标志，如果它们不依赖于真实依赖项，那么它们很可能是单元测试。如果它们使用会触发真实外部依赖项的真实对象，那么它们很可能不是单元测试。
- en: Sintegration testing
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: S集成测试
- en: 'A **Sintegration** test is a midway between integration testing and unit testing.
    Integration testing relies on real components, while unit testing relies on test
    doubles. Sintegration testing tries to solve the shortcomings of integration testing
    by mixing elements of unit testing:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**S集成测试**是集成测试和单元测试之间的中间阶段。集成测试依赖于真实组件，而单元测试依赖于测试替身。S集成测试试图通过混合单元测试的元素来解决集成测试的不足：'
- en: '![Figure 4.5 – Unit, Sintegration, and integration testing ](img/Figure_4.5_B18370.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 单元、S集成和集成测试](img/Figure_4.5_B18370.jpg)'
- en: Figure 4.5 – Unit, Sintegration, and integration testing
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 单元、S集成和集成测试
- en: 'I have found some developers referring to this type of test as a **component
    test**. But a component test, in software engineering, means something different,
    and I feel the developers were—rightly—more concerned about what it does than
    naming it correctly. This test category has these distinctive features, as outlined
    here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现一些开发者将这种测试称为**组件测试**。但在软件工程中，组件测试意味着不同的东西，我觉得开发者们——正确地——更关心它所做的事情，而不是正确命名。这个测试类别具有以下独特的特征，如下所述：
- en: Substitutes (swaps) some dependencies with their real counterpart
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用它们的真实对应物替换一些依赖项
- en: Simulates some real dependencies by building fakes (the fakes of test doubles)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建替身（测试替身的替身）来模拟一些真实依赖项
- en: For the *S* at the beginning of *s*ubstitute, *s*wap, and *s*imulate, and for
    its resemblance to integration tests, I gave it the name *Sintegration testing*.
    As always, let me clarify Sintegration tests with an example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“s”ubstitute、“s”wap和“s”imulate开头的“S”，以及它对集成测试的相似性，我给它命名为**S集成测试**。就像往常一样，让我用一个例子来澄清S集成测试。
- en: Example
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: Let’s assume that we have a web project that uses logging, service bus queues,
    and Cosmos DB. The logging logs to the cloud, so it needs cloud connectivity.
    The queue is also a cloud component, and Cosmos DB is a cloud component as well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个使用日志记录、服务总线队列和Cosmos DB的Web项目。日志记录到云端，因此需要云连接。队列也是一个云组件，Cosmos DB同样也是。
- en: 'Let’s also assume that we have a series of APIs to deal with the user profile,
    such as the `UpdateName` API and the `ChangePassword` API. A Sintegration test
    can do the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再假设我们有一系列API来处理用户资料，例如`UpdateName` API和`ChangePassword` API。S集成测试可以执行以下操作：
- en: Use the Kestrel web server and have the same features as per production, as
    Kestrel is flexible enough to run on-demand on local machines, test, and production
    environments.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kestrel Web服务器，并具有与生产环境相同的功能，因为Kestrel足够灵活，可以在本地机器、测试和生产环境中按需运行。
- en: Writing logs will require access to the cloud, so we inject a `NullLogger<>`
    service that will ignore logging but will let the system work.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写日志需要访问云，因此我们注入一个`NullLogger<>`服务，该服务将忽略日志记录，但允许系统运行。
- en: Queues are only available on the cloud, so we replaced this with a fake in-memory
    queue that can be easily wiped between tests.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列仅在云上可用，所以我们用可以轻松在测试之间擦除的模拟内存队列来替换它。
- en: Cosmos DB does not have an in-memory implementation, but the cloud version can
    be easily wiped between test runs. So, we use the same .NET Cosmos DB client library,
    but we point to a different database—the Sintegration Tests Cosmos DB, at test
    time.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cosmos DB 没有内存实现，但云版本可以在测试运行之间轻松擦除。因此，我们使用相同的 .NET Cosmos DB 客户端库，但在测试时指向不同的数据库——Sintegration
    测试 Cosmos DB。
- en: 'Here is a project component diagram of what the system would look like:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个系统看起来像的项目组件图：
- en: '![Figure 4.6 – Executing Sintegration tests ](img/Figure_4.6_B18370.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 执行 Sintegration 测试](img/Figure_4.6_B18370.jpg)'
- en: Figure 4.6 – Executing Sintegration tests
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 执行 Sintegration 测试
- en: The Sintegration tests in this scenario use fakes, dummies, and real components.
    They cover part of the integration in the system, on the other hand, the queues
    and DB can be easily wiped between individual tests to make sure no Sintegration
    test is affecting other tests.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景中，Sintegration 测试使用模拟、替身和真实组件。它们覆盖了系统中的部分集成，另一方面，队列和数据库可以在各个测试之间轻松擦除，以确保没有
    Sintegration 测试影响其他测试。
- en: Sintegration testing started gaining traction in recent years; perhaps the movement
    from the classical .NET Framework to .NET has surfaced this type of testing as
    .NET Core libraries are no longer dependent on specific Windows components, such
    as the IIS web server. Also, ASP.NET Core has specific implementations that allowed
    this type of testing, whereas, in the past, these implementations were not part
    of the framework. One of these implementations is having a Kestrel web server
    as part of .NET and being able to spin it easily without relying on a special
    deployment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Sintegration 测试近年来开始受到关注；也许从经典的 .NET Framework 到 .NET 的转变使这种测试类型浮出水面，因为 .NET
    Core 库不再依赖于特定的 Windows 组件，例如 IIS 服务器。此外，ASP.NET Core 有特定的实现允许这种测试，而过去这些实现不是框架的一部分。这些实现之一是
    .NET 中的 Kestrel 服务器作为一部分，并且可以轻松启动而无需依赖特殊的部署。
- en: This was a quick overview of Sintegration tests. While Sintegration tests are
    not part of TDD, they are important to understand as they are related to unit
    tests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Sintegration 测试的简要概述。虽然 Sintegration 测试不是 TDD 的一部分，但了解它们很重要，因为它们与单元测试相关。
- en: Acceptance tests
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收测试
- en: '**Acceptance testing** is the testing of a complete functionality or a feature
    end-to-end. One popular tool for acceptance tests that is used for websites is
    **Selenium**. You might find this category of testing under different names, such
    as **functional testing**, **system testing**, and **automated testing**.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收测试**是对完整功能或特性的端到端测试。用于网站的验收测试的一个流行工具是**Selenium**。您可能会在不同的名称下找到这类测试，例如**功能测试**、**系统测试**和**自动化测试**。'
- en: Example
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: A test that simulates a user’s action of updating their name, then pressing
    the **Update** button, and then checking whether the name is updated. This example
    tests a full workflow of different actions, probably in the same order that the
    user would trigger them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模拟用户更新其姓名、然后点击**更新**按钮，接着检查姓名是否已更新的测试。此示例测试了不同动作的完整工作流程，可能按照用户触发的顺序进行。
- en: Think of acceptance tests as multiple integration tests executing successively.
    These tests are fragile and slow, so they are better kept at a minimum. On the
    other hand, they are a necessity in a system as they cover areas not covered by
    unit tests and Sintegration tests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将验收测试视为多个依次执行的集成测试。这些测试脆弱且缓慢，因此最好保持最少。另一方面，在系统中它们是必要的，因为它们覆盖了单元测试和 Sintegration
    测试未覆盖的领域。
- en: Choosing test categories
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择测试类别
- en: After reading about the three test types—namely, unit, Sintegration, and integration—and
    the additional acceptance tests, what tests should you write? The answer, surprisingly,
    is all four (if possible). However, integration tests can be omitted if both Sintegration
    and acceptance tests are implemented.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了关于三种测试类型——即单元、Sintegration 和集成——以及额外的验收测试之后，你应该编写哪些测试？出人意料的是，答案是所有四种（如果可能的话）。然而，如果同时实现了
    Sintegration 和验收测试，则可以省略集成测试。
- en: The testing triangle
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试三角形
- en: 'There is an industry concept known as the **testing triangle** that states
    the essential test categories to be implemented and the number of tests in each
    category. However, as with all software engineering concepts, the categories of
    the essential tests vary per triangle. Let’s look at the testing triangle for
    a greenfield project:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个行业概念称为**测试三角形**，它说明了要实施的必要测试类别以及每个类别中的测试数量。然而，与所有软件工程概念一样，必要测试的类别在每个三角形中都是不同的。让我们看看绿色地带项目的测试三角形：
- en: '![Figure 4.7 – Testing triangle ](img/Figure_4.7_B18370.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 测试三角形](img/Figure_4.7_B18370.jpg)'
- en: Figure 4.7 – Testing triangle
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 测试三角形
- en: The triangle in the preceding image advocates more unit tests than the other
    two testing categories. Assume you are experienced with the three mentioned tests.
    You will find that implementing unit tests takes the least amount of time compared
    to the other two and takes a few seconds to execute hundreds of them (after compiling
    and loading the code).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像中的三角形提倡比其他两个测试类别更多的单元测试。假设你已经熟悉了提到的三种测试。你会发现，与其他两种测试相比，实现单元测试所需的时间最少，并且执行数百个单元测试只需要几秒钟（编译和加载代码之后）。
- en: Discussing this triangle with respect to brownfield projects will be covered
    in [*Chapter 12*](B18370_12.xhtml#_idTextAnchor279), *Dealing with Brownfield
    Projects*. Hopefully, debating integration test and Sintegration test have helped
    you to better understand what a unit test is.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个三角形与棕色地带项目的讨论将在[*第 12 章*](B18370_12.xhtml#_idTextAnchor279)“处理棕色地带项目”中介绍。希望关于集成测试和S集成测试的讨论能帮助你更好地理解单元测试是什么。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we compared unit tests with its siblings: *integration* and
    *Sintegration* *tests*. We listed test doubles and gave an example of each, and
    we have also seen xUnit and NSubstitute in action.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们比较了单元测试与其兄弟姐妹：*集成*和*S集成*测试。我们列出了测试替身，并为每个提供了示例，我们还看到了 xUnit 和 NSubstitute
    的实际应用。
- en: Our journey with understanding unit testing and test doubles will not stop here,
    but we will cover more examples of the two topics across the rest of the book.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解单元测试和测试替身之旅不会在这里停止，但我们将在这本书的其余部分涵盖更多这两个主题的例子。
- en: So far, you can consider the experience from this chapter to take you to TDD
    level 3 out of 5! And now, you should be able to write a basic unit test that
    uses test doubles.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以将本章的经验应用到 TDD 的 5 个级别中的第 3 个级别！现在，你应该能够编写一个使用测试替身的简单单元测试。
- en: We have not covered the advantages and disadvantages of unit testing—yes, it
    has disadvantages! We have also not covered how TDD relates to unit testing and
    the best practices of unit testing because this is the role of the next chapter,
    *Test-Driven Development Explained*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有涵盖单元测试的优点和缺点——是的，它有缺点！我们也没有涵盖 TDD 如何与单元测试相关以及单元测试的最佳实践，因为这是下一章*测试驱动开发解释*的作用。
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，你可以参考以下链接：
- en: '*Martin Fowler’s definition of test doubles*: [https://martinfowler.com/bliki/TestDouble.xhtml](https://martinfowler.com/bliki/TestDouble.xhtml%0D)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*马丁·福勒对测试替身的定义*: [https://martinfowler.com/bliki/TestDouble.xhtml](https://martinfowler.com/bliki/TestDouble.xhtml%0D)'
- en: '*NSubstitute*: [https://nsubstitute.github.io](https://nsubstitute.github.io)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NSubstitute*: [https://nsubstitute.github.io](https://nsubstitute.github.io)'
