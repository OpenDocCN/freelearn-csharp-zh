- en: '22'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '22'
- en: 'Case Study Extension: Developing .NET Microservices for Kubernetes'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究扩展：为 Kubernetes 开发 .NET 微服务
- en: In this chapter, we bridge the insights from *Chapter 21, Case Study*, where
    we explored the practical implementation of .NET microservices, with the foundational
    knowledge of Kubernetes presented in *Chapter 20, Kubernetes*. Our focus here
    is on preparing .NET code for seamless integration with Kubernetes, encompassing
    the complete development cycle—from coding to debugging, and even troubleshooting
    post-deployment challenges.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将结合第 21 章 *案例研究* 中探讨的 .NET 微服务的实际实施见解，以及第 20 章 *Kubernetes* 中介绍的 Kubernetes
    的基础知识。我们的重点是准备 .NET 代码以无缝集成到 Kubernetes 中，涵盖整个开发周期——从编码到调试，甚至包括部署后的故障排除。
- en: We will guide you through the process of setting up a development workstation
    optimized for Kubernetes, learn the intricacies of packaging code with Docker,
    and understand how to organize your codebase for flawless execution across varied
    environments, such as Docker Desktop, local minikube installations, and production
    or staging Kubernetes clusters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引导您通过设置一个针对 Kubernetes 优化的开发工作站的过程，学习使用 Docker 打包代码的细节，并了解如何组织代码库以确保在各种环境中（如
    Docker Desktop、本地 minikube 安装以及生产或预发布 Kubernetes 集群）无故障执行。
- en: Also, this chapter delves into the nuances of remote debugging, providing you
    with the necessary skills to efficiently troubleshoot and debug your application.
    Here, you will learn how to prepare each developer workstation, how to package
    the code with Docker, and how to organize the code so that it can immediately
    run both on the developer Docker Desktop, on the developer’s local Minikube installation,
    and on the production/staging Kubernetes clusters, without modifications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还深入探讨了远程调试的细微差别，为您提供高效故障排除和调试应用程序所需的技能。在这里，您将学习如何准备每个开发工作站的配置，如何使用 Docker
    打包代码，以及如何组织代码，使其可以立即在开发者的 Docker Desktop、开发者的本地 Minikube 安装以及生产/预发布 Kubernetes
    集群上运行，无需修改。
- en: By the end of the chapter, you will have mastered remote debugging techniques
    for applications in production or staging environments, enabling swift issue resolution
    and system reliability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将掌握生产或预发布环境中应用程序的远程调试技术，从而实现快速问题解决和系统可靠性。
- en: 'More specifically, you will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，您将学习以下主题：
- en: The tools needed for .NET Kubernetes development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Kubernetes 开发所需的工具
- en: Organizing the development process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织开发流程
- en: Running your application in Minikube
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Minikube 中运行您的应用程序
- en: Remote debugging of a Kubernetes application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 应用程序的远程调试
- en: All concepts will be explained with the help of a previous example taken from
    *Chapter 21*, *Case Study*, which we will adapt for Kubernetes execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有概念都将通过从 *第 21 章，案例研究* 中选取的先前示例进行解释，我们将对其进行修改以适应 Kubernetes 执行。
- en: You’ll adapt the `GrpcMicroService` microservice from *Chapter 21*, *Case Study*,
    seeing firsthand how a real-world application transitions to Kubernetes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将改编第 21 章 *案例研究* 中的 `GrpcMicroService` 微服务，亲眼看到真实世界应用程序如何过渡到 Kubernetes。
- en: To fully leverage this chapter, fortify your understanding of Docker and Kubernetes
    as laid out in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise
    Application*, and *Chapter 20*, *Kubernetes*, which form the foundation for the
    advanced practices discussed herein.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用本章内容，请加强您对 Docker 和 Kubernetes 的理解，这些内容在第 11 章 *将微服务架构应用于您的企业应用程序* 和第 20
    章 *Kubernetes* 中有所阐述，它们构成了本章讨论的高级实践的基石。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Visual Studio 2022 free Community Edition or better, with
    all the database tools installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要 Visual Studio 2022 免费社区版或更高版本，并安装所有数据库工具。
- en: 'You will also need these:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要以下内容：
- en: '**WSL** (**Windows Subsystem for Linux**) and *Docker Desktop for Windows*.
    Detailed instructions on how to install both of them are given in the *Technical
    requirements* section of *Chapter 11, Applying a Microservice Architecture to
    Your Enterprise Application*.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WSL（Windows Subsystem for Linux**）和 *Docker Desktop for Windows*。关于如何安装这两个软件的详细说明见第
    11 章 *将微服务架构应用于您的企业应用程序* 中的 *技术要求* 部分。'
- en: A Minikube installation that specifies Docker as a virtualization tool. Minikube
    installation is described in the *Using Minikube* section of *Chapter 20*, *Kubernetes*.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定 Docker 作为虚拟化工具的 Minikube 安装。Minikube 安装在 *第 20 章，Kubernetes* 中的 *使用 Minikube*
    部分进行了描述。
- en: A SQL Server database that allows TCP/IP connections. You can’t use *SQL Server
    Express LocalDB*, which comes with Visual Studio installation, since it doesn’t
    allow TCP/IP connections. So you need either a full SQL Express installation or
    an Azure SQL Server database. More details on how to fulfill this requirement
    will be given in the *Tools needed for .NET Kubernetes development* section of
    this chapter.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许 TCP/IP 连接的 SQL Server 数据库。你不能使用随 Visual Studio 安装一起提供的 *SQL Server Express
    LocalDB*，因为它不允许 TCP/IP 连接。因此，你需要一个完整的 SQL Express 安装或一个 Azure SQL Server 数据库。关于如何满足这一要求的更多细节将在本章的
    *.NET Kubernetes 开发所需工具* 部分中给出。
- en: 'All the code of this chapter can be found in the GitHub repository associated
    with this book: [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在本书关联的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)。
- en: The Tools needed for .NET Kubernetes development
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Kubernetes 开发所需工具
- en: Each single microservice can be unit-tested and debugged independently from
    the remainder of its application, with the technique you learned *Chapter 9*,
    *Testing Your Enterprise Application*. You don’t need to package it inside a Docker
    image to do this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的微服务都可以使用你在 *第 9 章，测试你的企业应用程序* 中学到的技术独立于其应用程序的其余部分进行单元测试和调试。你不需要将其打包在 Docker
    镜像中来做这件事。
- en: However, debugging and performing integration tests on the whole application
    or parts of it requires that all involved microservices interact and are packaged
    as in the final application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对整个应用程序或其部分进行调试和执行集成测试需要所有涉及的微服务进行交互，并打包成最终应用程序的形式。
- en: You can use a staging environment to beta-test your application. Prior to staging
    deployment, ensure your application’s stability in the development environment
    to prevent time-consuming troubleshooting, because the staging environment doesn’t
    have all the facilities that are available in a development environment. Otherwise,
    troubleshooting all frequent bugs and crashes discovered in the staging environment
    might imply an unacceptable time cost.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用预发布环境来测试你的应用程序。在部署到预发布环境之前，确保你的应用程序在开发环境中的稳定性，以避免耗时的故障排除，因为预发布环境没有开发环境中所有可用的设施。否则，解决在预发布环境中发现的所有常见错误和崩溃可能意味着不可接受的时间成本。
- en: Therefore, it is preferable to reach good application stability before deploying
    the application in a staging environment. Moreover, for easier and more efficient
    debug-fix cycles, it is desirable that all microservices run on each single developer
    machine. That’s why each developer workstation must be equipped with both Docker
    and Minikube.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将应用程序部署到预发布环境之前，最好先达到良好的应用程序稳定性。此外，为了更容易、更高效地进行调试-修复循环，最好所有微服务都在单个开发机器上运行。这就是为什么每个开发工作站都必须配备
    Docker 和 Minikube。
- en: Furthermore, the developer machine must be able to simulate all communications
    between microservices and between services and other storage media, like databases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，开发机器必须能够模拟微服务之间以及服务与其他存储媒体（如数据库）之间的所有通信。
- en: It is likely that, Minikube can run and simulate all communications that occur
    in an actual Kubernetes cluster, including when it runs on a single development
    machine.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，Minikube 可以运行并模拟在真实 Kubernetes 集群中发生的所有通信，包括它在单个开发机器上运行时。
- en: We can also let all involved Docker images communicate among them before loading
    them on Minikube because Docker Desktop allows the creation of virtual networks
    that are accessible by the local Docker images.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在将它们加载到 Minikube 之前，让所有涉及的 Docker 镜像之间进行通信，因为 Docker Desktop 允许创建本地 Docker
    镜像可以访问的虚拟网络。
- en: Finally, both Docker and Minikube virtual networks automatically include the
    development machine that hosts them, so we can place storage services like disk
    volumes and databases on the development machine itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Docker 和 Minikube 虚拟网络自动包括托管它们的开发机器，因此我们可以将存储服务（如磁盘卷和数据库）放置在开发机器本身上。
- en: '![](img/B19820_22_01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_01.png)'
- en: 'Figure 22.1: Minikube and Docker network structure'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.1：Minikube 和 Docker 网络结构
- en: However, the sophisticated virtual network facilities of both Docker and Kubernetes
    are not enough to ensure an efficient development and debugging environment, and
    further tools are needed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker 和 Kubernetes 的复杂虚拟网络功能不足以确保高效的开发和调试环境，还需要进一步的工具。
- en: 'Below are all the issues we need to fix to configure an efficacious development-debugging
    environment and how to solve them:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要解决的所有问题以及如何解决这些问题，以配置有效的开发调试环境：
- en: As a default, Visual Studio installs *SQL Server Express LocalDB* instead of
    *SQL Server Express*, and SQL Server Express LocalDB is not able to communicate
    via actual or virtual networks. Therefore, we need either an SQL Server Express
    installation or an external database.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Visual Studio 安装的是 *SQL Server Express LocalDB* 而不是 *SQL Server Express*，而
    SQL Server Express LocalDB 无法通过实际或虚拟网络进行通信。因此，我们需要 SQL Server Express 的安装或外部数据库。
- en: Since Kubernetes nodes have just virtual addresses that are handled by the Kubernetes
    engine itself, a Visual Studio debugger can be attached to a running microservice
    just through the REST API of the Kubernetes engine. At the time of writing, the
    best tool available for Visual Studio is *Bridge to Kubernetes,* which, in turn,
    uses *kubectl* to interact with the API of any Kubernetes cluster, Minikube included.
    Unluckily, we can’t use the Kubectl installation that runs on the virtual machine
    that hosts Minikube as we did in *Chapter 20*, *Kubernetes*, but we need an installation
    that runs directly in the development machine.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Kubernetes 节点仅具有由 Kubernetes 引擎本身处理的虚拟地址，因此 Visual Studio 调试器可以通过 Kubernetes
    引擎的 REST API 将其附加到正在运行的微服务。在撰写本文时，Visual Studio 可用的最佳工具是 *Bridge to Kubernetes*，它反过来使用
    *kubectl* 与任何 Kubernetes 集群的 API 进行交互，包括 Minikube。不幸的是，我们无法使用在 Minikube 主机虚拟机上运行的
    Kubectl 安装，就像我们在 *第 20 章*，*Kubernetes* 中所做的那样，但我们需要一个直接在开发机器上运行的安装。
- en: We describe how to install and configure all tools mentioned in the above points
    in two dedicated subsections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两个专门的子节中描述如何安装和配置上述提到的所有工具。
- en: Installing and configuring SQL Server Express
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 SQL Server Express
- en: 'If you have access to an SQL Server instance running in your development machine,
    you can use that one. Otherwise, you can choose between creating an SQL Server
    database in Azure following the instructions containedin *Chapter 12*, *Choosing
    Your Data Storage in the Cloud*, or installing a local instance of SQL Server
    Express:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有权访问在您的开发机器上运行的 SQL Server 实例，您可以使用该实例。否则，您可以根据 *第 12 章*，*在云中选择您的数据存储* 中的说明在
    Azure 中创建 SQL Server 数据库，或者安装 SQL Server Express 的本地实例：
- en: Begin by downloading the SQL Server installer from [https://www.microsoft.com/en-US/download/details.aspx?id=104781](https://www.microsoft.com/en-US/download/details.aspx?id=104781).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从 [https://www.microsoft.com/en-US/download/details.aspx?id=104781](https://www.microsoft.com/en-US/download/details.aspx?id=104781)
    下载 SQL Server 安装程序。
- en: You can freely choose between SQL Server Express and SQL Server Express Advanced,
    but please select a complete installation that includes both **SQL Server Management
    Studio** and the **SQL Server Management console**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在 SQL Server Express 和 SQL Server Express Advanced 之间自由选择，但请选择一个包含 **SQL
    Server Management Studio** 和 **SQL Server 管理控制台** 的完整安装。
- en: Select to install SQL Server as the default instance on your machine (the default
    in the installation procedure).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择将 SQL Server 作为默认实例安装到您的计算机上（安装过程中的默认选项）。
- en: Immediately after the installation, you must run SQL Server Management Console
    (just write this name in the Windows search box) to enable TCP/IP-based connections.
    In order to configure SQL Server properly, follow all the steps below.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完成后，您必须运行 SQL Server 管理控制台（只需在 Windows 搜索框中键入此名称）以启用基于 TCP/IP 的连接。为了正确配置 SQL
    Server，请遵循以下所有步骤。
- en: Once in the SQL Server Management Console, expand the **SQL Server Network Configuration**
    node.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入 SQL Server 管理控制台，展开 **SQL Server 网络配置** 节点。
- en: Select **Protocols for <your instance name>**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **<您的实例名称> 的协议**。
- en: On the right detail pane, you should see all the available communication protocols.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧详细窗格中，您应该看到所有可用的通信协议。
- en: Right-click on **TCP**/**IP** and select **Enable**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **TCP**/**IP** 并选择 **启用**。
- en: Now, TCP/IP is enabled but on a dynamic port. In order to impose a fixed port,
    right-click on the same TCP/IP node and select **Properties**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，TCP/IP 已启用，但使用动态端口。为了强制使用固定端口，右键单击相同的 TCP/IP 节点并选择 **属性**。
- en: '![](img/B19820_22_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_02.png)'
- en: 'Figure 22.2: Forcing a static IP address'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.2：强制使用静态 IP 地址
- en: Select the **IP Addresses** tab.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **IP 地址** 选项卡。
- en: You should see several IP addresses. These are all IP addresses that are associated
    with your computer, and each of them executes the next step.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到几个 IP 地址。这些都是与您的计算机关联的 IP 地址，每个地址都会执行下一步。
- en: Remove the **0** that is in **TCP Dynamic Port** and keep this field empty,
    and then write `1433` in the **TCP Port** field.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**TCP动态端口**中移除**0**，并保持此字段为空，然后在**TCP端口**字段中写入`1433`。
- en: Once finished, click on the **OK** button.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**确定**按钮。
- en: Now, you need to restart the SQL Server service. Select **SQL Server Services**
    in the left pane.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要重新启动SQL Server服务。在左侧窗格中选择**SQL Server服务**。
- en: Finally, in the right detail pane, right-click on **SQL Server <your instance
    name>** and select **Restart**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在右侧详细窗格中，右键单击**SQL Server <你的实例名称>**并选择**重启**。
- en: Once installed, the SQL Server only has Windows authentication enabled. In order
    to use the instance on a non-Windows network, you must enable username-based authentication
    and define at least one administrative user. This is a necessary step because
    Windows authentication will not work on Docker networks and Kubernetes.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，SQL Server仅启用了Windows身份验证。为了在非Windows网络上使用实例，你必须启用基于用户名的身份验证并定义至少一个管理员用户。这是一个必要的步骤，因为Windows身份验证在Docker网络上和Kubernetes上都不会工作。
- en: 'You can do this in SQL Server Management Studio. Once SQL Server Management
    Studio opens, it prompts you for an instance to connect with and for authentication
    information. The instance name of the database you just installed should be something
    like `<computer name>\SQLEXPRESS`; select it and also select **Windows Authentication**,
    as shown below:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在SQL Server Management Studio中完成此操作。一旦SQL Server Management Studio打开，它会提示你连接的实例和身份验证信息。你刚刚安装的数据库的实例名称应该是类似于`<计算机名称>\SQLEXPRESS`的名称；选择它，并选择**Windows身份验证**，如图下所示：
- en: '![](img/B19820_22_03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_03.png)'
- en: 'Figure 22.3: Connecting with SQL Server Management Studio'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.3：使用SQL Server Management Studio连接
- en: 'Once connected with the database, you can enable username-based authentication
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦与数据库连接，你可以按照以下步骤启用基于用户名的身份验证：
- en: Right-click on your server icon in Object Explorer and choose **Properties**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象资源管理器中右键单击你的服务器图标并选择**属性**。
- en: In the window that opens, select **Security** in the left pane.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，在左侧窗格中选择**安全**。
- en: 'Select **SQL Server and Windows Authentication mode**, as shown in the screenshot
    below:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**SQL Server和Windows身份验证模式**，如图下所示：
- en: '![](img/B19820_22_04.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_04.png)'
- en: 'Figure 22.4: Enabling SQL Server authentication'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.4：启用SQL Server身份验证
- en: In order to make your changes effective, you must restart SQL Server. You can
    do it by right-clicking on your server icon in Object Explorer and by selecting
    **Restart**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的更改生效，你必须重新启动SQL Server。你可以通过在对象资源管理器中右键单击你的服务器图标并选择**重启**来完成此操作。
- en: 'Now, you need to define at least one user by following the steps below:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要按照以下步骤定义至少一个用户：
- en: Expand the `Security` folder under your server icon in Object Explorer.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象资源管理器中展开你的服务器图标下的**安全**文件夹。
- en: Right-click on the **Logins** folder and select **New Login**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**登录名**文件夹并选择**新建登录名**。
- en: In the window that opens, insert a username.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，输入一个用户名。
- en: 'Select **SQL Server authentication**, insert a password, and confirm it by
    retyping the same password in the **Confirm password** field, as shown in the
    screenshot below:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**SQL Server身份验证**，输入一个密码，并在**确认密码**字段中重新输入相同的密码，如图下所示：
- en: '![](img/B19820_22_05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_05.png)'
- en: 'Figure 22.5: Defining user name and password'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.5：定义用户名和密码
- en: Finally, right-click on **Server Roles** and enable the **sysadmin** role to
    give all rights to the new user.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**服务器角色**上右键单击并启用**sysadmin**角色，以赋予新用户所有权限。
- en: And there you have it! Now, your SQL Server instance can be used by both Docker
    and Minikube.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了！现在，你的SQL Server实例既可以由Docker使用，也可以由Minikube使用。
- en: The next subsection explains how to configure Visual Studio for debugging applications
    running on Minikube or any other Kubernetes cluster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节解释了如何为在Minikube或任何其他Kubernetes集群上运行的应用程序配置Visual Studio进行调试。
- en: Enabling Kubernetes application debugging with Bridge to Kubernetes
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bridge to Kubernetes启用Kubernetes应用程序调试
- en: Since microservices running on Kubernetes have no fixed IP address and ports
    attached to them, only virtual addresses that are solved at runtime by Kubernetes,
    we can’t attach the Visual Studio debugger directly to any running microservice.
    That’s why we need software like Bridge to Kubernetes, which interacts with the
    Kubernetes API to enable debugging.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Kubernetes上运行的微服务没有固定的IP地址和端口，只有Kubernetes在运行时解决的虚拟地址，我们无法直接将Visual Studio调试器附加到任何正在运行的微服务。这就是为什么我们需要像Bridge
    to Kubernetes这样的软件，它与Kubernetes API交互以启用调试。
- en: Bridge to Kubernetes is a Visual Studio extension that’s easy to install, but
    it requires Kubectl to be installed on your development machine, which presents
    a challenge, as there is no direct Windows installer for Kubectl. In this subsection,
    we’ll guide you through the process of installing both Bridge to Kubernetes and
    Kubectl, overcoming the lack of a direct Windows installer for the latter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes桥接器是一个易于安装的Visual Studio扩展，但它要求在你的开发机器上安装Kubectl，这带来了一定的挑战，因为Kubectl没有直接的Windows安装程序。在本小节中，我们将指导你完成安装Bridge
    to Kubernetes和Kubectl的过程，克服后者缺乏直接Windows安装程序的问题。
- en: Bridge to Kubernetes enables Kubernetes application debugging by interacting
    with the Kubernetes API via Kubectl. However, it is not a debugger driver or a
    debugger extension. It does a completely different job; it asks you to select
    a service running in a Kubernetes cluster and reroute all communication with this
    service to a locally running Visual Studio POD replica instead of the actual cluster
    POD.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes桥接器通过Kubectl与Kubernetes API交互，从而实现Kubernetes应用程序的调试。然而，它不是一个调试驱动程序或调试扩展。它做的是一项完全不同的工作；它要求你选择在Kubernetes集群中运行的服务，并将与此服务的所有通信重定向到本地运行的Visual
    Studio POD副本，而不是实际的集群POD。
- en: '![](img/B19820_22_06.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_06.png)'
- en: 'Figure 22.6: How Bridge to Kubernetes works'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.6：Kubernetes桥接器的工作原理
- en: Therefore, the developer debugs a local copy of the POD code but in exactly
    the same dynamic Kubernetes environment as the original POD. This way, you have
    all the facilities offered by a usual local debugging session, but while you are
    debugging it, your code interacts with the actual Kubernetes cluster you need
    to fix.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发者调试的是POD代码的本地副本，但与原始POD完全相同的动态Kubernetes环境中。这样，你就有了一个通常本地调试会话提供的所有设施，同时在你调试时，你的代码与你需要修复的实际Kubernetes集群进行交互。
- en: Bridge to Kubernetes doesn’t work just with Minikube; it works with any Kubernetes
    cluster. Thus, you can use it for debugging the whole application on your development
    machine, and also for debugging the staging application or the production application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes桥接器不仅与Minikube一起工作；它与任何Kubernetes集群一起工作。因此，你可以用它来在开发机器上调试整个应用程序，也可以用于调试预发布应用程序或生产应用程序。
- en: Since you debug just the local code and not the deployed code, you are not forced
    to compile an application in debug mode in order to debug it. You can deploy the
    application with all compilation optimizations you want without caring about possible
    debugging needs; it is enough to have local copies of the PODs you would like
    to debug compiled in debug mode.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你只调试本地代码而不是已部署的代码，因此你不必在调试模式下编译应用程序来调试它。你可以部署应用程序，并使用你想要的任何编译优化，无需关心可能的调试需求；只需确保你想要调试的POD的本地副本已以调试模式编译即可。
- en: You will learn how to use Bridge to Kubernetes in practice in the *Remote debugging
    of a Kubernetes application* section. The remainder of this section will explain
    all the steps needed to install Bridge to Kubernetes on a development machine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在“Kubernetes应用程序的远程调试”部分学习如何在实际中使用Kubernetes桥接器。本节的其余部分将解释安装Bridge to Kubernetes到开发机器上所需的所有步骤。
- en: First of all, you need to install Kubectl. The simplest way to do it is by using
    the Chocolatey package manager.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装Kubectl。最简单的方法是使用Chocolatey包管理器。
- en: Chocolatey is a package manager like NuGet. Similarly, it consists of a public
    repository containing all packages and a client you must install on your machine,
    in order to interact with the public repository.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Chocolatey是一个类似于NuGet的包管理器。同样，它由一个包含所有包的公共仓库和一个你必须安装到你的机器上的客户端组成，以便与公共仓库交互。
- en: 'If you don’t have Chocolatey already installed, you can install it from a PowerShell
    prompt, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装Chocolatey，你可以从PowerShell提示符安装它，如下所示：
- en: Search **PowerShell** in the Windows search box.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows搜索框中搜索**PowerShell**。
- en: Right-click on the PowerShell link and select to execute it as an administrator.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击PowerShell链接，并选择以管理员身份执行。
- en: 'Finally, execute the PowerShell command suggested on the official Chocolatey
    page: [https://chocolatey.org/install#individual](https://chocolatey.org/install#individual).'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行官方Chocolatey页面上的PowerShell命令：[https://chocolatey.org/install#individual](https://chocolatey.org/install#individual)。
- en: 'The PowerShell command to execute is repeated below for your convenience:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为你的方便而重复的PowerShell命令：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once installation is complete, run `choco -?` to verify that the installation
    was successful and that the Chocolatey user interface works properly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，运行 `choco -?` 以验证安装成功并且 Chocolatey 用户界面工作正常。
- en: 'With Chocolatey installed, installing Kubectl is super easy; just open a Windows
    Command Prompt as an administrator and type this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Chocolatey 后，安装 Kubectl 非常简单；只需以管理员身份打开 Windows 命令提示符，并输入以下内容：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can check whether everything works properly by typing `kubectl version –client`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入 `kubectl version –client` 来检查一切是否正常工作。
- en: Kubectl should be configured to access a specific cluster, but when you start
    Minikube with `minikube start`, Minikube automatically configures it to access
    the local Minikube cluster, so you don’t need to worry about Kubectl configuration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl 应配置为访问特定集群，但当你使用 `minikube start` 启动 Minikube 时，Minikube 会自动将其配置为访问本地
    Minikube 集群，因此你不需要担心 Kubectl 的配置。
- en: 'Now, you are ready to install Bridge to Kubernetes, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以按照以下步骤安装 Bridge to Kubernetes：
- en: Open Visual Studio and select **Extensions -> Manage Extensions**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并选择 **扩展 -> 管理扩展**。
- en: Search `Bridge to Kubernetes`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `Bridge to Kubernetes`。
- en: Select it and install it.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它并安装。
- en: And there you have it! Now, your development machine is ready for .NET Kubernetes
    development. The next section details the development process and explains how
    to modify an existing project to run with both the local Docker installation and
    any Kubernetes cluster.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就到这里！现在，你的开发机器已经准备好进行 .NET Kubernetes 开发了。下一节将详细介绍开发过程，并解释如何修改现有项目以同时使用本地
    Docker 安装和任何 Kubernetes 集群。
- en: Organizing the development process
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织开发过程
- en: Since Visual Studio and other IDEs offer good support for Docker and a good
    integration with Docker Desktop, the best option for most of the development time
    is working with just Dockerized images without running them inside of Minicube.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Visual Studio 和其他 IDE 对 Docker 提供良好的支持，并与 Docker Desktop 有很好的集成，因此在大多数开发时间内，最佳选项是仅使用
    Docker 化的镜像进行工作，而不在 Minicube 内运行它们。
- en: In fact, as we will see shortly, once we have added Docker support to our projects,
    it is enough to click the Run Visual Studio button to start all our Dockerized
    microservices and to enable them to communicate through a Docker network. Conversely,
    running our application in Minikube requires several manual steps, and it takes
    some time to load the Docker images on Minikube and to create all the necessary
    Kubernetes objects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，正如我们很快就会看到的，一旦我们将 Docker 支持添加到我们的项目中，点击运行 Visual Studio 按钮就足够了，这样就可以启动所有
    Docker 化的微服务，并使它们能够通过 Docker 网络进行通信。相反，在 Minikube 中运行我们的应用程序需要几个手动步骤，并且需要一些时间来在
    Minikube 上加载 Docker 镜像以及创建所有必要的 Kubernetes 对象。
- en: 'Doing this in Visual Studio is super easy. It is enough to add Docker support
    for all microservice projects in your solution and to select the option of launching
    several projects simultaneously when the solution is run. Then, Visual Studio
    will automatically perform all the necessary tasks when your solution is run,
    namely:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中这样做非常简单。只需为你的解决方案中的所有微服务项目添加 Docker 支持，并在解决方案运行时选择同时启动多个项目的选项。然后，当你的解决方案运行时，Visual
    Studio 将自动执行所有必要的任务，即：
- en: Compile and link all code.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和链接所有代码。
- en: Build all microservice Docker images.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建所有微服务的 Docker 镜像。
- en: Insert the Docker images into the Docker Desktop local repository.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Docker 镜像插入 Docker Desktop 本地仓库。
- en: Launch all Docker images simultaneously.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时启动所有 Docker 镜像。
- en: Attach the debugger to all launched Docker images.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调试器附加到所有启动的 Docker 镜像。
- en: You just need to take care of microservice communication by defining a virtual
    network with Docker Desktop.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要通过定义一个 Docker Desktop 虚拟网络来关注微服务之间的通信。
- en: We will explain all the details of the development process with a simple example
    in the next subsection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中通过一个简单的示例解释开发过程的全部细节。
- en: gRPC worker microservices revisited
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视 gRPC 工作微服务
- en: In the code associated with *Chapter 14*, *Implementing Microservices with .NET*,
    and described in *Chapter 21*, *Case study,* there is a solution called `GrpcMicroService`.
    The solution is composed of two microservices. The first microservice simulates
    purchases by generating random data, while the second one uses this data to compute
    statistics that it stores in a database. The whole code is available in the `ch15->GrpcMicroService`
    folder of the GitHub repository associated with the book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 *第 14 章*，*使用 .NET 实现微服务* 和在第 21 章，*案例研究* 中描述的代码中，有一个名为 `GrpcMicroService`
    的解决方案。该解决方案由两个微服务组成。第一个微服务通过生成随机数据来模拟购买，而第二个微服务使用这些数据来计算存储在数据库中的统计数据。整个代码在书籍相关的
    GitHub 仓库的 `ch15->GrpcMicroService` 文件夹中可用。
- en: Let’s make a copy of the whole `GrpcMicroService` folder and call it `GrpcMicroServiceDocker`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制整个 `GrpcMicroService` 文件夹，并将其命名为 `GrpcMicroServiceDocker`。
- en: The steps below describe all the modifications that need to be made to Docker
    to enable all microservices.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的步骤描述了需要对 Docker 进行所有必要的修改，以启用所有微服务。
- en: Adding Docker support to GrpcMicroServiceDocker
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Docker 支持添加到 GrpcMicroServiceDocker
- en: Open the `GrpcMicroServiceDocker` solution in Visual Studio. The solution contains
    two microservices, called `FakeSource` and `GrpcMicroservice`. The last project
    is just the data layer of the `GrpcMicroservice` project.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 `GrpcMicroServiceDocker` 解决方案。该解决方案包含两个微服务，分别称为 `FakeSource`
    和 `GrpcMicroservice`。最后一个项目只是 `GrpcMicroservice` 项目的数据层。
- en: '![](img/B19820_22_07.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_22_07.png)'
- en: 'Figure 22.7: GrpcMicroServiceDocker solution'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.7：GrpcMicroServiceDocker 解决方案
- en: The solution is already configured to launch the two microservices when it is
    run. In other cases, you might need to configure multiple project launches by
    right-clicking on the solution node and selecting **Set Startup Projects….**
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案已经配置为在运行时启动两个微服务。在其他情况下，你可能需要通过右键单击解决方案节点并选择 **设置启动项目…** 来配置多个项目启动。
- en: Adding Docker support to both microservices is super easy. Right-click on each
    microservice project within Visual Studio. Navigate to **Add**, and then select
    **Docker Support**. If prompted, choose the operating system for your Docker environment.
    If you are using Minikube, you must select **Linux**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Docker 支持添加到两个微服务中非常简单。在 Visual Studio 中右键单击每个微服务项目。导航到 **添加**，然后选择 **Docker
    支持**。如果提示，选择你的 Docker 环境的操作系统。如果你使用 Minikube，你必须选择 **Linux**。
- en: All the necessary Docker files are automatically created and configured by Visual
    Studio. And that’s it!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的 Docker 文件都由 Visual Studio 自动创建和配置。就这样了！
- en: Now, we need to move the database to the newly installed SQL Server instance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将数据库移动到新安装的 SQL Server 实例。
- en: Moving GrpcMicroServiceDocker to SQL Server Express
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 GrpcMicroServiceDocker 移动到 SQL Server Express
- en: You need to change all connection strings and configure the string that will
    be used at runtime so that it can be used from inside a Docker image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更改所有连接字符串并配置将在运行时使用的字符串，以便它可以在 Docker 镜像内部使用。
- en: 'First of all, let’s change the connection string that is inside `GrpcMicroServiceStore->
    LibraryDesignTimeDbContextFactory.cs`. The new string should be something like
    this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更改 `GrpcMicroServiceStore-> LibraryDesignTimeDbContextFactory.cs` 中面的连接字符串。新字符串应该类似于以下内容：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'where the instance name should be `SQLEXPRESS`. You can take the above connection
    string directly from Visual Studio, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其中实例名称应该是 `SQLEXPRESS`。你可以直接从 Visual Studio 中获取上述连接字符串，如下所示：
- en: Open the **SQL Server Object Explorer** window.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **SQL Server 对象资源管理器**窗口。
- en: Right-click on the **SQL Server** node and select **Add SQL Server**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **SQL Server** 节点并选择 **添加 SQL Server**。
- en: In the window that opens, Visual Studio should enumerate all available SQL Server
    instances. Choose the newly installed SQL Server instance.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，Visual Studio 应该列出所有可用的 SQL Server 实例。选择新安装的 SQL Server 实例。
- en: Select **Windows authentication** and connect.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Windows 身份验证**并连接。
- en: A new server icon should appear below the **SQL Server** node. Select it.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **SQL Server** 节点下方应该出现一个新的服务器图标。选择它。
- en: In the **Visual Studio Properties** tab, you should see all database connection
    properties. Take the value of **General-> Connection string**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Visual Studio 属性**选项卡中，你应该能看到所有数据库连接属性。取 **通用-> 连接字符串** 的值。
- en: Now, you have to run all migrations to recreate the database in the new SQL
    Server instance. As usual, right-click on the library project and define it as
    a startup project. Then, in the Visual Studio Package Manager Console **Default
    Project**, select `GrpcMicroServiceStore` and issue the `Update-Database` command.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你必须运行所有迁移以在新的 SQL Server 实例中重新创建数据库。像往常一样，右键单击库项目并将其定义为启动项目。然后，在 Visual Studio
    包管理器控制台 **默认项目** 中，选择 `GrpcMicroServiceStore` 并发出 `Update-Database` 命令。
- en: After the new database has been created, restore the two microservices as simultaneous
    startup projects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新数据库创建后，将两个微服务作为同时启动项目恢复。
- en: 'Finally, update the runtime connection string in `GrpcMicroService -> appsettings.json`.
    If the newly installed SQL Server instance has been defined as the default instance
    on your machine, the connection string below should work:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新 `GrpcMicroService -> appsettings.json` 中的运行时连接字符串。如果新安装的 SQL Server 实例已被定义为机器上的默认实例，以下连接字符串应该可以工作：
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where `host. Docker.internal` is the URL used by Docker Desktop images to communicate
    with the host machine. If your SQL Server is not the machine’s default instance,
    you must replace `host.docker.internal` with `host.docker.internal\<your instance
    name>`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `host.docker.internal` 是 Docker Desktop 镜像用于与主机通信的 URL。如果你的 SQL Server 不是机器的默认实例，你必须将
    `host.docker.internal` 替换为 `host.docker.internal\<your instance name>`。
- en: If, instead, you are using an external database, you can use its standard connection
    string with no modifications.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，相反，你正在使用外部数据库，你可以使用其标准的连接字符串，无需修改。
- en: Enabling communication among microservices with a Docker virtual network
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Docker 虚拟网络启用微服务之间的通信
- en: 'Creating a Docker virtual network in Docker Desktop is easy; just open a Windows
    console and run the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Desktop 中创建 Docker 虚拟网络非常简单；只需打开 Windows 控制台并运行以下命令：
- en: '[PRE4]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'where `test-net` is the virtual network name. Once the network has been defined
    when we create a container instance from an image, we can specify that the launched
    container must be connected to our network and its hostname, with something like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `test-net` 是虚拟网络名称。一旦我们在从镜像创建容器实例时定义了网络，我们就可以指定启动的容器必须连接到我们的网络及其主机名，如下所示：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `rm` option specifies that the container must be destroyed when it
    stops running, `--net test-net` specifies the network where to connect the created
    container, and -`-name grpcmicroservice` is the name of the created container
    that will also act as its hostname in the network.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`rm` 选项指定容器停止运行时必须被销毁，`--net test-net` 指定连接创建容器的网络，而 `-name grpcmicroservice`
    是创建的容器名称，它也将作为其在网络中的主机名。
- en: We need to add to our `test-net` just the containers that must act as servers—in
    our case, the `GrpcMicroService` microservice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `test-net` 虚拟网络中添加的容器仅限于必须作为服务器的容器——在我们的例子中，是 `GrpcMicroService` 微服务。
- en: 'Since Visual Studio automatically issues all necessary `run` Docker commands
    when the solution is launched, we need just to specify the command options to
    add to Visual Studio’s original command. They must be specified in each microservice
    project file with the `DockerfileRunArguments` parameter. Below is how to modify
    the `GrpcMicroService` microservice project file, which is the only microservice
    acting as a server:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Visual Studio 在启动解决方案时自动发出所有必要的 `run` Docker 命令，我们只需要指定要添加到 Visual Studio
    原始命令的选项。它们必须在每个微服务项目文件中使用 `DockerfileRunArguments` 参数进行指定。以下是如何修改 `GrpcMicroService`
    微服务项目文件的方法，这是唯一作为服务器运行的微服务：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No modification is required to the `FakeSource` project, since it must not act
    as a server.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `FakeSource` 项目不需要进行修改，因为它必须不作为服务器运行。
- en: Now, the `grpcmicroservice` hostname must be used by `FakeSource` to communicate
    with the `GrpcMicroService` microservice.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`grpcmicroservice` 主机名必须由 `FakeSource` 用于与 `GrpcMicroService` 微服务进行通信。
- en: 'Therefore, we must replace the URL in the `FakeSource->Worker.cs` file with
    `http://grpcmicroservice:8080`, as shown in the code snippet below:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须将 `FakeSource->Worker.cs` 文件中的 URL 替换为 `http://grpcmicroservice:8080`，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'where we use the `8080` default Kestrel `http` port to communicate with the
    microservice. Therefore, we need to the Kestrel options in `GrpcMicroService ->Program.cs`
    that force Kestrel to listen to the `5000` port by replacing the code below:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们使用 `8080` 默认的 Kestrel `http` 端口与微服务进行通信。因此，我们需要在 `GrpcMicroService -> Program.cs`
    中的 Kestrel 选项中强制 Kestrel 监听 `5000` 端口，通过替换下面的代码：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we are ready to run our project. To be sure that both microservices are
    started with Docker, please select each of them as a single startup project, and
    then select **Docker** in the select box next to the run solution Visual Studio
    button, as shown in the image below:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行我们的项目。为了确保两个微服务都使用 Docker 启动，请将每个微服务作为单个启动项目选中，然后在下图所示的运行解决方案 Visual
    Studio 按钮旁边的选择框中选择 **Docker**，如图所示：
- en: '![](img/B19820_22_08.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_22_08.png)'
- en: 'Figure 22.8: Selecting Docker execution'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.8：选择 Docker 执行
- en: After that, you can restore the simultaneous launch of both microservices. Visual
    Studio will launch both of them with Docker.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以恢复同时启动两个微服务。Visual Studio 将使用 Docker 启动它们。
- en: 'Now, we can launch the solution. In order to verify that the server is properly
    receiving purchase information, place a breakpoint in the `GrpcMicroService->HostedServices->
    ProcessPurchases.cs` file inside of the `if` block below:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动解决方案。为了验证服务器是否正确接收购买信息，在下面的 `if` 块中 `GrpcMicroService->HostedServices->
    ProcessPurchases.cs` 文件内放置一个断点：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In fact, `GrpcMicroService` enters that block only if it finds something in
    the input queue.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`GrpcMicroService` 只有在输入队列中找到某些内容时才会进入那个块。
- en: You can also inspect the content of the `dbo.Purchases` database table to verify
    that it is filled with statistics on purchases. You can do it from within **SQL
    Server Object Explorer** by right-clicking on the table and choosing **View Data**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查 `dbo.Purchases` 数据库表的 内容，以验证它是否填充了购买统计信息。你可以通过在 **SQL Server Object Explorer**
    中右键单击表并选择 **查看数据** 来完成它。
- en: Having understood how to test our application with a Docker network, we must
    now understand when and how to test it with Minikube also.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了如何使用 Docker 网络测试我们的应用程序之后，我们现在必须了解何时以及如何使用 Minikube 进行测试。
- en: When to test the application with Minikube
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用 Minikube 测试应用程序
- en: Most of the debug-fix cycle involved in the application development can be done
    with the Docker virtual network.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发中涉及的调试-修复周期的大部分工作都可以使用 Docker 虚拟网络完成。
- en: Docker networks usually work well without creating issues. So, if you experience
    communication problems, they are probably due to misspelled service URLs. Therefore,
    please double-check the URLs in all calls to the microservice that does not receive
    communications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 网络通常运行良好，不会出现问题。因此，如果你遇到通信问题，它们可能是因为拼写错误的服务 URL。因此，请仔细检查所有调用微服务的 URL，这些微服务没有收到通信。
- en: 'From time to time, we need to test an application with Minikube for the following
    reasons:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要以下原因使用 Minikube 测试应用程序：
- en: Both ReplicaSets and StatefulSets can be tested with Docker and Visual Studio,
    but we are limited to a single POD for each of them.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是 ReplicaSets 还是 StatefulSets，都可以使用 Docker 和 Visual Studio 进行测试，但我们每个都限于一个
    POD。
- en: We must also test the `.yaml` Kubernetes configuration file, which might contain
    more complex objects like ingresses, permanent storage, secrets, and other complex
    configurations.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还必须测试 `.yaml` Kubernetes 配置文件，该文件可能包含更复杂的对象，如入口、持久存储、机密和其他复杂配置。
- en: You might need to integrate your microservices with other modules developed
    by other teams.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要将你的微服务与其他团队开发的模块集成。
- en: Therefore, each developer should spend most of their time testing a few microservices
    that strongly interact among them with the Docker virtual network, but from time
    to time, they should try a wider integration with Minikube. This can be done before
    committing their code at the end of the working day, or just before closing a
    development iteration of the agile application development process.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个开发者应该花大部分时间测试几个相互之间有强烈交互的微服务，但有时，他们应该尝试与 Minikube 进行更广泛的集成。这可以在工作日结束时提交代码之前，或者在敏捷应用程序开发过程的开发迭代即将结束时进行。
- en: Having learned when and how to test the application with Minikube, we must learn
    how to load and run our application on Minikube.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何使用 Minikube 测试应用程序的时间和方式之后，我们必须学习如何在 Minikube 上加载和运行我们的应用程序。
- en: Running your application in Minikube
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Minikube 上运行你的应用程序
- en: When Visual Studio runs your microservices with Docker, it creates special images
    that also contain information needed by the Visual Studio debugger and have a
    `dev` version name. These special images can be run just from Visual Studio, and
    if you try to launch them manually, you will get an error. For the same reason,
    you can’t use them in Minikube.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Visual Studio 使用 Docker 运行您的微服务时，它创建包含 Visual Studio 调试器所需信息的特殊图像，并具有 `dev`
    版本名称。这些特殊图像只能从 Visual Studio 运行，如果您尝试手动启动它们，将会出错。出于同样的原因，您不能在 Minikube 中使用它们。
- en: Therefore, the first step for running your microservice in Minikube is to create
    different “standard” images. You can do this by right-clicking both the `FakeSource`
    and `GrpcMicroService` Docker files in Visual Studio Solution Explorer and by
    selecting **Build Docker Image**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Minikube 中运行您的微服务的第一步是创建不同的“标准”图像。您可以通过在 Visual Studio 解决方案资源管理器中右键单击 `FakeSource`
    和 `GrpcMicroService` Docker 文件，并选择**构建 Docker 图像**来完成此操作。
- en: 'This way, you will create a `grpcmicroservice` and a `fakesource` image, both
    with the `latest` version name, as shown in the image below:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您将创建一个 `grpcmicroservice` 和一个 `fakesource` 图像，它们都具有 `latest` 版本名称，如下面的图像所示：
- en: '![](img/B19820_22_09.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_22_09.png)'
- en: 'Figure 22.9: Creating Minikube-ready Docker images'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.9：创建 Minikube 准备好的 Docker 图像
- en: 'As a next step, you must start Minikube:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，您必须启动 Minikube：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, you must load your Docker images inside of the Minikube images cache with
    the following commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您必须使用以下命令在 Minikube 图像缓存中加载您的 Docker 图像：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can verify that your images have been correctly loaded by listing all the
    images loaded in Minikube:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过列出 Minikube 中加载的所有图像来验证您的图像是否已正确加载：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we need to define a .`yaml` Kubernetes configuration file with two deployments
    and a service that forwards communications to `grpcmicroservice`, which is the
    only microservice acting as a server. Let’s call it `minikubedeploy.yaml`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个包含两个部署和一个将通信转发到作为唯一服务器微服务的 `grpcmicroservice` 的 `.yaml` Kubernetes
    配置文件。让我们称它为 `minikubedeploy.yaml`。
- en: 'The definition of the `grpcmicroservice` deployment is straightforward:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`grpcmicroservice` 部署的定义很简单：'
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code above requires just one replica, but you can experiment with two or
    three replicas. The `ASPNETCORE_HTTP_PORTS` environment variable is a standard
    ASP.NET setting that informs Kestrel on the HTTP port where to listen.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码只需要一个副本，但您可以尝试使用两个或三个副本。`ASPNETCORE_HTTP_PORTS` 环境变量是一个标准的 ASP.NET 设置，它通知
    Kestrel 在哪个 HTTP 端口上监听。
- en: 'The `imagePullPolicy: Never` setting specifies the image caching policy within
    the Kubernetes cluster. It prevents Minikube from trying to download a fresher
    version of the image from the original source into its cache. We need this setting,
    since there is no “original source” containing our image because we uploaded the
    image directly to the Minikube cache with the `minikube image load` command.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`imagePullPolicy: Never` 设置指定了 Kubernetes 集群内的图像缓存策略。它阻止 Minikube 尝试从原始源下载图像的新版本到其缓存中。我们需要此设置，因为我们没有包含我们的图像的“原始源”，因为我们直接使用
    `minikube image load` 命令将图像上传到 Minikube 缓存。'
- en: You must always specify this setting when images are not available in a shared
    image repository but are uploaded directly to the Minikube cache from the Docker
    Desktop local repository. Shared images, instead, do not need to be uploaded manually
    in the Minikube cache but can be simply referenced with their full URL in the
    Kubernetes `.yaml` file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当共享图像库中没有图像，但图像直接从 Docker Desktop 本地库上传到 Minikube 缓存时，您必须始终指定此设置。相反，共享图像不需要手动上传到
    Minikube 缓存，只需在 Kubernetes `.yaml` 文件中使用它们的完整 URL 进行引用即可。
- en: All other settings are quite standard.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他设置都很标准。
- en: 'The definition of the `fakesource` deployment is completely analogous but doesn’t
    contain information about the container ports, since this microservice doesn’t
    act as a server:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakesource` 部署的定义完全类似，但不包含有关容器端口的任何信息，因为此微服务不作为服务器：'
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The definition of the service that forwards communications to `grpcmicroservice`
    is quite standard:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将通信转发到 `grpcmicroservice` 的服务定义相当标准：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You must pay attention only to the port numbers that must be coherent in all
    settings and to the service name, since they will be used in the URLs of all communication
    to the `grpcmicroservice`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须注意的只有必须在一切设置中保持一致的端口号以及服务名称，因为它们将被用于所有通信到 `grpcmicroservice` 的 URL 中。
- en: If the service names match the hostnames in the Docker virtual network, the
    URLs will work both in Kubernetes and the Docker virtual network. So, you don’t
    need to modify any code or configuration to adapt the code that runs in the Docker
    virtual network to Minikube or any other Kubernetes clusters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务名称与 Docker 虚拟网络中的主机名匹配，URL 将在 Kubernetes 和 Docker 虚拟网络中都有效。因此，你不需要修改任何代码或配置来适应在
    Docker 虚拟网络中运行的代码以适应 Minikube 或任何其他 Kubernetes 集群。
- en: The whole `minkubedeploy.yaml` file is available in the `ch22` folder of the
    GitHub repository associated with the book.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 `minkubedeploy.yaml` 文件可在与本书相关的 GitHub 仓库的 `ch22` 文件夹中找到。
- en: 'Now, let’s open a Windows prompt in the folder that contains the `minkubedeploy.yaml`
    file, issuing the command below that will load the application configuration in
    the Minikube cluster:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在包含 `minkubedeploy.yaml` 文件的文件夹中打开一个 Windows 命令提示符，执行以下命令，将在 Minikube
    集群中加载应用程序配置：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, issue the `kubectl get deployment` command to verify that all deployments
    have been correctly defined and are running.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行 `kubectl get deployment` 命令以验证所有部署是否已正确定义并正在运行。
- en: 'You can verify that the application is properly running by inspecting the data
    in the `dbo.Purchases` database table, by right-clicking on the `dbo.Purchases`
    table in **SQL Server Object Explorer**and choosing **View Data**:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查 `dbo.Purchases` 数据库表中的数据来验证应用程序是否正常运行，通过在 **SQL Server 对象资源管理器**中右键单击
    `dbo.Purchases` 表并选择 **查看数据**：
- en: '![](img/B19820_22_10.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_10.png)'
- en: 'Figure 22.10: dbo.Purchases table'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.10：dbo.Purchases 表
- en: Each time you click the table refresh button, you should see new rows added
    to the database table. If new rows do not appear after several refreshes, your
    microservice is probably experiencing some communication problem, or some exception
    was thrown before data was computed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你点击表格刷新按钮时，你应该会看到数据库表中添加了新行。如果经过几次刷新后新行仍未出现，你的微服务可能遇到了一些通信问题，或者数据计算之前抛出了某些异常。
- en: You can discover what the problem is just by debugging the application. The
    next section explains how to verify in detail what is happening in the application,
    with the help of Bridge to Kubernetes. Please do not delete all Kubernetes objects
    created with `minkubedeploy.yaml` because we need the running application to attach
    Bridge to Kubernetes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调试应用程序来发现问题。下一节将解释如何借助 Bridge 到 Kubernetes 详细验证应用程序中发生的情况。请勿删除使用 `minkubedeploy.yaml`
    创建的所有 Kubernetes 对象，因为我们需要运行中的应用程序来附加 Bridge 到 Kubernetes。
- en: Remote debugging a Kubernetes application
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程调试 Kubernetes 应用程序
- en: 'As a final step, we will debug `GrpcMicroService` with Bridge to Kubernetes.
    Let’s set `GrpcMicroService` as a starting project and change the project start
    from **Docker** to **Bridge** **to Kubernetes**, as shown in the image below:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将使用 Bridge 到 Kubernetes 调试 `GrpcMicroService`。让我们将 `GrpcMicroService`
    设置为起始项目，并将项目启动从 **Docker** 更改为 **Bridge** **到 Kubernetes**，如图所示：
- en: '![](img/B19820_22_11.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_11.png)'
- en: 'Figure 22.11: Debugging GrpcMicroService with Bridge to Kubernetes'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.11：使用 Bridge 到 Kubernetes 调试 GrpcMicroService
- en: 'Let’s place a breakpoint in the `GrpcMicroService->HostedServices-> ProcessPurchases.cs`
    file inside of the `if` block, as shown below:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `GrpcMicroService->HostedServices-> ProcessPurchases.cs` 文件中的 `if` 块内放置一个断点，如下所示：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, start debugging. As soon as you click the **run** button, a window appears
    that prompts you to configure Bridge to Kubernetes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，开始调试。一旦你点击**运行**按钮，就会弹出一个窗口，提示你配置 Bridge 到 Kubernetes：
- en: '![](img/B19820_22_12.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_22_12.png)'
- en: 'Figure 22.12: Configuring Bridge to Kubernetes'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.12：配置 Bridge 到 Kubernetes
- en: If the window above doesn’t open, or you can’t see any Minikube node, `Kubectl`
    is probably not working or configured for Minikube. Try issuing a `Kubectl` command
    like `kubectl get all`. If you face any issues, try stopping and restarting Minikube
    with `minikube stop`, followed by `minikube start`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上面的窗口没有打开，或者你看不到任何 Minikube 节点，`Kubectl` 可能未为 Minikube 正常工作或配置。尝试执行一个 `Kubectl`
    命令，如 `kubectl get all`。如果你遇到任何问题，尝试使用 `minikube stop` 停止 Minikube，然后使用 `minikube
    start` 重新启动。
- en: Bridge to Kubernetes prompts us to select a namespace—in our case, `default`—and
    then choose a specific service within that namespace—in our case, `grpmicroservice`.
    All communications to that service will be forwarded to the `GrpcMicroService`
    code running on our development machine. Let’s set up the configuration window,
    as shown in the screenshot above. As soon as you submit your Bridge to Kubernetes
    configuration, debugging will automatically start. In a short time, the breakpoint
    will be hit, and our local copy of the microservice will start interacting with
    the remainder of the code that is running in Minikube!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Bridge to Kubernetes提示我们选择一个命名空间——在我们的例子中是`default`——然后在该命名空间中选择一个特定的服务——在我们的例子中是`grpmicroservice`。所有对该服务的通信都将转发到运行在我们开发机器上的`GrpcMicroService`代码。让我们设置配置窗口，如上图所示。一旦你提交Bridge
    to Kubernetes的配置，调试将自动开始。在短时间内，断点将被触发，我们本地微服务的副本将开始与在Minikube中运行的其余代码进行交互！
- en: After you finish debugging, please restore the project start to **Docker**,
    and restore the simultaneous start of both microservices so that you can continue
    working with the Docker virtual network.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成调试后，请将项目启动恢复到**Docker**，并恢复两个微服务的同时启动，以便你可以在Docker虚拟网络上继续工作。
- en: 'After having finished working with Minikube, you need to remove all objects
    created by `minkubedeploy.yaml` with the command below:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成与Minikube的工作后，你需要使用以下命令删除由`minkubedeploy.yaml`创建的所有对象：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is important to free up resources as soon as you don’t need them anymore;
    otherwise, they will continue wasting CPU time and memory, and if you constantly
    add more and more applications, sooner or later, you will experience performance
    problems on your development machine.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，一旦不再需要资源，就应立即释放它们；否则，它们将继续浪费CPU时间和内存，如果你不断添加更多应用程序，迟早会在你的开发机器上遇到性能问题。
- en: 'If you want to free up Minikube disk space, you can also remove the microservices
    images previously loaded in the Minikube cache with the commands below:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要释放Minikube磁盘空间，你也可以使用以下命令删除之前加载到Minikube缓存中的微服务镜像：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, you need to stop Minikube with:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要使用以下命令停止Minikube：
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained how to prepare a developer workstation for .NET
    Kubernetes development and how to organize code testing and bug-fix cycles.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了如何为.NET Kubernetes开发准备开发工作站以及如何组织代码测试和错误修复周期。
- en: We also explained how to define a Docker virtual network to ensure microservices
    communication during development and name conventions for hostnames and Kubernetes
    services, enabling the same code to run both on the Docker virtual network, Minikube,
    and any other Kubernetes cluster.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还解释了如何定义Docker虚拟网络以确保开发期间微服务之间的通信，以及主机名和Kubernetes服务的命名约定，使得相同的代码可以在Docker虚拟网络、Minikube以及任何其他Kubernetes集群上运行。
- en: Finally, we explained all the steps needed to run an application in Minikube
    and how to test it with Bridge to Kubernetes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解释了在Minikube中运行应用程序所需的全部步骤以及如何使用Bridge to Kubernetes进行测试。
- en: We’ve now reached the end of our journey through this book, and what a journey
    it has been!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了在这本书中的旅程，这是一段多么精彩的旅程啊！
- en: Packed with numerous new and challenging ideas, this book is sure to be your
    good friend on your journey as a software architect.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书充满了许多新颖和具有挑战性的想法，它必定会成为你在软件架构师旅程中的良师益友。
- en: These learnings will not only empower you to craft innovative solutions but
    also support your growth in the dynamic world of software projects. We sincerely
    hope you’ve enjoyed the adventure as much as we have creating this latest edition
    for you.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些学习将不仅赋予你创造创新解决方案的能力，还将支持你在软件项目动态世界中的成长。我们真诚地希望，你享受这次冒险的程度与我们为你创建最新版本的程度一样。
- en: Questions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why can’t the SQL Server installation that comes with Visual Studio be used
    for Kubernetes development?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Visual Studio附带的SQL Server安装不能用于Kubernetes开发？
- en: What is Bridge to Kubernetes?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Bridge to Kubernetes？
- en: Is it true that Bridge to Kubernetes works just with Minikube?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bridge to Kubernetes是否仅与Minikube一起工作？
- en: How do you load the Minikube images cache?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何加载Minikube镜像缓存？
- en: How do we define Minikube as the Kubectl default cluster?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将Minikube定义为Kubectl默认集群？
- en: Further reading
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Most of the references in this chapter are the same as those previously listed
    in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    and *Chapter 14*, *Implementing Microservices with .NET*. Here, it is worth adding
    the link to the official documentation about Bridge to Kubernetes: [https://learn.microsoft.com/en-us/visualstudio/bridge/](https://learn.microsoft.com/en-us/visualstudio/bridge/    )'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大部分参考资料与之前在 *第 11 章*，*将微服务架构应用于您的企业应用* 和 *第 14 章*，*使用 .NET 实现微服务* 中列出的相同。在此，值得添加关于
    Kubernetes 之桥的官方文档链接：[https://learn.microsoft.com/en-us/visualstudio/bridge/](https://learn.microsoft.com/en-us/visualstudio/bridge/)
- en: Learn more on Discord
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
