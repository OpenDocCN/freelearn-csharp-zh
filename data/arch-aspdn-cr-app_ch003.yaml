- en: 2 Automated Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 自动化测试
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file2.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file2.png)'
- en: 'This chapter focuses on automated testing and how helpful it can be for crafting
    better software. It also covers a few different types of tests and the foundation
    of **test-driven development** (**TDD**). We also outline how testable ASP.NET
    Core is and how much easier it is to test ASP.NET Core applications than old ASP.NET
    MVC applications. This chapter overviews automated testing, its principles, xUnit,
    ways to sample test values, and more. While other books cover this topic more
    in-depth, this chapter covers the foundational aspects of automated testing. We
    are using parts of this throughout the book, and this chapter ensures you have
    a strong enough base to understand the samples.In this chapter, we cover the following
    topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍自动化测试及其在构建更好软件方面的帮助。它还涵盖了几种不同类型的测试和**测试驱动开发**（**TDD**）的基础。我们还概述了 ASP.NET
    Core 的可测试性以及测试 ASP.NET Core 应用程序比测试旧版 ASP.NET MVC 应用程序容易多少。本章概述了自动化测试、其原则、xUnit、采样测试值的方法等。虽然其他书籍对此主题有更深入的探讨，但本章涵盖了自动化测试的基础方面。我们在整本书中使用了这些内容，本章确保你有一个足够坚实的基础来理解示例。在本章中，我们涵盖了以下主题：
- en: An overview of automated testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试概述
- en: Testing .NET applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 .NET 应用程序
- en: Important testing principles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的测试原则
- en: Introduction to automated testing
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试简介
- en: 'Testing is an integral part of the development process, and automated testing
    becomes crucial in the long run. You can always run your ASP.NET Core website,
    open a browser, and click everywhere to test your features. That’s a legitimate
    approach, but it is harder to test individual rules or more complex algorithms
    that way. Another downside is the lack of automation; when you first start with
    a small app containing a few pages, endpoints, or features, it may be fast to
    perform those tests manually. However, as your app grows, it becomes more tedious,
    takes longer, and increases the likelihood of making a mistake. Of course, you
    will always need real users to test your applications, but you want those tests
    to focus on the UX, the content, or some experimental features you are building
    instead of bug reports that automated tests could have caught early on.There are
    multiple types of tests and techniques in the testing space. Here is a list of
    three broad categories that represent how we can divide automated testing from
    a code correctness standpoint:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发过程中的一个重要部分，自动化测试在长期来看变得至关重要。你总是可以运行你的 ASP.NET Core 网站，打开浏览器，点击各个地方来测试你的功能。这是一个合法的方法，但这样测试单个规则或更复杂的算法会更困难。另一个缺点是缺乏自动化；当你刚开始使用包含几个页面、端点或功能的小型应用程序时，手动执行这些测试可能很快。然而，随着你的应用程序增长，这变得更加繁琐，耗时更长，并且增加了犯错的几率。当然，你总是需要真实用户来测试你的应用程序，但你希望这些测试专注于
    UX、内容或你正在构建的一些实验性功能，而不是自动化测试本可以早期捕获的错误报告。测试领域有多种测试类型和技术。以下是一个列表，列出了三个广泛的类别，代表了我们可以从代码正确性角度如何划分自动化测试：
- en: Unit tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: End-to-end (E2E) tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端（E2E）测试
- en: Usually, you want a mix of those tests, so you have fast unit tests testing
    your algorithms, slower tests that ensure the integrations between components
    are correct, and slow E2E tests that ensure the correctness of the system as a
    whole.The test pyramid is a good way of explaining a few concepts around automated
    testing. You want different granularity of tests and a different number of tests
    depending on their complexity and speed of execution. The following test pyramid
    shows the three types of tests stated above. However, we could add other types
    of tests in there as well. Moreover, that’s just an abstract guideline to give
    you an idea. The most important aspect is the **return on investment** (**ROI**)
    and execution speed. If you can write one integration test that covers a large
    surface and is fast enough, this might be worth doing instead of multiple unit
    tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望有一系列的测试，包括快速的单元测试来测试你的算法，较慢的测试来确保组件之间的集成正确，以及慢速的端到端测试来确保整个系统的正确性。测试金字塔是一种很好的方式来解释自动化测试的一些概念。你希望根据测试的复杂性和执行速度的不同，拥有不同粒度的测试和不同数量的测试。以下测试金字塔展示了上述三种类型的测试。然而，我们也可以在其中添加其他类型的测试。此外，这只是一个抽象的指导方针，给你一个大致的概念。最重要的方面是**投资回报率**（ROI）和执行速度。如果你能写一个覆盖范围广且足够快的集成测试，这可能比多个单元测试更有价值。
- en: '![Figure 2.1: The test pyramid](img/file3.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：测试金字塔](img/file3.png)'
- en: 'Figure 2.1: The test pyramid'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：测试金字塔
- en: I cannot stress this enough; the execution speed of your tests is essential
    to receive fast feedback and know immediately that you have broken something with
    your code changes. Layering different types of tests allows you to execute only
    the fastest subset often, the not-so-fast occasionally, and the very slow tests
    infrequently. If your test suite is fast-enough, you don’t even have to worry
    about it. However, if you have a lot of manual or E2E UI tests that take hours
    to run, that’s another story (that can cost a lot of money).
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我无法强调这一点；测试的执行速度对于快速获得反馈并立即知道你的代码更改破坏了什么至关重要。分层不同类型的测试允许你经常只执行最快的子集，偶尔执行不那么快的测试，以及很少执行非常慢的测试。如果你的测试套件足够快，你甚至不必担心它。然而，如果你有很多需要数小时运行的手动或端到端UI测试，那又是另一回事（这可能花费大量资金）。
- en: Finally, on top of running your tests using a test runner, like in Visual Studio,
    VS Code, or the CLI, a great way to ensure code quality and leverage your automated
    tests is to run them in a CI pipeline, validating code changes for issues.Tech-wise,
    back when .NET Core was in pre-release, I discovered that the .NET team was using
    xUnit to test their code and that it was the only testing framework available.
    xUnit has become my favorite testing framework since, and we use it throughout
    the book. Moreover, the ASP.NET Core team made our life easier by designing ASP.NET
    Core for testability; testing is easier than before.Why are we talking about tests
    in an architectural book? Because testability is a sign of a good design. It also
    allows us to use tests instead of words to prove some concepts. In many code samples,
    the test cases are the consumers, making the program lighter without building
    an entire user interface and focusing on the patterns we are exploring instead
    of getting our focus scattered over some boilerplate UI code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，除了使用测试运行器运行测试，如Visual Studio、VS Code或CLI之外，确保代码质量并利用自动化测试的一个好方法是，在CI管道中运行它们，验证代码更改以发现问题。从技术角度来看，当.NET
    Core处于预发布阶段时，我发现.NET团队正在使用xUnit来测试他们的代码，并且它是唯一可用的测试框架。自从那时起，xUnit就成了我最喜欢的测试框架，我们在整本书中都使用了它。此外，ASP.NET
    Core团队通过为可测试性设计ASP.NET Core，使我们的生活变得更简单；测试比以前更容易了。为什么在一本架构书中要讨论测试？因为可测试性是良好设计的标志。它还允许我们用测试而不是用文字来证明一些概念。在许多代码示例中，测试用例是消费者，这使得程序更轻量，无需构建整个用户界面，而是专注于我们正在探索的模式，而不是让我们的注意力分散在一些样板UI代码上。
- en: To ensure we do not deviate from the matter at hand, we use automated testing
    moderately in the book, but I strongly recommend that you continue to study it,
    as it will help improve your code and design
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了确保我们不偏离主题，我们在书中适度地使用自动化测试，但我强烈建议你继续学习它，因为它将有助于提高你的代码和设计质量。
- en: Now that we have covered all that, let’s explore those three types of tests,
    starting with unit testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了所有这些，让我们来探索这三种类型的测试，从单元测试开始。
- en: Unit testing
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests focus on individual units, like testing the outcome of a method.
    Unit tests should be fast and not rely on any infrastructure, such as a database.
    Those are the kinds of tests you want the most because they run fast, and each
    one tests a precise code path. They should also help you design your application
    better because you use your code in the tests, so you become its first consumer,
    leading to you finding some design flaws and making your code better. If you don’t
    like using your code in your tests, that is a good indicator that nobody else
    will. Unit tests should focus on testing algorithms (the ins and outs) and domain
    logic, not the code itself; how you wrote the code should have no impact on the
    intent of the test. For example, you are testing that a `Purchase` method executes
    the logic required to purchase one or more items, not that you created the variable
    `X`, `Y`, or `Z` inside that method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试关注于单个单元，比如测试一个方法的结果。单元测试应该是快速的，并且不依赖于任何基础设施，例如数据库。这些是你最想要的测试类型，因为它们运行速度快，每个测试都精确地测试一个代码路径。它们还应该帮助你更好地设计应用程序，因为你在测试中使用了你的代码，所以你成为了它的第一个消费者，这有助于你发现一些设计缺陷，并使你的代码更加完善。如果你不喜欢在测试中使用你的代码，那是一个很好的迹象，表明其他人也不会这样做。单元测试应该专注于测试算法（输入和输出）和领域逻辑，而不是代码本身；你编写代码的方式不应该影响测试的意图。例如，你正在测试一个`Purchase`方法是否执行了购买一个或多个项目的逻辑，而不是测试你在这个方法内部创建了变量`X`、`Y`或`Z`。
- en: Don’t discourage yourself if you find it challenging; writing a good test suite
    is not as easy as it sounds.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你发现这很有挑战性，请不要气馁；编写一个好的测试套件并不像听起来那么简单。
- en: Integration testing
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests focus on the interaction between components, such as what
    happens when a component queries the database or what happens when two components
    interact with each other.Integration tests often require some infrastructure to
    interact with, which makes them slower to run. By following the classic testing
    model, you want integration tests, but you want fewer of them than unit tests.
    An integration test can be very close to an E2E test but without using a production-like
    environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试关注于组件之间的交互，例如当组件查询数据库时会发生什么，或者当两个组件相互交互时会发生什么。集成测试通常需要一些基础设施来与之交互，这使得它们的运行速度较慢。按照经典的测试模型，你想要集成测试，但比单元测试要少。集成测试可以非常接近端到端测试，但不需要使用类似生产环境的测试环境。
- en: We will break the test pyramid rule later, so always be critical of rules and
    principles; sometimes, breaking or bending them can be better. For example, having
    one good integration test can be better than *N* unit tests; don’t discard that
    fact when writing your tests. See also Grey-box testing.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们稍后会打破测试金字塔规则，所以始终对规则和原则持批判态度；有时，打破或弯曲它们可能更好。例如，一个良好的集成测试可能比*N*个单元测试更有价值；在编写测试时不要忽视这个事实。另见灰盒测试。
- en: End-to-end testing
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端到端测试
- en: End-to-end tests focus on application-wide behaviors, such as what happens when
    a user clicks on a specific button, navigates to a particular page, posts a form,
    or sends a `PUT` request to some web API endpoint. E2E tests are usually run on
    infrastructure to test your application and deployment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试关注于应用程序的全局行为，例如当用户点击一个特定的按钮、导航到特定的页面、提交一个表单或向某个Web API端点发送一个`PUT`请求时会发生什么。端到端测试通常在基础设施上运行，以测试你的应用程序和部署。
- en: Other types of tests
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他类型的测试
- en: There are other types of automated tests. For example, we could do load testing,
    performance testing, regression testing, contract testing, penetration testing,
    functional testing, smoke testing, and more. You can automate tests for anything
    you want to validate, but some tests are more challenging to automate or more
    fragile than others, such as UI tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他类型的自动化测试。例如，我们可以进行负载测试、性能测试、回归测试、契约测试、渗透测试、功能测试、冒烟测试等等。你可以自动化验证任何你想要验证的内容，但有些测试自动化起来更具挑战性，或者比其他测试更脆弱，例如UI测试。
- en: 'If you can automate a test in a reasonable timeframe, think ROI: do it! In
    the long run, it should pay off.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你可以在合理的时间内自动化一个测试，考虑一下投资回报率：去做吧！从长远来看，这应该会带来回报。
- en: One more thing; don’t blindly rely on metrics such as code coverage. Those metrics
    make for cute badges in your GitHub project’s `readme.md` file but can lead you
    off track, resulting in you writing useless tests. Don’t get me wrong, code coverage
    is a great metric when used correctly, but remember that one good test can be
    better than a lousy test suite covering 100% of your codebase. If you are using
    code coverage, ensure you and your team are not gaming the system.Writing good
    tests is not easy and comes with practice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点；不要盲目依赖诸如代码覆盖率之类的指标。这些指标在你的GitHub项目的`readme.md`文件中可以成为可爱的徽章，但可能会让你偏离轨道，导致你编写无用的测试。请别误会，代码覆盖率是一个很好的指标，当正确使用时，但它记得一条好的测试胜过覆盖你代码库100%的糟糕测试套件。如果你在使用代码覆盖率，确保你和你的团队没有在玩弄系统。编写好的测试并不容易，需要通过实践来掌握。
- en: 'One piece of advice: keep your test suite healthy by adding missing test cases
    and removing obsolete or useless tests. Think about use case coverage, not how
    many lines of code are covered by your tests.'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一条建议：通过添加缺失的测试用例和删除过时或无用的测试来保持你的测试套件健康。考虑用例覆盖率，而不是你的测试覆盖了多少行代码。
- en: Before moving forward to testing styles, let’s inspect a hypothetical system
    and explore a more efficient way to test it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续测试样式之前，让我们先检查一个假设的系统，并探索一种更有效的方式来测试它。
- en: Picking the right test style
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择合适的测试风格
- en: 'Next is a dependency map of a hypothetical system. We use that diagram to pick
    the most meaningful type of test possible for each piece of the program. In real
    life, that diagram will most likely be in your head, but I drew it out in this
    case. Let’s inspect that diagram before I explain its content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个假设系统的依赖图。我们使用这张图来选择程序每个部分最具有意义的测试类型。在现实生活中，这张图很可能会在你的脑海中，但我在这个例子中把它画出来了。在我解释其内容之前，让我们先检查这张图：
- en: '![Figure 2.2: Dependency map of a hypothetical system](img/file4.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：假设系统的依赖图](img/file4.png)'
- en: 'Figure 2.2: Dependency map of a hypothetical system'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：假设系统的依赖图
- en: 'In the diagram, the **Actor** can be anything from a user to another system.
    **Presentation** is the piece of the system that the **Actor** interacts with
    and forwards the request to the system itself (this could be a user interface).
    **D1** is a component that has to decide what to do next based on the user input.
    **C1** to **C6** are other components of the system (could be classes, for example).
    **DB** is a database.D1 must choose between three code paths: interact with the
    components C1, C4, or C6\. This type of logic is usually a good subject for unit
    tests, ensuring the algorithm yields the correct result based on the input parameter.
    Why pick a unit test? We can quickly test multiple scenarios, edge cases, out-of-bound
    data cases, and more. We usually mock the dependencies away in this type of test
    and assert that the subject under test made the expected call on the desired component.Then,
    if we look at the other code paths, we could write one or more integration tests
    for component C1, testing the whole chain in one go (C1, C5, and C3) instead of
    writing multiple mock-heavy unit tests for each component. If there is any logic
    that we need to test in components C1, C5, or C3, we can always add a few unit
    tests; that’s what they are for.Finally, C4 and C6 are both using C2\. Depending
    on the code (that we don’t have here), we could write integration tests for C4
    and C6, testing C2 simultaneously. Another way would be to unit test C4 and C6,
    and then write integration tests between C2 and the DB. If C2 has no logic, the
    latter could be the best and the fastest, while the former will most likely yield
    results that give you more confidence in your test suite in a continuous delivery
    model.When it is an option, I recommend evaluating the possibility of writing
    fewer meaningful integration tests that assert the correctness of a use case over
    a suite of mock-heavy unit tests. Remember always to keep the execution speed
    in mind.That may seem to go “against” the test pyramid, but does it? If you spend
    less time (thus lower costs) testing more use cases (adding more value), that
    sounds like a win to me. Moreover, we must not forget that mocking dependencies
    tends to make you waste time fighting the framework or other libraries instead
    of testing something meaningful and can add up to a high maintenance cost over
    time.Now that we have explored the fundamentals of automated testing, it is time
    to explore testing approaches and TDD, which is a way to apply those testing concepts.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，**Actor**可以是用户或其他系统。**Presentation**是系统的一部分，**Actor**与之交互并将请求转发给系统本身（这可能是一个用户界面）。**D1**是一个组件，它必须根据用户输入决定下一步要做什么。**C1**到**C6**是系统的其他组件（例如，可以是类）。**DB**是一个数据库。D1必须在三条代码路径中选择：与组件C1、C4或C6交互。这种逻辑通常是一个很好的单元测试主题，确保算法根据输入参数产生正确的结果。为什么选择单元测试？我们可以快速测试多个场景、边缘情况、越界数据情况等。我们通常在这个类型的测试中模拟依赖项，并断言被测试的主题在期望的组件上做出了预期的调用。然后，如果我们看看其他代码路径，我们可以为组件C1编写一个或多个集成测试，一次性测试整个链（C1、C5和C3），而不是为每个组件编写多个重量级的模拟单元测试。如果需要在组件C1、C5或C3中测试任何逻辑，我们总是可以添加一些单元测试；这就是它们的作用。最后，C4和C6都使用C2。根据代码（我们这里没有），我们可以为C4和C6编写集成测试，同时测试C2。另一种方法是单元测试C4和C6，然后编写C2和数据库之间的集成测试。如果C2没有逻辑，后者可能是最好和最快的，而前者很可能会在持续交付模型中给出更有信心测试套件的结果。当有这个选项时，我建议评估编写更少的具有意义的集成测试的可能性，这些测试断言用例套件中用例的正确性，而不是编写大量的重量级模拟单元测试。记住，始终要考虑执行速度。这看起来可能“违反”了测试金字塔，但它吗？如果你花更少的时间（从而降低成本）测试更多的用例（增加更多的价值），对我来说这似乎是一个胜利。此外，我们不应忘记，模拟依赖项往往会让你浪费时间与框架或其他库作斗争，而不是测试有意义的东西，这可能会随着时间的推移增加维护成本。现在我们已经探讨了自动化测试的基础，是时候探索测试方法和TDD了，这是一种应用这些测试概念的方法。
- en: Testing approaches
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试方法
- en: There are various approaches to testing, such as **behavior-driven development**
    (**BDD**), **acceptance test-driven development** (**ATDD**), and **test-driven
    development** (**TDD)**. The DevOps culture brings a mindset that embraces automated
    testing in line with its **continuous integration** (**CI**) and **continuous
    deployment** (**CD**) ideals. We can enable CD with a robust and healthy suite
    of tests that gives a high degree of confidence in our code, high enough to deploy
    the program when all tests pass without fear of introducing a bug.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有多种方法，例如 **行为驱动开发**（**BDD**）、**验收测试驱动开发**（**ATDD**）和**测试驱动开发**（**TDD**）。DevOps
    文化带来了一种心态，它拥抱与 **持续集成**（**CI**）和 **持续部署**（**CD**）理念一致的自动化测试。我们可以通过一个强大且健康的测试套件来实现
    CD，这为我们提供了对代码的高度信心，足够高以至于在所有测试通过时可以部署程序，而不必担心引入错误。
- en: TDD
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD
- en: 'TDD is a software development method that states that you should write one
    or more tests before writing the actual code. In a nutshell, you invert your development
    flow by following the **Red-Green-Refactor** technique, which goes like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是一种软件开发方法，它指出你应该在编写实际代码之前编写一个或多个测试。简而言之，你通过遵循 **红-绿-重构** 技术来反转你的开发流程，其过程如下：
- en: You write a failing test (red).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你编写一个失败的测试（红色）。
- en: You write just enough code to make your test pass (green).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你只需编写足够的代码来使你的测试通过（绿色）。
- en: You refactor that code to improve the design by ensuring all the tests pass.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你重构这段代码，通过确保所有测试通过来改进设计。
- en: We explore the meaning of **refactoring** next.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在下一节探讨 **重构** 的含义。
- en: ATDD
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ATDD
- en: ATDD is similar to TDD but focuses on acceptance (or functional) tests instead
    of software units and involves multiple parties like customers, developers, and
    testers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ATDD 与 TDD 类似，但侧重于验收（或功能）测试，而不是软件单元，并涉及多个参与者，如客户、开发人员和测试人员。
- en: BDD
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BDD
- en: 'BDD is another complementary technique originating from TDD and ATDD. BDD focuses
    on formulating test cases around application behaviors using spoken language and
    involves multiple parties like customers, developers, and testers. Moreover, practitioners
    of BDD often leverage the *given–when–then* grammar to formalize their test cases.
    Because of that, BDD output is in a human-readable format allowing stakeholders
    to consult such artifacts.The given–when–then template defines the way to describe
    the behavior of a user story or acceptance test, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 是源自 TDD 和 ATDD 的另一种补充技术。BDD 侧重于使用口语化语言来制定围绕应用程序行为的测试用例，并涉及多个参与者，如客户、开发人员和测试人员。此外，BDD
    实践者经常利用 *给定-当-然后* 语法来规范化他们的测试用例。正因为如此，BDD 的输出以人类可读的格式呈现，允许利益相关者查阅此类工件。给定-当-然后模板定义了描述用户故事或验收测试行为的方式，如下所示：
- en: '*Given* one or more preconditions (context)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*给定* 一个或多个先决条件（上下文）'
- en: '*When* something happens (behavior)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当* 发生某些事情（行为）'
- en: '*Then* one or more observable changes are expected (measurable side effects)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*然后* 预期一个或多个可观察的变化（可衡量的副作用）'
- en: ATDD and BDD are great areas to dig deeper into and can help design better apps;
    defining precise user-centric specifications can help build only what is needed,
    prioritize better, and improve communication between parties. For the sake of
    simplicity, we stick to unit testing, integration testing, and a tad of TDD in
    the book. Nonetheless, let’s go back to the main track and define refactoring.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ATDD 和 BDD 是深入挖掘的绝佳领域，可以帮助设计更好的应用程序；定义精确的用户中心规格可以帮助构建所需的内容，更好地进行优先级排序，并改善各方之间的沟通。为了简单起见，我们在书中坚持单元测试、集成测试和一点
    TDD。不过，让我们回到主要轨道上，并定义重构。
- en: Refactoring
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构
- en: Refactoring is about (continually) improving the code without changing its behavior.An
    automated test suite should help you achieve that goal and should help you discover
    when you break something. No matter whether you do TDD or not, I do recommend
    refactoring as often as possible; this helps clean your codebase, and it should
    also help you get rid of some technical debt at the same time.Okay, but what is
    **technical debt**?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是关于（持续）改进代码而不改变其行为。一个自动化的测试套件应该帮助你实现这一目标，并帮助你发现何时破坏了某些东西。无论你是否做 TDD，我都建议尽可能多地重构；这有助于清理你的代码库，同时也有助于你消除一些技术债务。好的，但什么是
    **技术债务**？
- en: Technical debt
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术债务
- en: '**Technical debt** represents the corners you cut short while developing a
    feature or a system. That happens no matter how hard you try because life is life,
    and there are delays, deadlines, budgets, and people, including developers (yes,
    that’s you and me).The most crucial point is understanding that you cannot avoid
    technical debt altogether, so it’s better to embrace that fact and learn to live
    with it instead of fighting it. From that point forward, you can only try to limit
    the amount of technical debt you, or someone else, generate and ensure to always
    refactor some of it over time each sprint (or the unit of time that fits your
    projects/team/process).One way to limit the piling up of technical debt is to
    refactor the code often. So, factor the refactoring time into your time estimates.
    Another way is to improve collaboration between all the parties involved. Everyone
    must work toward the same goal if you want your projects to succeed.You will sometimes
    cut the usage of best practices short due to external forces like people or time
    constraints. The key is coming back at it as soon as possible to repay that technical
    debt, and automated tests are there to help you refactor that code and eliminate
    that debt elegantly. Depending on the size of your workplace, there will be more
    or less people between you and that decision.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术债务**代表在开发功能或系统时你省略的角落。无论你多么努力，这都是不可避免的，因为生活就是生活，会有延误、截止日期、预算和人员，包括开发者（是的，那也包括我和你）。最关键的是理解你无法完全避免技术债务，所以最好是接受这个事实，学会与之共存而不是与之抗争。从那时起，你只能尝试限制你或其他人产生的技术债务量，并确保在每个冲刺（或适合你项目/团队/流程的时间单位）中始终重构其中的一部分。限制技术债务积累的一种方法就是经常重构代码。因此，将重构时间纳入你的时间估算中。另一种方法是提高所有相关方的协作。如果你想使你的项目成功，每个人都必须朝着同一个目标努力。有时，由于外部因素如人员或时间限制，你可能会缩短最佳实践的运用。关键是尽快回来偿还那笔技术债务，而自动化测试正是帮助你重构代码和优雅地消除债务的工具。根据你工作场所的大小，你与那个决策之间的人数会有多或少。'
- en: Some of these things might be out of your control, so you may have to live with
    more technical debt than you had hoped. However, even when things are out of your
    control, nothing stops you from becoming a pioneer and working toward improving
    the enterprise’s culture. Don’t be afraid to become an agent of change and lead
    the charge.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其中一些事情可能超出了你的控制范围，所以你可能不得不忍受比你希望更多的技术债务。然而，即使事情超出了你的控制范围，也没有什么能阻止你成为先驱并致力于改善企业的文化。不要害怕成为变革的代理人并带头。
- en: Nevertheless, don’t let the technical debt pile up too high, or you may not
    be able to pay it back, and at some point, that’s where a project begins to break
    and fail. Don’t be mistaken; a project in production can be a failure. Delivering
    a product does not guarantee success, and I’m talking about the quality of the
    code here, not the amount of generated revenue (I’ll leave that to other people
    to evaluate).Next, we look at different ways to write tests, requiring more or
    less knowledge of the inner working of the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要让技术债务积累得太高，否则你可能无法偿还，到某个时候，项目就开始破裂和失败。不要误解；一个在生产中的项目可能就是失败的。交付产品并不能保证成功，我在这里谈论的是代码的质量，而不是产生的收入（我将那留给其他人来评估）。接下来，我们来看看不同的测试编写方式，这需要更多或更少的对代码内部工作的了解。
- en: Testing techniques
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试技术
- en: Here we look at different ways to approach our tests. Should we know the code?
    Should we test user inputs and compare them against the system results? How to
    identify a proper value sample? Let’s start with white-box testing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们来看看不同的测试方法。我们应该了解代码吗？我们应该测试用户输入并将其与系统结果进行比较吗？如何确定合适的值样本？让我们从白盒测试开始。
- en: White-box testing
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 白盒测试
- en: White-box testing is a software testing technique that uses knowledge of the
    internal structure of the software to design tests. We can use white-box testing
    to find defects in the software’s logic, data structures, and algorithms.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试是一种软件测试技术，它使用对软件内部结构的了解来设计测试。我们可以使用白盒测试来发现软件逻辑、数据结构和算法中的缺陷。
- en: This type of testing is also known as clear-box testing, open-box testing, transparent-box
    testing, glass-box testing, and code-based testing.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种测试也被称为清晰盒测试、开放盒测试、透明盒测试、玻璃盒测试和基于代码的测试。
- en: Another benefit of white-box testing is that it can help optimize the code.
    By reviewing the code to write tests, developers can identify and improve inefficient
    code structures, improving overall software performance. The developer can also
    improve the application design by finding architectural issues while testing the
    code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试的另一个好处是它可以帮助优化代码。通过审查代码来编写测试，开发者可以识别并改进低效的代码结构，从而提高整体软件性能。开发者还可以在测试代码时发现架构问题，从而改进应用程序设计。
- en: White-box testing encompasses most unit and integration tests.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 白盒测试涵盖了大多数单元和集成测试。
- en: Next, we look at black-box testing, the opposite of white-box testing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看黑盒测试，它是白盒测试的对立面。
- en: Black-box testing
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: 'Black-box testing is a software testing method where a tester examines an application’s
    functionality without knowing the internal structure or implementation details.
    This form of testing focuses solely on the inputs and outputs of the system under
    test, treating the software as a “black box” that we can’t see into.The main goal
    of black-box testing is to evaluate the system’s behavior against expected results
    based on requirements or user stories. Developers writing the tests do not need
    to know the codebase or the technology stack used to build the software.We can
    use black-box testing to assess the correctness of several types of requirements,
    like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试是一种软件测试方法，测试人员检查应用程序的功能，而不了解其内部结构或实现细节。这种测试形式仅关注受测系统的输入和输出，将软件视为一个“黑盒”，我们无法窥视。黑盒测试的主要目标是根据需求或用户故事评估系统行为是否符合预期结果。编写测试的开发者不需要了解代码库或用于构建软件的技术栈。我们可以使用黑盒测试来评估多种类型的需求的正确性，例如：
- en: '**Functional testing**: This type of testing is related to the software’s functional
    requirements, emphasizing what the system does, a.k.a. behavior verification.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**功能测试**：这种测试与软件的功能需求相关，强调系统做什么，即行为验证。'
- en: '**Non-functional testing**: This type of testing is related to non-functional
    requirements such as performance, usability, reliability, and security, a.k.a.
    performance evaluation.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非功能性测试**：这种测试与非功能性需求相关，如性能、可用性、可靠性和安全性，即性能评估。'
- en: '**Regression testing**: This type of testing ensures the new code does not
    break existing functionalities, a.k.a. change impact.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回归测试**：这种测试确保新代码不会破坏现有功能，即变更影响。'
- en: Next, let’s explore a hybrid between white-box and black-box testing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索白盒测试和黑盒测试之间的混合技术。
- en: Grey-box testing
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灰盒测试
- en: Grey-box testing is a blend between white-box and black-box testing. Testers
    need only partial knowledge of the application’s internal workings and use a combination
    of the software’s internal structure and external behavior to craft their tests.We
    implement grey-box testing use cases in *Chapter 16*, *Request-Endpoint-Response
    (REPR)*. Meanwhile, let’s compare the three techniques.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 灰盒测试是白盒测试和黑盒测试的结合。测试人员只需要了解应用内部工作的一部分，并使用软件的内部结构和外部行为相结合来构建他们的测试。我们在第16章中实现了灰盒测试用例，即*请求-端点-响应（REPR）*。同时，让我们比较一下这三种技术。
- en: White-box vs. Black-box vs. Grey-box testing
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 白盒测试与黑盒测试及灰盒测试的比较
- en: 'To start with a concise comparison, here’s a table that compares the three
    broad techniques:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行简洁的比较，这里有一个表格，比较了三种主要技术：
- en: '| **Feature** | **Whitebox Testing** | **Blackbox Testing** | **Gray-box Testing**
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **白盒测试** | **黑盒测试** | **灰盒测试** |'
- en: '| Definition | Testing based on the internal design of the software | Testing
    based on the behavior and functionality of the software | Testing that combines
    the internal design and behavior of the software |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 定义 | 基于软件内部设计的测试 | 基于软件行为和功能的测试 | 结合软件内部设计和行为的测试 |'
- en: '| Knowledge of code required | Yes | No | Yes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 是否需要了解代码 | 是 | 否 | 是 |'
- en: '| Types of defects found | Logic, data structure, architecture, and performance
    issues | Functionality, usability, performance, and security issues | Most types
    of issues |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 发现的缺陷类型 | 逻辑、数据结构、架构和性能问题 | 功能性、可用性、性能和安全问题 | 大多数类型的问题 |'
- en: '| Coverage per test | Small; targeted on a unit | Large; targeted on a use
    case | Up to large; can vary in scope |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 每个测试的覆盖率 | 小；针对单元 | 大；针对用例 | 大；范围可变 |'
- en: '| Testers | Usually performed by developers. | Testers can write the tests
    without specific technical knowledge of the application’s internal structure.
    | Developers can write the tests, while testers also can with some knowledge of
    the code. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 测试人员 | 通常由开发者执行。 | 测试人员可以编写测试，而无需了解应用程序内部结构的特定技术知识。 | 开发者可以编写测试，同时测试人员也可以在了解一些代码知识的情况下进行。
    |'
- en: '| When to use each style? | Write unit tests to validate complex algorithms
    or code that yields multiple results based on many inputs. These tests are usually
    high-speed so you can have many of them. | Write if you have specific scenarios
    you want to test, like UI tests, or if testers and developers are two distinct
    roles in your organization. These usually run the slowest and require you to deploy
    the application to test it. You want as few as possible to improve the feedback
    time. | Write to avoid writing black-box or white-box tests. Layer the tests to
    cover as much as possible with as few tests as possible. Depending on the application’s
    architecture, this type of test can yield optimal results for many scenarios.
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 何时使用每种风格？ | 编写单元测试以验证复杂算法或基于许多输入产生多个结果的代码。这些测试通常运行速度很快，因此你可以有很多这样的测试。 | 如果你有特定的场景想要测试，比如UI测试，或者如果你的组织中将测试人员和开发者视为两个不同的角色，那么就编写测试。这些测试通常运行得最慢，需要你部署应用程序以进行测试。你希望尽可能少地编写测试，以改善反馈时间。
    | 编写测试以避免编写黑盒或白盒测试。分层测试以尽可能少地使用测试覆盖尽可能多的内容。根据应用程序的架构，这种类型的测试可以为许多场景产生最佳结果。 |'
- en: Let’s conclude next and explore a few advantages and disadvantages of each technique.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下，并探讨每种技术的优缺点。
- en: Conclusion
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: White-box testing includes unit and integration tests. Those tests run fast,
    and developers use them to improve the code and test complex algorithms. However,
    writing a large quantity of those tests takes time. Writing brittle tests that
    are tightly coupled with the code itself is easier due to the proximity to the
    code, increasing the maintenance cost of such test suites. It also makes it prone
    to overengineering your application in the name of testability.Black-box testing
    encompasses different types of tests that tend towards end-to-end testing. Since
    the tests target the external surface of the system, they are less likely to break
    when the system changes. Moreover, they are excellent at testing behaviors, and
    since each test tests an end-to-end use case, we need fewer of them, leading to
    a decrease in writing time and maintenance costs. Testing the whole system has
    drawbacks, including the slowness of executing each test, so combining black-box
    testing with other types of tests is very important to find the right balance
    between the number of tests, test case coverage, and speed of execution of the
    tests.Grey-box testing is a fantastic mix between the two others; you can treat
    any part of the software as a black box, leverage your inner-working knowledge
    to mock or stub parts of the test case (like to assert if the system persisted
    a record in the database), and test end-to-end scenarios more efficiently. It
    brings the best of both worlds, significantly reducing the number of tests while
    increasing the test surface considerably for each test case. However, doing grey-box
    testing on smaller units or heavily mocking the system may yield the same drawbacks
    as white-box testing. Integration tests or almost-E2E tests are good candidates
    for grey-box testing. We implement grey-box testing use cases in *Chapter 16*,
    *Request-Endpoint-Response (REPR)*. Meanwhile, let’s explore a few techniques
    to help optimize our test case creation by applying different techniques, like
    testing a small subset of values to assert the correctness of our programs by
    writing an optimal number of tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试包括单元测试和集成测试。这些测试运行速度快，开发者使用它们来改进代码和测试复杂算法。然而，编写大量此类测试需要花费时间。由于与代码的紧密耦合，编写与代码本身紧密耦合的脆弱测试更容易，这增加了此类测试套件的维护成本。这也使得应用在测试可访问性的名义下过度工程化。黑盒测试涵盖了不同类型的测试，这些测试倾向于端到端测试。由于测试针对系统的外部表面，当系统发生变化时，它们不太可能中断。此外，它们在测试行为方面非常出色，并且由于每个测试都测试一个端到端用例，因此我们需要更少的测试，这导致编写时间和维护成本降低。测试整个系统有缺点，包括执行每个测试的缓慢，因此将黑盒测试与其他类型的测试相结合非常重要，以找到测试数量、测试用例覆盖率和测试执行速度之间的正确平衡。灰盒测试是两种其他测试的绝佳混合；你可以将软件的任何部分视为黑盒，利用你的内部知识来模拟或存根测试用例的部分（例如，断言系统是否在数据库中持久化记录），并更有效地测试端到端场景。它带来了两者的最佳之处，在显著减少测试数量的同时，大大增加了每个测试用例的测试面。然而，在较小的单元上进行灰盒测试或过度模拟系统可能会产生与白盒测试相同的缺点。集成测试或几乎端到端测试是灰盒测试的良好候选者。我们在*第16章*，*请求-端点-响应（REPR）*中实现了灰盒测试用例。同时，让我们探索一些技术，通过应用不同的技术，如测试一小部分值以通过编写最优数量的测试来断言程序的正确性，来帮助优化我们的测试用例创建。
- en: Test case creation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用例创建
- en: 'Multiple ways exist to break down and create test cases to help find software
    defects with a minimal test count. Here are some techniques to help minimize the
    number of tests while maximizing the test coverage:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种方法可以将测试用例分解和创建，以帮助以最小的测试数量找到软件缺陷。以下是一些技术，可以帮助最小化测试数量同时最大化测试覆盖率：
- en: Equivalence Partitioning
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等价类划分
- en: Boundary Value Analysis
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界值分析
- en: Decision Table Testing
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策表测试
- en: State Transition Testing
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态转换测试
- en: Use Case Testing
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例测试
- en: I present the techniques theoretically. They apply to all sorts of tests and
    should help you write better test suites. Let’s have a quick look at each.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我从理论上介绍这些技术。它们适用于所有类型的测试，并应有助于你编写更好的测试套件。让我们快速看一下每个技术。
- en: Equivalence Partitioning
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等价类划分
- en: 'This technique divides the input data of the software into different equivalence
    data classes and then tests these classes rather than individual inputs. An equivalence
    data class means that all values in that partition set should lead to the same
    outcome or yield the same result. Doing this allows for limiting the number of
    tests considerably.For example, consider an application that accepts an integer
    value between 1 and 100 (inclusive). Using equivalence partitioning, we can divide
    the input data into two equivalence classes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将软件的输入数据划分为不同的等价数据类，然后对这些类进行测试，而不是对单个输入进行测试。等价数据类意味着该分区集中的所有值都应该导致相同的结果或产生相同的结果。这样做可以显著减少测试的数量。例如，考虑一个接受介于1到100（包含）之间的整数值的应用程序。使用等价分区，我们可以将输入数据划分为两个等价类：
- en: Valid
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效
- en: Invalid
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效
- en: 'To be more precise, we could further divide it into three equivalence classes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确，我们可以进一步将其划分为三个等价类：
- en: 'Class 1: Less than 1 (Invalid)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1类：小于1（无效）
- en: 'Class 2: Between 1 and 100 (Valid)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2类：介于1和100之间（有效）
- en: 'Class 3: Greater than 100 (Invalid)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3类：大于100（无效）
- en: Then we can write three tests, picking one representative from each class (e.g.,
    0, 50, and 101) to create our test cases. Doing so ensures a broad coverage with
    minimal test cases, making our testing process more efficient.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写三个测试，从每个类别中选取一个代表（例如，0、50和101）来创建我们的测试用例。这样做确保了广泛的覆盖范围，同时测试用例数量最少，使我们的测试过程更加高效。
- en: Boundary Value Analysis
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界值分析
- en: This technique focuses on the values at the boundary of the input domain rather
    than the center. This technique is based on the principle that errors are most
    likely to occur at the boundaries of the input domain.The **input domain** represents
    the set of all possible inputs for a system. The **boundaries** are the edges
    of the input domain, representing minimum and maximum values.For example, if we
    expect a function to accept an integer between 1 and 100 (inclusive), the boundary
    values would be 1 and 100\. With Boundary Value Analysis, we would create test
    cases for these values, values just outside the boundaries (like 0 and 101), and
    values just inside the boundaries (like 2 and 99).Boundary Value Analysis is a
    very efficient testing technique that provides good coverage with a relatively
    small number of test cases. However, it’s unsuitable for finding errors within
    the boundaries or for complex logic errors. Boundary Value Analysis should be
    used on top of other testing methods, such as equivalence partitioning and decision
    table testing, to ensure the software is as defect-free as possible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术侧重于输入域边界的值，而不是中心。这种技术基于这样一个原则，即错误最有可能发生在输入域的边界。**输入域**代表系统所有可能的输入集合。**边界**是输入域的边缘，代表最小和最大值。例如，如果我们期望一个函数接受介于1到100（包含）之间的整数，边界值将是1和100。使用边界值分析，我们会为这些值、边界外的值（如0和101）以及边界内的值（如2和99）创建测试用例。边界值分析是一种非常高效的测试技术，它以相对较少的测试用例提供了良好的覆盖范围。然而，它不适合查找边界内的错误或复杂逻辑错误。边界值分析应该在等价分区和决策表测试等其他测试方法之上使用，以确保软件尽可能无缺陷。
- en: Decision Table Testing
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决策表测试
- en: 'This technique uses a decision table to design test cases. A decision table
    is a table that shows all possible combinations of input values and their corresponding
    outputs.It’s handy for complex business rules that can be expressed in a table
    format, enabling testers to identify missing and extraneous test cases.For example,
    our system only allows access to a user with a valid username and password. Moreover,
    the system denies access to users when it is under maintenance. The decision table
    would have three conditions (username, password, and maintenance) and one action
    (allow access). The table would list all possible combinations of these conditions
    and the expected action for each combination. Here is an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用决策表来设计测试用例。决策表是一个显示所有可能的输入值组合及其对应输出的表格。对于可以用表格格式表示的复杂业务规则来说，它非常方便，使测试人员能够识别缺失和多余的测试用例。例如，我们的系统只允许具有有效用户名和密码的用户访问。此外，当系统处于维护状态时，系统拒绝用户访问。决策表将包含三个条件（用户名、密码和维护）和一个动作（允许访问）。表格将列出这些条件的所有可能组合以及每个组合的预期动作。以下是一个示例：
- en: '| **Valid Username** | **Valid Password** | **System under Maintenance** |
    **Allow Access** |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **有效用户名** | **有效密码** | **系统处于维护状态** | **允许访问** |'
- en: '| True | True | False | Yes |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 是 | 是 | 否 | 是 |'
- en: '| True | True | True | No |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 是 | 是 | 是 | 否 |'
- en: '| True | False | False | No |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 正确 | 错误 | 错误 | 否 |'
- en: '| True | False | True | No |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 正确 | 错误 | 正确 | 否 |'
- en: '| False | True | False | No |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 正确 | 错误 | 否 |'
- en: '| False | True | True | No |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 正确 | 正确 | 否 |'
- en: '| False | False | False | No |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 错误 | 错误 | 否 |'
- en: '| False | False | True | No |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 错误 | 正确 | 否 |'
- en: The main advantage of Decision Table Testing is that it ensures we test all
    possible input combinations. However, it can become complex and challenging to
    manage when systems have many input conditions, as the number of rules (and therefore
    test cases) increases exponentially with the number of conditions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 决策表测试的主要优势在于它确保我们测试了所有可能的输入组合。然而，当系统具有许多输入条件时，它可能会变得复杂且难以管理，因为规则的数量（因此是测试用例的数量）会随着条件的数量呈指数增长。
- en: State Transition Testing
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态转换测试
- en: We usually use State Transition Testing to test software with a state machine
    since it tests the different system states and their transitions. It’s handy for
    systems where the system behavior can change based on its current state. For example,
    a program with states like “logged in” or “logged out”.To perform State Transition
    Testing, we need to identify the states of the system and then the possible transitions
    between the states. For each transition, we need to create a test case. The test
    case should test the software with the specified input values and verify that
    the software transitions to the correct state. For example, a user with the state
    “logged in” must transition to the state “logged out” after signing out.The main
    advantage of State Transition Testing is that it tests sequences of events, not
    just individual events, which could reveal defects not found by testing each event
    in isolation. However, State Transition Testing can become complex and time-consuming
    for systems with many states and transitions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用状态转换测试来测试具有状态机的软件，因为它测试了不同的系统状态及其转换。这对于系统行为可以根据其当前状态改变的情况非常有用。例如，具有“已登录”或“已登出”等状态的程序。为了执行状态转换测试，我们需要确定系统的状态以及状态之间的可能转换。对于每个转换，我们需要创建一个测试用例。测试用例应该使用指定的输入值测试软件，并验证软件是否转换到正确的状态。例如，处于“已登录”状态的用户在登出后必须转换到“已登出”状态。状态转换测试的主要优势在于它测试了事件序列，而不仅仅是单个事件，这可能会揭示在单独测试每个事件时未发现的缺陷。然而，对于具有许多状态和转换的系统，状态转换测试可能会变得复杂且耗时。
- en: Use Case Testing
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例测试
- en: This technique validates that the system behaves as expected when used in a
    particular way by a user. Use cases could have formal descriptions, be user stories,
    or take any other form that fits your needs.A use case involves one or more actors
    executing steps or taking actions that should yield a particular result. A use
    case can include inputs and expected outputs. For example, when a user (actor)
    that is “signed in” (precondition) clicks the “sign out” button (action), then
    navigates to the profile page (action), the system denies access to the page and
    redirects the users to the sign in page, displaying an error message (expected
    behaviors).Use case testing is a systematic and structured approach to testing
    that helps identify defects in the software’s functionality. It is very user-centric,
    ensuring the software meets the users’ needs. However, creating test cases for
    complex use cases can be difficult. In the case of a user interface, the time
    to execute end-to-end tests of use cases can take a long time, especially as the
    number of tests grows.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通过验证系统在用户以特定方式使用时是否按预期行为来验证系统。用例可以具有正式的描述，可以是用户故事，或者采取任何适合您需求的其他形式。用例涉及一个或多个参与者执行步骤或采取应产生特定结果的操作。用例可以包括输入和预期输出。例如，当“已登录”状态的用户（参与者）点击“登出”按钮（操作），然后导航到个人资料页面（操作）时，系统拒绝访问页面并将用户重定向到登录页面，显示错误消息（预期行为）。用例测试是一种系统化和结构化的测试方法，有助于识别软件功能中的缺陷。它非常以用户为中心，确保软件满足用户的需求。然而，为复杂的用例创建测试用例可能会很困难。在用户界面的情况下，执行用例端到端测试的时间可能会很长，尤其是随着测试数量的增加。
- en: It is an excellent approach to think of your test cases in terms of functionality
    to test, whether using a formal use case or just a line written on a napkin. The
    key is to test behaviors, not code.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将您的测试用例视为要测试的功能，无论是使用正式的用例还是只是在餐巾纸上写的一行字，都是一个很好的思考方式。关键是测试行为，而不是代码。
- en: Now that we have explored these techniques, it is time to introduce the xUnit
    library, ways to write tests, and how tests are written in the book. Let’s start
    by creating a test project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了这些技术，是时候介绍xUnit库、编写测试的方法以及书中如何编写测试了。让我们先创建一个测试项目。
- en: How to create an xUnit test project
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何创建xUnit测试项目
- en: To create a new xUnit test project, you can run the `dotnet new xunit` command,
    and the CLI does the job for you by creating a project containing a `UnitTest1`
    class. That command does the same as creating a new xUnit project from Visual
    Studio.For unit testing projects, name the project the same as the project you
    want to test and append `.Tests` to it. For example, `MyProject` would have a
    `MyProject.Tests` project associated with it. We explore more details in the *Organizing
    your tests* section below.The template already defines all the required NuGet
    packages, so you can start testing immediately after adding a reference to your
    project under test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的xUnit测试项目，你可以运行 `dotnet new xunit` 命令，CLI会为你创建一个包含 `UnitTest1` 类的项目。这个命令与从Visual
    Studio创建一个新的xUnit项目做的是同样的事情。对于单元测试项目，将项目命名为你想要测试的项目名称，并在其后添加 `.Tests`。例如，`MyProject`
    将会有一个与之关联的 `MyProject.Tests` 项目。我们将在下面的 *组织你的测试* 部分中探讨更多细节。模板已经定义了所有必需的NuGet包，因此你可以在将测试项目添加到你的测试项目后立即开始测试。
- en: 'You can also add project references using the CLI with the `dotnet add reference`
    command. Assuming we are in the `./test/MyProject.Tests` directory and the project
    file we want to reference is in the `./src/MyProject` directory; we can execute
    the following command to add a reference:'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你也可以使用CLI的 `dotnet add reference` 命令添加项目引用。假设我们位于 `./test/MyProject.Tests` 目录，并且我们想要引用的项目文件位于
    `./src/MyProject` 目录；我们可以执行以下命令来添加引用：
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we explore some xUnit features that will allow us to write test cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些xUnit特性，这将使我们能够编写测试用例。
- en: Key xUnit features
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键的xUnit特性
- en: In xUnit, the `[Fact]` attribute is the way to create unique test cases, while
    the `[Theory]` attribute is the way to make data-driven test cases. Let’s start
    with facts, the simplest way to write a test case.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在xUnit中，`[Fact]` 属性是用来创建独特测试用例的方式，而 `[Theory]` 属性是用来创建数据驱动测试用例的方式。让我们从事实开始，这是编写测试用例最简单的方式。
- en: Facts
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事实
- en: 'Any method with no parameter can become a test method by decorating it with
    a `[Fact]` attribute, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 任何没有参数的方法都可以通过添加 `[Fact]` 属性来成为一个测试方法，就像这样：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also decorate asynchronous methods with the fact attribute when the
    code under test needs it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试代码需要时，你还可以用事实属性装饰异步方法：
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, the highlighted line conceptually represents an asynchronous
    operation and does nothing more than allow using the `async`/`await` keywords.When
    we run the tests from Visual Studio’s Test Explorer, the test run result looks
    like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，高亮显示的行在概念上表示一个异步操作，它所做的只是允许使用 `async`/`await` 关键字。当我们从Visual Studio的测试资源管理器运行测试时，测试运行结果看起来像这样：
- en: '![Figure 2.3: Test results in Visual Studio](img/file5.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：Visual Studio中的测试结果](img/file5.png)'
- en: 'Figure 2.3: Test results in Visual Studio'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Visual Studio中的测试结果
- en: 'You may have noticed from the screenshot that the test classes are nested in
    the `xUnitFeaturesTest` class, part of the `MyApp` namespace, and under the `MyApp.Tests`
    project. We explore those details later in the chapter.Running the `dotnet test`
    CLI command should yield a result similar to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从截图注意到测试类嵌套在 `xUnitFeaturesTest` 类中，它是 `MyApp` 命名空间的一部分，并且位于 `MyApp.Tests`
    项目下。我们将在本章后面探讨这些细节。运行 `dotnet test` CLI命令应该会产生类似于以下的结果：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can read from the preceding output, all tests are passing, none have failed,
    and none were skipped. It is as simple as that to create test cases using xUnit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中我们可以看出，所有测试都通过了，没有失败的，也没有跳过的。使用xUnit创建测试用例就这么简单。
- en: Learning the CLI can be very helpful in creating and debugging CI/CD pipelines,
    and you can use them, like the `dotnet test` command, in any script (like bash
    and PowerShell).
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 学习CLI对于创建和调试CI/CD管道非常有帮助，你可以在任何脚本（如bash和PowerShell）中使用它们，就像使用 `dotnet test`
    命令一样。
- en: Have you noticed the `Assert` keyword in the test code? If you are not familiar
    with it, we will explore assertions next.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到测试代码中的 `Assert` 关键字？如果你不熟悉它，我们将在下一节探讨断言。
- en: Assertions
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: An assertion is a statement that checks whether a particular condition is `true`
    or `false`. If the condition is `true`, the test passes. If the condition is `false`,
    the test fails, indicating a problem with the subject under test.Let’s visit a
    few ways to assert correctness. We use barebone xUnit functionality in this section,
    but you can bring in the assertion library of your choice if you have one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是一种检查特定条件是否为 `true` 或 `false` 的声明。如果条件为 `true`，则测试通过。如果条件为 `false`，则测试失败，表明被测试的主题存在问题。让我们探讨一些断言正确性的方法。在本节中，我们使用基本的
    xUnit 功能，但如果你有选择的断言库，你也可以引入。
- en: In xUnit, the assertion throws an exception when it fails, but you may never
    even realize that. You do not have to handle those; that’s the mechanism to propagate
    the failure result to the test runner.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 xUnit 中，断言在失败时抛出异常，但你可能甚至都没有意识到这一点。你不必处理这些异常；这是将失败结果传播到测试运行器的机制。
- en: 'We won’t explore all possibilities, but let’s start with the following shared
    pieces:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会探索所有可能性，但让我们从以下共享部分开始：
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two preceding record classes, the `OperationThatThrows` method, and the
    variables are utilities used in the test to help us play with xUnit assertions.
    The variables are of type `object` for exploration purposes, but you can use any
    type in your test cases. I omitted the assertion code that we are about to see
    to keep the code leaner.The following two assertions are very explicit:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个记录类、`OperationThatThrows` 方法和变量是测试中使用的实用工具，帮助我们与 xUnit 断言互动。出于探索目的，变量是
    `object` 类型，但你可以在测试用例中使用任何类型。我省略了即将看到的断言代码，以使代码更简洁。以下两个断言非常明确：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first compares whether the actual value equals the expected value, while
    the second compares if the two values are different. `Assert.Equal` is probably
    the most commonly used assertion method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个比较实际值是否等于预期值，而第二个比较两个值是否不同。`Assert.Equal` 可能是使用最广泛的断言方法。
- en: As a rule of thumb, it is better to assert equality (`Equal`) than assert that
    the values are different (`NotEqual`). Except in a few rare cases, asserting equality
    will yield more consistent results and close the door to missing defects.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一条经验法则，断言相等（`Equal`）比断言值不同（`NotEqual`）更好。除了少数罕见的情况外，断言相等会产生更一致的结果，并关闭遗漏缺陷的大门。
- en: 'The next two assertions are very similar to the equality ones but assert that
    the objects are the same instance or not (the same instance means the same reference):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个断言与相等断言非常相似，但断言对象是否是同一个实例或不是（同一个实例意味着相同的引用）：
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next one validates that the two objects are equal. Since we are using record
    classes, it makes it super easy for us; `obj1` and `obj2` are not the same (two
    instances) but are equal (see *Appendix A* for more information on record classes):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个断言验证两个对象是否相等。由于我们使用的是记录类，这使我们变得非常容易；`obj1` 和 `obj2` 不是同一个实例（两个实例），但它们是相等的（有关记录类的更多信息，请参阅
    *附录 A*）：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next two are very similar and assert that the value is `null` or not:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个断言非常相似，断言值是否为 `null` 或不是：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next line asserts that `obj1` is of the `MyClass` type and then returns
    the argument (`obj1`) converted to the asserted type (`MyClass`). If the type
    is incorrect, the `IsType` method will throw an exception:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个断言检查 `obj1` 是否为 `MyClass` 类型，然后返回将参数（`obj1`）转换为断言类型（`MyClass`）的参数。如果类型不正确，`IsType`
    方法将抛出异常：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we reuse the `Assert.Equal` method to validate that the value of the `Name`
    property is what we expect:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重用 `Assert.Equal` 方法来验证 `Name` 属性的值是否符合我们的预期：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code block asserts that the `testCode` argument throws an exception
    of the `SomeCustomException` type:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块断言 `testCode` 参数抛出 `SomeCustomException` 类型的异常：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `testCode` argument executes the `OperationThatThrows` inline function we
    saw initially. The `Throws` method allows us to test some exception properties
    by returning the exception in the specified type. The same behavior as the `IsType`
    method happens here; if the exception is of the wrong type or no exception is
    thrown, the `Throws` method will fail the test.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`testCode` 参数执行我们最初看到的 `OperationThatThrows` 内联函数。`Throws` 方法允许我们通过返回指定类型的异常来测试一些异常属性。这里发生的行为与
    `IsType` 方法相同；如果异常类型不正确或未抛出异常，`Throws` 方法将使测试失败。'
- en: It is a good idea to ensure that not only the proper exception type is thrown,
    but the exception carries the correct values as well.
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保不仅抛出了正确的异常类型，而且异常还携带了正确的值，这是一个好主意。
- en: 'The following line asserts that the value of the `Name` property is what we
    expect it to be, ensuring our program would propagate the proper exception:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行断言 `Name` 属性的值是我们期望的，确保我们的程序会传播正确的异常：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We covered a few assertion methods, but many others are part of xUnit, like
    the `Collection`, `Contains`, `False`, and `True` methods. We use many assertions
    throughout the book, so if these are still unclear, you will learn more about
    them.Next, let’s look at data-driven test cases using theories.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了一些断言方法，但 xUnit 中还有许多其他方法，如 `Collection`、`Contains`、`False` 和 `True` 方法。我们在整本书中使用了许多断言，所以如果这些仍然不清楚，你将了解更多关于它们的信息。接下来，让我们看看使用理论的驱动数据测试案例。
- en: Theories
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理论
- en: 'For more complex test cases, we can use theories. A theory contains two parts:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的测试案例，我们可以使用理论。一个理论包含两个部分：
- en: A `[Theory]` attribute that marks the method as a theory.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标记方法为理论的 `[Theory]` 属性。
- en: 'At least one data attribute that allows passing data to the test method: `[InlineData]`,
    `[MemberData]`, or `[ClassData]`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少一个允许将数据传递给测试方法的属性：`[InlineData]`、`[MemberData]` 或 `[ClassData]`。
- en: When writing a theory, your primary constraint is ensuring that the number of
    values matches the parameters defined in the test method. For example, a theory
    with one parameter must be fed one value. We look at some examples next.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个理论时，你的主要约束是确保值的数量与测试方法中定义的参数相匹配。例如，一个只有一个参数的理论必须提供一个值。我们接下来将看看一些例子。
- en: You are not limited to only one type of data attribute; you can use as many
    as you need to suit your needs and feed a theory with the appropriate data.
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不仅限于只使用一种数据属性；你可以使用你需要的任何数量来满足你的需求，并用适当的数据来提供理论。
- en: 'The `[InlineData]` attribute is the most suitable for constant values or smaller
    sets of values. Inline data is the most straightforward way of the three because
    of the proximity of the test values and the test method.Here is an example of
    a theory using inline data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`[InlineData]` 属性最适合常量值或较小的值集。内联数据是三种方法中最直接的方式，因为测试值和测试方法的接近性。以下是一个使用内联数据的理论示例：'
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That test method yields three test cases in the Test Explorer, where each can
    pass or fail individually. Of course, since 1 equals 1, 2 equals 2, and 5 equals
    5, all three test cases are passing, as shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那个测试方法在测试资源管理器中产生了三个测试案例，每个案例可以单独通过或失败。当然，由于 1 等于 1，2 等于 2，5 等于 5，所有三个测试案例都通过了，如下所示：
- en: '![Figure 2.4: Inline data theory test results](img/file6.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4：内联数据理论测试结果](img/file6.png)'
- en: 'Figure 2.4: Inline data theory test results'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：内联数据理论测试结果
- en: 'We can also use the `[MemberData]` and `[ClassData]` attributes to simplify
    the test method’s declaration when we have a large set of data to tests. We can
    also do that when it is impossible to instantiate the data in the attribute. We
    can also reuse the data in multiple test methods or encapsulate the data away
    from the test class.Here is a medley of examples of the `[MemberData]` attribute
    usage:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `[MemberData]` 和 `[ClassData]` 属性来简化测试方法的声明，当我们有一大批数据要测试时。我们也可以在无法在属性中实例化数据时这样做。我们还可以在多个测试方法中重用数据或将数据封装在测试类之外。以下是一些
    `[MemberData]` 属性使用示例的混合：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding test case yields 12 results. If we break it down, the code starts
    by loading three sets of data from the `Data` property by decorating the test
    method with the `[MemberData(nameof(Data))]` attribute. This is how to load data
    from a member of the class the test method is declared in.Then, the second property
    is very similar to the `Data` property but replaces `IEnumerable<object[]>` with
    a `TheoryData<…>` class, making it more readable and type-safe. Like with the
    first attribute, we feed those three sets of data to the test method by decorating
    it with the `[MemberData(nameof(TypedData))]` attribute. Once again, it is part
    of the test class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试案例产生了 12 个结果。如果我们分解它，代码首先通过使用 `[MemberData(nameof(Data))]` 属性装饰测试方法来从 `Data`
    属性加载三组数据。这就是如何从测试方法声明的类成员中加载数据。然后，第二个属性与 `Data` 属性非常相似，但将 `IEnumerable<object[]>`
    替换为 `TheoryData<…>` 类，使其更易于阅读和类型安全。像第一个属性一样，我们通过使用 `[MemberData(nameof(TypedData))]`
    属性装饰它来将这三组数据提供给测试方法。再次强调，它也是测试类的一部分。
- en: I strongly recommend using `TheoryData<…>` by default.
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我强烈建议默认使用 `TheoryData<…>`。
- en: 'The third data feeds three more sets of data to the test method. However, that
    data originates from the `GetData` method of the `ExternalData` class, sending
    `10` as an argument during the execution (the `start` parameter). To do that,
    we must specify the `MemberType` instance where the method is located so xUnit
    knows where to look. In this case, we pass the argument `10` as the second parameter
    of the `MemberData` constructor. However, in other cases, you can pass zero or
    more arguments there.Finally, we are doing the same for the `ExternalData.TypedData`
    property, which is represented by the `[MemberData(nameof(ExternalData.TypedData),
    MemberType = typeof(ExternalData))]` attribute. Once again, the only difference
    is that the property is defined using `TheoryData` instead of `IEnumerable<object[]>`,
    which makes its intent clearer.When running the tests, the data provided by the
    `[MemberData]` attributes are combined, yielding the following result in the Test
    Explorer:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个数据将三组更多数据传递给测试方法。然而，这些数据源自 `ExternalData` 类的 `GetData` 方法，在执行过程中传递 `10` 作为参数（即
    `start` 参数）。为了做到这一点，我们必须指定方法所在的位置的 `MemberType` 实例，以便 xUnit 知道在哪里查找。在这种情况下，我们将参数
    `10` 作为 `MemberData` 构造函数的第二个参数传递。然而，在其他情况下，你可以传递零个或多个参数。最后，我们对 `ExternalData.TypedData`
    属性也做了同样的处理，该属性由 `[MemberData(nameof(ExternalData.TypedData), MemberType = typeof(ExternalData))]`
    属性表示。再次强调，唯一的区别是属性使用 `TheoryData` 而不是 `IEnumerable<object[]>` 来定义，这使得其意图更加明确。在运行测试时，由
    `[MemberData]` 属性提供的数据被组合，在测试资源管理器中产生以下结果：
- en: '![Figure 2.5: Member data theory test results](img/file7.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5：成员数据理论测试结果](img/file7.png)'
- en: 'Figure 2.5: Member data theory test results'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：成员数据理论测试结果
- en: These are only a few examples of what we can do with the `[MemberData]` attribute.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们使用 `[MemberData]` 属性所能做到的一小部分示例。
- en: I understand that’s a lot of condensed information, but the goal is to cover
    just enough to get you started. I don’t expect you to become an expert in xUnit
    by reading this chapter.
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我明白这有很多浓缩的信息，但目标是涵盖足够的内容以帮助你入门。我不期望你通过阅读这一章就能成为 xUnit 的专家。
- en: 'Last but not least, the `[ClassData]` attribute gets its data from a class
    implementing `IEnumerable<object[]>` or inheriting from `TheoryData<…>`. The concept
    is the same as the other two. Here is an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`[ClassData]` 属性从实现 `IEnumerable<object[]>` 接口或继承自 `TheoryData<…>`
    的类中获取数据。这个概念与前面两个相同。以下是一个示例：
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These are very similar to `[MemberData]`, but we point to a type instead of
    pointing to a member.In `TheoryDataClass`, implementing the `IEnumerable<object[]>`
    interface makes it easy to `yield return` the results. On the other hand, in the
    `TheoryTypedDataClass` class, by inheriting `TheoryData`, we can leverage a list-like
    `Add` method. Once again, I find inheriting from `TheoryData` more explicit, but
    either way works with xUnit. You have many options, so choose the best one for
    your use case.Here is the result in the Test Explorer, which is very similar to
    the other attributes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与 `[MemberData]` 非常相似，但我们指向的是类型而不是成员。在 `TheoryDataClass` 中，实现 `IEnumerable<object[]>`
    接口使得轻松 `yield return` 结果变得容易。另一方面，在 `TheoryTypedDataClass` 类中，通过继承 `TheoryData`，我们可以利用类似列表的
    `Add` 方法。再次强调，我发现从 `TheoryData` 继承更明确，但无论如何，它们都可以与 xUnit 一起工作。你有许多选择，所以请选择最适合你用例的最佳选项。以下是测试资源管理器中的结果，与其它属性非常相似：
- en: '![Figure 2.6: Test Explorer](img/file8.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6：测试资源管理器](img/file8.png)'
- en: 'Figure 2.6: Test Explorer'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：测试资源管理器
- en: That’s it for the theories—next, a few last words before organizing our tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 理论部分就到这里——接下来，在组织我们的测试之前，还有一些最后的话要说。
- en: Closing words
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束语
- en: 'Now that facts, theories, and assertions are out of the way, xUnit offers other
    mechanics to allow developers to inject dependencies into their test classes.
    These are named fixtures. Fixtures allow dependencies to be reused by all test
    methods of a test class by implementing the `IClassFixture<T>` interface. Fixtures
    are very helpful for costly dependencies, like creating an in-memory database.
    With fixtures, you can create the dependency once and use it multiple times. The
    `ValuesControllerTest` class in the `MyApp.IntegrationTests` project shows that
    in action.It is important to note that xUnit creates an instance of the test class
    for every test run, so your dependencies are recreated every time if you are not
    using the fixtures.You can also share the dependency provided by the fixture between
    multiple test classes by using `ICollectionFixture<T>`, `[Collection]`, and `[CollectionDefinition]`
    instead. We won’t get into the details here, but at least you know it’s possible
    and know what types to look for when you need something similar.Finally, if you
    have worked with other testing frameworks, you might have encountered **setup**
    and **teardown** methods. In xUnit, there are no particular attributes or mechanisms
    for handling setup and teardown code. Instead, xUnit uses existing OOP concepts:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事实、理论和断言都已解决，xUnit 提供了其他机制，允许开发者在测试类中注入依赖项。这些被称为固定装置（Fixtures）。固定装置通过实现 `IClassFixture<T>`
    接口，允许所有测试方法的测试类重用依赖项。固定装置对于昂贵的依赖项，如创建内存数据库，非常有帮助。有了固定装置，你可以创建依赖项一次，并多次使用它。《MyApp.IntegrationTests》项目中的
    `ValuesControllerTest` 类展示了这一点。重要的是要注意，xUnit 为每次测试运行创建测试类的实例，所以如果你不使用固定装置，你的依赖项每次都会被重新创建。你还可以通过使用
    `ICollectionFixture<T>`、`[Collection]` 和 `[CollectionDefinition]` 在多个测试类之间共享固定装置提供的依赖项。我们不会在这里深入细节，但至少你知道这是可能的，并且当你需要类似的东西时，你知道要查找哪些类型。最后，如果你使用过其他测试框架，你可能遇到过**设置**和**清理**方法。在
    xUnit 中，没有特定的属性或机制来处理设置和清理代码。相反，xUnit 使用现有的面向对象（OOP）概念：
- en: To set up your tests, use the class constructor.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置你的测试，请使用类构造函数。
- en: To tear down (clean up) your tests, implement `IDisposable` or `IAsyncDisposable`
    and dispose of your resources there.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了拆解（清理）你的测试，实现 `IDisposable` 或 `IAsyncDisposable` 并在那里释放你的资源。
- en: That’s it, xUnit is very simple and powerful, which is why I adopted it as my
    main testing framework several years ago and chose it for this book.Next, we learn
    to write readable test methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，xUnit 非常简单且强大，这就是为什么我在几年前将其作为我的主要测试框架，并选择它作为这本书的测试框架。接下来，我们将学习如何编写可读的测试方法。
- en: Arrange, Act, Assert
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安排（Arrange）、行动（Act）、断言（Assert）
- en: 'Arrange, Act, Assert (AAA or 3A) is a well-known method for writing readable
    tests. This technique allows you to clearly define your setup (arrange), the operation
    under test (act), and your assertions (assert). One efficient way to use this
    technique is to start by writing the 3A as comments in your test case and then
    write the test code in between. Here is an example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 安排（Arrange）、行动（Act）、断言（Assert）（AAA 或 3A）是编写可读测试的知名方法。这种技术允许你清楚地定义你的设置（安排）、被测试的操作（行动）以及你的断言（断言）。使用这种技术的有效方法之一是首先在测试用例中以注释的形式编写
    3A，然后在这之间编写测试代码。以下是一个示例：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, that test case cannot fail, but the three blocks are easily identifiable
    with the 3A comments.In general, **you want the Act block of your unit tests to
    be a single line**, making the test focus clear. If you need more than one line,
    the chances are that something is wrong in the test or the design.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，那个测试用例不能失败，但三个块可以通过 3A 注释轻松识别。一般来说，**你希望你的单元测试的 Act 块只有一行**，这样测试焦点就清晰了。如果你需要多于一行，那么测试或设计中可能存在问题。
- en: When the tests are very small (only a few lines), removing the comments might
    help readability. Furthermore, when you have nothing to set up in your test case,
    delete the Arrange comment to improve its readability further.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当测试非常小（只有几行）时，删除注释可能有助于可读性。此外，当你不需要在测试用例中进行任何设置时，删除 Arrange 注释可以进一步提高其可读性。
- en: Next, we learn how to organize tests into projects, directories, and files.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将测试组织到项目中、目录和文件中。
- en: Organizing your tests
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织你的测试
- en: There are many ways of organizing test projects inside a solution, and I tend
    to create a unit test project for each project in the solution and one or more
    integration test projects.A unit test is directly related to a single unit of
    code, whether it’s a method or a class. It is straightforward to associate a unit
    test project with its respective code project (assembly), leading to a one-on-one
    relationship. One unit test project per assembly makes them portable, easier to
    navigate, and even more so when the solution grows.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案内部组织测试项目有许多方法，我倾向于为解决方案中的每个项目创建一个单元测试项目，以及一个或多个集成测试项目。单元测试直接关联到单个代码单元，无论是方法还是类。将单元测试项目与其相应的代码项目（程序集）关联起来非常直接，从而形成一对一的关系。每个程序集一个单元测试项目使它们易于携带、易于导航，当解决方案规模扩大时更是如此。
- en: If you have a preferred way to organize yours that differs from what we are
    doing in the book, by all means, use that approach instead.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你有一个与我们书中所做不同的组织方式，请务必使用那种方法。
- en: Integration tests, on the other hand, can span multiple projects, so having
    a single rule that fits all scenarios is challenging. One integration test project
    per solution is often enough. Sometimes we can need more than one, depending on
    the context.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集成测试可以跨越多个项目，因此制定一个适用于所有场景的单一规则具有挑战性。通常情况下，每个解决方案一个集成测试项目就足够了。有时，根据上下文，我们可能需要不止一个。
- en: I recommend starting with one integration test project and adding more as needed
    during development instead of overthinking it before getting started. Trust your
    judgment; you can always change the structure as your project evolves.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我建议从创建一个集成测试项目开始，并在开发过程中根据需要添加更多，而不是在开始之前过度思考。相信你的判断；你总是可以根据项目的发展改变结构。
- en: 'Folder-wise, at the solution level, creating the application and its related
    libraries in an `src` directory helps isolate the actual solution code from the
    test projects created under a `test` directory, like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案级别按文件夹创建应用及其相关库到`src`目录中，有助于将实际解决方案代码与在`test`目录下创建的测试项目隔离开来，如下所示：
- en: '![Figure 2.7: The Automated Testing Solution Explorer, displaying how the projects
    are organized](img/file9.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：自动测试解决方案资源管理器，显示项目组织方式](img/file9.png)'
- en: 'Figure 2.7: The Automated Testing Solution Explorer, displaying how the projects
    are organized'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：自动测试解决方案资源管理器，显示项目组织方式
- en: That’s a well-known and effective way of organizing a solution in the .NET world.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在.NET世界中组织解决方案的一个众所周知且有效的方法。
- en: Sometimes, it is not possible or unwanted to do that. One such use case would
    be multiple microservices written under a single solution. In that case, you might
    want the tests to live closer to your microservices and not split them between
    `src` and `test` folders. So you could organize your solution by microservice
    instead, like one directory per microservice that contains all the projects, including
    tests.
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时，这样做可能不可行或不希望这么做。一个这样的用例是在单个解决方案下编写多个微服务。在这种情况下，你可能希望测试与微服务更接近，而不是在`src`和`test`文件夹之间分割。因此，你可以按微服务组织解决方案，例如每个微服务一个目录，包含所有项目，包括测试。
- en: Let’s now dig deeper into organizing unit tests.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来深入探讨单元测试的组织。
- en: Unit tests
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: How you organize your test projects may make a big difference between searching
    for your tests or making it easy to find them. Let’s look at the different aspects,
    from the `namespace` to the test code itself.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何组织测试项目可能会在搜索测试或使其易于找到之间产生很大差异。让我们看看不同的方面，从`命名空间`到测试代码本身。
- en: Namespace
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'I find it convenient to create unit tests in the same namespace as the subject
    under test when creating unit tests. That helps get tests and code aligned without
    adding any additional using statements. To make it easier when creating files,
    you can change the default namespace used by Visual Studio when creating a new
    class in your test project by adding `<RootNamespace>[Project under test namespace]</RootNamespace>`
    to a `PropertyGroup` of the test project file (`*.csproj`), like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现当创建单元测试时，在测试项目中创建与被测试主题相同的命名空间很方便。这有助于使测试和代码对齐，而无需添加任何额外的`using`语句。为了在创建文件时更容易，你可以通过在测试项目文件的`PropertyGroup`（`*.csproj`）中添加`<RootNamespace>[Project
    under test namespace]</RootNamespace>`来更改Visual Studio创建新类时使用的默认命名空间，如下所示：
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Test class name
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试类名称
- en: By convention, I name test classes `[class under test]Test.cs` and create them
    in the same directory as in the original project. Finding tests is easy when following
    that simple rule since the test code is in the same location of the file tree
    as the code under test but in two distinct projects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我将测试类命名为`[被测试类]Test.cs`，并将它们创建在原始项目的同一目录下。遵循这个简单的规则，查找测试变得容易，因为测试代码与被测试代码在文件树中的位置相同，但属于两个不同的项目。
- en: '![Figure 2.8: The Automated Testing Solution Explorer, displaying how tests
    are organized](img/file10.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：自动测试解决方案资源管理器，显示测试的组织方式](img/file10.png)'
- en: 'Figure 2.8: The Automated Testing Solution Explorer, displaying how tests are
    organized'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：自动测试解决方案资源管理器，显示测试的组织方式
- en: Test code inside the test class
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试类内的测试代码
- en: 'For the test code itself, I follow a multi-level structure similar to the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试代码本身，我遵循一个类似于以下的多级结构：
- en: One test class is named the same as the class under test.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试类的名称与被测试类相同。
- en: One nested test class per method to test from the class under test.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于被测试类中的每个方法，创建一个嵌套测试类。
- en: One test method per test case of the method under test.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于被测试方法的每个测试用例，创建一个测试方法。
- en: 'This technique helps organize tests by test case while keeping a clear hierarchy,
    leading to the following hierarchy:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通过测试用例组织测试，同时保持清晰的层次结构，导致以下层次结构：
- en: Class under test
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被测试类
- en: Method under test
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被测试的方法
- en: Test case using that method
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该方法的测试用例
- en: 'In code, that translates to the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这转化为以下：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This convention allows you to set up tests step by step. For example, by inheriting
    the outer class (the `ValuesControllerTest` class here) from the inner class (the
    `Get` nested class), you can create top-level private mocks or classes shared
    by all nested classes and test methods. Then, for each method to test, you can
    modify the setup or create other private test elements in the nested classes.
    Finally, you can do more configuration per test case inside the test method (the
    `Should_return_the_expected_strings` method here).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个惯例允许你逐步设置测试。例如，通过从内部类（这里的`Get`嵌套类）继承外部类（`ValuesControllerTest`类），你可以创建顶级私有模拟或所有嵌套类和测试方法共享的类。然后，对于要测试的每个方法，你可以在嵌套类中修改设置或创建其他私有测试元素。最后，你可以在测试方法内部为每个测试用例进行更多配置（这里的`Should_return_the_expected_strings`方法）。
- en: 'Don’t go too hard on reusability inside your test classes, as it can make tests
    harder to read from an external eye, such as a reviewer or another developer that
    needs to play there. Unit tests should remain focused, small, and easy to read:
    a unit of code testing another unit of code. Too much reusability may lead to
    a brittle test suite.'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要在测试类内部过度追求可复用性，因为这可能会使测试对外部观察者（如审阅者或需要在那里工作的其他开发者）更难阅读。单元测试应保持专注、小巧且易于阅读：一个代码单元测试另一个代码单元。过多的可复用性可能会导致脆弱的测试套件。
- en: Now that we have explored organizing unit tests, let’s look at integration tests.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了组织单元测试的方法，让我们来看看集成测试。
- en: Integration tests
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Integration tests are harder to organize because they depend on multiple units,
    can cross project boundaries, and interact with various dependencies.We can create
    one integration test project for most simple solutions or many for more complex
    scenarios.When creating one, you can name the project `IntegrationTests` or start
    with the entry point of your tests, like a REST API project, and name the project
    `[Name of the API project].IntegrationTests`. At this point, how to name the integration
    test project depends on your solution structure and intent.When you need multiple
    integration projects, you can follow a convention similar to unit tests and associate
    your integration projects one-to-one: `[Project under test].IntegrationTests`.Inside
    those projects, it depends on how you want to attack the problem and the structure
    of the solution itself. Start by identifying the features under test. Name the
    test classes in a way that mimics your requirements, organize those into sub-folders
    (maybe a category or group of requirements), and code test cases as methods. You
    can also leverage nested classes, as we did with unit tests.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的组织比较困难，因为它们依赖于多个单元，可以跨越项目边界，并与各种依赖项交互。对于大多数简单解决方案，我们可以创建一个集成测试项目；对于更复杂的场景，可能需要创建多个。在创建一个集成测试项目时，你可以将其命名为
    `IntegrationTests`，或者以测试的入口点为起点，例如 REST API 项目，并命名为 `[API项目的名称].IntegrationTests`。在这个阶段，如何命名集成测试项目取决于你的解决方案结构和意图。当你需要多个集成测试项目时，你可以遵循与单元测试类似的约定，将你的集成测试项目一对一地关联：`[被测试的项目].IntegrationTests`。在这些项目中，具体取决于你想要如何解决问题以及解决方案本身的架构。首先，确定要测试的功能。以模仿你的需求的方式来命名测试类，将这些组织到子文件夹中（可能是一个类别或一组需求），并将测试用例作为方法编写。你还可以利用嵌套类，就像我们在单元测试中做的那样。
- en: We write tests throughout the book, so you will have plenty of examples to make
    sense of all this if it’s not clear now.
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在整本书中都编写了测试，所以如果你现在还不清楚，你将会有很多例子来理解所有这些内容。
- en: Next, we implement an integration test by leveraging ASP.NET Core features.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过利用 ASP.NET Core 的功能来实现一个集成测试。
- en: Writing ASP.NET Core integration tests
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 ASP.NET Core 集成测试
- en: 'When Microsoft built ASP.NET Core from the ground up, they fixed and improved
    so many things that I cannot enumerate them all here, including testability.Nowadays,
    there are two ways to structure a .NET program:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软从头开始构建 ASP.NET Core 时，他们修复和改进了许多事情，我无法在这里一一列举，包括可测试性。如今，有两种方式来构建 .NET 程序：
- en: The classic ASP.NET Core `Program` and the `Startup` classes. This model might
    be found in existing projects (created before .NET 6).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的 ASP.NET Core `Program` 和 `Startup` 类。这个模型可能在现有的项目中找到（在 .NET 6 之前创建的项目）。
- en: The minimal hosting model introduced in .NET 6\. This may look familiar to you
    if you know Node.js, as this model encourages you to write the start-up code in
    the Program.cs file by leveraging top-level statements. You will most likely find
    this model in new projects (created after the release of .NET 6).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6 中引入的最小托管模型。如果你了解 Node.js，这可能会让你感到熟悉，因为这个模型鼓励你在 Program.cs 文件中通过使用顶层语句来编写启动代码。你很可能会在新的项目中找到这个模型（在
    .NET 6 发布之后创建的项目）。
- en: No matter how you write your program, that’s the place to define how the application’s
    composition and how it boots. Moreover, we can leverage the same testing tools
    more or less seamlessly.In the case of a web application, the scope of our integration
    tests is often to call the endpoint of a controller over HTTP and assert the response.
    Luckily, in .NET Core 2.1, the .NET team added the `WebApplicationFactory<TEntry>`
    class to make the integration testing of web applications easier. With that class,
    we can boot up an ASP.NET Core application in memory and query it using the supplied
    `HttpClient` in a few lines of code. The test classes also provide extension points
    to configure the server, such as replacing implementations with mocks, stubs,
    or other test-specific elements.Let’s start by booting up a classic web application
    test.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何编写程序，那里都是定义应用程序的组成和启动的地方。此外，我们可以利用相同的测试工具，实现更多或更少的无缝集成。在 Web 应用程序的情况下，我们的集成测试范围通常是通过
    HTTP 调用控制器的端点并断言响应。幸运的是，在 .NET Core 2.1 中，.NET 团队添加了 `WebApplicationFactory<TEntry>`
    类，这使得 Web 应用程序的集成测试变得更加容易。使用这个类，我们可以在内存中启动一个 ASP.NET Core 应用程序，并用提供的 `HttpClient`
    在几行代码中查询它。测试类还提供了配置服务器的扩展点，例如用模拟、存根或其他特定于测试的元素替换实现。让我们从一个经典的 Web 应用程序测试开始启动。
- en: Classic web application
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典 Web 应用程序
- en: In a classic ASP.NET Core application, the `TEntry` generic parameter of the
    `WebApplicationFactory<TEntry>` class is usually the `Startup` or `Program` class
    of your project under test.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个经典的ASP.NET Core应用程序中，`WebApplicationFactory<TEntry>`类的`TEntry`泛型参数通常是您正在测试的项目中的`Startup`或`Program`类。
- en: The test cases are in the `Automated Testing` solution under the `MyApp.IntegrationTests`
    project.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 测试用例位于`MyApp.IntegrationTests`项目下的`Automated Testing`解决方案中。
- en: 'Let’s start by looking at the test code structure before breaking it down:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看测试代码的结构，然后再将其分解：
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first piece of the preceding code that is relevant to us is how we get
    an instance of the `WebApplicationFactory<Startup>` class. We inject a `WebApplicationFactory<Startup>`
    object into the constructor by implementing the `IClassFixture<T>` interface (a
    xUnit feature). We can also use the factory to configure the test server, but
    we don’t need to here, so we can only keep a reference on the `HttpClient`, preconfigured
    to connect to the in-memory test server.Then, we may have noticed we have the
    nested `Get` class that inherits the `ValuesControllerTest` class. The `Get` class
    contains the test cases. By inheriting the `ValuesControllerTest` class, we can
    leverage the `_httpClient` field from the test cases we are about to see.In the
    first test case, we use `HttpClient` to query the `http://localhost/api/values`
    URI, accessible through the in-memory server. Then, we assert that the status
    code of the HTTP response was a success (`200 OK`):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中与我们相关的一部分是如何获取`WebApplicationFactory<Startup>`类的实例。我们通过实现`IClassFixture<T>`接口（一个xUnit特性）将`WebApplicationFactory<Startup>`对象注入构造函数。我们也可以使用工厂来配置测试服务器，但在这里我们不需要，所以我们只能保留对预配置为连接到内存测试服务器的`HttpClient`的引用。然后，我们可能已经注意到我们有一个嵌套的`Get`类，它继承自`ValuesControllerTest`类。`Get`类包含测试用例。通过继承`ValuesControllerTest`类，我们可以利用即将看到的测试用例中的`_httpClient`字段。在第一个测试用例中，我们使用`HttpClient`查询通过内存服务器可访问的`http://localhost/api/values`
    URI，并断言HTTP响应的状态码为成功（`200 OK`）：
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second test case also sends an HTTP request to the in-memory server but
    deserializes the body’s content as a string[] to ensure the values are the same
    as expected instead of validating the status code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试用例也向内存中的服务器发送HTTP请求，但将正文内容反序列化为string[]以确保值与预期相同，而不是验证状态码：
- en: '[PRE21]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you may have noticed from the test cases, the `WebApplicationFactory` preconfigured
    the `BaseAddress` property for us, so we don’t need to prefix our requests with
    `http://localhost`.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如您可能已从测试用例中注意到，`WebApplicationFactory`已为我们预先配置了`BaseAddress`属性，因此我们不需要在请求前加上`http://localhost`。
- en: When running those tests, an in-memory web server starts. Then, HTTP requests
    are sent to that server, testing the complete application. The tests are simple
    in this case, but you can create more complex test cases in more complex programs.Next,
    we explore how to do the same for minimal APIs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这些测试时，一个内存中的Web服务器会启动。然后，向该服务器发送HTTP请求，以测试整个应用程序。在这个例子中，测试很简单，但在更复杂的程序中，您可以创建更复杂的测试用例。接下来，我们将探讨如何为最小API做同样的事情。
- en: Minimal hosting
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小化托管
- en: Unfortunately, we must use a workaround to make the `Program` class discoverable
    when using minimal hosting. Let’s explore a few workarounds that leverage minimal
    APIs, allowing you to pick the one you prefer.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们必须使用一种解决方案来使`Program`类在使用最小化托管时可以被发现。让我们探索一些利用最小API的解决方案，让您可以选择您喜欢的方案。
- en: First workaround
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一种解决方案
- en: The **first workaround** is to use any other class in the assembly as the `TEntryPoint`
    of `WebApplicationFactory<TEntryPoint>` instead of the `Program` or `Startup`
    class. This makes what `WebApplicationFactory` does a little less explicit, but
    that’s all. Since I tend to prefer readable code, I do not recommend this.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一种解决方案**是使用程序集中的任何其他类作为`WebApplicationFactory<TEntryPoint>`的`TEntryPoint`，而不是`Program`或`Startup`类。这使得`WebApplicationFactory`的行为稍微不那么明确，但这只是所有。由于我倾向于喜欢可读的代码，我不推荐这样做。'
- en: Second workaround
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二种解决方案
- en: 'The **second workaround** is to add a line at the bottom of the `Program.cs`
    file (or anywhere else in the project) to change the autogenerated `Program` class
    visibility from `internal` to `public`. Here is the complete `Program.cs` file
    with that added line (highlighted):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二种解决方案**是在`Program.cs`文件的底部（或项目的任何其他位置）添加一行，将自动生成的`Program`类可见性从`internal`更改为`public`。以下是添加了该行的完整`Program.cs`文件（已突出显示）：'
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, the test cases are very similar to the ones of the classic web application
    explored previously. The only difference is the program itself, both programs
    don’t do the same thing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试用例与之前探索的经典Web应用程序的测试用例非常相似。唯一的区别是程序本身，两个程序都不做相同的事情。
- en: '[PRE23]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only change is the expected result as the endpoint returns the `text/plain`
    string `Hello World!` instead of a collection of strings serialized as JSON. The
    test cases would be identical if the two endpoints produced the same result.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是预期的结果，因为端点返回的是`text/plain`字符串`Hello World!`，而不是作为JSON序列化的字符串集合。如果两个端点产生相同的结果，测试用例将是相同的。
- en: Third workaround
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第三个解决方案
- en: 'The **third workaround** is to instantiate `WebApplicationFactory` manually
    instead of leveraging a fixture. We can use the `Program` class, which requires
    changing its visibility by adding the following line to the `Program.cs` file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三个解决方案**是手动实例化`WebApplicationFactory`而不是利用固定值。我们可以使用`Program`类，这需要通过在`Program.cs`文件中添加以下行来更改其可见性：'
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, instead of injecting the instance using the `IClassFixture` interface,
    we instantiate the factory manually. To ensure we dispose the `WebApplicationFactory`
    instance, we also implement the `IAsyncDisposable` interface.Here’s the complete
    example, which is very similar to the previous workaround:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不是通过使用`IClassFixture`接口注入实例，而是手动实例化工厂。为了确保我们能够释放`WebApplicationFactory`实例，我们还实现了`IAsyncDisposable`接口。以下是一个完整的示例，它与之前的解决方案非常相似：
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I omitted the test cases in the preceding code block because they are the same
    as the previous workarounds. The full source code is available on GitHub: [https://adpg.link/vzkr](https://adpg.link/vzkr).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了前面的代码块中的测试用例，因为它们与之前的解决方案相同。完整的源代码可在GitHub上找到：[https://adpg.link/vzkr](https://adpg.link/vzkr)。
- en: Using class fixtures is more performant since the factory and the server get
    created only once per test run instead of recreated for every test method.
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用类固定值更高效，因为工厂和服务器在每个测试运行中只创建一次，而不是为每个测试方法重新创建。
- en: Creating a test application
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建测试应用程序
- en: 'Finally, we can create a dedicated class that instantiates `WebApplicationFactory`
    manually. It leverages the other workarounds but makes the test cases more readable.
    By encapsulating the setup of the test application in a class, you will improve
    the reusability and maintenance cost in most cases.First, we need to change the
    `Program` class visibility by adding the following line to the `Project.cs` file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个专门类来手动实例化`WebApplicationFactory`。它利用了其他解决方案，但使测试用例更易于阅读。通过将测试应用程序的设置封装在类中，你将在大多数情况下提高代码的可重用性和维护成本。首先，我们需要通过在`Project.cs`文件中添加以下行来更改`Program`类的可见性：
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we can access the Program class without the need to allow internal
    visibility to our test project, we can create our test application like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在不需要允许测试项目内部可见性的情况下访问`Program`类，我们可以创建我们的测试应用程序如下：
- en: '[PRE27]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we can reuse the same code to test our program but instantiate `MyTestApplication`
    instead of `WebApplicationFactory<Program>`, highlighted in the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重用相同的代码来测试我们的程序，但实例化`MyTestApplication`而不是`WebApplicationFactory<Program>`，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also leverage fixtures, but for the sake of simplicity, I decided to
    show you how to instantiate our new test application manually.And that’s it. We
    have covered multiple ways to work around integration testing minimal APIs simplistically
    and elegantly. Next, we explore a few testing principles before moving to architectural
    principles in the next chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以利用固定值，但为了简单起见，我决定向你展示如何手动实例化我们的新测试应用程序。就这样。我们已经以简单而优雅的方式涵盖了多种解决集成测试最小API的方法。接下来，在下一章转向架构原则之前，我们将探讨一些测试原则。
- en: Important testing principles
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的测试原则
- en: 'One essential thing to remember when writing tests is to test use cases, not
    the code itself; we are testing features’ correctness, not code correctness. Of
    course, if the expected outcome of a feature is correct, that also means the codebase
    is correct. However, it is not always true the other way around; correct code
    may yield an incorrect outcome. Also, remember that code costs money to write,
    while features deliver value.To help with that, test requirements should revolve
    around **inputs and outputs**. When specific values go into your subject under
    test, you expect particular values to come out. Whether you are testing a simple
    `Add` method where the ins are two or more numbers, and the out is the sum of
    those numbers, or a more complex feature where the ins come from a form, and the
    out is the record getting persisted in a database, most of the time, we are testing
    that inputs produced an output or an outcome.Another concept is to divide those
    units as a query or a command. No matter how you organize your code, from a simple
    single-file application to a microservices architecture-base Netflix clone, all
    simple or compounded operations are queries or commands. Thinking about a system
    this way should help you test the ins and outs. We discuss queries and commands
    in several chapters, so keep reading to learn more.Now that we have laid this
    out, what if a unit must perform multiple operations, such as reading from a database,
    and then send multiple commands? You can create and test multiple smaller units
    (individual operations) and another unit that orchestrates those building blocks,
    allowing you to test each piece in isolation. We explore how to achieve this throughout
    the book.In a nutshell, when writing automated tests:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，要记住的是测试用例，而不是代码本身；我们测试的是功能的正确性，而不是代码的正确性。当然，如果功能的预期结果是正确的，这也意味着代码库是正确的。然而，并非总是相反；正确的代码可能产生错误的结果。此外，请记住，编写代码需要花钱，而功能则能带来价值。为了帮助这一点，测试需求应围绕**输入和输出**展开。当特定的值输入到你的测试对象中时，你期望得到特定的输出值。无论你是测试一个简单的`Add`方法，其中输入是两个或更多数字，输出是这些数字的总和，还是更复杂的功能，其中输入来自表单，输出是记录在数据库中持久化的，大多数情况下，我们是在测试输入产生了输出或结果。另一个概念是将这些单元分为查询或命令。无论你如何组织你的代码，从简单的单文件应用程序到基于微服务架构的Netflix克隆，所有简单或复合操作都是查询或命令。以这种方式思考系统应该有助于你测试输入和输出。我们在几个章节中讨论了查询和命令，所以继续阅读以了解更多。现在我们已经阐述了这一点，如果一个单元必须执行多个操作，比如从数据库中读取，然后发送多个命令，怎么办？你可以创建和测试多个较小的单元（单个操作），以及另一个协调这些构建块的单元，这样你可以单独测试每个部分。我们在整本书中探讨了如何实现这一点。总的来说，在编写自动化测试时：
- en: In case of a query, we assert the output of the unit undergoing testing based
    on its input parameters.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有疑问，我们将根据其输入参数断言正在测试的单元的输出。
- en: In case of a command, we assert the outcome of the unit undergoing testing based
    on its input parameters.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令的情况下，我们将根据其输入参数断言正在测试的单元的结果。
- en: We explore numerous techniques throughout the book to help you achieve that
    level of separation, starting with architectural principles in the next chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中探讨了多种技术，帮助你达到这种分离程度，从下一章的建筑原则开始。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered automated testing, such as unit and integration tests.
    We also briefly covered end-to-end tests, but covering that in only a few pages
    is impossible. Nonetheless, how to write integration tests can also be used for
    end-to-end testing, especially in the REST API space.We explored different testing
    approaches from a bird’s eye view, tackled technical debt, and explored multiple
    testing techniques like black-box, white-box, and grey-box testing. We also peaked
    at a few formal ways to choose the values to test, like equivalence partitioning
    and boundary value analysis.We then looked at xUnit, the testing framework used
    throughout the book, and a way of organizing tests. We explored ways to pick the
    correct type of test and some guidelines about choosing the right quantity for
    each kind of test. Then we saw how easy it is to test our ASP.NET Core web applications
    by running it in memory. Finally, we explored high-level concepts that should
    guide you in writing testable, flexible, and reliable programs.Now that we have
    talked about testing, we are ready to explore a few architectural principles to
    help us increase programs’ testability. Those are a crucial part of modern software
    engineering and go hand in hand with automated testing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了自动化测试，如单元测试和集成测试。我们还简要介绍了端到端测试，但在仅几页的篇幅内涵盖它是不可行的。尽管如此，如何编写集成测试也可以用于端到端测试，尤其是在REST
    API领域。我们从宏观角度探讨了不同的测试方法，处理了技术债务，并探讨了多种测试技术，如黑盒测试、白盒测试和灰盒测试。我们还简要介绍了几种选择测试值的形式方法，如等价类划分和边界值分析。然后我们探讨了xUnit，这是本书中使用的测试框架以及组织测试的方法。我们探讨了如何选择正确的测试类型以及关于为每种测试类型选择正确数量的指南。然后我们看到了如何通过在内存中运行来轻松测试我们的ASP.NET
    Core Web应用程序。最后，我们探讨了应该指导你编写可测试、灵活和可靠的程序的高级概念。现在我们已经讨论了测试，我们准备探索一些架构原则，以帮助我们提高程序的测试性。这些是现代软件工程的关键部分，与自动化测试相辅相成。
- en: Questions
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: Is it true that in TDD, you write tests before the code to be tested?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TDD中，你是在编写要测试的代码之前编写测试的吗？
- en: What is the role of unit tests?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试的作用是什么？
- en: How big can a unit test be?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试可以有多大？
- en: What type of test is usually used when the subject under test has to access
    a database?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被测试的主题需要访问数据库时，通常使用哪种类型的测试？
- en: Is doing TDD required?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行TDD是必需的吗？
- en: Do you need to know the inner working of the application to do black-box testing?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行黑盒测试需要了解应用程序的内部工作原理吗？
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build upon what we have learned in the chapter:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'xUnit: [https://xunit.net/](https://xunit.net/)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'xUnit: [https://xunit.net/](https://xunit.net/)'
- en: 'If you use Visual Studio, I have a few handy snippets to help improve productivity.
    They are available on GitHub: [https://adpg.link/5TbY](https://adpg.link/5TbY)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio，我有一些实用的代码片段可以帮助提高生产力。它们可以在GitHub上找到：[https://adpg.link/5TbY](https://adpg.link/5TbY)
