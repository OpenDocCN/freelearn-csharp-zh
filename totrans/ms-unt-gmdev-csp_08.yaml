- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Designing Optimized User Interfaces with C# for Unity Games
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#为Unity游戏设计优化用户界面
- en: Welcome to [*Chapter 5*](B22017_05.xhtml#_idTextAnchor074), where we will learn
    how to optimize **user interfaces** (**UIs**) for our Unity games using the versatile
    capabilities of C#. This chapter equips you with practical skills to enhance the
    performance of your UI and ensure a smooth user experience. The first skill focuses
    on utilizing C# for efficient UI optimization, maximizing the performance of your
    UI elements. Following this, we delve into strategies for creating an optimized
    UI system in C#, providing insights into structuring and managing views effectively.
    Throughout this chapter, the presented system acts as a flexible framework, allowing
    you to customize and optimize UI elements based on your game’s unique requirements.
    Let’s dive into the world of optimized UIs, leveraging the power of C# to refine
    the performance and functionality of your Unity game interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第五章*](B22017_05.xhtml#_idTextAnchor074)，我们将学习如何利用C#的多功能性优化Unity游戏的用户界面（UI）。本章为你提供了实用的技能，以提升UI的性能并确保流畅的用户体验。第一个技能侧重于利用C#进行高效的UI优化，最大化UI元素的性能。随后，我们将深入研究在C#中创建优化UI系统的策略，提供关于有效构建和管理视图的见解。在本章中，所提出的系统作为一个灵活的框架，允许你根据游戏独特的需求自定义和优化UI元素。让我们深入优化UI的世界，利用C#的力量来提升Unity游戏界面的性能和功能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Introducing UI design in gaming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的UI设计介绍
- en: Best practices and optimizing techniques for UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI的最佳实践和优化技术
- en: UI system using C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#的UI系统
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code files of this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005)。
- en: Introducing UI design in gaming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的UI设计介绍
- en: 'In the exciting world of making games, the UI is like the link between the
    player and the cool virtual world made by game creators. UI design isn’t just
    about making things look good; it’s super important in shaping how players experience
    the game. This section talks about why UI design is a big deal in games and how
    it really affects how much players get into the game and how much they like it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作游戏的激动人心的世界中，UI就像是玩家和游戏制作者创造的酷炫虚拟世界之间的联系。UI设计不仅仅是关于让事物看起来好看；它在塑造玩家体验游戏的方式中起着至关重要的作用。本节讨论了为什么UI设计在游戏中非常重要，以及它如何真正影响玩家对游戏的投入程度和喜爱程度：
- en: '**The** **first impression**:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一印象：**'
- en: Think of the UI as the first hello between the game and the player. A well-made
    UI grabs attention, sets the vibe, and makes the game look and feel unique. Whether
    you’re on the main menu or playing the game, every part adds up to the first feeling
    you get when you start playing.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将UI视为游戏与玩家之间的第一次问候。一个精心制作的UI能够吸引注意力，设定氛围，并使游戏看起来和感觉独特。无论你是在主菜单还是玩游戏，每个部分都汇聚成你开始玩游戏时获得的第一个感觉。
- en: '**Enhancing** **player immersion:**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强** **玩家沉浸感：**'
- en: Playing a game should feel like you’re right there in the action. A well-thought-out
    UI blends smoothly with the game, so you stay focused on playing without getting
    distracted. Whether it’s cool movements, matching themes, or easy controls, the
    UI becomes a big part of the game’s story.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 玩游戏应该感觉就像你真的身处其中。一个经过深思熟虑的UI与游戏无缝融合，让你专注于游戏，而不会被分散注意力。无论是酷炫的动作、匹配的主题还是简单的控制，UI都成为游戏故事的重要组成部分。
- en: '**Guiding** **user interaction:**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导** **用户交互：**'
- en: The UI is like a helpful guide showing players what to do in the game. From
    health bars to markers for quests, each thing gives important information without
    confusing players. Making the UI clear and simple is super important so that players
    can think about their moves and the tricky parts of the game, not figuring out
    the buttons.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UI就像一个有用的指南，向玩家展示在游戏中应该做什么。从生命值条到任务标记，每一项都提供了重要的信息，而不会让玩家感到困惑。使UI清晰简单非常重要，这样玩家就可以思考他们的动作和游戏的难点，而不是在研究按钮。
- en: '**Impact on** **player engagement:**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对** **玩家参与度** **的影响：**'
- en: A UI that’s easy to understand and looks good really keeps players interested.
    If moving around menus is smooth and the game responds well, players want to spend
    more time playing. On the flip side, a badly made UI can make players frustrated,
    not want to play, and ruin the fun.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个易于理解且看起来好的 UI 真的能保持玩家的兴趣。如果菜单操作流畅且游戏响应良好，玩家愿意花更多时间玩游戏。相反，一个制作糟糕的 UI 可能会让玩家感到沮丧，不想玩游戏，并破坏乐趣。
- en: '**Adapting to** **diverse platforms:**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应** **多种平台：**'
- en: Since we play games on all kinds of devices now, the UI has to work well on
    everything. It’s like speaking different languages for each device, making sure
    the game feels right no matter whether you’re using a computer, console, or phone.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们现在在各种各样的设备上玩游戏，UI 必须在所有设备上都能良好工作。这就像为每种设备说不同的语言，确保无论您使用电脑、游戏机还是手机，游戏体验都是正确的。
- en: Making the UI in games is like finding the right mix of making things look good
    and work well. It’s about picking colors and fonts, how things are spaced out,
    and also making sure everything runs smoothly. Using C# in Unity lets game makers
    use these cool design ideas and make interfaces that not only look awesome but
    also do their job well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中制作 UI 就像是找到让事物看起来好且工作良好的正确混合。这关乎选择颜色和字体，如何布局，以及确保一切运行顺畅。在 Unity 中使用 C# 让游戏制作者能够使用这些酷炫的设计理念，制作出不仅看起来很棒而且能很好地完成任务的界面。
- en: As we go through this chapter, we’ll check out the basic ideas behind UI design
    and see how C# can help make really great UIs that make playing games even more
    awesome.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览这一章的过程中，我们将探讨 UI 设计背后的基本理念，并看看 C# 如何帮助制作出真正出色的 UI，使游戏体验更加精彩。
- en: Transitioning to best practices and optimization techniques for UIs, we’ll explore
    strategies to enhance UI performance and responsiveness next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 转向 UI 的最佳实践和优化技术，我们将探讨提高 UI 性能和响应性的策略。
- en: Best practices and optimization techniques for UIs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 的最佳实践和优化技术
- en: In this section, we are going to talk about some optimization techniques for
    UIs along with some best practices to have a better performance. Let’s get started.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些 UI 优化技术以及一些最佳实践，以获得更好的性能。让我们开始吧。
- en: Splitting up Canvases
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割画布
- en: '**Issue**: *Modifying a single element on the UI Canvas triggers a complete
    Canvas refresh,* *impacting performance.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：*在 UI 画布上修改单个元素会触发整个画布的刷新，* *影响性能。*'
- en: The Unity UI relies on the Canvas as its fundamental component. It creates meshes
    representing UI elements, refreshes these meshes when there are changes, and sends
    draw calls to the GPU for actual UI display.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI 依赖于画布作为其基本组件。它创建代表 UI 元素的网格，当有变化时刷新这些网格，并将绘制调用发送到 GPU 以进行实际的 UI 显示。
- en: Mesh generation is resource-intensive, requiring UI Elements to be grouped into
    batches for efficiency in draw calls. Due to the cost of batch regeneration, it’s
    essential to minimize unnecessary refreshes. The challenge arises when even a
    single element changes on a Canvas, prompting a full Canvas re-evaluation to determine
    the optimal way to redraw its elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 网格生成是资源密集型操作，需要将 UI 元素分组批量处理以提高绘制调用的效率。由于批量重生成的成本，最小化不必要的刷新至关重要。当画布上的单个元素发生变化时，就会引发挑战，因为这会促使对整个画布进行全面评估，以确定重新绘制其元素的最佳方式。
- en: Many users construct their entire game’s UI on a single Canvas with numerous
    elements. Altering just one element can lead to a significant CPU spike, consuming
    multiple milliseconds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户在一个画布上构建整个游戏的 UI，包含众多元素。仅更改一个元素就可能引起显著的 CPU 峰值，消耗多个毫秒。
- en: '**Solution**: Divide your Canvases.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：分割您的画布。'
- en: Each Canvas functions as an independent entity, segregating its elements from
    those on other Canvases. Leverage the Unity GUI’s support for multiple Canvases
    by segmenting your Canvases, addressing the batching challenges within Unity UI.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个画布作为一个独立的实体运行，将其元素与其他画布上的元素隔离开。利用 Unity GUI 对多个画布的支持，通过分割您的画布，解决 Unity UI
    中的批量处理挑战。
- en: Nested Canvases offer another solution, enabling the creation of complex hierarchical
    UIs without the need to consider the spatial arrangement of elements across Canvases.
    Child Canvases additionally insulate content from both their parent and sibling
    Canvases. They maintain individual geometry and conduct independent batching.
    An effective strategy for segmentation is based on the refresh frequency of elements.
    Place static UI Elements on a distinct Canvas, reserving smaller sub-Canvases
    for dynamic elements that update simultaneously. Additionally, ensure uniformity
    in Z values, materials, and textures for all UI Elements on each Canvas.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套画布提供了另一种解决方案，允许在不考虑元素在画布间空间排列的情况下创建复杂的分层UI。子画布还能保护内容不受其父画布和兄弟画布的影响。它们保持独立的几何形状并执行独立的批处理。一种有效的分割策略是基于元素的刷新频率。将静态UI元素放置在独立的画布上，为同时更新的动态元素保留较小的子画布。此外，确保每个画布上所有UI元素的Z值、材质和纹理的一致性。
- en: In our game, let me illustrate with an example. We’ll set up a Canvas for the
    overall scene and, within this main canvas, each panel will function as an individual
    Canvas. This means that when we make updates, such as to the HUD canvas during
    gameplay, we won’t be affecting the **Pause** panel or any other panels. It’s
    crucial to ensure that every panel or view has its dedicated canvas component,
    preventing performance issues when updates are applied.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，让我用一个例子来说明。我们将为整个场景设置一个画布，在这个主画布内，每个面板将作为一个独立的画布使用。这意味着当我们进行更新，例如在游戏过程中更新HUD画布时，我们不会影响**暂停**面板或其他任何面板。确保每个面板或视图都有其专用的画布组件，这对于在应用更新时防止性能问题是至关重要的。
- en: The following figure shows the division of the gameplay scene canvases into
    smaller sub-canvases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了游戏场景画布的分割到更小的子画布中。
- en: '![Figure 5.1 – GamePlayCanvas hierarchy](img/B22017_05_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – GamePlayCanvas层次结构](img/B22017_05_1.jpg)'
- en: Figure 5.1 – GamePlayCanvas hierarchy
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – GamePlayCanvas层次结构
- en: 'The following figure shows the **GamePlayCanvas** which contains all canvases:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了包含所有画布的**GamePlayCanvas**：
- en: '![Figure 5.2 – GamePlayCanvas GameObject](img/B22017_05_2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – GamePlayCanvas GameObject](img/B22017_05_2.jpg)'
- en: Figure 5.2 – GamePlayCanvas GameObject
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – GamePlayCanvas GameObject
- en: 'The following figure shows the **PauseCanvas** which is a child of **GamePlayCanvas**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了**PauseCanvas**，它是**GamePlayCanvas**的子类：
- en: '![Figure 5.3 – PauseCanvas GameObject](img/B22017_05_3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – PauseCanvas GameObject](img/B22017_05_3.jpg)'
- en: Figure 5.3 – PauseCanvas GameObject
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – PauseCanvas GameObject
- en: Avoiding too many Graphic Raycasters and turning off Raycast Target
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用过多的Graphic Raycasters并关闭Raycast Target
- en: '**Issue #1**: *Not using Graphic* *Raycaster well*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题#1**：*没有很好地使用Graphic Raycaster*'
- en: The **Graphic Raycaster** helps with turning your clicks or taps on the screen
    into things the game understands. It’s like a translator between your actions
    and the game’s UI, figuring out what you’re touching and sending that information
    to the right parts of the game. You need this thing on every screen that needs
    your touch, even on smaller screens inside the big one. But it goes through all
    the places you touch on the screen and checks whether they’re inside a UI’s area,
    which can be a bit much.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Graphic Raycaster**组件有助于将屏幕上的点击或触摸转换为游戏能够理解的内容。它就像是你动作和游戏UI之间的翻译者，确定你触摸的位置，并将该信息发送到游戏的正确部分。你需要在需要触摸的每个屏幕上使用这个组件，即使在大型屏幕内部的小屏幕上也是如此。但是，它需要检查屏幕上你触摸的所有位置，看它们是否在UI区域内，这可能会有些繁琐。'
- en: Even though it’s called a Graphic Raycaster, it doesn’t exactly cast rays. By
    default, it only cares about UI graphics. It looks at all the UI parts that want
    to know when you touch them and checks whether the spot where you touch matches
    up with the UI parts that are set up to respond.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它被称为Graphic Raycaster，但它并不真正发射射线。默认情况下，它只关心UI图形。它查看所有希望知道你何时触摸的UI部分，并检查你触摸的位置是否与已设置响应的UI部分相匹配。
- en: The problem is that not all UI parts want to be bothered when you touch them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于并非所有UI部分都希望在触摸时被打扰。
- en: '`Image` component – we only turn it off for images that you can’t interact
    with:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`组件 – 我们只为无法与之交互的图像关闭它：'
- en: '![Figure 5.4 – RayCast Target variable](img/B22017_05_4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – RayCast Target变量](img/B22017_05_4.jpg)'
- en: Figure 5.4 – RayCast Target variable
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – RayCast Target变量
- en: '**Issue #2**: *Sometimes the Graphic Raycaster does more than just* *translate
    touches.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题#2**：*有时Graphic Raycaster所做的不仅仅是* *翻译触摸*。'
- en: When you set **Render Mode** on your Canvas to **Worldspace Camera** or **Screen
    Space Camera**, a blocking mask can be added. This mask determines whether the
    Raycaster will cast rays using 2D or 3D physics, determining whether any physics
    object obstructs the user’s ability to interact with the UI.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 Canvas 的 **渲染模式** 设置为 **世界空间相机** 或 **屏幕空间相机** 时，可以添加一个阻塞掩码。此掩码确定射线投射器是否使用
    2D 或 3D 物理投射光线，从而确定是否有物理对象阻碍用户与 UI 的交互。
- en: '**Solution**: Casting rays via 2D or 3D physics can be resource-intensive,
    so use this feature judiciously. To minimize the number of Graphic Raycasters,
    exclude them from non-interactive UI Canvases since, in such cases, there is no
    need to check for interaction events.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：通过 2D 或 3D 物理投射光线可能很耗费资源，因此请谨慎使用此功能。为了最小化图形射线投射器的数量，请从非交互式 UI 画布中排除它们，因为在这些情况下，没有必要检查交互事件。'
- en: 'In the following figure, you can see the **Graphic** **Raycaster** component:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你可以看到 **图形** **射线投射器** 组件：
- en: '![Figure 5.5 – Graphic Raycaster component](img/B22017_05_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 图形射线投射器组件](img/B22017_05_5.jpg)'
- en: Figure 5.5 – Graphic Raycaster component
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 图形射线投射器组件
- en: Efficiently managing UI object pools
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效管理 UI 对象池
- en: '**Issue**: *Inefficient practices in UI* *object pooling*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：*UI 对象池中的低效实践*'
- en: Frequently, individuals engage in pooling UI objects by first changing their
    parent and then disabling them, resulting in unnecessary complications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有人通过首先更改父对象然后禁用它来池化 UI 对象，这导致不必要的复杂性。
- en: '**Solution**: Optimize for deactivating the object first before reassigning
    its parent within the pool.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：首先优化对象在池中重新分配父对象之前的禁用操作。'
- en: This strategy ensures that the original hierarchy is dirtied only once. Once
    the object is reparented, there’s no need for an additional round of hierarchy
    changes, and the new hierarchy remains unaffected. When extracting an object from
    the pool, follow the sequence of reparenting it first, updating your data, and
    then activating it to maintain efficiency.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略确保原始层次结构只被污染一次。一旦对象被重新分配父对象，就不再需要额外的层次结构更改，新的层次结构保持不受影响。当从池中提取对象时，首先重新分配其父对象，更新你的数据，然后激活它以保持效率。
- en: Hiding a Canvas the right way
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确隐藏画布的方法
- en: '**Issue**: *Uncertain about efficiently hiding* *a Canvas*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：*不确定如何有效地隐藏* **画布**'
- en: There are times when you want to keep UI Elements and Canvases out of sight.
    But how can you achieve this in an effective manner?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望将 UI 元素和画布隐藏起来。但如何有效地实现这一点呢？
- en: '`Canvas` component itself.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas` 组件本身。'
- en: By disabling the `Canvas` component, you stop the generation of draw calls to
    the GPU, rendering the Canvas invisible. Importantly, the Canvas retains its vertex
    buffer, preserving all meshes and vertices. Consequently, re-enabling it doesn’t
    trigger a rebuild; it simply resumes drawing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过禁用 `Canvas` 组件，你停止了对 GPU 的绘制调用生成，使画布变得不可见。重要的是，画布保留了其顶点缓冲区，保留了所有网格和顶点。因此，重新启用它不会触发重建；它只是继续绘制。
- en: Furthermore, deactivating the `Canvas` component avoids initiating the resource-intensive
    `OnDisable`/`OnEnable` callbacks within the Canvas hierarchy. Just exercise caution
    when disabling child components that execute computationally demanding per-frame
    code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，禁用 `Canvas` 组件可以避免在 Canvas 层次结构中启动资源密集型的 `OnDisable`/`OnEnable` 回调。只是在禁用执行每帧计算密集型代码的子组件时要小心。
- en: Efficient implementation of animations for UI Elements
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI 元素动画的有效实现
- en: '**Issue**: *Implementing animators on* *the UI*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：*在 UI 上实现动画器*'
- en: When animators are applied to the UI, they consistently affect UI Elements in
    every frame, even when the animation value remains constant.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画器应用于 UI 时，它们会持续影响每一帧的 UI 元素，即使动画值保持不变。
- en: '**Solution**: Employ code for UI animation.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：使用代码进行 UI 动画。'
- en: Restrict the use of animators to dynamic UI Elements that undergo constant changes.
    For elements that infrequently change or experience temporary alterations triggered
    by events, opt for coding your animations or utilizing a tweening system, a system
    you can make through code or you can use third-party assets for that. Various
    effective solutions for this purpose can be found on the Unity Asset Store. For
    our game, we will use the free `DoTween` package for this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 限制动画师的使用范围，仅限于动态 UI 元素，这些元素会经历持续的变化。对于不经常变化或由事件触发的临时更改的元素，可以选择编写动画代码或使用缓动系统，您可以通过代码创建该系统，或者可以使用第三方资源。在
    Unity Asset Store 上可以找到各种有效的解决方案。对于我们的游戏，我们将使用免费的 `DoTween` 包来完成这项工作。
- en: Effective handling of fullscreen UIs
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效处理全屏 UI
- en: '**Issue**: *Performance issues with* *fullscreen UIs*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：*全屏 UI 的性能问题*'
- en: When a pause or start screen occupies the entire display, the remaining elements
    of the game continue rendering in the background, potentially leading to performance
    problems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当暂停或开始屏幕占据整个显示时，游戏的其他元素将继续在后台渲染，这可能导致性能问题。
- en: '**Solution**: Hide everything else.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：隐藏所有其他内容。'
- en: If you present a screen that overlays the entire scene, deactivate the camera
    responsible for rendering the 3D scene. Likewise, disable Canvas elements positioned
    beneath the top Canvas.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您展示一个覆盖整个场景的屏幕，请禁用负责渲染 3D 场景的相机。同样，禁用位于顶部 Canvas 之下的 Canvas 元素。
- en: Contemplate reducing `Application.targetFrameRate` when engaging a fullscreen
    UI, as there is no necessity for updates at a **60** **fps** rate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当全屏 UI 启用时，考虑降低 `Application.targetFrameRate`，因为没有必要以 **60** **fps** 的速率进行更新。
- en: Now that we have understood the best practices and optimization techniques for
    the UI, let’s move on to the next section where we will explore some architectural
    patterns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 UI 的最佳实践和优化技术，让我们继续下一节，我们将探讨一些架构模式。
- en: Introducing architecture patterns (MVC and MVVM)
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍架构模式（MVC 和 MVVM）
- en: In the world of game development, organizing and managing the UI is crucial
    for creating engaging and efficient experiences. Two widely used architectural
    patterns – namely, **Model-View-Controller** (**MVC**) and **Model-View-ViewModel**
    (**MVVM**) – provide frameworks for structuring UI elements in a way that enhances
    clarity and maintainability. MVC separates the application into three interconnected
    components — the **model** for data and logic, the **view** for the user interface,
    and the **controller** for managing user input. On the other hand, MVVM introduces
    **ViewModel** as a mediator between the model and the view, simplifying presentation
    logic and data binding, which is the automatic synchronization of data between
    the UI and the underlying data model in software applications. In this section,
    we will explore the practical application of these patterns in Unity game development,
    offering insights and guidance to help you make informed decisions about structuring
    your game’s UI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的世界里，组织和管理 UI 对于创建引人入胜且高效的体验至关重要。两种广泛使用的架构模式——即 **模型-视图-控制器**（**MVC**）和
    **模型-视图-视图模型**（**MVVM**）——为以增强清晰性和可维护性方式结构化 UI 元素提供了框架。MVC 将应用程序分为三个相互关联的组件——用于数据和逻辑的
    **模型**，用于用户界面的 **视图**，以及用于管理用户输入的 **控制器**。另一方面，MVVM 引入了 **ViewModel** 作为模型和视图之间的中介，简化了表示逻辑和数据绑定，即软件应用程序中
    UI 和底层数据模型之间的数据自动同步。在本节中，我们将探讨这些模式在 Unity 游戏开发中的实际应用，提供见解和指导，帮助您在结构化游戏 UI 时做出明智的决定。
- en: Understanding MVC – a teamwork of three roles
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 MVC – 三角合作的三种角色
- en: In the following figure, you can see the arrangement of the MVC pattern and
    how its components interact.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您可以查看 MVC 模式的布局及其组件的交互方式。
- en: '![Figure 5.6 – MVC structure](img/B22017_05_6.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – MVC 结构](img/B22017_05_6.jpg)'
- en: Figure 5.6 – MVC structure
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – MVC 结构
- en: 'Let’s understand a little bit more about the MVC structure:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 MVC 结构：
- en: '**Model**:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：'
- en: '*Essence*: Represents the data and business logic of the application'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本质*：代表应用程序的数据和业务逻辑'
- en: '*Unity implementation*: Often implemented as **ScriptableObject** or regular
    C# class instances'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unity 实现*：通常实现为 **ScriptableObject** 或常规 C# 类实例'
- en: '*Role*: Manages data, enforces business rules, and communicates changes to
    the view'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*角色*：管理数据，执行业务规则，并将更改通知给视图'
- en: '**View**:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：'
- en: '*Essence*: Represents the UI elements, responsible for displaying data to the
    user'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本质*：代表 UI 元素，负责向用户显示数据'
- en: '*Unity implementation*: Comprises Unity UI components, such as **Canvas**,
    **Text**, **Image**, and so on'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Renders the data from the model and handles user input interactions,
    forwarding them to the controller'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Acts as an intermediary between the model and the view, handling
    user input and updating the model and view accordingly'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: A **MonoBehaviour** script attached to Unity UI elements
    or game objects.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Listens for user input, updates the model, and instructs the view to
    reflect changes'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction flow**:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*User input*: Captured by the controller'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Model update*: The controller updates the model based on user input'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*View update*: The view receives notifications from the model and updates the
    UI accordingly'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros** **in Unity**:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simplicity*: Well suited for smaller projects and straightforward UI structures'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity compatibility*: Aligns seamlessly with Unity’s built-in UI system'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons** **in Unity**:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Potential complexity*: May lead to increased complexity as the project grows'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data binding challenges*: Achieving efficient data binding might require additional
    effort'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move on to understanding the next architectural pattern, MVVM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MVVM – a mix of views and models
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the arrangement of the MVVM pattern and
    how its components interact:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – MVVM structure](img/B22017_05_7.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – MVVM structure
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand a little bit more about the MVVM structure:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Represents the data and business logic, similar to MVC'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: **ScriptableObject** or regular C# class instances,
    much like in MVC'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Manages data, enforces business rules, and communicates changes to
    the view'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Represents the UI, responsible for displaying data'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: Unity UI components, same as in MVC'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Renders the data from the model and handles user input interactions,
    forwarding them to the controller'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Acts as an intermediary between the model and the view, exposing
    properties and commands'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: A **MonoBehaviour** script that facilitates data binding'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Simplifies data binding by exposing data and logic for the view to
    bind to directly'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction flow**:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*User input*: Captured by the view or directly by the ViewModel'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Model update*: The ViewModel updates the model based on user input'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*View update*: When data changes occur in the model, they automatically update
    the view through data binding'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros** **in Unity**:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enhanced data binding*: Streamlines the process of updating the UI in response
    to changes in the underlying data'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testability*: ViewModel components can be tested independently, fostering
    maintainability'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons** **in Unity**:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning curve*: May pose a learning curve for developers unfamiliar with
    the pattern'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overhead of abstraction*: Introducing an additional layer with the ViewModel
    might be considered over-engineering for smaller projects'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象的额外开销*：对于较小的项目，引入 ViewModel 可能被认为是过度设计'
- en: Now that we understand what MVC and MVVM are, let’s explore how to decide between
    them for our project based on certain factors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 MVC 和 MVVM 是什么，让我们探讨如何根据某些因素决定我们的项目之间如何选择它们。
- en: Choosing the right path for Unity UI
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的 Unity UI 路径
- en: 'The following points explain why we would choose MVC in Unity:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点解释了为什么我们会选择在 Unity 中使用 MVC：
- en: '**Well-established compatibility**: Unity’s built-in UI system aligns naturally
    with the principles of MVC'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**良好的兼容性**：Unity 内置的 UI 系统与 MVC 原则自然对齐'
- en: '**Simplicity for smaller projects**: For smaller projects or when simplicity
    is crucial, MVC can be a pragmatic choice'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用于较小项目的简单性**：对于较小的项目或当简单性至关重要时，MVC 可以是一个务实的选择'
- en: 'The following points explain why we would choose MVVM in Unity:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点解释了为什么我们会选择在 Unity 中使用 MVVM：
- en: '**Data-driven complexity**: MVVM shines in scenarios demanding efficient data
    binding and complex UI structures'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据驱动的复杂性**：MVVM 在需要高效数据绑定和复杂 UI 结构的场景中表现出色'
- en: '**Scaling for larger projects**: MVVM facilitates scalability and maintainability,
    making it a robust choice for larger endeavors'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用于更大项目的扩展性**：MVVM 促进可扩展性和可维护性，使其成为较大项目的稳健选择'
- en: 'The following points will help you select your approach:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点将帮助你选择你的方法：
- en: '**Consider project size**: MVC’s simplicity may be advantageous for smaller
    projects, while MVVM’s enhanced data binding and testability are beneficial for
    larger endeavors'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑项目规模**：MVC 的简单性可能对较小的项目有利，而 MVVM 的增强数据绑定和可测试性对较大的项目有益'
- en: '**Evaluate data binding needs**: If efficient data binding is crucial, MVVM
    might be the preferred choice'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估数据绑定需求**：如果高效的数据绑定至关重要，MVVM 可能是首选方案'
- en: The journey through Unity UI development is a dynamic exploration, guided by
    the architectural choices of MVC and MVVM. While MVC offers simplicity and familiarity,
    MVVM introduces a layer of abstraction, elevating data binding and testability.
    As you navigate the Unity UI architecture, consider the specific needs of your
    project, the complexity of your UI, and the familiarity of your development team.
    Whether adhering to the clarity of MVC or embracing the sophistication of MVVM,
    the path you choose defines not only the structure of your UI but also the foundation
    of an immersive player experience. For our game, we will go with the MVC structure.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI 开发之旅是一个动态探索过程，由 MVC 和 MVVM 的架构选择引导。虽然 MVC 提供了简单性和熟悉性，但 MVVM 引入了一层抽象，提高了数据绑定和可测试性。在导航
    Unity UI 架构时，考虑你项目的具体需求、UI 的复杂性和开发团队的熟悉度。无论遵循 MVC 的清晰性还是拥抱 MVVM 的复杂性，你选择的路径不仅定义了
    UI 的结构，也定义了沉浸式玩家体验的基础。对于我们的游戏，我们将采用 MVC 结构。
- en: Practical suggestions for enhancing your UI development
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高你的 UI 开发效率的实用建议
- en: Here are some tips that can be beneficial for you while working on UI.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在工作 UI 时可能对你有益的建议：
- en: 'Create Prefabs for the most frequently used elements:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为最常用的元素创建预制体：
- en: For this, consider using the title text as an example and attaching components
    to it. This makes it easier to implement changes later, as any modifications will
    impact all the elements in the game. Additionally, you can create images and any
    other UI elements.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于此，可以考虑使用标题文本作为示例，并将其组件附加到它上。这使得以后实施更改变得更容易，因为任何修改都将影响游戏中的所有元素。此外，你还可以创建图像和其他
    UI 元素。
- en: 'Use Sprite Atlases:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sprite Atlas：
- en: A Sprite Atlas is a feature in Unity that allows you to pack multiple Sprite
    textures into a single texture asset. This is particularly useful for optimizing
    and improving the performance of your game, as it reduces the number of draw calls
    by combining multiple Sprites into one texture.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sprite Atlas 是 Unity 中的一个功能，允许你将多个 Sprite 纹理打包成一个单独的纹理资产。这对于优化和提升游戏性能特别有用，因为它通过将多个
    Sprite 合并到一个纹理中，减少了绘制调用的次数。
- en: 'Here are some key points about Sprite Atlas in Unity:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是关于 Unity 中 Sprite Atlas 的一些关键点：
- en: '**Draw call optimization**: By using Sprite Atlases, Unity can efficiently
    render multiple Sprites with a single draw call, which can significantly improve
    performance, especially on mobile devices.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘制调用优化**：通过使用 Sprite Atlas，Unity 可以高效地通过单个绘制调用渲染多个 Sprite，这可以显著提高性能，尤其是在移动设备上。'
- en: '**Grouping textures**: Sprite Atlases enable you to group multiple Sprites
    or textures together, making it easier to manage and organize your game assets.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理分组**：Sprite Atlases 允许你将多个 Sprite 或纹理组合在一起，使管理游戏资源更容易。'
- en: '**Texture packing**: Unity’s Sprite Atlas system performs automatic texture
    packing, arranging individual Sprites within the Atlas to minimize wasted space
    and optimize texture usage.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理打包**：Unity 的 Sprite Atlas 系统执行自动纹理打包，将单个 Sprite 在 Atlas 中排列，以最小化浪费的空间并优化纹理使用。'
- en: '**Mipmapping**: Sprite Atlases support mipmapping, which helps improve the
    rendering quality of textures when they are viewed from a distance.'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mipmapping**：Sprite Atlases 支持Mipmapping，有助于提高从远处查看纹理时的渲染质量。'
- en: '**Atlas variants**: Unity allows you to create different variants of Sprite
    Atlases for different platforms or screen resolutions, ensuring optimal performance
    across various devices.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Atlas 变体**：Unity 允许你为不同的平台或屏幕分辨率创建不同的 Sprite Atlas 变体，确保在各种设备上实现最佳性能。'
- en: '**Integration with Unity Editor**: You can create and manage Sprite Atlases
    directly within the Unity Editor, making it convenient for game developers to
    visualize and adjust their assets.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与 Unity 编辑器的集成**：你可以在 Unity 编辑器中直接创建和管理 Sprite Atlases，这使得游戏开发者能够方便地可视化并调整他们的资源。'
- en: 'Design alignment using a transparent image overlay:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用透明图像叠加设计对齐：
- en: When provided with a designer’s view sample, you can overlay an image representing
    the final result with slight transparency. This allows you to align and organize
    the view according to the design.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提供设计师视图样本时，你可以叠加一个表示最终结果的图像，具有轻微的不透明度。这允许你根据设计对视图进行对齐和组织。
- en: 'Using the UI Extensions package:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI 扩展包：
- en: 'Discover the UI Extensions package, a valuable toolkit that significantly amplifies
    the capabilities of Unity’s native UI system. Here’s an overview of its key features:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现 UI 扩展包，这是一个宝贵的工具包，显著增强了 Unity 原生 UI 系统的功能。以下是其关键功能的概述：
- en: '**Extensive controls**: With over 70 additional UI controls, it offers advanced
    text fields (auto-complete, password masking, multi-line), sliders, progress bars,
    checkboxes, toggles, color pickers, dropdowns, list views, tree views, grids,
    tooltips, modal windows, context menus, toolbars, docking panels, and more.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广泛的控件**：包含超过 70 个额外的 UI 控件，提供高级文本字段（自动完成、密码掩码、多行）、滑块、进度条、复选框、开关、颜色选择器、下拉菜单、列表视图、树视图、网格、工具提示、模态窗口、上下文菜单、工具栏、停靠面板等。'
- en: '**Customization flexibility**: Enjoy extensive customization options for existing
    UI elements, including the addition of shadows, outlines, and other visual effects,
    animation of properties (position, color, size), and the creation of custom layouts
    and interactions.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制灵活性**：享受现有 UI 元素的广泛定制选项，包括添加阴影、轮廓和其他视觉效果，属性（位置、颜色、大小）的动画，以及创建自定义布局和交互。'
- en: '**Utility functions**: Benefit from various helpful utility functions for easy
    alignment and positioning of elements. Moreover, discover a shortcut for anchoring
    elements to corners, particularly useful for managing multiple resolutions, especially
    in mobile games.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用函数**：利用各种有用的实用函数，轻松对元素进行对齐和定位。此外，发现了一个将元素锚定到角落的快捷方式，这对于管理多个分辨率尤其有用，尤其是在移动游戏中。'
- en: This package provides a robust set of tools and features, making UI development
    in Unity more flexible and efficient.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此包提供了一套强大工具和功能，使 Unity 的 UI 开发更加灵活和高效。
- en: Now that we understand practical tips and architectural pattern (MVC and MVVM)
    structures, let’s dive into creating a UI system using C# to efficiently handle
    UI behavior in our Unity project.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实用技巧和架构模式（MVC 和 MVVM）结构，让我们深入探讨使用 C# 创建 UI 系统，以有效地在我们的 Unity 项目中处理
    UI 行为。
- en: Creating a UI system using C#
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 创建 UI 系统
- en: In this section, we will create a C# system for handling UI behavior, leveraging
    optimization tips and the MVC structure to achieve our objectives. This involves
    creating a `UIManager` class to oversee views, a `BaseView` class containing core
    view logic, and a practical example demonstrating the implementation of the UI
    system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个 C# 系统，用于处理 UI 行为，利用优化技巧和 MVC 结构来实现我们的目标。这包括创建一个 `UIManager` 类来监督视图，一个包含核心视图逻辑的
    `BaseView` 类，以及一个演示 UI 系统实现的实际示例。
- en: The UIManager class
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`UIManager` 类'
- en: To kick off this system, we’ll establish a base class called `UIManager`. This
    class will handle the invocation of `show` and `hide` functions for views and
    will act as a container for all the views. For each scene, we’ll create a child
    of `UIManager`, responsible for controlling the views within that specific scene.
    This scene-specific manager will hold all the views, providing us with better
    control over them. This setup allows us to hide all views, ensuring that only
    one view is active at a time, which is advantageous for performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动这个系统，我们将创建一个名为 `UIManager` 的基类。这个类将处理视图的 `show` 和 `hide` 函数的调用，并将作为所有视图的容器。对于每个场景，我们将创建
    `UIManager` 的一个子类，负责控制该特定场景内的视图。这个特定场景的管理器将包含所有视图，为我们提供对这些视图的更好控制。这种设置允许我们隐藏所有视图，确保一次只有一个视图处于活动状态，这对性能有利。
- en: 'The following code block provides a sample of the `UIManager` base class, which
    includes generic functions for showing and hiding views:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块提供了一个 `UIManager` 基类的示例，其中包含显示和隐藏视图的泛型函数：
- en: '[PRE0]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code block, we employed generic functions to handle the showing
    and hiding of views based on their type directly, avoiding the use of strings
    for improved performance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用了泛型函数来直接根据类型处理视图的显示和隐藏，以避免使用字符串以提高性能。
- en: We begin by registering the view and adding it to the dictionary, enabling us
    to hide or show it throughout the gameplay session. Additionally, we have functions
    to retrieve the view when needed, allowing access or performing specific actions
    on that view.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注册视图并将其添加到字典中，这样我们就可以在整个游戏过程中隐藏或显示它。此外，我们还有在需要时检索视图的函数，允许访问或对该视图执行特定操作。
- en: Utilizing UIManager
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 UIManager
- en: To utilize this class, we can create child classes for each scene and either
    attach this component to a GameObject or simply place it on the main canvas of
    the scene.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个类，我们可以为每个场景创建子类，并将此组件附加到一个 GameObject 上，或者简单地将其放置在场景的主画布上。
- en: 'As evident in the upcoming code block, we have `HUDManager`, which inherits
    from `UIManager`. We will attach it to the main canvas of the gameplay scene to
    manage and control all views associated with this scene:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如即将到来的代码块所示，我们有 `HUDManager`，它继承自 `UIManager`。我们将将其附加到游戏场景的主画布上，以管理和控制与该场景相关的所有视图：
- en: '[PRE1]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the following figure, you’ll notice the `HUDManager` component connected
    to the main canvas:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您将注意到 `HUDManager` 组件连接到了主画布：
- en: '![Figure 5.8 – The HUDManager component](img/B22017_05_8.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – HUDManager 组件](img/B22017_05_8.jpg)'
- en: Figure 5.8 – The HUDManager component
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – HUDManager 组件
- en: Now, we can proceed to the other key component of the UI system, which is the
    `BaseView` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到 UI 系统的另一个关键组件，即 `BaseView` 类。
- en: The BaseView class
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础视图类
- en: In the UI system, we require a foundational class for all views, encompassing
    core functions that define the view’s behavior, actions, or logic during `hide`
    and `show` operations. While the UI manager is responsible for invoking these
    functions, the underlying logic resides in the base class. We predominantly utilize
    `hide` and `show` canvas processes for efficiency, and for animations during these
    operations, we leverage the `DoTween` package.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 系统中，我们需要一个基础类来处理所有视图，包括在 `hide` 和 `show` 操作期间定义视图行为、动作或逻辑的核心功能。虽然 UI 管理器负责调用这些函数，但底层逻辑位于基类中。我们主要利用
    `hide` 和 `show` 画布过程以提高效率，并在这些操作期间利用 `DoTween` 包进行动画。
- en: 'In the following code block, you’ll find the `BaseView` class along with its
    core functions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，您将找到 `BaseView` 类及其核心函数：
- en: '[PRE2]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `BaseView` class serves as a foundational element within our UI system,
    facilitating essential functionalities crucial for managing views in Unity projects.
    At its core, this class offers methods to both show and hide views seamlessly.
    Moreover, it seamlessly integrates with `tween` components, enabling the application
    of animations during view transitions. Beyond its fundamental functions, the `BaseView`
    class provides a suite of auxiliary methods, offering invaluable support for implementing
    the intricate logic of our game.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseView` 类在我们的 UI 系统中充当基础元素，为 Unity 项目中管理视图提供关键功能。在其核心，这个类提供了显示和隐藏视图的方法。此外，它无缝地与
    `tween` 组件集成，允许在视图转换期间应用动画。除了其基本功能外，`BaseView` 类提供了一套辅助方法，为我们的游戏实现复杂逻辑提供了宝贵的支持。'
- en: Now that we understand the functionality of the `BaseView` class, let’s proceed
    to grasp the functionality of the `UITween` component, which is utilized for animating
    the views.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `BaseView` 类的功能，让我们继续了解 `UITween` 组件的功能，它用于对视图进行动画处理。
- en: The UITween component
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UITween 组件
- en: The `UITween` component serves as a wrapper that I’ve created for utilizing
    `DoTween`, simplifying the process of adding and removing animations in the Inspector
    for showing or hiding views.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITween` 组件是我创建的一个包装器，用于利用 `DoTween`，简化在检查器中添加和删除动画以显示或隐藏视图的过程。'
- en: You can locate all of these classes and additional resources in the GitHub repository,
    the link to which is mentioned in the Technical requirements section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 仓库中找到所有这些类和附加资源，其链接在技术要求部分中提到。
- en: In the following figure, you’ll observe the `UITween` component. This serves
    as a sample class, and we can adjust it to suit our game.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您将观察到 `UITween` 组件。这是一个示例类，我们可以根据游戏需求进行调整。
- en: '![Figure 5.9 – The UITween component](img/B22017_05_9.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – UITween 组件](img/B22017_05_9.jpg)'
- en: Figure 5.9 – The UITween component
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – UITween 组件
- en: Utilizing BaseView
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 BaseView
- en: To utilize the `BaseView` class, all you need to do is create a child class
    for each view in the game, enabling the use of core functions. Afterward, you
    can incorporate specific logic for each view.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `BaseView` 类，您只需为游戏中的每个视图创建一个子类，从而启用核心功能的使用。之后，您可以为每个视图添加特定的逻辑。
- en: 'In the following code block, you’ll see an example of the `BaseView` class
    usage:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，您将看到 `BaseView` 类的使用示例：
- en: '[PRE3]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `TopBar` class, functioning as a view class, will be responsible for displaying
    elements such as the player’s currency in the game. Simply attach the `TopBar`
    class to a `TopBar` Canvas GameObject in your game scene, and you’re done.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopBar` 类，作为一个视图类，将负责显示游戏中的玩家货币等元素。只需将 `TopBar` 类附加到游戏场景中的 `TopBar` Canvas
    GameObject 上，即可完成。'
- en: 'In the following figure, you’ll observe the `TopBarView` component attached
    to its canvas:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您将观察到附加到其画布上的 `TopBarView` 组件：
- en: '![Figure 5.10 – The TopBarView component](img/B22017_05_10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – TopBarView 组件](img/B22017_05_10.jpg)'
- en: Figure 5.10 – The TopBarView component
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – TopBarView 组件
- en: This system serves as an abstract framework for the UI system, providing a foundation
    that can be customized or extended with additional logic as needed for the game.
    Feel free to tailor and expand upon this structure according to the specific requirements
    of your game.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统作为 UI 系统的抽象框架，提供了一个可以自定义或根据游戏需要扩展逻辑的基础。请根据您游戏的具体要求调整和扩展这个结构。
- en: Next, let’s take an example to see how MVVM would be implemented.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过一个例子来看一下 MVVM 的实现方式。
- en: Implementing MVVM
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现MVVM
- en: Implementing the MVVM structure in Unity involves separating the logic and data
    management from the UI elements. Let’s look at an example implementation of MVVM
    in Unity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中实现 MVVM 结构涉及将逻辑和数据管理从 UI 元素中分离出来。让我们看看 Unity 中 MVVM 的一个示例实现。
- en: 'In the following code block, `PlayerData` represents the data structure, such
    as player level and score:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，`PlayerData` 代表数据结构，例如玩家等级和分数：
- en: '[PRE4]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the following code block, `PlayerViewModel` acts as an intermediary between
    the model and the view. It holds the logic for data manipulation and exposes properties
    that the view can bind to:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，`PlayerViewModel` 作为模型和视图之间的中介。它包含数据操作的逻辑，并公开视图可以绑定的属性：
- en: '[PRE5]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following code block, `PlayerView` represents the UI elements and is
    responsible for displaying data from `ViewModel`. It subscribes to `ViewModel`
    events and updates UI elements based on changes in `ViewModel`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，`PlayerView` 代表 UI 元素，并负责显示 `ViewModel` 中的数据。它订阅 `ViewModel` 事件并根据
    `ViewModel` 的变化更新 UI 元素：
- en: '[PRE6]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This structure allows for a clear separation of concerns, with `ViewModel` handling
    the logic and data manipulation while the view focuses solely on UI representation.
    Data binding ensures that changes in `ViewModel` automatically reflect in the
    view, promoting a more organized and maintainable code base.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构允许清晰地分离关注点，其中 `ViewModel` 负责逻辑和数据操作，而视图则专注于 UI 表示。数据绑定确保 `ViewModel` 中的更改自动反映在视图中，从而促进更组织化和可维护的代码库。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to improve our game interfaces using C#. We
    started by getting better at making the parts of the UI work faster. Then, we
    figured out ways to organize and control the different views in our game. The
    skills you picked up here gave you the tools to make your UI look good and run
    smoothly based on what your game needs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 C# 提升我们的游戏界面。我们首先通过提高 UI 各部分的运行速度来提升技能。然后，我们找到了组织和控制游戏内不同视图的方法。在这里学到的技能为你提供了根据游戏需求使
    UI 看起来美观且运行流畅的工具。
- en: In the upcoming [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), we’ll dive
    into handling game data using C#. We’ll learn how to organize and save game information
    in Unity. These skills will help us manage game progress, save and load game states,
    and create features that use stored data. As you continue on this coding adventure,
    you’ll discover new ways to handle game data effectively with C#. Get ready for
    more coding challenges in the upcoming chapter. Happy coding!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的[*第 6 章*](B22017_06.xhtml#_idTextAnchor098)中，我们将深入探讨使用 C# 处理游戏数据。我们将学习如何在
    Unity 中组织和保存游戏信息。这些技能将帮助我们管理游戏进度、保存和加载游戏状态，以及创建使用存储数据的特性。随着你继续这段编码之旅，你将发现使用 C#
    有效处理游戏数据的新方法。为即将到来的章节中的更多编码挑战做好准备。祝编码愉快！
