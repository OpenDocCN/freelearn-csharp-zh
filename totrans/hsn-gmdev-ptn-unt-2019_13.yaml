- en: Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about the Observer pattern, but we are
    going to take a different approach from our previous chapters, for the simple
    reason that the Observer pattern is already natively implemented in the Unity
    engine, in the form of the C# event system. But just to cover our bases, we will
    quickly review the classic form of the Observer pattern and then compare it to
    the C# event system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the the Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing how it's implemented natively in the C# event system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a hands-on chapter, so you will need to have a basic understanding of
    Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following Unity-specific engine and C# language concept(s):'
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't need to know about them before starting this chapter, but it would
    help to take the time to review some online documentation on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Fy4HvP](http://bit.ly/2Fy4HvP)'
  prefs: []
  type: TYPE_NORMAL
- en: A preview of the Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name implies, the purpose of the Observer pattern is to observe. To be
    more precise, the core purpose of the Observer is to observe other objects and
    specific changes in their internal states. Before the Observer pattern, the only
    way to watch an object from the *outside, looking in* was by calling constantly
    or *pinging* its public members in the hope that you would capture a change in
    its values.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern was designed to solve this limitation by defining a system
    in which objects (subjects) maintain a list of other objects (observers). Subjects
    call observers when they need to broadcast a change on their side.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the principles of this system with this real-world example
    of a Wall Street broker managing a catalog of stocks (subjects) associated with
    a list of clients (observers). When particular market events occur, the broker
    calls all their clients to let them know that the value of their stocks has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a UML diagram of a typical implementation of the Observer pattern
    to see how this might work when implemented in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e843293c-2b96-46ca-8fba-4c42b1f2ddc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the subject and the observer both have their respective interfaces,
    but the most important one to analyze is `ISubject`, which includes the following
    public functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Attach()`: This function allows the addition of an observer object to the
    list of observers to notify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Detach()`: This one removes an observer from the list of observers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notify()`: This will notify all the observers that have been attached to the
    subject''s observer list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though this is not a very complicated design to implement, it can become
    very tedious to write each time you need to observe other objects. Modern languages
    such as C# have natively implemented the Observer pattern in the form of an event
    system, so programmers don't have to write it out manually.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike applications such as spreadsheets, which usually only change their current
    run-states depending on users' interactions, we must take note that games are
    not event-driven; instead, it's the main game loop that drives the game forward.
  prefs: []
  type: TYPE_NORMAL
- en: The C# event system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a Unity developer, you will probably never need to implement a complete
    Observer pattern by hand because C# has a native implementation of the Observer
    natively available in the form of the event system. But before we start writing
    code, let''s review the core components of the C# event system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Events:** When an event is raised by an object (publisher), it sends out
    a signal that other objects (subscribers) can capture. This concept might sound
    very familiar to that of throwing and handling exceptions, in the sense that when
    an exception is thrown, it goes up the call stack until it''s handled. But in
    the case of the event system, there''s not really a call chain, because once an
    object broadcasts an event, only those objects that subscribe to it will be notified
    and can choose to get triggered by it or just ignore it. So, we can basically
    imagine it has as a sudden burst of a radio signal that only those with antennas
    can listen to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegates:** The concept behind delegates is simple when you understand their
    underlying low-level mechanism. A high-level definition of delegates is that they
    hold references to functions. They are very useful when you want to trigger multiple
    functions from one call—in other words, when you want to multicast. But this is
    a very abstract definition of what delegates actually do behind the scenes. They''re
    basically function pointers, which means that they hold the memory address to
    other functions. So, we could visualize them as an address book that contains
    a list of locations of functions. And that''s why a delegate can hold multiple
    functions and call them all at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Observer is one of those patterns that has become embedded in modern languages
    and code bases. It would be hard not to use this pattern, as its drawbacks are
    limited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loose coupling**: The main advantage of the Observer is that it decouples
    observed objects from observers. They don''t need to know one another; they just
    broadcast or listen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Send data to anyone**: You can easily send data to and from one object to
    another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop listening at any time**: There''s no explicit contract between subjects
    and listeners, so they can stop broadcasting if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a drawback:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Noisy code**: The Observer pattern has brought about the event-driven paradigm,
    but it can can become noisy and difficult to manage, if overused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Observer pattern in the form of an event system is often used to manage
    user input, but let's see whether we can use events for something else, such as
    an automated system that broadcasts its state changes to other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we are building a classic puzzle game with a countdown timer. As in
    most games or sports that have timers, we will give our player a unique sign and
    feedback to remind them how much time there is left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our three main timer feedback events are going to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Clock started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Half time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time's up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each event, let''s trigger something unique, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Dim the lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger a buzzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a message on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But the challenge here is this: how are we going to notify the individual systems
    or components that manage the lighting, sounds, and UI of the state of the timer?
    When we have this type of problem, the Observer pattern becomes very useful, in
    the form of the event system: we will be able to have all those individual systems
    listen to the timer while it broadcasts specific timed events.'
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start this code example by implementing the most important
    component of an Observer pattern: the subject. Without something to observe, the
    Observer pattern has no use. Refer to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of our code example, the `Timer` class is going to be our subject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's not much code; it's quite simple to implement a subject
    with the C# event system. The most important thing is the relationship between
    the `delegate` and the `event` type. An *event* is a message sent by an object,
    but during the communication process, it doesn't know which objects will receive
    its message, so it needs a pointer-like mechanism that can act as an intermediate
    between the sender and the receivers, and that's when delegates are required.
    Just imagine the delegate as the one that points the event message to the right
    *observers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also another important detail to keep in mind. Notice that every time
    we call an event such as `OnTimerEnded()`, it checks for nulls on its associated
    event-type reference before raising the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We do this because we can't broadcast an event if no one is listening. We need
    at least one observer that will handle the reception of the event. This is the
    way the event system is implemented and manages its references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our subject ready, it''s time to implement the systems that
    will register themselves to receive event messages from our `Timer`. In other
    words, we are going to implement our observers. The first one is `Buzzer`, which
    will notify our player that the timer has started or ended, by making a buzzing
    sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next one in our list is the `WarningLight`, which will blink when the timer
    reaches halftime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As our final observer, we are going to implement `Notifier`, which has the
    responsibility of popping up a message when the time is up and the game is over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We should notice something that all our observers have in common: they all
    register themselves to receive events from the `Timer` by pointing to a specific
    local function. This implementation means that when the `Timer` broadcasts an
    event, all those objects that are observing it will get one of their local methods
    called automatically. Therefore, a remote event can provoke a local function call
    of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Another point to keep in mind is that an event can't point to `null` references,
    so it's good practice to make sure an object will remove itself as an observer
    if it gets disabled.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern expressed through the C# event system offers a simple but
    powerful way of implementing an observer-and-subject relationship between objects,
    without explicit coupling and with a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to implement the Observer pattern by building
    a timer that can trigger behaviors in our scene by having components listen to
    specific timed events. An important take away from this pattern is that the Observer
    pattern is natively implemented in Unity in the form of the C# event system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the State pattern. Another useful pattern
    for game programming, it is somewhat related to the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have learned in this chapter, the Observer pattern was the inspiration
    for the C# event system. But, of course, it's not an exact implementation of this
    pattern. So, as an exercise, I would encourage you to re-write the timer system
    that we just implemented, but without using the C# event system; instead, follow
    the design of the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the UML diagram shown at the beginning of the chapter as a starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: It's common to see design patterns implemented in unorthodox ways. Often, design
    patterns inspire programmers to structure their code in a certain way, but rarely
    will you see an accurate and "by the book" implementation of a specific pattern
    in production code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides([http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&WT.oss_r=1&item=171742](http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&WT.oss_r=1&item=171742))'
  prefs: []
  type: TYPE_NORMAL
