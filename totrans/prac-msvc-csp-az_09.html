<html><head></head><body>
		<div id="_idContainer118">
			<h1 id="_idParaDest-217" class="chapter-number"><a id="_idTextAnchor216"/>9</h1>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/>Authentication and Authorization with Services and Clients</h1>
			<p>Not every user and application should be allowed to access all API services. Some APIs should only be accessible from specific applications, and others should be restricted to a group <span class="No-Break">of users.</span></p>
			<p>In this chapter, you’ll <a id="_idIndexMarker675"/>learn how to use <strong class="bold">business-to-consumer</strong> (<strong class="bold">B2C</strong>) to allow users to register with our application and protect APIs. We’ll use <a id="_idIndexMarker676"/>Azure <strong class="bold">Active Directory</strong> (<strong class="bold">AD</strong>) B2C for this. For an on-premises solution (which can also be used in the cloud), we’ll be using ASP.NET <span class="No-Break">Core Identity.</span></p>
			<p>Instead <a id="_idIndexMarker677"/>of securing every API project, you’ll learn about Microsoft <strong class="bold">Yet Another Reverse Proxy</strong> (<strong class="bold">YARP</strong>), a proxy that is put in front of the APIs that are available to restrict access to the services in <span class="No-Break">the backend.</span></p>
			<p>In this chapter, you’ll learn how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Create an Azure AD <span class="No-Break">B2C tenant</span></li>
				<li>Secure <span class="No-Break">REST APIs</span></li>
				<li>Use <span class="No-Break">Microsoft YARP</span></li>
				<li>Use ASP.NET <span class="No-Break">Core Identity</span></li>
			</ul>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription, Docker Desktop, and .<span class="No-Break">NET Aspire.</span></p>
			<p>The code for this chapter can be found in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure"><span class="No-Break">h</span><span class="No-Break">ttps://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">ch09</strong> folder contains the following projects, along with <span class="No-Break">their outputs:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.ApiGateway</strong>: This is a new project that will act as an application gateway in front of the <strong class="source-inline">game-apis</strong> service and <strong class="source-inline">bot-service</strong> and secure the APIs with the help <span class="No-Break">of YARP</span></li>
				<li><strong class="source-inline">WebAppAuth</strong>: This is a new project for the client part that focuses on creating new users with Azure AD B2C, providing authentication from the client side, and invoking <strong class="source-inline">bot-service</strong> via <span class="No-Break">the gateway</span></li>
				<li><strong class="source-inline">Codebreaker.ApiGateway.Identities</strong>: This is a new project that can be used instead of <strong class="source-inline">Codebreaker.ApiGateway</strong> where instead of using Azure AD B2C, local users are created <span class="No-Break">and managed</span></li>
			</ul>
			<p>To help you go through the code with this chapter, start by using the code from the <span class="No-Break">previous chapter.</span></p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Choosing an identity solution</h1>
			<p>Different options are available to authenticate users with .NET solutions. If you require a local database <a id="_idIndexMarker678"/>that can manage users, you can use <strong class="bold">ASP.NET Core Identity</strong>, which makes <a id="_idIndexMarker679"/>use of EF Core (see <a href="B21217_05.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>). It allows you to store local users and integrate user accounts, such as those from Microsoft, Facebook, and <a id="_idIndexMarker680"/>Google, with <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>). For the database, SQL Server and MySQL can be used, while the data schema is <span class="No-Break">completely customizable.</span></p>
			<p>To reduce the work required, and to enhance security, it’s not necessary to implement this functionality with every service – here, Microsoft YARP can be used to forward the requests and send the <span class="No-Break">required claims.</span></p>
			<p>If external applications are accessing the identity management solution, an <strong class="bold">OIDC</strong> server should be used to manage identities. If storing user data in a cloud service is not an option, a third-party service such as Identity Server from Duende (<a href="https://duendesoftware.com/products/communityedition">https://duendesoftware.com/products/communityedition</a>) can be used. This is free for <span class="No-Break">small companies.</span></p>
			<p>To store user <a id="_idIndexMarker681"/>data in a cloud service, many companies use <strong class="bold">Microsoft Entra</strong>. This can <a id="_idIndexMarker682"/>easily be integrated with .NET applications. This service offers <strong class="bold">business-to-business</strong> (<strong class="bold">B2B</strong>) functionality that allows you <a id="_idIndexMarker683"/>to add external users (<strong class="bold">Entra External Identities</strong>). Microsoft, Facebook, and Google accounts are on the list of supported external users. However, at the <a id="_idIndexMarker684"/>time of writing, <strong class="bold">Microsoft Entra</strong> does not allow <a id="_idIndexMarker685"/>users to register themselves. For this, <strong class="bold">Azure AD B2C</strong> is a great option. This service can also be used with services running on-premises and accessing authentication from <span class="No-Break">the cloud.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">With its user data residency requirement, Azure AD B2C allows you to select a country when you’re creating a directory and shows the location for the data. However, if, for example, the requirement is to keep the user data in Switzerland, it’s stored in Europe, which might not be enough for the legal requirements of <span class="No-Break">some businesses.</span></p>
			<p>For the Codebreaker solution, we’ll use Azure AD B2C and ASP.NET <span class="No-Break">Core Identity.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor220"/>Creating an Azure AD B2C tenant</h1>
			<p>The Codebreaker solution should allow users to register with the application and play different game types. Some limited game types are available to anonymous users. All the game <a id="_idIndexMarker686"/>types and more functionalities are available to registered users. Some parts of the solution should only be accessible to specific user groups – for example, <strong class="source-inline">bot-service</strong> should not be accessible from normal registered playing users. Specific user permissions (or claims) are required <span class="No-Break">for differentiation.</span></p>
			<p>To create a new AAD B2C tenant, open the Azure portal and click <strong class="bold">Create a resource</strong>. Select <strong class="bold">Identity</strong> from the left bar and choose <strong class="bold">Azure Active Directory B2C</strong>. Then, select <strong class="bold">Create a new Azure AD B2C Tenant</strong>. This will open the screen shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B21217_09_01.jpg" alt="Figure 9.1 – Creating an AAD B2C tenant"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Creating an AAD B2C tenant</p>
			<p>To create a <a id="_idIndexMarker687"/>new AAD B2C tenant, you need to enter the name of the organization, the name of the domain name (a domain name that does not exist yet), the location that will be used to define the region where the user data is stored, a subscription, and a resource group. Once you’ve done this, click <strong class="bold">Review + Create</strong>, <span class="No-Break">then </span><span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break">.</span></p>
			<p>You’ll need to wait a short time for the directory to be created. To list the directories available to you, and to switch directories, within the Azure portal, click the <strong class="bold">Settings</strong> button. Select the new directory and click <strong class="bold">Switch</strong> to change to it. Similarly, you can switch back to the directory where you run <span class="No-Break">Azure resources.</span></p>
			<p>In the <a id="_idIndexMarker688"/>next few sections, we’ll do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Specify identity providers so that the user doesn’t need to enter <span class="No-Break">another password</span></li>
				<li>Configure user attributes to define what information the application needs from <span class="No-Break">the user</span></li>
				<li>Define user flows to specify how the user <span class="No-Break">information flows</span></li>
				<li>Create app registrations to define service applications that offer APIs and client applications for <span class="No-Break">accessing APIs</span></li>
			</ul>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Specifying identity providers</h2>
			<p>When you <a id="_idIndexMarker689"/>are in an Azure AD B2C, you can open the Azure AD B2C configuration. The B2C directory supports a large list of different identity providers. Users don’t need to remember another password when they use identity providers. Within the Azure AD B2C configuration, in the <strong class="bold">Manage</strong> category in the left pane, select <strong class="bold">Identity provider</strong> (see <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B21217_09_02.jpg" alt="Figure 9.2 – Identity providers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Identity providers</p>
			<p>By default, <strong class="bold">Local account</strong> is configured so that a password is stored locally with AAD B2C. You can <a id="_idIndexMarker690"/>configure Microsoft, Google, Facebook, and other accounts that support OIDC. The Codebreaker directory has GitHub configured as a provider because most developers already have a <span class="No-Break">GitHub account.</span></p>
			<p>For each provider, you’re what needs to be done to configure it. You just need to click on the provider to get that information. With GitHub, for example, you need to create a GitHub OAuth application to get all the values you need to configure this provider. For authenticating services with AAD B2C, you can keep the <span class="No-Break">default settings.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Configuring user attributes</h2>
			<p>No matter <a id="_idIndexMarker691"/>which provider you choose, you must have a way to identify users. To gather such information, you must ask your users for details. You can also create custom attributes that should be stored in the directory. Within the <strong class="bold">Manage</strong> category, select <strong class="bold">User Attributes</strong>, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B21217_09_03.jpg" alt="Figure 9.3 – User Attributes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – User Attributes</p>
			<p>Here, several built-in attributes, such as <strong class="bold">Given Name</strong>, <strong class="bold">Surname</strong>, <strong class="bold">City</strong>, <strong class="bold">Country/Region</strong>, and more, are available. You can also add custom attributes. Add a custom <a id="_idIndexMarker692"/>attribute called <strong class="source-inline">Gamer Name</strong> of the <span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break"> type.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Due <a id="_idIndexMarker693"/>to the <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>), you need to ensure you only collect necessary data and keep it secured, allow the user to ask for the data that you’ve stored, and allow the user to delete that data if it doesn’t need to be stored for <span class="No-Break">legal reasons.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Defining user flows</h2>
			<p>With user <a id="_idIndexMarker694"/>flows, you define what information should be collected from the user when registering or editing the user profile, and what information should be sent to the application <span class="No-Break">within </span><span class="No-Break"><strong class="bold">claims</strong></span><span class="No-Break">.</span></p>
			<p>Within the AAD B2C configuration, from the left pane, within the <strong class="bold">Policies</strong> category, click <strong class="bold">User flows</strong>. Create a new user flow for <strong class="bold">Sign up and sign in</strong>. The user flow’s name is prefixed with <strong class="source-inline">B2C_1_</strong>. Add a name (for example, <strong class="source-inline">SUSI</strong>) and select the <strong class="bold">Email</strong> signup identity provider. You can also select social providers such as GitHub. Regarding the <strong class="bold">User attributes and token claims</strong> category, select the user attributes the user should enter when this dialogue is shown, as well as the claims that are passed to the application within a token, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B21217_09_04.jpg" alt="Figure 9.4 – Creating a user flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Creating a user flow</p>
			<p>When defining what information to ask from the user, keep GDPR <span class="No-Break">in mind.</span></p>
			<p>Azure AD B2C allows you to customize user flow dialogues by specifying company branding, changing the page layout, returning custom pages, and adding API connectors for custom <a id="_idIndexMarker695"/>validators when a <span class="No-Break">user registers.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">User attributes <a id="_idIndexMarker696"/>can be filled by creating user flows or <strong class="bold">custom policies</strong>. See the links in the <em class="italic">Further reading</em> section for more information. Also, check out the source code in the Codebreaker Backend repository (<a href="https://github.com/codebreakerapp/Codebreaker.Backend">https://github.com/codebreakerapp/Codebreaker.Backend</a>), which contains a custom policy for adding groups for <span class="No-Break">privileged users.</span></p>
			<p>As soon as an application has been registered (the next step), you can test the user flow, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B21217_09_05.jpg" alt="Figure 9.5 – Testing the user flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Testing the user flow</p>
			<p>Selecting the user attributes that should be collected defines the input elements of the dialogue. The icon, colors, and <a id="_idIndexMarker697"/>layout can be customized. It’s even possible to create complete <span class="No-Break">custom dialogues.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>Creating app registrations</h2>
			<p>Next, we’ll <a id="_idIndexMarker698"/>learn how to register apps. Here, we <a id="_idIndexMarker699"/>will register the application gateway that offers APIs and a client application. Other applications can be <span class="No-Break">registered similarly.</span></p>
			<p>In the <strong class="bold">Manage</strong> category in the left pane, click <strong class="bold">App registrations</strong>. This opens the <strong class="bold">App registrations</strong> page, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B21217_09_06.jpg" alt="Figure 9.6 – Registering an app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Registering an app</p>
			<p>Add multiple <a id="_idIndexMarker700"/>app registrations: the <strong class="source-inline">Codebreaker.GameAPIs</strong> application <a id="_idIndexMarker701"/>offers the game APIs, <strong class="source-inline">Codebreaker.Bot</strong> and <strong class="source-inline">Codebreaker.Blazor</strong> are web applications that need API permissions, and <strong class="source-inline">Codebreaker.Client</strong> is a client application that needs <span class="No-Break">API permissions.</span></p>
			<p>When you configure the app registration process, you specify what accounts are allowed to use this application. Here, we’ll allow all accounts, externally registered users, and the <a id="_idIndexMarker702"/>redirect URI. To test the <strong class="source-inline">game-apis</strong> service from <a id="_idIndexMarker703"/>the local developer system, specify the port number that’s used when running it locally, such as <strong class="source-inline">http://localhost:5453</strong>, and click the <strong class="bold">Register</strong> button. The link to the Azure container app needs to be <span class="No-Break">added later.</span></p>
			<h3>Defining scopes</h3>
			<p>You can specify <a id="_idIndexMarker704"/>applications that offer APIs via the app registration process. In the <strong class="bold">Manage</strong> category, you’ll see the <strong class="bold">Expose an API</strong> option. Click <strong class="bold">Add a Scope</strong>. The root scope can be the proposed GUID, but you can define a more readable name, such as <strong class="source-inline">games</strong>. Within this scope, add the <strong class="source-inline">Games.Play</strong> and <strong class="source-inline">Games.Query</strong> scopes, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B21217_09_07.jpg" alt="Figure 9.7 – Defining scopes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Defining scopes</p>
			<h3>Creating a secret</h3>
			<p>To only allow <a id="_idIndexMarker705"/>applications that have been identified applications, you can add a certificate or a secret. Instead of using secrets, a better approach could be to run the application with a user that is allowed to access the service. Here, managed identities can be used. This is not possible in <span class="No-Break">all scenarios.</span></p>
			<p>Using the <strong class="bold">Certificates and secrets</strong> option from the left pane, create a client secret. Secrets cannot be read from the portal again, only after creation. Copy the secret before leaving <span class="No-Break">the page.</span></p>
			<h3>Adding API permissions</h3>
			<p>For application <a id="_idIndexMarker706"/>registrations that invoke APIs, you need to configure <strong class="bold">API permissions</strong>, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B21217_09_08.jpg" alt="Figure 9.8 – Adding API permissions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Adding API permissions</p>
			<p>The <strong class="source-inline">Codebreaker.Blazor</strong> and <strong class="source-inline">Codebreaker.Client</strong> application registrations need the <strong class="source-inline">Games.Play</strong> and <strong class="source-inline">Games.Query</strong> application permissions. After adding these permissions, click <strong class="bold">Grant </strong><span class="No-Break"><strong class="bold">admin consent</strong></span><span class="No-Break">.</span></p>
			<h3>Evaluating the app registration process</h3>
			<p>With this <a id="_idIndexMarker707"/>configuration complete, open <strong class="bold">Integration assistant</strong> and check if the application registration supports the recommended configurations. Select the application type and check if the application invokes APIs (such as <strong class="source-inline">bot-service</strong> and the client applications). Then, click <strong class="bold">Evaluate my app registration</strong>, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B21217_09_09.jpg" alt="Figure 9.9 – Integration assistant results"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Integration assistant results</p>
			<p>The integration <a id="_idIndexMarker708"/>assistant offers great information for development, testing, releasing, and monitoring when you click the tabs above the recommended configurations. If you see some warnings or errors, click the ellipsis (<strong class="bold">…</strong>). From here, you can check the documentation and open a page where you can change <span class="No-Break">your configuration.</span></p>
			<p>With Azure AD B2C configured, let’s implement some code so that we can make use of <span class="No-Break">AAD B2C.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Securing an API</h1>
			<p>We can now <a id="_idIndexMarker709"/>secure every API project. However, there are different ways we can do this so that we can reduce the work we need to do. One option is to use Azure Container Apps to configure authentication. Instead of configuring this for every container app, let’s create a new project that will be secured and routed to multiple services. For this, we’ll <span class="No-Break">use </span><span class="No-Break"><strong class="bold">YARP</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/>Creating a new project with authentication</h2>
			<p>Create a new <a id="_idIndexMarker710"/>Web API project by using the .NET template with the <strong class="source-inline">-au</strong> <span class="No-Break">authentication option:</span></p>
			<pre class="console">
dotnet new webapi -minimal -au IndividualB2C -o Codebreaker.ApiGateway</pre>
			<p>Using the .NET CLI, you can also pass all the values needed to configure the B2C service, such as <strong class="source-inline">--domain</strong> for the domain, <strong class="source-inline">--aad-b2c-instance</strong> to pass the domain link for logging in, <strong class="source-inline">--client-id</strong> for the application ID, <strong class="source-inline">--susi-policy-id</strong> for the signup user flow (before it was called <em class="italic">user flow</em>, it was called <em class="italic">policy</em>), and <strong class="source-inline">--default-scope</strong> to configure a scope. If you don’t assign parameter values for these configurations, you just need to change them after they’ve been created in the <span class="No-Break"><strong class="source-inline">appsettings.json</strong></span><span class="No-Break"> file.</span></p>
			<p>The NuGet packages related to authentication and authorization that have been added to this project are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">Microsoft.AspNetCore.Authentication.JwtBearer</strong>: This package supports <a id="_idIndexMarker711"/>authentication using <strong class="bold">JSON Web </strong><span class="No-Break"><strong class="bold">Tokens</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JWT</strong></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">Microsoft.AspNetCore.Authentication.OpenIdConnect</strong>: This package allows authentication with an OIDC against identity providers, such as Azure <span class="No-Break">AD B2C</span></li>
				<li><strong class="source-inline">Microsoft.Identity.Web</strong>: This package provides utilities and middleware for authentication flows and <span class="No-Break">user authorization</span></li>
				<li><strong class="source-inline">Microsoft.Identity.Web.DownstreamApi</strong>: This package helps call downstream APIs using the same <span class="No-Break">authentication context</span></li>
			</ul>
			<p>Next, we’ll add YARP to <span class="No-Break">this project.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>Creating an application gateway with YARP</h2>
			<p>When creating a microservices solution, it’s not necessary to implement authentication with every service. Instead, you can create a service that acts as a reverse proxy. Clients only <a id="_idIndexMarker712"/>call into the reverse proxy. This proxy forwards authenticated requests to other services. Here, we’ll use Microsoft YARP. A reverse proxy sits in front of backend services and intercepts invocations from a client before it is sent to the service. The YARP proxy offers different features, such as load balancing, rate limiting, switching of protocols, selecting services based on different versions, and more. Based on Layer 7, the proxy can read HTTP requests to route based on links and HTTP headers, as well as change the protocol that’s used. Here, we’ll use a reverse proxy to deal with authentication and authorization before forwarding the requests to the <span class="No-Break">backend service.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.10</em> shows the new way to communicate with <span class="No-Break">the services:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B21217_09_10.jpg" alt="Figure 9.10 – Communication via YARP"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Communication via YARP</p>
			<p>The reverse proxy routes incoming requests to backend services. The backend services that have been routed are <strong class="source-inline">game-apis</strong> and <strong class="source-inline">bot-service</strong>. The client applications don’t interact with these services; they just use the <span class="No-Break">YARP gateway.</span></p>
			<p>In <a id="_idIndexMarker713"/>addition to the NuGet packages we added earlier, we need to add the <strong class="source-inline">Yarp.ReverseProxy</strong> and <strong class="source-inline">Microsoft.Extensions.ServiceDiscovery.Yarp</strong> NuGet packages. The first one is the package for YARP, while the second one allows us to use.NET service discovery <span class="No-Break">with YARP.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/>Mapping routes with YARP</h2>
			<p>How the <a id="_idIndexMarker714"/>proxy service communicates with the backend APIs can be configured both programmatically and using a configuration file. We’ll use the second option with the <strong class="source-inline">appsettings.json</strong> file. First, let’s configure the addresses of the <strong class="source-inline">game-apis</strong> service <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">bot-service</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGatewayIntro/appsettings.json</p>
			<pre class="source-code">
{
  "ReverseProxy": {
    <strong class="bold">"Clusters":</strong> {
      "gamesapicluster": {
        <strong class="bold">"Destinations":</strong> {
          "gamescluster/destination1": {
            "Address": "http://gameapis"
          }
        }
      }
      "botcluster": {
<strong class="bold">        "Destinations": {</strong>
          "botcluster/destination1": {
            "Address": "http://bot"
          }
        }
      },
    },
    // configuration removed for brevity
  }
}</pre>
			<p>The complete <a id="_idIndexMarker715"/>reverse proxy configuration is added to the <strong class="source-inline">ReverseProxy</strong> section, The configuration section, called <strong class="source-inline">Clusters</strong>, defines the list of systems that are available for the <strong class="source-inline">game-apis</strong> service and <strong class="source-inline">bot-service</strong>. With every service, multiple addresses can be added. Using the service discovery YARP package, we can use the .NET Aspire <span class="No-Break">named endpoints.</span></p>
			<p>The following code configures the routes that use the <span class="No-Break">cluster configuration:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGatewayIntro/appsettings.json</p>
			<pre class="source-code">
{
  "ReverseProxy": {
    // configuration removed for brevity
    <strong class="bold">"Routes":</strong> {
      "gamesRoute": {
        "ClusterId": "gamesapicluster",
        <strong class="bold">"Match":</strong> {
          <strong class="bold">"Path":</strong> "/games/{*any}"
        }
      },
      "botRoute": {
        "ClusterId": "botcluster",
        <strong class="bold">"Match":</strong> {
          <strong class="bold">"Path":</strong> "/bot/{*any}"
        }
      }
    }
  }
}</pre>
			<p>The <strong class="source-inline">Routes</strong> configuration contains a list of routes. <strong class="source-inline">gamesRoute</strong> references the previously specified <strong class="source-inline">gamesapicluster</strong>, while <strong class="source-inline">botRoute</strong> references the hosts defined by <strong class="source-inline">botcluster</strong>. The <strong class="source-inline">Match</strong> configuration specifies the <strong class="source-inline">Path</strong> that’s used to map the request to the <span class="No-Break">corresponding cluster.</span></p>
			<p>We just <a id="_idIndexMarker716"/>need to make a small update to the startup code to activate this reverse <span class="No-Break">proxy library:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.Services.AddReverseProxy()</strong>
<strong class="bold">  .LoadFromConfig(</strong>
<strong class="bold">    builder.Configuration.GetSection("ReverseProxy"));</strong>
var app = builder.Build();
<strong class="bold">app.MapReverseProxy();</strong>
app.Run();</pre>
			<p>The <strong class="source-inline">AddReverseProxy</strong> method registers the services that are needed by the reverse proxy to the DI container. The <strong class="source-inline">LoadFromConfig</strong> method retrieves the configuration values from the previously specified configuration. The <strong class="source-inline">MapReverseProxy</strong> method configures the middleware to forward the requests, as defined by <span class="No-Break">the configuration.</span></p>
			<p>With the <strong class="source-inline">AppHost</strong> project, after adding a reference to the gateway project, the gateway can be added to the <span class="No-Break">app model:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
  .WithReference(cosmos)
  .WithEnvironment("DataStore", dataStore);
var bot = builder.AddProject&lt;Projects.CodeBreaker_Bot&gt;("bot")
  .WithReference(gameAPIs);
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_ApiGateway&gt;("gateway")</strong>
<strong class="bold">  .WithReference(gameAPIs)</strong>
<strong class="bold">  </strong><strong class="bold">.WithReference(bot)</strong>
<strong class="bold">  .WithExternalHttpEndpoints();</strong>
// code removed for brevity</pre>
			<p>The API <a id="_idIndexMarker717"/>gateway needs to reference the <strong class="source-inline">game-apis</strong> service and <strong class="source-inline">bot-service</strong>. Here, external HTTP endpoints are no longer needed. Only the gateway needs references from outside when it’s deployed to the Azure Container Apps environment, thus only the gateway configuration uses the <span class="No-Break"><strong class="source-inline">WithExternalHttpEndpoints</strong></span><span class="No-Break"> method.</span></p>
			<p>With this in place, you can start the application and invoke the two services via the gateway. The requests are forwarded to the <span class="No-Break">specific service.</span></p>
			<p>Next, we’ll add authentication to <span class="No-Break">the gateway.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>Adding authentication to the gateway</h2>
			<p>Using the .NET <a id="_idIndexMarker718"/>template for the Web API with Identity already added some code for authentication and authorization. We will enhance this <span class="No-Break">code now.</span></p>
			<p>We can configure the DI container to authenticate users by invoking the <span class="No-Break"><strong class="source-inline">AddAuthentication</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.<strong class="bold">AddAuthentication</strong>(JwtBearerDefaults.AuthenticationScheme)
  .<strong class="bold">AddMicrosoftIdentityWebApi</strong>(
    <strong class="bold">builder.Configuration.GetSection("AzureAdB2C")</strong>);
// code removed for brevity</pre>
			<p>The <strong class="source-inline">AddAuthentication</strong> method registers services that are needed for authentication. The <strong class="source-inline">JwtBearerDefaults.AuthenticationScheme</strong> argument returns <strong class="bold">Bearer</strong> as the authentication scheme. Bearer tokens are used with most REST APIs because they can be used easily and don’t require encryption but need to perform HTTPS encryption to <span class="No-Break">secure it.</span></p>
			<p><strong class="source-inline">AddMicrosoftIdentityWebApi</strong> is an extension method that extends <strong class="source-inline">AuthenticationBuilder</strong> and protects the API using the Microsoft Identity platform. <strong class="source-inline">AzureAdB2C</strong> is a configuration section that specifies the values from AADB2C <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">appsettings.json</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/appsettings.json</p>
			<pre class="source-code">
{
  // configuration removed for brevity
  «AzureAdB2C»: {
<strong class="bold">    «Instance»: «https://&lt;domain&gt;.b2clogin.com»,</strong>
<strong class="bold">    «Domain»: «&lt;domain&gt;.onmicrosoft.com»,</strong>
<strong class="bold">    "ClientId": "&lt;app-id&gt;",</strong>
<strong class="bold">    "SignedOutCallbackPath": "/signout/B2C_1_SUSI",</strong>
<strong class="bold">    "SignUpSignInPolicyId": "B2C_1_SUSI"</strong>
  }
}</pre>
			<p>With the <strong class="source-inline">appsettings.json</strong> configuration file, you need to configure your Azure AD B2C <a id="_idIndexMarker719"/>domain name, the application ID, and the previously configured <span class="No-Break">user flow.</span></p>
			<p>The <strong class="source-inline">AddAuthentication</strong> method specifies the <span class="No-Break">authentication configuration:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
// code removed for brevity
builder.Services.<strong class="bold">AddAuthentication</strong>(JwtBearerDefaults.AuthenticationScheme)
  .<strong class="bold">AddMicrosoftIdentityWebApi</strong>(
    builder.Configuration.GetSection("AzureAdB2C"));
builder.Services.<strong class="bold">AddAuthorization</strong>(options =&gt;
{
<strong class="bold">  options.AddPolicy("playPolicy", config =&gt;</strong>
<strong class="bold">  </strong><strong class="bold">{</strong>
<strong class="bold">    config.RequireScope("Games.Play");</strong>
<strong class="bold">  });</strong>
<strong class="bold">  options.AddPolicy("queryPolicy", config =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    config.RequireScope("Games.Query");</strong>
<strong class="bold">    config.RequireAuthentication();</strong>
<strong class="bold">  }</strong>
});</pre>
			<p>The <strong class="source-inline">AddAuthorization</strong> method <a id="_idIndexMarker720"/>allows configuration with an <strong class="source-inline">AuthorizationOptions</strong> delegate. The options allow you to specify a default policy and named policies. The preceding code snippet defines the <strong class="source-inline">playPolicy</strong> and <strong class="source-inline">queryPolicy</strong> policies. <strong class="source-inline">playPolicy</strong> requires the <strong class="source-inline">Games.Play</strong> scope to be set, whereas <strong class="source-inline">queryPolicy</strong> requires the <strong class="source-inline">Games.Query</strong> scope to be set. <strong class="source-inline">queryPolicy</strong> also requires <a id="_idIndexMarker721"/>the user to be authenticated. You can define a claim to be passed with the token by using the <span class="No-Break"><strong class="source-inline">RequireClaim</strong></span><span class="No-Break"> method.</span></p>
			<p>With the policies in place, routes can be restricted to the <span class="No-Break">required policies:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/appsettings.json</p>
			<pre class="source-code">
// configuration removed for brevity
  "ReverseProxy": {
    "Routes": {
      "botRoute": {
        "ClusterId": "botcluster",
<strong class="bold">        "AuthorizationPolicy": "botPolicy",</strong>
        "Match": {
          "Path": "/bot/{*any}"
        }
      },</pre>
			<p>Using the <strong class="source-inline">AuthorizationPolicy</strong> configuration, alongside <strong class="source-inline">botRoute</strong>, <strong class="source-inline">botPolicy</strong> is referenced to require authenticated users and the application to send the <span class="No-Break">correct scope.</span></p>
			<p>Now that we’ve configured the DI container, the middleware needs to <span class="No-Break">be configured:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPis/Program.cs</p>
			<pre class="source-code">
var app = builder.Build();
<strong class="bold">app.UseAuthentication();</strong>
<strong class="bold">app.UseAuthorization();</strong>
// code removed for brevity</pre>
			<p>The <strong class="source-inline">UseAuthentication</strong> method adds <a id="_idIndexMarker722"/>authentication middleware, while the <strong class="source-inline">UseAuthorization</strong> method adds <span class="No-Break">authorization middleware.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If the minimal API needs to be restricted directly, the <strong class="source-inline">RequireAuthorization</strong> extension method can be used. A policy can be passed as an argument to check for the policy’s requirements. Upon injecting <strong class="source-inline">ClaimsPrincipal</strong> as an argument to a minimal API method, information about the user and claim information can be retrieved programmatically. This allows us to check for restrictions based on values that are retrieved with <span class="No-Break">the API.</span></p>
			<p>To test <a id="_idIndexMarker723"/>this out, we’ll update our <span class="No-Break">client application.</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/>Authentication using Microsoft Identity with ASP.NET Core web applications</h1>
			<p>To <a id="_idIndexMarker724"/>authenticate <a id="_idIndexMarker725"/>using Azure AD B2C, we’ll use the Microsoft Identity platform. In this section, we’ll focus on creating accounts with Azure AD B2C, logging in, and invoking secured REST APIs with ASP.NET Core <span class="No-Break">web applications.</span></p>
			<p>Like with the minimal API we created earlier, a .NET template can be used. Invoke this command to create a <span class="No-Break">new project:</span></p>
			<pre class="console">
dotnet new webapp -au IndividualB2C -o WebAppAuth</pre>
			<p>In creating this project, several NuGet packages are added for identities and authentication. These were discussed when we secured the API. An additional package that hasn’t been used before is <strong class="source-inline">Microsoft.Identity.Web.UI</strong>. This package integrates with <strong class="source-inline">Microsoft.Identity.Web</strong> and offers pre-built UI elements for login, logout, and <span class="No-Break">profile management.</span></p>
			<p>With <a id="_idIndexMarker726"/>the DI <a id="_idIndexMarker727"/>container configuration, authentication is added. So, we need to customize it for <span class="No-Break">calling APIs:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">WebAppAuth/Program.cs</p>
			<pre class="source-code">
IConfigurationSection scopeSections = builder.Configuration
  .GetSection("AzureAdB2C").GetSection("Scopes");
String[] scopes = scopeSection.Get&lt;string[]&gt;() == [];
<strong class="bold">builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)</strong>
<strong class="bold">  .AddMicrosoftIdentityWebApp(</strong>
<strong class="bold">    builder.Configuration.GetSection("AzureAdB2C"))</strong>
<strong class="bold">  .EnableTokenAcquisitionToCallDownstreamApi(scopes)</strong>
<strong class="bold">  .AddInMemoryTokenCaches();</strong></pre>
			<p>To use Azure AAD B2C, <strong class="source-inline">AddAuthentication</strong> is invoked using the configuration from the <strong class="source-inline">AzureAdB2C</strong> section within <strong class="source-inline">appsettings.json</strong>. <strong class="source-inline">AddMicrosoftIdentityWeb</strong> is an extension method from the <strong class="source-inline">Microsoft.Identity.Web</strong> NuGet package. This configures supporting cookies and <strong class="source-inline">OpenIdConnect</strong>. The <strong class="source-inline">EnableTokenAcquisitionToCallDownstreamApi</strong> method allows us to pass tokens that have been received from the application so that we can forward them to the APIs that have been invoked by the application via <strong class="source-inline">HttpClient</strong>. When using this method, the <strong class="source-inline">ITokenAcquisition</strong> interface is registered in the DI container. This can be used to retrieve the tokens and pass them to the HTTP headers <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">HttpClient</strong></span><span class="No-Break">.</span></p>
			<p>For the Microsoft Identity user interface, the <strong class="source-inline">AddMicrosoftIdentityUI</strong> method needs to be configured with the <span class="No-Break">DI container:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">WebAppAuth/Program.cs</p>
			<pre class="source-code">
<strong class="bold">builder.Services.AddRazorPages()</strong>
<strong class="bold">  .AddMicrosoftIdentityUI();</strong></pre>
			<p>This <a id="_idIndexMarker728"/>method <a id="_idIndexMarker729"/>configures <strong class="source-inline">AccountController</strong> (based on ASP.NET Core MVC) with <strong class="source-inline">SignIn</strong> and <strong class="source-inline">SignOut</strong> methods in the <span class="No-Break"><strong class="source-inline">MicrosoftIdentity</strong></span><span class="No-Break"> area.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">When creating Blazor client applications, AD B2C support is built-in with .NET 7 templates, but not with .NET 8. Support has been planned for .NET 9. You can add AD B2C <span class="No-Break">integration manually.</span></p>
			<p class="callout">Some differences in authentication can be implemented with different client technologies. Check out the links in the <em class="italic">Further reading</em> section for more information. Also, check out the Codebreaker GitHub (<a href="https://github.com/codebreakerapp">https://github.com/codebreakerapp</a>) for implementations for Blazor, WinUI, .NET MAUI, WPF, and <span class="No-Break">Uno Platform.</span></p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/>Specifying authentication with Azure Container Apps</h1>
			<p>Instead of <a id="_idIndexMarker730"/>needing to manage authentication with the service itself, we can do this directly with Azure Container Apps. After selecting the deployed games API, within the Azure portal, choose <strong class="bold">Authentication</strong> from the <strong class="bold">Settings</strong> category in the left pane. Here, you can add an <strong class="bold">identity provider</strong>. By selecting <strong class="bold">Microsoft</strong>, you can configure <strong class="bold">Workforce</strong> or <strong class="bold">Customer</strong> tenant types. <strong class="bold">Workforce</strong> is for B2B scenarios. Here, you can directly create an app registration within Microsoft Entra. For B2C, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Customer</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/>Using ASP.NET Core Identity to store user information in a local database</h1>
			<p>If Azure <a id="_idIndexMarker731"/>AD B2C is not <a id="_idIndexMarker732"/>an option for you, you can use <strong class="bold">ASP.NET Core Identity</strong>, which .NET offers for storing users in a local database. We’ll use this as an alternative way to run the solution without the need to configure Azure <span class="No-Break">AD B2C.</span></p>
			<p>With <strong class="bold">ASP .NET Core Blazor</strong>, a template <a id="_idIndexMarker733"/>is available to create the core code needed to create an application that allows users to register, store user information in a database, and manage users. Use this template with the <strong class="source-inline">-au </strong><span class="No-Break"><strong class="source-inline">Individual</strong></span><span class="No-Break"> option:</span></p>
			<pre class="console">
dotnet new blazor -au Individual -int Auto -o Codebreaker.ApiGateway.Identities</pre>
			<p>This creates two projects: <strong class="source-inline">Codebreaker.ApiGateway.Identities</strong> and <strong class="source-inline">Codebreaker.ApiGateway.Identities.Client</strong>. The second project is a library that <a id="_idIndexMarker734"/>contains <strong class="bold">Razor components</strong> that can be run on the client <a id="_idIndexMarker735"/>with <strong class="bold">interactive WebAssembly rendering</strong>, as <a id="_idIndexMarker736"/>well as <strong class="bold">interactive server rendering</strong>. This library was referenced in the first project, which hosts the Blazor application and contains Razor components that support interactive server rendering. This project contains a huge list of Razor components for registering users to help users with forgotten passwords, as well as components for managing <span class="No-Break">user information.</span></p>
			<p>Let’s cover some important parts of this application, beginning with <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor233"/>Customizing the EF Core configuration</h2>
			<p>With this <a id="_idIndexMarker737"/>project, user information is <a id="_idIndexMarker738"/>stored in a relational database via EF Core. By default, MySQL is used. This can easily be changed to SQL Server, but using MySQL for this scenario is great <span class="No-Break">as well.</span></p>
			<p>What information about users is stored is defined with the <span class="No-Break"><strong class="source-inline">ApplicationDbContext</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Data/ApplicationDbContext.cs</p>
			<pre class="source-code">
public class <strong class="bold">ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) :</strong>
<strong class="bold">  IdentityDbContext&lt;ApplicationUser&gt;(options)</strong>
{
}</pre>
			<p><strong class="source-inline">ApplicationDbContext</strong> is an EF Core context with a hierarchy of base classes. The body of this class is empty as it was created from the template. Adding custom <strong class="source-inline">DbSet</strong> properties <a id="_idIndexMarker739"/>allows you to add <a id="_idIndexMarker740"/>additional tables to the database. The base class, <strong class="source-inline">IdentityDbContext</strong>, uses the <strong class="source-inline">ApplicationUser</strong> class as a generic parameter to define what information to store about <span class="No-Break">the user:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs</p>
			<pre class="source-code">
public class <strong class="bold">ApplicationUser</strong> : <strong class="bold">IdentityUser</strong>
{
}</pre>
			<p>Adding properties to this class allows you to customize the <strong class="source-inline">users</strong> table with additional columns. To see the defined properties, you need to follow the base classes, starting with <strong class="source-inline">IdentityUser</strong>. <strong class="source-inline">IdentityUser</strong> derives from <strong class="source-inline">IdentityUser&lt;string&gt;</strong>. The generic string parameter specifies the use of GUID values for the key. The generic <strong class="source-inline">IdentiyUser</strong> type defines the <strong class="source-inline">UserName</strong>, <strong class="source-inline">Email</strong>, <strong class="source-inline">PasswordHash</strong>, and <strong class="source-inline">PhoneNumber</strong> properties, among others, to map <span class="No-Break">to columns.</span></p>
			<p><strong class="source-inline">IdentityDbContext&lt;TUser&gt;</strong> has some more base classes, such as <strong class="source-inline">IdentityUserContext&lt;TUser</strong>, <strong class="source-inline">TRole</strong>, <strong class="source-inline">TKey</strong>, <strong class="source-inline">TUserClaim</strong>, <strong class="source-inline">TuserLogin</strong>, and <strong class="source-inline">TUserToken&gt;</strong>, to define several tables that <span class="No-Break">are used.</span></p>
			<p>The EF Core context needs to be configured with the <span class="No-Break">DI container:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
<strong class="bold">builder.AddMySqlDbContext&lt;ApplicationDbContext&gt;("usersdb");</strong></pre>
			<p>Here, the EF Core configuration has been changed to use the <strong class="source-inline">Aspire.Pomelo.EntityFrameworkCore.MySql</strong> NuGet package with the MySQL Entity Framework .NET <span class="No-Break">Aspire component.</span></p>
			<p>With that, the EF Core context has been configured with ASP.NET <span class="No-Break">Core Identity.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>Configuring ASP.NET Core Identity</h2>
			<p>When <a id="_idIndexMarker741"/>configuring ASP.NET Core Identity, EF Core must <span class="No-Break">be mapped:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
<strong class="bold">builder.Services.AddIdentityCore&lt;ApplicationUser&gt;(options =&gt;</strong>
<strong class="bold">  options.SignIn.RequireConfirmedAccount = true)</strong>
<strong class="bold">  .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()</strong>
<strong class="bold">  .AddSignInManager()</strong>
<strong class="bold">  .AddDefaultTokenProviders();</strong></pre>
			<p>The <strong class="source-inline">AddIdentityCore</strong> method configures the <strong class="source-inline">ApplicationUser</strong> class (the same class that was used with the EF Core model) for ASP.NET Core Identity. When the user registers, before using the account, it needs to be confirmed by setting the <strong class="source-inline">RequireConfirmedAccount</strong> property (discussed next). With the invocation of <strong class="source-inline">AddEntityFrameworkStores</strong>, the EF Core context, <strong class="source-inline">ApplicationDbContext</strong>, is mapped to ASP.NET Core Identity. The <strong class="source-inline">AddSignInManager</strong> method registers the <strong class="source-inline">SignInManager</strong> class with the DI container. <strong class="source-inline">SignInManager</strong> can be used to log the user in and out, retrieve claims, and work with two-factor authentication options. The <strong class="source-inline">AddDefaultTokenProviders</strong> method registers token providers by implementing the <strong class="source-inline">IUserTwoFactorTokenProvider</strong> interface to return and validate tokens for two-factor authentication, such as email, phone, and <span class="No-Break">so on.</span></p>
			<p>To confirm an account, the <strong class="source-inline">IEmailSender</strong> interface needs to be registered with the <span class="No-Break">DI container:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs</p>
			<pre class="source-code">
<strong class="bold">builder.Services.AddSingleton&lt;IEmailSender&lt;ApplicationUser&gt;, IdentityNoOpEmailSender&gt;();</strong></pre>
			<p>With the <a id="_idIndexMarker742"/>default configuration, a no-op <strong class="source-inline">IdentityNoOpEmailSender</strong> class is implemented. This is practical for testing purposes but needs to be changed to verify a user’s <span class="No-Break">email address.</span></p>
			<p>Now, let’s configure the project with the .NET Aspire <span class="No-Break">AppHost project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CodebreakerAppHost/Program.cs</p>
			<pre class="source-code">
string startupMode = Environment.GetEnvironmentVariable("STARTUP_MODE") ?? "Azure";
bool useAzureADB2C = startupMode == "Azure";
// code removed for brevity
if (startupMode == "OnPremises")
{
  var usersDbName = "usersdb";
  var mySqlPassword = builder.AddParameter("mysql-password", secret: true);
<strong class="bold">  var usersDb = builder.AddMySql("mysql", password: mySqlPassword)</strong>
<strong class="bold">    .WithEnvironment("MYSQL_DATABASE", usersDbName)</strong>
<strong class="bold">    .WithDataVolume()</strong>
<strong class="bold">    .WithPhpMyAdmin()</strong>
<strong class="bold">    .AddDatabase(usersDbName);</strong>
<strong class="bold">  var gateway = builder.AddProject&lt;Projects.Codebreaker_ApiGateway_</strong>
    <strong class="bold">Identities&gt;("gateway-identities")</strong>
    .WithReference(gameAPIs)
    .WithReference(bot)
<strong class="bold">    .WithReference(usersDb)</strong>
    .WithExternalHttpEndpoints();</pre>
			<p>Here, the AppHost project uses multiple launch profiles to either start the solution with Azure AD B2C (the <strong class="source-inline">Azure</strong> launch profile), or with the local database (the <strong class="source-inline">OnPremises</strong> launch profile). When it comes to the different launch profile settings, the <strong class="source-inline">STARTUP_MODE</strong> environment variable is configured, which is then used to differentiate <a id="_idIndexMarker743"/>the projects to be started and how they are configured. When launching <strong class="source-inline">OnPremises</strong> mode, the newly created project is configured to reference the MySQL database running in a container via the <strong class="source-inline">Aspire.Hosting.MySql</strong> NuGet package. The <strong class="source-inline">WithDataVolume</strong> method creates a named Docker volume (see <a href="B21217_05.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>) to have persistence, while the <strong class="source-inline">WithPhpMyAdmin</strong> method adds an <span class="No-Break">admin UI.</span></p>
			<p>If we run the solution now, we can register a new user, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B21217_09_11.jpg" alt="Figure 9.11 – Registering a local user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Registering a local user</p>
			<p>When registering <a id="_idIndexMarker744"/>the user, you might need to apply EF Core migrations to create the database. On receiving the registration confirmation, choose <strong class="bold">Click here to confirm your account</strong> to approve the email. Then, click the <strong class="bold">Login</strong> button on the left pane. After logging in, the email will be shown on the <strong class="bold">Auth </strong><span class="No-Break"><strong class="bold">Required</strong></span><span class="No-Break"> page.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Instead of having the user remember another password, with ASP.NET Core Identity, it’s also possible to add external providers, such as Microsoft, Facebook, and Google accounts, as shown <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social</span></a><span class="No-Break">.</span></p>
			<p>With phpMyAdmin enabled, you can open the management UI and see the tables that have been created, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B21217_09_12.jpg" alt="Figure 9.12 – MySQL admin UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – MySQL admin UI</p>
			<p>Using this <a id="_idIndexMarker745"/>admin UI, you can perform SQL queries and easily change and <span class="No-Break">delete records.</span></p>
			<p>With ASP.NET Core Identity in place, users can now register with this application and manage their accounts. This option is great if user data isn’t stored within a managed cloud service and can be implemented easily. What about using desktop client applications? They can use an API to access this data. We’ll learn how to add this API in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>Creating identity API endpoints</h2>
			<p>.NET 8 offers identity API endpoints that use the ASP.NET Core <span class="No-Break">Identity infrastructure.</span></p>
			<p>With the <a id="_idIndexMarker746"/>EF Core configuration <a id="_idIndexMarker747"/>for ASP.NET Core Identity in place, all we need to do is configure the identity endpoints with the DI container and the middleware. The DI container must be <span class="No-Break">configured first:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Gateway.Identity/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
builder.Services
<strong class="bold">  .AddIdentityApiEndpoints&lt;ApplicationUser&gt;()</strong>
<strong class="bold">  .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();</strong></pre>
			<p>The <strong class="source-inline">AddIdentityApiEndpoints</strong> method adds authentication with a Bearer token and identity cookies, as well as options and validators to validate allowed passwords and usernames, register <strong class="source-inline">UserManager</strong>, and provide a factory for user claims. <strong class="source-inline">IEmailSender</strong>, which is used to validate correct emails, is configured to use <strong class="source-inline">NoOpEmailSender</strong>. When you have a real implementation of <strong class="source-inline">IEmailSender</strong> in place (using your email provider), you need to make sure you register this class after the invocation of <strong class="source-inline">AddIdentityApiEndpoints</strong> to overwrite <strong class="source-inline">NoOpEmailSender</strong> with your configuration. The <strong class="source-inline">AddEntityFrameworkStores</strong> method is an extension method for the returned <strong class="source-inline">IdentityBuilder</strong> object and adds the EF Core store for user and <span class="No-Break">role data.</span></p>
			<p>The middleware can be configured using the <span class="No-Break"><strong class="source-inline">MapIdentityApi</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Gateway.Identity/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
<strong class="bold">app.MapGroup("/identity")</strong>
<strong class="bold">  .MapIdentityApi&lt;ApplicationUser&gt;();</strong></pre>
			<p>The <strong class="source-inline">MapGroup</strong> method is used to add a common prefix for the identity API. <strong class="source-inline">MapIdentityApi</strong> itself defines several URIs, such as <strong class="source-inline">/register</strong> to register a new user by using <strong class="source-inline">RegisterRequest</strong> with the body of a POST request, and <strong class="source-inline">/login</strong> to log a user in while passing <strong class="source-inline">LoginRequest</strong>, which can include username, password, and two-factor codes, links to reset a forgotten password, confirmation of the email, <span class="No-Break">and more.</span></p>
			<p>Some of these APIs allow anonymous access (for example, when registering or logging in), while with others, authentication is required. The API group with the <strong class="source-inline">/manage</strong> link is configured to <span class="No-Break">require authentication.</span></p>
			<p>When <a id="_idIndexMarker748"/>Swagger is enabled, you’ll see <a id="_idIndexMarker749"/>all these APIs, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.13</em>. This means you can test them before using them from a <span class="No-Break">client application:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B21217_09_13.jpg" alt="Figure 9.13 – Identity API endpoints"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Identity API endpoints</p>
			<p>Try invoking the <strong class="source-inline">/register</strong> API and create a new user passing two values. With a success, HTTP status code <strong class="source-inline">200</strong> is returned with an empty HTTP body if you didn’t create a custom implementation of the <strong class="source-inline">IEmailSender</strong> interface. If this is the case, you can use the MySQL admin UI to approve the user (or change the ASP.NET Core Identity configuration so that it doesn’t require confirmed accounts) before logging in; otherwise, login will <span class="No-Break">be denied.</span></p>
			<p>With a successful login, Bearer tokens are returned. You receive access and refresh tokens and <a id="_idIndexMarker750"/>expiration information <a id="_idIndexMarker751"/>that is set to 3,600 seconds by default. The refresh token can be used with the <strong class="source-inline">/refresh</strong> API to get new access and <span class="No-Break">refresh tokens.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn how <a id="_idIndexMarker752"/>to use SendGrid to implement <strong class="source-inline">IemailSender</strong>, take a look at the following <span class="No-Break">article: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor236"/>Summary</h1>
			<p>In this chapter, you learned how to authenticate users with Azure AD B2C using Microsoft Identities and ASP.NET Core Identity. With Azure AD B2C, you added custom user attributes, specified user flows, and <span class="No-Break">registered applications.</span></p>
			<p>Instead of implementing protection with every API, you created a reverse proxy using Microsoft YARP and protected the APIs with a gateway service. Using YARP, we defined routes to map different backend services and configured policies with routes to require <span class="No-Break">authenticated clients.</span></p>
			<p>You also learned to use ASP.NET Core Identity as an alternative option for authentication and authorization with built-in ASP.NET Core functionality but a simpler <span class="No-Break">feature set.</span></p>
			<p>The next chapter covers how to test microservices solutions, from unit tests to integration tests, including testing services with <span class="No-Break">Microsoft Playwright.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor237"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">Azure AD B2C Claims </em><span class="No-Break"><em class="italic">Schema</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema"><span class="No-Break">https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema</span></a></li>
				<li><em class="italic">Enrich tokens with claims from external sources using API </em><span class="No-Break"><em class="italic">connectors</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment"><span class="No-Break">https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment</span></a></li>
				<li><em class="italic">ASP.NET Core </em><span class="No-Break"><em class="italic">Middleware</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware</span></a></li>
				<li><em class="italic">How to use Identity to secure a Web API backend for </em><span class="No-Break"><em class="italic">SPAs</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization</span></a></li>
				<li><em class="italic">GitHub repository for </em><span class="No-Break"><em class="italic">YARP</em></span><span class="No-Break">: </span><a href="https://github.com/microsoft/reverse-proxy"><span class="No-Break">https://github.com/microsoft/reverse-proxy</span></a></li>
				<li><em class="italic">Securing a Blazor WASM app with Azure AD </em><span class="No-Break"><em class="italic">B2C</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c</span></a></li>
				<li><em class="italic">Securing a WPF desktop app with Aure AD </em><span class="No-Break"><em class="italic">B2C</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app"><span class="No-Break">https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app</span></a></li>
				<li><em class="italic">Choosing an identity management </em><span class="No-Break"><em class="italic">solution</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution</span></a></li>
				<li><em class="italic">Azure API </em><span class="No-Break"><em class="italic">Management</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/api-management/"><span class="No-Break">https://learn.microsoft.com/en-us/azure/api-management/</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer119" class="Content">
			<h1 id="_idParaDest-239" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor238"/>Part 3: Troubleshooting and Scaling</h1>
			<p>In this part, the focus shifts towards ensuring the smooth operation of the application and promptly addressing any emerging issues. Emphasis is placed on early issue detection through unit testing. You will delve into creating integration tests using .NET Aspire libraries and implementing end-to-end testing with Microsoft Playwright. The importance of logs, metrics, and distributed tracing, facilitated by Open Telemetry and supported by .NET Aspire, will be explored. Monitoring service interactions, performance metrics, memory consumption, and more during development will be facilitated by the .NET Aspire dashboard. Within the Azure environment, Azure Log Analytics and Application Insights will be utilized, alongside alternative options like <strong class="bold">Prometheus</strong> and <strong class="bold">Grafana</strong> that can be deployed in both on-premises and cloud environments. When scaling services, insights gained from previous chapters will be leveraged, with caution advised when using Azure Load Testing to prevent exceeding budget limits. Before scaling up and out, potential performance enhancements will be identified <span class="No-Break">and implemented.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21217_10.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a>, <em class="italic">All about Testing the Solution</em></li>
				<li><a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>, <em class="italic">Logging and Monitoring</em></li>
				<li><a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a><em class="italic">, Scaling Services</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer120">
			</div>
		</div>
		<div>
			<div id="_idContainer121">
			</div>
		</div>
		<div>
			<div id="_idContainer122">
			</div>
		</div>
		<div>
			<div id="_idContainer123">
			</div>
		</div>
		<div>
			<div id="_idContainer124">
			</div>
		</div>
		<div>
			<div id="_idContainer125" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer126" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer127">
			</div>
		</div>
		<div>
			<div id="_idContainer128">
			</div>
		</div>
		<div>
			<div id="_idContainer129" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>