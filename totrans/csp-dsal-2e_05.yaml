- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Stacks and Queues
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和队列
- en: So far, you learned a lot about arrays and lists. However, these structures
    are not the only ones available. Among others, there is also a group of more specialized
    data structures called **limited access** **data structures**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学到了很多关于数组和列表的知识。然而，这些结构并不是唯一可用的。在其他结构中，还有一组更专业的数据结构，称为 **有限访问** **数据结构**。
- en: What does this mean? To explain the name, let’s return to the topic of arrays
    for the moment, which belong to the group of **random access data structures**.
    The difference between them is only one word - that is, *limited* or *random*.
    As you already know, arrays allow you to store data and get access to various
    elements using indices. Thus, you can easily get the first, the middle, the *n*th,
    or the last element from an array. For this reason, it can be named a random access
    data structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？为了解释这个名称，让我们暂时回到数组的话题，数组属于 **随机访问数据结构** 的组。它们之间的区别只有一个词 - 那就是有限或随机。如您所知，数组允许您存储数据，并使用索引访问各种元素。因此，您可以从数组中轻松获取第一个、中间的、第
    *n* 个或最后一个元素。因此，它可以被称为随机访问数据结构。
- en: However, what does *limited* mean? The answer is very simple. With a limited
    access data structure, **you cannot access every element from the structure**.
    Thus, **the way of getting elements is strictly specified**. For example, you
    can get only the first or the last element, but you cannot get the *n*th element
    from the data structure. Popular representatives of limited access data structures
    are stacks and queues, which are topics mentioned in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“有限”是什么意思？答案是简单的。在有限访问数据结构中，**您不能从结构中访问每个元素**。因此，**获取元素的方式是严格指定的**。例如，您只能获取第一个或最后一个元素，但不能从数据结构中获取第
    *n* 个元素。有限访问数据结构的流行代表是栈和队列，这些是本章中提到的主题。
- en: You will see the application of a stack, as well as a few variants of queues,
    including a regular one, a priority queue, and a circular queue. To make understanding
    easier, the text is supported with illustrations and code snippets with detailed
    explanations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到栈的应用，以及队列的一些变体，包括普通队列、优先队列和循环队列。为了使理解更加容易，文本配有插图和带有详细解释的代码片段。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Stacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Queues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Priority queues
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Circular queues
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环队列
- en: Stacks
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: To begin, let’s talk about a **stack**. It is a data structure that allows you
    to **add a new element only at the top** (referred to as a **push** operation)
    and **to get an element only by removing it from the top** (a **pop** operation).
    For this reason, a stack is consistent with the **LIFO** principle, which stands
    for **Last-In First-Out**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来谈谈 **栈**。它是一种数据结构，允许您 **只在顶部添加新元素**（称为 **push** 操作）和 **通过从顶部移除元素来获取元素**（pop
    操作）。因此，栈符合 **LIFO** 原则，即 **后进先出**。
- en: Imagine a stack
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个栈
- en: If you want to better visualize a stack, let’s close the book for a moment,
    go to the kitchen, and take a look at a pile of plates, each placed on top of
    the other. You can only add a new plate to the top of the pile, and you can only
    get a plate from the top of the pile. You cannot remove the seventh plate without
    taking the previous six from the top, and you cannot add a plate to the middle
    of the pile. So, the last added plate (last-in) will be removed from the pile
    first (first-out). And do not even try to get a plate from the middle of the pile,
    as you don’t want to break plates! The stack operates similarly. It allows you
    to add a new element only at the top (a push operation) and to get an element
    only by removing it from the top (a pop operation).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地可视化栈，让我们暂时合上书本，去厨房看看一堆盘子，每个盘子都放在另一个盘子的上面。您只能将新盘子放在堆的顶部，您也只能从堆的顶部取盘子。您不能在不取掉顶部前六个盘子的情况下取走第七个盘子，您也不能在盘子堆的中间添加盘子。所以，最后添加的盘子（后进先出）将首先从盘子堆中取出。而且，甚至不要尝试从盘子堆的中间取盘子，因为您不想打碎盘子！栈的操作方式类似。它允许您只在顶部添加新元素（push
    操作）并且只能通过从顶部移除元素来获取元素（pop 操作）。
- en: 'A diagram of a stack with *push* and *pop* operations is shown as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示是带有 *push* 和 *pop* 操作的栈的图示：
- en: "![Figure 5.1 – \uFEFFIllustration of a stack](img/B18069_05_01.jpg)"
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 栈的示意图](img/B18069_05_01.jpg)'
- en: Figure 5.1 – Illustration of a stack
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 栈的示意图
- en: It seems to be very easy, doesn’t it? It really is, and you can benefit from
    various features of stacks using the built-in generic `Stack` class. It is worth
    remembering that it is located in the `System.Collections.Generic` namespace.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很简单，不是吗？确实如此，您可以通过使用内置的泛型`Stack`类来享受堆栈的各种功能。值得记住的是，它位于`System.Collections.Generic`命名空间中。
- en: 'Let’s mention three methods from this class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提及这个类中的三个方法：
- en: '`Push` inserts an element at the top of the stack'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Push`在堆栈顶部插入一个元素'
- en: '`Pop` removes an element from the top of the stack and returns it'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pop`从堆栈顶部移除一个元素并返回它'
- en: '`Peek` returns an element from the top of the stack without removing it'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Peek`返回堆栈顶部的元素而不移除它'
- en: You also have access to other methods, such as for removing all elements from
    the stack (`Clear`) or for checking whether a given element is available in the
    stack (`Contains`). You can get the number of elements currently in the stack
    using the `Count` property.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以访问其他方法，例如从堆栈中移除所有元素（`Clear`）或检查给定元素是否在堆栈中可用（`Contains`）。您可以使用`Count`属性获取当前堆栈中的元素数量。
- en: What about the performance?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于性能如何？
- en: It is worth noting that the `Push` method is either an *O(1)* operation, if
    the capacity does not need to increase, or *O(n)* otherwise, where *n* is the
    number of elements in the stack. Both `Pop` and `Peek` are *O(1)* operations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Push`方法要么是*O(1)*操作，如果容量不需要增加，否则是*O(n)*，其中*n*是堆栈中的元素数量。`Pop`和`Peek`都是*O(1)*操作。
- en: As the time complexity looks very promising, it is high time to take a look
    at some examples showing stacks in action.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时间复杂度看起来非常有前景，现在是时候看看一些展示堆栈实际应用的示例了。
- en: Where can you find more information?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里可以找到更多信息？
- en: You can find content regarding a stack at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1)找到有关堆栈的内容
- en: Example – reversing a word
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 反转一个单词
- en: 'For the first example, let’s try to reverse a word using a stack. You can do
    this by iterating through characters that form a string, adding each at the top
    of the stack, and then removing all elements from the stack. At the end, you receive
    the reversed word, as shown in the following diagram presenting how to reverse
    `MARCIN`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个示例，让我们尝试使用堆栈来反转一个单词。您可以通过遍历形成字符串的字符，将每个字符添加到堆栈顶部，然后移除堆栈中的所有元素来实现这一点。最后，您将收到反转后的单词，如下面的图表示例所示，如何反转`MARCIN`：
- en: "![Figure 5.2 – \uFEFFIllustration of the reversing \uFEFFa word example](img/B18069_05_02.jpg)"
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 反转单词示例的说明](img/B18069_05_02.jpg)'
- en: Figure 5.2 – Illustration of the reversing a word example
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 反转单词示例的说明
- en: 'The implementation is shown in the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了实现：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: NICRAM
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: NICRAM
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: public class Game
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: public class Game
- en: '{'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public Stack<int> From { get; private set; }
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: public Stack<int> From { get; private set; }
- en: public Stack<int> To { get; private set; }
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: public Stack<int> To { get; private set; }
- en: public Stack<int> Auxiliary { get; private set; }
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: public Stack<int> Auxiliary { get; private set; }
- en: public int DiscsCount { get; private set; }
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: public int DiscsCount { get; private set; }
- en: public int MovesCount { get; private set; }
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: public int MovesCount { get; private set; }
- en: public event EventHandler<EventArgs>? MoveCompleted;
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: public event EventHandler<EventArgs>? MoveCompleted;
- en: '}'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: public Game(int discsCount)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: public Game(int discsCount)
- en: '{'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: DiscsCount = discsCount;
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: DiscsCount = discsCount;
- en: From = new Stack<int>();
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: From = new Stack<int>();
- en: To = new Stack<int>();
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: To = new Stack<int>();
- en: Auxiliary = new Stack<int>();
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Auxiliary = new Stack<int>();
- en: for (int i = 0; i < discsCount; i++)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < discsCount; i++)
- en: '{'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int size = discsCount - i;
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: int size = discsCount - i;
- en: From.Push(size);
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: From.Push(size);
- en: '}'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: public async Task MoveAsync(int discs, Stack<int> from,
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: public async Task MoveAsync(int discs, Stack<int> from,
- en: Stack<int> to, Stack<int> auxiliary)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Stack<int> to, Stack<int> auxiliary)
- en: '{'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (discs == 0) { return; }
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: if (discs == 0) { return; }
- en: await MoveAsync(discs - 1, from, auxiliary, to);
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: await MoveAsync(discs - 1, from, auxiliary, to);
- en: to.Push(from.Pop());
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: to.Push(from.Pop());
- en: MovesCount++;
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MovesCount++;
- en: MoveCompleted?.Invoke(this, EventArgs.Empty);
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: MoveCompleted?.Invoke(this, EventArgs.Empty);
- en: await Task.Delay(250);
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: await Task.Delay(250);
- en: await MoveAsync(discs - 1, auxiliary, to, from);
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: await MoveAsync(discs - 1, auxiliary, to, from);
- en: '}'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: public class Visualization
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: public class Visualization
- en: '{'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: private readonly Game _game;
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: private readonly Game _game;
- en: private readonly int _columnSize;
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: private readonly int _columnSize;
- en: private readonly char[,] _board;
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: private readonly char[,] _board;
- en: public Visualization(Game game)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: public Visualization(Game game)
- en: '{'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: _game = game;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: _game = game;
- en: _columnSize = Math.Max(6,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: _columnSize = Math.Max(6,
- en: GetDiscWidth(_game.DiscsCount) + 2);
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDiscWidth(_game.DiscsCount) + 2);`'
- en: _board = new char[_game.DiscsCount,
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`_board = new char[_game.DiscsCount,`'
- en: _columnSize * 3];
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`_columnSize * 3];`'
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'private int Show, which is shown next:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`private int Show, which is shown next:'
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method clears the current content of the console (by calling the `Clear`
    method). Then, it calls the `FillEmptyBoard` and `FillRodOnBoard` methods to clear
    content that should be shown in the console and then fill it with data of the
    current state of rods, one in each call of `FillRodOnBoard`. Next, you show captions
    for each rod, draw the board, as well as write the number of moves and discs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过调用`Clear`方法清除控制台当前内容。然后，它调用`FillEmptyBoard`和`FillRodOnBoard`方法来清除控制台应显示的内容，然后使用`FillRodOnBoard`的每次调用填充杆的当前状态数据。接下来，显示每个杆的标题，绘制板，以及写入移动次数和圆盘数。
- en: 'To clear the content of the board, you just iterate through all elements in
    the two-dimensional array and set the value of each item to a space, as shown
    next:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除板的内容，只需遍历二维数组中的所有元素，并将每个项目的值设置为空格，如下所示：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want to learn how to fill a part of the two-dimensional array that is
    related to a particular rod, let’s take a look at the code of `FillRodOnBoard`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解如何填充与特定杆相关的二维数组部分，让我们看看`FillRodOnBoard`的代码：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, the left margin is calculated to add data in the correct section within
    the overall array - that is, within the correct range of columns. The main part
    of the method is the `for` loop, where the number of iterations is equal to the
    number of discs located in the stack. In each iteration, the size of the current
    disc is read using the `ElementAt` extension method (from the `System.Linq` namespace).
    Next, you calculate an index of a row, where the disc should be shown, as well
    as start and end indices for columns. Finally, a `for` loop is used to insert
    the equals sign (`=`) in proper locations in the array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算左边界以在整体数组中正确部分添加数据 - 也就是说，在正确的列范围内。方法的主要部分是`for`循环，其中迭代次数等于堆栈中放置的圆盘数量。在每次迭代中，使用`ElementAt`扩展方法（来自`System.Linq`命名空间）读取当前圆盘的大小。接下来，计算圆盘应显示的行索引，以及列的起始和结束索引。最后，使用`for`循环在数组中适当位置插入等号（`=`）。
- en: 'One of the auxiliary methods is `Center`. It aims to add additional spaces
    before and after the text, passed as the parameter, to center the text in the
    column:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个辅助方法是`Center`。它的目的是在传递给参数的文本前后添加额外的空格，以在列中居中文本：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last used method is named `DrawBoard`. It simply iterates through all elements
    in the two-dimensional array and writes content in the console. The code is shown
    next:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后使用的方法命名为`DrawBoard`。它简单地遍历二维数组中的所有元素，并在控制台中写入内容。代码如下所示：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the end, let’s take a look at the main code, located in the `Program.cs`
    file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看位于`Program.cs`文件中的主要代码：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: List<int> items = [2, -4, 1, 8, 5];
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<int> items = [2, -4, 1, 8, 5];`'
- en: Queue<int> queue = new();
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue<int> queue = new();`'
- en: items.ForEach(queue.Enqueue);
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`items.ForEach(queue.Enqueue);`'
- en: while (queue.Count > 0)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`while (queue.Count > 0)`'
- en: '{'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine(queue.Dequeue());
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.WriteLine(queue.Dequeue());`'
- en: '}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'items.ForEach(ConcurrentQueue generic class from the System.Collections.Concurrent
    namespace. This class contains a set of built-in methods to perform various operations
    on the queue, such as the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`items.ForEach(ConcurrentQueue generic class from the System.Collections.Concurrent
    namespace. This class contains a set of built-in methods to perform various operations
    on the queue, such as the following:'
- en: '`Enqueue` adds an element at the end of the queue'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enqueue`将一个元素添加到队列的末尾'
- en: '`TryDequeue` tries to remove an element from the beginning and return it'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryDequeue`尝试从开始移除一个元素并返回它'
- en: '`TryPeek` tries to return an element from the beginning without removing it'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryPeek`尝试从开始返回一个元素而不移除它'
- en: Both `TryDequeue` and `TryPeek` have a parameter with the `out` keyword. If
    the operation is successful, such methods return `true`, and the result is returned
    as a value of the `out` parameter. Moreover, the `ConcurrentQueue` class also
    contains two properties, namely `Count` to get the number of elements stored in
    the collection and `IsEmpty` to return a value indicating whether the queue is
    empty.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryDequeue`和`TryPeek`都有带有`out`关键字的参数。如果操作成功，此类方法返回`true`，并将结果作为`out`参数的值返回。此外，`ConcurrentQueue`类还包含两个属性，即`Count`用于获取存储在集合中的元素数量，以及`IsEmpty`用于返回一个值，指示队列是否为空。'
- en: Where can you find more information?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里可以找到更多信息？
- en: You can find content regarding the `ConcurrentQueue` class at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1)找到有关`ConcurrentQueue`类的相关内容。
- en: After this short introduction, let’s proceed to two examples representing a
    queue in the context of a call center, with many clients and one or many consultants.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们来看两个例子，这两个例子代表了呼叫中心环境中的队列，其中有许多客户和一位或多位顾问。
- en: Example – call center with a single consultant
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 单顾问呼叫中心
- en: This first example represents a simple approach to the call center solution,
    where there are **many clients** (with different identifiers), and **only one
    consultant**, who answers waiting calls in the same order in which they appear.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个例子代表了对呼叫中心解决方案的简单方法，其中有许多**客户**（具有不同的标识符），以及**仅有一位顾问**，他按照来电出现的顺序回答等待的电话。
- en: 'This scenario is shown next:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个场景如下所示：
- en: "![Figure 5.9 – \uFEFFIllustration of the call center with a single consultant\
    \ example](img/B18069_05_09.jpg)"
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 单顾问呼叫中心示例的说明](img/B18069_05_09.jpg)'
- en: Figure 5.9 – Illustration of the call center with a single consultant example
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 单顾问呼叫中心示例的说明
- en: 'As you can see in the preceding diagram, four calls are performed by clients.
    They are added to the queue with waiting phone calls, namely from clients `#1234`,
    `#5678`, `#1468`, and `#9641`. When a consultant is available, they answer the
    phone. When the call ends, the consultant can answer the next waiting call. According
    to this rule, the consultant will talk with clients in the following order: **#1234**,
    **#5678**, **#1468**, and **#9641**.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，客户执行了四个呼叫。它们被添加到等待电话的队列中，即来自客户`#1234`、`#5678`、`#1468`和`#9641`。当顾问可用时，他们会接听电话。当通话结束时，顾问可以接听下一个等待的电话。根据这个规则，顾问将与客户按以下顺序交谈：**#1234**、**#5678**、**#1468**和**#9641**。
- en: 'Let’s take a look at the code of the first class, named `IncomingCall`, which
    represents a single incoming call performed by a client. Its code is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看第一个类的代码，名为`IncomingCall`，它代表客户执行的单个来电。其代码如下：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The class contains six properties representing a unique identifier of a call
    (`Id`), a client identifier (`ClientId`), the date and time when the call was
    started (`CallTime`), when it was answered (`AnswerTime`), and when it was ended
    (`EndTime`), as well as the name of the consultant (`Consultant`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含六个属性，代表一个呼叫的唯一标识符（`Id`）、客户标识符（`ClientId`）、呼叫开始时的日期和时间（`CallTime`）、回答时的日期和时间（`AnswerTime`）、结束时的日期和时间（`EndTime`），以及顾问的姓名（`Consultant`）。
- en: 'The most important part of the code is related to the `CallCenter` class, which
    represents call-related operations. Its fragment is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最重要的一部分与`CallCenter`类相关，它代表与呼叫相关的操作。其片段如下：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `CallCenter` class contains the `_counter` field with an identifier of the
    last call, which is equal to the number of calls so far. The class also has the
    `Calls` property representing a queue (with `IncomingCall` instances), where data
    of waiting calls is stored. In the constructor, a new instance of the `Queue`
    generic class is created, and its reference is assigned to the `Calls` property.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallCenter`类包含一个`_counter`字段，其标识符为最后一个呼叫，等于迄今为止的呼叫数量。该类还有一个`Calls`属性，代表一个队列（包含`IncomingCall`实例），其中存储了等待电话的数据。在构造函数中，创建了一个新的`Queue`泛型类实例，并将其引用分配给`Calls`属性。'
- en: 'Of course, the class contains some methods, such as `Call` with the following
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，该类还包含一些方法，例如具有以下代码的`Call`方法：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, you create a new instance of the `IncomingCall` class and set values of
    its properties, namely its identifier (together with pre-incrementing the `_counter`
    field), the client identifier (using the `clientId` parameter), and the call time.
    The created instance is added to the queue by calling the `Enqueue` method and
    returned.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建`IncomingCall`类的新实例并设置其属性的值，即其标识符（包括预增量`_counter`字段），客户标识符（使用`clientId`参数），以及呼叫时间。通过调用`Enqueue`方法将创建的实例添加到队列中并返回。
- en: 'The next method is `Answer`. It represents the operation of answering the call
    from the person waiting in the queue for the longest time. Such a call is represented
    by the element located at the beginning of the queue. The `Answer` method is shown
    next:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是 `Answer`。它表示从等待时间最长的队列中接听电话的操作。这样的电话由队列开头的元素表示。`Answer` 方法如下所示：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Within this method, you check whether the queue is empty. If so, the method
    returns `null`, which means that there are no phone calls that can be answered
    by the consultant. Otherwise, the call is removed from the queue (using the `Dequeue`
    method), and its properties are updated by setting the consultant’s name (using
    the `consultant` parameter) and answer time (to the current date and time). At
    the end, the data of the call is returned.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，你检查队列是否为空。如果是，则方法返回 `null`，这意味着没有电话可以被顾问接听。否则，电话将从队列中移除（使用 `Dequeue` 方法），并通过设置顾问的姓名（使用
    `consultant` 参数）和接听时间（到当前日期和时间）来更新其属性。最后，返回电话的数据。
- en: 'Apart from the `Call` and `Answer` methods, you also implement the `End` method,
    which is called whenever the consultant ends a call with a particular client.
    In such a case, you only set the end time, as shown in the following piece of
    code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Call` 和 `Answer` 方法之外，你还实现了 `End` 方法，该方法在顾问结束与特定客户的通话时被调用。在这种情况下，你只需设置结束时间，如下所示：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last method in the `CallCenter` class is named `AreWaitingCalls`. It returns
    a value indicating whether there are any waiting calls in the queue, using the
    `Count` property of the `Queue` class. Its code is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallCenter` 类中的最后一个方法是名为 `AreWaitingCalls` 的方法。它返回一个值，表示队列中是否有等待的电话，使用 `Queue`
    类的 `Count` 属性。其代码如下：'
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Random random = new();
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Random random = new();
- en: CallCenter center = new();
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: CallCenter center = new();
- en: center.Call(1234);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: center.Call(1234);
- en: center.Call(5678);
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: center.Call(5678);
- en: center.Call(1468);
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: center.Call(1468);
- en: center.Call(9641);
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: center.Call(9641);
- en: while (center.AreWaitingCalls())
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: while (center.AreWaitingCalls())
- en: '{'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: IncomingCall call = center.Answer("Marcin")!;
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: IncomingCall call = center.Answer("Marcin")!;
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '记录($"电话 #{call.Id} 来自客户 #{call.ClientId}'
- en: answered by {call.Consultant}.");
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接听 by {call.Consultant}.");
- en: await Task.Delay(random.Next(1000, 10000));
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: await Task.Delay(random.Next(1000, 10000));
- en: center.End(call);
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: center.End(call);
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '记录($"电话 #{call.Id} 来自客户 #{call.ClientId}'
- en: ended by {call.Consultant}.");
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 by {call.Consultant}.");
- en: '}'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: void Log(string text) =>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: void Log(string text) =>
- en: Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {text}");
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出($"[{DateTime.Now:HH:mm:ss}] {text}");
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[13:10:53] Call #1 from client #1234 answered by Marcin.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:10:53] 来自客户 #1234 的电话 #1 由 Marcin 接听。'
- en: '[13:10:56] Call #1 from client #1234 ended by Marcin.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:10:56] 来自客户 #1234 的电话 #1 由 Marcin 结束。'
- en: '[13:10:56] Call #2 from client #5678 answered by Marcin.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:10:56] 来自客户 #5678 的电话 #2 由 Marcin 接听。'
- en: '[13:10:59] Call #2 from client #5678 ended by Marcin.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:10:59] 来自客户 #5678 的电话 #2 由 Marcin 结束。'
- en: '[13:10:59] Call #3 from client #1468 answered by Marcin.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:10:59] 来自客户 #1468 的电话 #3 由 Marcin 接听。'
- en: '[13:11:06] Call #3 from client #1468 ended by Marcin.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:11:06] 来自客户 #1468 的电话 #3 由 Marcin 结束。'
- en: '[13:11:06] Call #4 from client #9641 answered by Marcin.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:11:06] 来自客户 #9641 的电话 #4 由 Marcin 接听。'
- en: '[13:11:09] Call #4 from client #9641 ended by Marcin.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[13:11:09] 来自客户 #9641 的电话 #4 由 Marcin 结束。'
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: using System.Collections.Concurrent;
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: using System.Collections.Concurrent;
- en: public class CallCenter
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: public class CallCenter
- en: '{'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: private int _counter = 0;
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: private int _counter = 0;
- en: public ConcurrentQueue<IncomingCall> Calls
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: public ConcurrentQueue<IncomingCall> Calls
- en: '{ get; private set; }'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '{ get; private set; }'
- en: public CallCenter() => Calls =
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: public CallCenter() => Calls =
- en: new ConcurrentQueue<IncomingCall>();
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: new ConcurrentQueue<IncomingCall>();
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: public IncomingCall? Answer(string consultant)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public IncomingCall? Answer(string consultant)
- en: '{'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (!Calls.IsEmpty
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: if (!Calls.IsEmpty
- en: '&& Calls.TryDequeue(out IncomingCall? call))'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '&& Calls.TryDequeue(out IncomingCall? call))'
- en: '{'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: call.Consultant = consultant;
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: call.Consultant = consultant;
- en: call.AnswerTime = DateTime.Now;
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: call.AnswerTime = DateTime.Now;
- en: return call;
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: return call;
- en: '}'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return null;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: return null;
- en: '}'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'public bool AreWaitingCalls() => CallCenter class. However, more changes are
    required in the code located in Program.cs, as shown next:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: public bool AreWaitingCalls() => CallCenter 类。然而，还需要在 Program.cs 中的代码进行更多更改，如下所示：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: void Clients(CallCenter center)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: void Clients(CallCenter center)
- en: '{'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: while (true)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: while (true)
- en: '{'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int clientId = random.Next(1, 10000);
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: int clientId = random.Next(1, 10000);
- en: IncomingCall call = center.Call(clientId);
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: IncomingCall call = center.Call(clientId);
- en: 'Log($"Incoming call #{call.Id}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '记录($"来电 #{call.Id}'
- en: 'from client #{clientId}");'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'from client #{clientId}");'
- en: 'Log($"Waiting calls in the queue:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记录($"等待队列中的电话：
- en: '{center.Calls.Count}");'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '{center.Calls.Count}");'
- en: Thread.Sleep(random.Next(500, 2000));
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(random.Next(500, 2000));
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: void Consultant(CallCenter center, string name,
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: void Consultant(CallCenter center, string name,
- en: ConsoleColor color)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleColor color)
- en: '{'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: while (true)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: while (true)
- en: '{'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(random.Next(500, 1000));
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(random.Next(500, 1000));
- en: IncomingCall? call = center.Answer(name);
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: IncomingCall? call = center.Answer(name);
- en: if (call == null) { continue; }
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: if (call == null) { continue; }
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'Log($"Call #{call.Id} from client #{call.ClientId}'
- en: answered by {call.Consultant}.", color);
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: answered by {call.Consultant}.", color);
- en: Thread.Sleep(random.Next(1000, 10000));
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(random.Next(1000, 10000));
- en: center.End(call);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: center.End(call);
- en: 'Log($"Call #{call.Id} from client #{call.ClientId}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log($"Call #{call.Id} from client #{call.ClientId}'
- en: ended by {call.Consultant}.", color);
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ended by {call.Consultant}.", color);
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: void Log(string text,
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: void Log(string text,
- en: ConsoleColor color = ConsoleColor.Gray)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleColor color = ConsoleColor.Gray)
- en: '{'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.ForegroundColor = color;
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ForegroundColor = color;
- en: Console.WriteLine(
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: $"[{DateTime.Now:HH:mm:ss.fff}] {text}");
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: $"[{DateTime.Now:HH:mm:ss.fff}] {text}");
- en: Console.ResetColor();
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ResetColor();
- en: '}'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: using Priority_Queue;
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: using Priority_Queue;
- en: SimplePriorityQueue<string> queue = new();
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: SimplePriorityQueue<string> queue = new();
- en: queue.Enqueue("Marcin", 1);
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: queue.Enqueue("Marcin", 1);
- en: queue.Enqueue("Lily", 1);
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: queue.Enqueue("Lily", 1);
- en: queue.Enqueue("Mary", 2);
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: queue.Enqueue("Mary", 2);
- en: queue.Enqueue("John", 0);
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue.Enqueue("John", 0);`'
- en: queue.Enqueue("Emily", 1);
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: queue.Enqueue("Emily", 1);
- en: queue.Enqueue("Sarah", 2);
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: queue.Enqueue("Sarah", 2);
- en: queue.Enqueue("Luke", 1);
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue.Enqueue("Luke", 1);`'
- en: while (queue.Count > 0)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: while (queue.Count > 0)
- en: '{'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: Console.WriteLine(queue.Dequeue());
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(queue.Dequeue());
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: John
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: John
- en: Marcin
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Marcin
- en: Lily
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Lily
- en: Emily
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Emily
- en: Luke
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Luke
- en: Mary
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Mary
- en: Sarah
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Sarah
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: public class IncomingCall
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: public class IncomingCall
- en: '{'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public int Id { get; set; }
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: public int Id { get; set; }
- en: public int ClientId { get; set; }
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: public int ClientId { get; set; }
- en: public DateTime CallTime { get; set; }
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: public DateTime CallTime { get; set; }
- en: public DateTime? AnswerTime { get; set; }
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: public DateTime? AnswerTime { get; set; }
- en: public DateTime? EndTime { get; set; }
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: public DateTime? EndTime { get; set; }
- en: public string? Consultant { get; set; }
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: public string? Consultant { get; set; }
- en: public bool IsPriority { get; set; }
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: public bool IsPriority { get; set; }
- en: '}'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: public class CallCenter
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: public class CallCenter
- en: '{'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: private int _counter = 0;
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: private int _counter = 0;
- en: public SimplePriorityQueue<IncomingCall> Calls
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: public SimplePriorityQueue<IncomingCall> Calls
- en: '{ get; private set; }'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '{ get; private set; }'
- en: public CallCenter() => Calls =
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: public CallCenter() => Calls =
- en: new SimplePriorityQueue<IncomingCall>();
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: new SimplePriorityQueue<IncomingCall>();
- en: '}'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: public IncomingCall Call(int clientId, bool isPriority)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: public IncomingCall Call(int clientId, bool isPriority)
- en: '{'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: IncomingCall call = new()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: IncomingCall call = new()
- en: '{'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Id = ++_counter,
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Id = ++_counter,
- en: ClientId = clientId,
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ClientId = clientId,
- en: CallTime = DateTime.Now,
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: CallTime = DateTime.Now,
- en: IsPriority = isPriority
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: IsPriority = isPriority
- en: '};'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`};`'
- en: 'Calls.Enqueue(call, isPriority ? 0 : 1);'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'Calls.Enqueue(call, isPriority ? 0 : 1);'
- en: return call;
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: return call;
- en: '}'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: public IncomingCall? Answer(string consultant)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: public IncomingCall? Answer(string consultant)
- en: '{'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (!AreWaitingCalls()) { return null; }
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: if (!AreWaitingCalls()) { return null; }
- en: IncomingCall call = Calls.Dequeue();
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: IncomingCall call = Calls.Dequeue();
- en: call.Consultant = consultant;
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: call.Consultant = consultant;
- en: call.AnswerTime = DateTime.Now;
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: call.AnswerTime = DateTime.Now;
- en: return call;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: return call;
- en: '}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void End(IncomingCall call) =>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: public void End(IncomingCall call) =>
- en: call.EndTime = DateTime.Now;
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: call.EndTime = DateTime.Now;
- en: 'public bool Program.cs file:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: public bool Program.cs文件：
- en: '[PRE33]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You may be surprised to learn that only small changes are necessary in this
    part of the code. The reason for this is that the logic regarding a used data
    structure is hidden in the `CallCenter` class. Within the `Program.cs` file, you
    call methods and use properties exposed by the `CallCenter` class. You just need
    to modify how you add calls to the queue (together with priorities), as well as
    adjust logs presented when a call is answered by the consultant, to choose a proper
    color based on the call’s priority. That’s all!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶地发现，在这个代码部分只需要进行微小的改动。原因是关于已使用数据结构的逻辑隐藏在`CallCenter`类中。在`Program.cs`文件中，您调用`CallCenter`类公开的方法和使用属性。您只需修改如何将调用添加到队列中（包括优先级），以及当顾问接听电话时调整显示的日志，根据电话的优先级选择合适的颜色。就这样！
- en: 'When you run the application, you will receive a result similar to the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您将收到类似以下的结果：
- en: "![Figure 5.14 – \uFEFFScreenshot of the call center with priority support example](img/B18069_05_14.jpg)"
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14 – 带优先级支持的呼叫中心截图示例](img/B18069_05_14.jpg)'
- en: Figure 5.14 – Screenshot of the call center with priority support example
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 带优先级支持的呼叫中心截图示例
- en: As you can see, the calls are served in the correct order. This means that the
    calls from clients with priority support are served earlier than calls from clients
    with the standard support plan, even though such calls need to wait much longer
    to be answered.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，呼叫是按照正确的顺序服务的。这意味着具有优先级支持的客户的呼叫比具有标准支持计划的客户的呼叫先被服务，尽管这样的呼叫需要等待更长的时间才能得到回答。
- en: Circular queues
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 环形队列
- en: At the end of this chapter, let’s take a look at another data structure, namely
    a **circular queue**, also called a **ring buffer**. In this case, **a queue forms
    a circle**, internally uses an array, and the maximum number of elements that
    can be placed inside the queue is limited. You need to specify two variables that
    indicate indices of the **front** and **rear** elements. **The front one points
    to the element that will be dequeued first. The rear one points to the element
    that is the last in** **the queue**.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，让我们看看另一种数据结构，即**环形队列**，也称为**环形缓冲区**。在这种情况下，**队列形成一个环**，内部使用数组，并且可以放置在队列中的最大元素数量是有限的。你需要指定两个变量，它们指示**前**和**后**元素的索引。**前一个指向第一个将被出队的元素。后一个指向队列中的最后一个元素**。
- en: Imagine a circular queue
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个环形队列
- en: If you want to better imagine a circular queue, think back to your young years
    when you persuaded your parents to take you on a roller coaster. It consisted
    of 10 carriages, each with room for 2 people, so only 20 people could take part
    in 1 roller coaster ride. As this was a unique attraction, such a ride took place
    only once an hour. This meant that only 20 people were allowed to enter a queue
    for the roller coaster and no one else. As the departure date approached, people
    were admitted to it in the order in which they were admitted to the queue. And
    a circular queue works similarly! It has some specific capacity, and nothing else
    can be enqueued to it. However, when you dequeue elements, new ones can be added
    in place of the previous ones. Well, it means that after an hour, you can fill
    a queue for the roller coaster with new people!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地想象环形队列，回想一下你年轻的时候，当你说服你的父母带你坐过山车的时候。它由10节车厢组成，每节车厢可以容纳2人，所以只有20人可以参加一次过山车之旅。由于这是一个独特的景点，这样的旅程每小时只发生一次。这意味着只有20人被允许进入过山车的队列，其他人则不行。随着出发日期的临近，人们按照他们进入队列的顺序被允许进入。而环形队列的工作方式类似！它有一定的容量，并且不能向其中入队其他东西。然而，当你出队元素时，新的元素可以替代之前的元素。嗯，这意味着一个小时后，你可以用新的人来填满过山车的队列！
- en: 'The mentioned data structure is presented in the following diagram:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所述数据结构在以下图中展示：
- en: "![Figure 5.15 – \uFEFFIllustration of a circular queue](img/B18069_05_15.jpg)"
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 环形队列的示意图](img/B18069_05_15.jpg)'
- en: Figure 5.15 – Illustration of a circular queue
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 环形队列的示意图
- en: At the beginning, the circular queue is empty, so both `-1`. Then, you add `2`,
    `-4`, `1`, and `8` elements, and this state is shown in the first step in the
    preceding diagram. Here, the front index is equal to `0`, and the rear one to
    `3`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，环形队列是空的，所以都是`-1`。然后，你添加`2`、`-4`、`1`和`8`个元素，这个状态在前图中第一步显示。在这里，前索引等于`0`，后索引等于`3`。
- en: In the next step, you perform an `5` is located at index `4`, as shown in the
    third step in the preceding diagram. Of course, the rear index is updated to `4`
    while the front index remains the same, namely `0`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，你执行一个`5`位于索引`4`，正如前图中第三步所示。当然，后索引更新为`4`，而前索引保持不变，即`0`。
- en: The following step shows a `2` is returned, and the front index is changed to
    `1`. It means that currently, the circular queue stores `4` elements in the part
    of the array between `1` (the front index) and `4` (the rear index).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示返回了一个`2`，前索引变为`1`。这意味着目前，环形队列在数组的前索引`1`（队首）和后索引`4`（队尾）之间存储了`4`个元素。
- en: What about the performance?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？
- en: The performance results are great in this case! Both the `Enqueue` and the `Dequeue`
    methods are *O(1)* operations, as you don’t need to iterate through an array.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，性能结果非常出色！`入队`和`出队`方法都是*O(1)*操作，因为你不需要遍历数组。
- en: 'You can perform many more *enqueue* and *dequeue* operations to see how the
    content of the queue “rotates” within a circular queue. To do so, you need to
    implement this data structure. Let’s write some code, starting with the `CircularQueue`
    class:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行更多的`入队`和`出队`操作，以查看队列内容在环形队列中是如何“旋转”的。为此，你需要实现这个数据结构。让我们编写一些代码，从`CircularQueue`类开始：
- en: '[PRE34]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is a generic class that uses the primary constructor taking the maximum
    number of elements in the queue as the `size` parameter. You can see four private
    fields:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个泛型类，它使用主构造函数，将队列中元素的最大数量作为`size`参数。你可以看到四个私有字段：
- en: An array with the stored items (`_items`)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储元素的数组（`_items`）
- en: An index of the front and rear elements in the queue (`_front` and `_rear`)
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列中前后元素的下标（`_front`和`_rear`）
- en: The current number of elements located in the circular queue (`_count`)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环形队列中当前元素的数量（`_count`）
- en: 'The public read-only `Count` property is added as well, which returns the value
    of the `_count` field. If everything is clear for you, let’s take a look at the
    `Enqueue` method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 还添加了一个公共只读`Count`属性，它返回`_count`字段的值。如果你对此已经很清楚，让我们看看`Enqueue`方法：
- en: '[PRE35]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the beginning, you need to check whether you have any space within the circular
    queue, so you compare the current number of elements in the queue (`_count`) with
    the length of the array storing such data (`_items`). If these values are equal,
    you return `false` because there is no space, so you cannot enqueue any element.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，你需要检查环形队列中是否有空余空间，所以你需要比较队列中当前元素的数量（`_count`）与存储此类数据的数组长度（`_items`）。如果这两个值相等，你将返回`false`，因为没有空间，所以你不能入队任何元素。
- en: The next line checks whether the circular queue is empty, which means that the
    front index is smaller than `0`. If so, both front and rear indices are set to
    `0`. It indicates that there is only one element in the circular queue, and it
    is pointed to by both these indices.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行检查环形队列是否为空，这意味着前索引小于`0`。如果是这样，前索引和后索引都被设置为`0`。这表示环形队列中只有一个元素，并且这两个索引都指向它。
- en: If there is already something in the queue, you increment a value of the rear
    index. If it is equal to the number of elements in the array, you assign `0` to
    it.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列中已经有东西了，你增加后索引的值。如果它等于数组中的元素数量，你将其设置为`0`。
- en: In the last three lines, you add the new item to the place indicated by the
    rear index (`_rear`), increment the counter storing the number of elements currently
    located in the queue (`_count`), as well as return `true` indicating that the
    enqueue operation was successful.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后三行中，你将新元素添加到由后索引（`_rear`）指示的位置，增加存储队列中当前元素数量的计数器（`_count`），以及返回`true`以指示入队操作成功。
- en: 'Let’s now move to the `Dequeue` method, the code of which is shown next:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到`Dequeue`方法，其代码如下所示：
- en: '[PRE36]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, you check whether the circular queue is empty. If so, you return a `null`
    value. Otherwise, you save as `result` a value indicated by the front index. Such
    a value will be returned at the end of this method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你检查环形队列是否为空。如果是这样，你返回一个`null`值。否则，你将前索引指示的值保存为`result`。这个值将在本方法结束时返回。
- en: In the following lines, you check whether the front and rear indices are equal.
    It means that there is only one element in the queue. If so, you set both these
    indices to `-1`, which indicates that the circular queue is empty. Otherwise,
    you increment the front index. If it is equal to the number of elements in the
    array, you assign `0` to it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，你检查前索引和后索引是否相等。这意味着队列中只有一个元素。如果是这样，你将这两个索引都设置为`-1`，这表示环形队列是空的。否则，你增加前索引。如果它等于数组中的元素数量，你将其设置为`0`。
- en: In the last two lines, you just decrement the number of elements in the queue,
    as well as return the previously saved value (`result`).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两行中，你只是减少队列中的元素数量，以及返回之前保存的值（`result`）。
- en: 'Another method is named `Peek` and is presented as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法名为`Peek`，如下所示：
- en: '[PRE37]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This method just returns the first item in the queue without removing it from
    the queue. Of course, it returns `null` if the queue is empty.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是返回队列中的第一个元素，而不从队列中移除它。当然，如果队列为空，它将返回`null`。
- en: 'As you can see, the implementation of a circular queue is not difficult and
    requires a small number of lines of code. So, let’s see it in action with the
    following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，环形队列的实现并不困难，并且只需要少量代码。所以，让我们看看以下代码的实际效果：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding lines perform the operations shown in the diagram presenting a
    circular queue (*Figure 5**.15*). You create a new circular queue with places
    for eight elements of the `int` type. Then, you add `2`, `-4`, `1`, `8`, and `5`
    values and dequeue one element.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的几行执行了图中展示的环形队列操作（*图5.15*）。你创建了一个新的环形队列，可以存储八个`int`类型的元素。然后，你添加了`2`、`-4`、`1`、`8`和`5`这些值，并出队一个元素。
- en: After the introduction to the topic of circular queues, it is high time to take
    a look at a real-world example.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了循环队列的主题之后，是时候看看一个现实世界的例子了。
- en: Example – gravity roller coaster
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 重力过山车
- en: 'Let’s simulate the behavior of a gravity roller coaster located on a mountainside.
    There can be a maximum of 12 carts on this queue at the same time, which slide
    down the chute accelerated by gravity. After the participant enters the cart,
    it accelerates automatically, and there are several turns on its path. After reaching
    the foot of the mountain, the cart and the participant are pulled in using a simple
    pulley. The participant gets off at the same place where they boarded the cart,
    as shown next:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟位于山腰上的重力过山车的行为。这个队列在同一时间最多可以有12个车卡，它们在重力作用下沿着滑道下滑。参与者进入车卡后，它会自动加速，并在其路径上有几个转弯。到达山脚下后，车卡和参与者被一个简单的滑轮拉上来。参与者从他们上车的地方下车，如图所示：
- en: "![Figure 5.16 – \uFEFFIllustration of a gravity roller coaster example](img/B18069_05_16.jpg)"
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图5.16 – 重力过山车示例示意图](img/B18069_05_16.jpg)'
- en: Figure 5.16 – Illustration of a gravity roller coaster example
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 – 重力过山车示例示意图
- en: You can simulate this example using a circular queue with the maximum size set
    to 12, which means that a maximum of 12 people can currently be on this gravity
    roller coaster. Another person will not be admitted until a seat becomes available.
    Entering the cart means performing an *enqueue* operation, and leaving the cart
    means performing a *dequeue* operation. It is also worth mentioning that it is
    not possible to change the order in which participants are served. Whoever enters
    the queue first will be let out first, which is consistent with the FIFO principle.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用最大容量设置为12的循环队列来模拟这个例子，这意味着目前最多可以有12个人在这个重力过山车上。直到有座位空出，不会让另一个人进入。进入车卡意味着执行一个*入队*操作，离开车卡意味着执行一个*出队*操作。还值得一提的是，无法改变参与者被服务的顺序。首先进入队列的人将首先被放出，这与FIFO（先进先出）原则一致。
- en: 'Let’s take a look at the code, which is located in the `Program.cs` file:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位于`Program.cs`文件中的代码：
- en: '[PRE39]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, you specify a `QueueItem` alias for the value tuple type consisting of
    cart entering time and the chosen color. Then, the ride length is set to 10 seconds,
    as well as some additional variables being created, including the circular queue
    and the last used color.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你为包含车进入时间和所选颜色的值元组类型指定了一个`QueueItem`别名。然后，将骑行长度设置为10秒，以及创建了一些其他变量，包括循环队列和最后使用的颜色。
- en: 'The next part of the code is shown here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的下一部分，展示如下：
- en: '[PRE40]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It contains an infinite `while` loop. Within it, you first check which items
    should be dequeued, which means that the ride time (that is, 10 seconds) elapsed
    for them. If so, you also log the message. Then, you draw a random number to decide
    whether a new item should be added to the circular queue in this iteration of
    an infinite `while` loop. If so, you choose the next color from the `ConsoleColor`
    enumeration, try to enqueue a new item to the queue, as well as log the message.
    At the end of the iteration, you wait 500 milliseconds.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一个无限`while`循环。在这个循环中，你首先检查哪些项目应该被出队，这意味着它们的骑行时间（即10秒）已经过去。如果是这样，你也会记录消息。然后，你随机抽取一个数字来决定是否在这个无限`while`循环的这次迭代中向循环队列中添加一个新的项目。如果是这样，你从`ConsoleColor`枚举中选择下一个颜色，尝试将新项目入队，并记录消息。在迭代结束时，你等待500毫秒。
- en: 'The code of the auxiliary `Log` method is presented here:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了辅助`Log`方法的代码：
- en: '[PRE41]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When you run the code, you get the following result:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你会得到以下结果：
- en: "![Figure 5.17 – \uFEFFScreenshot of the gravity roller coaster example](img/B18069_05_17.jpg)"
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图5.17 – 重力过山车示例截图](img/B18069_05_17.jpg)'
- en: Figure 5.17 – Screenshot of the gravity roller coaster example
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 – 重力过山车示例截图
- en: Congratulations – you now know how to use a few types of queues! You took a
    look at a regular one, a priority queue, as well as a circular one, together with
    examples. So, it is high time to summarize the chapter.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜 – 你现在知道如何使用几种类型的队列了！你查看了一个常规队列、一个优先队列以及一个循环队列，并一起看了示例。所以，是时候总结本章内容了。
- en: Summary
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about two limited access data structures, namely
    stacks and queues, including regular, priority, and circular ones. It is worth
    remembering that such data structures have strictly specified ways of accessing
    elements. All of them also have various real-world applications. Some of them
    were mentioned in this chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了两种有限访问数据结构，即栈和队列，包括常规的、优先的和循环的。值得记住的是，这些数据结构有严格指定的访问元素的方式。它们都有各种现实世界的应用。其中一些在本章中提到了。
- en: First, you saw how a **stack** operates according to the LIFO principle. In
    this case, you can add an element at the top of the stack (a *push* operation),
    and remove an element from the top (a *pop* operation). The stack was shown in
    two examples, namely for reversing a word and for solving the *Tower of Hanoi*
    mathematical game.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你看到了**栈**如何根据LIFO（后进先出）原则操作。在这种情况下，你可以在栈顶添加一个元素（一个*压入*操作），并从栈顶移除一个元素（一个*弹出*操作）。栈在两个示例中进行了展示，即用于反转单词和解决*汉诺塔*数学游戏。
- en: In the following part of the chapter, you got to know a **queue** as a data
    structure, which operates according to the FIFO principle. In this case, *enqueue*
    and *dequeue* operations were presented. The queue was explained using two examples,
    both regarding the application simulating a call center. You learned how to use
    a thread-safe variant of a queue-related class, which is available while developing
    applications in the C# language.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，你了解了作为数据结构的**队列**，它根据FIFO（先进先出）原则操作。在这种情况下，介绍了*入队*和*出队*操作。队列使用两个示例进行了说明，都是关于模拟呼叫中心的应用。你学习了如何在C#语言开发应用程序时使用线程安全的队列相关类的变体。
- en: The next data structure shown in this chapter is named a **priority queue**
    and is an extension of a queue that supports the priorities of particular elements.
    In the end, you learned about a **circular queue**, which expands the concept
    of a regular queue by forming a circle, where the first and rear elements are
    indicated by indices.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来介绍的数据结构被称为**优先队列**，它是支持特定元素优先级的队列的扩展。最后，你学习了**循环队列**，它通过形成一个圆来扩展常规队列的概念，其中第一个和最后一个元素由索引指示。
- en: This is just the fifth chapter of this book, and you already learned a lot about
    various data structures and algorithms that are useful while developing applications
    in C#! Are you interested in increasing your knowledge by learning about **dictionaries**
    and **sets**? If so, let’s proceed to the next chapter and learn more about them!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是这本书的第五章，而你已经学到了很多关于在C#开发应用程序时非常有用的各种数据结构和算法。你对通过学习**字典**和**集合**来增加你的知识感兴趣吗？如果是这样，那就让我们继续到下一章，了解更多关于它们的内容！
- en: '[PRE42]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
