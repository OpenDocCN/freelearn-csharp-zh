- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: ASP.NET Core Web API Common Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API 常见实践
- en: We have introduced a lot of concepts in the previous chapters, including the
    basics of ASP.NET web API, the RESTful style, Entity Framework, unit testing and
    integration testing, CI/CD, and so on. You should be able to build a simple ASP.NET
    Core web API application by yourself. However, there are still many things that
    we need to learn.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了很多概念，包括 ASP.NET web API 的基础知识、RESTful 风格、Entity Framework、单元测试和集成测试、CI/CD
    等。你应该能够自己构建一个简单的 ASP.NET Core web API 应用程序。然而，还有很多东西我们需要学习。
- en: You may have heard the phrase “*there is no silver bullet*” before. It means
    that there are often no simple, universal, or one-size-fits-all solutions to solve
    all problems. No matter how powerful the technologies, tools, or frameworks are,
    they are not omnipotent. This is true for ASP.NET Core web API development. However,
    there are some common practices that can help us build a better ASP.NET Core web
    API application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过“*没有银弹*”这个短语。这意味着通常没有简单、通用或一刀切的解决方案来解决所有问题。无论技术、工具或框架多么强大，它们都不是万能的。这对于
    ASP.NET Core Web API 开发也是如此。然而，有一些常见实践可以帮助我们构建更好的 ASP.NET Core Web API 应用程序。
- en: 'In this chapter, we will summarize the common practices of ASP.NET Core web
    API development. We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将总结 ASP.NET Core Web API 开发的常见实践。在本章中，我们将涵盖以下主题：
- en: Common practices of ASP.NET Core web API development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API 开发的常见实践
- en: Optimizing the performance by implementing caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现缓存来优化性能
- en: Using HttpClientFactory to manage HttpClient instances
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HttpClientFactory 管理HttpClient实例
- en: After reading this chapter, you should be able to expand your knowledge of ASP.NET
    Core web API development and build a better web API application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 读完本章后，你应该能够扩展你对 ASP.NET Core web API 开发的知识，并构建更好的 Web API 应用程序。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code example in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15)找到。
- en: Common practices of ASP.NET web API development
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Web API 开发的常见实践
- en: In this section, we will introduce some common practices of ASP.NET web API
    development. Of course, we can’t cover all the common practices in this book.
    However, we will try to cover the most important ones.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些 ASP.NET web API 开发的常见实践。当然，我们无法在本书中涵盖所有常见实践。但是，我们将尝试涵盖最重要的那些。
- en: Using HTTPS instead of HTTP
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HTTPS 而不是 HTTP
- en: In the previous chapters, we have used HTTP endpoints for simplicity; however,
    in the real world, HTTPS should always be used instead of HTTP. HTTPS is a secure
    version of HTTP, which uses TLS/SSL to encrypt the HTTP traffic, thus preventing
    data from being intercepted or tampered with by a third party. This ensures the
    safety and integrity of the data being transmitted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们为了简单起见使用了 HTTP 端点；然而，在现实世界中，应该始终使用 HTTPS 而不是 HTTP。HTTPS 是 HTTP 的安全版本，它使用
    TLS/SSL 加密 HTTP 流量，从而防止第三方拦截或篡改数据。这确保了传输数据的安仝性和完整性。
- en: HTTPS is becoming increasingly popular for websites that require secure data
    transmission, such as online banking and online shopping. This trend is reflected
    in the fact that many web browsers, such as Google Chrome, Microsoft Edge, Firefox,
    and so on, now mark HTTP websites as **Not Secure** to encourage users to switch
    to HTTPS. This is a clear indication of the growing trend toward using HTTPS for
    secure data transmission.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要安全数据传输的网站，如在线银行和在线购物，HTTPS 正变得越来越流行。这一趋势体现在许多网络浏览器，如 Google Chrome、Microsoft
    Edge、Firefox 等，现在将 HTTP 网站标记为 **不安全**，以鼓励用户切换到 HTTPS。这是使用 HTTPS 进行安全数据传输趋势日益增长的明显迹象。
- en: 'The default ASP.NET Core web API template uses HTTPS by default. You can find
    the following code in the `Program.cs` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ASP.NET Core Web API 模板使用 HTTPS。你可以在 `Program.cs` 文件中找到以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code redirects all HTTP requests to HTTPS. In the development environment,
    the ASP.NET Core web API application uses a self-signed certificate. When you
    deploy your ASP.NET Core web API application to the production environment, you
    need to use a valid certificate issued by a trusted **certificate authority**
    (**CA**), such as Let’s Encrypt, DigiCert, Comodo, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将所有HTTP请求重定向到HTTPS。在开发环境中，ASP.NET Core Web API应用程序使用自签名证书。当您将ASP.NET Core
    Web API应用程序部署到生产环境时，您需要使用由受信任的**证书颁发机构**（**CA**）签发的有效证书，例如Let’s Encrypt、DigiCert、Comodo等。
- en: Using HTTP status codes correctly
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确使用HTTP状态码
- en: 'HTTP status codes are used to indicate the status of the HTTP request. There
    are five categories of HTTP status codes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码用于指示HTTP请求的状态。HTTP状态码有五个类别：
- en: '1xx: Informational'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1xx: 信息性'
- en: '2xx: Success'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2xx: 成功'
- en: '3xx: Redirection'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3xx: 重定向'
- en: '4xx: Client errors'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4xx: 客户端错误'
- en: '5xx: Server errors'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5xx: 服务器错误'
- en: 'The following table provides a summary of some of the most commonly used HTTP
    status codes in RESTful web APIs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了RESTful Web API中最常用的一些HTTP状态码的摘要：
- en: '| **Status code** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `200` | OK |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `200` | OK |'
- en: '| `201` | Created |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `201` | 已创建 |'
- en: '| `202` | Accepted |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `202` | 已接受 |'
- en: '| `204` | No Content |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `204` | 无内容 |'
- en: '| `301` | Moved Permanently |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `301` | 永久移动 |'
- en: '| `302` | Found |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `302` | 找到 |'
- en: '| `304` | Not Modified |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `304` | 未修改 |'
- en: '| `400` | Bad Request |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 错误请求 |'
- en: '| `401` | Unauthorized |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `401` | 未授权 |'
- en: '| `403` | Forbidden |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `403` | 禁止访问 |'
- en: '| `404` | Not Found |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `404` | 未找到 |'
- en: '| `405` | Method Not Allowed |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `405` | 不允许的方法 |'
- en: '| `409` | Conflict |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `409` | 冲突 |'
- en: '| `410` | Gone |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `410` | 已删除 |'
- en: '| `415` | Unsupported Media Type |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `415` | 不支持媒体类型 |'
- en: '| `422` | Unprocessable Entity |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `422` | 不可处理的实体 |'
- en: '| `429` | Too Many Requests |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `429` | 请求过多 |'
- en: '| `500` | Internal Server Error |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `500` | 内部服务器错误 |'
- en: '| `501` | Not Implemented |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `501` | 未实现 |'
- en: '| `503` | Service Unavailable |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `503` | 服务不可用 |'
- en: '| `504` | Gateway Timeout |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `504` | 网关超时 |'
- en: Table 15.1 – Commonly used HTTP status codes in RESTful web APIs
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1 – RESTful Web API中常用的HTTP状态码
- en: 'The following list shows the HTTP methods and their corresponding status codes
    for RESTful web APIs:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了RESTful Web API中HTTP方法和它们对应的状态码：
- en: '`GET`: The `GET` method is used to retrieve a single resource or a collection
    of resources. A `GET` request should not modify the state of the server. It can
    return the following status codes:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: `GET`方法用于检索单个资源或资源集合。`GET`请求不应修改服务器状态。它可以返回以下状态码：'
- en: '`200`: The resource is found and returned.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`: 资源已找到并返回。'
- en: '`404`: The resource is not found. Note that if a collection exists but is empty,
    the `GET` method should return the `200` status code instead of the `404` status
    code.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`: 资源未找到。注意，如果集合存在但为空，则`GET`方法应返回`200`状态码，而不是`404`状态码。'
- en: '`POST`: The `POST` method is used to create a new single resource or a collection
    of resources. It can be also used to update a resource. It can return the following
    status codes:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: `POST`方法用于创建单个资源或资源集合。它也可以用于更新资源。它可以返回以下状态码：'
- en: '`200`: The resource is updated successfully.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`: 资源已成功更新。'
- en: '`201`: The resource is created successfully. The response should include the
    identifier of the newly created resource.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201`: 资源创建成功。响应应包含新创建资源的标识符。'
- en: '`202`: The resource is accepted for processing, but the processing is not yet
    complete. This status code is often used for long-running operations.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`202`: 资源已接受处理，但处理尚未完成。此状态码通常用于长时间运行的操作。'
- en: '`400`: The request is invalid.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`: 请求无效。'
- en: '`409`: The resource already exists.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`409`: 资源已存在。'
- en: '`PUT`: The `PUT` method is used to update a single resource or a collection
    of resources. It is rarely used to create resources. It can return the following
    status codes:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: `PUT`方法用于更新单个资源或资源集合。它很少用于创建资源。它可以返回以下状态码：'
- en: '`200`: The resource was updated successfully.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`: 资源已成功更新。'
- en: '`204`: The resource was updated successfully but there is no content to return.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204`: 资源已成功更新，但没有内容可返回。'
- en: '`404`: The resource was not found.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`: 资源未找到。'
- en: '`DELETE`: The `DELETE` method is used to delete a single resource with a specific
    identifier. It can be used to delete a collection of resources but it is not a
    common scenario. It can return the following status codes:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: `DELETE`方法用于删除具有特定标识符的单个资源。它可以用于删除资源集合，但这不是常见场景。它可以返回以下状态码：'
- en: '`200`: The resource was deleted successfully and the response includes the
    deleted resource.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`: 资源已成功删除，并且响应中包含已删除的资源。'
- en: '`204`: The resource was deleted successfully but there is no content to return.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204`: 资源已成功删除，但没有内容返回。'
- en: '`404`: The resource was not found.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`: 资源未找到。'
- en: It is important to note that this list is not exhaustive and only applies to
    RESTful web APIs. When selecting the appropriate HTTP status codes, please consider
    the specific scenarios. For GraphQL APIs, `200` is typically used for most responses,
    with the `errors` field indicating any errors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个列表并不全面，仅适用于 RESTful Web API。在选择合适的 HTTP 状态码时，请考虑具体场景。对于 GraphQL API，通常使用
    `200` 作为大多数响应的状态码，`errors` 字段指示任何错误。
- en: Using asynchronous programming
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步编程
- en: The ASP.NET Core web API framework is designed to process requests asynchronously,
    so we should use asynchronous programming as much as possible. Asynchronous programming
    allows the application to process multiple tasks concurrently, which can improve
    the performance of the application. For many I/O-bound operations, such as accessing
    the database, sending HTTP requests, and operating files, using asynchronous programming
    can release the thread to process other requests while waiting for the I/O operation
    to complete.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API 框架旨在异步处理请求，因此我们应该尽可能使用异步编程。异步编程允许应用程序并发处理多个任务，从而可以提高应用程序的性能。对于许多
    I/O 密集型操作，例如访问数据库、发送 HTTP 请求和操作文件，使用异步编程可以在等待 I/O 操作完成的同时释放线程以处理其他请求。
- en: 'In C#, you can use the `async` and `await` keywords to define and await asynchronous
    operations. Many methods in .NET have synchronous and asynchronous versions. For
    example, the `StreamReader` class has the following synchronous and asynchronous
    methods to read the content of the stream:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你可以使用 `async` 和 `await` 关键字来定义和等待异步操作。.NET 中的许多方法都有同步和异步版本。例如，`StreamReader`
    类有以下同步和异步方法来读取流的内容：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In these four methods, the methods without the `Async` suffix are synchronous,
    which blocks the thread until the operation is completed. In contrast, the methods
    that have the `Async` suffix are asynchronous, which returns a `Task` object immediately
    and allows the thread to process other requests. When the operation is completed,
    the `Task` object will be completed and the thread will continue to process the
    request. Whenever possible, we should use asynchronous programming to improve
    the performance of the application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四种方法中，没有 `Async` 后缀的方法是同步的，它会在操作完成之前阻塞线程。相比之下，带有 `Async` 后缀的方法是异步的，它立即返回一个
    `Task` 对象并允许线程处理其他请求。当操作完成时，`Task` 对象将完成，线程将继续处理请求。尽可能使用异步编程以提高应用程序的性能。
- en: 'For I/O operations, we should always use asynchronous programming. For example,
    when accessing `HttpRequest` and `HttpResponse` objects, we should use the asynchronous
    methods. Here is an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 I/O 操作，我们应该始终使用异步编程。例如，当访问 `HttpRequest` 和 `HttpResponse` 对象时，应使用异步方法。以下是一个示例：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the `ReadToEndAsync()` method is used to read the content
    of the request body. For this case, we should not use the synchronous `ReadToEnd()`
    method because it will block the thread until the operation is completed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用 `ReadToEndAsync()` 方法读取请求体的内容。对于这种情况，我们不应使用同步的 `ReadToEnd()` 方法，因为它将阻塞线程直到操作完成。
- en: 'If there are multiple asynchronous operations that need to be executed concurrently,
    we can use the `Task.WhenAll()` method to wait for all the asynchronous operations
    to complete. Here is an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个异步操作需要同时执行，我们可以使用 `Task.WhenAll()` 方法等待所有异步操作完成。以下是一个示例：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, the `Task.WhenAll()` method waits for the `task1` and
    `task2` tasks to complete. If you need to get the results of the tasks after they
    are completed, you can use the `Result` property of the `Task` object to get the
    results. Here is an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Task.WhenAll()` 方法等待 `task1` 和 `task2` 任务完成。如果你需要在任务完成后获取任务的结果，可以使用
    `Task` 对象的 `Result` 属性来获取结果。以下是一个示例：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, the `Result` property of the `task1` and `task2` objects
    is used to get the results of the tasks. As we already used the `await` keyword
    to wait for the tasks to be completed, the `Result` property will return the results
    immediately. But if we don’t use the `await` keyword to wait for the tasks to
    be completed, the `Result` property will block the thread until the tasks are
    completed. So, please be careful when using the `Result` property. Similarly,
    the `Wait()` method of the `Task` object will also block the thread until the
    task is completed. If you want to wait for a task to complete, use the `await`
    keyword instead of the `Wait` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了`task1`和`task2`对象的`Result`属性来获取任务的结果。因为我们已经使用了`await`关键字等待任务完成，所以`Result`属性将立即返回结果。但如果我们没有使用`await`关键字等待任务完成，`Result`属性将阻塞线程，直到任务完成。因此，在使用`Result`属性时请务必小心。同样，`Task`对象的`Wait()`方法也会阻塞线程，直到任务完成。如果你想等待任务完成，请使用`await`关键字而不是`Wait`方法。
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that the `Task.WhenAll()` method is not suitable for all scenarios. For
    example, EF Core does not support running multiple queries in parallel on the
    same database context. If you need to execute multiple queries on the same database
    context, you should use the `await` keyword to wait for the previous query to
    complete before executing the next query.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Task.WhenAll()`方法并不适用于所有场景。例如，EF Core不支持在同一个数据库上下文中并行执行多个查询。如果你需要在同一个数据库上下文中执行多个查询，你应该使用`await`关键字等待前一个查询完成，然后再执行下一个查询。
- en: 'When utilizing asynchronous programming, there are several important considerations
    to keep in mind. These include, but are not limited to, the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用异步编程时，有几个重要的考虑因素需要记住。这些包括但不限于以下内容：
- en: Do not use `async void` in ASP.NET Core. The only scenario where `async void`
    is allowed is in event handlers. If an async method returns `void`, the exceptions
    thrown in the method will not be caught by the caller properly.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在ASP.NET Core中使用`async void`。唯一允许使用`async void`的场景是在事件处理器中。如果异步方法返回`void`，则方法中抛出的异常不会被调用者正确捕获。
- en: Do not mix synchronous and asynchronous methods in the same method. Try to use
    async for the entire process if possible. This allows the entire call stack to
    be asynchronous.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在同一个方法中混合同步和异步方法。如果可能，尽量在整个过程中使用`async`。这允许整个调用堆栈都是异步的。
- en: If you need to use the `Result` property of the `Task` object, make sure that
    the `Task` object is completed. Otherwise, the `Result` property will block the
    thread until the `Task` object is completed.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要使用`Task`对象的`Result`属性，请确保`Task`对象已完成。否则，`Result`属性将阻塞线程，直到`Task`对象完成。
- en: 'If you have a method that only returns the result of another async method,
    there’s no need to use the `async` keyword. Just return the `Task` object directly.
    For example, the following code is unnecessary:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个只返回另一个异步方法结果的函数，就没有必要使用`async`关键字。只需直接返回`Task`对象即可。例如，以下代码是不必要的：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following code does not use the `async`/`await` keywords, which is better:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码没有使用`async`/`await`关键字，这更好：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is because the `async` keyword will create a state machine to manage the
    execution of the async method. In this case, it is unnecessary. Returning the
    `Task` directly does not create additional overhead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`async`关键字将创建一个状态机来管理异步方法的执行。在这种情况下，这是不必要的。直接返回`Task`不会产生额外的开销。
- en: Using pagination for large collections
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对大型集合使用分页
- en: 'It is not recommended to return a large collection of resources in a single
    response, as this can lead to performance issues. Such issues may include the
    following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在单个响应中返回大量资源，因为这可能导致性能问题。这些问题可能包括以下内容：
- en: The server may require a significant amount of time to query the database and
    process the response.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可能需要大量时间来查询数据库并处理响应。
- en: The response payload may be quite large, resulting in network congestion. This
    can negatively impact the performance of the system, leading to increased latency
    and decreased throughput.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应负载可能相当大，从而导致网络拥塞。这可能会对系统的性能产生负面影响，导致延迟增加和吞吐量下降。
- en: The client may require additional time and resources to process the large response.
    Deserializing a large JSON object can be computationally expensive for the client.
    Also, rendering a large collection of items on the UI may cause the client to
    become unresponsive.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可能需要额外的时间和资源来处理大量的响应。对于客户端来说，反序列化一个大的JSON对象可能是计算密集型的。此外，在UI上渲染大量项目可能会导致客户端无响应。
- en: 'In order to efficiently manage large collections, it is recommended to use
    pagination. [*Chapter 5*](B18971_05.xhtml#_idTextAnchor198) introduces pagination
    and filtering through the use of the `Skip()` and `Take()` methods of the `IQueryable`
    interface. Also, we mentioned that the `AsNoTracking()` method should be used
    to improve the performance of the read-only queries. This will result in a collection
    of resources being returned to the client. However, the client may not be aware
    of whether there are more resources available. To address this issue, we can create
    a custom class to represent the paginated response. An example of this is provided
    here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地管理大量集合，建议使用分页。[*第五章*](B18971_05.xhtml#_idTextAnchor198)介绍了通过使用`IQueryable`接口的`Skip()`和`Take()`方法来实现分页和过滤。我们还提到应该使用`AsNoTracking()`方法来提高只读查询的性能。这将导致返回给客户端的资源集合。然而，客户端可能不知道是否有更多的资源可用。为了解决这个问题，我们可以创建一个自定义类来表示分页响应。以下是一个示例：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, the `PaginatedList<T>` class contains a couple of properties
    to represent the pagination information:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`PaginatedList<T>`类包含一些属性来表示分页信息：
- en: '`PageIndex`: The current page index'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PageIndex`：当前页索引'
- en: '`PageSize`: The page size'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PageSize`：页面大小'
- en: '`TotalPages`: The total number of pages'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TotalPages`：总页数'
- en: '`Items`: The collection of items on the current page'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Items`：当前页上的项目集合'
- en: '`HasPreviousPage`: Indicates whether there is a previous page'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HasPreviousPage`：指示是否存在上一页'
- en: '`HasNextPage`: Indicates whether there is a next page'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HasNextPage`：指示是否存在下一页'
- en: 'Then, we can use this class in the controller for pagination. Here is an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在控制器中使用这个类来实现分页。以下是一个示例：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, besides the `Items` property, the `PaginatedList<T>`
    class also contains the pagination information, such as `PageIndex`, `PageSize`,
    `TotalPages`, `HasPreviousPage`, `HasNextPage`, and so on. The response of the
    endpoint will be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，除了`Items`属性外，`PaginatedList<T>`类还包含分页信息，如`PageIndex`、`PageSize`、`TotalPages`、`HasPreviousPage`、`HasNextPage`等。端点的响应将如下所示：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this way, the clients can implement pagination easily. You can also include
    more information in the `PaginatedList<T>` class, such as the links to the previous
    page and the next page, and so on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，客户端可以轻松实现分页。您还可以在`PaginatedList<T>`类中包含更多信息，例如上一页和下一页的链接等。
- en: 'When implementing pagination, it is important to consider sorting and filtering.
    Generally, the data should be filtered first, followed by sorting and then pagination.
    For example, the following LINQ query can be used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现分页时，考虑排序和过滤非常重要。通常，数据应该先进行过滤，然后是排序，最后是分页。例如，以下LINQ查询可以用来：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Where()` method should be used to filter the data first in order to reduce
    the amount of data to be sorted. This is important, as sorting is often an expensive
    operation. Once the data has been filtered, the `OrderBy()` method can be used
    to sort it. Finally, the `Skip()` and `Take()` methods can be used to paginate
    the data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用`Where()`方法首先过滤数据，以减少需要排序的数据量。这很重要，因为排序通常是一个昂贵的操作。一旦数据被过滤，可以使用`OrderBy()`方法对其进行排序。最后，可以使用`Skip()`和`Take()`方法对数据进行分页。
- en: Specifying the response types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定响应类型
- en: 'An ASP.NET Core web API endpoint can return various types of responses, such
    as `ActionResult`, `ActionResult<T>`, or a specific type of the object. For example,
    the following code returns a `Post` object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API端点可以返回各种类型的响应，例如`ActionResult`、`ActionResult<T>`或对象的特定类型。以下代码返回一个`Post`对象：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code works, but what if the `post` cannot be found? It is recommended
    to use `ActionResult<T>` instead of the specific type of the object. The `ActionResult<T>`
    class is a generic class that can be used to return various HTTP status codes.
    Here is an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以正常工作，但如果找不到`post`怎么办？建议使用`ActionResult<T>`而不是对象的特定类型。`ActionResult<T>`类是一个泛型类，可以用来返回各种HTTP状态码。以下是一个示例：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the `ActionResult<Post>` class is used to return a `Post`
    object. If the `post` cannot be found, the `NotFound` method is used to return
    the `404 Not Found` status code. If the `post` is found, the `Ok` method is used
    to return the `200 OK` status code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ActionResult<Post>` 类被用来返回一个 `Post` 对象。如果找不到 `post`，则使用 `NotFound`
    方法返回 `404 Not Found` 状态码。如果找到 `post`，则使用 `Ok` 方法返回 `200 OK` 状态码。
- en: 'We can add the `[ProducesResponseType]` attribute to specify the response types
    of the endpoint. Here is a complete example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `[ProducesResponseType]` 属性添加到指定端点的响应类型。以下是一个完整的示例：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, there are two `[ProducesResponseType]` attributes. The
    first one specifies the `200 OK` status code and the second one specifies the
    `404 Not Found` status code. The `[ProducesResponseType]` attribute is optional,
    but it is recommended to use it to specify the response types of the endpoint.
    The Swagger UI will use the `[ProducesResponseType]` attribute to generate the
    response types of the endpoint, as shown in *Figure 15**.1*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有两个 `[ProducesResponseType]` 属性。第一个指定了 `200 OK` 状态码，第二个指定了 `404 Not
    Found` 状态码。`[ProducesResponseType]` 属性是可选的，但建议使用它来指定端点的响应类型。Swagger UI 将使用 `[ProducesResponseType]`
    属性来生成端点的响应类型，如图 *图15.1* 所示：
- en: '![Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to
    generate the response types of the endpoint](img/B18971_15_01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – Swagger UI 使用 `[ProducesResponseType]` 属性来生成端点的响应类型](img/B18971_15_01.jpg)'
- en: Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to generate
    the response types of the endpoint
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – Swagger UI 使用 `[ProducesResponseType]` 属性来生成端点的响应类型
- en: We can see there are possible responses in the Swagger UI. This endpoint can
    return the `200 OK` status code or the `404 Not Found` status code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Swagger UI 中看到可能的响应。这个端点可以返回 `200 OK` 状态码或 `404 Not Found` 状态码。
- en: 'To enforce the use of the `[ProducesResponseType]` attribute, we can use the
    `OpenAPIAnalyzers`. This analyzer can be used to report the missing `[ProducesResponseType]`
    attribute. Add the following code in the `<PropertyGroup>` section of the `*.``csproj`
    file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制使用 `[ProducesResponseType]` 属性，我们可以使用 `OpenAPIAnalyzers`。这个分析器可以用来报告缺少 `[ProducesResponseType]`
    属性。在 `*.csproj` 文件的 `<PropertyGroup>` 部分添加以下代码：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can see the warning in Visual Studio if the controller action does
    not have the `[ProducesResponseType]` attribute, as shown in *Figure 15**.2*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 Visual Studio 中看到如果控制器操作没有 `[ProducesResponseType]` 属性将显示的警告，如图 *图15.2*
    所示：
- en: '![Figure 15.2 – Visual Studio displays the warning if the controller action
    does not have the [ProducesResponseType] attribute](img/B18971_15_02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 – Visual Studio 如果控制器操作没有 `[ProducesResponseType]` 属性将显示警告](img/B18971_15_02.jpg)'
- en: Figure 15.2 – Visual Studio displays the warning if the controller action does
    not have the [ProducesResponseType] attribute
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – Visual Studio 如果控制器操作没有 `[ProducesResponseType]` 属性将显示警告
- en: Visual Studio will provide you with a quick fix to add these attributes. This
    analyzer is very useful and it is recommended to use it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 将为你提供快速修复来添加这些属性。这个分析器非常有用，建议使用它。
- en: Adding comments to the endpoints
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在端点添加注释
- en: Adding XML comments to the endpoints can help other developers understand them
    better. These comments will be displayed in the Swagger UI, providing a comprehensive
    description of the endpoints. This can be a great resource for developers to use
    when working with the endpoints.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点添加 XML 注释可以帮助其他开发者更好地理解它们。这些注释将在 Swagger UI 中显示，提供端点的全面描述。这可以成为开发者使用端点时的宝贵资源。
- en: 'Adding XML comments to the endpoints is very simple. We just need to add the
    `///` comments to them. Visual Studio will automatically generate the XML comments
    structure when you type `///`. You need to add the description of the method,
    the parameters, the return value, and so on. Here is an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点添加 XML 注释非常简单。我们只需向它们添加 `///` 注释。当你输入 `///` 时，Visual Studio 将自动生成 XML 注释结构。你需要添加方法的描述、参数、返回值等。以下是一个示例：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also add comments to the model classes. Here is a simple example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向模型类添加注释。以下是一个简单的示例：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we need to enable the XML documentation file generation in the project
    file. Open the `*.csproj` file and add the following code in the `<``PropertyGroup>`
    element:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在项目文件中启用 XML 文档文件生成。打开 `*.csproj` 文件，并在 `<PropertyGroup>` 元素中添加以下代码：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `GenerateDocumentationFile` property specifies whether an XML documentation
    file should be generated. The `NoWarn` property can be used to suppress specific
    warnings, such as the `1591` warning code, which is associated with missing XML
    comments. Suppressing this warning is beneficial, as it prevents the warning from
    appearing when the project is built.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateDocumentationFile` 属性指定是否应生成 XML 文档文件。`NoWarn` 属性可以用来抑制特定的警告，例如与缺少
    XML 注释相关的 `1591` 警告代码。抑制此警告是有益的，因为它可以防止在构建项目时出现警告。'
- en: 'Next, we need to configure the Swagger UI to use the XML documentation file.
    Open the `Program.cs` file and update the `builder.Services.AddSwaggerGen()` method
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置 Swagger UI 以使用 XML 文档文件。打开 `Program.cs` 文件，并更新 `builder.Services.AddSwaggerGen()`
    方法如下：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, the `IncludeXmlComments` method is used to specify the
    XML documentation file. We can use reflection `{Assembly.GetExecutingAssembly().GetName().Name}.xml`,
    to get the name of the XML documentation file. The `AppContext.BaseDirectory`
    property is used to get the base directory of the application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了 `IncludeXmlComments` 方法来指定 XML 文档文件。我们可以使用反射 `{Assembly.GetExecutingAssembly().GetName().Name}.xml`
    来获取 XML 文档文件名。`AppContext.BaseDirectory` 属性用于获取应用程序的基本目录。
- en: 'To view the comments in the Swagger UI, run the application and open the Swagger
    UI. As shown in *Figure 15**.3*, the comments will be displayed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Swagger UI 中查看评论，运行应用程序并打开 Swagger UI。如图 *15.3* 所示，评论将被显示：
- en: '![Figure 15.3 – The Swagger UI displays the comments of the endpoints](img/B18971_15_03.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – Swagger UI 显示端点的评论](img/B18971_15_03.jpg)'
- en: Figure 15.3 – The Swagger UI displays the comments of the endpoints
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – Swagger UI 显示端点的评论
- en: 'The model classes are also described in the Swagger UI, as shown in *Figure
    15**.4*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类也在 Swagger UI 中进行了描述，如图 *15.4* 所示：
- en: '![Figure 15.4 – The Swagger UI displays the comments of the model classes](img/B18971_15_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.4 – Swagger UI 显示模型类的评论](img/B18971_15_04.jpg)'
- en: Figure 15.4 – The Swagger UI displays the comments of the model classes
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – Swagger UI 显示模型类的评论
- en: Displaying the comments in the Swagger UI is a great way to provide developer-friendly
    API documentation. It is highly recommended to add comments to the endpoints and
    model classes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swagger UI 中显示评论是提供开发者友好的 API 文档的绝佳方式。强烈建议为端点和模型类添加注释。
- en: Using System.Text.Json instead of Newtonsoft.Json
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 System.Text.Json 替代 Newtonsoft.Json
- en: '`Newtonsoft.Json` is a popular JSON library for .NET and is widely used in
    many projects. It was created as a personal project by James Newton-King in 2006
    and has since become the number one library on NuGet, with over one billion downloads.
    An interesting fact is that in 2022, the downloads of `Newtonsoft.Json` on NuGet
    reached an impressive 2.1 billion, surpassing the `Int32.MaxValue` of 2,147,483,647\.
    This milestone necessitated a change to NuGet to support the continued downloads
    of `Newtonsoft.Json`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Newtonsoft.Json` 是 .NET 中流行的 JSON 库，在许多项目中得到广泛应用。它是由 James Newton-King 在 2006
    年作为一个个人项目创建的，并从此成为 NuGet 上的第一库，下载量超过十亿次。一个有趣的事实是，在 2022 年，NuGet 上 `Newtonsoft.Json`
    的下载量达到了令人印象深刻的 21 亿次，超过了 2,147,483,647 的 `Int32.MaxValue`。这一里程碑促使 NuGet 进行了修改，以支持
    `Newtonsoft.Json` 的持续下载。'
- en: Microsoft has introduced a new JSON library, `System.Text.Json`, with the release
    of .NET Core 3.0\. This library was designed to be high performing by utilizing
    `Span<T>`, which provides a type-safe and memory-safe representation of contiguous
    regions of arbitrary memory. Using `Span<T>` can reduce memory allocation and
    improve the performance of .NET code. `System.Text.Json` is included in the .NET
    Core SDK and is actively being developed. Although it may not have all the features
    of `Newtonsoft.Json`, it is a great choice for new projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 .NET Core 3.0 的发布，Microsoft 引入了一个新的 JSON 库，`System.Text.Json`。这个库通过利用 `Span<T>`
    来设计，它提供了一个类型安全和内存安全的任意连续内存区域的表示。使用 `Span<T>` 可以减少内存分配并提高 .NET 代码的性能。`System.Text.Json`
    包含在 .NET Core SDK 中，并且正在积极开发中。尽管它可能没有 `Newtonsoft.Json` 的所有功能，但它对于新项目来说是一个很好的选择。
- en: 'The latest ASP.NET web API template uses `System.Text.Json` by default. It
    provides a simple way to serialize and deserialize JSON data. Here is an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的 ASP.NET Web API 模板默认使用 `System.Text.Json`。它提供了一个简单的方式来序列化和反序列化 JSON 数据。以下是一个示例：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you still want to use `Newtonsoft.Json`, you can install the `Microsoft.AspNetCore.Mvc.NewtonsoftJson`
    NuGet package and update the `Program.cs` file as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然想使用`Newtonsoft.Json`，您可以安装`Microsoft.AspNetCore.Mvc.NewtonsoftJson` NuGet包，并按照以下方式更新`Program.cs`文件：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can update the `options` object to configure the `Newtonsoft.Json` library.
    Again, it is recommended to use `System.Text.Json` instead of `Newtonsoft.Json`
    unless you need some specific features of `Newtonsoft.Json` because `System.Text.Json`
    has better performance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更新`options`对象来配置`Newtonsoft.Json`库。再次强调，除非您需要`Newtonsoft.Json`的一些特定功能，否则建议使用`System.Text.Json`而不是`Newtonsoft.Json`，因为`System.Text.Json`具有更好的性能。
- en: Optimizing the performance by implementing caching
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过实现缓存来优化性能
- en: Caching is a common technique used to improve the performance of the application.
    In web API development, caching can store frequently accessed data in a temporary
    storage, such as memory or disk, to reduce the number of database queries and
    improve the responsiveness of the application. In this section, we will introduce
    the caching in ASP.NET Core web API development.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一种常用的技术，用于提高应用程序的性能。在Web API开发中，缓存可以将频繁访问的数据存储在临时存储中，如内存或磁盘，以减少数据库查询次数并提高应用程序的响应速度。在本节中，我们将介绍ASP.NET
    Core web API开发中的缓存。
- en: Caching is an effective tool when handling data that is not regularly updated
    but is costly to compute or obtain from the database. It is also useful when multiple
    clients access the same data frequently. As an example, consider an e-commerce
    application that displays a list of categories. The categories of the products
    are not often changed, yet they are frequently viewed by users. To improve the
    performance of the application, we can cache the categories. When a user requests
    the categories, the application can return the cached data directly without querying
    the database.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是处理不经常更新但计算或从数据库获取成本高昂的数据的有效工具。当多个客户端频繁访问相同的数据时，它也非常有用。例如，考虑一个电子商务应用程序，它显示产品类别列表。产品类别不经常更改，但用户经常查看。为了提高应用程序的性能，我们可以缓存类别。当用户请求类别时，应用程序可以直接返回缓存数据，而无需查询数据库。
- en: 'In ASP.NET Core, we have several options for implementing caching, each suited
    to a specific scenario:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中，我们有几种实现缓存的方法，每种方法都适用于特定的场景：
- en: '**In-memory caching**: This type of caching stores data in the memory of the
    application. It is fast and efficient and is suitable for scenarios where the
    data does not need to be shared across multiple instances of the application.
    However, the data will be lost when the application is restarted.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存缓存**：这种类型的缓存将数据存储在应用程序的内存中。它快速高效，适用于数据不需要在应用程序的多个实例之间共享的场景。然而，当应用程序重启时，数据将会丢失。'
- en: '**Distributed caching**: This type of caching involves storing cached data
    in a shared storage, such as Redis or SQL Server, which can be accessed by multiple
    instances of the application. It is suitable for applications that are deployed
    with multiple instances, such as a web farm, container orchestration, or serverless
    computing.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式缓存**：这种类型的缓存涉及将缓存数据存储在共享存储中，如Redis或SQL Server，可以被应用程序的多个实例访问。它适用于部署了多个实例的应用程序，如Web农场、容器编排或无服务器计算。'
- en: '**Response caching**: This caching technique is based on the HTTP caching mechanism.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应缓存**：这种缓存技术基于HTTP缓存机制。'
- en: In the following sections, we will introduce the in-memory caching and distributed
    caching in ASP.NET Core web API development, as well as the output caching, which
    is introduced in ASP.NET Core 7.0.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将介绍ASP.NET Core web API开发中的内存缓存和分布式缓存，以及ASP.NET Core 7.0中引入的输出缓存。
- en: In-memory caching
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存缓存
- en: In-memory caching is a fast and easy way to store data in an application’s memory.
    ASP.NET Core provides the `IMemoryCache` interface to facilitate this process.
    This type of caching is highly versatile, as it can store any type of data in
    the form of a key-value pair.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缓存是将数据存储在应用程序内存中的快速简单方法。ASP.NET Core提供了`IMemoryCache`接口来简化此过程。这种类型的缓存非常灵活，因为它可以以键值对的形式存储任何类型的数据。
- en: The example project in this section can be found in the `chapter15/CachingDemo`
    folder. This is a simple ASP.NET Core web API application. It contains a `/categories`
    endpoint that returns the categories of products.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例项目可以在`chapter15/CachingDemo`文件夹中找到。这是一个简单的ASP.NET Core web API应用程序。它包含一个返回产品类别的`/categories`端点。
- en: 'To simplify the example, we use a static list to store the categories to simulate
    a database. When the application queries the categories, it will print a log to
    indicate that the categories are queried from the database. Here is the code in
    the `CategoryService` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，我们使用静态列表来存储类别以模拟数据库。当应用程序查询类别时，它将打印一条日志以指示类别是从数据库中查询的。以下是 `CategoryService`
    类中的代码：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we use a `Task.Delay()` method to simulate a database
    query. This query takes two seconds to complete, which is slow. As the categories
    are not often changed, we can use in-memory caching to improve the performance
    of the application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `Task.Delay()` 方法来模拟数据库查询。这个查询需要两秒钟才能完成，速度较慢。由于类别不经常更改，我们可以使用内存缓存来提高应用程序的性能。
- en: 'To use in-memory caching, we need to add the `Microsoft.Extensions.Caching.Memory`
    NuGet package by running the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用内存缓存，我们需要通过运行以下命令添加 `Microsoft.Extensions.Caching.Memory` NuGet 包：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we need to register the in-memory caching in the `Program` class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `Program` 类中注册内存缓存：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we can use the `IMemoryCache` interface in other classes. Inject the
    `IMemoryCache` interface into the `CategoryService` class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在其他类中使用 `IMemoryCache` 接口。将 `IMemoryCache` 接口注入到 `CategoryService` 类中：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Update the `GetCategoriesAsync` method as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `GetCategoriesAsync` 方法：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the updated code, we first try to get the categories from the cache by the
    cache key. If the categories are found in the cache, we return them directly.
    Otherwise, we query the database and cache the categories for 10 minutes. The
    `SetAbsoluteExpiration()` method is used to set the absolute expiration time of
    the cache entry. After 10 minutes, the cache entry will be removed from the cache.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的代码中，我们首先尝试通过缓存键从缓存中获取类别。如果类别在缓存中找到，我们直接返回它们。否则，我们查询数据库并将类别缓存10分钟。使用 `SetAbsoluteExpiration()`
    方法设置缓存条目的绝对过期时间。10分钟后，缓存条目将从缓存中删除。
- en: 'Run the application and send a request to the `/categories` endpoint. The first
    request will take 2 seconds to complete, and then the subsequent requests will
    be completed immediately. You may see the following log in the console:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `/categories` 端点发送请求。第一次请求将花费2秒钟完成，然后后续请求将立即完成。你可能在控制台看到以下日志：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this way, in-memory caching can significantly improve the performance of
    the application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，内存缓存可以显著提高应用程序的性能。
- en: 'To ensure that the cache does not become bloated with outdated entries, the
    cache must apply a proper expiration policy. The cache has several options for
    expiration, two of them are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保缓存不会因过时条目而膨胀，缓存必须应用适当的过期策略。缓存有几种过期选项，其中两个如下：
- en: '**Absolute expiration**: The cache entry will be removed from the cache after
    a specified time.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对过期**：缓存条目将在指定时间后从缓存中删除。'
- en: '**Sliding expiration**: The cache entry will be removed after a predetermined
    period of time if it is not accessed.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动过期**：如果缓存条目在预定时间内未被访问，它将被删除。'
- en: 'When using `SlidingExpiration`, the cache can be retained indefinitely if it
    is accessed frequently. To avoid this, we can set the `AbsoluteExpiration` property
    or `AbsoluteExpirationRelativeToNow` property to limit the maximum lifetime of
    the cache entry. Here is an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `SlidingExpiration` 时，如果缓存经常被访问，它可以无限期地保留。为了避免这种情况，我们可以设置 `AbsoluteExpiration`
    属性或 `AbsoluteExpirationRelativeToNow` 属性以限制缓存条目的最大生存期。以下是一个示例：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, the `SlidingExpiration` property is set to 10 minutes,
    and the `AbsoluteExpirationRelativeToNow` property is set to 30 minutes. This
    means that the cache entry will be removed from the cache after 30 minutes, even
    if it is frequently accessed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，将 `SlidingExpiration` 属性设置为10分钟，将 `AbsoluteExpirationRelativeToNow`
    属性设置为30分钟。这意味着即使缓存条目经常被访问，30分钟后缓存条目也将从缓存中删除。
- en: 'Sometimes we may need to manually update the cache entry. For example, when
    a new category is created, or an existing category is updated or deleted, we can
    remove the cache entry to force the application to query the database again and
    refresh the cache entry. Move the preceding code to a new method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要手动更新缓存条目。例如，当创建新类别或更新或删除现有类别时，我们可以删除缓存条目以强制应用程序再次查询数据库并刷新缓存条目。将前面的代码移动到一个新方法中：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that in the preceding code, we should query the database first, then remove
    the cache entry and reset it. Otherwise, the application may query the database
    multiple times if the cache entry is removed before the database query is completed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们应该先查询数据库，然后删除缓存条目并重置它。否则，如果缓存条目在数据库查询完成之前被删除，应用程序可能会多次查询数据库。
- en: 'Then, we can call the `RefreshCategoriesCache()` method when a new category
    is created or an existing category is updated or deleted. Here is an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当创建新类别或更新或删除现有类别时，我们可以调用`RefreshCategoriesCache()`方法。以下是一个示例：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, we can create a background task to update the cache entry periodically.
    A background task is a task that runs behind the scenes without user interaction.
    It is useful for performing tasks that are not time-sensitive, such as updating
    the cache entry. To create a background task, we can use the `BackgroundService`
    class. Create a new class named `CategoriesCacheBackgroundService` that inherits
    from the `BackgroundService` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个后台任务定期更新缓存条目。后台任务是一种在后台运行而不需要用户交互的任务。它适用于执行非时间敏感的任务，例如更新缓存条目。要创建后台任务，我们可以使用`BackgroundService`类。创建一个名为`CategoriesCacheBackgroundService`的新类，该类继承自`BackgroundService`类：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we use a `while` loop to reset the cache entry every
    one hour. Note that you cannot inject the `ICategoryService` directly because
    the `BackgroundService` class will be registered as a singleton service, but the
    `ICategoryService` is registered as a scoped service. A singleton service cannot
    depend on a scoped service. To solve this problem, we need to use the `IServiceProvider`
    interface to create a scope and get the `ICategoryService` from the scope.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`while`循环每小时重置一次缓存条目。请注意，您不能直接注入`ICategoryService`，因为`BackgroundService`类将被注册为单例服务，而`ICategoryService`被注册为作用域服务。单例服务不能依赖于作用域服务。为了解决这个问题，我们需要使用`IServiceProvider`接口创建作用域并从作用域中获取`ICategoryService`。
- en: 'Then, register the `CacheBackgroundService` class in the `Program` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Program`类中注册`CacheBackgroundService`类：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the background task is executed every one hour, the cache entry will be
    removed from the cache. The background task should first query the database and
    then remove the cache entry and reset it. If the cache entry is deleted first,
    the application may query the database multiple times, resulting in performance
    issues.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当后台任务每小时执行一次时，缓存条目将从缓存中删除。后台任务应首先查询数据库，然后删除缓存条目并重置它。如果首先删除缓存条目，则应用程序可能会多次查询数据库，导致性能问题。
- en: 'When implementing caching, it is important to consider scenarios where records
    cannot be found in the database. Let us see how it happens. Update the `GetCategoryAsync()`
    method as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现缓存时，考虑无法在数据库中找到记录的场景非常重要。让我们看看这是如何发生的。按照以下方式更新`GetCategoryAsync()`方法：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, if the category cannot be found in the cache, we query
    the database and cache the category. But there is a potential issue here. What
    if the category with the specified ID does not exist? In this case, the application
    will not set the cache and each request will query the database. Cache is not
    used at all. To solve this problem, we can use the `GetOrCreateAsync` method of
    the `IMemoryCache` interface. Here is the updated code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果缓存中找不到类别，我们将查询数据库并将类别缓存起来。但这里有一个潜在的问题。如果指定的ID没有对应的类别，会发生什么？在这种情况下，应用程序将不会设置缓存，并且每次请求都会查询数据库。缓存根本不会被使用。为了解决这个问题，我们可以使用`IMemoryCache`接口的`GetOrCreateAsync`方法。以下是更新后的代码：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The updated code uses the `GetOrCreateAsync` method to retrieve the category
    from the cache. If the category is not present, the method will execute the specified
    delegate to fetch it from the database. Upon successful retrieval, the category
    will be cached and returned. If the category is not found, `null` will be returned.
    So, the application will not query the database every time. To avoid the issue
    mentioned earlier, it is recommended to use the `GetOrCreateAsync` method to obtain
    the data from the cache.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码使用`GetOrCreateAsync`方法从缓存中检索类别。如果类别不存在，该方法将执行指定的委托从数据库中获取它。成功检索后，类别将被缓存并返回。如果类别未找到，将返回`null`。因此，应用程序不会每次都查询数据库。为了避免前面提到的问题，建议使用`GetOrCreateAsync`方法从缓存中获取数据。
- en: 'There are more important considerations when using in-memory caching:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用内存缓存时，还有更多重要的考虑因素：
- en: '*Consider the expiration time of the cache entry*. If the data is not often
    changed, we can set a longer expiration time. Otherwise, use a shorter expiration
    time. Also, you can use the `SlidingExpiration` property and the absolute expiration
    time to achieve a balance between the performance and the freshness of the data.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*考虑缓存条目的过期时间*。如果数据不经常更改，我们可以设置较长的过期时间。否则，使用较短的过期时间。此外，您还可以使用 `SlidingExpiration`
    属性和绝对过期时间来在性能和数据新鲜度之间取得平衡。'
- en: '*The in-memory cache can cache any object, but be careful when caching large
    objects*. It is important to limit the size of the cache entry. We can use `SetSize`,
    `Size`, and `SizeLimit` to limit the size of the cache. Note that when using these
    methods, the in-memory cache must be registered as a singleton service. Please
    refer to the documentation for more information at [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory).'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存缓存可以缓存任何对象，但在缓存大型对象时要小心*。限制缓存条目的大小非常重要。我们可以使用 `SetSize`、`Size` 和 `SizeLimit`
    来限制缓存的大小。请注意，当使用这些方法时，内存缓存必须注册为单例服务。有关更多信息，请参阅[https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory)。'
- en: '*Define proper cache keys*. The cache keys should be unique and descriptive.
    Especially, when using caching for users, ensure that the cache keys are unique
    for each user. Otherwise, the cached data of one user may be used by another user.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义合适的缓存键*。缓存键应该是唯一的且具有描述性。特别是，当使用缓存为用户服务时，确保缓存键对每个用户都是唯一的。否则，一个用户的缓存数据可能会被另一个用户使用。'
- en: '*Provide a way to fall back to the data source when the cache is* *not available*.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供一个当缓存不可用时回退到数据源的方法*。'
- en: There are no hard rules for these settings. You need to consider the specific
    scenarios and adjust the settings accordingly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置没有硬性规则。您需要考虑特定的场景并相应地调整设置。
- en: In-memory caching is a simple and effective way to improve the performance of
    the application. However, it is not suitable for applications that are deployed
    with multiple instances. The cached data only works for the current instance.
    When a client requests the data from another instance, the cached data in the
    original instance will not be used. To solve this problem, one solution is to
    implement session affinity, which means the request from a user will always be
    routed to the same instance. This can be achieved by using a load balancer that
    supports session affinity, such as Nginx, Azure Application Gateway, and so on.
    This is out of the scope of this book. Please refer to the documentation of the
    load balancer for more information.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缓存是提高应用程序性能的一种简单而有效的方法。然而，它不适用于以多个实例部署的应用程序。缓存数据仅适用于当前实例。当客户端从另一个实例请求数据时，原始实例中的缓存数据将不会被使用。为了解决这个问题，一种解决方案是实现会话亲和性，这意味着用户的请求将始终被路由到相同的实例。这可以通过使用支持会话亲和性的负载均衡器，如
    Nginx、Azure Application Gateway 等，来实现。这超出了本书的范围。有关更多信息，请参阅负载均衡器的文档。
- en: Another approach to this issue is to implement a distributed cache, as outlined
    in the following section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的另一种方法是实现分布式缓存，如下一节所述。
- en: Distributed caching
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: Distributed caching offloads the cache from the application to a shared storage,
    such as Redis or SQL Server. The data stored in the distributed cache can be accessed
    by multiple instances of the application. If the application restarts, the cached
    data will not be lost. There is no need to implement session affinity when using
    distributed caching.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存将缓存从应用程序卸载到共享存储，例如 Redis 或 SQL Server。存储在分布式缓存中的数据可以被应用程序的多个实例访问。如果应用程序重新启动，缓存的数据将不会丢失。使用分布式缓存时，无需实现会话亲和性。
- en: 'There are several options to implement distributed caching in ASP.NET Core.
    The following are the most commonly used options:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中实现分布式缓存有几种选择。以下是最常用的选项：
- en: '**Redis**: Redis is an open-source, in-memory data structure store. It has
    many features, such as caching, pub/sub, and so on.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis**: Redis 是一个开源的内存数据结构存储。它具有许多功能，如缓存、发布/订阅等。'
- en: '**SQL Server**: SQL Server can be also used as a distributed cache.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Server**: SQL Server 也可以用作分布式缓存。'
- en: '**Azure Cache for Redis**: Azure Cache for Redis is a fully managed, open-source,
    in-memory data structure store. It is based on the popular open-source Redis cache.
    You can use a local Redis server for development and testing and use Azure Cache
    for Redis in production.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Cache for Redis**：Azure Cache for Redis 是一个完全托管、开源的内存数据结构存储。它基于流行的开源
    Redis 缓存。您可以使用本地 Redis 服务器进行开发和测试，并在生产中使用 Azure Cache for Redis。'
- en: '`https://github.com/Alachisoft/NCache`.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://github.com/Alachisoft/NCache`。'
- en: In this section, we will introduce the Redis cache using the same sample project
    as the previous section. We use a static `Dictionary<int, List<Category>>` to
    store the users’ favorites categories, which simulates the data stored in the
    database. When a user requests the favorites categories, the application will
    use the user ID as the key to query the database. If we use in-memory caching,
    the caching key should include the user ID, such as `1_Favorites_Categories`.
    However, if this user’s subsequent requests are routed to another instance, there
    is no way to get the cached data. That is why we need to use the distributed caching.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用与上一节相同的示例项目介绍 Redis 缓存。我们使用静态的 `Dictionary<int, List<Category>>` 来存储用户的收藏类别，这模拟了数据库中存储的数据。当用户请求收藏类别时，应用程序将使用用户
    ID 作为键来查询数据库。如果我们使用内存缓存，缓存键应包括用户 ID，例如 `1_Favorites_Categories`。然而，如果此用户的后续请求被路由到另一个实例，将无法获取缓存数据。这就是为什么我们需要使用分布式缓存。
- en: 'First, we need to prepare a Redis server. We can use the Docker to run a Redis
    server. Start Docker Desktop on your machine and run the following command to
    pull the Redis image:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要准备一个 Redis 服务器。我们可以使用 Docker 来运行 Redis 服务器。在您的机器上启动 Docker Desktop 并运行以下命令以拉取
    Redis 镜像：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, run the Redis server:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行 Redis 服务器：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Redis server will be listening on port `6379`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 服务器将在端口 `6379` 上监听。
- en: 'To access the Redis server in the terminal, we need to use the `redis-cli`
    command. This command is included in the Redis image. Run the following command
    to access the Redis server:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要在终端中访问 Redis 服务器，我们需要使用 `redis-cli` 命令。此命令包含在 Redis 镜像中。运行以下命令以访问 Redis 服务器：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `docker exec` command is used to execute a command in a running container.
    The `-it` option is used to run the command interactively. It means we want to
    execute the `redis-cli` command in the container. You will see the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker exec` 命令在运行中的容器中执行命令。`-it` 选项用于以交互式方式运行命令。这意味着我们想在容器中执行 `redis-cli`
    命令。您将看到以下输出：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This means we have successfully accessed the Redis server. Now we can use the
    `redis-cli` command to access the Redis server. For example, we can use the `set`
    command to set the value of a key:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经成功访问了 Redis 服务器。现在我们可以使用 `redis-cli` 命令来访问 Redis 服务器。例如，我们可以使用 `set`
    命令来设置键的值：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we can use the `get` command to get the value of the key:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `get` 命令来获取键的值：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will see `Hello World` in the output.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在输出中看到 `Hello World`。
- en: 'Now the Redis server is ready to use. To use the Redis cache in ASP.NET Core,
    we need to install the `Microsoft.Extensions.Caching.StackExchangeRedis` NuGet
    package:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Redis 服务器已准备好使用。要在 ASP.NET Core 中使用 Redis 缓存，我们需要安装 `Microsoft.Extensions.Caching.StackExchangeRedis`
    NuGet 包：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we need to register the Redis cache in the `Program` class:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `Program` 类中注册 Redis 缓存：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, the `AddStackExchangeRedisCache` extension method is
    used to register the Redis cache. We specify the Redis server address and an optional
    instance name, which is used to create a logical partition for the cache. Note
    that these configurations can be defined in the `appsettings.json` file or environment
    variables, allowing for different Redis instances to be used for development and
    production purposes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了 `AddStackExchangeRedisCache` 扩展方法来注册 Redis 缓存。我们指定了 Redis 服务器地址和可选的实例名称，该名称用于为缓存创建一个逻辑分区。请注意，这些配置可以在
    `appsettings.json` 文件或环境变量中定义，允许使用不同的 Redis 实例进行开发和生产。
- en: 'Next, we can use the `IDistributedCache` interface to operate the Redis cache.
    Inject the `IDistributedCache` interface into the `CategoryService` class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `IDistributedCache` 接口来操作 Redis 缓存。将 `IDistributedCache` 接口注入到 `CategoryService`
    类中：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we first try to get the favorites categories from the
    cache using the cache key. If the favorites categories are found in the distributed
    cache, we return the cached data directly. Otherwise, we query the database and
    store the result in the distributed cache.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先尝试使用缓存键从缓存中获取收藏的分类。如果收藏的分类在分布式缓存中找到，我们直接返回缓存的数据。否则，我们查询数据库并将结果存储在分布式缓存中。
- en: As the Redis cache stores the data as `byte[]`, to store the cached data, we
    need to serialize the data into a JSON string and then convert the JSON string
    into a `byte[]` value using the `Encoding.UTF8.GetBytes()` method. Similarly,
    when getting the cached data, we need to convert the `byte[]` value to a JSON
    string using the `Encoding.UTF8.GetString()` method and then deserialize the JSON
    string into the strongly-typed object using the `JsonSerializer.Deserialize()`
    method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Redis 缓存将数据存储为 `byte[]`，为了存储缓存数据，我们需要将数据序列化为 JSON 字符串，然后使用 `Encoding.UTF8.GetBytes()`
    方法将 JSON 字符串转换为 `byte[]` 值。同样，在获取缓存数据时，我们需要使用 `Encoding.UTF8.GetString()` 方法将
    `byte[]` 值转换为 JSON 字符串，然后使用 `JsonSerializer.Deserialize()` 方法将 JSON 字符串反序列化为强类型对象。
- en: In addition, the caching key must be a `string` value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，缓存键必须是一个 `string` 值。
- en: 'To make it easier to convert the data to and from `byte[]`, the `IDistributedCache`
    interface has a few extension methods as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据转换为 `byte[]` 和从 `byte[]` 转换更容易，`IDistributedCache` 接口有几个扩展方法，如下所示：
- en: '`SetStringAsync` and `SetString`: These two methods can save `string` values
    directly'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetStringAsync` 和 `SetString`：这两个方法可以直接保存 `string` 值'
- en: '`GetStringAsync` and `GetString`: These two methods can read `string` values
    directly'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetStringAsync` 和 `GetString`：这两个方法可以直接读取 `string` 值'
- en: To remove a cache entry, we can use the `RemoveAsync()` method or `Remove()`
    method. As we mentioned before, using the asynchronous versions of these methods
    is preferred.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除缓存条目，我们可以使用 `RemoveAsync()` 方法或 `Remove()` 方法。正如我们之前提到的，使用这些方法的异步版本是首选的。
- en: 'Run the application and send some requests to the `Categories/favorites/1`
    endpoint. You will see that the logs show the first response was from the database
    and the subsequent responses were from the distributed cache:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并向 `Categories/favorites/1` 端点发送一些请求。您将看到日志显示第一次响应来自数据库，后续的响应来自分布式缓存：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can use the `redis-cli` to examine the cached data. Run the following command
    to get the keys:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `redis-cli` 来检查缓存数据。运行以下命令以获取键：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output should look as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, use the `HGETALL` command to show the cached data:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `HGETALL` 命令来显示缓存数据：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that you cannot use the `GET` command here because it is used to retrieve
    the string values only. The categories data is stored as `hash` in Redis, so we
    need to use the `HGETALL` command.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不能在这里使用 `GET` 命令，因为它仅用于检索字符串值。分类数据在 Redis 中存储为 `hash`，因此我们需要使用 `HGETALL`
    命令。
- en: 'The output should look as follows, including all the fields of the cached entry:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示，包括缓存条目的所有字段：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using a distributed cache can help make applications more scalable by allowing
    cached data to be shared across multiple instances. However, this does come with
    the potential cost of increased latency due to the extra network I/O required.
    Careful consideration should be taken when deciding whether to use a distributed
    cache.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式缓存可以通过允许缓存数据在多个实例之间共享来帮助使应用程序更具可伸缩性。然而，这也可能带来由于额外的网络I/O所需的潜在成本增加的延迟。在决定是否使用分布式缓存时，应仔细考虑。
- en: 'The `IDistributedCache` interface does not have the `GetOrCreateAsync()` method.
    If the cached data is not found, the application still needs to query the database.
    To solve this problem, we can implement our own `GetOrCreateAsync()` method. Create
    an extension method for the `IDistributedCache` interface:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDistributedCache` 接口没有 `GetOrCreateAsync()` 方法。如果缓存数据未找到，应用程序仍然需要查询数据库。为了解决这个问题，我们可以实现自己的
    `GetOrCreateAsync()` 方法。为 `IDistributedCache` 接口创建一个扩展方法：'
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now the `GetFavoritesCategoriesAsync` method can be updated as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以将 `GetFavoritesCategoriesAsync` 方法更新如下：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the category is not found in the database, the `GetOrCreateAsync()` method
    will return `null` and cache the `null` value for future requests. In this way,
    the application will not query the database again and again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库中没有找到该分类，`GetOrCreateAsync()` 方法将返回 `null` 并为未来的请求缓存 `null` 值。这样，应用程序将不再反复查询数据库。
- en: 'The following table shows the differences between in-memory caching and distributed
    caching:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了内存缓存和分布式缓存的区别：
- en: '| **In-memory caching** | **Distributed caching** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **内存缓存** | **分布式缓存** |'
- en: '| --- | --- |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Cache data in the memory of the application | Cache data in a shared storage
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 在应用程序的内存中缓存数据 | 在共享存储中缓存数据 |'
- en: '| Suitable for applications that are deployed with a single instance | Suitable
    for applications that are deployed with multiple instances |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 适用于以单个实例部署的应用程序 | 适用于以多个实例部署的应用程序 |'
- en: '| The cached data is lost when the application restarts | The cached data is
    not lost when the application restarts |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序重启时缓存的数据会丢失 | 应用程序重启时缓存的数据不会丢失 |'
- en: '| The caching keys can be any `object` | The caching keys must be `string`
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 缓存键可以是任何 `object` | 缓存键必须是 `string` |'
- en: '| The cached data value can be any strongly-typed object | The cached data
    is persisted as `byte[]` and may need serialization and deserialization. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 缓存的数据值可以是任何强类型对象 | 缓存的数据以 `byte[]` 的形式持久化，可能需要序列化和反序列化。|'
- en: Table 15.2 – The differences between in-memory caching and distributed caching
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.2 – 内存缓存和分布式缓存的区别
- en: 'If you would like to use other distributed cache, you can install other packages
    such as the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用其他分布式缓存，你可以安装以下包等：
- en: '`dotnet add` `package Microsoft.Extensions.Caching.SqlServer`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet add` `package Microsoft.Extensions.Caching.SqlServer`'
- en: '`dotnet add` `package NCache.Microsoft.Extensions.Caching.OpenSource`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet add` `package NCache.Microsoft.Extensions.Caching.OpenSource`'
- en: Please refer to their official documentation for more details.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅它们的官方文档以获取更多详细信息。
- en: Response caching
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应缓存
- en: Response caching is defined in the RFC 9111 specification ([https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111)).
    It uses the HTTP header `cache-control` to specify the caching behavior. The clients
    (such as browsers) and immediate proxies (such as CDNs and gateways), can use
    the `cache-control` header to determine whether to cache the response and how
    long to cache it for.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 响应缓存定义在 RFC 9111 规范中 ([https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111))。它使用
    HTTP 头部 `cache-control` 来指定缓存行为。客户端（如浏览器）和直接代理（如 CDN 和网关）可以使用 `cache-control`
    头部来确定是否缓存响应以及缓存多长时间。
- en: 'The `cache-control` header has several directives as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache-control` 头部有几个指令，如下所示：'
- en: '`public`: The response can be cached by the clients and the intermediate proxies.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`: 响应可以被客户端和中间代理缓存。'
- en: '`private`: The response can be cached by the clients only. A shared cache,
    such as CDN, must not cache the response.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`: 响应只能被客户端缓存。共享缓存（如 CDN）不得缓存响应。'
- en: '`no-cache`: For requests, the clients must send the request to the server for
    validation before using a cached copy of the response. For responses, the clients
    must not use a cached copy of the response without successful validation on the
    server.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-cache`: 对于请求，客户端必须在使用缓存的响应副本之前将请求发送到服务器进行验证。对于响应，客户端必须在服务器上成功验证后才能使用缓存的响应副本。'
- en: '`no-store`: For requests, the clients must not store any part of the request.
    For responses, the clients must not store any part of the response.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-store`: 对于请求，客户端必须不存储请求的任何部分。对于响应，客户端必须不存储响应的任何部分。'
- en: '`max-age`: This is the maximum age of the response in seconds. The clients
    can use the cached copy of the response if it is not expired. For example, `max-age=3600`
    means the response can be cached for one hour.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max-age`: 这是指响应的最大年龄，以秒为单位。如果响应未过期，客户端可以使用缓存的副本。例如，`max-age=3600` 表示响应可以被缓存一小时。'
- en: 'We can use the `ResponseCache` attribute to specify the caching behavior of
    the endpoint. Here is an example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ResponseCache` 属性来指定端点的缓存行为。以下是一个示例：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we use the `ResponseCache` attribute on the controller
    to specify the caching behavior of the endpoint. `Duration = 60` means the response
    can be cached for 60 seconds.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `ResponseCache` 属性在控制器上指定端点的缓存行为。`Duration = 60` 表示响应可以被缓存 60 秒。
- en: 'Run the application and test the `/Categories` endpoint in the Swagger UI.
    You will see the `cache-control` header in the response, as shown here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并在 Swagger UI 中测试 `/Categories` 端点。你将看到响应中的 `cache-control` 头部，如下所示：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you resubmit the request, the browser will use the cached version of the
    response without sending the request to the server. This is managed by the `max-age`
    directive in the `cache-control` header. After 60 seconds have elapsed, the browser
    will send the request to the server for validation if the request is resubmitted.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新提交请求，浏览器将使用缓存的响应版本，而无需将请求发送到服务器。这由 `cache-control` 标头中的 `max-age` 指令管理。如果请求在
    60 秒后重新提交，浏览器将向服务器发送请求以进行验证。
- en: The HTTP-based response caching takes effect on the client side. If multiple
    clients send requests to the same endpoint, each request will cause the server
    to handle the request and generate the response. ASP.NET Core provides a server-side
    response caching middleware to cache the response on the server side. However,
    this middleware has a few limitations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 基于HTTP的响应缓存在客户端生效。如果多个客户端向同一端点发送请求，每个请求都会导致服务器处理请求并生成响应。ASP.NET Core 提供了一个服务器端响应缓存中间件，用于在服务器端缓存响应。然而，此中间件有一些限制。
- en: It only supports the `GET` and `HEAD` requests and it does not support requests
    that contain the `Authorization`, `Set-Cookie` headers, and so on.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅支持 `GET` 和 `HEAD` 请求，并且不支持包含 `Authorization`、`Set-Cookie` 标头等内容的请求。
- en: You cannot invalidate the client-side cached response on the server side when
    the data is changed.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据发生变化时，您无法在服务器端使客户端缓存的响应失效。
- en: 'Additionally, most browsers, such as Chrome and Edge, automatically send requests
    with the `cache-control: max-age=0` header, which disables response caching on
    the client side. As a result, the server will also respect this header and disable
    server-side response caching.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '此外，大多数浏览器，如 Chrome 和 Edge，会自动发送带有 `cache-control: max-age=0` 标头的请求，这禁用了客户端的响应缓存。因此，服务器也将尊重此标头并禁用服务器端响应缓存。'
- en: This book does not cover the middleware mentioned; for more information, please
    refer to the documentation at [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware).
    We will, however, introduce output caching, which is available in ASP.NET Core
    7.0 and later versions. This middleware resolves some of the limitations of the
    server-side response caching middleware.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有涵盖提到的中间件；有关更多信息，请参阅[https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware)上的文档。然而，我们将介绍输出缓存，这是
    ASP.NET Core 7.0 及更高版本中可用的。此中间件解决了服务器端响应缓存中间件的一些限制。
- en: Output caching
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出缓存
- en: 'In ASP.NET Core 7.0, Microsoft introduced the output caching middleware. This
    middleware works in a similar way to the server-side response caching middleware,
    but it has a few advantages:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 7.0 中，Microsoft 引入了输出缓存中间件。此中间件的工作方式与服务器端响应缓存中间件类似，但它有一些优点：
- en: It configures the caching behavior on the server side, so the client HTTP caching
    configuration does not affect the output caching configuration.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它配置了服务器端的缓存行为，因此客户端 HTTP 缓存配置不会影响输出缓存配置。
- en: It has the capability to invalidate the cached response on the server side when
    the data is changed.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据发生变化时，它具有在服务器端使缓存的响应失效的能力。
- en: It can use external cache stores, such as Redis, to store the cached response.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以使用外部缓存存储，例如 Redis，来存储缓存的响应。
- en: It can return a `304 Not Modified` response to the client when the cached response
    is not modified. This can save the network bandwidth.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓存的响应未修改时，它可以向客户端返回 `304 Not Modified` 响应。这可以节省网络带宽。
- en: 'However, the output caching middleware also has similar limitations to the
    response caching middleware:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，输出缓存中间件也具有与响应缓存中间件类似的限制：
- en: It only supports `GET` and `HEAD` requests with the `200 OK` status code
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅支持带有 `200 OK` 状态码的 `GET` 和 `HEAD` 请求
- en: It does not support `Authorization` and `Set-Cookie` headers
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持 `Authorization` 和 `Set-Cookie` 标头
- en: 'To enable output caching, we need to register the output caching middleware
    in the `Program` class:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用输出缓存，我们需要在 `Program` 类中注册输出缓存中间件：
- en: '[PRE52]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we need to add the middleware to the HTTP request pipeline:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将中间件添加到 HTTP 请求管道中：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, apply the `OutputCache` attribute to the endpoints that need to be cached.
    For example, we can apply the `OutputCache` attribute to the `/``categories/{id}`
    endpoint:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `OutputCache` 属性应用于需要缓存的端点。例如，我们可以将 `OutputCache` 属性应用于 `/categories/{id}`
    端点：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `GetOrCreateAsync()` method is shown as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetOrCreateAsync()` 方法如下所示：'
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Similarly, we use a `Task.Delay()` method to simulate the database query. Run
    the application and test the `/categories/1` endpoint in the Swagger UI. You will
    see that the console log shows that the first response was from the database.
    The headers of the response look as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用`Task.Delay()`方法来模拟数据库查询。运行应用程序并在Swagger UI中测试`/categories/1`端点。你会看到控制台日志显示第一个响应来自数据库。响应的头部如下所示：
- en: '[PRE56]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Send the request again. You will not see the database query log in the console.
    The headers of the response look as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 再次发送请求。你将不会在控制台看到数据库查询日志。响应的头部如下所示：
- en: '[PRE57]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can find that the headers of the response contain the `age` header, which
    indicates that the response is cached. The `age` header is the number of seconds
    since the response was generated.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现响应的头部包含`age`头部，这表明响应已被缓存。`age`头部是自响应生成以来的秒数。
- en: By default, the expiration time of the cached response is 60 seconds. After
    60 seconds have elapsed, the next request will query the database again.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，缓存的响应过期时间为60秒。60秒后，下一个请求将再次查询数据库。
- en: 'We can define different caching policies for different endpoints. Update the
    `AddOutputCache()` method as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为不同的端点定义不同的缓存策略。按照以下方式更新`AddOutputCache()`方法：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding code, we added two caching policies. The first `Expire600`
    policy will expire the cached response after 10 minutes, and the second one will
    expire the cached response after 1 hour. Then, we can apply the `OutputCache`
    attribute to the endpoints as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了两种缓存策略。第一个`Expire600`策略将在10分钟后使缓存的响应过期，第二个策略将在1小时后使缓存的响应过期。然后，我们可以将`OutputCache`属性应用到端点上，如下所示：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, the cached response will expire in 10 minutes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，缓存的响应将在10分钟后过期。
- en: What caching strategy should I use?
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该使用哪种缓存策略？
- en: Caching is a useful tool for improving the performance of applications. In this
    section, we introduced a couple of caching techniques, including in-memory caching,
    distributed caching, response caching, and output caching. Each caching technique
    has its suitable scenarios. We need to choose the proper caching technique based
    on the specific scenarios.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是提高应用程序性能的有用工具。在本节中，我们介绍了几种缓存技术，包括内存缓存、分布式缓存、响应缓存和输出缓存。每种缓存技术都有其适用的场景。我们需要根据具体场景选择合适的缓存技术。
- en: Response caching is relatively straightforward to implement; however, it is
    dependent on the client-side HTTP caching configuration. If the client-side HTTP
    caching is disabled, response caching will not work as intended. Output caching
    is more flexible and can be used independently of the client-side HTTP caching
    configuration. It does not need much effort to implement, but it has a few limitations.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 响应缓存相对容易实现；然而，它依赖于客户端的HTTP缓存配置。如果客户端的HTTP缓存被禁用，响应缓存将无法按预期工作。输出缓存更灵活，可以独立于客户端的HTTP缓存配置使用。它不需要太多努力来实现，但有一些限制。
- en: In-memory caching is a fast and easy way to cache data in a single instance
    of the application. However, it needs session affinity to work properly if there
    are multiple instances of the application. Distributed caching supports multiple
    instances, but it needs extra network I/O to access the cache. So, we need to
    consider the trade-off between the performance and the scalability. If retrieving
    the data from the database is complex or needs expensive computation and the data
    is not often changed, we can use distributed caching to reduce the load on the
    database or the computation. Additionally, we can use in-memory caching and distributed
    caching together to leverage the advantages of both caching techniques. For example,
    we can query the data from the in-memory cache first, and if the data is not found,
    we can then query the distributed cache. Also, consider the expiration time of
    the cache entry. You may need various expiration policies for different data.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缓存是在应用程序的单个实例中缓存数据的一种快速且简单的方式。然而，如果有多个应用程序实例，它需要会话亲和性才能正常工作。分布式缓存支持多个实例，但需要额外的网络I/O来访问缓存。因此，我们需要在性能和可扩展性之间权衡。如果从数据库检索数据复杂或需要昂贵的计算，并且数据不经常更改，我们可以使用分布式缓存来减少数据库或计算的负载。此外，我们可以将内存缓存和分布式缓存结合使用，以利用两种缓存技术的优势。例如，我们首先从内存缓存中查询数据，如果找不到数据，然后查询分布式缓存。还要考虑缓存条目的过期时间。你可能需要对不同的数据使用不同的过期策略。
- en: "This section only introduces the basic concepts of caching in ASP.NET Core.\
    \ To learn more about caching, please refer to the documentation at [https://docs.microsoft.com/en-us/aspnet/core/performance/caching/](https://docs.microsoft.com/en-us/aspnet/core/p\uFEFF\
    erformance/caching/)."
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅介绍了ASP.NET Core中缓存的基本概念。要了解更多关于缓存的信息，请参阅[https://docs.microsoft.com/en-us/aspnet/core/performance/caching/](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/)上的文档。
- en: Using HttpClientFactory to manage HttpClient instances
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HttpClientFactory管理HttpClient实例
- en: .NET provides the `HttpClient` class for sending HTTP requests. However, there
    is some confusion when using it. In the past, many developers would misuse the
    `using` statement to create a `HttpClient` instance, as it implements the `IDisposal`
    interface. This is not recommended, as the `HttpClient` class is designed to be
    reused for multiple requests. Creating a new instance for each request can exhaust
    the local socket ports.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了`HttpClient`类来发送HTTP请求。然而，在使用它时可能会有些困惑。在过去，许多开发者会误用`using`语句来创建`HttpClient`实例，因为它实现了`IDisposal`接口。这是不建议的，因为`HttpClient`类旨在用于多个请求的重用。为每个请求创建一个新的实例可能会耗尽本地套接字端口。
- en: To solve this problem, Microsoft introduced the `IHttpClientFactory` interface
    in ASP.NET Core 2.1\. This interface simplifies the management of `HttpClient`
    instances. It allows us to use dependency injection to inject `HttpClient` instances
    into the application without worrying about the life cycle of the `HttpClient`
    instances. In this section, we will introduce how to use the `IHttpClientFactory`
    interface to manage `HttpClient` instances.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Microsoft在ASP.NET Core 2.1中引入了`IHttpClientFactory`接口。此接口简化了`HttpClient`实例的管理。它允许我们使用依赖注入将`HttpClient`实例注入到应用程序中，而无需担心`HttpClient`实例的生命周期。在本节中，我们将介绍如何使用`IHttpClientFactory`接口来管理`HttpClient`实例。
- en: You can find the sample application for this section in the `samples/chapter15/HttpClientDemo`
    folder.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`samples/chapter15/HttpClientDemo`文件夹中找到本节的示例应用程序。
- en: 'To demonstrate how to use the `IHttpClientFactory` interface, we need to have
    a web API application as the backend service. You can use any sample applications
    we have created in the previous chapters. In this section, we will use a fake
    API service: `https://jsonplaceholder.typicode.com/`. This is a free online REST
    API service that can be used for testing and prototyping. It provides a set of
    endpoints, such as `/posts`, `/comments`, `/albums`, `/photos`, `/todos`, and
    `/users`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`IHttpClientFactory`接口，我们需要有一个作为后端服务的Web API应用程序。您可以使用我们在前几章中创建的任何示例应用程序。在本节中，我们将使用一个模拟API服务：`https://jsonplaceholder.typicode.com/`。这是一个免费的在线REST
    API服务，可用于测试和原型设计。它提供了一组端点，例如`/posts`、`/comments`、`/albums`、`/photos`、`/todos`和`/users`。
- en: Tip
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you create C# models from JSON data, you can use the **Paste JSON as Classes**
    feature in Visual Studio. You can find this feature in the **Edit** | **Paste**
    **Special** menu.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从JSON数据创建C#模型时，您可以使用Visual Studio中的**粘贴JSON为类**功能。您可以在**编辑** | **粘贴** **特殊**菜单中找到此功能。
- en: Creating a basic HttpClient instance
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本的HttpClient实例
- en: 'The `IHttpClientFactory` interface provides an `AddHttpClient()` extension
    method to register the `HttpClient` instances. Add the following code in the `Program.cs`
    file:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`IHttpClientFactory`接口提供了一个`AddHttpClient()`扩展方法来注册`HttpClient`实例。在`Program.cs`文件中添加以下代码：'
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we can inject the `IHttpClientFactory` interface into the controller
    and use it to create a `HttpClient` instance:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`IHttpClientFactory`接口注入到控制器中，并使用它来创建`HttpClient`实例：
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding code, we use the `CreateClient()` method to create a `HttpClient`
    instance. Then, we create an `HttpRequestMessage` instance and use the `SendAsync()`
    method to send the HTTP request. The `EnsureSuccessStatusCode()` method is used
    to ensure the response is successful. If the response fails, an exception will
    be thrown. The `ReadAsStringAsync()` method is used to read the response content
    as a string. Finally, we use the `JsonSerializerHelper` class to deserialize the
    JSON string into a list of `Post` objects.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`CreateClient()`方法创建一个`HttpClient`实例。然后，我们创建一个`HttpRequestMessage`实例，并使用`SendAsync()`方法发送HTTP请求。`EnsureSuccessStatusCode()`方法用于确保响应成功。如果响应失败，将抛出异常。`ReadAsStringAsync()`方法用于将响应内容读取为字符串。最后，我们使用`JsonSerializerHelper`类将JSON字符串反序列化为`Post`对象列表。
- en: 'The `JsonSerializerHelper` class is defined as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSerializerHelper`类定义如下：'
- en: '[PRE62]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is because the JSON data returned by the API uses the camel case naming
    convention. We need to use the `JsonNamingPolicy.CamelCase` property to deserialize
    the JSON string into the strongly-typed object. We can pass a `JsonSerializerOptions`
    instance to the `JsonSerializer.Serialize()` and `JsonSerializer.Deserialize()`
    methods to specify the serialization and deserialization options. Using a helper
    method can simplify the code.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 API 返回的 JSON 数据使用的是驼峰命名法。我们需要使用 `JsonNamingPolicy.CamelCase` 属性将 JSON 字符串反序列化为强类型对象。我们可以将
    `JsonSerializerOptions` 实例传递给 `JsonSerializer.Serialize()` 和 `JsonSerializer.Deserialize()`
    方法来指定序列化和反序列化选项。使用辅助方法可以简化代码。
- en: 'The `HttpRequestMessage` class is a low-level class that represents an HTTP
    request message. In most cases, we can use the `GetStringAsync()` method to send
    a `GET` request and get the response content as a string, as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequestMessage` 类是一个表示 HTTP 请求消息的低级类。在大多数情况下，我们可以使用 `GetStringAsync()`
    方法发送 `GET` 请求，并将响应内容作为字符串获取，如下所示：'
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The code to send a `POST` request is similar:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 `POST` 请求的代码类似：
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: To send a `POST` request, we need to serialize the `Post` object to a JSON string
    and then convert the JSON string into a `StringContent` instance. Then, we can
    use the `PostAsync()` method to send the request.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送 `POST` 请求，我们需要将 `Post` 对象序列化为 JSON 字符串，然后将 JSON 字符串转换为 `StringContent` 实例。然后，我们可以使用
    `PostAsync()` 方法发送请求。
- en: 'The `StringContent` class is a concrete implementation of the `HttpContent`
    class. The `HttpContent` class is an abstract class that represents the content
    of an HTTP message. It has the following concrete implementations:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringContent` 类是 `HttpContent` 类的一个具体实现。`HttpContent` 类是一个抽象类，表示 HTTP 消息的内容。它有以下具体实现：'
- en: '`ByteArrayContent`: Represents an `HttpContent` instance based on a byte array'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByteArrayContent`: 表示基于字节数组的 `HttpContent` 实例'
- en: '`FormUrlEncodedContent`: Represents a collection of name/value pairs encoded
    using `application/x-www-form-urlencoded` MIME type'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormUrlEncodedContent`: 表示使用 `application/x-www-form-urlencoded` MIME 类型编码的名称/值对集合'
- en: '`MultipartContent`: Represents a collection of `HttpContent` instances serialized
    using `multipart/*` MIME type'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipartContent`: 表示使用 `multipart/*` MIME 类型序列化的 `HttpContent` 实例集合'
- en: '`StreamContent`: Represents an `HttpContent` instance based on a stream'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamContent`: 表示基于流的 `HttpContent` 实例'
- en: '`StringContent`: Represents an `HttpContent` instance based on a string'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringContent`: 表示基于字符串的 `HttpContent` 实例'
- en: 'The `HttpClient` class has a few methods and extension methods to send HTTP
    requests. The following table shows the commonly used methods:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 类有几个方法和扩展方法来发送 HTTP 请求。以下表格显示了常用的方法：'
- en: '| **Method name** | **Description** |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SendAsync()` | Sends an HTTP request to the specified URI. This method can
    send any HTTP request. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `SendAsync()` | 向指定的 URI 发送 HTTP 请求。此方法可以发送任何 HTTP 请求。|'
- en: '| `GetAsync()` | Sends a `GET` request to the specified URI. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `GetAsync()` | 向指定的 URI 发送 `GET` 请求。|'
- en: '| `GetStringAsync()` | Sends a `GET` request to the specified URI. This method
    returns the response body as a string. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `GetStringAsync()` | 向指定的 URI 发送 `GET` 请求。此方法将响应体作为字符串返回。|'
- en: '| `GetByteArrayAsync()` | Sends a `GET` request to the specified URI. This
    method returns the response body as a byte array. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `GetByteArrayAsync()` | 向指定的 URI 发送 `GET` 请求。此方法将响应体作为字节数组返回。|'
- en: '| `GetStreamAsync()` | Sends a `GET` request to the specified URI. This method
    returns the response body as a stream. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `GetStreamAsync()` | 向指定的 URI 发送 `GET` 请求。此方法将响应体作为流返回。|'
- en: '| `GetFromJsonAsync<T>()` | Sends a `GET` request to the specified URI. This
    method returns the response body as a strongly-typed object. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `GetFromJsonAsync<T>()` | 向指定的 URI 发送 `GET` 请求。此方法将响应体作为强类型对象返回。|'
- en: '| `GetFromJsonAsAsyncEnumerable<T>()` | Sends a `GET` request to the specified
    URI. This method returns the response body as an `IAsyncEnumerable<T>` instance.
    |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `GetFromJsonAsAsyncEnumerable<T>()` | 向指定的 URI 发送 `GET` 请求。此方法将响应体作为 `IAsyncEnumerable<T>`
    实例返回。|'
- en: '| `PostAsync()` | Sends a `POST` request to the specified URI. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `PostAsync()` | 向指定的 URI 发送 `POST` 请求。|'
- en: '| `PostAsJsonAsync()` | Sends a `POST` request to the specified URI. The request
    body is serialized as JSON. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `PostAsJsonAsync()` | 向指定的 URI 发送 `POST` 请求。请求体被序列化为 JSON。|'
- en: '| `PutAsync()` | Sends a `PUT` request to the specified URI. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `PutAsync()` | 向指定的 URI 发送 `PUT` 请求。|'
- en: '| `PutAsJsonAsync()` | Sends a `PUT` request to the specified URI. The request
    body is serialized as JSON. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `PutAsJsonAsync()` | 向指定的 URI 发送 `PUT` 请求。请求体被序列化为 JSON。|'
- en: '| `DeleteAsync()` | Sends a `DELETE` request to the specified URI. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `DeleteAsync()` | 向指定的URI发送`DELETE`请求。|'
- en: '| `DeleteFromJsonAsync<T>()` | Sends a `DELETE` request to the specified URI.
    This method returns the response body as a strongly-typed object. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `DeleteFromJsonAsync<T>()` | 向指定的URI发送`DELETE`请求。此方法将响应体作为强类型对象返回。|'
- en: '| `PatchAsync()` | Sends a `PATCH` request to the specified URI. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `PatchAsync()` | 向指定的URI发送`PATCH`请求。|'
- en: Table 15.3 – The commonly used methods of the HttpClient class
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.3 – HttpClient类常用的方法
- en: 'When we use the `HttpClient` instance created by the `IHttpClientFactory` interface,
    we need to specify the request URL. We can set the base address of the `HttpClient`
    instance when registering the `HttpClient` instance. Update the `AddHttpClient()`
    method in the `Program.cs` file:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用由`IHttpClientFactory`接口创建的`HttpClient`实例时，我们需要指定请求URL。我们可以在注册`HttpClient`实例时设置`HttpClient`实例的基本地址。更新`Program.cs`文件中的`AddHttpClient()`方法：
- en: '[PRE65]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then, we do not need to specify the base address when sending the HTTP request.
    However, what if we need to send requests to multiple endpoints with different
    base addresses? Let us see how to solve this problem in the next section.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在发送HTTP请求时，我们不需要指定基本地址。但是，如果我们需要向具有不同基本地址的多个端点发送请求怎么办？让我们在下一节中看看如何解决这个问题。
- en: Named HttpClient instances
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名的HttpClient实例
- en: 'It is tedious to specify the base address of the `HttpClient` instance or the
    request URI every time. We can specify some common settings when registering the
    `HttpClient` instance. For example, we can specify the base address of the `HttpClient`
    instance as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 每次指定`HttpClient`实例的基本地址或请求URI都是一件繁琐的事情。我们可以在注册`HttpClient`实例时指定一些通用设置。例如，我们可以如下指定`HttpClient`实例的基本地址：
- en: '[PRE66]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the preceding code, we register the `HttpClient` instance with the name
    `JsonPlaceholder` and specify the base address of the `HttpClient` instance. We
    can also set the default request headers, such as the `Accept` and `User-Agent`
    headers. Then, we can use the `JsonPlaceholder` name to inject the `HttpClient`
    instance into the controller:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用名称`JsonPlaceholder`注册了`HttpClient`实例并指定了`HttpClient`实例的基本地址。我们还可以设置默认请求头，例如`Accept`和`User-Agent`头。然后，我们可以使用`JsonPlaceholder`名称将`HttpClient`实例注入到控制器中：
- en: '[PRE67]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is called named `HttpClient` instances, which allows us to register multiple
    `HttpClient` instances with different names. This is useful when we need multiple
    `HttpClient` instances with different configurations. By using the name, we can
    easily access the desired instance.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为命名`HttpClient`实例，它允许我们使用不同的名称注册多个`HttpClient`实例。当我们需要具有不同配置的多个`HttpClient`实例时，这非常有用。通过使用名称，我们可以轻松访问所需的实例。
- en: Typed HttpClient instances
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化的HttpClient实例
- en: 'To better encapsulate the `HttpClient` instances, we can create a typed `HttpClient`
    instance for a specific type. For example, we can create a typed `HttpClient`
    instance for the `User` type:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地封装`HttpClient`实例，我们可以为特定类型创建一个类型化的`HttpClient`实例。例如，我们可以为`User`类型创建一个类型化的`HttpClient`实例：
- en: '[PRE68]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding code, we create a `UserService` class to encapsulate the `HttpClient`
    instance. Register the `UserService` class in the `Program` class:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`UserService`类来封装`HttpClient`实例。在`Program`类中注册`UserService`类：
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, we can inject the `UserService` class into the controller:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`UserService`类注入到控制器中：
- en: '[PRE70]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding code, the controller does not need to know the details of the
    `HttpClient` instance. It only needs to call the methods of the `UserService`
    class. The code is much cleaner.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，控制器不需要知道`HttpClient`实例的详细信息。它只需要调用`UserService`类的方 法。代码更加简洁。
- en: "The `IHttpClientFactory` interface is the recommended way to manage `HttpClient`\
    \ instances. It saves us from the tedious work of managing the lifetime of the\
    \ `HttpClient` instances. It also allows us to configure the `HttpClient` instances\
    \ in a centralized place. For more information, please refer to the documentation\
    \ at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requ\uFEFF\
    ests)."
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: "`IHttpClientFactory`接口是管理`HttpClient`实例的推荐方式。它使我们免于管理`HttpClient`实例生命周期的繁琐工作。它还允许我们在集中位置配置`HttpClient`实例。有关更多信息，请参阅[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requ\uFEFF\
    ests)的文档。"
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed common practices in ASP.NET Core web API development,
    such as HTTP status codes, asynchronous programming, pagination, response types,
    and API documentation. We also explored several caching techniques, including
    in-memory caching, distributed caching, response caching, and output caching.
    Each technique has its own advantages and disadvantages, so it is important to
    consider the trade-offs and choose the appropriate caching strategy for the given
    scenario. Additionally, we discussed the `IHttpClientFactory` interface, which
    simplifies the management of `HttpClient` instances and allows us to use dependency
    injection to inject `HttpClient` instances into the application without worrying
    about their life cycle.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 ASP.NET Core Web API 开发中的常见实践，例如 HTTP 状态码、异步编程、分页、响应类型和 API 文档。我们还探讨了多种缓存技术，包括内存缓存、分布式缓存、响应缓存和输出缓存。每种技术都有其自身的优缺点，因此考虑权衡并选择适合特定场景的适当缓存策略非常重要。此外，我们还讨论了
    `IHttpClientFactory` 接口，该接口简化了 `HttpClient` 实例的管理，并允许我们使用依赖注入将 `HttpClient` 实例注入到应用程序中，而无需担心其生命周期。
- en: In the next chapter, we will discuss how to handle errors in ASP.NET Core web
    API applications and how to monitor the applications using OpenTelemetry.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何在 ASP.NET Core Web API 应用程序中处理错误，以及如何使用 OpenTelemetry 监控应用程序。
