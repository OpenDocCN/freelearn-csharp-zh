- en: Chapter 6. Building a Chat Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be moving back into Xamarin native. Our user interface
    will move away from an MVVM design and follow a new paradigm called **Model-View-Presenter**
    (**MVP**). We will also step further into the backend and setup a SignalR hub
    and client to simulate a chat service, which data will be sent between the server
    and clients instantly as the messages become available. Another key topic of focus
    is project architecture, spending time on separating the project into modules,
    and creating a nicely tiered structure that will maximize code sharing across
    different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following knowledge is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: Some understanding of Xamarin native (iOS and Android)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some understanding of the OWIN specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some understanding of OAuth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Presenter (MVP) pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with Open Web Interface for .NET (OWIN)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an authorization server using OWIN OAuth 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OAuthAuthorizationServerProvider`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization server providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseOAuthBearerAuthentication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Authentication Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the AccountController
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring OAuth Authentication with our Web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the SignalR Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up mobile projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `SignalRClient`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Web API access layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the navigation service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the iOS navigation service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Android navigation service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the iOS interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Hub proxy callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `LoginPresenter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the connection between Presenter and View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `LoginActivity`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `ClientsListPresenter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `ClientListViewController`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TaskCompletionSource` framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `ClientsListActivity`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the Activity `OnBackPressed()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `ListAdapter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `ChatPresenter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the iOS `ChatView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the `UIColor` framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android `TableLayouts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Android `ChatActivity`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the server and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model-View-Presenter (MVP) pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all our previous chapters we have focused our development patterns around
    the **Model-View-View-Model** (**MVVM**) approach. This time we are going to be
    setting up our project around the MVP design pattern. In MVP the presenter centralizes
    the user interface functionality between the model and the view, meaning all presentation
    logic is pushed to the presenter.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Model-View-Presenter (MVP) pattern](img/B05293_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So why bother with this approach?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The advantage with this approach is we can apply unit testing to our presenters,
    meaning all UI logic is tested via the presenter. We also have the ability to
    keep our user interfaces in native, and share a great amount of the UI logic between
    the different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to cross-platform applications, our goal is to share as much
    code as possible. We focus our attention on architecture, having a nice clean
    project structure that lends itself to a maximization of code sharing across platforms.
    So how do we solve this problem? Ask yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the different layers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we set up the folder structure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What parts go in which projects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many different approaches to this problem; here are some of the most
    common architectural layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data layer**: This stores the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data access layer**: This layer focuses on the objects and wrappers that
    apply operations on the data layer (Read, Write, Update)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business layer (logic)**: This layer focuses on the different domains (domain-driven
    design), separating the different areas of logic into objects that handle operations
    for each domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service access layer**: The area that focuses operations on the web API,
    how we handle JSON, and data sent and received between the API Controllers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application/platform layer**: Code which is not shared, specific to the native
    platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common layer**: A shared project, code which is shared to all native projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interface layer**: The layer which contains all the UI design (XAML
    sheets, UIViewControllers, AXML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we determine which layers our project needs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example it is quite simple; we don't have a database so we don't need
    the data layer or data access layer. Everything else we will require, so let's
    begin building our project from the ground up, starting with the lower layers
    first.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start building the project from the service access layer; it
    will include everything involved with SignalR, so our first step is to build the
    backend SignalR hub.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SignalR is a library that provides real-time web functionality to applications
    using WebSocket transport (if HTML 5 is supported; older transport methods will
    be used if it is not supported). It has the ability for a server to push data
    to its clients in real-time as it becomes available; this means we do not have
    to repeatedly ask the server for data (such as refreshing/recalling the Web API).
  prefs: []
  type: TYPE_NORMAL
- en: In order to set up SignalR, we must first set up a SignalR **Hub** on the server
    side; our clients (mobile projects) will use access this **Hub** by creating a
    **HubConnection **and creating a **HubProxy** from which the server and client
    can call functions on either side.
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's get into development; we will have the same hardware set up as the
    last chapter. We will set up a locally hosted backend via Visual Studio and build
    our mobile projects via Xamarin Studio on MacOSX. Open up Visual Studio, create
    a `newASP.NET` web application, and call it `Chat`.
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we must select a template; select the **Empty** template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Great! We now have our empty project, let's start by adding the NuGet package, **Microsoft.AspNet.SignalR**.
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A readme file will appear with some basic directions on setting up the SignalR
    **Hub**. We also want to add Web API 2.2 features for OWIN as we will be adding
    a small Web API to the project to handle login, register, and account functionality.
    Let''s add in the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will install Web API functionality so we can create API controllers and
    map routes through the `Startup` class. We then want to add the Web API 2.2 OWIN
    library to integrate the OWIN pipeline to our HTTP configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also want to add the `OWIN.Security` libraries for handling account authorization
    using **Bearer tokens**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bearer tokens are used in HTTP request headers for authorizing access to OAuth
    2.0 protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we have to add another package called `Microsoft.AspNet.Identity.Framework`.
    This library will be used to handle storage of user accounts (usernames and passwords)
    using the `UserManager` framework.
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B05293_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have all our packages added, let's start building the web application
    from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Open Web Interface for .NET (OWIN)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OWIN** is a standard interface between .NET servers and web applications.
    It provides a middleware for decoupling a web server from a web application. The
    biggest advantage of OWIN is that we are able to host the web application anywhere,
    and keep the server and application completely separated.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on OWIN, the best place to start is with the Katana Project.
    Katana is a collection of projects that support OWIN with various Microsoft components.
  prefs: []
  type: TYPE_NORMAL
- en: So what does OWIN have to do with our project?
  prefs: []
  type: TYPE_NORMAL
- en: If you notice the code above we see all references to OWIN namespaces, and we
    register in the assembly the `OwinStartup` object to our `Startup` class. We must
    have at least one `Startup` class registered in the `OwinStartup` attribute. The
    `Startup` class has one function called `Configuration`. All `Startup` classes
    must include this function, and it must accept `IAppBuilder`. Additional services,
    such as `IHostingEnvironment` and `ILoggerFactory` may also be specified, in which
    case these services will be injected by the server if they are available. The
    `Configuration` specifies how the application will respond to individual HTTP
    requests. Finally, in our `Configuration` method, we will be calling the `MapSignalR` (an
    extension to the `IAppBuilder` object). This will define the route for clients
    to use to connect to your **Hub/s**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The route is set to the app builder pipeline at the URL `/signalr` by default:
    we can also customize this URL if required.'
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to bring in some security.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an authorization server using OWIN OAuth 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OAuth 2.0 framework enables a server to provide clients with limited access
    for HTTP services. Protected server resources can only be accessed via access
    tokens that expire after certain periods of time. Clients will shoot a HTTP request
    at a domain endpoint URL (normally `/token`), the server will send a response
    with token details (such as expiration, access token, time/date issued), and the
    access token will be used for a period of time with other HTTP request headers
    to authorize access to protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Access tokens are strings denoting specified scope, lifetime, and other access
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: So where do we begin to set up server authorization?
  prefs: []
  type: TYPE_NORMAL
- en: Our first step is to build the logic behind granting clients access from username
    and password credentials.
  prefs: []
  type: TYPE_NORMAL
- en: OAuthAuthorizationServerProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `OAuthAuthorizationServerProvider` determines how we validate user credentials
    using `OAuthGrantResourceOwnerCredentialsContext`. Its job is to simply handle
    the authentication of users. This item provides the context in which we handle
    resource grants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new folder called `Providers`, and add a new file in this folder
    called `AuthorizationServerProvider.cs`. Implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our implementation of the `OAuthAuthorizationServerProvider` will override the
    `ValidateClientAuthentication` function, which simply returns whether the `usercontext`
    has been validated. We then override the `GrantResourceOwnerCredentials()` function,
    which is called when a request to the token endpoint (`/token`) arrives with a
    `grant_type` of `password` (this key is set in the request header along with the
    username and password). The function will simply initialize a new `AuthenticationRepository`
    to access the `UserManager` framework and check if the user exists; if it doesn't
    we return, and the context will still be invalid. If the user exists, we create
    a new `ClaimsIdentity` object with two claims, one for the *role* and *username* principles
    of there source owner (the user who sent the HTTP request). Finally, we then place
    the `ClaimsIdentity` object into the `context.Validated()` function in order to
    issue the access token. This `ClaimsIdentity` object is now the ticket that contains
    the claims about the resource owner (the user) associated with the access token.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `ClaimsIdentity` is an object that is a collection of `Claim` objects to represent
    an entity's identity. Each `Claim` object is simply a statement describing an
    identity's role, permission, or an other quality of an entity.
  prefs: []
  type: TYPE_NORMAL
- en: Use OAuthBearerAuthentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next step is to add the logic behind handling bearer tokens (these are
    the access tokens granted by the authorization server provider). `UseOAuthBearerAuthentication`
    has the job of ensuring that only authenticated users can access your protected
    server resources (in our example the `ChatHub`). Add a new file called `OAuthBearerTokenAuthenticationProvider.cs` and
    implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at this item more closely. We are overriding the `RequestToken()`
    function to access the `OAuthRequestTokenContext` from every HTTP request that
    hits the server. Inside the `OwinContext` object, we can access the HTTP request
    that just hit the server, check through the dictionary of headers for our `BearerToken`,
    and then extract this access token and assign it to the `OAuthRequestTokenContext.Token`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the AuthenticationRepository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we move on to the `AuthenticationRepository`. This is the object that will
    handle access and storage using the `UserManager` framework provided by the `Identity.EntityFramework`
    library. Add in a new folder called `Repositories`, then add a new file called
    `AuthenticationRepository.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UserManager` class is a facade for providing identity management in any
    ASP.Net application
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our main concern here involves two functions, one for registering users if they
    don't exist, and one for finding users. The authorization server provider uses
    `FindUser` to determine whether a user exists to confirm authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add another file called `AuthenticationContext.cs` and implement
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple class which inherits the `IdentityDBContext` of type
    `IdentityUser`. This object is the access layer for retrieving data objects (`IdentityUser `objects)
    via the `EntityFramework`. The following diagram shows the layers of logic between
    your ASP.Net application and `EntityFramework`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the AuthenticationRepository](img/B05293_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fantastic! Hopefully those topic weren't too confusing. Now let's start building
    the Web API.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Web API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next step is to configure the Web API. Let's add in a new folder called
    `App_Start`. Inside this folder add a new file called `WebApiConfig.cs` and implement
    the following:,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Look more closely at the `routeTemplate`; notice the `{action}` addition? This
    means we have to include the `ActionName` attribute with each function in our
    `AccountController`. The `ActionName` attribute represents the URL extension,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now let's add another file called `Startup.cs` and implement the following:,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now let's move on to building the `AccountController` to handle incoming HTTP
    requests for user login and registration.
  prefs: []
  type: TYPE_NORMAL
- en: Building the AccountController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have configured the Web API, let''s build the first API controller.
    Add in a new folder called `Models`. Inside this folder, add a new file called
    `UserModel.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The object will contain the username and password fields passed in through
    the HTTP request from the client. The `Register` attribute is used to make sure
    that this property is included with the HTTP request. We can then map this attribute
    to the API controller `ModelState.IsValid` check, so if any of the properties
    with this attribute are missing, the `IsValid` property will be `false`. Next,
    let''s add in another folder called `Controllers`. Inside this folder add in a
    new file, `AccountController.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our first step is the `Register` function, which is responsible for storing
    a new user into the `UserManager` through the `AccountRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the if statement on `ModalState.IsValid`?
  prefs: []
  type: TYPE_NORMAL
- en: If either the `Username` or `Password` properties are missing from the HTTP
    request, it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the `Login` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as `Register` but we are using the `FindUser` function
    to check if the user exists in the `UserManager`. Finally, to avoid any memory
    leakage, we need to make sure that the `AuthenticationRepostiory` is disposed
    when the API controller is disposed. Let''s override the `Dispose` function like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Great! That's everything for the `AccountController`, now we must integrate
    the OAuth authentication and Web API together.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OAuth Authentication with our Web API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to integrate our OAuth module with the Web API we must add some extra
    configuration in `Startup.cs`. Add in a new function called `ConfigureOAuth` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Looking more closely, we start with instantiating a new `OAuthAuthorizationServerOptions`
    object, we set the endpoint URL, expiration period for an access token, and the
    provider is set to our `AuthorizationServerProvider` class created in the preceding
    example. We then add this object into the `IAppBuilder` object using the function
    `UseOAuthAuthorizationServer`. Finally, we create a new `OAuthBearerAuthenticationOptions`
    object where the provider is set to our `OAuthBearerTokenAuthenticationProvider`
    object created in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for now; we now have OAuth authentication integrated with our Web
    API. Now let's implement the final part of our server application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the SignalR Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ChatHub` will be responsible for routing messages between clients using
    a `ConnectionId`. Let''s add in a new file called `ChatHub` and start with overriding
    the `OnConnected` and `OnDisconnected` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`HashSetUsers` is static because we are going to use this later on in our `AccountController`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the Authorize attribute?
  prefs: []
  type: TYPE_NORMAL
- en: This is how we created a protected server resource; only clients with granted
    access tokens can connect to the `ChatHub`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's turn our attention to the `OnConnected` function. When a client connects
    to the `ChatHub`, the username is retrieved from the `HubCallerContext` property,
    which is actually a `ClaimsIdentity` object. When we login through the `AccountController`,
    inside the `AuthorizationServerProvider` we store the identity object inside the
    context when the function `GrantResourceOwnerCredentials` is called. We also store
    a `Claim` object of type `username` inside the identity, which we can now retrieve
    from the user's identity in the `HubCallerContext`. This is how we integrate OAuth
    with SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the username, we are going to try and retrieve a `SigRUser`
    object from the `ConcurrentDictionary`; if the username doesn''t exist we create
    a new `SignRUser` and add it to the `HashSet`. We then lock the `ConnectionIdsConcurrentDictionary`
    making it thread safe as multiple threads (different user connections) can make
    changes on this property. Inside the lock statement we add the new `ConnectionId`
    and notify all other usernames connected to the `ChatHub` using the function `NotifyOtherConnectedUsers`.
    Let''s now add this function to the `ChatHub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function will call `displayMessage`, sending a serialized JSON object of
    the `ConcurrentDictionary Users` to all other connected clients (we will see why
    later).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's turn our attention to the `OnDisconnected` function. This function
    will simply check there is a `SigRUser` with the username equal to the one retrieved
    from the `HubCallerContext` object. If this user exists, we try and remove it
    from the `ConcurrentDictionary` and call the `NotifyOtherConnectedUsers` again
    sending the updated dictionary of clients to the remaining connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We call this function every time a user connects or disconnects to the hub,
    so in our mobile application we can update a list of connected clients in real
    time without refreshing the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can handle an updated list of connected clients, our last step
    is to add the function which will send a message between two clients. The `Send`
    function will be called through the client''s hub proxy with two parameters (message
    and username):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's all for our backend. We have now created our first addition to the server's
    service access layer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The server service access layer will sit in a different service access layer
    to the mobile projects. With server and client code, each side of the system will
    have its own architecture and layers.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move onto the client side and start building our mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up mobile projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we move back to the mobile side; in our mobile projects we are going to
    be setting up SignalR clients on both Android and iOS natively. We will also be
    creating a presenter layer to share the UI logic between both native platforms.
    Open up Xamarin Studio and create a new shared project called `Chat.Common`; inside
    this project add two empty folders called `Model` and `Presenter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then want to create a **single view iOS application**, a **general Android
    application** and a shared project called `Chat.ServiceAccess`. Our project structure
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up mobile projects](img/B05293_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the SignalRClient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start implementing a new class called `SignalRClient`. This
    will sit in the service access layer, the shared project called `Chat.ServiceAccess`.
    Create a new file called `SignalRClient.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look more closely. We have two `readonly` properties in which we only
    initialize once when the object is created, the hub connection which is set to
    the server URL, and the `HubProxy` which is created off the connection to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add two functions for connecting and disconnecting to the `ChatHub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Connect` function requires an access token which we add to the `Headers` dictionary
    of the `HubConnection` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The access token is used as a Bearer token to authorize access to the `ChatHub`.
  prefs: []
  type: TYPE_NORMAL
- en: The function `On` called from the proxy takes in two parameters, the name of
    the function on the server we are listening for, and the action that will be performed
    every time this function is called on the Hub's connected clients. In this example,
    our proxy will fire this action whenever two strings are received from the server.
    The first string is an ID for the data passed in the second string (this could
    be a JSON list of connected clients or it could be a simple chat message). This
    data will then be passed a `Tuple<string, string>` object to the `EventHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can call `On` for multiple functions, and fire different actions for as many
    different functions being called on the `Hub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Disconnect` function simply closes the connection and disposes the `HubConnection`
    object. Finally, we add another function for invoking the `Send` function via
    the `ChatHub` object on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When we invoke server functions, we use an array of objects, in order to match
    the parameters required on the server function.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `SignalRClient` will sit in a shared project, the same code will be
    used for each different platform, but the libraries referenced from the `using`
    statements will come from each platform project. Now let's have both the iOS and
    Android projects reference this shared project. We also want to add the `Microsoft.AspNet.SignalR.Client`
    NuGet package for all the platform projects (iOS and Android).
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the SignalRClient](img/B05293_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are trying to add the NuGet package for SignalR version 2.2.0 with Xamarin.iOS
    1.0, the package will fail to add. If so, visit the following link and add the
    correct `.dll` files from the `lib` folder to each platform project''s references:
    [https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr](https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the SignalRClient](img/B05293_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add the references correctly, right-click the folder **References** for each
    project, click the **.Net assembly** tab, and click the **B****rowse** button
    to add the `.dll` files (`Microsoft.AspNet.SignalR.Client`, `System.Net.Http.Extensions`,
    and `System.Net.Http.Primitives`).
  prefs: []
  type: TYPE_NORMAL
- en: For each platform project, we also need to add the `Json.Net` package from NuGet,
    then right-click on the **References****,** click the **All** tab, and select **System.Net**
    and **System.Net.Http**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the SignalRClient](img/B05293_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have **SignalR** configured, let's move on to building the `WebApiAccess`
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Building the WebApiAccess layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `WebApiAccess` object will be mapped to the `AccountController` on the
    server. Let''s add in a new file called `WebApiAccess.cs`, and implement the `LoginAsync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `_baseAddress` property will be the same as the `SignalRHubConnection` address;
    this is our server link. In our `LoginAsync` function, we start with creating
    a new `HttpRequestMessage` set as a `HttpMethod.Post`. We also set the content
    to a new `StringContent` object, which takes the username and password. This message
    is used in a new `HttpClient` to send to the server, and the response received
    is read as a string and parsed in to a new `bool` object to determine the success
    of the login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and implement the rest of the access layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Register` function is very much the same, but we only check that the response
    status code is a `200(OK)` response; if so, then we have registered successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetTokenAsync` function is responsible for retrieving the access token
    from the OAuth endpoint (`/token`). The JSON response will be of the type `TokenContract`;
    let''s go ahead and add this object into the `Chat.ServiceAccess` project. Create
    a new folder called `Contracts` inside the `Web` folder, add in a new file called
    `TokenContract.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `JsonProperty` attribute?
  prefs: []
  type: TYPE_NORMAL
- en: We can map properties from the JSON objects into other named variables for the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the final Web API function, `GetAllConnectedUsersAsync`. This function
    will be called when a user logs in for the first time. We need to have both an
    API call and a real-time update with the **SignalRClient** to keep track of the
    current connected clients because when a new user logs in, the server will call
    `displayMessage` on all other clients. Even if we were to call `displayMessage` on
    `Clients.All` (this is a reference to all the connected clients on any **SignalR
    Hub**), the newly connected client won't appear in the Clients list as there is
    a minor delay with the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This minor delay is something we cannot control; only sometimes would the newly
    connected client receives the updated list through the `HubProxy` event. So, to
    make things more reliable, we add this update through the API access layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the final Web API function for `GetAllConnectedUsersAsync`. This
    function will deserialized an IEnumerable of strings which represents the list
    of connected clients from the **ChatHub**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Great! We now have our Web API access layer. Our next step is to start building
    the application state and navigation service required for each presenter.
  prefs: []
  type: TYPE_NORMAL
- en: Application state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In MVP, every presenter must include the current application state. When we
    cross between different screens, the persistent state of application data is kept
    alive throughout the entire life of the application (this includes search results,
    downloaded JSON objects, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some most MVP applications, the application state will include a service
    for saving and loading this persistent data between different sessions. For an
    extra learning activity, try implementing a new service called `IApplicationStateService`.
    This will be responsible for saving and loading the `ApplicationState` object
    locally to your device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent! Now let''s add another file called `ApplicationState.cs`, and implement
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Nothing much to it, right?
  prefs: []
  type: TYPE_NORMAL
- en: We only ever want one instance of this object throughout the entire life of
    the application, so we will build upon the persistent data to be kept alive between
    each screen.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the navigation service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a navigation service in MVP is very different from our `Xamarin.Forms`
    navigation service. Our navigation service will not be used in an IoC container
    this time; instead, we will be instantiating one of these objects at the start
    of our application in the `AppDelegate` and `MainActivity` classes. Since we are
    working in native, we will also be implementing a separate navigation service
    for each platform that will share the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with creating the shared interface. Add a new file to the `Chat.Common`
    folder ****Presenter**** | **Services**, call it `INavigationService.cs`, and
    implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Building the iOS navigation service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the iOS navigation service. Add in a new folder called `Services`
    to the `Chat.iOS` project, create a new file called `NavigationService.cs`, and
    implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we instantiate this object we always want to pass in the `UINavigationController`
    that is assigned to our `RootViewController` of the `UIWindow` object created
    in our `AppDelegate`. We also have to implement the `Push` function, which takes
    a `BasePresenter` object (any presenter), and we perform a type check to determine
    which presenter is being passed, and pushing the related `UIViewController`, onto
    the navigation stack. We must always pass the presenter to the new `UIViewController`,
    so we can register the new view to the current presenter.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Android navigation service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move onto the Android navigation service, we have to add an extra
    class to hold persistent state on the current activity, current presenter, and
    current context. Add in a new file called `Application.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This class will extend off the Android application, so when we reference the
    Android application class in other parts of our application, we have reference
    to the extra persistent objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the Android navigation service. Add in a new folder to
    the Android project called `Services`, add a new file called `NavigationService.cs`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we pass in the `Application` object and keep this stored
    as a private variable inside the navigation service. The `Push` function requires
    the `Application` everytime we push a new `Activity` onto the stack, because we
    require the current activity reference to start the new intent from the current
    activity held inside the `Application` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our navigation service and application state, let's start building
    our user interface for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Building the iOS interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we don't really know how the user interface is going to look for each
    screen, we can't define the logic in our presenters. So let's loosely talk about
    how the user interface is going to look.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should normally have screen mock-ups at this point before we move to the
    UI layer of a project.
  prefs: []
  type: TYPE_NORMAL
- en: We have three screens in our application, one of which is going to be list which
    displays all the connected clients live on the **ChatHub** on our server. A user
    will be able to select this user from the list; when a user selects another client
    from the list, this client should receive a message asking for permission to start
    a chat conversation. When a user accepts, this will move to another screen which
    will show a typical chat conversation, much the same as with any other SMS application
    (speech bubbles on either side). The following diagram is a quick mock-up of the
    three screens and workflow. All we see is the first screen showing a login screen,
    then another showing a list with the connected clients, and the last screen showing
    a conversation between two connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the iOS interface](img/B05293_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Excellent! Now that we have an idea as to how our screens are going to look,
    let's talk about the logic behind the first screen that we can share. We have
    a screen with two entry boxes for a username and password. The screen will be
    able to perform logins and registrations on our Web API, so we will require a
    button for each. If we are successful with login, this will push the list page
    on to the navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a cross-platform approach; what can we share here?
  prefs: []
  type: TYPE_NORMAL
- en: Web API layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventHandlers** to handle the click events for a login and register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation service to handle push/pop onto our navigation stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a rough idea of the logic behind our first screen; let''s build our
    first **Presenter**. Create two new files called `BasePresenter.cs` and `IView.cs`.
    We will start with the `IView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We want all screens to have an `IsInProgress` variable, if any screen is loading
    or processing, we can display loading activity to the user. The `SetMessage` function
    is used to display any errors to the user through an alert dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `BasePresenter`, this is an abstract class which will be used for
    all presenters. All presenters require the `ApplicationState`, `INavigationService`,
    and the `SignalRClient`. Throughout our entire application, each screen requires
    events from the `SignalRClient` to function, so we can bring it into the `BasePresenter`
    object. We have created two `EventHandlers`; these are fired based upon the data
    received via the **hub proxy** on the `SignalRClient`. If we receive a list of
    **Clients**, we will fire the `ConnectedClientsUpdated` event. If we receive a
    `string`, we will fire the `ChatReceived` event, so we can actually control all
    `SignalR` data via the `BasePresenter` class, and channel specific data types
    to specific events for our views to register. We also have the `WebApiAccess`
    object for accessing the Web API and a string for holding the access token when
    we login successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Handling Hub proxy callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s turn our attention to the `SignalRClient`; we created an `EventHandler`, which
    fires every time data is received from the **Hub**. The `BasePresenter` will be
    responsible for handling the data received from this `EventHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The private dictionary `_signalREvents` is used instead of a switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: With each `Tuple` received from the SignalRClient's `OnDataReceived` event,
    the first string will be the key matching the indexed `Action<string>` in the
    dictionary. The other string of the `Tuple` is the data string (either a serialized
    JSON of `HashSet<string>`, or a string which represents a chat message), which
    is passed as the input parameter for our `Action<string>`, then, out of this input
    parameter, we will create the correct arguments used for the specified event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could take things a step further and abstract a `view` object into the `BasePresenter`,
    as every presenter requires a `view`, but because each view logic is independent,
    it is very hard to centralize this logic in one area. The need for this will come
    if multiple views have similar behaviors. Then we can look at abstracting these
    areas into the `BasePresenter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait! You may have noticed that we have two types of arguments being passed
    into each `EventHandler`. Add a new file to the `Events` folder in the `Chat.Common`
    project called `ConnectedClientsUpdatedEventArgs.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need another file called `ChatEventArgs.cs`. Add this to the `Events`
    folder and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This object is the wrapper for every message received for a chat message. Now
    we have everything ready to implement our first presenter object.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the LoginPresenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file called `LoginPresenter.cs`, add it to the `Presenter` folder
    in the `Chat.Common` project, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `LoginPresenter` contains a new `ILoginView` interface with two new event
    handlers for the two buttons that will appear on the login screen. We also include
    a new `WebApiAccess` object as we will need to perform logins and registrations
    on the Web API. We also need another function called `SetView`, this will take
    the user interface object and register any `EventHandlers` specified by the `ILoginView`
    interface. Let''s now add the function for handling logins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `HandleLogin` function will check first if the screen is currently progressing
    from another login; we want to make sure that only one login or registration can
    occur at any one time. Firstly, we call the `LoginAsync` and check that the user
    exists in the `UserManager`, then we call the `GetTokenAsync` function to retrieve
    the access token which will be used in our `HubConnection`. If both are successful,
    we push on the `ClientsListViewController` using the `NavigationService`. If either
    fails, we use the `SetErrorMessage` function for displaying an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We control the navigation stack by the presenter type passed into the `PushPresenter`/
    `PopPresenter` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the function for handling registrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Very much the same as the `LoginAsync`, but we call the `RegisterAsync` and
    simply wait for the call to finish and check we have the HTTP status code of `200
    (OK)`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the connection between Presenter and View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we move on to the user interface design and demonstrate how we set up the
    link between our presenters. Developing the user interface is no different to
    developing natively for iOS and Android; the only difference with MVP is that
    we initialize a view with its related presenter in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a new folder to the `Chat.iOS` project called `Views`,
    add in a new file called `LoginViewController.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We start off simply with the private properties and the constructor, where we
    are passing a new `LoginPresenter` object that we create from the `AppDelegate`
    as the starting presenter. The two text fields are used for the username and password
    entries. We have these as a local variable as we will need to access one instance
    of each from multiple functions. We also have a `UIActivityIndicatorView` for
    displaying the progress when we login and register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add the `ViewDidLoad` function. We will implement this
    in a few parts. First we are going to set the view of the presenter and initialize
    all the UI elements and add them into the `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is a large block of code, but we are creating quite a few UI elements.
    All have the `TranslatesAutoresizingMaskIntoConstraints` set to `false` ready
    for `**NSLayout**` . Have a look at how we integrate the `ILoginView` implementation
    with the Login and `RegisterEventHandlers` as they are wired to the `TouchUpInside`
    event of each button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s start building the `NSLayoutConstraints`. Add the following to the
    bottom of the `ViewDidLoad` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using the `DictionaryViews` object that we used in previous chapters.
    Create a new folder called `Extras` and add this object into the `Extras` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The constraints will position the `buttonView` to the center of the screen horizontally;
    each buttons inside will be positioned horizontally next to each other. The rest
    of the layout is very self-explanatory. We are simply stacking the remaining element
    vertically down the page. The `UIActivityIndicatorView` will be positioned to
    the top right of the screen next to the `TitleLabel`. The rest of the layout will
    make more sense when we try running the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the remaining interface implementations; we require both Login
    and `Register` for the `ILoginView` interface. We also require `IsInProgress`
    bool and the `SetErrorMessage` function; this will create a new `UIAlertView`
    showing the error message. We also override the get and set of `IsInProgress`
    to control the start and stop animation of the `UIActivityIndicatorView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The link between our first view and presenter is not as clean as an MVVM **BindingContext**
    with `Xamarin.Forms`, but the advantage is having no middle layer of rendering
    between the native user interface and the data to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Building the LoginActivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move back into the `Chat.Droid` project; before we create our `Activity`
    we need to create the layout using a new XML sheet. Add a new file called `LoginView.xml`
    into the **Resources** | **l**ayout**** and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `XMLlayout` will stack the page vertically, with the two buttons placed
    side-by-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick way of checking your layouts in `Xamarin.Studio` is to click the **Designer**
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the LoginActivity](img/B05293_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s create a new folder called `Views`, add in a new file called `LoginActivity.cs`,
    and implement the first section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have the UI logic in our presenter, building the interface
    for `LoginActivity` is much easier as the answers all lie in the presenter. This
    is the advantage of code-sharing using the MVP pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In our `OnCreate()` function, we will start with setting the `ContentView` to
    the `XMLlayout` we created previously. We will then register the button `Touch`
    events to the `ILoginView`interface, very much like the iOS version with the `TouchUpInside`
    events. We then retrieve the application from the `GetApplication` function**.**
    We also create an instance of the `ApplicationState`, and create a new `LoginPresenter`.
  prefs: []
  type: TYPE_NORMAL
- en: We must also add the requirements of the `ILoginView` and `IView` interfaces.
    The `SetErrorMessage` will use the `AlertDialog.Builder` framework to create the
    same popup as the iOS version. We only set one button for this dialog which will
    simply close the dialog when we press ****OK**:**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: See how the structure is the exact same as iOS?
  prefs: []
  type: TYPE_NORMAL
- en: 'We just have to match the UI elements for each platform independently. Our
    final part to the activity is the `OnResume` function. This function will reset
    the `CurrentActivity` in the `Application`:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important that every time an activity is resumed we reset the `CurrentActivity`,
    otherwise the navigation service will not push/pop on the correct `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Now we have created the first screen, presenter, and linked it up
    with the navigation service. Let's hop back into the `Chat.iOS` project and build
    the next screen of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ClientsListPresenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file called `ClientsListPresenter.cs`, add it to the `Presenter`
    folder in the `Chat.Common` project, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We have declared a new **IClientsListView** interface specific to the current
    **UIViewController** (this must be done for every screen). It simply extends off
    the **IView** interface, and we add an extra event handler for selected items
    in our **UITableView**. We then have our constructor which we must pass in an
    **ApplicationState**,**NavigationService,** and an access token. We also initialize
    the **SignalRClient**: the `ConfigureAwait` function is set to false because we
    don''t want to wait for this task to finish.'
  prefs: []
  type: TYPE_NORMAL
- en: We now need to add another function called `SetView`.This will take the action
    user interface object and register any `EventHandlers` specified by the **IClientsListView**
    interface. We also make another call to the Web API to retrieve the current clients
    connected to the **ChatHub**. We also specify that we don't want to wait on this
    task via the `ConfigureAwait`function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each `SetView` that will be responding to real-time data updates from the
    **SignalRClient**, we have to reregister to the OnDataReceived`EventHandler` so
    the correct presenter function `HandleSignalRDataReceived` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A presenter can also have the opposite to the `SetView` function called `ReleaseView`.
    It will be responsible for disposing EventHandlers when screens disappear. This
    ensures we don''t have events on any previous pages doing work when they are not
    visible. Add the following under the `SetView` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the `Signout` function.This will be called when a user wants
    to disconnect from the **ChatHub** (when the user leaves the **ClientsListViewController**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add two more functions: `HandleClientSelected` will use the **INavigationService**
    to push the next screen on to the stack, and the other function, `HandleConnectedClientsUpdated` will
    call the native implementation in the user interface object. We will also filter
    the list of clients using Linq to include all other clients but the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Since we know that we require a **UITableView **on the **ClientsListView **screen,
    we need to create a **TableSource** object that will show all our clients that
    are connected to the **ChatHub**. We also need a model object to hold the data
    to be displayed for each **Client**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, create a new folder in the **Chat.Common** project called **Model**,
    add in a new file called `Client.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For each cell, we are only going to display one text label showing the username
    of the connected client. Now let''s add in a new file called `ClientsTableSource.cs` and
    start with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We require a private `List` for holding the latest clients connected, we have
    our `CellIdentifier` label set as `ClientCell`, and we have an `EventHandler`
    for selected cell events that will occur from the `UITableView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time one of these events are fired from the `TableSource`, we will be
    firing the event handler in our `ClientsListPresenter` presenter. Now let''s implement
    the rest of the overrides required by the `UITableViewSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Our `GetCell` function will use the default `UITableViewCellStyle`, and the
    text will be set to the username of the `Client` object. Our `RowSelected` function
    will fire our custom `EventHandlerItemSelected`. We will register a delegate on
    this `EventHandler` for firing our related presenter `Event`. Finally, our `UpdateClients`
    will be called whenever we receive a proxy event when the client count changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ClientListViewController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will move on to the user interface design and demonstrate how we set
    up the link between our presenters. Developing the user interface is no different
    to developing natively for iOS and Android; the only difference with MVP is that
    we initialize a view with its related presenter in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a new folder to the `Chat.iOS` project called `Views`,
    add in a new file called `ClientsListViewController.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we pass the presenter in the constructor of the `UIViewController`?
  prefs: []
  type: TYPE_NORMAL
- en: We will be doing this with every view that is added to the navigation service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the constructor, we are also registering the `itemSelected` event to
    fire the interface event for our presenter. Let''s add in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` function, we will always be calling the `SetView` on a
    presenter class, and passing the view itself to the presenter. We are also going
    to add another little trick on this screen to override the `navbar` back button.
    We must create a `UIBArButtonItem`, which will be set as the left button of the
    navigation bar. When we instantiate this item, the `HandleSignout` function will
    be called when this button is pressed. Let''s add this to the `UIViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The function will show an alert and wait for a response to be provided by the
    user. In this case, it will be `"Yes"` or `"No"`. We are going to add another
    function `ShowAlert()`, which will use the `TaskCompletionSource` framework to
    allow us to await a response from a `UIAlertView`.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskCompletionSource framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ShowAlert` function will instantiate a new instance of a `TaskCompletionSource`
    of type `bool`. We then invoke the action on the main thread using the `UIApplication.SharedApplication`,
    and then return the `Task` object of the `TaskCompletionSource`. This means we
    can wait for the task to be returned When we create the `UIAlertView`, we set
    the `Clicked` event of the dialog to call the `SetResult`function of the `TaskCompletionSource`,
    so the `Task` will not finish until this click event has occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have overriden the back button, when a user tries to click back
    on the clients list screen to return to the login, the `UIAlertView` will appear,
    asking if the user wants to signout (meaning the user will disconnect from the
    `ChatHub`). If the user presses **Yes**, we will call the `Signout` function on
    the `ClientsListPresenter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get back to the `ViewDidLoad` function and add in the `NSLayoutConstraints`
    to build the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We have all the elements stacked vertically, taking up the entire width of the
    screen with padding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also want to add the `ViewDidUnload` function, so we can remove
    the `OnDataReceived` event on the `SignalRClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Creating the ClientsListActivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move back again to the `Chat.Droid` project. Create a new folder called
    `Views`, add in a new file called `ClientsListView.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For the first section of the `ClientsListActivity`, let's look at the `OnCreate`override.
    We will start with the `ChatApplication` instance and set the current `Activity`
    to the `ClientsListView` activity. We then instantiate a new `ClientsListPresenter`,
    add in the state, and add a new `NavigationService`. We will also set the view
    object of the presenter to the `ClientsListView`. Finally, we simply instantiate
    a new `ClientsListAdapter` and set it to the `ListAdapter` of the `Activity`,
    as we are inheriting a `ListActivity`. We are going to have a different layout
    to iOS and only show the `ListView` on this screen so we can demonstrate the `ListActivity`;
    therefore, we don't need an `XMLsheet` for the layout of this `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnResume` function is the same as the `LoginActivity`; we have to maintain
    the current `Activity`shown to the user. We also want to override the `OnPause`
    function to call `ReleaseView` on the `ClientsListPresenter` so we remove the `EventHandler`
    on the `OnDataReceived` property of the `SignalRClient`. This ensures we don't
    call `HandleSignalRDataReceived` whilst the screen is not visible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the `IClientsListView` and `IView` implementation.The `NotifyConnectedClientsUpdated` will
    call the `UpdateClients` function on the `ListAdapter`, and we must propogate
    the `NotifyDataSetChanged` on the main thread as we are making data changes to
    the `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `SetErrorMessage()` will initiate a dialog similar to iOS, using the `AlertDialog.Builder`
    framework. In this case, we only need to set the original button since we only
    need one button on the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the OnBackPressed activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our iOS implementation we integrated an override to the navigation back
    button, so when a user leaves the `ClientListViewController`, we ask the user
    if they would like to signout from the `ChatHub`. We are going to do the same
    here but on the Android platform. We will be building the alert from the `AlertDialog.Builder`
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We start with instantiating a new builder object which must take the `Activity`
    context as the only parameter. We then set the title and message of the dialog,
    and two buttons for the `"Yes"` and `"No"` selections. Only when the user selects
    `"Yes"` does an action occur by calling the same `Signout` as with iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Our last piece of this `Activity` is to override the `OnListItemClick`. When
    an item in the list is selected, we want to fire the `ClientSelected` event specified
    by the interface, so we can tie this event logic into the `ClientsListPresenter:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Building the ListAdapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we build our `ListAdapter,` we need to create another AXML sheet for
    the **CustomCell**, add another file to the **Resources** | **layout** folder
    called `CustomCell.xml`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is another simple layout which has one `TextView` wrapped in a `LinearLayout`.
    The `TextView` will display the `ConnectionId` for each `Client`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get back to the `ListAdapter`. Inside the `Views` folder, add another
    file called `ClientsListAdapter.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we are just creating a new class which inherits the `BaseAdapter` class
    which is typecasted to the `Client` object. We also have a private `List` which
    is going to store the clients retrieved from the `SignalRClient`, and finally
    we have the current **Activity Context**. Now let's add in the required override
    functions from the `BaseAdapter:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The first override is to implement an index reference to the `_clientslist`.
    All the override functions are the same as we implemented in [Chapter 1](ch01.html
    "Chapter 1.  Building a Gallery Application"), *Building a Gallery Application*.
    Let's turn our attention to the `GetView` function; we are simply creating a new
    `CustomCell` layout using the `LayoutInflater` framework (this will take any AXML
    file and create a new instance of the view).
  prefs: []
  type: TYPE_NORMAL
- en: Then, now that we have our new view, we will set the `Text` property of the `TextView`
    object in the `CustomCell` view to the `Username` in our `Client` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our last step is to add a another function called `UpdateClients` (as
    specified in our presenter). This will simply take a new `IEnumerable` of **Clients**,
    and the `List` will be updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: With complete direction from the presenter class, look how fast we developed
    the android interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can test the connection to the server **Hub**, we have to make changes
    to the application.config and `http.sys` using `netsh` in the command prompt.
    Follow the section *Hosting the Web API project locally* in [Chapter 5](ch05.html
    "Chapter 5. Building a Stocklist Application"), *Building a Stocklist Application*.
  prefs: []
  type: TYPE_NORMAL
- en: You can try testing the first page. Startup the server **Hub** and watch the
    list update whenever we connect or disconnect a new client. A good test on this
    example is to use multiple running instances of the application on different devices.
  prefs: []
  type: TYPE_NORMAL
- en: Building the ChatPresenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we move on to the next screen; this will be our chat window in which we
    will be passing messages between different clients connected to the server **Hub**.
    Our first step is to build the `ChatPresenter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We are going to start by inheriting the `BasePresenter` class. It will include
    two `private` properties, one for the `Client` selected from the previous `ClientListView`
    screen and another for the `IChatView` interface. The `IChatView` interface inherits
    the `IView` interface and it will include one function for handling messages received
    from the receiving `Client`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the same set up as the `ClientsListPresenter`; our `SetView` function
    will take the native view object and register the events. We also have another
    function, `SendChat` which will invoke the `SendChat` function on the **Hub**.
    Don''t forget the `ReleaseView` function; this will be exactly the same as the
    `ClientsListPresenter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have built all our presenter objects, we need to make a small update
    to the navigation service implementations to allow navigation for the other screens.
    Open the Android `NavigationService.cs`, and in the `PushPresenter` function update
    the `if` statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For the iOS `NavigationService.cs`, update the if statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Building the iOS ChatView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new file called `ChatViewController` into the `Views` project of the
    `Chat.iOS` project and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We have multiple `Private` properties, one for the presenter, a local `UITextField`.
    We need this UI object to be local, as we need to extract the `Text` value to
    send through the `SignalRClient`, and we also need the `UIScrollView` to be local
    so we can change the content size and add in `ChatView` objects. The integers
    are use to record the current top (y-axis + height) of the all chat messages which
    will display on the screen. Finally, the remaining `nfloat` is used for recording
    the height and width of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will see all these variables used further on through the class functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the `ViewDidLoad` function to build the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The chat screen will contain a `UITextField`, a `UIButton`, and a `UIScrollView`.
    The button is for notifying the current `Text` value of the `UITextField` to be
    sent to the server **Hub**, and our `UIScrollView` will contain all the messages
    published from each client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to add the `ViewDidUnload()` function, so we can remove the `OnDataReceived`
    event on the `SignalRClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s then add the `IView` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `IView` implementation is the same as with the `ClientsListViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `ChatBoxView.cs` and add it to the `Views`
    folder. We will create a new one of these for every chat message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple object that contains one `UILabel` for the chat message.
    We also set the height and width of this label to the height and width of the
    `UIView` using `NSAutoLayout`. We also round the corners of the `Layer` to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever used the **SMS** application on any iOS device, you will see
    we have two colors, distinguishing between you and the person you are talking
    to. We are going to do the same with our application but instead of using standard
    colors from the `UIColor` interface, we are going to use custom hex colors.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the UIColor framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we are going to apply a common technique for extending on standard
    iOS classes. In the `UIColor` class, there is no function for applying hex strings
    to determine a color, so let''s add this on top. Create a new folder called `Extensions`,
    add in a new file called `UIColorExtensions.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: When we extend a class with extra functions, the first input parameter must
    always start with the `this` keyword; this represents the current object calling
    the function. The next two parameters are a string representing the hex value
    and an alpha percentage (between 0 and 1) for transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we remove the `#` character from the hex string. We then double-check
    if the alpha character is below 0, if so, set the alpha to 0, and vice versa with
    the alpha if it is greater than 1\. Then our switch statement will select a case
    based on the hex string length (either an RGB or RRGGBB value). Then we simply
    extract the red, green, and blue string values and return a new `UIColor` from
    the red, green, and blue values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can apply a hex color string to the `UIColor` framework like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since MonoTouch 5.4, we have to apply the `FromHex` extension to a `Color.Clear`.
    Previously we were able to use a parameterless constructor like this: `new UIColor().FromHex("FFFFFF")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `UIColor` additions, let''s use these for our chatbox
    `BackgroundColor` property. We are going to add in a new function to the `ChatView`,
    which will create a new `ChatBox` and set the color according to whether it was
    sent or received. We will also do the same with the x-axis position and set the
    `ChatBox` to the left if sent and to the right if received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We first update the `ContentSize` property of the `UIScrollView`; this represents
    the dimensions of the scroll area. The `currentTop` variable is used to record
    the last ChatBox's y-axis value so we know the height of the UIScrollView's content,
    and so we know the next y-axis position for the next `ChatBox`. Then we add the
    new `ChatBox` object, pass in the new message, and assign the message to the `Title`
    of the `UILabel`. We also use our new extension function to set the `BackgroundColor`
    property of the `ChatBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, where do we call this function?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two areas, whenever the `Send` button is pressed, or when a message
    is received. Let''s add the `TouchUpInside` callback on the `_sendButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HandleSendButton` will also call the presenter function, `SendChat`, and
    send the message to the server **Hub**. We also need to add the `IChatView` implementation.
    The `NotifyChatMessageReceived` function will also use `CreateChatBox`, but this
    time we will set the `received` flag to `true`. This must also be invoked on the
    main thread as sometimes the event might fire this function on another thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished the iOS `ChatView`, try testing. Connect two iOS clients
    to the **Hub**, select the other client from either client, try entering messages
    into the `UITextField`, press Send, and watch the magic happen.
  prefs: []
  type: TYPE_NORMAL
- en: That's enough of iOS development, let's move back over to Android and complete
    the `ChatView`.
  prefs: []
  type: TYPE_NORMAL
- en: Android TableLayouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move back to the Android implementation. This part is easy, we have already
    mapped the UI logic to the `ChatPresenter` so let's get straight into building
    the interface. For our `ChatView.xml` file, we are going to introduce a `TableLayout`.
    TableLayouts are similar to **Grids** in `Xamarin.Forms`; we simply split an area
    into rows and columns. We are able to set UI objects to specific rows and columns
    as well as span specific UI objects across multiple rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new file called `ChatView.xml` to the **Resources** | **layout**
    folder and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Each row is declared using the `<TableRow>` tag; our first row contains an `EditText`
    item for the messages, and a button to call the `SendChat` function on the `SignalRClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Android ChatActivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move back to the Android implementation. This part is easy, we have
    already mapped the UI logic to the `ChatPresenter`, so let''s get straight into
    building the interface. Add a new file to the `Views` folder in the `Chat.Droid`
    project, call it `ChatActivity.cs`, and implement the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `OnCreate` function, we are setting the content view to the `ChatView`
    layout. We then retrieve the width of the screen as we need to be able position
    the x-axis of the chat box to the left or right of the screen, based on whether
    it was sent/received. We then assign the SendButton''s `Touch` event to call the
    `HandleSendButton` function. Finally, we retrieve the `ChatApplication` object
    and cast the presenter to a `ChatPresenter`, call the `SetView`  function, and
    pass the `ChatActivity`. Then we set the `CurrentActivity` of the `ChatApplication`
    object to the `ChatActivity`. Let''s also add an override on the `OnPause` so
    we can call `ReleaseView` on the `ChatPresenter` to remove the `OnDataReceived`
    event from the `SignalRClient`. This is the equivalent to the `ViewDidUnload` override
    on a `UIViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to add the `IChatView` implementation; `CreateChatBox` must be
    propagated to the main thread as this event will sometimes call this function
    on a different thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to add the `IView` implementation, which we can simply copy from
    the previous activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we add the remaining functions, we are going to add another layout for
    the `ChatBoxView` in Android. Add a new file called `ChatBoxView.xml`, add it
    to the **Resources** | **layout** folder, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple view which contains a `LinearLayout` that contains one
    `TextView` to display the chat message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the remaining `HandleSendButton` and `CreateChatBox` functions;
    they are the same functions as iOS, but use Android objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HandleSendButton` function will do the exact same: call the presenter
    function, `SendChat`, create a new chatbox, and add it to the `ScrollView`. The
    `CreateChatBox` function will use the context''s `LayoutInflator` and create a
    new `ChatBoxView`. We will then set the x, y, width and height properties, retrieve
    the `TextView` property of the view, and set the `Text` property to the message.
    We then call `SetBackgroundColor` on the view and change the background color
    according to whether it has been sent or received. Finally, we add the new view
    to the `ScrollView` and record the current y-axis value.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the server and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can test everything together, please revisit the section in [Chapter
    5](ch05.html "Chapter 5. Building a Stocklist Application"), *Building a Stocklist
    Application*, called **Hosting a Web API project locally**. This must be done
    before we can connect to the server side from our mobile clients. Once we have
    the server application running, build and run the mobile application from either
    platform and register a user first before we login. The `Register` button will
    place the new account in the `UserManager`, allowing us to perform a **Login**
    with those account details as they now exist in the `UserManager`. Once we login,
    we can't do anymore unless we have another mobile client that can run the app
    and login. It is best to test this application with two mobile devices running
    the mobile application. Once both have logged in and the clients list screen has
    been loaded, each user will be connected to the user, and both users can now click
    on each other to navigate to the chat window and begin sending messages to each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: To further understand everything going on, try adding debug breakpoints to server
    functions, and test these server functions by clicking between the different screens
    of the mobile application. This will give a better overview as to what is happening
    between server and client on each screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created an application for iOS and Android using the native
    libraries. We integrated SignalR on the client and server side by building a hub
    and proxy connections via a client. In the next chapter, we will see how to store
    files locally with `Xamarin.Forms` using dependency services. You will learn about shared
    projects and their differences to PCL projects. We will also run through SQLite, setting
    it up with Android, iOS, and WinPhone and share the same code using different platform-specific
    libraries.
  prefs: []
  type: TYPE_NORMAL
