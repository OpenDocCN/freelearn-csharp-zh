<html><head></head><body>
		<div id="_idContainer094">
			<h1 id="_idParaDest-112"><em class="italic"><a id="_idTextAnchor112"/>Chapter 7</em>: Securing ASP.NET Web Applications</h1>
			<p>In the previous chapter, we explored the architecture considerations that should be taken into account when designing and implementing a solution architecture. <em class="italic">Why do we need to learn this?</em> Because creating an innovative and robust software solution requires us to plan for various aspects and consider different attributes for balancing short-term and long-term product goals and priorities. Paying attention to the quality of attributes, logging, and tracing, along with a proper deployment strategy, will help you deliver a good-quality product that is scalable, maintainable, and secure.</p>
			<p>It is exciting for any solution architect to design and build a fancy product; however, this achievement can be ruined if we don't pay attention to the security risks involved. Security is an integral part of any software solution, especially <strong class="bold">ASP.NET</strong> web applications. By nature, these applications are exposed to a large number of users, therefore security isn't a luxury in this case and can no longer be an afterthought—it's a necessity. </p>
			<p>The <strong class="bold">.NET Core</strong> framework provides a set of powerful features and built-in functionalities to secure our applications if we implement and configure them the right way. However, this is not enough, as we still need to apply a set of security measures and write secure code to protect our application from threats and vulnerabilities.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Securing ASP.NET Core applications</li>
				<li>Web <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) security recommendations</li>
				<li>Protecting web apps and APIs hosted on Azure</li>
			</ul>
			<p>By the end of this chapter, we will have explored a set of security measures, tips, and tricks that will help us build secure ASP.NET web applications. Furthermore, we will get to know some security recommendations to protect our RESTful APIs (where <strong class="bold">REST</strong> stands for <strong class="bold">REpresentational State Transfer</strong>), along with some tips to securely host our solution on <strong class="bold">Azure</strong>.</p>
			<p>Most essentially, this chapter provides us with a roadmap to secure our solution. We'll get a deep understanding of how we can incorporate security into our solution architecture, and we'll see what the most important factors are for creating secure software.</p>
			<p>Now, let's dig deeper into each of those security measures.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Introducing key security practices</h1>
			<p>In this section, we will <a id="_idIndexMarker467"/>explore key security measures to be taken into consideration while building our ASP.NET web application. There are some <strong class="bold">C#</strong> code samples in the following sections that we will use to explain various security vulnerabilities we may face. This code syntax was prepared based on <strong class="bold">ASP.NET Core</strong> and <strong class="bold">.NET 5</strong>, but the concept is the same even if you have an ASP.NET Web Forms application.</p>
			<p>The following is a list of the security measures we will learn about in this section:</p>
			<ul>
				<li>Authentication</li>
				<li>Authorization</li>
				<li>Anti-<strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>)</li>
				<li><strong class="bold">Cross-site request forgery</strong> (<strong class="bold">CSRF</strong>)</li>
				<li>Cookie stealing</li>
				<li>Overposting</li>
				<li>Preventing open redirection attacks </li>
				<li>Blocking brute-force attacks</li>
				<li>File-upload protection</li>
				<li>Preventing <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) injection attacks in ADO.NET and <strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>)</li>
				<li>General security recommendations</li>
			</ul>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Authentication</h2>
			<p>Authentication is the <a id="_idIndexMarker468"/>process of validating the identity of a user who is trying to access an application. It starts by obtaining the credentials of the user, then validating them against the identity provider such as <strong class="bold">Windows Active Directory</strong> that can be on-premises or in the cloud as part of <strong class="bold">Microsoft 365</strong> services. The user is considered authenticated if the validation process of the credentials is successful. After authentication, the system should start the authorization process to check the access level of the user and decide which data and resources are accessible for this user. Without knowing who the user is, authorization cannot take place.</p>
			<p>There are four different authentication modes in ASP.NET Core that we must know about, as follows:</p>
			<ul>
				<li><strong class="bold">Individual accounts</strong>: This<a id="_idIndexMarker469"/> mode is used when we want to make use of the built-in ASP.NET <strong class="source-inline">identity</strong> module. This module will automatically create the authentication and authorization SQL tables, along with the UI that includes the <strong class="source-inline">Register</strong>, <strong class="source-inline">Login</strong>, <strong class="source-inline">LogOut</strong>, and <strong class="source-inline">RegisterConfirmation</strong> views, which will be added to Visual Studio through the scaffolding functionality. The following screenshot shows the SQL tables that will be created when we apply the migrations in the package manager console:</li>
			</ul>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/Figure_7.01_B17366.jpg" alt="Figure 7.1: ASP.NET identity SQL tables"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: ASP.NET identity SQL tables</p>
			<p>By using this mode, the unauthenticated users will be automatically redirected to a login page where they can supply their login credentials and submit them back to the server. If the IdP authenticates the request, ASP.NET issues a cookie that contains the ID token of the authenticated user, which will be attached to all subsequent requests in each request header. This means that all subsequent requests are automatically authenticated using the authentication token stored in this <a id="_idIndexMarker470"/>cookie.</p>
			<p>Here is a Microsoft reference on how to configure this authentication mode: </p>
			<p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&amp;tabs=visual-studio&#13;">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&amp;tabs=visual-studio</a></p>
			<ul>
				<li><strong class="bold">Microsoft identity platform</strong>: This mode is used if we want to authenticate users against <strong class="bold">Azure Active Directory</strong>. We will have to register our app with the Azure Active <a id="_idIndexMarker471"/>Directory, then configure our ASP.NET Core project. Here is a screenshot showing the settings that we need to change in the <strong class="source-inline">appSettings.json</strong> file; we can get these settings from the Azure Active Directory after we register the app: </li>
			</ul>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_7.02_B17366.jpg" alt="Figure 7.2 – Configuration in the appsettings.json file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Configuration in the appsettings.json file</p>
			<p>As shown in the preceding screenshot, we first need to set the <strong class="source-inline">Domain</strong> name that we are using in the application. Then, we need to set <strong class="source-inline">TenantId</strong> and <strong class="source-inline">ClientId</strong> that we get from Azure <a id="_idIndexMarker472"/>when we register the application. As for <strong class="source-inline">CallbackPath</strong>, this is the <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) where we want to redirect users after successful login.</p>
			<p>The following diagram shows how the authentication with the Microsoft identity platform works:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_7.3_B17366.jpg" alt="Figure 7.3: Authentication process using the Microsoft identity platform"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: Authentication process using the Microsoft identity platform</p>
			<p>As you can see, unauthenticated users will be redirected to the Windows login page where they are prompted to provide their credentials, and then an access token is created if the <a id="_idIndexMarker473"/>credentials are valid. After that, the user gets redirected to the landing page or redirects the URL specified in the <strong class="bold">HTTP</strong> response returned by the identity provider.</p>
			<p>Here is a Microsoft reference on how to configure the Microsoft identity platform: </p>
			<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-v2-aspnet-core-webapp&#13;">https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-v2-aspnet-core-webapp</a></p>
			<ul>
				<li><strong class="bold">Windows</strong>: This is <a id="_idIndexMarker474"/>also<a id="_idIndexMarker475"/> known as <strong class="bold">Negotiate</strong>, <strong class="bold">Kerberos</strong>, or <strong class="bold">New Technology LAN Manager</strong> (<strong class="bold">NTLM</strong>) authentication. This<a id="_idIndexMarker476"/> authentication mode is best suited for apps running in<a id="_idIndexMarker477"/> intranet environments under the same Windows domain. It can be configured for apps hosted <a id="_idIndexMarker478"/>with <strong class="bold">Internet Information Services</strong> (<strong class="bold">IIS</strong>) or <strong class="bold">Kestrel</strong> while the server runs on a corporate network using Active Directory<a id="_idIndexMarker479"/> domain identities. This authentication process relies on the operating system to get the ID of the user and confirm the authentication.<p>Here is a Microsoft reference on how to configure Windows authentication: </p><p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-5.0&amp;tabs=visual-studio&#13;">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-5.0&amp;tabs=visual-studio</a></p></li>
				<li><strong class="bold">None</strong>: When we<a id="_idIndexMarker480"/> choose this mode, it means the identity of users is not needed. This type of mode is used in two cases—either when our application is public and anyone is allowed to access it or when we want to build our own custom authentication module. </li>
			</ul>
			<p>Here are a few tips to consider when we implement a custom authentication process:</p>
			<ul>
				<li>Enforce the <a id="_idIndexMarker481"/>user to use a complex password and hash it before storing it in the users' table.</li>
				<li>Never store a password in a hidden field or in any state management object.</li>
				<li>Consider encrypting the password input using a client-side library before submitting it to the server along with the request header and body. On the server, when you receive the password you will need to decrypt it, hash it, and then compare it to the hashed password in the database. If they are equal, then the user is considered authenticated. </li>
				<li>If you are using sessions, make sure to clear them on logout and modify the session ID, and on login generate a new session ID.</li>
				<li>Consider implementing <strong class="bold">two-factor authentication</strong> (<strong class="bold">2FA</strong>).</li>
				<li>Never grant any user <strong class="source-inline">db_owner</strong> access to our SQL database, including the user used in the connection string.</li>
			</ul>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Authorization</h2>
			<p>Authorization is<a id="_idIndexMarker482"/> the process of deciding whether a user ID should be granted access to a specific resource in an application. Usually, authorization starts immediately after authentication, and there are different types of resource authorizations that can be given to a user, listed as follows:</p>
			<ul>
				<li><strong class="bold">URL authorization</strong>: This is<a id="_idIndexMarker483"/> performed to selectively grant users and roles access to particular URLs in the application. </li>
				<li><strong class="bold">File authorization</strong>: This<a id="_idIndexMarker484"/> process is used to protect the assets of an application and prevent unauthorized users from browsing the directories. </li>
				<li><strong class="bold">UI authorization</strong>: This is <a id="_idIndexMarker485"/>also known as <strong class="bold">UI trimming</strong>. This process is performed to selectively allow or deny <a id="_idIndexMarker486"/>access to arbitrary parts of a page for specific users or roles. The section will be completely removed from the page if a user has no access to it.</li>
			</ul>
			<p>It's quite easy to apply authorization in <strong class="bold">model-view-controller</strong> (<strong class="bold">MVC</strong>) by adding the <strong class="source-inline">[Authorize]</strong> attribute to the controller class or to actions that are not anonymous. Here is an example of this:</p>
			<p class="source-code">[Authorize(Users = "john,tim")]</p>
			<p class="source-code">public IActionResult EditContent() </p>
			<p class="source-code">{ </p>
			<p class="source-code"> return View(); </p>
			<p class="source-code">}</p>
			<p>If you allow anonymous access to a particular action within a controller class that has the <strong class="source-inline">[Authorize]</strong> attribute on top of it, you need to use <strong class="source-inline">[AllowAnonymous]</strong> on top of the action. You can use the <strong class="source-inline">[Authorize]</strong> attribute to grant access to roles and not only users.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Anti-XSS </h2>
			<p><strong class="bold">XSS</strong> is <a id="_idIndexMarker487"/>considered the number-one security vulnerability on the web and, unfortunately, a large number of web developers are not familiar with the risks of this vulnerability. XSS is a type of injection attack in which an attacker tries to execute malicious client-side scripts in the web <a id="_idIndexMarker488"/>browser of another end user.</p>
			<p>There are two scenarios in terms of XSS attacks: the first one is called <strong class="bold">passive injection</strong>, where<a id="_idIndexMarker489"/> an attacker inputs a vulnerable script in an input field that will be stored in the database and will be displayed on the page when users access it. The second one is <a id="_idIndexMarker490"/>called <strong class="bold">active injection</strong>, where a user enters a vulnerable script into an input that will be displayed immediately onscreen.</p>
			<p>Let's explore these two scenarios with some examples in the following sections.</p>
			<h3>Passive injection</h3>
			<p>This type of XSS <a id="_idIndexMarker491"/>attack occurs when the web page accepts unsanitized text input that can be later displayed to a victim who is accessing this page. Suppose we have an online blog post that allows users to post comments and interact with each other.</p>
			<p>If the input field, where we should specify our comment, is accepting the text as is without validation or sanitization, then the attacker will inject a client script in the comment field, which will be triggered whenever a user is accessing this blog post. Here is an example of a comment that contains malicious input:</p>
			<p class="source-code">This is a nice post&lt;script&gt;window.alert('This is an unsecure website')&lt;/script&gt;</p>
			<p>In this example, the comment contains <strong class="bold">JavaScript</strong> code that will trigger an alert with a nasty message. This message will be stored in the comments table, and every time a user tries to access the page, the script will be triggered and the message will be displayed to the end user, which is very annoying.</p>
			<p>The attacker can inject JavaScript code to manipulate the <strong class="bold">HTML</strong> code of the page, such as in this example:</p>
			<p class="source-code">This is a nice post&lt;script src="http://hackersite.xxx/badscript.js"&gt;&lt;/script&gt;</p>
			<p>In the preceding example, you will notice that the attacker injected a client-side library that can manipulate the HTML code of your page and display different content.</p>
			<h3>Active injection</h3>
			<p>This type of XSS <a id="_idIndexMarker492"/>attack occurs when the user input is immediately displayed on the web page and is not saved on the server. Suppose we have a web page that is reading metadata from the query string of the URL, and it shows a welcome message when we access the page. </p>
			<p>In this case, an attacker can manipulate the query string and pass the following input script:</p>
			<p class="source-code">johnsmith\x3cscript\x3e%20alert(\x27XSS attack! weak security\x27)%20\x3c/script\x3e</p>
			<p>This will display an <strong class="source-inline">XSS attack! weak security</strong> alert message on the web page.</p>
			<p>Let's check the following recommendations to help protect your application against XSS attacks:</p>
			<ul>
				<li>Don't trust any user input, even if the user is authenticated. You should always validate the input provided by the end users. Moreover, you should encode query strings and escape single quotes before storing the text in a database or displaying it on a web page.</li>
				<li>Ensure the URL query string is encoded, and always validate the value in the query string before using it.</li>
				<li>Perform content sanitization before you store untrusted content in your database. <strong class="bold">HTML sanitization</strong> is <a id="_idIndexMarker493"/>the process of checking content that is dynamic and only preserving tags that match with the whitelist.</li>
				<li>You should always use <strong class="source-inline">@Html.Raw</strong> to render untrusted content.</li>
				<li>You can encode untrusted data before displaying it in your HTML code. This way, you make sure no one can inject an input with a script code because the encoding mechanism will convert <strong class="source-inline">&lt;</strong> to <strong class="source-inline">&amp;lt;</strong>, which will be treated as regular text.</li>
				<li>Make sure to set the <strong class="source-inline">HttpOnly</strong> flag to protect our cookies from being accessible through client-side code.</li>
			</ul>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>Cross-Site Request Forgery (CSRF)</h2>
			<p><strong class="bold">CSRF</strong> (also known by the <a id="_idIndexMarker494"/>acronym <strong class="bold">XSRF</strong>, and pronounced <em class="italic">sea-surf</em> or <em class="italic">c-surf</em>) is a type of attack that is performed by a malicious website that enforces a trusted but vulnerable site to perform an undesirable action when the user is still authenticated.</p>
			<p>A CSRF attack is possible because browser requests include cookies that encapsulate the authentication tokens. In this case, the attacker is taking advantage of the authentication cookie to fool the trusted website, which cannot distinguish between legitimate requests and forged requests, by executing a malicious request using the authentication cookie <a id="_idIndexMarker495"/>from the trusted website. This type of attack is also <a id="_idIndexMarker496"/>known as a <strong class="bold">one-click attack</strong> or <strong class="bold">session riding</strong>.</p>
			<p>The easiest way to perform a CSRF attack is by attracting the attention of users to a malicious website by sending millions of phishing emails claiming that users won a big amount of money or a trip to Las Vegas. Usually, there is a link included in the email that will take us to the malicious website, and to collect our prize the malicious website would ask us to click a fancy button.</p>
			<p>Of course, users would not hesitate to do so, for different reasons. One such reason is that they don't know the risks or the consequences of clicking the button. Once the button is clicked, the malicious website sends the nasty request to the trusted website while attaching an authentication cookie with the request. If the vulnerable website is not taking precautions such as validating the incoming request (as in this case), the attack will, unfortunately, be successful. Here is a diagram showing a CSRF attack:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/Figure_7.04_B17366.jpg" alt="Figure 7.4: Steps of a CSRF attack"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: Steps of a CSRF attack</p>
			<p>Here are some recommendations<a id="_idIndexMarker497"/> that should be considered to prevent CSRF attacks:</p>
			<ul>
				<li>Generate a user-specific CSRF token and store it in a hidden field. This token should be submitted with every request, and it should be validated on the server on all <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> requests. The token should be regenerated on every request to prevent attackers from simulating this token and fooling the validation process on the server side. In MVC, we can use the following code to generate an anti-forgery token:<p class="source-code">@using (Html.BeginForm("Create", "Product"))</p><p class="source-code">{</p><p class="source-code">@Html.AntiForgeryToken() </p><p class="source-code">  //Here we put our form fields along with the submit     button</p><p class="source-code">}</p><p>This will output the following <a id="_idIndexMarker498"/>HTML code:</p><p class="source-code"><strong class="bold">&lt;form asp-controller="Product" </strong></p><p class="source-code"><strong class="bold">    asp-action="Create" method="post"&gt;    &lt;input name="__RequestVerificationToken"        type="hidden" value="sK0JeZQad</strong>..<strong class="bold">AhEYoo1" /&gt;</strong></p><p class="source-code"><strong class="bold"> &lt;!-- rest of form goes here --&gt;</strong></p><p class="source-code"><strong class="bold">&lt;/form&gt;</strong></p><p>As you can see, the <strong class="source-inline">"__RequestVerificationToken"</strong> hidden field is holding the CSRF token. Here is an example, showing us how to force the post action in the controller to validate the token before executing the core functionality of the action:</p><p class="source-code">[HttpPost]</p><p class="source-code">[ValidateAntiForgeryToken]</p><p class="source-code">public async Task&lt;IActionResult&gt;    Create (ProductViewModel newProduct)</p><p class="source-code">{</p><p class="source-code">&lt;!-- rest of the action code goes here --&gt;</p><p class="source-code">}</p><p>Notice the attribute on top of the action to validate the anti-forgery token. If the token is not valid, the request will be rejected/canceled.</p></li>
				<li>Consider<a id="_idIndexMarker499"/> checking the <strong class="source-inline">referer</strong> header of incoming requests, which should be referencing the same domain of the trusted site. This will prevent or cancel requests submitted from a different domain.</li>
			</ul>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Cookie stealing</h2>
			<p>Cookies are an essential part of a website because they usually hold the session details of the logged-in user. A <strong class="bold">cookie</strong> is an <a id="_idIndexMarker500"/>object that is transmitted back and forth between the client browser and the server. So, instead of authenticating the user on every request, the authentication token or claims can be stored in the cookie, and it will be used to identify the user after login. Without cookies, the user will need to log in again on every request.</p>
			<p>It is important to secure <a id="_idIndexMarker501"/>cookies if you are using them in your application. <strong class="bold">Cookie stealing</strong> (also known as <strong class="bold">session hijacking</strong>) is a type of attack that allows hackers to steal the cookie of a <a id="_idIndexMarker502"/>logged-in user, then impersonate that user and start sending requests on their behalf. In this case, the server is fooled because the request sent by the attacker looks authentic since it contains a valid authentication cookie.</p>
			<p>To prevent cookie <a id="_idIndexMarker503"/>stealing, we must apply the following recommendations:</p>
			<ul>
				<li>Use a <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificate and only allow <strong class="bold">HTTP Secure</strong> (<strong class="bold">HTTPS</strong>) requests to encrypt all requests passed between the user and the server.</li>
				<li>Consider applying <strong class="source-inline">secure</strong> and <strong class="source-inline">HttpOnly</strong> flags in the <strong class="source-inline">web.config</strong> file to protect the cookie and to ensure that it is only sent over an SSL connection.</li>
				<li>Regenerate the session ID immediately after login.</li>
				<li>Consider clearing the authentication cookie on logout.</li>
			</ul>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/>Overposting</h2>
			<p><strong class="bold">Model binding</strong> in ASP.NET<a id="_idIndexMarker504"/> handles the <a id="_idIndexMarker505"/>mapping of data between incoming requests and the .NET application model. It is a powerful feature that simplifies the process of populating the model properties with the user input data, based on a naming convention. However, this may cause another security breach by allowing an attacker to populate some properties in the model that are not presented in the form. This <a id="_idIndexMarker506"/>type of attack is<a id="_idIndexMarker507"/> called an <strong class="bold">overposting</strong> or <strong class="bold">mass assignment</strong>.</p>
			<p>Let's check the following example to understand the overposting vulnerability. Assume we have a user model that we are using to register a new user in our application:</p>
			<p class="source-code">public class User</p>
			<p class="source-code">{</p>
			<p class="source-code">    public int ID { get; set; }</p>
			<p class="source-code">    public string FirstName { get; set; }</p>
			<p class="source-code">    public string LastName { get; set; }</p>
			<p class="source-code">    public string Email { get; set; }</p>
			<p class="source-code">    public string Password { get; set; }</p>
			<p class="source-code">    public bool IsAdmin { get; set; }</p>
			<p class="source-code">}</p>
			<p>This is pretty much a simple user model. You will notice that there is a property named <strong class="source-inline">IsAdmin</strong> in the model—this is used to specify if the user has an administration access level on the entire application. The <strong class="bold">CSHTML</strong> view should not include this property because we don't want end users to decide their access level. The view should look like this:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_7.05_B17366.jpg" alt="Figure 7.5 – User registration sample form"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – User registration sample form</p>
			<p>When the form <a id="_idIndexMarker508"/>is submitted, it will produce the following HTTP <strong class="source-inline">POST</strong> request:</p>
			<p class="source-code">Request URL:http://TheWebsiteUrl/register</p>
			<p class="source-code">Request Method:POST</p>
			<p class="source-code">Status Code:200 OK</p>
			<p class="source-code">firstname:John</p>
			<p class="source-code">lastname:miller</p>
			<p class="source-code">email:john@xxx.com</p>
			<p class="source-code">password:encryptedPassword</p>
			<p class="source-code">. . .</p>
			<p>However, when using a debugging proxy-server tool, we can modify this HTTP request and include additional values and properties in the request. In this case, the attacker would include <strong class="source-inline">IsAdmin:True</strong> in the <strong class="source-inline">POST</strong> request. As a result, the user will be registered in the system with admin privileges.</p>
			<p><em class="italic">How can we prevent this kind of attack?</em> Well, there are a few solutions to prevent this vulnerability, such as the<a id="_idIndexMarker509"/> following ones: </p>
			<ul>
				<li><strong class="bold">Matching incoming parameters</strong>: Instead of using the full model as an input parameter for the MVC action, just declare the fields that we need to pass to register the user. So, instead of <strong class="source-inline">public IActionResult Register(User model)</strong>, we can use <strong class="source-inline">public IActionResult Register(string firstName, string lastName, string email, string password)</strong>, and in the implementation of the action, we populate the model using the fields passed in the action's parameters. In this case, any additional property that is added by the attacker will be ignored.</li>
				<li><strong class="bold">Using a view model</strong>: Again, instead of using the full model as an input, just create a new custom view model and call it <strong class="source-inline">RegisterUserViewModel</strong>. In this new model, we only add the properties needed for registration, so the action will become <strong class="source-inline">public IActionResult Register(RegisterUserViewModel model)</strong>. I like this option and I usually apply it as a common practice.</li>
				<li><strong class="bold">Whitelist parameters</strong>: We can use a <strong class="source-inline">BindAttribute</strong> class on the method parameters and just include (whitelist) the properties we want to allow for binding. So, the action should look like this: <strong class="source-inline">public IActionResult Register(([Bind("FirstName,LastName,Email,Password") User model)</strong>.</li>
			</ul>
			<p>As a good practice, we must not use our database entities directly as models in the MVC views and actions.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>Preventing open redirection attacks</h2>
			<p>Let's first understand what an <a id="_idIndexMarker510"/>open redirection attack is. If you have logic in your web application that redirects users to a URL that is specified in the query string or via the HTTP request's parameters, this can potentially be tampered with to redirect users to a malicious URL, to steal their credentials. </p>
			<p>Assume an attacker sent an email with a redirect link such as this:</p>
			<p class="source-code">http://www.yourtrustedwebsite.com?ReturnUrl=www.fakedomain.com/login</p>
			<p>Usually, some users won't look at the query string, and others won't even check the domain in the first part of the URL. When they click this URL, they will get redirected to a login page provided by the malicious website. This login page is very similar in terms of look and feel to the original login page in the trusted website. In this case, users will provide their credentials, assuming they log in normally.</p>
			<p>However, the attacker will steal the credentials and redirect them to the original login page in the trusted website. Users will feel as though they provided the wrong username or password, so they will provide these again and continue what they wanted to do on the trusted website.</p>
			<p>In this way, the attacker steals the user credentials without the victim ever knowing about it. This type of attack is called an <strong class="bold">open redirection attack</strong>. Now, let's get to the part about how to prevent it. </p>
			<p>When using such redirection logic in your web applications, treat all users as untrustworthy. Therefore, we need to make sure to only redirect to local URLs within our application or make use of a new method available in ASP.NET, named <strong class="source-inline">LocalRedirect</strong>. This is used to redirect to a local URL within the app itself, which means it validates the URL before triggering the redirection, and if the URL is not local, the method will throw an exception.</p>
			<p>Also, there is a method to validate whether a URL is local or not—you can make use of <strong class="source-inline">Url.IsLocalUrl(..)</strong>. This method will return a Boolean to indicate whether the URL is local or not.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Blocking brute-force attacks</h2>
			<p>In cryptography, a <strong class="bold">brute-force attack</strong> (also known as <a id="_idIndexMarker511"/>an <strong class="bold">exhaustive search</strong>) involves an attacker <a id="_idIndexMarker512"/>attempting to guess a password by thoroughly trying every possible combination of letters, numbers, and symbols until discovering the correct combination that works. In many cases, the attacker will use a bot tool to perform an automatic attack and predict the password. To prevent this type of attack, we can apply the following steps:</p>
			<ul>
				<li>Lock the user account after a specific number of failed login attempts.</li>
				<li>Implement a <strong class="bold">Completely Automated Public Turing test to tell Computers and Humans Apart </strong>(<strong class="bold">CAPTCHA</strong>) on the login page.</li>
				<li>Consider allowing logins from specific <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) addresses and restrict these from all other IP addresses.</li>
				<li>Enforce complex passwords.</li>
				<li>Consider enabling 2FA. </li>
				<li>Block the attackers' IP addresses, but this is not a guaranteed solution because the attackers can change the IP addresses from which they are performing the attacks.</li>
				<li>Consider using a proper username and avoid using <strong class="source-inline">admin</strong>, <strong class="source-inline">administrator</strong>, or any other easy-to-guess usernames.</li>
			</ul>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>File-upload protection</h2>
			<p>A file upload allows users to <a id="_idIndexMarker513"/>upload files while submitting a form. A career form is a simple example of the usage of a file upload, where users need to attach their resume when applying for a job position. Attackers can make use of the file upload and try to upload malicious files to the server. Here are a few security steps that should reduce the likelihood of using a file upload to perform a successful attack:</p>
			<ul>
				<li>Disable the execute permissions on the folder where you are storing the uploaded files.</li>
				<li>Make sure to use a whitelist to only allow approved file extensions.</li>
				<li>Enable client-side validation to check the file extension before uploading it to the server. </li>
				<li>Check the size of the uploaded file and restrict the uploading of large files that exceed the size limit.</li>
				<li>Make sure to check<a id="_idIndexMarker514"/> the header of the uploaded file, using the server-side code in .NET, to prevent the upload of malicious files.</li>
				<li>Encode the filename, especially if you are displaying the filename in the HTML code.</li>
			</ul>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/>Preventing SQL injection in ADO.NET and Entity Framework</h2>
			<p>A <strong class="bold">SQL injection</strong> is a <a id="_idIndexMarker515"/>vulnerability that enables an attacker to bypass the security measures taken in an application to execute malicious SQL commands directly in the application's database. </p>
			<p>With these SQL commands, attackers can query the data of other users. They can also modify data and even delete some tables or the entire database, which can cause a major loss to the client business, especially <a id="_idIndexMarker516"/>if there is no proper backup process in place.</p>
			<p>Furthermore, they <a id="_idIndexMarker517"/>can escalate an attack to compromise the entire SQL server. A SQL injection attack is one of the most dangerous attacks we can face because it affects the entire database and possibly all databases hosted on the same server. Let's get to know how to prevent this type of attack, as follows:</p>
			<ul>
				<li>Check for malicious input data by enforcing constraints, validating the type and format of the data, and enforcing sanitization.</li>
				<li>Consider using parameterized SQL stored procedures for data access and avoid using text concatenation with inline SQL statements.</li>
				<li>Never grant administrative privileges to SQL users that are used in the data access layer—the read/write permissions should be enough.</li>
				<li>Avoid disclosing the details of database errors that may occur in the application. Actual errors should be logged properly in a centralized location, and the end user should be redirected to a custom error page with no technical details.</li>
				<li>Encrypt the SQL connection in the <strong class="source-inline">web.config</strong> file to secure connectivity with the database.</li>
				<li>SQL injection vulnerabilities are applicable in <strong class="bold">NoSQL</strong> databases such as <strong class="bold">Azure Cosmos DB</strong> and <strong class="bold">MongoDB</strong>, and therefore all the previous recommendations are also applicable in this case as well.</li>
			</ul>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor124"/>General security recommendations</h2>
			<p>In the previous sections, we learned about the major security vulnerabilities. In this section, we will highlight some security recommendations<a id="_idIndexMarker518"/> that will increase the security level of the solution, as follows:</p>
			<ul>
				<li>Consider enabling audit trails, logging, and tracing to monitor all events and incoming requests.</li>
				<li>Always upgrade the .NET version used in your solution by installing .NET patches to benefit from the security enhancements released by the Microsoft team.</li>
				<li>Consider encrypting passwords before sending them to the server to avoid sniffing attacks.</li>
				<li>One of the common security steps is to enable the following response headers:<p>a. <strong class="source-inline">Content-Security-Policy</strong>: This allows us to specify a source whitelist of content that can be loaded onto the website. It helps to prevent XSS, <strong class="bold">clickjacking</strong>, and other code-injection attacks.</p><p>b. <strong class="source-inline">X-Content-Type-Options</strong>: This helps in preventing <strong class="bold">Multipurpose Internet Mail Extensions-sniffing</strong> (<strong class="bold">MIME-sniffing</strong>) attacks.</p><p>c. <strong class="source-inline">X-XSS-Protection</strong>: This enables the XSS filter.</p></li>
				<li>Block <strong class="bold">cross-frame scripting</strong> (<strong class="bold">XFS</strong>) attacks by enabling the <strong class="source-inline">X-Frame-Options</strong> response header. </li>
				<li>Prevent disclosing sensitive data related to the hosting server and .NET Framework by removing the following response headers:<p>a. <strong class="source-inline">Server</strong>: This header specifies the web server version (IIS version).</p><p>b. <strong class="source-inline">X-Powered-By</strong>: This header indicates that the website is powered by ASP.NET.</p><p>c. <strong class="source-inline">X-AspNet-Version</strong>: This header specifies the version of ASP.NET used.</p></li>
				<li>Avoid using <a id="_idIndexMarker519"/>third-party components and libraries with known vulnerabilities.</li>
				<li>Consider updating <strong class="bold">NuGet</strong> packages periodically to make use of the latest fixes and enhancements.</li>
				<li>If you are hosting your app with IIS, make sure to encrypt the connection string because it contains the credentials of the user who can access the database. If you are hosting your app with Azure App Service, consider storing the connection string in the Azure application settings instead of the <strong class="source-inline">web.config</strong> file.</li>
			</ul>
			<p>In this section, we explored a set of key security practices to help secure our ASP.NET web applications against malicious attacks. Once each of these practices is applied, it will add a security layer to the application. The objective is to highlight various areas that a solution architect should focus on while designing a robust web solution.</p>
			<p>In the next section, we will learn how to secure a web API with a set of security recommendations. </p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor125"/>Web API security recommendations</h1>
			<p>With an increasing demand to <a id="_idIndexMarker520"/>build modern web and mobile apps, web APIs have become essential to empower these applications, with an easy way to communicate with the data access layer. This should be accompanied by proper security measures to protect web APIs. In addition to the security recommendations we discussed in the previous section, here are some essential tips to secure your web API:</p>
			<ul>
				<li>Consider using the latest <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) version to encrypt communication between the app and the server.</li>
				<li>Authenticate users who are trying to consume the RESTful API.</li>
				<li>Act like a stalker by enabling audit logs, tracing, and logging to monitoring all events.</li>
				<li>Consider protecting your API by applying throttling and quotas, such as limiting the number of messages per a specific time. This is important to control the bandwidth of the server<a id="_idIndexMarker521"/> according to the available capacity.</li>
				<li>Always validate the <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) data input to avoid SQL injection.</li>
				<li>Enable proper firewall configuration on the server where you host the web API.</li>
				<li>Consider having an API gateway, which is a middleware layer that sits between the client application and the RESTful API. This helps you to secure, control, and monitor the traffic to the RESTful API.</li>
				<li>Prevent a <strong class="bold">distributed denial-of-service</strong> attack (also known as a <strong class="bold">DDoS</strong> attack), which sends a large number of useless requests to overwhelm the memory and capacity of the hosting server by flooding it with concurrent connections. You can prevent DDoS attacks in IIS by enabling the dynamic IP restrictions extension that can block incoming requests from certain IP addresses based on the number of concurrent requests. If the application is hosted in Azure, then we can enable <strong class="bold">Azure DDoS protection</strong>.</li>
				<li>Consider enforcing a timestamp in every request by adding it to the request header. This timestamp should be validated on the server to only accept requests if their timestamp is within a particular timeframe. This approach can help you protect the web API against brute-force attacks (explained in the <em class="italic">Blocking brute-force attacks</em> section) and replay attacks that allow attackers to maliciously complete <a id="_idIndexMarker522"/>duplicate requests.</li>
			</ul>
			<p>In this section, we discussed a set of security recommendations that should be applied to secure an ASP.NET web API.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Protecting web apps and APIs hosted on Azure</h1>
			<p>In this section, we will<a id="_idIndexMarker523"/> highlight some security recommendations to <a id="_idIndexMarker524"/>bear in mind if you are hosting your web application or your web API on Azure, as follows:</p>
			<ul>
				<li>Consider enabling <strong class="bold">Azure Defender</strong> to protect your app service.</li>
				<li>Always run the integrated vulnerability assessment scanner available in Azure Defender for SQL servers to extend the protection of SQL servers along with stored databases.</li>
				<li>You can keep your app service up to date by using the latest versions of supported platforms, frameworks, and protocols.</li>
				<li>Disable anonymous access to the blob storage to protect uploaded files. You can enable anonymous access to specific folders if needed.</li>
				<li>Enforce the usage of the <strong class="bold">SSL</strong>/<strong class="bold">TLS</strong> protocol to provide a secure connection.</li>
				<li>Always use <strong class="bold">File Transfer Protocol Secure</strong> (<strong class="bold">FTPS</strong>) instead of the regular <strong class="bold">FTP</strong> to deploy your files and disable the FTP protocol if you are not using it.</li>
				<li>Consider using environment variables to store your database credentials, API tokens, and any application settings.</li>
				<li>Consider using a cloud <strong class="bold">Windows Application Firewall</strong> (<strong class="bold">WAF</strong>), which can help to protect your web applications from malicious attacks and common web vulnerabilities such as SQL injection and XSS.</li>
			</ul>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/>Summary</h1>
			<p>In this chapter, we learned that security is an essential part of a web solution. We outlined the fundamental security measures and techniques to help in understanding the possible security vulnerabilities that will allow us to protect an ASP.NET web application against malicious attacks.</p>
			<p>Furthermore, we highlighted some key guidelines to secure our RESTful API. Later, in this chapter, we explored some tips to secure our app that can be hosted on Azure. These security practices allow us to build robust yet secure ASP.NET apps.</p>
			<p>In addition to the recommendations shared in this chapter, I strongly recommend you keep updating your knowledge about the security features in ASP.NET by reading the online official documentation shared by the Microsoft .NET team. Here is the link to the documentation: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-5.0">https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-5.0</a>.</p>
			<p>In the next chapter, we will explore the different types of testing that we may need to conduct before releasing our solution.</p>
		</div>
	</body></html>