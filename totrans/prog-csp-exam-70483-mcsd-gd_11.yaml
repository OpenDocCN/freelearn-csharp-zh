- en: Validating Application Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证应用程序输入
- en: When working on real-world projects, there may be scenarios where different
    kinds of users access your application and enter information in to it. In the
    event that any aspect of the scenario was not handled properly, or any input data
    was not properly parsed, this can cause your application to crash or result in
    the corruption of your application data. Even though you validate all the input
    data used and accessed within your application when deployed in production, input
    data can interact with other external applications, which can place your application
    in jeopardy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当在实际项目中工作时，可能会出现不同类型的用户访问您的应用程序并向其中输入信息的情况。如果场景中的任何方面处理不当，或者任何输入数据没有被正确解析，这可能会导致您的应用程序崩溃或导致您的应用程序数据损坏。尽管您在生产环境中验证了应用程序中使用的和访问的所有输入数据，但输入数据可能会与其他外部应用程序交互，这可能会使您的应用程序处于危险之中。
- en: The purpose of this chapter is to understand the importance of validating input
    data in your application. Different validation techniques are available in the
    .NET Framework to validate JSON data and XML data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是理解在您的应用程序中验证输入数据的重要性。.NET Framework 中提供了不同的验证技术来验证 JSON 数据和 XML 数据。
- en: In upcoming sections, we will focus on why it is important to validate input
    data, how we can manage data integrity, how to use framework-provided parsing
    statements and regular expressions, and how to validate JSON and XML data. After
    reading this chapter, you will be able to create application logic to validate
    incoming data and also handle scenarios where exceptions might occur.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将关注验证输入数据的重要性，如何管理数据完整性，如何使用框架提供的解析语句和正则表达式，以及如何验证 JSON 和 XML 数据。阅读本章后，您将能够创建用于验证传入数据的应用程序逻辑，并处理可能发生的异常场景。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The importance of validating input data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入数据的重要性
- en: Data integrity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性
- en: Parsing and converting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析和转换
- en: Regular expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: JSON and XML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 和 XML
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Exercises in this chapter can be implemented using Visual Studio 2012 or above
    with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and
    above require you to have Visual Studio 2017.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习可以使用 Visual Studio 2012 或更高版本以及 .NET Framework 2.0 或更高版本来实现。然而，任何从 C# 7.0
    及以上版本的新特性都需要您拥有 Visual Studio 2017。
- en: If you don't have a license for any of the products, you can download the community
    version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有任何产品的许可证，您可以从 [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
    下载 Visual Studio 2017 的社区版。
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter
    11](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter%2011).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter%2011](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter%2011)。
- en: The importance of validating input data
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证输入数据的重要性
- en: Creating and running an application in isolation mode makes your application
    run without any issues. However, when working on a real project, your application
    will be executing in an environment where many external interfaces may interact.
    In such scenarios, is your application capable of handling such communications?
    Can it handle all kinds of data from these external applications? There will be
    many users who will try to use your system; some may use it properly, and others
    may try to break your system. Can your application tolerate such interactions?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在独立模式下创建和运行应用程序可以使您的应用程序无任何问题地运行。然而，当在实际项目中工作时，您的应用程序将在一个可能存在许多外部接口交互的环境中执行。在这种情况下，您的应用程序能否处理这种通信？它能否处理来自这些外部应用程序的所有类型的数据？将会有许多用户尝试使用您的系统；有些人可能会正确使用它，而其他人可能会试图破坏您的系统。您的应用程序能否容忍这种交互？
- en: There may be problems with both types of user. Those who use your system properly
    may make mistakes by entering incorrect data or may forget to provide the requisite
    data. In the event your application has logic based on the user's date of birth
    and the user enters some text data, your application might throw an exception
    and crash.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的用户都可能存在问题。那些正确使用您的系统的人可能会因为输入错误数据或忘记提供必要的数据而犯错误。如果您的应用程序的逻辑基于用户的出生日期，而用户输入了一些文本数据，那么您的应用程序可能会抛出异常并崩溃。
- en: In a scenario where users try to break your application by providing data that
    doesn't match any of the types that your application expects, this may crash your
    application and a significant amount of time may be devoted to recovering it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户尝试通过提供与应用程序期望的类型不匹配的数据来破坏您的应用程序的情况下，这可能会导致您的应用程序崩溃，并且可能会花费大量时间来恢复它。
- en: Any of these aforementioned actions can cause temporary damage to your application
    or may constitute a major issue. When it corrupts your database, recovering your
    application may entail more time and effort.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述任何操作都可能导致您的应用程序暂时受损或构成重大问题。当它破坏您的数据库时，恢复您的应用程序可能需要更多的时间和精力。
- en: Creating an application using .NET Framework involves the provision of some
    built-in features that can be utilized to validate some of the input data, be
    it from internal or external users or external applications. Framework allows
    you to add attributes over each property that can validate data for you. These
    are available when you use ASP.NET or the Entity Framework, and so on. As you
    learned in previous chapters, you can define custom attributes and perform validation
    on the data entered by users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET Framework创建应用程序涉及提供一些内置功能，这些功能可以用来验证一些输入数据，无论是来自内部用户还是外部用户或外部应用程序。框架允许您为每个属性添加属性，以便为您验证数据。这些在您使用ASP.NET或Entity
    Framework等时可用。正如您在前几章中学到的，您可以定义自定义属性并对用户输入的数据进行验证。
- en: In the next section, we will see a variety of data integrity scenarios that
    are important to understand while working on data validations in your applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到各种数据完整性场景，这些场景在您在应用程序中进行数据验证时非常重要。
- en: Data integrity
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据完整性
- en: While working on any application, it is very important to design it in such
    a way that it handles all scenarios, or at least provides user-friendly messages
    to users on what went wrong. We have already learned about exception handling
    in [Chapter 7](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml), *Implementing Exception
    Handling*, which can be handy in such scenarios.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何应用程序时，非常重要的一点是设计它以便它可以处理所有场景，或者至少向用户提供友好的错误信息。我们已经在前一章中学习了异常处理，即[第7章](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml)，*实现异常处理*，这在这些场景中非常有用。
- en: While working on a database or distributed applications, data integrity plays
    a vital role.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据库或分布式应用程序时，数据完整性起着至关重要的作用。
- en: 'Data integrity applies differently in different scenarios:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数据完整性在不同场景中的应用方式不同：
- en: For example, if you are creating an application and storing user information
    in a table, one of the principles you may adopt might be to not maintain duplicate
    users in the table so that they are uniquely identifiable. This is termed **entity
    integrity**.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果您正在创建一个应用程序并将用户信息存储在表中，您可能采用的一个原则是不要在表中维护重复的用户，以便它们可以唯一识别。这被称为**实体完整性**。
- en: In a scenario where you are collecting demographic information, you may allow
    certain values, or ranges of values, in specific fields. This is termed **domain
    integrity**. In other words, you are making sure that the data entered in each
    record/entity is valid.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在收集人口统计信息的情况下，您可能允许在特定字段中输入某些值或值范围。这被称为**域完整性**。换句话说，您正在确保每个记录/实体中输入的数据是有效的。
- en: There may be a scenario where you have to enter data into multiple tables with
    a parent-child relationship. In such cases, your application should maintain these
    relationships while saving information to the database. This is called **referential
    integrity**.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，您必须将数据输入到具有父子关系的多个表中。在这种情况下，您的应用程序应在将信息保存到数据库时维护这些关系。这被称为**引用完整性**。
- en: Last but not least, in a business scenario, in order to achieve the desired
    outcome based on a business process, your application may enforce certain constraints.
    This is called **user-defined** integrity, or **business-defined** integrity.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，在业务场景中，为了根据业务流程实现预期的结果，您的应用程序可能需要强制实施某些约束。这被称为**用户定义**的完整性或**业务定义**的完整性。
- en: There are many real-world examples. These include any eCommerce applications
    or any banking applications. How critical is it to validate and control input
    and program flow? In a banking application, what would happen in the event of
    a power outage? In an eCommerce application, how would a shopping cart be maintained
    between multiple sessions, when the user closes their browser, or in the event
    that a clean-up job kicks in?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多现实世界的例子。这包括任何电子商务应用程序或任何银行应用程序。验证和控制输入以及程序流的重要性有多大？在银行应用程序中，如果发生停电，会发生什么？在电子商务应用程序中，当用户关闭浏览器或在清理作业启动时，购物车将如何维护？
- en: Many of these data integrity options are available in the latest databases and
    frameworks, which enable us to utilize these options to validate and control the
    flow of our program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些数据完整性选项在最新的数据库和框架中可用，这使得我们能够利用这些选项来验证和控制我们程序的流程。
- en: 'One of the ways to validate data is to use the data annotations assembly, which
    is available in .NET Framework 3.5 and above. Data annotations talk about adding
    more information about an attribute or property in a class. You can use data annotations
    by referring to the `System.ComponentModel.DataAnnotations` namespace. These data
    annotations fall into three categories:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 验证数据的一种方法是通过使用数据注释程序集，该程序集在.NET Framework 3.5及以上版本中可用。数据注释涉及在类中添加有关属性或属性的信息。你可以通过引用`System.ComponentModel.DataAnnotations`命名空间来使用数据注释。这些数据注释分为三类：
- en: Validation attributes
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证属性
- en: Display attributes
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示属性
- en: Modeling attributes
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模属性
- en: 'Each of these attributes is used for a specific purpose: validation attributes
    enforce the validation of data; display attributes are used as display labels
    on the user interface, and modeling attributes represent the recommended use of
    the relevant attribute.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些属性都用于特定的目的：验证属性强制执行数据的验证；显示属性用于用户界面上的显示标签，而建模属性表示相关属性的推荐使用方式。
- en: 'In the following class, we will reference `System.ComponentModel.DataAnnotations`
    and use validating attributes, display attributes, and modeling attributes on
    the three available properties:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下类中，我们将引用`System.ComponentModel.DataAnnotations`并使用验证属性、显示属性和建模属性在三个可用的属性上：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the name property, we have a required field attribute and string length restrictions
    as validation attributes. The data type set to text is a data modeling attribute
    that tells the system that the name attribute only accepts text values. On the
    `DOB` property, we have a display attribute. However, display properties can be
    used in either ASP.NET applications or WPF applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称属性上，我们有一个必填字段属性和字符串长度限制作为验证属性。设置为文本的数据类型是一个数据建模属性，它告诉系统名称属性只接受文本值。在`DOB`属性上，我们有一个显示属性。然而，显示属性可以在ASP.NET应用程序或WPF应用程序中使用。
- en: 'Now, we create an instance of the `Student` class and try to validate its data.
    Data annotations help us to define `ValidationContext`; when an object is validated,
    `ValidationResult` will be returned, which consists of all properties and their
    respective error messages. While defining properties in the `Student` class, we
    added attributes with messages. When `ValidationContext` returns results, it returns
    each of these properties with their respective attributes and messages:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个`Student`类的实例并尝试验证其数据。数据注释帮助我们定义`ValidationContext`；当一个对象被验证时，将返回`ValidationResult`，它包含所有属性及其相应的错误消息。在定义`Student`类中的属性时，我们添加了带有消息的属性。当`ValidationContext`返回结果时，它返回每个这些属性及其相应的属性和消息：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you create a `ValidationContext` instance, we use the constructor that
    takes three parameters. These are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`ValidationContext`实例时，我们使用接受三个参数的构造函数。这些参数如下：
- en: An instance of an object that we want to validate
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要验证的对象的实例
- en: An object that implements the `IServiceProvider` interface, which means that
    you need to create an instance using the `GetService` method
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了`IServiceProvider`接口的对象，这意味着你需要使用`GetService`方法创建一个实例
- en: A dictionary of a key/value pair to consume
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个键/值对的字典以供消费
- en: Also, while trying to validate an object, we passed `true` as the last parameter,
    which represents the validation of all properties of the object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在尝试验证一个对象时，我们将`true`作为最后一个参数传递，这代表验证对象的所有属性。
- en: 'When you execute the program, you should see the following output. The student''s
    name should have a minimum of five characters and the email address should be
    in a valid format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行程序时，您应该看到以下输出。学生的姓名应至少有五个字符，电子邮件地址应格式正确：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the next section, we will look at the different features available in C#
    to validate our data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨C#中可用于验证我们数据的各种功能。
- en: Parsing and converting
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析和转换
- en: Entity integrity and domain integrity involve allowing valid values into our
    application for further processing. Valid values include manipulating or managing
    input provided by a user, rendering it as data that is acceptable to the application.
    This process may including parsing specific types of data to the type our application
    accepts, converting data types, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实体完整性和域完整性涉及允许有效值进入我们的应用程序以进行进一步处理。有效值包括操纵或管理用户提供的输入，将其呈现为应用程序可接受的数据。这个过程可能包括将特定类型的数据解析为应用程序接受的数据类型，转换数据类型等。
- en: '`Parse` and `TryParse` are two statements available across multiple data types
    within the .NET Framework, for example if you are writing a console application
    and you want to accept parameters as command-line arguments. In a console application,
    command-line parameters are always of the string type. So, how do you parse these
    arguments from the string type to another required type?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parse`和`TryParse`是.NET框架中多个数据类型中可用的两个语句，例如如果您正在编写控制台应用程序，并且希望将参数作为命令行参数接受。在控制台应用程序中，命令行参数始终是字符串类型。那么，您如何将这些参数从字符串类型解析为所需的另一种类型？'
- en: In the following example, we know that our first parameter is a Boolean value,
    but is passed as a string. When we are certain of the value passed, we can use
    the parse method to convert the string to a Boolean. `Parse` compares to with
    static string values and returns either `true` or `false`. When invalid data is
    passed, an exception is thrown—`Input string is in an invalid format`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们知道我们的第一个参数是一个布尔值，但它被传递为一个字符串。当我们确定传递的值时，我们可以使用解析方法将字符串转换为布尔值。`Parse`将字符串与静态字符串值进行比较，并返回`true`或`false`。当传递无效数据时，会抛出异常——`输入字符串格式无效`。
- en: 'Let''s start with an example. Define two methods that each take a parameter
    of the string type. We want to parse it into Boolean and integer values. Parsing
    a Boolean is as simple as using the parse method of a Boolean type. However, for
    the integer type, there are two approaches. One is to use parse, as we did when
    parsing a Boolean, and the other is `TryParse`. When we are not sure if the string
    parameter provided is an integer or not, then we can use the `TryParse` method,
    which will then give us a `bool` result on which we can set up our logic. In the
    following example, we are showing both ways. This will allow us to handle exceptions
    and provide the user with a meaningful message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。定义两个方法，每个方法都接受一个字符串类型的参数。我们希望将其解析为布尔值和整数值。解析布尔值就像使用布尔类型的解析方法一样简单。然而，对于整型，有两种方法。一种方法是使用解析，就像我们在解析布尔值时做的那样，另一种方法是`TryParse`。当我们不确定提供的字符串参数是否为整数时，我们可以使用`TryParse`方法，这样它就会给我们一个`bool`结果，我们可以根据这个结果设置我们的逻辑。在下面的例子中，我们展示了两种方法。这将使我们能够处理异常，并向用户提供有意义的消息：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that our sample class is ready, let''s invoke it using our `main` method.
    Here, we have a `switch` statement to check the length of the arguments passed
    to the `main` method. If it is `1`, call the `processbool` method; if it is `2`,
    call both methods, otherwise, a message is displayed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了示例类，让我们使用我们的`main`方法来调用它。在这里，我们有一个`switch`语句来检查传递给`main`方法的参数长度。如果是`1`，则调用`processbool`方法；如果是`2`，则调用两个方法，否则将显示一条消息：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To invoke this method, because we are trying to read command-line arguments
    in our program, these need to be passed at runtime or from the Properties window,
    which will then be read at runtime. Parameters are passed from the Properties
    window as follows. Right-click on Project, select Properties, and then navigate
    to the Debug tab, where you can set these parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此方法，因为我们正在尝试在我们的程序中读取命令行参数，这些参数需要在运行时或从属性窗口传递，然后将在运行时读取。参数的传递方式如下。右键单击项目，选择属性，然后导航到调试选项卡，在那里您可以设置这些参数：
- en: '![](img/4ac4b314-42ab-4fc9-9202-4a269dc90c2e.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ac4b314-42ab-4fc9-9202-4a269dc90c2e.png)'
- en: 'When you run the program, as you pass `1` or `2` arguments, the respective
    case statements get executed and the output will be presented on the screen:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序时，如果您传递`1`或`2`个参数，相应的case语句将被执行，输出将显示在屏幕上：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, in the last output, `TryParse` statements are processed, but `Parse`
    will throw an error as follows. Because `Parse` expects a proper string to be
    passed, when a non-string value is passed, or when your statement doesn''t correspond
    to the value passed, it throws an error. However, if we handle this statement
    using `try..catch`, we won''t see any issues. Otherwise, your program will break
    and an exception dialog will appear as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在最后一个输出中，处理了`TryParse`语句，但`Parse`会抛出以下错误。因为`Parse`期望传递一个合适的字符串，当传递非字符串值或当您的语句与传递的值不对应时，它会抛出错误。然而，如果我们使用`try..catch`处理这个语句，我们不会看到任何问题。否则，您的程序将崩溃，并出现以下异常对话框：
- en: '![](img/999810a0-4c08-41ad-b311-f3e7a2a5b81f.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/999810a0-4c08-41ad-b311-f3e7a2a5b81f.png)'
- en: Another way to validate your input is to use the conversion method. `Convert`
    is a method defined in .NET Framework that casts a base type to another base type.
    Unlike `Parse`, `Convert` accepts an object of a type and converts it into another
    type. `Parse` accepts only string input. Also, when a `null` value is passed,
    `Convert` returns the minimum value of the target type. The `Convert` class has
    a few static methods that support conversion to and from different types in .NET
    Framework. Types supported by the `Convert` method are `Boolean`, `Char`, `SByte`,
    `Byte`, `Int16`, `Int32`, `Int64`, `UInt16`, `UInt32`, `UInt64`, `Single`, `Double`,
    `Decimal`, `DateTime`, and `String`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 验证输入的另一种方法是使用转换方法。`Convert`是在.NET Framework中定义的一个方法，它将基本类型转换为另一个基本类型。与`Parse`不同，`Convert`接受一个对象类型并将其转换为另一个类型。`Parse`只接受字符串输入。此外，当传递`null`值时，`Convert`返回目标类型的最小值。`Convert`类有几个静态方法，支持.NET
    Framework中不同类型之间的转换。`Convert`方法支持的类型有`Boolean`、`Char`、`SByte`、`Byte`、`Int16`、`Int32`、`Int64`、`UInt16`、`UInt32`、`UInt64`、`Single`、`Double`、`Decimal`、`DateTime`和`String`。
- en: 'When you apply the `Convert` method, you can expect any of the following output.
    The system either successfully converts the source type to the target type or
    throws one of the following exceptions: `FormatException`, `InvalidCastException`,
    or `ArgumentNull`. Let''s look at an example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您应用`Convert`方法时，可以预期以下任何一种输出。系统要么成功地将源类型转换为目标类型，要么抛出以下异常之一：`FormatException`、`InvalidCastException`或`ArgumentNull`。让我们看一个例子：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we tried to convert different types. The important
    thing to note is that you can get any output while converting, and so you have
    to handle it accordingly in your application code. Also, while converting decimal
    or float values to integers, precise information is lost. However, no exception
    is thrown.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们尝试了不同类型的转换。需要注意的是，在转换过程中可能会得到任何输出，因此您必须在应用程序代码中相应地处理它。此外，在将十进制或浮点值转换为整数时，会丢失精确信息。然而，不会抛出异常。
- en: With same-type conversions, there won't be any exceptions or conversions. `FormatException`
    is thrown when you try to convert a string to any other type. `String` to `Boolean`,
    `String` to `Char`, or `String` to `DateTime` may throw this exception.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同类型的转换中，不会抛出任何异常或进行转换。当尝试将字符串转换为任何其他类型时，会抛出`FormatException`。`String`到`Boolean`、`String`到`Char`或`String`到`DateTime`可能会抛出此异常。
- en: '`InvalidCastException` occurs when a conversion between specific types is not
    valid, as in the following examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当特定类型之间的转换无效时，会发生`InvalidCastException`，如下面的示例所示：
- en: Conversions from `Char` to `Boolean`, `Single`, `Double`, `Decimal`, or `DateTime`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Char`转换为`Boolean`、`Single`、`Double`、`Decimal`或`DateTime`
- en: Conversions from `Boolean`, `Single`, `Double`, `Decimal`, or `DateTime` to
    `Char`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Boolean`、`Single`、`Double`、`Decimal`或`DateTime`转换为`Char`
- en: Conversions from `DateTime` to any other type except `String`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`DateTime`转换为除`String`以外的任何类型
- en: Conversions from any other type, except `String`, to `DateTime`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从除`String`以外的任何类型转换为`DateTime`
- en: '`OverflowException` is thrown in the event of loss of data, for example, when
    converting a huge decimal to an integer, as shown in our example. In our example,
    we are converting a double value to an `int` value. The `int` type variable in
    C# has a minimum and maximum value. If the number passed is outside this range,
    an overflow exception is raised:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据丢失的情况下会抛出`OverflowException`，例如，当将一个巨大的十进制数转换为整数时，如我们的示例所示。在我们的示例中，我们将一个双精度值转换为`int`值。C#中的`int`类型变量有一个最小值和最大值。如果传递的数字超出了这个范围，则会引发溢出异常：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Regular expressions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: When talking about validating input data, it is important to have an understanding
    of regular expressions, which is a powerful way to process text. It employs a
    pattern-matching technique to identify a pattern of text in input texts and validates
    it to the required format. For example, if our application wants to validate an
    email, regular expressions can be used to identify whether the email address provided
    is in a valid format. it checks for `.com`, `@`, and other patterns and returns
    if it matches a required pattern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论验证输入数据时，了解正则表达式非常重要，这是一种强大的文本处理方式。它采用模式匹配技术来识别输入文本中的文本模式，并将其验证到所需格式。例如，如果我们的应用程序想要验证电子邮件，可以使用正则表达式来识别提供的电子邮件地址是否为有效格式。它检查
    `.com`、`@` 和其他模式，并在匹配所需模式时返回。
- en: '`System.Text.RegularExpressions.Regex` acts as a regular expression engine
    in .NET Framework. To use this engine, we need to pass two parameters, the first
    a pattern to match and the second text where this pattern matching happens.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Text.RegularExpressions.Regex` 在 .NET Framework 中充当正则表达式引擎。要使用此引擎，我们需要传递两个参数，第一个是要匹配的模式，第二个是模式匹配发生的文本。'
- en: The regex class comes up with four different methods – `IsMatch`, `Match`, `Matches`,
    and `Replace`. The `IsMatch` method is used to identify a pattern in the input
    text. The `Match` or `Matches` methods are used to get all occurrences of text
    that match a pattern. The `Replace` method replaces text that matches a regular
    expression pattern.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Regex 类提供了四种不同的方法——`IsMatch`、`Match`、`Matches` 和 `Replace`。`IsMatch` 方法用于在输入文本中识别模式。`Match`
    或 `Matches` 方法用于获取与模式匹配的所有文本的实例。`Replace` 方法用于替换与正则表达式模式匹配的文本。
- en: 'Now, let''s jump into some examples to understand regular expressions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一些示例来了解正则表达式：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ReplacePatternTest` method identifies `FirstName` and `LastName` from an
    array of strings and replaces them with an empty string. In the `MatchPatternText`
    method, we identify how many times `Madhav` exists in the string; in the third
    method, we use a pattern to identify a chapter word. The `^c\w+` pattern represents
    the beginning of the word, `c` represents a word starting with *c*, `\w` represents
    any characters, and `+` represents matches with the preceding token.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplacePatternTest` 方法从一个字符串数组中识别 `FirstName` 和 `LastName` 并将它们替换为空字符串。在 `MatchPatternText`
    方法中，我们识别字符串中 `Madhav` 出现的次数；在第三个方法中，我们使用模式来识别章节词。`^c\w+` 模式表示单词的开始，`c` 表示以 *c*
    开头的单词，`\w` 表示任何字符，`+` 表示与前面的标记匹配。'
- en: 'The following output shows the first two lines of the output from the `ReplacePatternTest`
    method, where we replaced `Madhav` with an empty string. The second output set
    identifies a pattern and displays it. The third set is where we identify a chapter
    word in the string:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了 `ReplacePatternTest` 方法的输出前两行，其中我们将 `Madhav` 替换为空字符串。第二个输出集识别一个模式并显示它。第三个集是识别字符串中的章节词：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JSON and XML
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 和 XML
- en: With the extensive use of internet and cloud applications, JSON and XML are
    becoming more important in terms of data transfer between applications. Using
    JSON and XML also increases the number of data-related issues, unless the data
    is validated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网和云应用的广泛使用，JSON 和 XML 在应用程序之间的数据传输方面变得越来越重要。使用 JSON 和 XML 也增加了与数据相关的问题数量，除非数据得到验证。
- en: Schema validation can be used to validate an XML file, which will help us to
    identify whether XML is inline with data types defined. However, to validate the
    actual data, you may still be using the methods we discussed in this chapter.
    Visual Studio helps you to create a schema file. The `Xsd.exe <XML file>` command
    will create a schema file. Here is an example XML file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 模式验证可以用来验证 XML 文件，这将帮助我们确定 XML 是否与定义的数据类型一致。然而，为了验证实际数据，你可能仍然会使用本章中讨论的方法。Visual
    Studio 帮助你创建模式文件。`Xsd.exe <XML file>` 命令将创建一个模式文件。以下是一个示例 XML 文件。
- en: 'This XML file has a `Students` root element, in which information is held in
    relation to multiple students. Each `student` element has child elements that
    hold values including `FirstName`, `LastName`, `School`, and `DOB`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此 XML 文件有一个 `Students` 根元素，其中包含与多个学生相关的信息。每个 `student` 元素都有子元素，包含 `FirstName`、`LastName`、`School`
    和 `DOB` 等值：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Visual Studio allows us to create a schema for this XML. Open the XML file
    in Visual Studio and select the XML menu item. The Create Schema option will become
    available. Selecting this will create a `.xsd` schema:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 允许我们为这个 XML 创建一个模式。在 Visual Studio 中打开 XML 文件并选择 XML 菜单项。将出现创建模式选项。选择此选项将创建一个
    `.xsd` 模式：
- en: '![](img/7e289b05-02e1-4ff8-a351-ca8b86cc67aa.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e289b05-02e1-4ff8-a351-ca8b86cc67aa.png)'
- en: 'The content of the `Sample.xsd` file is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample.xsd`文件的内容如下：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, names are defined as a string, as are dates. So when you access
    this date element, we may need to convert it in order to use it in our application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，名称被定义为字符串，日期也是如此。因此，当您访问这个日期元素时，我们可能需要将其转换以便在应用程序中使用。
- en: 'Now, we will jump to some sample code and observe how to validate an XML file
    using a schema:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将跳转到一些示例代码，观察如何使用模式验证XML文件：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we passed a valid XML file, we did not encounter any issues validating it.
    However, when you try to remove any elements from it, such as removing the school
    from the XML file, then you encounter an error message. Try it yourself when you
    practice this lab so as to understand validation in greater detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们传递了一个有效的XML文件，所以在验证它时我们没有遇到任何问题。然而，当您尝试从其中删除任何元素时，例如从XML文件中删除学校，那么您会遇到错误消息。当您练习这个实验时，请自己尝试，以便更详细地了解验证：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When executed, this method either writes a message on the console to the effect
    that validation is complete, or it may throw an exception in the event of an error
    in the XML.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，此方法要么在控制台上写入一条消息，表明验证已完成，要么在XML出现错误时抛出异常。
- en: Another format we discussed is JSON. .NET Framework provides us with JSON serializers,
    which can be used to validate JSON. This is like creating a C# class, using a
    JSON serializer to convert a C# object to JSON, and then deserializing back to
    the C# object. It is similar to the .NET Framework serialization concept. However,
    not every JSON has a schema to serialize or deserialize. In this case, we will
    work on validating the JSON format. In the following example, we create a class
    serializer to convert a JSON object and then deserialize it back to an object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的另一种格式是JSON。.NET Framework为我们提供了JSON序列化器，可以用来验证JSON。这就像创建一个C#类，使用JSON序列化器将C#对象转换为JSON，然后再将其反序列化回C#对象。它与.NET
    Framework序列化概念类似。然而，并非所有的JSON都有用于序列化或反序列化的模式。在这种情况下，我们将验证JSON格式。在下面的示例中，我们创建了一个类序列化器来转换JSON对象，然后将其反序列化回对象。
- en: 'Here, we are creating a class called `Authors` with three properties: `AuthorName`,
    `Skills`, and `DOB`. We will use this object to serialize and deserialize this
    object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`Authors`的类，具有三个属性：`AuthorName`、`Skills`和`DOB`。我们将使用此对象来序列化和反序列化此对象：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next section, we created a new method where we used the `Newtonsoft.Json`
    namespace to convert the `Authors` object to JSON. You can get `NewtonSoft.Json`
    using NuGet packages:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们创建了一种新方法，其中我们使用了`Newtonsoft.Json`命名空间将`Authors`对象转换为JSON。您可以使用NuGet包来获取`NewtonSoft.Json`：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we will convert JSON to the `Authors` object using the `JSON.Deserialize`
    method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`JSON.Deserialize`方法将JSON转换为`Authors`对象：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Following is the program that invokes both these methods. Initially, we invoke
    the `GetJSON` method to get the `Json` string, and then use this string to convert
    it to an `Authors` object using the `GetObject` method. In the second line, we
    modify the string result that we got in the first line, and try to deserialize
    it. This operation will throw an exception.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是调用这两个方法的程序。最初，我们调用`GetJSON`方法来获取`Json`字符串，然后使用这个字符串通过`GetObject`方法将其转换为`Authors`对象。在第二行，我们修改了第一行中得到的字符串结果，并尝试对其进行反序列化。这个操作将抛出异常。
- en: 'In the following, we are trying to modify the `.json` results by concatenating
    text called `Test`. This is what happens when you modify the `.json` object and
    try to deserialize it to an `Authors` object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们尝试通过连接名为`Test`的文本来修改`.json`结果。这是您修改`.json`对象并尝试将其反序列化为`Authors`对象时发生的情况：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following output shows the `JSON` object that we converted from the `Authors`
    object, followed by the `Author` object that we deserialized from the `JSON` object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示了我们将`Authors`对象转换为的`JSON`对象，随后是我们在`JSON`对象中反序列化的`Author`对象：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the exception that the program throws when we modify `JSON` and try
    to deserialize it to an `Authors` object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们在修改`JSON`并尝试将其反序列化为`Authors`对象时程序抛出的异常：
- en: '![](img/e6e9c06d-4dc9-48a4-b810-3e0b0db40c46.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6e9c06d-4dc9-48a4-b810-3e0b0db40c46.png)'
- en: This is an example where we try to validate a `JSON` object. If it gets modified
    during transmission, this can be identified during the deserialization process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个尝试验证`JSON`对象的示例。如果在传输过程中被修改，这个修改可以在反序列化过程中被识别出来。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood the importance of validating input data; different
    ways of validating input data in our application, including the `Parse` and `Convert`
    methods; and how we can use regular expressions and the data annotations namespace.
    We also looked briefly at how we can validate XML and JSON input.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了验证输入数据的重要性；在我们的应用程序中验证输入数据的不同方法，包括 `Parse` 和 `Convert` 方法；以及我们如何使用正则表达式和数据注释命名空间。我们还简要地探讨了如何验证
    XML 和 JSON 输入。
- en: In the next chapter, we will explore ways to secure our data, such as emails,
    passwords, and API keys, using encryption techniques available in .NET Framework.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用 .NET Framework 中可用的加密技术来保护我们的数据，例如电子邮件、密码和 API 密钥的方法。
- en: Questions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: The `Parse` method always takes the __ type as input
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parse` 方法始终接受 __ 类型作为输入'
- en: Any valid .NET type
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何有效的 .NET 类型
- en: Object
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象
- en: String
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串
- en: None
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无
- en: When converting `DateTime` to `Double`, which exception is thrown?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将 `DateTime` 转换为 `Double` 时，会抛出哪种异常？
- en: No exception is thrown; instead, it gets converted successfully.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不会抛出异常；相反，它会被成功转换。
- en: A Format exception is thrown.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出格式异常。
- en: An Overflow exception is thrown.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出溢出异常。
- en: An Invalid cast exception is thrown.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出无效转换异常。
- en: Information about members of an object can be provided using the ___________
    namespace.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 ___________ 命名空间提供关于对象成员的信息。
- en: '`DataContract`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DataContract`'
- en: '`DataAnnotations`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`数据注释`'
- en: '`System.Reflection`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.Reflection`'
- en: '`System.XML`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.XML`'
- en: Answers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**String**'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: '**An** **Invalid cast exception is thrown**.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**抛出** **无效转换异常**。'
- en: '`DataAnnotations`'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`数据注释`'
