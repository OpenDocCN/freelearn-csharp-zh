- en: '*Chapter 16*: Implementing Multi-Tenancy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 16 章*：实现多租户'
- en: Multi-tenancy is a common pattern to create **Software as a Service** (**SaaS**)
    solutions, where a single deployment can concurrently serve multiple customers.
    Multi-tenancy is one of the fundamental design principles of ABP Framework, so
    all other framework features are multi-tenancy compatible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户是创建 **软件即服务**（**SaaS**）解决方案的常见模式，其中单个部署可以同时为多个客户提供服务。多租户是 ABP 框架的基本设计原则之一，因此所有其他框架功能都是多租户兼容的。
- en: In this chapter, we will start with understanding what a multi-tenant system
    is and how ABP provides a multi-tenant solution to us. Then, we will continue
    with the ABP infrastructure to understand, build, and control the multi-tenancy
    in our applications. We will also learn to design specific application features
    and make different tenants use different application features. At the end of this
    chapter, you will understand the basics of multi-tenancy and will be able to build
    multi-tenant applications using ABP Framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从了解什么是多租户系统以及 ABP 如何为我们提供多租户解决方案开始。然后，我们将继续了解 ABP 基础设施，以理解、构建和控制我们应用程序中的多租户。我们还将学习设计特定的应用程序功能，并使不同的租户使用不同的应用程序功能。在本章结束时，您将了解多租户的基本知识，并能够使用
    ABP 框架构建多租户应用程序。
- en: 'Here is a list of the main topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章涵盖的主要主题列表：
- en: Understanding multi-tenancy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多租户
- en: Working with the ABP multi-tenancy infrastructure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 ABP 多租户基础设施协同工作
- en: Using the feature system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能系统
- en: When to use multi-tenancy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用多租户
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随本章中的示例，您需要一个支持 ASP.NET Core 开发的 IDE/编辑器。
- en: 'You can download the example application from the following GitHub repository:
    [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
    It contains some of the examples given in this chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下 GitHub 仓库下载示例应用程序：[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)。它包含本章中给出的一些示例。
- en: Understanding multi-tenancy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多租户
- en: In this section, you will understand the SaaS and multi-tenancy concepts, the
    main benefits of creating a SaaS solution, and what ABP provides us as a multi-tenant-aware
    framework. Let's start by understanding what a SaaS system provides.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解 SaaS 和多租户概念、创建 SaaS 解决方案的主要好处以及 ABP 作为多租户感知框架为我们提供的内容。让我们首先了解 SaaS
    系统提供的内容。
- en: What is SaaS?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 SaaS？
- en: Building, deploying, and licensing software solutions with the SaaS model has
    become quite popular. Customers typically purchase a SaaS solution with a subscription
    model and use it online without requiring them to download and install it on their
    own servers, which is called on-premises deployment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SaaS 模型构建、部署和许可软件解决方案已经变得相当流行。客户通常以订阅模式购买 SaaS 解决方案，并在网上使用它，无需他们自己下载和安装在自己的服务器上，这被称为本地部署。
- en: 'Building a SaaS solution has these benefits when hosting:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管时构建 SaaS 解决方案具有以下好处：
- en: You can utilize your resources at the maximum level since customers can share
    servers, databases, and other resources.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于客户可以共享服务器、数据库和其他资源，您可以充分利用您的资源。
- en: It is extremely easy and typically automated to add a new customer (tenant)
    to the system.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向系统中添加新客户（租户）非常简单，通常也是自动化的。
- en: It is easier to maintain and upgrade the system compared to separate deployment
    for each customer.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与为每个客户进行单独部署相比，维护和升级系统更容易。
- en: On the other hand, using a SaaS solution benefits customers as well. They pay
    less for software and hosting than with an on-premises deployment. They can pay
    based on how much they use it. They also don't need to care about maintenance
    and upgrades as long as they pay the service costs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用 SaaS 解决方案对客户也有利。与本地部署相比，他们为软件和托管支付的费用更少。他们可以根据使用量付费。只要他们支付服务费用，他们也不必担心维护和升级。
- en: While the SaaS solution benefits hosting, creating a SaaS solution comes with
    some development costs and runtime considerations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SaaS 解决方案对托管有利，但创建 SaaS 解决方案也伴随着一些开发成本和运行时考虑。
- en: SaaS solutions typically share the resources between customers. Some of the
    major shared resources are database, cache, and application servers. Data isolation,
    security, and performance are the main concerns that we should care about when
    sharing resources between customers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SaaS 解决方案通常在客户之间共享资源。一些主要的共享资源包括数据库、缓存和应用服务器。数据隔离、安全和性能是我们应该在客户之间共享资源时应关注的主要问题。
- en: In addition to shared resources, application settings, features, and permissions
    should be customized per customer without affecting each other.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了共享资源外，应用程序设置、功能和权限应根据客户进行定制，而不会相互影响。
- en: As we now understand the benefits and challenges of building SaaS solutions,
    let's talk a bit about multi-tenancy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在理解了构建 SaaS 解决方案的好处和挑战，让我们简单谈谈多租户。
- en: What is multi-tenancy?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是多租户？
- en: Multi-tenancy is an architectural pattern to create SaaS solutions. It defines
    and controls how customers access resources securely and efficiently and how the
    application is customized per customer easily.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户是一种创建 SaaS 解决方案的建筑模式。它定义并控制客户如何安全有效地访问资源，以及如何轻松地为每个客户定制应用程序。
- en: ABP Framework provides a complete multi-tenancy infrastructure. It defines how
    your application and domain code should be designed, how you access shared resources
    (such as databases and caches), how you customize the application configuration
    per customer, and so on. It not only defines but automates wherever possible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架提供了一个完整的多租户基础设施。它定义了你的应用程序和领域代码应该如何设计，你如何访问共享资源（如数据库和缓存），你如何根据客户定制应用程序配置，等等。它不仅定义了，而且在可能的情况下还实现了自动化。
- en: 'There are two sides of a multi-tenant system:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户系统有两个方面：
- en: '**Tenant**: A customer that uses the system and pays for it. A customer has
    its own users and data, which are isolated from other tenants.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**租户**：使用系统并为其付费的客户。客户有自己的用户和数据，这些用户和数据与其他租户隔离。'
- en: '**Host**: The company that manages the system and the tenants.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：管理和租户的系统公司。'
- en: You can have separate applications for tenant and host users, or you can build
    a single application that makes some application features available only for tenant
    users or only for host users. The ABP startup solution template uses the second
    approach since it is easier to develop and deploy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为租户和主机用户拥有单独的应用程序，或者你可以构建一个单一的应用程序，其中一些应用程序功能仅对租户用户或仅对主机用户可用。ABP 启动解决方案模板采用第二种方法，因为它更容易开发和部署。
- en: The next section discusses how databases are shared or separated for different
    tenants.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论如何为不同租户共享或分离数据库。
- en: The database architecture
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库架构
- en: 'One of the most fundamental design decisions of a multi-tenant system is how
    to share or separate the databases of different tenants. There are three common
    approaches:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户系统最基本的设计决策之一是如何共享或分离不同租户的数据库。有三种常见的方法：
- en: '**Single database**: All data of all tenants is stored in a single, shared
    database. In this case, you should take care when isolating data of different
    tenants since the database tables are shared.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单数据库**：所有租户的所有数据都存储在一个单一、共享的数据库中。在这种情况下，你应该在隔离不同租户的数据时格外小心，因为数据库表是共享的。'
- en: '**Database (or schema) per tenant**: Every tenant has its own dedicated database.
    You should dynamically connect to the database for the tenant of the current user.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库（或模式）每个租户**：每个租户都有自己的专用数据库。你应该动态连接到当前用户的租户数据库。'
- en: '**Hybrid**: A mixed approach where some tenants have their own database while
    others are grouped in one or more databases.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：一种混合方法，其中一些租户拥有自己的数据库，而其他租户则被分组在一个或多个数据库中。'
- en: ABP supports the hybrid approach at the framework level by allowing every tenant
    to have a separate database connection string. However, the startup template and
    the open source tenant management module come with the single-database model.
    If you want to use the database per tenant or the hybrid approach, you should
    customize the tenant management module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 通过允许每个租户拥有单独的数据库连接字符串，在框架级别支持混合方法。然而，启动模板和开源租户管理模块都附带单数据库模型。如果你想使用每个租户的数据库或混合方法，你应该定制租户管理模块。
- en: 'The following figure visualizes the main components of the ABP multi-tenancy
    infrastructure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 ABP 多租户基础设施的主要组件：
- en: '![Figure 16.1 – ABP Framework multi-tenancy in brief'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.1 – ABP 框架多租户概述'
- en: '](img/Figure_16.1_B17287.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_16.1_B17287.jpg]'
- en: Figure 16.1 – ABP Framework multi-tenancy in brief
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – ABP 框架多租户概述
- en: ABP Framework's goal is to automate the multi-tenancy-related logic as much
    as possible and make your application code multi-tenancy-unaware. ABP resolves
    the current tenant from the HTTP request. It can determine the tenant from the
    domain (or subdomain) name, cookie, HTTP header, and other parameters. Then, it
    uses the current tenant information to automatically select the right connection
    if the tenant has a separate connection string. If the tenant uses a shared database,
    it automatically filters the data so that a tenant doesn't accidentally access
    another tenant's data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架的目标是尽可能自动化与多租户相关的逻辑，并使您的应用程序代码不感知多租户。ABP从HTTP请求中解析当前租户。它可以从域名（或子域名）、cookie、HTTP头和其他参数中确定租户。然后，它使用当前租户信息自动选择正确的连接，如果租户有单独的连接字符串。如果租户使用共享数据库，它将自动过滤数据，以确保租户不会意外访问另一个租户的数据。
- en: We can now start working with the ABP multi-tenancy infrastructure, as we've
    learned about multi-tenancy and ABP's fundamental multi-tenancy logic overall.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始使用ABP多租户基础设施了，因为我们已经了解了多租户和ABP的基本多租户逻辑。
- en: Working with the ABP multi-tenancy infrastructure
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与ABP多租户基础设施一起工作
- en: In this section, we will explore the basic infrastructure and features of the
    ABP multi-tenancy system. You will learn how ABP understands the current tenant
    and isolates the tenant data, how you can get information about the current tenant,
    and how to switch between tenants. But first, we will start with how you can disable
    multi-tenancy if you don't need it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨ABP多租户系统的基本基础设施和功能。您将了解ABP如何理解当前租户并隔离租户数据，如何获取有关当前租户的信息，以及如何在租户之间切换。但首先，我们将从如何在不使用它的情况下禁用多租户开始。
- en: Enabling and disabling multi-tenancy
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和禁用多租户
- en: 'The ABP startup solution template comes with multi-tenancy enabled by default.
    The startup solution has a single point that you can use to easily enable or disable
    multi-tenancy. Find the `MultiTenancyConsts` class inside the `.Domain.Shared`
    project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ABP启动解决方案模板默认启用多租户。启动解决方案有一个单点，您可以使用它轻松地启用或禁用多租户。在`.Domain.Shared`项目中找到`MultiTenancyConsts`类：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can set the `IsEnabled` value to `false` to disable multi-tenancy. This
    constant is used in a few places in the solution. It is used to set the `AbpMultiTenancyOptions.IsEnabled`
    option in the `.Domain` project''s module class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`IsEnabled`值设置为`false`来禁用多租户功能。此常量在解决方案的几个地方被使用。它用于在`.Domain`项目模块类中设置`AbpMultiTenancyOptions.IsEnabled`选项：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ABP uses `AbpMultiTenancyOptions.IsEnabled` to enable or disable multi-tenancy-related
    features, pages, and components. If you set `MultiTenancyConsts.IsEnabled` to
    `false` and run the application, you won't see the tenant switch box on the login
    form and the tenant management page on the main menu anymore. However, the multi-tenancy-related
    database tables are not removed. The next section explains how to do it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ABP使用`AbpMultiTenancyOptions.IsEnabled`来启用或禁用与多租户相关的功能、页面和组件。如果您将`MultiTenancyConsts.IsEnabled`设置为`false`并运行应用程序，您将不再在登录表单上看到租户切换框和在主菜单上的租户管理页面。然而，与多租户相关的数据库表不会被删除。下一节将解释如何进行删除。
- en: Removing multi-tenancy tables
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除多租户表
- en: Disabling multi-tenancy doesn't remove the multi-tenancy-related database tables
    from the database. You can leave this as it is (they will already be empty/not
    used). This way, you can easily enable it for your application later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用多租户不会从数据库中删除与多租户相关的数据库表。您可以保持原样（它们已经为空/未使用）。这样，您可以轻松地在以后为您的应用程序启用它。
- en: 'If you don''t want the multi-tenancy-related tables in your database, find
    the following line in the `DbContext` class in the `.EntityFramework` project
    and remove it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想在数据库中保留与多租户相关的表，请在`.EntityFramework`项目的`DbContext`类中找到以下行并将其删除：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, remove the implementation of the `ITenantManagementDbContext` interface
    from your `DbContext` class. You need to remove the `Tenants` and `TenantConnectionStrings`
    `DbSet` properties from the class. Finally, remove the `[ReplaceDbContext(typeof(ITenantManagementDbContext))]`
    attribute from the `DbContext` class declaration. These changes remove the tenant
    management module's tables from your database schema.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从您的`DbContext`类中删除`ITenantManagementDbContext`接口的实现。您需要从类中删除`Tenants`和`TenantConnectionStrings`
    `DbSet`属性。最后，从`DbContext`类声明中删除`[ReplaceDbContext(typeof(ITenantManagementDbContext))]`属性。这些更改将租户管理模块的表从您的数据库模式中删除。
- en: 'You can add a new database migration to remove the tables from the database.
    Run the following command in the root directory of the `.EntityFramework` project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`.EntityFramework`项目的根目录中运行以下命令来添加一个新的数据库迁移，以从数据库中删除表：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, run the following command to apply changes to the database:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令以将更改应用到数据库：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this way, your database won't include multi-tenancy-related tables. You can
    also remove the `Volo.Abp.TenantManagement.*` NuGet packages from the projects
    in the solution and the code parts using these packages. However, all these are
    optional. I suggest you keep them if you think you may enable multi-tenancy for
    your application later because they have no functionality as long as the `AbpMultiTenancyOptions.IsEnabled`
    option is set to `false`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您的数据库将不会包含与多租户相关的表。您还可以从解决方案中的项目以及使用这些包的代码部分中删除`Volo.Abp.TenantManagement.*`
    NuGet包。然而，这些都是可选的。我建议您保留它们，如果您认为您可能以后会为您的应用程序启用多租户，因为只要将`AbpMultiTenancyOptions.IsEnabled`选项设置为`false`，它们就没有任何功能。
- en: As you've seen, enabling/disabling multi-tenancy with ABP Framework is just
    a single line of change. If you decide to develop your application as multi-tenancy-enabled,
    you can continue with the next section to understand how ABP determines the current
    tenant from HTTP requests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用ABP框架启用/禁用多租户只需一行更改。如果您决定将应用程序作为多租户启用来开发，您可以继续下一节，了解ABP如何从HTTP请求中确定当前租户。
- en: Determining the current tenant
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定当前租户
- en: If you look at *Figure 16.1* again, you will see that all the requests coming
    from the users are passing through the tenant resolution component before executing
    the application code. This way, the current tenant becomes known inside your application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次查看*图16.1*，您将看到所有来自用户的请求在执行应用程序代码之前都通过了租户解析组件。这样，当前租户就可在您的应用程序中知道了。
- en: 'Intercepting the incoming requests is done with ABP''s multi-tenancy middleware
    component. All the hosting projects in the startup solution template contain the
    following lines in the `OnApplicationInitialization` method of the ABP module
    class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ABP的多租户中间件组件拦截传入的请求。启动解决方案模板中的所有托管项目在ABP模块类的`OnApplicationInitialization`方法中都包含以下行：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This middleware is added after the authentication middleware (because the user's
    authentication ticket is used on tenant resolution) and before the authorization
    middleware (because ABP authorizes users based on their tenants).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件是在身份验证中间件之后（因为用户身份验证票据用于租户解析）和授权中间件之前（因为ABP根据用户的租户授权用户）添加的。
- en: The multi-tenancy middleware resolves the current tenant from the HTTP request
    and sets the `ICurrentTenant` properties that are used to obtain the current tenant
    information. The `ICurrentTenant` interface will be explained in the next section,
    but we should first understand how ABP determines the current tenant from the
    HTTP request.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户中间件从HTTP请求中解析当前租户，并设置用于获取当前租户信息的`ICurrentTenant`属性。`ICurrentTenant`接口将在下一节中解释，但我们应该首先了解ABP如何从HTTP请求中确定当前租户。
- en: 'The current tenant information is obtained from the current HTTP request using
    request parameters in the following order:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当前租户信息是通过以下顺序使用当前HTTP请求中的请求参数获得的：
- en: If the user (or client) has authenticated, then the current tenant's ID and
    name are extracted from the claims in the authentication ticket (either in the
    cookie or in the header, based on the authentication method).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户（或客户端）已通过身份验证，则当前租户的ID和名称将从身份验证票据中的声明中提取（根据身份验证方法，可能在cookie中或在header中）。
- en: If `AbpTenantResolveOptions` is configured, the tenant's name is determined
    from the domain (or subdomain) name.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已配置`AbpTenantResolveOptions`，则从域名（或子域名）中确定租户的名称。
- en: The `__tenant` query string parameter is used to get the tenant's name or ID
    if the current HTTP request contains that parameter.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前HTTP请求包含该参数，则使用`__tenant`查询字符串参数来获取租户的名称或ID。
- en: The `__tenant` route parameter is used to get the tenant's name or ID if the
    current HTTP request contains that parameter.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前HTTP请求包含该参数，则使用`__tenant`路由参数来获取租户的名称或ID。
- en: The `__tenant` HTTP header is used to get the tenant's name or ID if the current
    HTTP request contains that parameter.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前HTTP请求包含该参数，则使用`__tenant` HTTP头获取租户的名称或ID。
- en: The `__tenant` cookie's value is used to get the tenant's name or ID if the
    current HTTP request contains that parameter.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前HTTP请求包含该参数，则使用`__tenant` cookie的值获取租户的名称或ID。
- en: If ABP determines the tenant in any of the preceding steps, it doesn't continue
    to other steps as you might expect. If none of the information is found in the
    HTTP request, then it is assumed that the current user is a host user. All the
    options are already preconfigured and working when you create a new solution,
    so you typically do not make many configurations for your solution. You should
    only care about the domain name resolution, which is suggested in the production
    environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ABP在之前的任何步骤中确定了租户，它不会像您预期的那样继续到其他步骤。如果HTTP请求中没有找到任何信息，那么就假设当前用户是主机用户。所有选项在您创建新解决方案时都已经预先配置并正常工作，所以您通常不需要为您的解决方案进行很多配置。您应该只关注域名解析，这在生产环境中是建议的。
- en: 'The following example shows how to configure the domain name resolver in the
    `ConfigureServices` method of your module class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在模块类的`ConfigureServices`方法中配置域名解析器：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `AddDomainTenantResolver` method accepts a domain format where the `{0}`
    part matches the tenant name. This means if your tenant's name (the `Name` property
    of the `Tenant` class) is `acme`, then the `acme` users should use the `acme.yourdomain.com`
    URL to enter the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDomainTenantResolver`方法接受一个域名格式，其中`{0}`部分与租户名称匹配。这意味着如果您的租户名称（`Tenant`类的`Name`属性）是`acme`，那么`acme`用户应该使用`acme.yourdomain.com`
    URL来进入应用程序。'
- en: Once ABP resolves the tenant, we can work with the current tenant, as explained
    in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ABP解决了租户问题，我们就可以像下一节中解释的那样与当前租户一起工作。
- en: Working with the current tenant
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与当前租户一起工作
- en: 'ABP determines the tenant before executing our application code, as we''ve
    learned in the previous section. We can get the current tenant''s information
    using the `ICurrentTenant` service. The following example demonstrates how to
    use the `ICurrentTenant` service in an arbitrary class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ABP在执行我们的应用程序代码之前就确定了租户，正如我们在上一节中学到的。我们可以使用`ICurrentTenant`服务来获取当前租户的信息。以下示例演示了如何在任意类中使用`ICurrentTenant`服务：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ve injected the `ICurrentTenant` service and accessed the `Id` and `Name`
    properties in the example method. The `Id` and `Name` properties return `null`
    if the current user is a host user (which means that the tenant is not available).
    Some ABP base classes already pre-inject the `ICurrentTenant` service, so you
    can directly use the `CurrentTenant` property, as shown in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例方法中，我们已经注入了`ICurrentTenant`服务并访问了`Id`和`Name`属性。如果当前用户是主机用户（这意味着租户不可用），`Id`和`Name`属性将返回`null`。一些ABP基类已经预先注入了`ICurrentTenant`服务，因此您可以直接使用`CurrentTenant`属性，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the `ApplicationService` base class already has the `CurrentTenant` property
    (of the `ICurrentTenant` type), we can use it directly without manual injection.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ApplicationService`基类已经具有`CurrentTenant`属性（`ICurrentTenant`类型），我们可以直接使用它，无需手动注入。
- en: '`ICurrentTenant` has no more important properties. If you need to get more
    information/data for the current tenant, you have the tenant''s `Id` property
    to query from the database.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICurrentTenant`没有更多重要的属性。如果您需要获取当前租户的更多信息/数据，您可以使用租户的`Id`属性从数据库中查询。'
- en: Most of the time, your application code will work with the current tenant. But
    sometimes, you may need to change the current tenant, as explained in the next
    section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，您的应用程序代码将与当前租户一起工作。但有时，您可能需要更改当前租户，下一节将解释这一点。
- en: Switching between tenants
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在租户之间切换
- en: 'The `ICurrentTenant` service is also used by ABP Framework to isolate the current
    tenant''s data automatically so that you don''t accidentally access other tenant
    data. However, in some cases, you may need to work with another tenant''s data
    in the same HTTP request and temporarily switch the tenant. The `ICurrentTenant`
    service is not only used to get information about the current tenant but also
    to switch to the desired tenant. See the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICurrentTenant`服务也被ABP框架用于自动隔离当前租户的数据，这样您就不会意外地访问其他租户的数据。然而，在某些情况下，您可能需要在同一HTTP请求中处理另一个租户的数据并临时切换租户。`ICurrentTenant`服务不仅用于获取当前租户的信息，还用于切换到所需的租户。请参阅以下示例：'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you use the `CurrentTenant.Id` property before the `using` block, you get
    the tenant's ID that was resolved, as explained in the *Determining the current
    tenant* section. The `CurrentTenant.Change` method changes the current tenant
    to a given value, so you get the desired tenant's ID when using the `CurrentTenant.Id`
    property inside the `using` block. For example, if you perform a database query
    from a shared database inside the `using` block, ABP will retrieve the desired
    tenant's data instead of the one resolved by the multi-tenancy middleware. Once
    the `using` block completes, `CurrentTenant.Id` is automatically restored to the
    previous value. You can safely use the `CurrentTenant.Change` method in a nested
    way when you rarely need it. If you want to switch to the host context, you can
    pass a `null` value to the `Change` method. Always use the `Change` method with
    a `using` block, as in this example, to not affect the surrounding context of
    your method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`using`块之前使用`CurrentTenant.Id`属性，您将获得已解析的租户ID，如“确定当前租户”部分中所述。`CurrentTenant.Change`方法将当前租户更改为给定值，因此在`using`块内部使用`CurrentTenant.Id`属性时，您将获得所需的租户ID。例如，如果您在`using`块内部从共享数据库中执行数据库查询，ABP将检索所需的租户数据而不是多租户中间件解析的租户数据。一旦`using`块完成，`CurrentTenant.Id`将自动恢复到之前的值。当您很少需要时，可以安全地以嵌套方式使用`CurrentTenant.Change`方法。如果您想切换到主机上下文，可以将`null`值传递给`Change`方法。始终像在这个示例中一样使用`using`块与`Change`方法一起使用，以避免影响您的方法的周围上下文。
- en: In addition to switching to the desired tenant, it is also possible to completely
    disable the tenant isolation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了切换到所需的租户之外，还可以完全禁用租户隔离。
- en: Disabling the data isolation
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用数据隔离
- en: Data isolation is critical in a multi-tenant application. It guarantees to query
    only the current tenant's data. However, in some cases, your application may require
    querying from the entire database, including all tenants' data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据隔离在多租户应用程序中至关重要。它保证了只查询当前租户的数据。然而，在某些情况下，您的应用程序可能需要查询整个数据库，包括所有租户的数据。
- en: 'We explored the ABP''s data filtering system in the *Using the data filtering
    system* section of [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using
    the Features and Services of ABP*. ABP uses the same data-filtering system to
    filter data of the current tenant. So, we can use the same data-filtering API
    to disable the multi-tenancy filter temporarily:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)的“使用数据过滤系统”部分中探讨了ABP的数据过滤系统，*使用ABP的功能和服务*。ABP使用相同的数据过滤系统来过滤当前租户的数据。因此，我们可以使用相同的数据过滤API临时禁用多租户过滤器：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are getting the total number of products owned by all the
    tenants in the database. The multi-tenancy data filter is disabled in the `using`
    block, so the repository works with all the records in the database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在获取数据库中所有租户拥有的产品总数。在`using`块中禁用了多租户数据过滤器，因此存储库与数据库中的所有记录一起工作。
- en: While disabling the multi-tenancy filter is pretty easy, there is an important
    limitation – it only works with the single database approach. It cannot query
    a tenant's data if the tenant has a dedicated database. Currently, there is no
    direct way to perform a query on multiple databases and aggregate the query results
    as a single result set.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然禁用多租户过滤器相对简单，但存在一个重要的限制——它仅适用于单数据库方法。如果租户有专用数据库，则无法查询租户数据。目前，没有直接的方法可以对多个数据库执行查询并将查询结果聚合为单个结果集。
- en: Besides the technical limitation, there is also a design problem with querying
    all tenants' data. Ideally, multi-tenant software should be designed so that all
    tenants have their on-premises deployment with separate database and application
    servers. We will return to this discussion later in the *When to use multi-tenancy*
    section of this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技术限制之外，查询所有租户数据的设计也存在问题。理想情况下，多租户软件应该设计成每个租户都有自己的本地部署，包括独立的数据库和应用服务器。我们将在本章的“何时使用多租户”部分稍后回到这个讨论。
- en: We've learned the ways to access and change the current tenant. In the next
    section, we will see how to design our entities to be multi-tenancy-compatible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了访问和更改当前租户的方法。在下一节中，我们将看到如何设计我们的实体以实现多租户兼容性。
- en: Designing the domain as multi-tenant
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将域设计为多租户
- en: 'ABP aims to make your application code multi-tenancy-unaware and automate things
    wherever possible. Designing an entity class as multi-tenant is very simple. Just
    implement the `IMultiTenant` interface for your entity, as shown in the following
    example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ABP旨在使你的应用程序代码不感知多租户，并在可能的情况下自动化处理。将实体类设计为多租户非常简单。只需为你的实体实现`IMultiTenant`接口，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Product` aggregate root entity in this example implements the `IMultiTenant`
    interface and defines a `TenantId` property. The tenant identifier type is always
    `Guid` in ABP Framework. The `TenantId` property is nullable, making the `Product`
    entity available both for the tenant and the host side. If the `TenantId` property
    is `null`, that entity belongs to the host side. It also allows us to easily convert
    our application to a single-tenant, on-premises application where the `TenantId`
    property is always `null`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的`Product`聚合根实体实现了`IMultiTenant`接口，并定义了一个`TenantId`属性。在ABP框架中，租户标识类型始终是`Guid`。`TenantId`属性是可空的，这使得`Product`实体既可用于租户端，也可用于主机端。如果`TenantId`属性为`null`，则该实体属于主机端。这也允许我们轻松地将我们的应用程序转换为单租户、本地应用程序，其中`TenantId`属性始终为`null`。
- en: ABP automatically sets the `TenantId` value using the `ICurrentTenant.Id` property
    when you create a new entity object (a `Product` object for this example). ABP
    is also responsible for saving it to the right database and querying from the
    right database, or filtering the tenant data if you are using a single database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的实体对象（例如，一个`Product`对象）时，ABP会自动使用`ICurrentTenant.Id`属性设置`TenantId`值。ABP还负责将其保存到正确的数据库，或从正确的数据库查询，或者如果你使用的是单个数据库，则过滤租户数据。
- en: We've learned the fundamental points of building a multi-tenant solution with
    ABP Framework. The next section introduces the ABP feature system that can be
    used to restrict application functionalities for tenants.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用ABP框架构建多租户解决方案的基本要点。下一节介绍了ABP特性系统，它可以用来限制租户的应用程序功能。
- en: Using the feature system
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特性系统
- en: Most SaaS solutions provide different packages to the customers. Every package
    has a different set of application features and is subscribed at a different price.
    ABP provides a feature system used to define such application features, and then
    disable or enable these features for individual tenants. Let's start by defining
    a feature.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数SaaS解决方案为顾客提供不同的套餐。每个套餐都有一组不同的应用程序特性，并且以不同的价格订阅。ABP提供了一个用于定义此类应用程序特性的特性系统，然后为单个租户禁用或启用这些特性。让我们先定义一个特性。
- en: Defining the features
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义特性
- en: 'It is required to define a feature before using it. Create a new class deriving
    from the `FeatureDefinitionProvider` class (typically in the `.Application.Contracts`
    project in the startup solution) and override the `Define` method, as shown in
    the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前需要定义一个特性。创建一个新的类，从`FeatureDefinitionProvider`类派生（通常在启动解决方案中的`.Application.Contracts`项目中），并重写`Define`方法，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Features are grouped to create more modular systems (where every module defines
    its own group). In this example, I created a feature group for the final application.
    Then, I defined two features under that group. This example defines the two features:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 特性被分组以创建更模块化的系统（其中每个模块定义其自己的组）。在这个例子中，我为最终应用程序创建了一个特性组。然后，我在该组下定义了两个特性。本例定义了这两个特性：
- en: The first one is used to enable or disable the stock management feature for
    tenants.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个用于为租户启用或禁用库存管理特性。
- en: The second one is used to limit the product entity count.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个用于限制产品实体的数量。
- en: Feature values are actually just strings, such as `false` and `100` in this
    example. However, Boolean values (`true` and `false`) can be used for conditional
    checks by convention.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 特性值实际上是字符串，例如本例中的`false`和`100`。然而，根据惯例，布尔值（`true`和`false`）可以用于条件检查。
- en: ABP automatically discovers classes derived from the `FeatureDefinitionProvider`
    class, so you don't need to register it somewhere. After defining a feature, we
    can check its value for the current tenant (we will see how to assign features
    to tenants later, in the *Managing tenant features* section).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ABP会自动发现从`FeatureDefinitionProvider`类派生的类，因此你不需要在某个地方注册它。定义特性后，我们可以检查当前租户的特性值（我们将在*管理租户特性*部分中看到如何将特性分配给租户）。
- en: Checking for the features
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查特性
- en: I will show you how to enable, disable, or set the value of a feature for a
    tenant in the *Managing tenant features* section. But first, I want to show you
    how we check a feature's value for a tenant.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在 *管理租户功能* 部分向您展示如何为租户启用、禁用或设置功能的值。但首先，我想向您展示我们如何检查租户的功能值。
- en: There are several ways to check a feature's value for the current tenant. The
    easiest way is to use the `RequiresFeature` attribute that can be used on methods
    or classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以检查当前租户的功能值。最简单的方法是使用可以用于方法或类的 `RequiresFeature` 属性。
- en: Using the RequiresFeature attribute
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `RequiresFeature` 属性
- en: 'The following example uses the `RequiresFeature` attribute to restrict a class''s
    usage for the current tenant:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `RequiresFeature` 属性来限制当前租户对类的使用：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This way, the `MyApp.StockManagement` feature's value is automatically checked
    in every method call for the `StockAppService` service, and an exception is thrown
    for unauthorized access.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`MyApp.StockManagement` 功能的值会在每次调用 `StockAppService` 服务的 `StockAppService`
    方法时自动检查，并且对于未经授权的访问会抛出异常。
- en: 'The `RequiresFeature` attribute can also be used on a method. See the following
    example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequiresFeature` 属性也可以用于方法上。请参见以下示例：'
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, only the `GetStockCountAsync` method is restricted, and the other
    methods of `ProductAppService` without the `RequiresFeature` attribute are not
    affected.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有 `GetStockCountAsync` 方法受到限制，而 `ProductAppService` 的其他没有 `RequiresFeature`
    属性的方法不受影响。
- en: The `RequiresFeature` attribute is easy to use but limited to Boolean features
    (with `true` and `false` values). For detailed usage, we should use the `IFeatureChecker`
    service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequiresFeature` 属性易于使用，但仅限于布尔功能（具有 `true` 和 `false` 值）。对于详细使用，我们应该使用 `IFeatureChecker`
    服务。'
- en: Using the IFeatureChecker service
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IFeatureChecker 服务
- en: 'The `IFeatureChecker` service allows us to get and check the feature values
    programmatically. You can inject it just like any other service. The following
    example checks whether the `MyApp.StockManagement` feature is enabled for the
    current tenant:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFeatureChecker` 服务允许我们以编程方式获取和检查功能值。您可以像注入任何其他服务一样注入它。以下示例检查 `MyApp.StockManagement`
    功能是否为当前租户启用：'
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `IsEnabled` method returns `true` only if the feature''s value is `true`
    (as `string`). If you have fallback logic (when the tenant doesn''t have that
    feature enabled), then using `IsEnabledAsync` is a good approach. However, if
    you only want to check whether a feature is enabled and should throw an exception
    otherwise, use the `CheckEnabledAsync` method, as shown in the following example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsEnabled` 方法仅在功能值为 `true`（作为 `string`）时返回 `true`。如果您有回退逻辑（当租户未启用该功能时），则使用
    `IsEnabledAsync` 是一个好的方法。但是，如果您只想检查功能是否启用，并在其他情况下抛出异常，请使用 `CheckEnabledAsync`
    方法，如下所示：'
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `CheckEnabledAsync` method throws `AbpAuthorizationException` if the given
    feature is not enabled for the current tenant. However, if you need to simply
    check whether a feature is enabled or disabled at the beginning of the method,
    using the `RequiresFeature` attribute would be simpler.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckEnabledAsync` 方法如果给定的功能对于当前租户未启用，则会抛出 `AbpAuthorizationException`。然而，如果您需要在方法开始时简单地检查一个功能是否启用或禁用，使用
    `RequiresFeature` 属性会更简单。'
- en: Using the `IFeatureChecker` service is especially useful when you want to get
    the value of non-Boolean features. For example, the `MyApp.MaxProductCount` feature
    introduced in the *Defining the features* section is a numeric feature. We can't
    simply check whether it is enabled or disabled. We need to know its value for
    the current user.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IFeatureChecker` 服务在您想获取非布尔功能的值时特别有用。例如，在 *定义功能* 部分中引入的 `MyApp.MaxProductCount`
    功能是一个数值功能。我们无法简单地检查它是否启用或禁用。我们需要知道当前用户的功能值。
- en: 'The following example checks the maximum allowed product count for the current
    tenant before creating a new product:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在创建新产品之前检查当前租户允许的最大产品数量：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `FeatureChecker.GetAsync<T>` method returns the value of the given feature
    by converting to the given generic type argument. Here, `MyApp.MaxProductCount`
    is a numeric feature, so I am converting to `int` and then comparing it with the
    current product count of the current tenant. `IFeatureChecker` also defines the
    `GetOrNullAsync` method that returns the string value of the feature or returns
    `null` if the feature has no value defined for the current tenant.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeatureChecker.GetAsync<T>` 方法通过转换为给定的泛型类型参数来返回给定功能的值。在这里，`MyApp.MaxProductCount`
    是一个数值功能，所以我将其转换为 `int` 并与当前租户的产品数量进行比较。`IFeatureChecker` 还定义了 `GetOrNullAsync`
    方法，该方法返回功能的字符串值，如果该功能未为当前租户定义值，则返回 `null`。'
- en: Checking the Feature of Another Tenant
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查其他租户的功能
- en: The `IFeatureChecker` service works for the current tenant. If you want to check
    a feature's value for another tenant when you have the other tenant's ID, first
    switch to the target tenant, as explained in the *Switching between tenants* section,
    and then use the `IFeatureChecker` service as normal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFeatureChecker` 服务适用于当前租户。如果你有其他租户的 ID，并且想要检查该租户的功能值，首先切换到目标租户，如 *在租户之间切换*
    部分所述，然后正常使用 `IFeatureChecker` 服务。'
- en: The `RequiresFeature` attribute and the `IFeatureChecker` service are used on
    the server side, but we also need to get and check feature values in our client
    applications.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequiresFeature` 属性和 `IFeatureChecker` 服务在服务器端使用，但我们也需要在我们的客户端应用程序中获取和检查功能值。'
- en: Checking features on the client side
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在客户端检查功能
- en: When you define a feature, you will need to know its value on the client side.
    For example, if the `MyApp.StockManagement` feature is not enabled for the current
    tenant, you generally want to hide the related UI elements from the application
    pages and disable the client-to-server HTTP API calls for this feature.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个功能时，你需要知道它在客户端的值。例如，如果 `MyApp.StockManagement` 功能对当前租户未启用，你通常希望从应用程序页面中隐藏相关的
    UI 元素，并禁用针对此功能的客户端到服务器的 HTTP API 调用。
- en: 'ABP provides multiple UI options, and each one provides a different API to
    check the features on the client side. For example, the ABP MVC/Razor Pages UI
    provides the global `abp.features` JavaScript API to check the features, as shown
    in the following code block:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 提供了多个 UI 选项，每个选项都提供了一个不同的 API 来在客户端检查功能。例如，ABP MVC/Razor Pages UI 提供了全局的
    `abp.features` JavaScript API 来检查功能，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Please see the *Checking the tenant features* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, for more details about the `abp.features` JavaScript
    API.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [*第 12 章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356) 的 *检查租户功能* 部分，*使用 MVC/Razor
    Pages*，以了解更多关于 `abp.features` JavaScript API 的详细信息。
- en: 'The ABP Blazor UI, on the other hand, uses the same `IFeatureChecker` service
    on the client side. For other UI types, please refer to ABP''s documentation:
    [https://docs.abp.io/en/abp/latest/Features](https://docs.abp.io/en/abp/latest/Features).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，ABP Blazor UI 在客户端使用相同的 `IFeatureChecker` 服务。对于其他 UI 类型，请参阅 ABP 的文档：[https://docs.abp.io/en/abp/latest/Features](https://docs.abp.io/en/abp/latest/Features)。
- en: You've now learned how to get and check a feature's value for the current tenant.
    The next section explains how you can set the value of a feature for a tenant.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何获取和检查当前租户的功能值。下一节将解释如何为租户设置功能的值。
- en: Managing tenant features
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理租户功能
- en: At a framework level, ABP doesn't care where the feature values are stored and
    how they are changed. It just defines an interface, `IFeatureStore`, that can
    be implemented to obtain the current value of a feature. However, it would not
    be good to leave its implementation to every developer because, most of the time,
    the implementation will be similar, and we don't want to waste our time re-implementing
    it again and again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架层面，ABP 不关心功能值存储在哪里以及如何更改。它只定义了一个接口，`IFeatureStore`，可以用来获取功能的当前值。然而，将其实现留给每个开发者并不是一个好的选择，因为大多数情况下，实现将是相似的，我们不希望浪费时间一次又一次地重新实现它。
- en: ABP Framework provides the `IFeatureStore` interface and provides a UI and API
    to modify the feature values for the tenants. The Feature Management module is
    already installed when you create a new solution using ABP's startup solution
    template. The following sections explain the Feature Management UI modal and the
    API to manage the feature values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架提供了`IFeatureStore`接口，并提供了UI和API来修改租户的特征值。当您使用ABP的启动解决方案模板创建新解决方案时，特征管理模块已经安装。以下部分解释了特征管理UI模态和用于管理特征值的API。
- en: Using the Feature Management UI modal
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用特征管理UI模态
- en: 'The Feature Management module can automatically create the modal dialog to
    set the feature values. However, we need to define the value type for each feature.
    Return to `MyFeatureDefinitionProvider` and update the feature definitions as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 特征管理模块可以自动创建设置特征值的模态对话框。然而，我们需要为每个特征定义值类型。返回到`MyFeatureDefinitionProvider`并更新特征定义如下：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I added `valueType` parameters to the `AddFeature` methods. The first one is
    `ToggleStringValueType`, which indicates that the feature has an on/off style
    (Boolean) value. The second one is `FreeTextStringValueType`, which indicates
    that the feature has a value that should be changed with a textbox. `NumericValueValidator`
    specifies the validation rule for the value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`AddFeature`方法中添加了`valueType`参数。第一个是`ToggleStringValueType`，表示该特征具有开/关风格的（布尔）值。第二个是`FreeTextStringValueType`，表示该特征具有应通过文本框更改的值。`NumericValueValidator`指定了值的验证规则。
- en: 'Once we have defined the value types properly, the Feature Management module
    can automatically render the necessary UI to set the feature values. To open the
    Feature Management dialog, log in to the application as an authorized host user,
    navigate to the tenant management page from the main menu, click the **Actions**
    button, and select the **Features** action, as shown in the following figure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们正确地定义了值类型，特征管理模块可以自动渲染设置特征值所需的UI。要打开特征管理对话框，以授权主机用户身份登录应用程序，从主菜单导航到租户管理页面，点击**操作**按钮，然后选择**特征**操作，如图所示：
- en: '![Figure 16.2 – The Features action on the tenant management page'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 16.2 – The Features action on the tenant management page'
- en: '](img/Figure_16.2_B17287.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_16.2_B17287.jpg]'
- en: Figure 16.2 – The Features action on the tenant management page
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 租户管理页面上的特征操作
- en: 'This action will open a modal dialog, as shown in the following figure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将打开一个模态对话框，如图所示：
- en: '![Figure 16.3 – The Feature Management dialog'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 16.3 – The Feature Management dialog'
- en: '](img/Figure_16.3_B17287.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_16.3_B17287.jpg]'
- en: Figure 16.3 – The Feature Management dialog
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 特征管理对话框
- en: We can see the group name on the left side (you can also localize the group's
    display name). When we click the **MyApp** group, we can see the form elements
    to set the values of the features. The UI has been dynamically created by the
    Feature Management module.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在左侧看到组名（您也可以本地化组的显示名称）。当我们点击**MyApp**组时，我们可以看到设置特征值的表单元素。UI界面是由特征管理模块动态创建的。
- en: The `MyApp.StockManagement` feature becomes a checkbox on the UI, while a numeric
    textbox is shown for the `MyApp.MaxProductCount` feature. This way, you can easily
    set the feature values for any tenant. In addition to the UI, it is also possible
    to programmatically set the feature values using the Feature Management API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyApp.StockManagement`特征在UI上显示为一个复选框，而`MyApp.MaxProductCount`特征则显示为数字文本框。这样，您可以轻松地为任何租户设置特征值。除了UI之外，还可以使用特征管理API编程设置特征值。'
- en: Using the Feature Management API
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用特征管理API
- en: 'The Feature Management module provides the `IFeatureManager` service to set
    a feature''s value for a tenant programmatically. The following example enables
    the `MyApp.StockManagement` feature for the given tenant:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 特征管理模块提供了`IFeatureManager`服务，可以通过编程方式为租户设置特征值。以下示例为指定的租户启用了`MyApp.StockManagement`特征：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are injecting the `IFeatureManager` service into our class's constructor,
    just like any other service. Then, we use the `SetForTenantAsync` method to set
    the value to `true` for the given tenant.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的类构造函数中注入了`IFeatureManager`服务，就像注入任何其他服务一样。然后，我们使用`SetForTenantAsync`方法将给定租户的值设置为`true`。
- en: When to use multi-tenancy
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用多租户
- en: Multi-tenancy is a great pattern to create SaaS solutions, and ABP Framework
    provides a complete infrastructure to create multi-tenant applications. However,
    not all applications should be SaaS, and not all SaaS applications should be multi-tenant.
    ABP's multi-tenancy system has some assumptions, and we've made some design decisions
    while building it. In this section, I want to talk about these assumptions and
    decisions to help you to decide whether ABP's multi-tenancy system fits into your
    solution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户是一个创建SaaS解决方案的优秀模式，ABP框架提供了一个完整的基础设施来创建多租户应用程序。然而，并非所有应用程序都应该是SaaS，也并非所有SaaS应用程序都应该是多租户。ABP的多租户系统有一些假设，我们在构建它时做出了一些设计决策。在本节中，我想讨论这些假设和决策，以帮助你决定ABP的多租户系统是否适合你的解决方案。
- en: 'ABP multi-tenant applications should be developed by assuming that each tenant
    will have a separated and isolated production environment. If you make this assumption,
    then you will have some restrictions. Here are a few example restrictions:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ABP的多租户应用程序应该假设每个租户都将有一个分离和隔离的生产环境来开发。如果你做出这个假设，那么你将有一些限制。以下是一些示例限制：
- en: You should not perform database queries from multiple tenants at once. If you
    do this, you assume that you will have a shared tenant database because it is
    technically not straightforward to query from multiple databases from different
    (and probably isolated) environments.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不应该同时从多个租户执行数据库查询。如果你这样做，你假设你将有一个共享的租户数据库，因为从不同（可能隔离的）环境中查询多个数据库在技术上并不直接。
- en: A tenant's user cannot log in to the system with another tenant. This means
    you can't assign multiple tenants to a single user since users are completely
    isolated. ABP allows using the same email address or user name in different tenants,
    but they will actually be different users with different passwords and identifiers
    in the database, without any relation.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 租户的用户不能使用另一个租户登录到系统中。这意味着你不能将多个租户分配给单个用户，因为用户是完全隔离的。ABP允许在不同的租户中使用相同的电子邮件地址或用户名，但实际上它们将是数据库中具有不同密码和标识符的不同用户，没有任何关联。
- en: You cannot share roles (and their permissions) between different tenants.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在不同租户之间共享角色（及其权限）。
- en: These are natural restrictions if you assume that two tenants have different
    production environments and can't access each other's environment. ABP assumes
    that the same application can be deployed on-premises for a customer without any
    code change (except the `AbpMultiTenancyOptions.IsEnabled` option).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你假设两个租户有不同的生产环境并且不能访问彼此的环境，这些限制是自然的。ABP假设同一个应用程序可以在不进行任何代码更改的情况下（除了`AbpMultiTenancyOptions.IsEnabled`选项）在客户的本地部署上运行。
- en: These assumptions don't mean that the tenants cannot share data at all. If an
    entity doesn't implement the `IMultiTenant` interface, it is naturally shared
    among all tenants and always stored in the central (host) database. In addition,
    you can switch between tenants to temporarily access a tenant's data from another
    tenant user. However, you should think about how this logic will work in an on-premises
    environment, or you can drop the on-premises deployment support from your solution.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些假设并不意味着租户不能共享数据。如果一个实体没有实现`IMultiTenant`接口，它将自然地在所有租户之间共享，并且始终存储在中央（主机）数据库中。此外，你可以切换租户以临时访问另一个租户用户的数据。然而，你应该考虑这种逻辑如何在本地环境中工作，或者你可以从你的解决方案中删除本地部署支持。
- en: Most of the confusion comes from thinking about the multi-tenancy only from
    a technical perspective but not thinking about its purpose of design. For example,
    think of an electronic marketplace where vendors manage and sell their products.
    Individual customers list and search products, add to a cart, and make a payment.
    This application may seem like a multi-tenant system if you assume that the vendors
    have their own products and vendor back-office users manage these products. If
    you use ABP's multi-tenancy system, all the isolation will be automatically done,
    right?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数混淆都来自于只从技术角度考虑多租户，而没有考虑其设计目的。例如，考虑一个电子市场，其中卖家管理和销售他们的产品。个人客户列出和搜索产品，添加到购物车，并完成支付。如果你假设卖家有自己的产品，并且卖家后台用户管理这些产品，这个应用程序可能看起来像是一个多租户系统。如果你使用ABP的多租户系统，所有的隔离都将自动完成，对吗？
- en: While it has some requirements similar to a multi-tenant system from a technical
    perspective, the marketplace is likely to have parts that are integrated as a
    unified platform. In a multi-tenant system, a customer (tenant) behaves as if
    it owns the entire system. In a marketplace, a vendor is not a tenant. It does
    not use an application in isolation, as in an on-premises system. So, if you start
    with multi-tenancy, you will later have to deal with the problems of data sharing
    and integrations because shared/integrated parts are much more than the isolated
    parts in such a system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术角度来看，它有一些类似于多租户系统的要求，但市场可能包含作为统一平台集成的部分。在多租户系统中，客户（租户）表现得好像拥有整个系统。在市场中，供应商不是租户。它不会像在本地系统那样独立使用应用程序。因此，如果您从多租户开始，您将不得不后来处理数据共享和集成的问题，因为共享/集成部分比这种系统中的隔离部分要多得多。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've explored the fundamental infrastructure provided by ABP
    Framework. We've learned how ABP determines the current tenant and isolates the
    data between the tenants. We also learned how to switch to another tenant or completely
    disable the data isolation when needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 ABP 框架提供的根本基础设施。我们学习了 ABP 如何确定当前租户并隔离租户之间的数据。我们还学习了如何在需要时切换到另一个租户或完全禁用数据隔离。
- en: Another great ABP feature is the feature system. We've defined features by creating
    a feature provider class and learned different ways of checking the value of a
    feature for the current user.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个伟大的 ABP 功能是功能系统。我们通过创建功能提供者类来定义功能，并学习了检查当前用户功能值的多种方法。
- en: You are now able to work on a multi-tenant application's development where the
    tenants can have different rights on the application features.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您能够从事多租户应用程序的开发工作，其中租户可以对应用程序功能拥有不同的权限。
- en: The next chapter introduces different levels of automated testing and explains
    how you can create unit and integration tests for your ABP-based solutions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了不同级别的自动化测试，并解释了您如何为基于 ABP 的解决方案创建单元和集成测试。
