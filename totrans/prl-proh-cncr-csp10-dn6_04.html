<html><head></head><body>
<div><div><h1 id="_idParaDest-62"><em class="italic"><a id="_idTextAnchor061"/>Chapter 3</em>: Best Practices for Managed Threading</h1>
<p>When building applications that leverage parallelism and concurrency, developers need to be aware of some best practices regarding integrating managed threading concepts. This chapter will assist in this capacity. We will cover important concepts such as working with static data, avoiding deadlocks, and exhausting managed resources. These are all areas that can lead to unstable applications and unexpected behavior.</p>
<p>In this chapter, you will learn the following concepts:</p>
<ul>
<li>Handling static objects</li>
<li>Managing deadlocks and race conditions</li>
<li>Threading limits and other recommendations</li>
</ul>
<p>By the end of this chapter, you will have the knowledge to avoid the most common managed threading pitfalls.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter03">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter03</a>.</p>
<p>We will get started by discussing some best practices for handling static data in .NET.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Handling static objects</h1>
<p>When working <a id="_idIndexMarker141"/>with static data in .NET, there are some important things to understand when it comes to managed threading.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Static data and constructors</h2>
<p>One important <a id="_idIndexMarker142"/>item to<a id="_idIndexMarker143"/> understand about accessing static data from managed threads relates to constructors. Before a static member of any class can be accessed, its <strong class="bold">static constructor</strong> must first finish running. The runtime will block thread execution until the static constructor has run to ensure that all required initialization has finished.</p>
<p>If you are using static objects within your own code base, you will know which classes have static constructors and can control the complexity of the logic inside them. When the static data is outside of your control, inside a third-party library or .NET itself, things may not be so clear.</p>
<p>Let’s try a quick example to illustrate the potential delays that can be encountered in this scenario.</p>
<ol>
<li>Start by creating a new .NET console application in Visual Studio named <code>ThreadingStaticDataExample</code>.</li>
<li>Add a new class to the project named <code>WorkstationState</code> with the following static members:<pre>internal static string Name { get; set; }
internal static string IpAddress { get; set;}
internal static bool IsNetworkAvailable { get; set; }
internal static DateTime? NetworkConnectivity
    LastUpdated { get; set; }
static WorkstationState()
{
    Name = Dns.GetHostName();
    IpAddress = GetLocalIPAddress(Name);
    IsNetworkAvailable = NetworkInterface
        .GetIsNetworkAvailable();
    NetworkConnectivityLastUpdated = DateTime.UtcNow;
    Thread.Sleep(2000);
}
private static string GetLocalIPAddress
    (string hostName)
{
    var hostEntry = Dns.GetHostEntry(hostName);
    foreach (var address in hostEntry.AddressList
                        .Where(a =&gt; a.AddressFamily == 
                         AddressFamily.InterNetwork))
    {
        return address.ToString();
    }
    return string.Empty;
}</pre></li>
</ol>
<p>This class will hold some information about the current workstation, including the host name, local IP address, and whether the network is currently available. The private <code>GetLocalIpAddress</code> method fetches the local IP based on a provided host name.</p>
<p>There is a static constructor for <code>WorkstationState</code> that sets the initial property data and injects a delay of two seconds with a <code>Thread.Sleep</code> call. This will help us simulate the application fetching some other network information that takes some time to retrieve on a slow network connection.</p>
<ol>
<li value="3">Next, add a class named <code>WorkstationHelper</code>. This class will contain an async method to update the static <code>IsNetworkAvailable</code> and <code>NetworkConnectivityLastUpdated</code> properties in <code>WorkstationState</code> and<a id="_idIndexMarker144"/> return the value of <code>IsNetworkAvailable</code> to<a id="_idIndexMarker145"/> the caller:<pre>internal async Task&lt;bool&gt; GetNetworkAvailability()
{
    await Task.Delay(100);
    WorkstationState.IsNetworkAvailable = 
        NetworkInterface.GetIsNetworkAvailable();
    WorkstationState.NetworkConnectivityLastUpdated = 
        DateTime.UtcNow;
    return WorkstationState.IsNetworkAvailable;
}</pre></li>
</ol>
<p>There is also a <code>Task.Delay</code> call being awaited if you would like to call this in a loop and experiment by varying the injected delay.</p>
<ol>
<li value="4">Finally, update <code>Program.cs</code> to call <code>GetNetworkAvailability</code> and update the console output with the connectivity, host name, and IP address:<pre>using ThreadingStaticDataExample;
Console.WriteLine("Hello, World!");
Console.WriteLine($"Current datetime: 
    {DateTime.UtcNow}");
var helper = new WorkstationHelper();
await helper.GetNetworkAvailability();
Console.WriteLine($"Network availability last updated 
  {WorkstationState.NetworkConnectivityLastUpdated} 
    for computer {WorkstationState.Name} at IP 
      {WorkstationState.IpAddress}");</pre></li>
<li>Run the program and examine the output. You can see that there is a two second delay between the times in the two <code>Console.WriteLine</code> calls injected by the static constructor:</li>
</ol>
<pre>Hello, World!
Current datetime: 2/12/2022 4:07:13 PM
Network availability last updated 2/12/2022 4:07:15 PM for computer ALVINASHCRABC3A at IP 10.211.55.3</pre>
<p>Static<a id="_idIndexMarker146"/> constructors <a id="_idIndexMarker147"/>are one aspect of static data to keep in mind when working with managed threading. A more common issue is controlling concurrent read/write access to static objects across threads.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Controlling shared access to static objects</h2>
<p>When it comes to <a id="_idIndexMarker148"/>static data, the best practice is to avoid using it whenever possible. In general, it makes your code less testable, less scalable, and more prone to unexpected behavior when working with concurrency. However, there are times when static data cannot be avoided. You may be working with a legacy code base, where refactoring the code to remove statics can be risky or too large an effort to undertake. Static classes can also be useful when data rarely changes, or when the classes are stateless.</p>
<p>For cases where <a id="_idIndexMarker149"/>static objects are unavoidable, some precautions can be taken. Let’s review some of them and discuss the merits of each, starting with locking mechanisms.</p>
<h3>Locks</h3>
<p>In <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a><em class="italic">,</em> we discussed some strategies for locking <a id="_idIndexMarker150"/>objects for shared use. <strong class="bold">Locks</strong> are even<a id="_idIndexMarker151"/> more important when working with static variables because of the chance of concurrent access increases with the increased scope of the object.</p>
<p>The simplest way of preventing concurrent access to an object from multiple threads is to enclose any code that accesses it with a lock. Let’s modify the code in <code>WorkstationHelper</code> to prevent multiple calls to <code>GetNetworkActivity</code> from writing to <code>WorkstationState</code> properties concurrently:</p>
<pre class="source-code">internal class WorkstationHelper</pre>
<pre class="source-code">{</pre>
<pre class="source-code"><strong class="bold">    private static object _workstationLock = new object();</strong></pre>
<pre class="source-code">    internal async Task&lt;bool&gt; GetNetworkAvailability()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        await Task.Delay(100);</pre>
<pre class="source-code"><strong class="bold">        </strong><strong class="bold">lock( _workstationLock)</strong></pre>
<pre class="source-code"><strong class="bold">        {</strong></pre>
<pre class="source-code">            WorkstationState.IsNetworkAvailable = </pre>
<pre class="source-code">                NetworkInterface.GetIsNetworkAvailable();</pre>
<pre class="source-code">            WorkstationState.NetworkConnectivityLastUpdated </pre>
<pre class="source-code">                = DateTime.UtcNow;</pre>
<pre class="source-code"><strong class="bold">        }</strong></pre>
<pre class="source-code">        return WorkstationState.IsNetworkAvailable;</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>We have added a private static <code>_workstationLock</code> object, and we are using it as part of the lock block enclosing the writes to <code>WorkstationState</code> properties. If <code>GetNetworkAvailability</code> were now used in a <code>Parallel.ForEach</code> or some other concurrent operation, only one thread could enter that lock block at a time.</p>
<p>You can use any of the locking mechanisms that were discussed in <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>. Choose the feature that works best for your scenario. Another .NET feature you can leverage with static<a id="_idIndexMarker152"/> members <a id="_idIndexMarker153"/>is the <code>ThreadStatic</code> attribute.</p>
<h3>ThreadStatic attribute</h3>
<p>The <code>ThreadStatic</code> attribute<a id="_idIndexMarker154"/> can <a id="_idIndexMarker155"/>be added to a static field to indicate that a separate static instance of the object should be created for each thread. The <code>ThreadStatic</code> attribute should only be used when this is the desired behavior, and it is well documented in your code. It can produce unexpected results when used improperly.</p>
<p>Fields marked as <code>ThreadStatic</code> should not have their data initialized in a constructor, as the initialization will only apply to the current thread. The value on all other threads will be <code>null</code> or the default value for that type.</p>
<p>If you applied the <code>ThreadStatic</code> attribute to the <code>NetworkConnectivityLastUpdated</code> property of <code>WorkstationState</code> and call <code>WorkstationHelper.GetNetworkAvailability</code> thirty times in a <code>Parallel.For</code> loop, the value read in <code>Program.cs</code> at the end may or may not be the last value written to one of the static instances. The variable in <code>Program.cs</code> will contain the last value written from the main thread inside the <code>Parallel.For</code> loop.</p>
<ol>
<li value="1">To try it for yourself, add the <code>ThreadStatic</code> attribute to <code>NetworkConnectivityLastUpdated</code> and make it an internal field instead of a property. The attribute cannot be applied to properties:<pre>[ThreadStatic]
internal static DateTime? 
    NetworkConnectivityLastUpdated;</pre></li>
<li>Then update <code>Program.cs</code> to use a <code>Parallel.For</code> loop:<pre>using ThreadingStaticDataExample;
Console.WriteLine("Hello, World!");
Console.WriteLine($"Current datetime: 
    {DateTime.UtcNow}");
var helper = new WorkstationHelper();
<strong class="bold">Parallel.For(1, 30, async (x) =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">    await helper.GetNetworkAvailability();</strong>
<strong class="bold">});</strong>
Console.WriteLine($"Network availability last updated 
    {WorkstationState.NetworkConnectivityLastUpdated} 
        for computer {WorkstationState.Name} at IP 
           {WorkstationState.IpAddress}");</pre></li>
</ol>
<p>The time between the date/time values in the output will now vary each time you run the program because the final value written to the console may not be the final value across all threads.</p>
<p>While <code>ThreadStatic</code> should be applied only in scenarios where instances per thread are necessary, another<a id="_idIndexMarker156"/> pattern <a id="_idIndexMarker157"/>similar in application to statics is the <strong class="bold">singleton</strong>. Let’s discuss the use of singletons in a multithreaded application.</p>
<h3>Working with singletons</h3>
<p>The <a id="_idIndexMarker158"/>singleton <a id="_idIndexMarker159"/>pattern is an<a id="_idIndexMarker160"/> object <strong class="bold">design pattern</strong> that only allows a single instance of itself to be created. This design pattern is one of the most common and is known by most .NET developers. Every mainstream <strong class="bold">dependency injection (DI)</strong> framework <a id="_idIndexMarker161"/>allows registered types to be registered as singletons. The container will only create one instance for each of these types, providing the same instances every time the type is requested.</p>
<p>We can manually create a singleton for our <code>WorkstationState</code> with a <code>lock</code> and a little extra code. This is the <code>WorkstationStateSingleton</code>:</p>
<pre>public class WorkstationStateSingleton
{
    private static WorkstationStateSingleton? 
        _singleton = null;
    private static readonly object _lock = new();
    WorkstationStateSingleton()
    {
        Name = Dns.GetHostName();
        IpAddress = GetLocalIPAddress(Name);
        IsNetworkAvailable = 
            NetworkInterface.GetIsNetworkAvailable();
        NetworkConnectivityLastUpdated = 
            DateTime.UtcNow;
    }
    public static WorkstationStateSingleton Instance
    {
        get
        {
            lock (_lock)
            {
                if (_singleton == null)
                {
                    _singleton = new 
                       WorkstationStateSingleton();
                }
                return _singleton;
            }
        }
    }
...
}</pre>
<p>The complete implementation of the class can be found in the GitHub repository referenced in the <em class="italic">Technical requirements</em> section of this chapter. Look at the <code>ThreadingStaticDataExample</code> in the <code>chapter3</code> folder.</p>
<p>There are two steps taken to make this a singleton. First, the constructor is private so only the <code>WorkstationStateSingleton</code> can create an instance of itself. Second, a static <code>Instance</code> method <a id="_idIndexMarker162"/>is <a id="_idIndexMarker163"/>created. It returns the <code>_singleton</code> instance of itself if it is not <code>null</code>. Otherwise, it creates the instance to return. Surrounding this code with the <code>_lock</code> ensures that the instances are not created twice on different concurrent threads.</p>
<p>A singleton presents the same challenges as a static class. All shared data should be protected by locks if they can be accessed concurrently by managed threads. The added challenge with singletons that are registered in a DI container is that a <code>lock</code> object, <code>Mutex</code>, or another mechanism must be declared at the same scope as the container. This will ensure that all data that can potentially use the singleton can also enforce the same lock.</p>
<p class="callout-heading">Note</p>
<p class="callout">Please note that the use of singletons is generally not considered a good practice today. For this reason, many developers consider them an anti-pattern. However, it is important to understand them and how existing singletons in your code may be impacted by multithreaded code.</p>
<p><strong class="bold">Deadlocks</strong> are one of the pitfalls of aggressive locking. Aggressive locking is when you are locking uses <a id="_idIndexMarker164"/>of an object <a id="_idIndexMarker165"/>in many parts of the code that could be executing in parallel. In the next section, we will discuss deadlocks and <strong class="bold">race conditions</strong> in managed threading.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Managing deadlocks and race conditions</h1>
<p>As with many<a id="_idIndexMarker166"/> tools <a id="_idIndexMarker167"/>at a developer’s disposal, misusing features of managed threading can have adverse impacts on your applications at runtime. Deadlocks and race conditions are two scenarios that can be created because of multithreaded programming: </p>
<ul>
<li>A <strong class="bold">deadlock</strong> happens when multiple threads are trying to lock the same resource and as a result, cannot continue executing. </li>
<li><strong class="bold">Race conditions</strong> happen when multiple threads are proceeding toward updating a particular routine, and a correct outcome is dependent on the order in which they execute it.</li>
</ul>
<div><div><img alt="Figure 3.2 – Two threads in contention for the same resources, causing a deadlock " height="522" src="img/Figure_3.1_B18552.jpg" width="933"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Two threads in contention for the same resources, causing a deadlock</p>
<p>First, let’s <a id="_idIndexMarker168"/>discuss <a id="_idIndexMarker169"/>deadlocks and some techniques for avoiding them.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Mitigating deadlocks</h2>
<p>It is critical to avoid <a id="_idIndexMarker170"/>deadlocks in your applications. If one of the threads involved in a deadlock is the application’s UI thread, it will cause the application to freeze. When only non-UI threads are deadlocked, it can be harder to diagnose the problem. Deadlocked thread pool threads will prevent an application from closing, but deadlocked background threads will not.</p>
<p>Well-instrumented code is essential in debugging problems when they occur in a production environment. If the issue can be reproduced in your own development environment, stepping through the code with the Visual Studio debugger is the fastest way to find the source of a deadlock. We will discuss debugging techniques in detail in <a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a>.</p>
<p>One of the easiest ways to create a deadlock is through recursion or nested methods that try to acquire a lock<a id="_idIndexMarker171"/> on the same resource. Look at the following code:</p>
<pre class="source-code">private object _lock = new object();</pre>
<pre class="source-code">private List&lt;string&gt; _data;</pre>
<pre class="source-code">public DeadlockSample()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    _data = new List&lt;string&gt; { "First", "Second",</pre>
<pre class="source-code">        "Third" };</pre>
<pre class="source-code">}</pre>
<pre class="source-code">public async Task ProcessData()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    lock (_lock)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        foreach(var item in _data)</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            Console.WriteLine(item);</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        await AddData();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private async Task AddData()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    lock (_lock)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        _data.AddRange(GetMoreData());</pre>
<pre class="source-code">        await Task.Delay(100);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>The <code>ProcessData</code> method is locking the <code>_lock</code> object and processing with <code>_data</code>. However, it is calling <code>AddData,</code> which also tries to acquire the same lock. This lock will never become available, and the process will be deadlocked. In this case, the problem is apparent. What if <code>AddData</code> is called from multiple places or some <code>Parallel.ForEach</code> any loops are involved in the parent code? Some of the parent code uses <code>_data</code> and acquire a lock, but some do not. This is a case where non-blocking read locks in the <code>ReaderWriterLockSlim</code> can help prevent deadlocks.</p>
<p>Another way to<a id="_idIndexMarker172"/> prevent deadlocks is by adding a timeout to the lock attempt with <code>Monitor.TryEnter</code>. In this example, the code will time out if a lock cannot be acquired within one second:</p>
<pre class="source-code">private void AddDataWithMonitor()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    if (Monitor.TryEnter(_lock, 1000))</pre>
<pre class="source-code">    {  </pre>
<pre class="source-code">        try</pre>
<pre class="source-code">        {  </pre>
<pre class="source-code">            _data.AddRange(GetMoreData());</pre>
<pre class="source-code">        }  </pre>
<pre class="source-code">        finally</pre>
<pre class="source-code">        {  </pre>
<pre class="source-code">            Monitor.Exit(_lock);  </pre>
<pre class="source-code">        }  </pre>
<pre class="source-code">    }  </pre>
<pre class="source-code">    else</pre>
<pre class="source-code">    {  </pre>
<pre class="source-code">        Console.WriteLine($"AddData: Unable to acquire </pre>
<pre class="source-code">            lock. Stack trace: {Environment.StackTrace}");</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>Logging any failures to acquire locks can help to pinpoint possible sources of deadlocks in your code so <a id="_idIndexMarker173"/>you can rework the code to avoid them.</p>
<p>Next, let’s examine how race conditions can occur in multithreaded applications.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Avoiding race conditions</h2>
<p>A race condition <a id="_idIndexMarker174"/>occurs when multiple threads are reading and writing the same variables simultaneously. Without any locks in place, the outcome can be wildly unpredictable. Some operations can be overwritten by other parallel threads’ results. Even with locks in place, the order of two thread operations can change the result. Here is a simple example without locks that performs some addition and multiplication in parallel:</p>
<pre class="source-code">private int _runningTotal;</pre>
<pre class="source-code">public void PerformCalculationsRace()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    _runningTotal = 3;</pre>
<pre class="source-code">    Parallel.Invoke(() =&gt; {</pre>
<pre class="source-code">        AddValue().Wait();</pre>
<pre class="source-code">    }, () =&gt; {</pre>
<pre class="source-code">        MultiplyValue().Wait();</pre>
<pre class="source-code">    });</pre>
<pre class="source-code">    Console.WriteLine($"Running total is {_runningTotal}");</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private async Task AddValue()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await Task.Delay(100);</pre>
<pre class="source-code">    _runningTotal += 15;</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private async Task MultiplyValue()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await Task.Delay(100);</pre>
<pre class="source-code">    _runningTotal = _runningTotal * 10;</pre>
<pre class="source-code">}</pre>
<p>We all know that when combining addition and multiplication, the order of operations is important. If the two operations are processed sequentially, the two results could be either <code>180</code> or <code>45</code>, but if both <code>AddValue</code> and <code>MultiplyValue</code> read the initial value of <code>3</code> before performing their respective operations, the last method to complete will write either <code>18</code> or <code>30</code> as <a id="_idIndexMarker175"/>the final value of <code>_runningTotal</code>.</p>
<p>If you want to ensure that multiplication happens before addition, the <code>PerformCalculations</code> method can be rewritten to use the <code>ContinueWith</code> method on the <code>Task</code> returned from <code>MultiplyValue</code>:</p>
<pre class="source-code">public async Task PerformCalculations()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    _runningTotal = 3;</pre>
<pre class="source-code">    await MultiplyValue().ContinueWith(async (Task) =&gt; {</pre>
<pre class="source-code">        await AddValue();</pre>
<pre class="source-code">        });</pre>
<pre class="source-code">    Console.WriteLine($"Running total is {_runningTotal}");</pre>
<pre class="source-code">}</pre>
<p>This code will always multiply before adding and will always finish with <code>_runningTotal</code> equaling <code>45</code>. Using <code>async</code> and <code>await</code> throughout the code ensures that the UI or service process remains responsive while using threads from the thread pool as needed.</p>
<p>The <code>Interlocked</code> class discussed in the previous chapter can also be used to perform mathematic operations on shared resources. <code>Interlocked.Add</code> and <code>Interlocked.Exchange</code> can perform thread-safe operations on the <code>_runningTotal</code> variable in parallel. Here is the original <code>Parallel.Invoke</code> example modified to <a id="_idIndexMarker176"/>use <code>Interlocked</code> methods with <code>_runningTotal</code>:</p>
<pre class="source-code">public class InterlockedSample</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    private long _runningTotal;</pre>
<pre class="source-code">    public void PerformCalculations()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        _runningTotal = 3;</pre>
<pre class="source-code">        Parallel.Invoke(() =&gt; {</pre>
<pre class="source-code">            AddValue().Wait();</pre>
<pre class="source-code">        }, () =&gt; {</pre>
<pre class="source-code">            MultiplyValue().Wait();</pre>
<pre class="source-code">        });</pre>
<pre class="source-code">        Console.WriteLine($"Running total is </pre>
<pre class="source-code">            {_runningTotal}");</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private async Task AddValue()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        await Task.Delay(100);</pre>
<pre class="source-code">        <strong class="bold">Interlocked.Add(ref _runningTotal, 15);</strong></pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private async Task MultiplyValue()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        await Task.Delay(100);</pre>
<pre class="source-code">        <strong class="bold">var currentTotal = Interlocked.Read(ref </strong></pre>
<pre class="source-code"><strong class="bold">            _runningTotal);</strong></pre>
<pre class="source-code">        <strong class="bold">Interlocked.Exchange(ref _runningTotal, </strong></pre>
<pre class="source-code"><strong class="bold">            currentTotal * 10);</strong></pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>The two operations could still perform in different orders, but the uses of <code>_runningTotal</code> are now locked and thread-safe. The <strong class="bold">Interlocked</strong> class<a id="_idIndexMarker177"/> is more efficient than using a lock statement and will yield greater performance for simple changes like these.</p>
<p>It is important to guard all shared resources when performing concurrent operations in your code. By creating a well-designed locking strategy, you will achieve the best possible performance<a id="_idIndexMarker178"/> while maintaining thread safety in your application. Let’s finish up this chapter with some guidance around threading limits.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Threading limits and other recommendations</h1>
<p>So, it sounds<a id="_idIndexMarker179"/> like using <a id="_idIndexMarker180"/>multiple threads can really speed up your application’s performance. You should probably start replacing all your <code>foreach</code> loops with <code>Parallel.ForEach</code> loop and start calling all your services and helper methods on thread pool threads, right? Are there any limits and what are they? Well, when it comes to threading, there absolutely are limits.</p>
<p>The number of threads that can execute simultaneously is limited by the number of processors and processor cores on the system. There is no way around hardware limitations, as the CPU (or virtual CPU when running on a virtual machine) can only run so many threads. In addition, your application must share these CPUs with other processes running on the system. If your CPU has four cores, it is actively running five other applications, and your program is trying to execute a process with multiple threads, the system is not likely to accept more than one of your threads at a time.</p>
<p>The .NET thread pool is optimized to handle different scenarios based on the number of threads available, but you can do some things to guard against taxing the system. Some parallel operations such as <code>Parallel.ForEach</code> can limit how many threads the loop will try to use. You can provide a <code>ParallelOptions</code> object to the operation and set the <code>MaxDegreeOfParallelism</code> option. By default, the loop will use as many threads as the scheduler will provide.</p>
<p>You can ensure that the maximum does not exceed half the number of available cores on the<a id="_idIndexMarker181"/> system <a id="_idIndexMarker182"/>with the following implementation:</p>
<pre class="source-code">public void ProcessParallelForEachWithLimits</pre>
<pre class="source-code">    (List&lt;string&gt; items)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    int max = Environment.ProcessorCount &gt; 1 ? </pre>
<pre class="source-code">                Environment.ProcessorCount / 2 : 1;</pre>
<pre class="source-code">    var options = new ParallelOptions</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        MaxDegreeOfParallelism = max</pre>
<pre class="source-code">    };</pre>
<pre class="source-code">    Parallel.ForEach(items, options, y =&gt; {</pre>
<pre class="source-code">        // Process items</pre>
<pre class="source-code">    });</pre>
<pre class="source-code">}</pre>
<p>PLINQ operations can also limit the max degree of parallelism with the <code>WithDegreeOfParallelism</code> extension method:</p>
<pre class="source-code">public bool ProcessPlinqWithLimits(List&lt;string&gt; items)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    int max = Environment.ProcessorCount &gt; 1 ? </pre>
<pre class="source-code">        Environment.ProcessorCount / 2 : 1;</pre>
<pre class="source-code">    return items.AsParallel()</pre>
<pre class="source-code">        <strong class="bold">.WithDegreeOfParallelism(max)</strong></pre>
<pre class="source-code">        .Any(i =&gt; CheckString(i));</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private bool CheckString(string item)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    return !string.IsNullOrWhiteSpace(item);</pre>
<pre class="source-code">}</pre>
<p>An application can <a id="_idIndexMarker183"/>also <a id="_idIndexMarker184"/>adjust the thread pool maximum values, if necessary. By calling <code>ThreadPool.SetMaxThreads</code>, you can change the maximum values for <code>workerThreads</code> and <code>completionPortThreads</code>. <code>completionPortThreads</code> is the number of async I/O threads on the thread pool. It is usually not required to change these values, and there are some limits to the values you can set. The maximum cannot be set to less than the number of cores on the system or less than the current minimum values on the thread pool. You can query the current minimums with <code>ThreadPool.GetMinThreads</code>. Here is an example of how to safely set the maximum thread values to values greater than the current minimums:</p>
<pre class="source-code">private void UpdateThreadPoolMax()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    ThreadPool.GetMinThreads(out int workerMin, out int </pre>
<pre class="source-code">        completionMin);</pre>
<pre class="source-code">    int workerMax = GetProcessingMax(workerMin);</pre>
<pre class="source-code">    int completionMax = GetProcessingMax(completionMin);</pre>
<pre class="source-code">    ThreadPool.SetMaxThreads(workerMax, completionMax);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private int GetProcessingMax(int min)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    return min &lt; Environment.ProcessorCount ?</pre>
<pre class="source-code">                    Environment.ProcessorCount * 2 :</pre>
<pre class="source-code">                    min * 2;</pre>
<pre class="source-code">}</pre>
<p>There are some other general guidelines to follow regarding the number of threads to assign to an operation in your application. Try to avoid assigning multiple threads to operations that share a resource. For example, if you have a service that logs activity to a file, you should not assign more than one background worker to do the logging. The blocking file I/O operations <a id="_idIndexMarker185"/>will prevent the second thread from writing until the <a id="_idIndexMarker186"/>first one is complete. You are not gaining any efficiency in this case.</p>
<p>If you find yourself adding extensive locking to objects in your application, you are either using too many threads or the task distribution needs to be changed to reduce contention for resources. Try to divide threaded task responsibility by the types of data being consumed. You might have many parallel tasks calling services to fetch data, but only one or two threads are needed to process the data once it is returned.</p>
<p>You may have heard the <a id="_idIndexMarker187"/>term <strong class="bold">thread starvation</strong>. This usually happens when too many threads are blocking or waiting for resources to become available. There are some common scenarios where this happens:</p>
<ul>
<li><strong class="bold">Locks</strong>: There are too <a id="_idIndexMarker188"/>many threads competing for the same locked resources. Analyze your code to determine how to reduce contention.</li>
<li><code>async</code>. This allows the webserver to serve other requests while yours are waiting for operations to complete.</li>
<li><strong class="bold">Too much threading</strong>: Creating too many thread pool threads will result in more idle threads <a id="_idIndexMarker190"/>waiting to be processed. It also increases the likelihood of thread contention and starvation.</li>
</ul>
<p>Avoid these practices, and .NET will do its best to manage the thread pool to serve your application and others on the system.</p>
<p>Finally, do not use <code>Thread.Suspend</code> and <code>Thread.Resume</code> trying to control the sequence of operations across multiple threads. Instead, leverage other techniques discussed in<a id="_idIndexMarker191"/> this<a id="_idIndexMarker192"/> chapter, including locking mechanisms and <code>Task.ContinueWith</code>.</p>
<p>We have covered plenty of best practices for managed threading in this chapter. Let’s wrap up by reviewing what we have learned.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Summary</h1>
<p>In this chapter, we discussed some best practices to follow when working with managed threads in C# and .NET. We started by creating some examples of how to manage and process static data in a multithreaded application. The examples illustrated how to leverage locks, work with singletons, and how static constructors can impact performance when working with static data. Next, we explored some techniques for avoiding deadlocks and race conditions. Both pitfalls can be avoided if you design your algorithms to minimize the need for locking. Finally, we looked at some features of .NET that can adjust the limits of several parallel and thread pool operations.</p>
<p>At this point, you are well prepared to start using managed threads responsibly in your .NET projects. For some further reading on best practices with managed threading, you can check out some recommendations on Microsoft Docs: <a href="">https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices</a>.</p>
<p>In the next chapter, <a href="B18552_04_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, you will learn how to leverage parallelism and concurrency to keep your application responsive and pick up some best practices for updating the UI from a non-UI thread.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Questions</h1>
<ol>
<li value="1">Which design pattern models how to create an object that only has one instance?</li>
<li>What .NET attribute will cause a static field to have one instance per thread?</li>
<li>What is a threading deadlock?</li>
<li>Which method on the <code>Monitor</code> class can be used to specify a timeout when trying to access a locked resource?</li>
<li>Which lightweight class can be used to lock value types for atomic operations?</li>
<li>Which thread-safe operation can be used to add two integers?</li>
<li>What option can be set on a <code>Parallel.For</code> or <code>Parallel.ForEach</code> loop to limit the number of threads used?</li>
<li>How can you limit the number of threads used in a PLINQ query?</li>
<li>What is the name of the method to find the current minimum thread values on the thread pool?</li>
</ol>
</div>
</div>
</body></html>