<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer090" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor096" class="pcalibre1 pcalibre calibre6"/>5</h1>
<h1 id="_idParaDest-95" class="calibre5"><a id="_idTextAnchor097" class="pcalibre1 pcalibre calibre6"/>Continuing the Adventure Game</h1>
<p class="calibre3">In <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 4</em></span></a>, we covered the larger scope of the adventure game by extending the <strong class="bold">Game Design Document</strong> (<strong class="bold">GDD</strong>) for <a id="_idIndexMarker515" class="pcalibre1 pcalibre calibre6"/>the game and explored the level and environment design while also considering new principles to guide the player. We also imported and prepped artwork for use with additional 2D tooling that will bring the game <span>to life.</span></p>
<p class="calibre3">We also challenged the player by exploring and adding moving platforms and interactive elements in the level design, immersing the player with a parallax effect on a layered background, and optimizing the sprite draw calls to keep <span>things performant.</span></p>
<p class="calibre3">With the game level and environment established, we can now move on to creating our player character using the 2D <span>Animation package.</span></p>
<p class="calibre3">In this chapter, we’re going to cover the following <span>main topics:</span></p>
<ul class="calibre17">
<li class="calibre15">Setting up the player character with <span>PSD Importer</span></li>
<li class="calibre15">Using an Input <span>Action Map</span></li>
<li class="calibre15">Moving the player with a player <span>controller script</span></li>
<li class="calibre15">Animating the character <span>with Mecanim</span></li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to set up a 2D sprite-based character rigged for animation and driven by player input. You’ll also be able to assign and transition between different animations required for the player’s <span>current state.</span></p>
<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor098" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter and use the same artwork that was created for the project in this book, download the adventure game 2D art assets from the following GitHub <span>link: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets</span></a><span>.</span></p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop or use a graphics program that can export layered PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and <span>Affinity Photo).</span></p>
<p class="calibre3">You can download the complete project from GitHub <span>at </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example</span></a><span>.</span></p>
<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor099" class="pcalibre1 pcalibre calibre6"/>Setting up the player character with PSD Importer</h1>
<p class="calibre3">Creating our player<a id="_idIndexMarker516" class="pcalibre1 pcalibre calibre6"/> character for the 2D adventure game will be a multi-step process. In this section, we’ll cover all the steps required to make an animated 2D character controlled by <span>the player.</span></p>
<p class="calibre3">We’ll start with the import settings for the artwork and setting up the character bones that will allow us to animate. You’ll repeat these actions many times throughout a project while importing artwork and assets. <strong class="bold">PSD Importer</strong> is an<a id="_idIndexMarker517" class="pcalibre1 pcalibre calibre6"/> asset importer that can work with multilayered PSB/PSD files to create a Prefab of sprites based on the <span>source layers.</span></p>
<p class="calibre3">The import options allow Unity to generate both a sprite sheet and a character rig that arranges the sprites according to their original position and layer order, significantly simplifying the creation of a sprite-based <span>animated character.</span></p>
<p class="calibre3">Let’s go ahead and import the artwork for the player character. Here, we will set up the source file so that it uses PSD Importer to create the actor (the Prefab created based on the multilayered Photoshop file is<a id="_idIndexMarker518" class="pcalibre1 pcalibre calibre6"/> called <span>an </span><span><strong class="bold">actor</strong></span><span>):</span></p>
<ol class="calibre14">
<li class="calibre15">Create a new folder in the <span><strong class="source-inline">Assets/Sprites/Character</strong></span><span> directory.</span></li>
<li class="calibre15">Import <strong class="source-inline">PlayerCharacter1.psd</strong> into the newly <span>created folder.</span></li>
<li class="calibre15">Select the imported file and, in the <strong class="bold">Inspector</strong> window, change <strong class="bold">Importer</strong> to <strong class="bold">UnityEditor.U2D.PSD.PSDImporter</strong> in the <span>dropdown list.</span></li>
</ol>
<p class="calibre3"><strong class="bold">PSD Importer</strong> provides two new options that appear as tabs once it’s selected as <span>the importer:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Settings</strong>: This is where you will set the properties for how the file will be imported. The fields under <strong class="bold">Settings</strong> are similar to the default texture importer, with the addition of the <strong class="bold">Layer Import</strong> (when <strong class="bold">Texture Type</strong> is set to <strong class="bold">Multiple</strong>) and <strong class="bold">Character </strong><span><strong class="bold">Rig</strong></span><span> sections</span></li>
<li class="calibre15"><strong class="bold">Layer Management</strong>: This is where you can customize which layers from the Photoshop file <span>are imported</span></li>
</ul>
<p class="calibre3">With the default import settings, we are already in good shape to continue with the player character setup since we’ll be using all the layers. The importer will keep the layer positions and sorting order from Photoshop so that our character sprites are arranged correctly for <span>our actor.</span></p>
<p class="calibre3">We won’t have to recreate the player character in Unity from the individual sprites that make up the character – arms, torso, legs, head, and so on. So, we are ready for the next step – rigging the<a id="_idIndexMarker519" class="pcalibre1 pcalibre calibre6"/> character by <span>adding bones.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Preparing and importing <span>artwork: </span><a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml</span></a><span>.</span></p>
<p class="callout">PSD Importer Inspector <span>properties: </span><a href="https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml</span></a><span>.</span></p>
<h2 id="_idParaDest-98" class="calibre8"><a id="_idTextAnchor100" class="pcalibre1 pcalibre calibre6"/>Rigging the actor</h2>
<p class="calibre3">With the actor (the player <a id="_idIndexMarker520" class="pcalibre1 pcalibre calibre6"/>character PSD file) still <a id="_idIndexMarker521" class="pcalibre1 pcalibre calibre6"/>selected in the <strong class="bold">Project</strong> window, click the <strong class="bold">Open Sprite Editor</strong> button in the <strong class="bold">Inspector</strong> window. The default view is the sliced sprite shape representing our <span>Photoshop layers.</span></p>
<p class="calibre3">Don’t worry – as I said, we won’t have to work with our character in a dismembered way, as shown in <span><em class="italic">Figure 5</em></span><span><em class="italic">.1</em></span><span>:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer076">
<img alt="Figure 5.1 – Actor sprite sheet" src="image/B18347_05_1.jpg" class="calibre65"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Actor sprite sheet</p>
<p class="calibre3">If the artwork is shown with the individual sprites representing the Photoshop layers, then we need to switch to <strong class="bold">Sprite Skinning Editor</strong> (part of the 2D Animation package), where we’ll continue setting up the animation rig for <span>the actor.</span></p>
<p class="calibre3">From the <strong class="bold">Sprite Editor</strong> dropdown, select <strong class="bold">Skinning Editor</strong> – the sprites should now represent the character, as seen in the original Photoshop source <span>file. Sweet!</span></p>
<p class="calibre3">The entire workflow of <a id="_idIndexMarker522" class="pcalibre1 pcalibre calibre6"/>setting up the actor for <a id="_idIndexMarker523" class="pcalibre1 pcalibre calibre6"/>animations looks <span>like this:</span></p>
<ol class="calibre14">
<li class="calibre15"><strong class="bold">Create a rig</strong>: A skeleton<a id="_idIndexMarker524" class="pcalibre1 pcalibre calibre6"/> made up of <span>individual bones.</span></li>
<li class="calibre15"><strong class="bold">Generate mesh geometry</strong>: This will influence the sprite’s position, rotation, and, <span>optionally, deformation.</span></li>
<li class="calibre15"><strong class="bold">Adjust bone influence</strong>: Change the attributes of a sprite to specify which bone or bones <span>affect it.</span></li>
<li class="calibre15"><strong class="bold">Adjust weights</strong>: How much a bone, or bones, influence a given sprite (the entire sprite, or just part(s) <span>of it).</span></li>
<li class="calibre15"><strong class="bold">Preview pose</strong>: Test, test, and test again regarding the rig and sprite bone, geometry, and weight assignments until everything is looking and working correctly when bones are moved or rotated; this is a <span>cyclical process.</span></li>
<li class="calibre15"><strong class="bold">Inverse kinematics</strong> (<strong class="bold">IK</strong>): You can apply IK to a chain of bones to automatically calculate positions<a id="_idIndexMarker525" class="pcalibre1 pcalibre calibre6"/> and rotations that make it much easier to animate the <span>actor’s limbs.</span></li>
</ol>
<p class="callout-heading">Additional reading | Inverse kinematics (IK)</p>
<p class="callout">IK is a technique that’s used in computer animation and robotics to control the position and orientation of limbs. It calculates the joint angles required to place the end effector in a given position and orientation – endpoints such as hands and feet. It’s useful for creating natural and realistic human motion, especially for <span>complex poses.</span></p>
<p class="callout">You can read more <span>at </span><a href="https://docs.unity3d.com/Manual/InverseKinematics.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Manual/InverseKinematics.xhtml</span></a><span>.</span></p>
<ol class="calibre14">
<li value="7" class="calibre15"><strong class="bold">Animate</strong>: Create animations<a id="_idIndexMarker526" class="pcalibre1 pcalibre calibre6"/> for the actor’s different gameplay states, such as idle, walking, jumping, <span>and attacking.</span></li>
</ol>
<p class="calibre3">Game development is <a id="_idIndexMarker527" class="pcalibre1 pcalibre calibre6"/>a multidisciplinary <a id="_idIndexMarker528" class="pcalibre1 pcalibre calibre6"/>craft that combines both technical and artistic skills. Creating a character rig with individual bones to affect individual sprites combines both skill sets. Thankfully, the rigging process is non-destructive, so we’ll be able to go back and make changes at any time to adjust and fix anything that doesn’t seem to be working well or <span>look correct.</span></p>
<p class="calibre3">The general creation process we’ll follow when creating the rig is to start with the pelvic bone – this bone will represent the <em class="italic">true center</em> of the character. Moving or rotating this bone will affect all child bones in the rig, moving the <span>entire actor.</span></p>
<p class="calibre3">This first bone we’ll create can be seen in <span><em class="italic">Figure 5</em></span><em class="italic">.2</em> as the small red bone pointing upwards in the pelvic area of the character. In the bone hierarchy (as shown in the <strong class="bold">Visibility</strong> window), this bone, <strong class="source-inline">bone_1</strong>, is the <span>root bone.</span></p>
<p class="calibre3">Let’s create our bones! Perform the following steps to develop the whole <span>character rig:</span></p>
<ol class="calibre14">
<li class="calibre15">We should already be in <strong class="bold">Skinning Editor</strong>; if not, select it from the <strong class="bold">Sprite </strong><span><strong class="bold">Editor</strong></span><span> dropdown.</span></li>
<li class="calibre15">To view the hierarchy of the bones being created (or to manage the visibility of the sprites you’re working with), toggle on the <strong class="bold">Visibility</strong> panel (the top right of the window next to <strong class="bold">Revert</strong> <span>and </span><span><strong class="bold">Apply</strong></span><span>).</span></li>
<li class="calibre15">Now, under the <strong class="bold">Bones</strong> section (the left-hand side of the window), select the <strong class="bold">Create Bone</strong> button – your cursor should now have a red dot at <span>the tip.</span></li>
<li class="calibre15">Start at the character’s pelvis and click to start creating the root bone. Click again slightly above the first click point to make the small red root bone – refer to <span><em class="italic">Figure 5</em></span><em class="italic">.2</em> for the general size <span>and orientation.</span></li>
<li class="calibre15">Continue by clicking again to create a bone that will represent the lower portion of the torso (yellow bone) and again to make a bone for the upper part of the torso (green bone); this will allow us to bend the character’s torso (for example, arching forward <span>or backward).</span></li>
<li class="calibre15">Moving up the spine, create two additional bones – a small bone for the neck and another for the head (refer to <span><em class="italic">Figure 5</em></span><span><em class="italic">.2</em></span><span>).</span></li>
<li class="calibre15">Right-click or press the <em class="italic">Esc</em> key to stop <span>creating bones.</span></li>
</ol>
<p class="calibre3">Our actor now has a<a id="_idIndexMarker529" class="pcalibre1 pcalibre calibre6"/> spine (if you’ll forgive the pun). Creating<a id="_idIndexMarker530" class="pcalibre1 pcalibre calibre6"/> the limbs will follow a similar process, but the critical difference in creating bones for limbs is to first select the bone that will parent the limb bones. Follow <span>these steps:</span></p>
<ol class="calibre14">
<li class="calibre15">With <strong class="bold">Create Bone</strong> still selected, click on the upper torso bone (green). You should now see a semi-transparent bone coming from the bone that was just clicked (this indicates parenting; you can also see this in the <strong class="bold">Visibility</strong> window’s <strong class="bold">Bone </strong><span><strong class="bold">Hierarchy</strong></span><span> view).</span></li>
<li class="calibre15">We’ll start by creating a limb for the character’s left arm (the arm behind the torso), so click where the left shoulder joint should be to begin <span>making bones.</span></li>
<li class="calibre15">Note that to make placing bones easier for sprites behind others, you can toggle the visibility off for the sprites in front by using the <span><strong class="bold">Visibility</strong></span><span> panel.</span></li>
<li class="calibre15">Keep clicking to create bones for the upper arm, lower arm, and hand (refer to <span><em class="italic">Figure 5</em></span><span><em class="italic">.2</em></span><span>).</span></li>
<li class="calibre15">Right-click or press the <em class="italic">Esc</em> key to stop <span>creating bones.</span></li>
<li class="calibre15">Continue creating the other limb bones for the right arm and both legs by selecting the parent bone again – for the legs, parent to the pelvic bone (the red root bone we started creating the <span>rig from).</span></li>
</ol>
<p class="calibre3">Your actor’s entire skeleton<a id="_idIndexMarker531" class="pcalibre1 pcalibre calibre6"/> rig should look similar<a id="_idIndexMarker532" class="pcalibre1 pcalibre calibre6"/> to the rig shown in <span><em class="italic">Figure 5</em></span><span><em class="italic">.2</em></span><span>:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer077">
<img alt="Figure 5.2 – The actor rig and Auto Geometry with Weights" src="image/B18347_05_2.jpg" class="calibre66"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The actor rig and Auto Geometry with Weights</p>
<p class="calibre3">If you want to have your bones named more intelligibly – making it easier for you to know which bones you are working with – you can easily rename them while using the <strong class="bold">Edit Bone</strong> tool. Click on a bone to select it and then use the <strong class="bold">Name</strong> field in the <strong class="bold">Bone</strong> dialogue (on the right-hand side of the window and under <strong class="bold">Visibility</strong>) to specify a new name (for example, <strong class="source-inline">bone_14</strong> <span>to </span><span><strong class="source-inline">foot_right</strong></span><span>).</span></p>
<p class="calibre3">Creating the rig is just the first step in making a fully animatable character. Let’s take the next step by assigning the sprite’s mesh geometry to the rig’s bones – as you continue to work with the rig, it <a id="_idIndexMarker533" class="pcalibre1 pcalibre calibre6"/>may help to know that<a id="_idIndexMarker534" class="pcalibre1 pcalibre calibre6"/> the sprite mesh geometry a bone influences will be the same color as <span>the bone.</span></p>
<h2 id="_idParaDest-99" class="calibre8"><a id="_idTextAnchor101" class="pcalibre1 pcalibre calibre6"/>Generating the sprite mesh geometry</h2>
<p class="calibre3">Perform the following<a id="_idIndexMarker535" class="pcalibre1 pcalibre calibre6"/> steps to<a id="_idIndexMarker536" class="pcalibre1 pcalibre calibre6"/> create the sprite mesh geometry and apply default bone weights that will influence the sprites that we’ll <span>start with:</span></p>
<ol class="calibre14">
<li class="calibre15">First, double-click in the checkered area to unselect all sprites (noting that this action is <span>not apparent).</span></li>
<li class="calibre15">Select the <strong class="bold">Auto Geometry</strong> button under the <strong class="bold">Geometry</strong> section (the left-hand side of <span>the window).</span></li>
<li class="calibre15">In the <strong class="bold">Geometry</strong> panel at the window’s bottom-right section, ensure <strong class="bold">Weights</strong> is enabled; this will automatically generate bone weights along with the mesh geometry, saving <span>a step.</span></li>
<li class="calibre15">Finish up by clicking the <strong class="bold">Generate For All </strong><span><strong class="bold">Visible</strong></span><span> button.</span></li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">2D Animation | Editor tools and <span>shortcuts: </span><a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml</span></a><span>.</span></p>
<p class="calibre3">After clicking the <strong class="bold">Generate For All Visible</strong> button for the geometry, all your sprites will have taken on coloring from the associated bones. You’ll notice that it does not look like the solid colors seen in <span><em class="italic">Figure 5</em></span><em class="italic">.2</em> since the generated weights were distributed across adjacent bones; instead, the coloring will be a gradient of the adjoining <span>bone colors.</span></p>
<p class="calibre3">This is due to both the overlapping sprites and Unity wanting to blend the sprite deformation across the bones, which is desired in some cases. We’ll be addressing this shortly in the <em class="italic">Editing sprite bone weights</em> section for the torso and neck sprites. For the remainder of the sprites, we only want one bone to influence a sprite (represented by the solid color) for<a id="_idIndexMarker537" class="pcalibre1 pcalibre calibre6"/> this <a id="_idIndexMarker538" class="pcalibre1 pcalibre calibre6"/><span>particular character.</span></p>
<p class="calibre3">We’ll fix this by adjusting the bone influence for <span>each sprite.</span></p>
<h2 id="_idParaDest-100" class="calibre8"><a id="_idTextAnchor102" class="pcalibre1 pcalibre calibre6"/>Adjusting the bone influence</h2>
<p class="calibre3">The process we’re <a id="_idIndexMarker539" class="pcalibre1 pcalibre calibre6"/>going to follow is<a id="_idIndexMarker540" class="pcalibre1 pcalibre calibre6"/> to remove – or set – bones in the <strong class="bold">Bone Influences</strong> property of the sprites. This will ensure that our character’s sprites are not deformed or distorted while positioned or rotated by only assigning a <span>single bone.</span></p>
<p class="calibre3">For a different style character, we may very well want a single sprite to be deformed by multiple bones (as we will do shortly with the torso and neck), but that is not what we want for the style character we’re <span>building here.</span></p>
<p class="calibre3">Perform the following steps to assign the correct bone influence for all of the sprites (again, except for the torso <span>and neck):</span></p>
<ol class="calibre14">
<li class="calibre15">Select the <strong class="bold">Bone Influence</strong> button under the <strong class="bold">Weights</strong> section (the left-hand side of <span>the window).</span></li>
<li class="calibre15">Double-click on a sprite. For example, in <span><em class="italic">Figure 5</em></span><em class="italic">.3</em>, we’ll double-click on the <em class="italic">wing</em> for the <span>right foot.</span><p class="calibre3">The panel in the bottom right of the window will now show the selected sprite and the bones <span>influencing it.</span></p></li>
<li class="calibre15">Since we only want one bone to influence the sprite, we’ll select <strong class="source-inline">bone_13</strong> (the yellow bone) in the list and then click the minus (<strong class="bold">-</strong>) button on the small tab below the list to <span>remove it.</span><p class="calibre3">The sprite will turn the same color as the remaining assigned bone, which is green in this case, as seen in <span><em class="italic">Figure 5</em></span><span><em class="italic">.3</em></span><span>:</span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer078">
<img alt="Figure 5.3 – Bone Influence editing" src="image/B18347_05_3.jpg" class="calibre66"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Bone Influence editing</p>
<p class="calibre3">Note that if there is more than one bone to remove, you can select multiple bones by holding the <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> key down while clicking and then clicking the minus (<strong class="bold">-</strong>) <span>button.</span></p>
<p class="calibre3">This workflow <a id="_idIndexMarker541" class="pcalibre1 pcalibre calibre6"/>was for assigning a single<a id="_idIndexMarker542" class="pcalibre1 pcalibre calibre6"/> bone to a sprite. Next, we’ll learn how to use multiple bones to influence the deformation of <span>a sprite.</span></p>
<h2 id="_idParaDest-101" class="calibre8"><a id="_idTextAnchor103" class="pcalibre1 pcalibre calibre6"/>Editing sprite bone weights</h2>
<p class="calibre3">We’ll use two<a id="_idIndexMarker543" class="pcalibre1 pcalibre calibre6"/> weight tools<a id="_idIndexMarker544" class="pcalibre1 pcalibre calibre6"/> to assign the bones and adjust the weight influence each bone has over the sprite: <strong class="bold">Weight Slider</strong> and <span><strong class="bold">Weight Brush</strong></span><span>.</span></p>
<p class="calibre3">We’ll start with <strong class="bold">Weight Slider</strong> to adjust the overall influence of the bones and then perform any fine-tuning with <span><strong class="bold">Weight Brush</strong></span><span>.</span></p>
<p class="calibre3">The <strong class="bold">Auto Weights</strong> generation may have already performed an excellent job but let’s examine the results and make some adjustments, starting with the <span>neck sprite:</span></p>
<ol class="calibre14">
<li class="calibre15">Double-click on the neck sprite (note that you can use the mouse scroll wheel to zoom in on a sprite to work <span>with it).</span></li>
<li class="calibre15"><strong class="bold">Auto Weights</strong> assigned three bones with influence over the neck sprite, so this sprite should have a color gradient representing the color of the three bones: the (green) upper torso, (cyan) neck, and (blue) head bone (see <span><em class="italic">Figure 5</em></span><span><em class="italic">.4</em></span><span>).</span></li>
<li class="calibre15">Select the <strong class="bold">Weight Slider</strong> button under the <strong class="bold">Weights</strong> section (the left-hand side of <span>the window).</span></li>
<li class="calibre15">In the <strong class="bold">Weight Slider</strong> panel in the window’s lower-right corner, you can now adjust the amount of influence a selected bone has over the sprite; drag the <strong class="bold">Amount</strong> slider <a id="_idIndexMarker545" class="pcalibre1 pcalibre calibre6"/>left or right <a id="_idIndexMarker546" class="pcalibre1 pcalibre calibre6"/>to increase or decrease <span>the influence.</span></li>
<li class="calibre15">Preview the effect of weight changes to see how the mesh deforms by rotating <span>the bones:</span><p class="calibre3">You can rotate and move bones by simply clicking and dragging on them (the mouse cursor will show a rotate or move icon, depending on where you are hovering on the bone). Adjust the <strong class="bold">Weight Slider</strong> amount until you get overall pleasing results – this operation is a lot more artistic <span>than technical:</span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer079">
<img alt="Figure 5.4 – Editing weights with Weight Brush" src="image/B18347_05_4.jpg" class="calibre67"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Editing weights with Weight Brush</p>
<p class="calibre3">You may find it challenging to get good results using <strong class="bold">Weight Slider</strong> alone. In this case, continue<a id="_idIndexMarker547" class="pcalibre1 pcalibre calibre6"/> to fine-tune<a id="_idIndexMarker548" class="pcalibre1 pcalibre calibre6"/> the bone influence for any problem areas using <span><strong class="bold">Weight Brush</strong></span><span>.</span></p>
<ol class="calibre14">
<li value="6" class="calibre15">With the sprite still selected, select the <strong class="bold">Weight Brush</strong> button under the <strong class="bold">Weights</strong> section (the left-hand side of <span>the window).</span></li>
<li class="calibre15">Click on the bone you want to paint <span>weights for.</span></li>
<li class="calibre15">You can now adjust the <strong class="bold">Weight Brush</strong> properties in the <strong class="bold">Weight Brush</strong> panel in the window’s lower-right corner or start painting weights. The sprite mesh geometry will update in real time as <span>you paint.</span></li>
<li class="calibre15">Continue to rotate the bones by hovering your mouse over the bone to show the rotate icon. Then, click and drag to rotate the bone to test the weight painting and adjust it until you’ve achieved the <span>desired results.</span></li>
</ol>
<p class="calibre3">Note that you can undo bone rotations using <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">Z</em>. If you’ve made many bone rotations and aren’t sure how much influence is being applied, then you can use the <strong class="bold">Reset Pose</strong> button under the <strong class="bold">Pose</strong> section (the top-left corner of the window) to <span>start over.</span></p>
<p class="calibre3">Continue to repeat this process for the actor’s torso. Once you’re finished with the torso, this is probably a great time to think about saving your work. Use the <strong class="bold">Apply</strong> button in the toolbar on the <span>right-hand side.</span></p>
<p class="calibre3">When you’re relatively satisfied with the bone weights and want to see how things are progressing, you can do some pose tests! Doing some pose tests allows you to test the range of motion and see if the sprites are associated with only the correct bones that influence the sprite weights without undesirable distortion. This provides you with the first indication of how<a id="_idIndexMarker549" class="pcalibre1 pcalibre calibre6"/> the character <a id="_idIndexMarker550" class="pcalibre1 pcalibre calibre6"/>may look <span>when animated.</span></p>
<p class="calibre3"><span><em class="italic">Figure 5</em></span><em class="italic">.5</em> represents an example of a test pose for <span>the actor:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer080">
<img alt="Figure 5.5 – Pose test for the actor" src="image/B18347_05_5.jpg" class="calibre68"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Pose test for the actor</p>
<p class="calibre3">Being able to pose our character is great, but for the limbs, in particular, it can be time-consuming and challenging to get good results by rotating all the bones individually. Thankfully, there <a id="_idIndexMarker551" class="pcalibre1 pcalibre calibre6"/>is a <a id="_idIndexMarker552" class="pcalibre1 pcalibre calibre6"/>better way – <span>using </span><span><strong class="bold">IK</strong></span><span>.</span></p>
<h2 id="_idParaDest-102" class="calibre8"><a id="_idTextAnchor104" class="pcalibre1 pcalibre calibre6"/>Setting up inverse kinematics (IK)</h2>
<p class="calibre3">We’ve now <a id="_idIndexMarker553" class="pcalibre1 pcalibre calibre6"/>finished<a id="_idIndexMarker554" class="pcalibre1 pcalibre calibre6"/> working with <strong class="bold">Skinning Editor</strong> and will continue working with the actor in the scene to add IK. So, let’s create a Prefab from the actor for our <span>player character:</span></p>
<ol class="calibre14">
<li class="calibre15">Drag the <strong class="source-inline">PlayerCharacter1</strong> asset from the <strong class="bold">Project</strong> window into the <strong class="bold">Hierarchy</strong> window or <strong class="bold">Scene</strong> view (optionally, you can create a new empty scene to <span>work in).</span></li>
<li class="calibre15">Parent the actor to a new empty GameObject and name <span>it </span><span><strong class="source-inline">Player</strong></span><span>.</span></li>
<li class="calibre15">Then, drag the GameObject into the <strong class="source-inline">Assets/Prefabs</strong> folder to create <span>the Prefab.</span></li>
</ol>
<p class="calibre3">Since we’ll be using an IK setup to position our actor for animation, we’ll want to change the actor’s rig to make posing the limbs – in particular, the legs – much better. We could have done this when we first created the actor’s rig, but it’s easier to show the reason for this change while implementing IK, and it shows that we can go back and make changes to the bone structure at any time and make corrections <span>where necessary.</span></p>
<p class="calibre3">Next, we’ll be adding a new root bone to the rig using the same <strong class="bold">Create Bone</strong> workflow we used to create the actor’s complete <span>skeleton rig:</span></p>
<ol class="calibre14">
<li class="calibre15">Start a new bone at the feet of the actor and name <span>it </span><span><strong class="source-inline">root_bone</strong></span><span>.</span></li>
<li class="calibre15">Change the color to gray (just as an indication to us that no sprites are being influenced <span>by it).</span></li>
<li class="calibre15">Now, click and drag the existing rig (<strong class="source-inline">bone_1</strong>) to parent it to the new root bone, as shown in <span><em class="italic">Figure 5</em></span><span><em class="italic">.6</em></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer081">
<img alt="Figure 5.6 – Adding root_bone for IK and the parent existing rig" src="image/B18347_05_6.jpg" class="calibre69"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Adding root_bone for IK and the parent existing rig</p>
<p class="calibre3">Be patient with me – this<a id="_idIndexMarker555" class="pcalibre1 pcalibre calibre6"/> will all make<a id="_idIndexMarker556" class="pcalibre1 pcalibre calibre6"/> sense in a bit when we add <strong class="bold">IK Limb Solvers</strong> for <span>the legs.</span></p>
<h3 class="calibre10">Adding IK Solvers</h3>
<p class="calibre3">We will make IK-constrained<a id="_idIndexMarker557" class="pcalibre1 pcalibre calibre6"/> limbs for the arms and legs, starting with the right arm (the arm in front of <span>the actor).</span></p>
<p class="calibre3">First, let’s add GameObjects that act as our IK Effectors (the transform the IK Solver solves for) and work in tandem with the limb <span>solver’s Target:</span></p>
<ol class="calibre14">
<li class="calibre15">Select the forearm bone of the arm in front of the character’s torso – <strong class="source-inline">bone_7</strong> in <span>my case.</span></li>
<li class="calibre15">Right-click on it in the <strong class="bold">Inspector</strong> window and click <strong class="bold">Create Empty</strong> to add a child GameObject – this will make the new object a sibling of the <span>hand bone.</span></li>
<li class="calibre15">Rename it <strong class="source-inline">IK Effector</strong> and then position it at the tip of the <span>forearm bone.</span></li>
<li class="calibre15">Using the red arrow of the position tool gizmo, drag it down, extending it past the hand just a bit. Positioning the effector outside of the sprites will make them more visible and easier to click on to manipulate (this step is purely personal preference; you may also leave it at the tip of the <span>forearm bone).</span></li>
<li class="calibre15">Repeat these steps for the other arm (the arm behind the actor) and <span>both legs.</span></li>
<li class="calibre15">With our effectors in place, add the <strong class="source-inline">IK Manager 2D</strong> component to the root bone and start adding <strong class="bold">IK Solvers</strong> for the limbs by clicking the plus (<strong class="bold">+</strong>) button in the tab and then <span>selecting </span><span><strong class="bold">Limb</strong></span><span>.</span></li>
</ol>
<p class="calibre3">We’re making this selection because it’s meant for posing joints specifically for arms and legs (also known<a id="_idIndexMarker558" class="pcalibre1 pcalibre calibre6"/> as a <span><strong class="bold">two-bone Solver</strong></span><span>).</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">IK <span>Solvers: </span><a href="https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers</span></a><span>.</span></p>
<p class="calibre3">Adding an <strong class="bold">IK Solver</strong> property to the list will automatically add a new GameObject to the bottom of the actor object hierarchy named <strong class="bold">New LimbSolver2D</strong> with a <strong class="source-inline">LimbSolver2D</strong> <span>component</span><span><a id="_idIndexMarker559" class="pcalibre1 pcalibre calibre6"/></span><span> added.</span></p>
<p class="calibre3">Perform the following steps to complete the IK limb setup for the <span>front arm:</span></p>
<ol class="calibre14">
<li class="calibre15">Rename <strong class="source-inline">New LimbSovler2D</strong> to <strong class="source-inline">Front Arm LimbSolver2D</strong> and keep it selected so that the <strong class="source-inline">LimbSolver2D</strong> component is visible in the <span><strong class="bold">Inspector</strong></span><span> window.</span></li>
<li class="calibre15">Click and drag the <strong class="source-inline">IK Effector</strong> object for the front forearm to the <strong class="bold">Effector</strong> field of the <span><strong class="source-inline">LimbSolver2D</strong></span><span> component.</span></li>
<li class="calibre15">Once this <strong class="bold">Effector</strong> has been assigned, we can click the <strong class="bold">Create Target</strong> button – which visually sets a color to the dot at the base of the bone for all bones in the IK chain. This will also create a <strong class="source-inline">_Target</strong> child GameObject for the limb solver that we can now manipulate the position of in the <strong class="bold">Scene</strong> view to pose <span>the limb.</span></li>
<li class="calibre15">Click and drag the circle icon that has now appeared on the <strong class="bold">Target</strong> transform in the <strong class="bold">Scene</strong> view to test out the <span>IK limb.</span></li>
<li class="calibre15">Note that the default value for <strong class="bold">Flip</strong> is disabled, which may work just fine for how the target was created, but if the limb is bending backward as you drag the target around, then enable <strong class="bold">Flip</strong> to solve <span>this issue.</span></li>
</ol>
<p class="calibre3"><span><em class="italic">Figure 5</em></span><em class="italic">.7</em> illustrates the results of <span>these steps:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer082">
<img alt="Figure 5.7 – IK Effector and limb solver setup" src="image/B18347_05_7.jpg" class="calibre70"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.7 – IK Effector and limb solver setup</p>
<p class="calibre3">The <strong class="source-inline">Front Arm LimbSolver2D_Target</strong> object’s transform position is what is keyframed <span>during</span><span><a id="_idIndexMarker560" class="pcalibre1 pcalibre calibre6"/></span><span> animation.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Once the IK Solvers have been set up, we can no longer scale the player character with the <strong class="bold">Pixels Per Unit</strong> value in the <strong class="bold">PSD Importer</strong> settings – this is due to the IK targets being based on the transform local positions, which won’t update when the sprite’s PPU is scaled. Instead, change the transform scale on the parented <span><strong class="source-inline1">PlayerCharacter1</strong></span><span> object.</span></p>
<p class="calibre3">You can now follow these steps any time you need to create an IK limb on a skinned actor rig. Go ahead <a id="_idIndexMarker561" class="pcalibre1 pcalibre calibre6"/>and make IK limbs for the back arm and both legs. With that, we’re ready <span>to animate!</span></p>
<p class="callout-heading">Reminder</p>
<p class="callout">Don’t forget to apply changes to the <span><strong class="source-inline1">Player</strong></span><span> Prefab!</span></p>
<p class="callout-heading">Additional resources | 2D characters</p>
<p class="callout">Another option for getting a head start on creating your rigged and animated 2D characters is to work with existing example characters from either the Dagon Crashers or Lost Crypt sample projects that Unity provides on the <span>Asset Store:</span></p>
<p class="callout">Dragon <span>Crashers: </span><a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721" class="pcalibre1 pcalibre calibre6"><span>https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721</span></a><span>.</span></p>
<p class="callout">Lost <span>Crypt: </span><a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673" class="pcalibre1 pcalibre calibre6"><span>https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673</span></a><span>.</span></p>
<h2 id="_idParaDest-103" class="calibre8"><a id="_idTextAnchor105" class="pcalibre1 pcalibre calibre6"/>Creating actor animations</h2>
<p class="calibre3"><strong class="bold">Actor animation</strong> is the <a id="_idIndexMarker562" class="pcalibre1 pcalibre calibre6"/>process of<a id="_idIndexMarker563" class="pcalibre1 pcalibre calibre6"/> repositioning or rotating the actor’s bones at different times on the timeline of the <strong class="bold">Animation</strong> window, which is recorded as keyframes that hold the transform data. In <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 4</em></span></a>, we performed a simpler version of this process when we animated <span>the vines.</span></p>
<p class="calibre3">Let’s start animating <span>the actor:</span></p>
<ol class="calibre14">
<li class="calibre15">First, we’ll make an idle animation by opening the <strong class="bold">Animation</strong> window by going to <strong class="bold">Window</strong> | <strong class="bold">Animation</strong> | <span><strong class="bold">Animation</strong></span><span>.</span></li>
<li class="calibre15">Select <strong class="source-inline">PlayerCharacter1</strong> in the hierarchy (not the root <strong class="source-inline">Player</strong> object; we want to animate the <em class="italic">graphics</em>, which can be later switched out with a different actor that may not have the same skeletal rig) and click the <span><strong class="bold">Create</strong></span><span> button.</span></li>
<li class="calibre15">This will create an animation asset file (<strong class="source-inline">.anim</strong>) that we’ll name <strong class="source-inline">Player Idle</strong> and save to the <span><strong class="source-inline">Assets/Animation</strong></span><span> folder.</span></li>
</ol>
<p class="calibre3">Now, put your animator hat on again, because it’s time <span>to animate!</span></p>
<p class="calibre3">The first thing to note while animating with IK limbs is why we added the new root bone in the <em class="italic">Setting Up inverse kinematics (IK)</em> section. Select the <strong class="bold">Move</strong> tool in the <strong class="bold">Scene</strong> view and click on the actor. With the bones now visible, select the pelvic bone (<strong class="source-inline">bone_1</strong>, our <em class="italic">original</em> <span>root bone).</span></p>
<p class="calibre3">You’ll notice that a square outline has appeared at the larger end of the bone (the base) and that hovering the mouse pointer within this square will show a move icon. Hovering over the part of the bone outside of the square will show a rotate icon. Click and hold the left-mouse button within the square and slowly drag <span>it down.</span></p>
<p class="calibre3">The whole actor will start to move down except for the feet – they will remain firmly grounded in place. This <a id="_idIndexMarker564" class="pcalibre1 pcalibre calibre6"/>would not be <a id="_idIndexMarker565" class="pcalibre1 pcalibre calibre6"/>possible without IK and the new root bone we <span>added. Yay!</span></p>
<p class="calibre3">One more thing to note with the IK limbs before letting you lose to create your idle animation – you can position the limbs in <span>two ways:</span></p>
<ul class="calibre17">
<li class="calibre15">By clicking and dragging the IK circular targets in the <span><strong class="bold">Scene</strong></span><span> view</span></li>
<li class="calibre15">By selecting the <strong class="source-inline">… LimbSolver2D_Target</strong> objects in the <strong class="bold">Hierarchy</strong> window and using the <strong class="bold">Move</strong> tool in the <strong class="bold">Scene</strong> view (or entering <strong class="bold">Transform</strong> values in the <span><strong class="bold">Inspector</strong></span><span> window)</span></li>
</ul>
<p class="calibre3">Do not try to keyframe individual bones in the IK chains, the IK Effector objects, or the objects with the <strong class="source-inline">LimbSolver2D</strong> components! Create your idle animation by following <span>these steps:</span></p>
<ol class="calibre14">
<li class="calibre15">Click the red record button (the <strong class="bold">Animation</strong> window; <strong class="bold">Keyframe Recording</strong> mode) to start recording keyframes (any time a bone is rotated or repositioned, a key will <span>be created).</span></li>
<li class="calibre15">Pose your actor into a nice starting position for a simple idling <span>in place.</span></li>
<li class="calibre15">Scrub the timeline ahead about 1.5 seconds and make a second pose by lowering the torso bending into the knees, bending the arms, and tilting down the head slightly – something <span>like that.</span></li>
<li class="calibre15">Now, to animate between these two poses, click and drag a rectangle around the starting frame’s keys – press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">C</em> to copy <span>those keys.</span></li>
<li class="calibre15">Scrub the timeline to 3 seconds and press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">V</em> to paste <span>the keys.</span></li>
<li class="calibre15">Click the red record button again to stop recording, then use the <strong class="bold">Play</strong> button to check <span>the results.</span></li>
</ol>
<p class="calibre3">You know the drill – animation<a id="_idIndexMarker566" class="pcalibre1 pcalibre calibre6"/> is more <a id="_idIndexMarker567" class="pcalibre1 pcalibre calibre6"/>art than technical, so fiddle with the poses and timing until you get good results. <span><em class="italic">Figure 5</em></span><em class="italic">.8</em> illustrates a completed actor <span>idle animation:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer083">
<img alt="Figure 5.8 – Actor keyframe idle animation" src="image/B18347_05_8.jpg" class="calibre71"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Actor keyframe idle animation</p>
<p class="calibre3">Note that in <span><em class="italic">Figure 5</em></span><em class="italic">.8</em>, I’ve changed the color of the IK Solvers (the <strong class="source-inline">IKManager2D</strong> component on the <strong class="source-inline">root_bone</strong> object) to give the limb bones their own color – another way to visually organize the different components that make up the actor and make it a bit easier to <span>work with.</span></p>
<p class="calibre3">With our base idle animation added to the character, let’s look at how to drive animation and<a id="_idIndexMarker568" class="pcalibre1 pcalibre calibre6"/> apply movement to <a id="_idIndexMarker569" class="pcalibre1 pcalibre calibre6"/>our character from <span>player input.</span></p>
<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor106" class="pcalibre1 pcalibre calibre6"/>Using an Input Action Map</h1>
<p class="calibre3">We’ll continue to use<a id="_idIndexMarker570" class="pcalibre1 pcalibre calibre6"/> the new <strong class="bold">Input System</strong> for the adventure game player<a id="_idIndexMarker571" class="pcalibre1 pcalibre calibre6"/> input. So, let’s first make sure we have the <strong class="source-inline">Input System</strong> <span>package installed:</span></p>
<ol class="calibre14">
<li class="calibre15">Open <strong class="bold">Package Manager</strong> by going to <strong class="bold">Window</strong> | <span><strong class="bold">Package Manager</strong></span><span>.</span></li>
<li class="calibre15">The default <strong class="bold">Packages</strong> location is <strong class="bold">In Project</strong>, so if you see <strong class="bold">Input System</strong> in the list under the <strong class="bold">Package – Unity</strong> section, then we’re <span>all set!</span></li>
<li class="calibre15">If you can’t find <strong class="bold">Input System</strong>, then switch the <strong class="bold">Packages</strong> dropdown to <strong class="bold">Unity Registry</strong>, select <strong class="bold">Input System</strong> from the list, and click <strong class="bold">Install</strong> (the bottom-right corner of the window). See <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 2</em></span></a>, section <em class="italic">New Input System</em> for <span>a refresher.</span></li>
</ol>
<p class="calibre3">For the collection game, we received input directly from <strong class="bold">Input Device</strong>; this time, we will use the <strong class="bold">Input Action</strong> approach. For that, we’re going to need an <strong class="bold">Action </strong><span><strong class="bold">Map</strong></span><span> asset.</span></p>
<p class="calibre3">Thankfully, creating a default action map for the player character is quite trivial – with most of the device inputs we’ll need for the keyboard and a game controller <span>already made!</span></p>
<p class="calibre3">Follow these steps to <span>accomplish this:</span></p>
<ol class="calibre14">
<li class="calibre15">The magic happens via the <strong class="source-inline">Player Input</strong> component. So, add it to the root object of the <strong class="source-inline">Player</strong> Prefab by using the <strong class="bold">Add Component</strong> button in the <span><strong class="bold">Inspector</strong></span><span> window.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">You can work with the <strong class="source-inline1">Player</strong> Prefab by adding it to a scene or working on it directly by double-clicking the Prefab in the <span><strong class="bold">Project</strong></span><span> window.</span></p>
<ol class="calibre14">
<li value="2" class="calibre15">Once the <strong class="source-inline">Player Input</strong> component has been added, click the <strong class="bold">Create Actions…</strong> button, as shown in <a id="_idIndexMarker572" class="pcalibre1 pcalibre calibre6"/>the<a id="_idIndexMarker573" class="pcalibre1 pcalibre calibre6"/> following screenshot. This will create a default<a id="_idIndexMarker574" class="pcalibre1 pcalibre calibre6"/> set of <strong class="bold">Input Action Maps</strong>, <strong class="bold">Input Actions</strong>, and <span><strong class="bold">Input Bindings</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer084">
<img alt="Figure 5.9 – Player Input | Create Actions" src="image/B18347_05_9.jpg" class="calibre72"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Player Input | Create Actions</p>
<ol class="calibre14">
<li value="3" class="calibre15">You will be prompted to save the new <strong class="source-inline">.inputactions</strong> asset. Select the <strong class="source-inline">Assets/Settings</strong> folder and use <strong class="source-inline">Player Input</strong> as the name for it. This asset will then be connected to the <strong class="source-inline">Player Input</strong> component and<a id="_idIndexMarker575" class="pcalibre1 pcalibre calibre6"/> bring up the <strong class="bold">Input </strong><span><strong class="bold">Actions editor</strong></span><span>.</span></li>
</ol>
<p class="calibre3">Here, we can see all of the actions pre-populated for the player action map, as shown in <span><em class="italic">Figure 5</em></span><em class="italic">.10</em> – everything we need <span>plus more!</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer085">
<img alt="Figure 5.10 – Player Input Action Maps (Input Actions)" src="image/B18347_05_10.jpg" class="calibre73"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Player Input Action Maps (Input Actions)</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Input <span>System: </span><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml</span></a><span>.</span></p>
<p class="callout">Editing Input Actions <span>Assets: </span><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets</span></a><span>.</span></p>
<p class="calibre3">The <strong class="source-inline">Player Input</strong> component<a id="_idIndexMarker576" class="pcalibre1 pcalibre calibre6"/> also provides everything we need to respond to input from the player. <span><em class="italic">Figure 5</em></span><em class="italic">.10</em> sets the <strong class="bold">Behavior</strong> field to the <strong class="bold">Send Messages</strong> value. This means that when <strong class="bold">Player Input</strong> receives input from the player, it will use <strong class="source-inline">SendMessage()</strong> on the GameObject to which the <strong class="source-inline">Player Input</strong> component belongs, calling the name on every component (<strong class="source-inline">MonoBehaviour</strong>) added to the GameObject. As shown in <span><em class="italic">Figure 5</em></span><em class="italic">.10</em>, the relevant method names will be called as listed in the box just below the <span><strong class="bold">Behavior</strong></span><span> field.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Notification <span>behaviors: </span><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors</span></a><span>.</span></p>
<p class="calibre3">For simplicity’s sake, we’ll stick with the <strong class="bold">Send Messages</strong> behavior. In cases where input events could occur quite rapidly, <strong class="bold">Invoke Unity Events</strong> would be preferred over <strong class="source-inline">SendMessage()</strong>, which is slower due to having to <span>use </span><span><strong class="bold">Reflection</strong></span><span>.</span></p>
<p class="callout-heading">Reflection | C#</p>
<p class="callout"><strong class="source-inline1">SendMessage()</strong> heavily relies on <strong class="bold">Reflection</strong> to find the method to call at runtime. <strong class="bold">Reflection</strong> is slow (supposedly 3x slower than calling the method directly) because it requires managed code to read (search) its metadata to <span>find assemblies.</span></p>
<p class="calibre3">With our input set <a id="_idIndexMarker577" class="pcalibre1 pcalibre calibre6"/>up and we know how to respond to the inputs we’ve defined, we’re ready to write our player <span>controller code!</span></p>
<h1 id="_idParaDest-105" class="calibre5"><a id="_idTextAnchor107" class="pcalibre1 pcalibre calibre6"/>Moving the player with a player controller script</h1>
<p class="calibre3">We’ll need more<a id="_idIndexMarker578" class="pcalibre1 pcalibre calibre6"/> than just input to move our player <a id="_idIndexMarker579" class="pcalibre1 pcalibre calibre6"/>character around the level. We’ll have to configure the <strong class="source-inline">Player</strong> object to work with the <strong class="bold">Physics</strong> system so that it interacts with our level’s ground and platforms and interactivity trigger volumes, and then applies the <span>movement force.</span></p>
<p class="calibre3">Configure the <strong class="source-inline">Player</strong> Prefab’s root GameObject with the following components while referring to <span><em class="italic">Figure 5</em></span><span><em class="italic">.11</em></span><span>:</span></p>
<ol class="calibre14">
<li class="calibre15">Add a <strong class="source-inline">Rigidbody2D</strong> component (by pressing the <strong class="bold">Add Component</strong> button) with <span>these values:</span><ol class="calibre42"><li class="upper-roman"><strong class="bold">Use Auto Mass</strong> enabled: Physics objects react more believably in the physics simulation if they have proper mass. This setting will estimate the mass based on the density and area of the <span>accompanying collider.</span></li><li class="upper-roman"><strong class="bold">Linear Drag</strong> = <strong class="source-inline">1</strong>: We’ll add some drag to the player’s movement to provide additional constraints on the move to help the player feel more grounded and not <span>very floaty.</span></li><li class="upper-roman"><strong class="bold">Constraints</strong> | <strong class="bold">Freeze Rotation Z</strong> enabled: We want to prevent the player from spinning around and have them always stand vertically (perpendicular to the <span>ground plane).</span></li></ol></li>
<li class="calibre15">Add <strong class="source-inline">CapsuleCollider2D</strong> (by pressing the <strong class="bold">Add Component</strong> button). Use the <strong class="bold">Edit bounding volume</strong> button and modify the collider’s shape until it encompasses <span>the actor.</span><p class="calibre3">This represents <a id="_idIndexMarker580" class="pcalibre1 pcalibre calibre6"/>the<a id="_idIndexMarker581" class="pcalibre1 pcalibre calibre6"/> player’s hitbox, which may need to be adjusted over time as <span>you playtest:</span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer086">
<img alt="Figure 5.11 – Player physics setup" src="image/B18347_05_11.jpg" class="calibre74"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Player physics setup</p>
<p class="calibre3">With the required <strong class="bold">Physics</strong> components now added and configured for the player, let’s have a look at taking player input and applying the movement force through code since the <strong class="source-inline">Player Input</strong> component<a id="_idIndexMarker582" class="pcalibre1 pcalibre calibre6"/> is <a id="_idIndexMarker583" class="pcalibre1 pcalibre calibre6"/>only responsible for reading the device input and invoking the <span>assigned action.</span></p>
<h2 id="_idParaDest-106" class="calibre8"><a id="_idTextAnchor108" class="pcalibre1 pcalibre calibre6"/>Processing Player Input</h2>
<p class="calibre3">While we could use the <a id="_idIndexMarker584" class="pcalibre1 pcalibre calibre6"/>device input directly, as we did in the <em class="italic">Player controller script</em> section of <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 2</em></span></a>, it’s essential to understand the value of using <strong class="bold">Input Action Map</strong>. Here are a <span>few examples:</span></p>
<ul class="calibre17">
<li class="calibre15">Multiple device inputs can be simultaneously configured without the need to change the input <span>handling code</span></li>
<li class="calibre15">A different action map can be switched to, depending on the current input <span>actions required</span></li>
<li class="calibre15">Key rebinding can be implemented without changing the input <span>handling code</span></li>
</ul>
<p class="calibre3">Armed with this knowledge, you can determine the best approach for different use cases (are you prototyping? Are you engineering a flexible solution for a <span>commercial title?).</span></p>
<p class="calibre3">Previously, we continuously polled the <strong class="source-inline">isPressed</strong> key state directly on the input device in the <strong class="source-inline">Update()</strong> loop to control the player movement, <span>like so:</span></p>
<pre class="source-code">
void Update()
{
    if (keyboard.aKey.isPressed
        || keyboard.leftArrowKey.isPressed)
            _moveHorizontal = -1.0f;
    …
}</pre> <p class="calibre3">Since we’re receiving <a id="_idIndexMarker585" class="pcalibre1 pcalibre calibre6"/>our input handling from <strong class="source-inline">SendMessage()</strong> now, we’ll need to make <span>some changes.</span></p>
<p class="calibre3"><strong class="source-inline">SendMessage()</strong> is called anytime there is input. Input is not continuously polled! It behaves like an event whenever an input action occurs, which means that for the <em class="italic">Move</em> action, <strong class="source-inline">OnMove()</strong> will be called when a key is pressed and when <span>it’s released.</span></p>
<p class="calibre3">The <strong class="bold">Inspector</strong> window in <span><em class="italic">Figure 5</em></span><em class="italic">.10</em> shows all the <strong class="source-inline">SendMessage()</strong> method names that were invoked for the defined <span>input actions.</span></p>
<p class="calibre3"><strong class="source-inline">SendMessage()</strong> will also pass an <strong class="source-inline">InputValue</strong> parameter representing the <strong class="bold">Action Type</strong> and <strong class="bold">Control Type</strong> – <strong class="source-inline">Vector2</strong> in the case of <em class="italic">Move</em>, which holds the horizontal and vertical <span>input values.</span></p>
<p class="calibre3">We’ll use the horizontal (X-axis) value to determine if a <strong class="bold">move left/right</strong> button was pressed or released since we want to move our player while the button is being held down (or while holding a game controller’s stick in a <span>certain direction).</span></p>
<p class="calibre3">Our <strong class="source-inline">move</strong> method (<strong class="source-inline">OnMove()</strong>) will be called with a <strong class="source-inline">Vector2</strong> X-axis value for a horizontal input of <strong class="source-inline">-1</strong> and <strong class="source-inline">1</strong> for left and right, respectively, when a button is pressed, and a value of <strong class="source-inline">0</strong> when the button <span>is released.</span></p>
<p class="calibre3">Now that we have all<a id="_idIndexMarker586" class="pcalibre1 pcalibre calibre6"/> this information, we can begin to code our <span>input handler!</span></p>
<h2 id="_idParaDest-107" class="calibre8"><a id="_idTextAnchor109" class="pcalibre1 pcalibre calibre6"/>Creating the PlayerController script</h2>
<p class="calibre3">Let’s start by <a id="_idIndexMarker587" class="pcalibre1 pcalibre calibre6"/>creating a new C# script named <strong class="source-inline">PlayerController</strong> in the <span><strong class="source-inline">Assets/Scripts</strong></span><span> folder.</span></p>
<p class="calibre3">We can now add our input handler method for the <em class="italic">move</em> action – <strong class="source-inline">OnMove()</strong> – and assign the <strong class="source-inline">InputValue</strong> parameter’s <strong class="source-inline">Vector2</strong> value to a private member variable named <strong class="source-inline">_movementInput</strong>. We’ll use this later when we calculate the movement to be applied to the player’s <span><strong class="bold">Rigidbody2D</strong></span><span> velocity.</span></p>
<p class="calibre3">Here’s what our initial code <span>looks like:</span></p>
<pre class="source-code">
public class PlayerController : MonoBehaviour
{
    private Vector2 _movementInput;
    void OnMove(InputValue value)
    {
        var move = value.Get&lt;Vector2&gt;();
        _movementInput = (move.x != 0f)
            ? new Vector2(move.x, 0f) : Vector2.zero;
    }
}</pre> <p class="calibre3">We read the input values of the input using the <strong class="source-inline">Get()</strong> method of the <strong class="source-inline">value</strong> parameter variable. We’re only interested in the horizontal movement here and will set the <strong class="source-inline">_movementInput</strong> value depending on the input state: pressed <span>or released.</span></p>
<p class="calibre3">So, if <strong class="source-inline">move.x</strong> equals <strong class="source-inline">0</strong>, then the button key was released (think of it as <strong class="source-inline">IsPressed == false</strong>). Then, using a ternary operator (<strong class="source-inline">?:</strong>), we’ll assign <strong class="source-inline">Vector2.zero</strong> to make sure that any/all input <span>is ignored.</span></p>
<p class="calibre3">When <strong class="source-inline">move.x</strong> is not equal to zero, we have a button key press input value that represents the direction (<strong class="source-inline">-1</strong>: <em class="italic">left</em>, <strong class="source-inline">1</strong>: <em class="italic">right</em>) and assign it to <strong class="source-inline">_movementInput</strong> with a new <strong class="source-inline">Vector2</strong> of the direction and no vertical value: <strong class="source-inline">new </strong><span><strong class="source-inline">Vector2(move.x, 0f)</strong></span><span>.</span></p>
<p class="calibre3">With this approach, we can still respond to vertical input later, such as one for a jetpack! Now that we have a direction, we can apply force (in the form of velocity) to move the player character in<a id="_idIndexMarker588" class="pcalibre1 pcalibre calibre6"/> <span>that direction.</span></p>
<p class="calibre3">Let’s add the following code to <span>handle this:</span></p>
<pre class="source-code">
private Rigidbody2D _rb;
void Awake() =&gt; _rb = GetComponent&lt;Rigidbody2D&gt;();
void FixedUpdate() =&gt; UpdateVelocity();
private void UpdateVelocity()
{
    var velocity = _rb.velocity;
    velocity += Time.fixedDeltaTime * _movementInput;
    _rb.velocity = velocity;
}</pre> <p class="calibre3">Let’s break this code down item <span>by item:</span></p>
<ul class="calibre17">
<li class="calibre15">The <strong class="source-inline">_rb</strong> variable: This private member variable will hold a reference to the <strong class="source-inline">Rigidbody2D</strong> component that we previously added, and we’ll be setting the velocity here to move the player. We once made this a <strong class="source-inline">public</strong> field that could be assigned in the <strong class="bold">Inspector</strong> window, but we’ll keep it private this time to <span>encapsulate it.</span></li>
<li class="calibre15">The <strong class="source-inline">Awake()</strong> method (expression body): Since our <strong class="source-inline">Rigidbody2D</strong> variable is private, we’re only using this Unity message event to get the reference to the <strong class="source-inline">Rigidbody2D</strong> component on this object at runtime <span>using </span><span><strong class="source-inline">GetComponent()</strong></span><span>.</span></li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">GameObject.GetComponent</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml</span></a><span>.</span></p>
<ul class="calibre17">
<li class="calibre15">The <strong class="source-inline">FixedUpdate()</strong> method (expression body): This Unity message event is called at <a id="_idIndexMarker589" class="pcalibre1 pcalibre calibre6"/>every <strong class="bold">Physics Fixed Timestep</strong> and should always be used when applying<a id="_idIndexMarker590" class="pcalibre1 pcalibre calibre6"/> physics. Here, we’re simply calling the <span><strong class="source-inline">UpdateVelocity()</strong></span><span> method.</span></li>
<li class="calibre15">The <strong class="source-inline">UpdateVelocity()</strong> method: This method will calculate and apply the velocity vector to the Player’s <span><strong class="source-inline">Rigidbody2D</strong></span><span> component.</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">var velocity</strong>: This holds the current value of the <strong class="source-inline">Rigidbody2D</strong> component’s velocity that we’ll modify and <span>assign back.</span></li><li class="calibre15">The <strong class="source-inline">velocity</strong> calculation: This adds the movement input vector multiplied by <strong class="source-inline">fixedDeltaTime</strong> to the velocity variable. Multiplying by <strong class="source-inline">fixedDeltaTime</strong> ensures frame <span>rate independence.</span></li><li class="calibre15">The <strong class="source-inline">_rb.velocity</strong> assignment: Here, we simply assign the calculated velocity back to the <strong class="source-inline">Rigidbody2D</strong> component, which moves the player. Remember that <strong class="source-inline">FixedUpdate</strong> should always be used for executing physics-related code, especially for applying force to a <span><strong class="source-inline">Rigidbody</strong></span><span> component!</span></li></ul></li>
</ul>
<p class="callout-heading">Author’s note</p>
<p class="callout">I’ve read discussions on whether it’s necessary to apply <strong class="source-inline1">deltaTime</strong> in <strong class="source-inline1">FixedUpdate</strong> because it runs at a consistent framerate. Anyway, I err on the side of knowing that the <strong class="source-inline1">FixedUpdate</strong> interval is always relative to the in-game time. Also, the Unity-provided example code always includes <strong class="source-inline1">deltaTime</strong>, and being consistent in including it will ensure we achieve frame rate independence across <span>all devices.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">Time.fixedDeltaTime</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml</span></a><span>.</span></p>
<p class="callout">Time and Frame Rate <span>Management: </span><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml</span></a><span>.</span></p>
<p class="calibre3">Multiplying by zero always gives zero, so <strong class="source-inline">Vector2.zero</strong> with <strong class="source-inline">_movementInput</strong> will assign a velocity value of zero, stopping the <span>player’s movement.</span></p>
<p class="calibre3">We’ve applied velocity to the player, but don’t get too excited. This will likely have no net effect on <a id="_idIndexMarker591" class="pcalibre1 pcalibre calibre6"/>moving the player because the velocity value is too small! Let’s fix that by applying an acceleration multiplier to <span>the velocity.</span></p>
<p class="calibre3">Add the following member variables and make the changes that are shown here to the <span><strong class="source-inline">UpdateVelocity()</strong></span><span> method:</span></p>
<pre class="source-code">
[Header("Movement")]
[SerializeField] private float _acceleration = 0.0f;
[SerializeField] private float _speedMax = 0.0f;
private void UpdateVelocity()
{
    var velocity = _rb.velocity;
    velocity += _acceleration * Time.fixedDeltaTime
        * _movementInput;
    velocity.x = Mathf.Clamp(velocity.x,
        -_speedMax, _speedMax);
    _rb.velocity = velocity;
}</pre> <p class="calibre3">Let’s break down <span>these changes:</span></p>
<ul class="calibre17">
<li class="calibre15">We’ve added two new variables, <strong class="source-inline">_acceleration</strong> and <strong class="source-inline">_speedMax</strong>, which we’ve set to private but made available to assign in the <strong class="bold">Inspector</strong> window by introducing a new attribute. By using the <strong class="source-inline">[SerializeField]</strong> attribute to decorate a private accessor field, we’re telling Unity to serialize it and make it available for assignment in the <strong class="bold">Inspector</strong> window without making it public. This allows us to follow good OOP practices<a id="_idIndexMarker592" class="pcalibre1 pcalibre calibre6"/> such as <strong class="bold">encapsulation</strong> so that other classes won’t be able to modify the <span>field’s values:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">_acceleration</strong>: This <a id="_idIndexMarker593" class="pcalibre1 pcalibre calibre6"/>applies our overall velocity amount (force) for how quickly we’ll reach the maximum <span>speed value.</span></li><li class="calibre15"><strong class="source-inline">_speedMax</strong>: The maximum speed of the player <span>character’s movement.</span></li></ul></li>
<li class="calibre15">In the <strong class="source-inline">UpdateVelocity()</strong> method, we’ve made the <span>following changes:</span><ul class="calibre22"><li class="calibre15">We’ve modified the line that adds to the velocity vector by multiplying by the <span><strong class="source-inline">_acceleration</strong></span><span> value.</span></li><li class="calibre15">We’ve ensured that <strong class="source-inline">velocity.x</strong> will be clamped to the maximum speed value by using the <span><strong class="source-inline">Mathf.Clamp()</strong></span><span> method.</span></li></ul></li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">SerializeField</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml</span></a><span>.</span></p>
<p class="calibre3">You can now add the <strong class="source-inline">PlayerController</strong> script to the root of the <strong class="source-inline">Player</strong> Prefab, add your player to a scene with some ground (don’t forget to add a collider), and playtest. You can move the player with the <em class="italic">A</em> and <em class="italic">D</em> keys, left and right arrow keys, or a game controller’s left stick. You can adjust values for acceleration, max speed, and the <strong class="bold">Rigidbody2D</strong> properties for mass and <span>linear drag.</span></p>
<p class="callout-heading">PlayerController.cs code</p>
<p class="callout">To view the <a id="_idIndexMarker594" class="pcalibre1 pcalibre calibre6"/>completed code for the <strong class="source-inline1">PlayerController</strong> class, visit the following GitHub <span>repository: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts</span></a><span>.</span></p>
<p class="calibre3">Playtesting means tweaking these movement variables repeatedly until the player control <em class="italic">feels right</em> to you. I’ve currently settled on values of <strong class="source-inline">30</strong> for acceleration and <strong class="source-inline">8</strong> for max speed. As you <a id="_idIndexMarker595" class="pcalibre1 pcalibre calibre6"/>build out the game, you’ll find yourself going back and tweaking these values many, many more times – game feel is crucial to <span>player satisfaction.</span></p>
<h2 id="_idParaDest-108" class="calibre8"><a id="_idTextAnchor110" class="pcalibre1 pcalibre calibre6"/>Physics materials</h2>
<p class="calibre3">While<a id="_idIndexMarker596" class="pcalibre1 pcalibre calibre6"/> playtesting, you may notice that the player <a id="_idIndexMarker597" class="pcalibre1 pcalibre calibre6"/>may slide for a bit when you release the key (or controller stick). This can be corrected by freezing the player in place when the key is released, but I believe a better way is to change the properties of the ground the player is currently standing on. By adjusting the friction of the ground, we can provide different types of ground, including ice, where the player would slide when input <span>is released.</span></p>
<p class="calibre3">We’re going to add a <strong class="bold">physics material</strong> to the ground to provide <em class="italic">higher default friction</em>. That way, we can have areas with less friction later to change up the gameplay, and <span>so on.</span></p>
<p class="calibre3">Follow these steps to create a new physics material and apply it to the ground objects in <span>your level:</span></p>
<ol class="calibre14">
<li class="calibre15">In the <strong class="bold">Project</strong> window, in the <strong class="source-inline">Assets/Settings</strong> folder, create a new folder and name it <span><strong class="source-inline">Physics Materials</strong></span><span>.</span></li>
<li class="calibre15">Right-click within the new folder, select <strong class="bold">Create</strong> | <strong class="bold">2D</strong> | <strong class="bold">Physics Material 2D</strong>, and name it <span><strong class="source-inline">Default Friction</strong></span><span>.</span></li>
<li class="calibre15">Select the newly created physics material and, in the <strong class="bold">Inspector</strong> window, assign a <strong class="bold">Friction</strong> value of <strong class="source-inline">10</strong> (this, like all other gameplay variables, is subject to change <span>with playtesting).</span></li>
<li class="calibre15">Now, assign the physics material to your ground objects by dragging it into the <strong class="bold">Material</strong> field of the <strong class="source-inline">Collider</strong> component, as seen in the <span>following figure:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer087">
<img alt="Figure 5.12 – Assigning a physics material to the ground collider" src="image/B18347_05_12.jpg" class="calibre75"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Assigning a physics material to the ground collider</p>
<p class="calibre3">Continue to playtest and adjust <span>these values.</span></p>
<p class="calibre3">We’ll finish <a id="_idIndexMarker598" class="pcalibre1 pcalibre calibre6"/>up<a id="_idIndexMarker599" class="pcalibre1 pcalibre calibre6"/> the initial player controller next by adding a run animation and having the player always face the direction <span>of movement.</span></p>
<h1 id="_idParaDest-109" class="calibre5"><a id="_idTextAnchor111" class="pcalibre1 pcalibre calibre6"/>Animating the character with Mecanim</h1>
<p class="calibre3">In the <em class="italic">Creating actor animations</em> section, we <a id="_idIndexMarker600" class="pcalibre1 pcalibre calibre6"/>added an <strong class="bold">Animator</strong> component to the <strong class="source-inline">PlayerCharacter1</strong> object when we created the idle animation for the actor. The <strong class="source-inline">Animator</strong> component allows us to assign animation to a GameObject in the <strong class="bold">Scene</strong> view – it’s the interface responsible for controlling <a id="_idIndexMarker601" class="pcalibre1 pcalibre calibre6"/>Unity’s <strong class="bold">Mecanim</strong> animation system (on the actor or any other GameObject you’d like <span>to animate).</span></p>
<p class="calibre3">An <strong class="bold">Animator Controller</strong> asset was also created in the same folder the idle animation was saved to and automatically referenced in the <strong class="bold">Controller</strong> field of the <strong class="source-inline">Animator</strong> component. This controller asset defines what animations to use and when and how to transition and <span>blend them.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span>Animator: </span><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml</span></a><span>.</span></p>
<p class="calibre3">To continue setup in the <strong class="source-inline">Animator</strong> component, we’ll need a second animation to transition to when our player character moves or, let’s <span>say, runs.</span></p>
<p class="calibre3">Follow these steps to create an additional animation for <span>the actor:</span></p>
<ol class="calibre14">
<li class="calibre15">Open the <strong class="bold">Animation</strong> window, then select the <strong class="source-inline">PlayerCharacter1</strong> object in the <span><strong class="bold">Scene</strong></span><span> view.</span></li>
<li class="calibre15">Now, in the <strong class="bold">Animation</strong> window, click the <strong class="bold">Animation Clips</strong> list dropdown (the top left of the window just under the playback controls), then click <strong class="bold">Create New Clip…</strong>, as seen in the <span>following figure:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer088">
<img alt="Figure 5.13 – Create New Clip…" src="image/B18347_05_13.jpg" class="calibre76"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.13 – Create New Clip…</p>
<ol class="calibre14">
<li value="3" class="calibre15">Save the new clip as <strong class="source-inline">Player Run</strong> in the <span><strong class="source-inline">Assets/Animation</strong></span><span> folder.</span></li>
<li class="calibre15">Animate a run cycle. You’ve <span>got this!</span></li>
</ol>
<p class="calibre3">Seriously though, animation is a skill you’ll need to grow into. While I can create animations, I still need lots of practice in this area to get better at it (I’ll likely employ a skilled character animator for the final actor animations in the finished project files for this book, and<a id="_idIndexMarker602" class="pcalibre1 pcalibre calibre6"/> these will be available for you to use and learn from <span>as well).</span></p>
<p class="callout-heading">Additional resources | 2D character animation</p>
<p class="callout">Another option<a id="_idIndexMarker603" class="pcalibre1 pcalibre calibre6"/> for getting a head start on character animations is to work with existing example characters from either the Dragon Crashers or Lost Crypt sample projects that Unity provides on the <span>Asset Store.</span></p>
<p class="callout">Dragon <span>Crashers: </span><a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721" class="pcalibre1 pcalibre calibre6"><span>https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721</span></a><span>.</span></p>
<p class="callout">Lost <span>Crypt: </span><a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673" class="pcalibre1 pcalibre calibre6"><span>https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673</span></a><span>.</span></p>
<p class="calibre3">We can now move on to wiring up the transition for the <em class="italic">idle to </em><span><em class="italic">run</em></span><span> animation.</span></p>
<h2 id="_idParaDest-110" class="calibre8"><a id="_idTextAnchor112" class="pcalibre1 pcalibre calibre6"/>Transitioning animation states</h2>
<p class="calibre3">To open<a id="_idIndexMarker604" class="pcalibre1 pcalibre calibre6"/> the <strong class="bold">Animator</strong> window, you can<a id="_idIndexMarker605" class="pcalibre1 pcalibre calibre6"/> either double-click on the <strong class="bold">Controller</strong> field of the <strong class="source-inline">Animator</strong> component on the <strong class="source-inline">PlayerCharacter1</strong> object or double-click on the <strong class="source-inline">PlayerCharacter1</strong> asset in the <strong class="source-inline">Assets/Animation</strong> folder in the <span><strong class="bold">Project</strong></span><span> window.</span></p>
<p class="calibre3">With the <strong class="bold">Animator</strong> window open (you may want to dock it so that you can still see all the Editor windows clearly), you should see the default states (<strong class="bold">Any State</strong>, <strong class="bold">Entry</strong>, <strong class="bold">Exit</strong>) as well as states for the animation clips currently on the actor (<strong class="bold">Player Idle</strong>, <span><strong class="bold">Player Run</strong></span><span>):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer089">
<img alt="Figure 5.14 – Actor animation transition with Mecanim" src="image/B18347_05_14.jpg" class="calibre77"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Actor animation transition with Mecanim</p>
<p class="calibre3">Note that you can navigate the <strong class="bold">Animator</strong> window using the mouse scroll wheel to zoom in/out and use the <em class="italic">Alt</em> + left-mouse button/<em class="italic">Option</em> + left-mouse button shortcut to pan the view. Click and drag on any State Node to reposition it in an <span>orderly fashion.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">The <strong class="bold">Animator</strong> <span>window: </span><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml</span></a><span>.</span></p>
<p class="calibre3">Follow these steps to create a <strong class="bold">Transition</strong> from the <strong class="bold">Player Idle</strong> to <strong class="bold">Player </strong><span><strong class="bold">Run</strong></span><span> states:</span></p>
<ol class="calibre14">
<li class="calibre15">First, create a Boolean parameter for whether we are running or not by executing the <span>following steps:</span><ol class="calibre42"><li class="upper-roman">First, select the <strong class="bold">Parameters</strong> tab (<em class="italic">A</em> in <span><em class="italic">Figure 5</em></span><em class="italic">.14</em>), then click the plus (<strong class="bold">+</strong>) dropdown and <span>select </span><span><strong class="bold">bool</strong></span><span>.</span></li><li class="upper-roman">A new parameter will be added and highlighted for renaming. Name it <strong class="source-inline">Running</strong> – we want a Boolean parameter to hold the state for if the player is running (<strong class="source-inline">true</strong>) or not <span>running (</span><span><strong class="source-inline">false</strong></span><span>).</span></li></ol></li>
<li class="calibre15">Right-click on the <strong class="bold">Player Idle</strong> node and select <strong class="bold">Make Transition</strong> from the <span>popup menu.</span></li>
<li class="calibre15">With the <strong class="bold">Transition</strong> arrow<a id="_idIndexMarker606" class="pcalibre1 pcalibre calibre6"/> attached <a id="_idIndexMarker607" class="pcalibre1 pcalibre calibre6"/>to the mouse pointer, click on the <strong class="bold">Player </strong><span><strong class="bold">Run</strong></span><span> node.</span></li>
<li class="calibre15">Now, click on the newly created transition line (<em class="italic">B</em> in <span><em class="italic">Figure 5</em></span><em class="italic">.14</em>) to view its properties in the <span><strong class="bold">Inspector</strong></span><span> window.</span></li>
<li class="calibre15">Within the <strong class="bold">Conditions</strong> list, click the plus (<strong class="bold">+</strong>) button to add a new condition – <strong class="bold">Running</strong> should be selected by default since it is our only parameter. Make sure the value is <strong class="source-inline">true</strong>; meaning, transition to the assigned node when the <strong class="bold">Running</strong> bool value <span>becomes </span><span><strong class="source-inline">true</strong></span><span>.</span></li>
<li class="calibre15">Go back to <em class="italic">step 2</em> and repeat the instructions to transition back to <strong class="bold">Player Idle</strong>, but when the <strong class="bold">Running</strong> condition <span>is </span><span><strong class="source-inline">false</strong></span><span>.</span></li>
<li class="calibre15">The last step is to disable <strong class="bold">Has Exit Time</strong> (<em class="italic">D</em> in <span><em class="italic">Figure 5</em></span><em class="italic">.14</em>) for both transitions. We want the state to exit (the animation to stop) as soon as the condition is met and not wait for the animation to <span>play completely.</span></li>
</ol>
<p class="calibre3">Since we haven’t wired up the animation states to the player input yet, you can test manually to make sure the transition is working well by entering <strong class="bold">Play Mode</strong> and, while viewing both the <strong class="bold">Game view</strong> and <strong class="bold">Animator</strong> windows, toggling the <strong class="bold">Running</strong> parameter on/off. The player should change from an <em class="italic">idle</em> to <em class="italic">run</em> animation and back every time<a id="_idIndexMarker608" class="pcalibre1 pcalibre calibre6"/> you toggle the <a id="_idIndexMarker609" class="pcalibre1 pcalibre calibre6"/><span>parameter. Yay!</span></p>
<p class="calibre3">Now, let’s make this transition based on the <span>player’s input.</span></p>
<h2 id="_idParaDest-111" class="calibre8"><a id="_idTextAnchor113" class="pcalibre1 pcalibre calibre6"/>Changing the animation state with code</h2>
<p class="calibre3">The first<a id="_idIndexMarker610" class="pcalibre1 pcalibre calibre6"/> thing we’ll need is a variable<a id="_idIndexMarker611" class="pcalibre1 pcalibre calibre6"/> to hold the reference to the <strong class="source-inline">Animator</strong> component (assignable in the <strong class="bold">Inspector</strong> window). Then, when we receive player input for moving the character left or right, we will set the <strong class="source-inline">Running</strong> parameter to <strong class="source-inline">true</strong>, and when the player stops moving the character, we will set the <strong class="source-inline">Running</strong> parameter to <strong class="source-inline">false</strong>. We’ll make quick work of this and accomplish it with only one line <span>of code!</span></p>
<p class="calibre3">Add the following code to the <span><strong class="source-inline">PlayerController</strong></span><span> script:</span></p>
<pre class="source-code">
[Header("Actor")]
[SerializeField] private Animator _animator;
private void UpdateVelocity()
{
    …
    // Update animator.
    _animator.SetBool("Running", _movementInput.x != 0f);
}</pre> <p class="calibre3">The <strong class="source-inline">_animator</strong> variable declaration is our reference to the <strong class="source-inline">Animator</strong> component in the <strong class="source-inline">Player</strong> object. We marked it as <strong class="source-inline">private</strong> so that no other class can modify it but decorated it with the <strong class="source-inline">[SerializeField]</strong> attribute so that it’s serialized and assignable in the <span><strong class="bold">Inspector</strong></span><span> window.</span></p>
<p class="calibre3">In the <strong class="source-inline">UpdateVelocity()</strong> method, we added a call to <strong class="source-inline">_animator.SetBool()</strong> and passed in the <strong class="source-inline">Running</strong> string to identify the bool parameter we’d like to set. We’ll pass in the evaluation result of the <strong class="source-inline">_movementInput.x != 0f</strong> expression for the <span>bool value.</span></p>
<p class="calibre3">What this means is that if our player is receiving movement input (value is not zero), then we are moving (<strong class="source-inline">Running</strong> equals <strong class="source-inline">true</strong>); otherwise, (that is, <strong class="source-inline">if _movementInput.x == 0f</strong>), we are standing still (<strong class="source-inline">Running</strong> <span>equals </span><span><strong class="source-inline">false</strong></span><span>).</span></p>
<p class="calibre3">Once you’ve added and saved this code, drag the child <strong class="source-inline">PlayerCharacter1</strong> object to the <strong class="source-inline">PlayerController</strong> component’s <strong class="bold">Animator</strong> field using the <strong class="bold">Hierarchy</strong> and <strong class="bold">Inspector</strong> windows in the <span><strong class="bold">Editor</strong></span><span> view.</span></p>
<p class="calibre3">Enter <strong class="bold">Play Mode</strong> and move the player left and right to test that the animation is transitioning from idle to run and back. You’ll likely notice that even though the animation is <a id="_idIndexMarker612" class="pcalibre1 pcalibre calibre6"/>transitioning, the<a id="_idIndexMarker613" class="pcalibre1 pcalibre calibre6"/> actor is facing the wrong direction while moving to <span>the left!</span></p>
<p class="calibre3">We’ll address this next to finish up the <span>player movement.</span></p>
<h2 id="_idParaDest-112" class="calibre8"><a id="_idTextAnchor114" class="pcalibre1 pcalibre calibre6"/>Flipping the player character</h2>
<p class="calibre3">While the <strong class="bold">Animator</strong> handles<a id="_idIndexMarker614" class="pcalibre1 pcalibre calibre6"/> changing animation <a id="_idIndexMarker615" class="pcalibre1 pcalibre calibre6"/>states for us quite nicely, it does not handle flipping the direction the actor is facing based on player input. It’s pretty simple to add logic to our <strong class="source-inline">PlayerController</strong> script to ensure the player is always facing the direction <span>of movement.</span></p>
<p class="calibre3">Open the <strong class="source-inline">PlayerController</strong> script and, at the end of the <strong class="source-inline">OnMove()</strong> method, add a call to a new method named <strong class="source-inline">UpdateDirection</strong>. Create the <strong class="source-inline">UpdateDirection()</strong> method with the <span>following code:</span></p>
<pre class="source-code">
void OnMove(InputValue value)
{
    …
    UpdateDirection();
}
private void UpdateDirection()
{
    if (_movementInput.x != 0f)
    {
        transform.localScale = Vector3.one;
        if (_movementInput.x &lt; 0f)
            transform.localScale = new
                Vector3(-1f, 1f, 1f);
    }
}</pre> <p class="calibre3">The simple trick we’re employing to flip the direction the player character is facing is to set the <strong class="source-inline">localScale X</strong> value to <strong class="source-inline">-1</strong> for the player object’s <strong class="bold">Transform</strong> if the movement input value is less than zero (that is, input indicating moving to <span>the left).</span></p>
<p class="calibre3">The first <strong class="source-inline">if</strong> statement in <strong class="source-inline">UpdateDirection()</strong> checks if we have any input for moving the player. Remember, a value of zero means that the player released the direction key (or game <span>controller stick).</span></p>
<p class="calibre3">If the movement’s input horizontal value is not zero, we first set a default scale for facing right (an <strong class="source-inline">X</strong> value of <strong class="source-inline">1</strong>). If it turns out that the movement input is for facing left (an <strong class="source-inline">X</strong> value of <strong class="source-inline">-1</strong>), then we set <strong class="source-inline">localScale</strong> to <strong class="source-inline">Vector3</strong> with an X-axis value of <strong class="source-inline">-</strong><span><strong class="source-inline">1</strong></span><span>. Easy-peasy.</span></p>
<p class="callout-heading">Bonus activity</p>
<p class="callout">Based on the techniques learned in this chapter for processing player input, moving the player via its <strong class="source-inline1">Rigidbody2D</strong> component and animating the player using the <strong class="bold">Animator</strong> all within the <strong class="source-inline1">PlayerController</strong> script, add the ability for the player character to jump. Might as well jump, go ahead <span>and jump!</span></p>
<p class="callout">I didn’t necessarily leave you hanging here. If you’re looking for a lifeline to solve this problem, you can view instructions for completing this jumping bonus activity by visiting the following GitHub <span>link: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping</span></a></p>
<p class="calibre3">In this section, you <a id="_idIndexMarker616" class="pcalibre1 pcalibre calibre6"/>learned how to create animations<a id="_idIndexMarker617" class="pcalibre1 pcalibre calibre6"/> and apply them to the player, as well as how to transition and change the animation state with code, all while using Mecanim. We finished off by learning how to flip the facing direction of the <span>player character.</span></p>
<h1 id="_idParaDest-113" class="calibre5"><a id="_idTextAnchor115" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter walked us through the complete setup of an animated 2D player character, including importing art and setting up an animatable rig via PSD Importer, setting up IK Solvers, and creating and applying animations to the player <span>using Mecanim.</span></p>
<p class="calibre3">We continued by adding movement ability from player input by using an Input Action Map asset with the new Input System, coding a simple player controller script, processing input, and changing animations based on the current player action, also <span>using Mecanim.</span></p>
<p class="calibre3">In the next chapter, we’ll add a weapon for the player so that they can shoot <span>projectiles efficiently.</span></p>
</div>
</div></body></html>