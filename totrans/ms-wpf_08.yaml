- en: Creating Visually Appealing User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While adding form elements to a View is simple, it takes somewhat more to produce
    an application that looks visually appealing. Luckily, **Windows Presentation
    Foundation** (**WPF**) provides us with many features that can help us to achieve
    this goal, such as gradient brushes, rounded corners, opacity control, layered
    visuals, and animations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll take a look at a number of ways of using these elements
    in order to greatly improve the visual aspect of our applications. We'll investigate
    solutions that are simple to implement, using style properties, and other solutions
    that will take more work, such as animations and custom controls.
  prefs: []
  type: TYPE_NORMAL
- en: Styling applications consistently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest ways to make our applications stand out is to make them look
    unique. This can be achieved by defining custom styles for the controls that we
    use in it. However, if we decide to style our controls, it is essential that we
    style all of the controls that we use, as a half styled application can often
    look worse than an application that merely uses the default styles.
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore absolutely essential that we design our application control
    styles consistently, in order to attain a professional look for our application.
    In this section, we'll discuss a number of tips and tricks to help us to implement
    these application styles.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding default control styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When providing custom styles for our application controls, this typically requires
    us to define a new `ControlTemplate` element for each of them. As these can often
    be very large, it is customary to declare them in a separate resource file and
    merge it with the application resources in the `App.xaml` file, as shown in [Chapter
    5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml), *Using the Right Controls for
    the Job*.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting this task, we need to plan how we want our controls to look
    and then apply this same look to each control. Another mistake would be to customize
    different controls with different styles, as consistency is key to providing a
    professional look. For example, if we want our single-line textboxes to be a certain
    height, then we should also define our other controls to be the same height.
  prefs: []
  type: TYPE_NORMAL
- en: The custom styles that we declare for our controls can be part of our application
    framework. If we define them without naming them via the `x:Key` directive, they
    will be implicitly applied and so, the developers that utilize our application
    framework need not concern themselves with the look of each control, effectively
    freeing them up to concentrate on aggregating them into the various Views.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do before starting to design our custom styles is to define
    a small range of colors that we will use in our application. Using too many colors
    in an application can make it look less professional, so we should choose a few
    shades of a small number of colors to use. There are a number of online tools
    that can help us to pick a color palette to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have chosen our application colors, we should declare them, first,
    as `Color` objects in the `App.xaml` file, and then declare brush elements that
    use them, as most controls use brushes rather than colors. This has two benefits;
    using only these colors will promote consistency and if we ever need to change
    a color, we only need to change it in a single place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is often a good idea to also define multiple named styles for the most common
    types of controls. For example, having a `Label` style for `TextBlock` elements,
    that right aligns them and adds suitable margins, or a `Heading` style that sets
    a larger font size and heavier font weight. Providing the developers with a set
    of predefined styles helps to make the application look consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining multiple named styles, it is common to reuse some of them in
    others. For example, if we have a default style for the `TextBox` control, we
    can base other style variations on it. Let''s see some XAML examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the simplified `TextBoxStyle` style defines the majority of the properties
    for all `TextBox` controls. The `Max2LineTextBoxStyle` style inherits all of the
    property settings from this style and sets a few more that ensure that the vertical
    scrollbar can appear when required and enforce a maximum height for the control.
  prefs: []
  type: TYPE_NORMAL
- en: The `Max3LineTextBoxStyle` style extends the `Max2LineTextBoxStyle` style and
    so, inherits all of its property settings, as well as those of the `TextBoxStyle`
    style. It overrides the `MaxHeight` property that was set in the previous style.
    The `ReadOnlyTextBoxStyle` style also extends the `TextBoxStyle` style and sets
    properties to ensure that the control is read-only. Defining styles in this way
    ensures that controls in each View will remain consistent.
  prefs: []
  type: TYPE_NORMAL
- en: As well as defining default styles for our application controls, it is often
    also a good idea to provide default data template resources for each data Model
    in the application. In a similar way to the controls, predefining these data templates
    can result in improved consistency. We can also define a number of named templates
    to override the default ones with and use in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: If there are a large number of data models in an application, it can be helpful
    to also declare their data templates in a separate resource file and merge it
    with the application resources in the `App.xaml` file, like to the default control
    templates. It is therefore not unusual to see multiple resource files being merged
    in the application resources file.
  prefs: []
  type: TYPE_NORMAL
- en: Using professional icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that can often be underestimated when developing applications is the
    overall impact that a consistent set of decent icons can have. Using mis-matched
    icons that have been sourced from a number of different places can really make
    an otherwise professional looking application look far less professional.
  prefs: []
  type: TYPE_NORMAL
- en: If you or your company cannot afford to or will not for any other reason buy
    a set of custom icons, all is not lost. Visual Studio has long since offered sets
    of professional icons in a number of different formats, that we can utilize in
    our applications free of charge. These are the actual icons that are used in Visual
    Studio, Office and other Microsoft applications, so many users will already be
    familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In older versions of Visual Studio, such as the 2010, or even 2008 versions,
    the provided image libraries were installed with the application and could be
    found at one of the following paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files\Microsoft Visual Studio 9.0\Common7\VS2008ImageLibrary\1033`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that on a 64 bit machine, this path would change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, Microsoft changed how the image libraries could be accessed in newer
    versions of Visual Studio, from the 2012 version onwards. In these later versions,
    the image libraries were no longer included in the installation of Visual Studio.
    Instead, we have to search for `Visual Studio Image Library` and manually download
    them from the **Microsoft** website.
  prefs: []
  type: TYPE_NORMAL
- en: The newer icon sets also contain searchable Adobe Reader files that list the
    contents of the icon sets and provide links to the relevant folders of each of
    the icons. Most of the icons are also included in multiple sizes and so the newer
    libraries are much larger than the previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few examples of the 2010 icons can be seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09b06e31-4096-49b5-b296-c3e365a1b914.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows the same icons, but in the flat style introduced
    in 2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30902505-d996-4831-8fd8-634663029cf5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows how the flat style icons changed in 2017, for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7286858f-fbf1-49ff-b711-1168980e9eca.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that no image library was made available with Visual Studio 2019, so maybe
    this is a sign of things to come. However, the current collections of icons will
    cover most purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Layering visuals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've just looked at simple redefinitions of the standard controls,
    by altering shapes, sizes, borders, and other common properties. However, we can
    do much more than that with WPF. Before continuing with this section, it is important
    to know that the more visuals each control is comprised of, the longer it will
    take to render them and so, this can negatively affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: As such, it's important not to overdo the visual aspect of our controls if our
    application will be run on slow, old computers. Conversely, if we know that our
    end users will have plenty of RAM and/or graphics cards, then we can go the extra
    distance and develop visually stunning controls. Let's take a look at some techniques
    that we can use to improve the look of our controls.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest ways to make our UI elements pop out of the screen is to
    add a shadow to them. Each control has an `Effect` property that is inherited
    from the `UIElement` class. We can set an object of type `DropShadowEffect` to
    this property to add a shadow to our controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we must be conservative with the settings that we use on the `DropShadowEffect`
    element because this effect can be easily overdone. We also do not want to apply
    this effect to every control, as that would spoil the overall effect. It is most
    useful when setting on a panel that contains other controls, or on a border that
    surrounds such a panel. Let''s see a simple example of applying this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the output of this code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b474d8e-e2de-4c43-a0a0-ab80d183dcb7.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we have a standard button with a `DropShadowEffect` element
    that is set as its `Effect` property. As we'll see later in in this chapter, the
    `DropShadowEffect` class has a number of uses, but its primary use is to create
    shadow effects.
  prefs: []
  type: TYPE_NORMAL
- en: When using this element for shadow effects, we generally want to set its `Color`
    property to black and its `Opacity` property to a value that is at least semi-transparent
    for best, or most realistic, results. The `ShadowDepth` property dictates how
    far from the element the shadow should fall. Along with the `BlurRadius` property,
    this property is used to add a sense of height to the element.
  prefs: []
  type: TYPE_NORMAL
- en: The `BlurRadius` property spreads out the shadow area while also making it less
    dense. Like the `ShadowDepth` property, this property has a default value of five.
    The `Direction` property specifies which direction the shadow should fall in,
    with a value of zero degrees making the shadow fall to the right and increasing
    values moving the shadow angle anti-clockwise.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a value of `270` makes the shadow fall directly below the applied
    control and is often most suitable for use in business applications. Using this
    angle results in what appears to be an element that is hovering slightly above,
    or in front of, the screen, with a light source coming from above, which is the
    most natural direction for light to come from.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to this, an angle of `45` degrees for example, would place the shadow
    to the top right of the element and this would have the effect of telling the
    brain that there is a light source to the bottom left. However, this particular
    effect is unnatural looking and can detract from, rather than add to the styling
    of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring multiple borders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another simple technique that we can use to make our controls stand out is
    to declare multiple `Border` elements for each control. By declaring one or more
    borders within an outer border, we can give our controls that professional look.
    We''ll see how we can animate these borders differently when the user''s mouse
    cursor is over the button later, but for now, let''s see how we can create this
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have declared a simple `ControlTemplate` element for our
    `Button` control to demonstrate the double border technique. Note that we would
    typically declare this template in the `Application.Resources` section of the
    `App.xaml` file, so that it could be reused, but we have declared it locally to
    save space here.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we need to adjust the corner radius of the inner border to accurately
    fit within the outer border. If we had used the same size for both, they would
    not have correctly fit together. Also, we have set the `SnapsToDevicePixels` property
    to `true` on the two borders to ensure that they are not blurred by anti-aliasing
    artefacts.
  prefs: []
  type: TYPE_NORMAL
- en: One further point to note is that we have used `#7FFFFFFF` as the value for
    the background of the outer border and the border brush of the inner border. The
    alpha channel in this value is set to `7F`, which equates to an opacity value
    of `0.5`. This means that these elements will be partly transparent and so the
    colors from the background will partly show through the border edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added our button into a `Grid` panel and set a `LinearGradientBrush` object
    as its background to demonstrate this semi-transparent effect. When rendered,
    our background gradient and button will look like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b436441f-bb8c-4a96-8ccb-ef4f5c39f9b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Reusing composite visuals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next technique involves defining a particular motif that will be rendered
    in the background of our controls. This could be all or part of a company logo,
    a particular shape, or even just a simple, well-placed curve. This will form the
    bottom most level of our control visuals and can have additional levels of visuals
    on top. Let''s take a look at one way in which we could implement such a design,
    starting with defining some resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a few elements to this design, so let's take a look at each one individually.
    We started by declaring a `RadialGradientBrush` element with the key `LayeredButtonBackgroundBrush`
    and a `LinearGradientBrush` with a key of `LayeredButtonCurveBrush`.
  prefs: []
  type: TYPE_NORMAL
- en: The `RadiusX` and `RadiusY` properties of the `RadialGradientBrush` element
    specify the `X` and `Y` radii of the outermost ellipse that encompasses the radial
    gradient, while the `Center` and `GradientOrigin` properties dictate the center
    and focal point of the radial gradient and enable us to position it precisely
    within our rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: The `LinearGradientBrush` element has a `StartPoint` value of `0,0` and an `EndPoint`
    value of `1,1`, which results in a diagonal gradient. With this particular design,
    the idea is to have a sharp contrast between the two gradients at the center and
    to somewhat blend them together at the edges.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a `Grid` panel with the key `LayeredButtonBackgroundElements`,
    which contains a `Rectangle` and a `Path` element. The rectangle is stretched
    to fill the panel by default and is painted with the `LayeredButtonBackgroundBrush`
    resource. The `Path` element is painted with the `LayeredButtonCurveBrush` resource.
  prefs: []
  type: TYPE_NORMAL
- en: The `Data` property of the `Path` object is where we define the shape of the
    path. There are a number of ways that we can specify the path data; however, in
    this example, we use a `CombinedGeometry` element with a `GeometryCombineMode`
    value of `Intersect`, which outputs a single shape that represents the intersection
    of the two specified geometry shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `CombinedGeometry` element, we have the `Geometry1` and `Geometry2`
    properties, where we combine the two geometry shapes according to the `Intersect`
    mode specified by the `GeometryCombineMode` property.
  prefs: []
  type: TYPE_NORMAL
- en: Our first shape defines the curve in our design and comes from an `EllipseGeometry`
    element, using the `Center` property to position the ellipse and the `RadiusX`
    and `RadiusY` properties to shape it. The second shape is a rectangle that comes
    from a `RectangleGeometry` element and is defined by its `Rect` property.
  prefs: []
  type: TYPE_NORMAL
- en: The intersection of these two shapes is the result of this path and approximately
    covers the bottom section of our overall shape, up to the curve. The partly obscured
    rectangle element behind this completes the remainder of the overall shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Visual` property of the `VisualBrush` element with the `LayeredButtonBackground` key
    is set to the `LayeredButtonBackgroundElements` panel, so any UI element that
    is painted with this brush will now have this design imprinted on it. Once we
    have added these resources to the `Application.Resources` section in the `App.xaml` file,
    we can use them through the `VisualBrush` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the gradients in the button background, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2245a20-d18a-4ec1-a932-ade30cc797cd.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we manually specify the reference to the visual brush to paint
    the `Button` object's background. However, setting the background in this way
    would require the developers that use our application framework to do this each
    time they add a button. A better solution would be to redesign the default button
    template so that the visual brush is automatically applied to each button. We'll
    see an example of this later in this chapter when we pull together a number of
    these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another technique involves adding a semi-opaque layer with a gradient that
    fades to transparency over the top of our controls to give the appearance of the
    reflection of a light source. This can easily be achieved using a simple `Border`
    element and a `LinearGradientBrush` instance. Let''s look at how we can accomplish
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this example will produce a button that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/489c3568-28ae-42ee-9b59-30c186132bcc.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's examine this example. We start by declaring the `Button` element with
    a few style properties. Rather than defining a separate style or control template
    in a resources section, as we would in a real-world application, we again declare
    the template inline to save space here.
  prefs: []
  type: TYPE_NORMAL
- en: In the control template, we first declare a `Border` element with a jade green
    background and a `CornerRadius` value of `5`. We again set the `SnapsToDevicePixels`
    property to `true` to ensure that the edges remain sharp.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the border, we define two elements within a `Grid` panel. The first is
    the `Rectangle` element that produces the reflection effect and the second is
    the required `ContentPresenter` object. The rectangle uses a value of `4` in the
    `RadiusX` and `RadiusY` properties and sets the `Margin` property appropriately
    to ensure that there is a tiny gap around the edge of the reflection.
  prefs: []
  type: TYPE_NORMAL
- en: It also sets its `SnapsToDevicePixels` property to true to ensure that this
    tiny gap is not blurred. Note that the value for the bottom margin is `7`, because
    we do not want the reflection effect to cover the bottom half of the button. The
    `Fill` property is where the reflection effect is actually created.
  prefs: []
  type: TYPE_NORMAL
- en: In the rectangle's `Fill` property, we define a vertical `LinearGradientBrush`
    element by setting both of the `X` values of the `StartPoint` and `EndPoint` properties
    and the `StartPoint.Y` property to `0` and the `Endpoint.Y` property to `1`; plotting
    these points on a graph will produce a vertical line, and so this produces a vertical
    gradient.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GradientStops` collection of the `LinearGradientBrush` object, we have
    defined two `GradientStop` elements. The first has an offset of zero and is set
    to a white color with a hexadecimal alpha channel value of `BF`, which approximates
    an opacity value of `0.7`. The second has an offset of `0.8` and is set to a white
    color that has a hexadecimal alpha channel value of `00`, which results in a completely
    transparent color and could be replaced with the `Transparent` color.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting gradient, therefore, starts slightly transparent at the top and
    is fully transparent at the bottom, which, with the bottom margin and offset values,
    is actually around the middle of the button. As with our other examples, the `ContentPresenter`
    object is declared afterwards so that it is rendered on top of the reflection
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating glowing effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another effect that we can create for our controls is that of a glowing appearance,
    as if a light were shining outward from inside the control. We''ll need another
    `LinearGradientBrush` instance and UI element to paint it on. A `Rectangle` element
    suits this role well, as it''s very lightweight. We should define these resources
    in the application resources in the `App.xaml` file to enable every View to use
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We start off by declaring a `TransformGroup` element that enables us to group
    one or more transform objects together. Inside it, we define a `ScaleTransform`
    element that scales applied elements vertically by the default factor of `1` and
    horizontally by a factor of `1.8`. We specify the center of this transformation
    using its `CenterX` and `CenterY` properties. Next, we declare a `TranslateTransform`
    element that moves applied elements downwards by a small amount.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we define a `RadialGradientBrush` object that will represent the
    glow in our design. We use the `RadiusX` and `RadiusY` properties to shape the
    brush element and specify the `Center` and `GradientOrigin` properties to dictate
    the center and focal point of the radial gradient.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the `TransformGroup` element to the `RelativeTransform` property
    of the brush to apply the transforms to it. Note that the three `GradientStop`
    elements all use the same `R`, `G` and `B` values, and just differ in the alpha
    channel, or opacity values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the `GlowingButtonStyle` style for type `Button`, setting the
    `SnapsToDevicePixels` property to `true`, to keep its lines crisp and sharp. In
    the `Template` property, we define a `ControlTemplate` element with a white `Border`
    element that has slightly rounded corners.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the border, we declare a `Grid` panel containing a `Rectangle` and a
    `ContentPresenter` element. Again, the `RadiusX` and `RadiusY` properties of the
    rectangle are set to a smaller value than that of the `CornerRadius` property
    of the parent border control to ensure that it fits evenly within it. Our `RadialGradientBrush`
    resource is assigned as the rectangle's `Fill` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `ContentPresenter` object is centered to ensure that the content of the
    button will be rendered in its center. Returning to the `Border` element, we see
    a `DropShadowEffect` is declared within its `Effect` property. However, this element
    is not here to create a shadow effect; this class is multi-functional and can
    also render glowing effects as well as shadow effects.
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to set its `Color` property to a color other than black and its
    `BlurRadius` property to a larger value than we would typically use when creating
    a shadow effect. In this particular case, we set the `Direction` property to `270`
    and the `ShadowDepth` property to `4` in order to position the glow effect toward
    the bottom of the border, where the light is supposed to be coming from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this effect does not translate to grayscale and paper well,
    so the glowing effect is somewhat lost when not viewed in color and on screen.
    For readers of the e-book version of this book, here is what the glowing effect
    from our example looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad149cc5-d086-44df-8589-8152a3b2abfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While these various effects can improve the look of our controls on their own,
    the biggest improvement can be found when amalgamating a number of them into a
    single design. In this next example, we''ll do just that. We first need to add
    a few more resources to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There isn''t anything too complicated here. We simply have a number of colors
    defined with varying levels of transparency and a slightly transparent version
    of our visual brush that references our layered background elements. Let''s move
    on to the encompassing style now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the example XAML, we can see that the `SnapsToDevicePixels` property
    is set to `true`, to avoid anti-aliasing artifacts blurring the edges of the button,
    and the `Cursor` property is set to display the pointing finger cursor when the
    user's mouse is over the button.
  prefs: []
  type: TYPE_NORMAL
- en: Within the control template, we see the two nested `Border` elements. Note that
    the outer border uses the `TransparentBlack` and `TransparentWhite` brush resources
    so that it is semi-transparent. Also, note that the white inner border actually
    comes from the background of the outer border rather than the inner border, which
    sets the `Margin` property to `1` to give the impression of an inner border.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the inner border element is only responsible for displaying
    the layered button elements from the visual brush and has no displayed border
    of its own. Again, we have adjusted its `CornerRadius` property so that it fits
    neatly within the outer border. We can zoom in on the magnification level in the
    WPF designer to help us to decide what values we should use here.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the inner border, we declare a `Grid` panel, so that we can add both
    the required `ContentPresenter` and the `Rectangle` element that is painted with
    the `GreenGlow` brush from the resources. Again, we set its `IsHitTestVisible`
    property to `false`, so that users cannot interact with it and set the `RadiusX`
    and `RadiusY` properties to match the `CornerRadius` value of the inner border.
  prefs: []
  type: TYPE_NORMAL
- en: We use `TemplateBinding` elements to map properties of the `ContentPresenter`
    object to suitable properties from the templated object so that setting properties
    on our button can affect its positioning and content. Next, we set the previously
    displayed `DropShadowEffect` element to the `Effect` property of the outer border
    and that sums up the contained UI elements in the template.
  prefs: []
  type: TYPE_NORMAL
- en: To make the template more useful, we have set some `Trigger` objects in the
    `ControlTemplate.Triggers` collection, that will add mouse over effects for our
    button. The first trigger targets the `IsMouseOver` property and sets the background
    of the inner border to the slightly more transparent version of the layered button
    elements visual brush when true.
  prefs: []
  type: TYPE_NORMAL
- en: The second trigger targets the `IsPressed` property and re-applies the original
    visual brush when the property is true. Note that these two triggers must be defined
    in this order, so that the one that targets the `IsPressed` property will override
    the other when both conditions are true. It is of course, a matter of taste, whether
    the button lights up or goes out when clicked, or perhaps even changes color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we omitted the `x:Key` directive on this style so that it will be
    implicitly applied to all `Button` elements that do not have a different style explicitly
    applied to them. We are, therefore, able to declare our `Button` elements without
    specifying the style, like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a290a5d8-c832-4018-8e76-f4f183565601.png)'
  prefs: []
  type: TYPE_IMG
- en: We could take this glowing idea further too, by defining a number of different
    color resources and using data triggers inside a data template to change the color
    of the glow to indicate different states of a data object. This enables us to
    provide further visual information to the users, in addition to the usual textual
    feedback methods.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a blue glow on a data Model object could specify an unchanged object,
    while green could signify an object with valid changes and red could highlight
    an object in error. We'll see how we can implement this idea in the next chapter,
    but for now, let's continue looking at different ways to make our applications
    stand out from the crowd.
  prefs: []
  type: TYPE_NORMAL
- en: Moving away from the ordinary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vast majority of business applications in general, look fairly ordinary,
    with various form pages containing banks of standard rectangular form fields.
    Visually appealing applications on the other hand, stand out from the crowd. Therefore,
    in order to create visually appealing applications, we need to move away from
    the ordinary.
  prefs: []
  type: TYPE_NORMAL
- en: Whether this means simply adding control templates with rounded corners for
    our controls or something more is up to you. There are many different ways that
    we can enhance the look of our controls and we'll take a look at a number of these
    ideas in this section. Let's start with a refection effect that is best suited
    for use with logos or startup and background images.
  prefs: []
  type: TYPE_NORMAL
- en: Casting reflections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All `FrameworkElement`-derived classes have a `RenderTransform` property that
    we can utilize to transform their rendered output in a variety of ways. A `ScaleTransform`
    element enables us to scale each object in both horizontal and vertical directions.
    One useful facet about the `ScaleTransform` object is that we can also scale negatively,
    and therefore reverse the visual output.
  prefs: []
  type: TYPE_NORMAL
- en: 'One visually pleasing effect that we can create with this particular facet
    is a mirror image, or reflection, of the object. In order to enhance this effect,
    we can use an opacity mask to fade out the reflection as it recedes from the object.
    This can give the visual impression of an object being reflected on a shiny surface,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66ac37ab-3ec6-4727-a887-664fbc9d9344.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how we can achieve this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a `StackPanel` object to position a `TextBlock` element
    above a `Rectangle` element. The text will be the object to reflect and the reflection
    will be generated in the rectangle. The panel's width is constrained to ensure
    that the reflection fits the text element exactly. We start by naming the `TextBlock`
    element and setting some typeface properties, along with the text to output.
  prefs: []
  type: TYPE_NORMAL
- en: We've set a `LinearGradientBrush` object as the color for the text to make it
    more interesting, although this plays no part in creating the reflection effect.
    Next, note that the `Rectangle` element is sized and positioned exactly to fit
    the size of the text from the `TextBlock` element. We can of course use this technique
    to reflect anything and are not restricted to just reflecting text elements.
  prefs: []
  type: TYPE_NORMAL
- en: The background of the rectangle is painted with a `VisualBrush` object, where
    the `Visual` property is data bound to the visual output of the `TextBlock` element,
    using the `ElementName` property. Note the `RelativeTransform` property of the
    `VisualBrush` object, enables us to transform the visual in some way and is set
    to an instance of the `ScaleTransform` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most important constituents for creating this effect, as
    this element is what inverts the related visual in the vertical plane. Setting
    the `ScaleY` property to `-1` will invert the visual vertically for us, while
    setting the `ScaleX` property to `-1` would invert the visual horizontally. Note
    that we omit the `ScaleX` property here because we want it set at its default
    value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `OpacityMask` property, which lets us set a gradient brush
    to be mapped to the opacity of the rectangle. When the alpha channel of the brush
    is `1`, the rectangle will be opaque, when it is `0`, the rectangle will be transparent
    and when it is in between, the rectangle will be semi-transparent. This is the
    other essential part of this effect and creates the fade of the reflected image.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have a vertical gradient that is almost solid black at the
    top and gets increasingly transparent until it reaches four fifths of the way
    down, where it becomes fully transparent. When set as the rectangle's `OpacityMask`,
    only the alpha channel values are used and this results in it being totally visible
    at the top and then fading to invisibility four fifths of the way down, as shown
    in the preceding image.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring borderless windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using WPF, it is possible to create windows without borders, a title bar, and
    the standard minimize, restore and close buttons. It is also possible to create
    irregular shaped windows and windows with transparent areas that display whatever
    lies beneath. Although it would be somewhat unconventional to make our main application
    window borderless, we can still take advantage of this ability.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could create a borderless window for custom message boxes, or
    perhaps for extended tooltips, or any other popup control that provides information
    to the end user. Creating borderless windows can be achieved in a few simple steps.
    Let's start with the basics and assume that we're adding this to our existing
    application framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we've already got our `MainWindow` class and need to add an additional
    window. As we saw in [Chapter 6](c60a6db9-4352-4eb3-ac1d-406fd337b1b4.xhtml),
    *Adapting the Built-In Controls*, we can do this by adding a new `UserControl`
    to our project and replacing the word `UserControl` with the word `Window`, *in
    both the XAML file and its associated code behind file*. Failure to change both
    will result in a design time error that complains about mismatched classes.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can right click on the start up project and select Add and
    then Window…, and then cut and paste it wherever you want it to reside. Unfortunately,
    Visual Studio provides no other way to add a `Window` control into our other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our `Window` object, all we need to do is to set its `WindowStyle`
    property to `None` and its `AllowsTransparency` property to `true`. This will
    result in the white background of our window appearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, while this removes the default window chrome that we are all used
    to and provides us with a borderless window, it also removes the standard buttons,
    so we are unable to close, resize, or even move the window directly. Luckily,
    making our window moveable is a very simple matter. We just need to add the following
    line of code into our window''s constructor after the `InitializeComponent` method
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `DragMove` method is declared within the `Window` class and enables us
    to click and drag the window from anywhere within its bounds. We could easily
    recreate the normal window functionality of only being able to move the window
    from the title bar by adding our own title bar and attaching this anonymous event
    handler to that object's `MouseLeftButtonDown` event instead.
  prefs: []
  type: TYPE_NORMAL
- en: If we want our borderless window to be resizable, there is a `ResizeMode` property
    in the `Window` class that provides us with a few options. One value that we can
    use with our borderless window is the `CanResizeWithGrip` value. This option adds
    a so-called resize grip, specified by a triangular pattern of dots in the bottom
    right corner of the window, that users can resize the window with.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set the `ResizeMode` property to this value and set the background to
    a color that will contrast with this resize grip, we will end with this visual
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e42ec98-e6ba-4dc9-98a5-522bf0c8ca00.png)'
  prefs: []
  type: TYPE_IMG
- en: However, we still have no way to close the window. For this, we could add our
    own button, or perhaps enable the window to be closed by pressing the escape *Esc*key or
    some other key on the keyboard. Either way, whatever the trigger, closing the
    window is a simple matter of calling the window's `Close` method.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than implementing a replacement window chrome, which could be easily
    achieved with a few borders, let's focus on developing a borderless window with
    an irregular shape, that we could use to popup helpful information for the users.
    Ordinarily, we would need to set the window's background to transparent to hide
    it, but we will be replacing its control template, so we don't need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we don't need a resize grip either, so let's set the `ResizeMode`
    property to `NoResize`. We also have no need to move this callout window by mouse,
    so we don't need to add the anonymous event handler that calls the `DragMove`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: As this window will only offer information to the user, we should also set a
    few other window properties. One important property to set is the `ShowInTaskbar`
    property, which specifies whether the application icon should appear in the Windows
    Taskbar or not. As this window will be an integral part of our main application,
    we set this property to `false`, so that its icon will be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful property for this situation is the `WindowStartupLocation` property,
    which enables the window to be positioned using the `Window.Top` and `Window.Left`
    properties. In this way, the callout window can be programmatically positioned
    on screen anywhere that it is needed. Before continuing any further, let''s see
    the code for this window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While this example is not overly long, there is a lot to discuss here. In order
    to clarify the situation somewhat, let''s also see the code behind before we examine
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code-behind file is simpler than the XAML file, so let's quickly walk through
    it first. We added a static constructor in order to call the `OverrideMetadata`
    method on a few pre-existing Dependency Properties. This enables us to override
    the default settings of these properties, and we do this in a static constructor
    because we want to run this code just once per class and because it is called
    before any other constructor or method in the class.
  prefs: []
  type: TYPE_NORMAL
- en: In this constructor, we override the metadata for the `BorderBrush` property,
    in order to set a default border color for our callout window. We do the same
    for both the `HorizontalContentAlignment` and `VerticalContentAlignment` properties
    to ensure that the window content will be centered by default. By doing this,
    we are re-using these existing properties.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can also totally replace the pre-existing properties. As an example,
    we've replaced the `Background` property to paint our callout background. In this
    case, we declare our own `Background` property, specified by the `new` keyword,
    and set its own default brush color. We then use that to paint the background
    of our callout shape, although we could just as easily add another setter into
    our style to reuse the original `Background` property.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the XAML code now, we can see the `WindowStartupLocation` property
    set in the `Window` declaration, followed by a style in the window's `Resources`
    section. In this style, we set the aforementioned properties and define the window's
    control template. Inside the `ControlTemplate` object, we define a `Grid` panel.
    We'll return to this later, but for now, note that there is a nine pixel margin
    set on the bottom of the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Next, note that the panel has two star-sized `ColumnDefinition` elements declared,
    one with a width of `*` and another with a width of `5*`. If we add these together,
    we end with a total width of six equal divisions. This means that the first column
    will be one sixth of the total width of the window and the second column will
    take up the remaining five sixths. We will soon see why this is set as it is.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Grid` panel, we first declare the `Path` element that is used to
    define the shape of our callout. We set the `Grid.ColumnSpan` property on it to
    `2`, to ensure that it takes all of the space of the parent window. Next, we set
    our new `Background` property to the `Fill` property, so that users of our window
    can set `Background` property and have that brush paint just the background of
    our path.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the `Stroke` property of the `Path` element to the overridden `BorderBrush`
    property and although we didn't, we could have exposed the `StrokeThickness` property
    by declaring another Dependency Property. Note that we use `TemplateBinding` elements
    to access the properties of the window, as they are the most efficient in this
    particular case.
  prefs: []
  type: TYPE_NORMAL
- en: Take special note of the `Path.Stretch` property, which we have set to `Fill`
    and defines how the shape should fill the space that it is provided with. Using
    this `Fill` value specifies that the content should fill all of the available
    space, rather than preserve its originally defined aspect ratio. However, if we
    want to preserve the aspect ratio, then we can change this property to the `Uniform`
    value instead.
  prefs: []
  type: TYPE_NORMAL
- en: The most important part of the path is found in the `Path.Data` section. This
    defines the shape of the rendered path and like our layered background example,
    we utilize a `CombinedGeometry` element here to combine two separate geometries.
    Unlike the previous example, here we use a `GeometryCombineMode` value of `Union`,
    which renders the output of both geometry shapes together.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CombinedGeometry.Geometry1` element, we declare a `PathGeometry` object
    with a `PathFigure` element that has a starting point and two `LineSegment` elements.
    Together with the starting point, these two elements form the triangular section
    of our callout, that points to the area on the screen that our window's information
    relates to. Note that this triangle is fifty pixels wide in the path.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CombinedGeometry.Geometry2` element, we declare a `RectangleGeometry`
    object, with its size specified by the `Rect` property and the size of its rounded
    corners being specified by the `RadiusX` and `RadiusY` properties. The rectangle
    is positioned fifty pixels away from the left edge and its width is two hundred
    and fifty pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: The overall area taken up by the rectangle and the triangle is therefore three
    hundred pixels. One sixth of three hundred is fifty and this is how wide the triangle
    in our shape is. This explains why our first `Grid` column is set to take one
    sixth of the total space.
  prefs: []
  type: TYPE_NORMAL
- en: After the `Path` object, we declare the `ContentPresenter` element that is required
    to output the actual content of the window and set it to be in the second column
    of the panel. In short, this column is used to position the `ContentPresenter`
    element directly over the rectangular section of our shape, avoiding the triangular
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ContentPresenter` element, we data bind several positional properties
    to the relevant properties of the window using `TemplateBinding` elements. We
    also data bind its `Content` property to the `Content` property of the window
    using another `TemplateBinding` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have declared our UI controls directly within the `Window`
    control. However, had we done that, then we would not be able to data bind to
    its `Content` property in this way, as setting it externally would replace all
    of our declared XAML controls, including the `ContentPresenter` object. By providing
    a new template, we are totally overriding the default behavior of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we have declared a style in the `Resources` section of the `ContentPresenter`
    element. This style has been declared without the `x:Key` directive. This is so
    that it will be implicitly applied to all `TextBlock` objects within scope, specifically
    to affect the `TextBlock` objects that the `ContentPresenter` element will automatically
    generate for `string` values, while not affecting others.
  prefs: []
  type: TYPE_NORMAL
- en: The style sets the `TextBlock.TextWrapping` property to the `Wrap` member of
    the `TextWrapping` enumeration, which has the effect of wrapping long text lines
    onto the following lines. The default setting is `NoWrap`, which would result
    in long strings not being fully displayed in our window.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we come to the end of the XAML example and find a `DropShadowEffect`
    object set as the `Effect` property of the `Grid` panel. As with all shadow effects,
    we set the `Color` property to black and the `Opacity` property to a value less
    or equal to `0.5`. The `Direction` property is set to `270`, which produces a
    shadow that lies directly underneath our callout shape.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we set the `ShadowDepth` property to a value of `7`. *Now, do you
    remember the bottom margin that was set on the grid?* That was set to a value
    just above this value and was to ensure that enough space was left in the window
    to display our shadow underneath our callout shape. Without this, the shadow would
    sit outside the bounding box of the window and not be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had set a different value for the `Direction` property, then we would
    need to adjust the `Grid` panel''s margin to ensure that it left enough space
    around the window to display the shadow in its new location. Let''s now take a
    look at how we could use our new window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code from a suitable location would result in the following rendered
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2690552-94de-4c3d-a524-ca01581833ae.png)'
  prefs: []
  type: TYPE_IMG
- en: In our window-showing code, we set a `string` to the `Content` property of the
    window. However, this property is of type `object`, so we can add any object as
    its value. In the same way that we set our View Model instances to the `Content`
    property of a `ContentControl` earlier in this book, we can also do that with
    our window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a suitable `DataTemplate` that defines some UI for a particular custom
    object type, we could set an instance of that object to our window''s `Content`
    property and have the controls from that template rendered within our callout
    window, so we are not restricted to only using type `string` for content here.
    Let''s use a previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With a few slight adjustments to our `calloutWindow` dimension properties,
    we would see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11b6417d-e6c4-4127-b2d5-b2a60fb2fd38.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are a number of pre-existing graph controls and third party data
    visualization controls available in WPF, we can create our own relatively easily.
    Expressing data in textual terms alone, while generally acceptable, is not optimal.
    Breaking the norm in an application always makes that application stand out from
    the rest that strictly adheres to the standard.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, imagine a simple situation, where we have a dashboard that visualizes
    the number of work tasks that have come in and the number that have been completed.
    We could just output the numbers in a big, bold font, but that would be the normal
    kind of output. *What about if we visualized each number as a shape, with its
    size being specified by the number?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reuse our layering techniques from earlier and design some visually
    appealing spheres, that grow in size depending upon a particular value. To do
    this, we can create another custom control, with a `Value` Dependency Property
    to data bind to. Let''s first look at the code of the `Sphere` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As this class will declare its own `Color` property, we start by adding a `MediaColor` using
    alias directive, which we'll just use as a shortcut to accessing the methods of
    the `System.Windows.Media.Color` class, when declaring the brushes that will be
    used in the `Sphere` class.
  prefs: []
  type: TYPE_NORMAL
- en: From the class declaration, we can see that there are two named parts specified
    in `TemplatePartAttribute` attributes. These specify that the two mentioned `Ellipse`
    elements are required in our control's template in the `Generic.xaml` file. Inside
    the class, we define a number of `RadialGradientBrush` resources to paint our
    spheres with.
  prefs: []
  type: TYPE_NORMAL
- en: In the static constructor, we call the `OverrideMetadata` method to let the
    Framework know where our control's default style is. We then see the declaration
    of the `Value` and `Color` Dependency Properties, with the `Color` property's
    related `PropertyChangedCallback` hander method.
  prefs: []
  type: TYPE_NORMAL
- en: In this `OnColorChanged` method, we cast the `dependencyObject` input parameter
    to an instance of our `Sphere` class and call its `SetEllipseColors` method. In
    that method, we use the `FrameworkElement.GetTemplateChild` method to access the
    two main `Ellipse` objects from our `ControlTemplate` element.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we must always check these objects for `null`, as our `ControlTemplate`
    could have been replaced with one that does not contain these ellipse elements.
    If they are not `null`, we set their `Fill` properties to one of our brush resources
    using the ternary operator and depending upon the value of our `Color` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'One alternative for creating this functionality would be to declare a Dependency
    Property of type `Brush` to data bind to each ellipse''s `Fill` property and to
    set the relevant brush resources to these properties, instead of accessing the
    XAML elements directly. Before viewing the control''s default style, let''s see
    the `SphereColor` enumeration that is used by the `Color` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is a simple affair and could be easily extended. Note
    that this enumeration has been declared within the `CustomControls` namespace
    and project, so that the project is self-contained and can be reused in other
    applications without any external dependencies. Let''s take a look at our control''s
    default style from `Generic.xaml` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When looking at our control's default template, we can see some of resources
    defined in the `ControlTemplate.Resources` section. We first declare a `DropShadowEffect`
    element, similar to our previous uses of this class. Next, we define a vertical
    `LinearGradientBrush` element, to use as a light reflection layer, in a similar
    way to our earlier example.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we saw that the default value of the `GradientStop.Offset` property
    is zero and so, we can omit the setting of this property if that is the value
    that we need to use. In this brush resource, we see that the last `GradientStop`
    element has no `Color` value specified. This is because its default value of this
    property is `Transparent` and that is the value that we need to use here.
  prefs: []
  type: TYPE_NORMAL
- en: In the actual markup for our control, we declare three `Ellipse` objects within
    a `Grid` panel. Two of these elements are named and referenced in the control's
    code, while the third ellipse uses the brush from resources to create the "shine"
    on top of the other ellipses. The panel's size properties are data bound to the
    `Value` Dependency Property, using a `TemplatedParent` source.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have used the star-sizing capabilities of the `Grid` panel to both
    position and size our ellipse elements, with the exception of the two pixels in
    the top margin specified on the reflection ellipse. In this way, our control can
    be any size and the positioning of the various layers will remain visually correct.
    Note that we could not achieve this by hard coding exact margin values for each
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we could use this in a simple View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how our example looks when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e45b0d9-ac6f-4e99-a95f-dd64c527c422.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, WPF is very powerful and enables us to create completely original
    looking controls. However, we can also use it to recreate more commonly seen controls.
    As an example, let''s see how we can create an alternative control to gauge how
    close we may be to our particular target value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5665f562-3a70-484b-b46f-7006d54a7373.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This example features a semi-circular arc, which is something that does not
    exist in a form that is usable from XAML, so we''ll first create an `Arc` control
    to use internally within our `Gauge` control. Let''s see how we can achieve this
    by adding a new custom control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we extend the `Shape` class when creating our `Arc` class. We do this
    because it provides us with a wide variety of stroke and fill properties and also
    the apparatus to render our custom shape from a `Geometry` object. Additionally,
    users of our `Arc` control will also be able to take advantage of the `Shape`
    class' transformation abilities through its `Stretch` and `GeometryTransform`
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: To draw our arc, we will use the `ArcTo` method of the `StreamGeometryContext`
    class and with it, we need to specify exact `Point` values for its start and end.
    However, in order to reflect the correct value in the size of our arc, it is easier
    to define it using angle values for its start and end.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we add `StartAngle` and `EndAngle` Dependency Properties to our `Arc`
    class. Note that these two properties are declared with the `FrameworkPropertyMetadataOptions.AffectsRender`
    member. This notifies the Framework that changes to these properties need to cause
    a new rendering pass, so new values will be accurately represented in the control.
  prefs: []
  type: TYPE_NORMAL
- en: After these property declarations, we see the overridden `DefiningGeometry`
    property, that enables us to return a `Geometry` object that defines the shape
    to be rendered. We simply return the result from the `GetArcGeometry` method from
    this property.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GetArcGeometry` method, we obtain the required start and end `Point`
    elements from the `ConvertToPoint` method, passing in the `StartAngle` and `EndAngle`
    property values. Note that we use the `Min` and `Max` methods of the `Math` class
    here to ensure that the start point is calculated from the smaller angle and the
    end point is calculated from the larger angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our arc shape''s fill will actually come from the geometric arc''s stroke,
    so we will not be able to add a stroke to it. In WPF, the stroke of a shape with
    a thickness of one pixel will extend no further than the shape''s bounding box.
    However, at the furthest point, strokes with larger thickness values are rendered
    so that their center remains on the line of the bounding box also therefore, half
    of it will extend outside the bounds of the element and half will be rendered
    within the bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/085f2c30-a9b1-4bc5-9816-685a724888ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we calculate the size of the arc by dividing the `RenderSize` value
    minus the `StrokeThickness` value by two. This will reduce the size of the arc
    so that it remains totally within the bounds of our control. We make use of the
    `Math.Max` method to ensure that the values that we pass to the `Size` class are
    never less than zero and avoid exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `ArcTo` method, we need to specify a value that determines whether
    we want to connect our start and end points with a short arc or a long one. Our
    `isLargeArc` variable therefore determines whether the two specified angles would
    produce an arc of more than one hundred and eighty degrees or not.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `StreamGeometry` object and retrieve a `StreamGeometryContext`
    object from its `Open` method, with which to define our geometric shape. Note
    that we could equally use a `PathGeometry` object here, but as we do not need
    its data binding, animation, or other abilities, we use the more efficient `StreamGeometry`
    object instead.
  prefs: []
  type: TYPE_NORMAL
- en: We enter the arc's start point in the `BeginFigure` method and the remaining
    parameters in the `ArcTo` method. Note that we call these methods on our `StreamGeometryContext`
    object from within a `using` statement to ensure that it is closed and disposed
    of properly, once we are finished with it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we apply a `TranslateTransform` element to the `Transform` property of
    the `StreamGeometry` object in order to shift the arc so that it is fully contained
    within our control. Without this step, our arc would stick out of the bounding
    box of our control to the upper left, by the amount of half of the `StrokeThickness`
    property value.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have finished manipulating our `StreamGeometry` object, we call its
    `Freeze` method, which makes it unmodifiable and rewards us with additional performance
    benefits. We'll find out more about this in [Chapter 11](ef8426a1-cec3-4ae0-801a-798557f3fbd4.xhtml),
    *Improving Application Performance, *but for now, let's continue looking through
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get to the `ConvertToPoint` method, which converts the values of
    our two angle Dependency Properties into two-dimensional `Point` objects. Our
    first job is to convert each angle from degrees into radians, as the methods of
    the `Math` class that we need to use require radian values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we calculate the two radii of our arc using half of the `RenderSize` value
    minus the `StrokeThickness` property value, so that the size of the arc does not
    exceed the bounding box of our `Arc` control. Finally, we perform some basic trigonometry
    using the `Math.Cos` and `Math.Sin` methods when calculating the `Point` element
    to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes our simple `Arc` control and so now, we can utilize this new
    class in our `Gauge` control. We''ll need to create another new custom control
    for it, so let''s first see the properties and code in our new `Gauge` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we start by overriding the metadata of the `DefaultStyleKeyProperty`
    for our control type in the static constructor, to help the Framework find where
    its default style is defined. We then declare the internal, read-only `ValueAngle`
    and `RotationAngle` Dependency Properties and the regular public `Value`, `MaximumValue`,
    and `Title` Dependency Properties.
  prefs: []
  type: TYPE_NORMAL
- en: We declare a `PropertyChangedCallback` hander for the `Value` property, and,
    in that method, we first cast the `dependencyObject` input parameter to an instance
    of our `Gauge` class. If the value of the `MaximumValue` property is zero, then
    we simply set both of the `ValueAngle` and `RotationAngle` properties to `180.0`,
    which results in the arc and needle being displayed in their start positions,
    on the left.
  prefs: []
  type: TYPE_NORMAL
- en: If the new value of the data bound `Value` property is more than the value of
    the `MaximumValue` property, then we make the arc and needle display in their
    end, or full, positions to the right. We do this by setting the `ValueAngle` property
    to `0.0` and the `RotationAngle` property to `360.0`.
  prefs: []
  type: TYPE_NORMAL
- en: If the new value of the `Value` property is valid, then we calculate the `scaledPercentageValue`
    variable. We do this by first dividing the new value by the value of the `MaximumValue`
    property, to get the percentage of the maximum value. We then multiply that figure
    by `180.0`, because our gauge covers a range of one hundred and eighty degrees.
  prefs: []
  type: TYPE_NORMAL
- en: We then subtract the `scaledPercentageValue` variable value from `180.0` for
    the `ValueAngle` property and add it to `180.0` for the `RotationAngle` property.
    This is because the `ValueAngle` property is used by our arc and needs to be between
    `180.0` and `0.0`, and the `RotationAngle` property is used by our gauge needle
    and needs to be between `180.0` and `360.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will soon be made clearer, so let''s now see how we use these properties
    and the `Arc` control in our `Gauge` control''s default style from the `Generic.xaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We start our default style as usual, by specifying the type of our control in
    both the style and the control template. Inside the template, we have two `Grid`
    panels and data bind the `Background` property of the outer panel and the `Margin`
    property of the inner panel to properties of our templated control, so that users
    can set them externally.
  prefs: []
  type: TYPE_NORMAL
- en: We then define three rows in our inner panel. The control's `Title` property
    is data bound to a horizontally centered `TextBlock` element in the first row.
    In the second row, we declare a horizontally centered `Canvas` panel that contains
    two of our new `Arc` controls and a `Path` object.
  prefs: []
  type: TYPE_NORMAL
- en: The first `Arc` control is gray and represents the background track that the
    `Arc` that represents our `Gauge` control's `Value` property sits on. The second
    `Arc` control is colored `OrangeRed` and displays the current value of our `Gauge`
    control's `Value` property, by data binding its `EndAngle` property to the `AngleValue` Dependency
    Property of the `Gauge` control.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the angles in our `Arc` control follow the common Cartesian coordinate
    system, with an angle of zero degrees falling to the right and increasing values
    moving anti-clockwise. Therefore, to draw a semi-circular arc from left to right,
    we start with an angle of `180` degrees and end at `0` degrees, as demonstrated
    by the background arc in our `Gauge` control.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, our `Arc` controls have the same width and height values, but as
    we don't need their lower halves, we crop them using the height of the canvas
    panel. The `Path` object represents the gauge needle in our control and is painted
    white.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `StrokeLineJoin` property to the `Round` value in order to curve
    the three corners, where the lines of the needle path meet. Note that the needle
    is positioned exactly half way across the width of the canvas and ten pixels above
    the bottom, to enable its center line to lie along the bottom of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than declaring `PathFigure` and `LineSegment` objects to define the needle,
    we have used the shorthand notation inline in the `Data` property. The `M` specifies
    that we should move to (or start from) point `0,0`, the `L` specifies that we
    want to draw a line to point `125,10` and then from there to point `0,20`, and
    the `Z` means that we want to close the path by joining the first and last points.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the width and height of the path to the same values that were declared
    within `Data` property. Now, the essential part of enabling this needle to point
    to the relevant position to reflect the data bound `Value` property, is the `RotateTransform`
    object that is applied to the path's `RenderTransform` property. Note that its
    center point is set to be the center of the bottom of the needle, as that is the
    point that we want to rotate from.
  prefs: []
  type: TYPE_NORMAL
- en: As the `RotateTransform` object rotates clockwise with increasing `Angle` values,
    we cannot reuse the `AngleValue` Dependency Property with it. Therefore, in this
    particular example, we define the needle pointing to the right and use a range
    of `180.0` to `360.0` degrees in the `RotationAngle` read-only Dependency Property
    with the transform object to match the position of the value arc.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the example, we see another horizontally centered `TextBlock`,
    element that outputs the current, unaltered value of the data bound `Value` Dependency
    Property. Note that we use the `StringFormat` value of `N0` to remove the decimal
    places from the value before displaying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes our new `Gauge` control and so, all we need to do now is see
    how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We could extend our new `Gauge` control to make it more usable in several ways.
    We could add a `MinimumValue` Dependency Property to enable its use with value
    ranges that do not start at zero, or we could expose further properties to enable
    users to color, size, or further customize the control. Alternatively, we could
    rewrite it to enable it to be any size, instead of hard coding sizes as we did
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Livening up the UI controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to making our UI controls look visually appealing, we can also "*liven
    them up*" by adding user interactivity in the form of mouse over effects. While
    most mouse over effects are created using `Trigger` and `Setter` objects, that
    immediately update the relevant style properties when the related trigger condition
    is met, we can alternatively use animations to produce these effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having even subtle transitions between states, rather than instantly switching,
    can also provide a richer user experience. Let''s reuse our initial double bordered
    example from earlier and add some mouse interactivity animations to it to demonstrate
    this point. We''ll need to add a few more resources into a suitable resource collection
    and adjust a couple of our previously declared resources too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have declared our semi-transparent `Color` resources, we can adjust
    our earlier brush resources to utilize them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s view our full example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While this example might seem quite long, it is actually fairly simple. We start
    with our original control template, albeit with the previously hardcoded brush
    values being replaced by our newly defined resources. The main difference with
    the original example is found in the `ControlTemplate.Triggers` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The first trigger will start its various storyboards when the `IsMouseOver`
    property of the `Button` element is true, or in other words, when the user moves
    the mouse cursor over the button. Our storyboards are split between the `Trigger.EnterActions`
    and `Trigger.ExitActions` collections.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the storyboards in the `Trigger.EnterActions` collection will
    be started as the mouse enters the bounds of the button, while the storyboards
    in the `Trigger.ExitActions` collection will be started as the mouse leaves the
    bounds of the button. We declare three `BeginStoryboard` objects with their associated
    `Storyboard` objects within each of these `TriggerActionCollection` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The first animation targets the `BorderBrush` property of the `OuterBorder`
    element. Note that this property is of type `Brush`, but there is no `BrushAnimation`
    class in WPF. Therefore, we need to target the `Color` property of the `SolidColorBrush`
    that is actually applied to this property and use a `ColorAnimation` object instead.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we need to use indirect targeting to first reference the
    `BorderBrush` property and then to chain to the `Color` property using the syntax `BorderBrush.(SolidColorBrush.Color)`.
    Note that this will only work if we are in fact using a `SolidColorBrush` element,
    as we are in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we were using one of the gradient brushes instead of a `SolidColorBrush`
    element, we could target the various colors of its `GradientStop` elements with
    a slightly different syntax. For example, we could target the color of the first
    `GradientStop` element in a gradient brush like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Returning to this example now, the second animation targets the `BorderBrush`
    property of the `InnerBorder` element and follows the syntactical example of the
    first animation. While the third animation also uses indirect targeting to reference
    the `Background` property of the `InnerBorder` element, it is somewhat different
    to the other two animations.
  prefs: []
  type: TYPE_NORMAL
- en: For this animation, we name the `BeginStoryboard` object `BackgroundFadeIn`
    and set its `HandoffBehavior` property to `Compose`, to enable smoother transitions
    between this and the other animations of this property. The specified name will
    be used later in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these three `ColorAnimation` objects only have their `To` and `Duration`
    properties set and that the three duration values are slightly different. This
    has the effect of slightly thickening the effect, although synchronizing the times
    also works well.
  prefs: []
  type: TYPE_NORMAL
- en: We have omitted the `From` values on these animations to avoid situations where
    the current animated colors do not match the `From` values and have to immediately
    jump to the starting values before animating to the `To` values. By omitting these
    values, the animations will start at their current color values and will result
    in smoother transitions.
  prefs: []
  type: TYPE_NORMAL
- en: The three animations in the `Trigger.ExitActions` collection are very similar
    to those in the `EnterActions` collection, albeit animating the colors back to
    their original starting colors, so we can skip their explanation here. However,
    it is worth highlighting the fact that the third animation is also declared in
    a named `BeginStoryboard` that has its `HandoffBehavior` property set to `Compose`.
  prefs: []
  type: TYPE_NORMAL
- en: The next `Trigger` object will start its associated storyboard when the `IsPressed`
    property of the `Button` element is true, and as it is declared within the `EnterActions`
    collection, it will start when the user presses the mouse button down, rather
    than upon its release.
  prefs: []
  type: TYPE_NORMAL
- en: This animation also uses indirect targeting to reference the `Background` property
    of the `InnerBorder` element and also has a named `BeginStoryboard` object with
    its `HandoffBehavior` property set to `Compose`. Unlike the other animations,
    this one has an extended duration and also sets the `DecelerationRatio` property
    to `1.0`, which results in quick start and slow end.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reach the last trigger, which is an `EventTrigger` object that will
    be triggered when the `Button` object is unloaded. In this trigger, we remove
    the three named storyboards, thereby freeing the extra resources that they consume
    when using the `Compose` handoff behavior. This was the sole purpose for naming
    the three `BeginStoryboard` objects that reference the `Background` property.
  prefs: []
  type: TYPE_NORMAL
- en: When animating mouse over effects on buttons, we are not restricted to simply
    changing the background and border colors. The more imaginative that we can be,
    the more our applications will stand out from the crowd.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, rather than simply changing the background color of the button,
    we can instead move the focal point of the gradient with the mouse. We''ll need
    to use some code to do this, so we''ll need to create another custom control to
    demonstrate this point. Let''s first take a look at the code from our new custom
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We start as usual, by adding the relevant references and declaring the `PART_RootGrid`
    panel element as being a required part of the control template in the `TemplatePartAttribute`
    attribute. As our custom control is a button, we extend the `ButtonBase` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `glowBrush` field and set it to `null`. In the static constructor,
    we call the `OverrideMetadata` method to inform the Framework of where our control''s
    default style is. We then declare a `GlowMode` CLR property of type `GlowMode` and
    set it to the default `FullCenterMovement` member. Let''s see the members of this
    `GlowMode` enumeration now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Returning to our `GlowButton` class, we also declare a `GlowColor` Dependency
    Property and define a default purple color, a property changed handler and some
    CLR property wrappers for it. In the `OnGlowColorChanged` handler method, we cast
    the `dependencyObject` input parameter to our `GlowButton` class and call the
    `SetGlowColor` method, passing in the new `Color` input value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `OnApplyTemplate` method that is called when the button element's
    control template has been applied. In this method, we attempt to access the `PART_Root`
    panel element using the `GetTemplateChild` method and check it for `null`. If
    it is not `null`, we do a number of things.
  prefs: []
  type: TYPE_NORMAL
- en: First, we attach the `Grid_MouseMove` event handler method to the grid's `MouseMove`
    event. Note that this is the way to attach event handlers to the UI elements that
    are declared in the `Generic.xaml` file, as it has no related code behind file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the grid's `FindResource` method in order to access the `GlowBrush`
    resource from its `Resources` section and set it to our local `glowBrush` field,
    as we will be referencing it regularly. After this, we call the `SetGlowColor`
    method and pass in the current `GlowColor` value.
  prefs: []
  type: TYPE_NORMAL
- en: We do this because the `OnApplyTemplate` method is generally called after the
    properties have been set, but we are unable to update the brush resource until
    the template has been applied. When writing custom controls, we often need to
    update properties from this method, once the template has been applied.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `SetGlowColor` method and in it we first make the set color semi-transparent.
    If the `glowBrush` variable is not `null`, we then access the third `GradientStop`
    element from its `GradientStops` collection and set its `Color` property to the
    value of our `GlowColor` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the third `GradientStop` element represents the dominant color in
    this gradient and so in this example, we are only updating this single element,
    in order to save space in this book. This gives the overall impression of a complete
    color change, but anyone that looks carefully will be able to see a dash of purple
    showing through from the other two unchanged `GradientStop` elements. You may
    wish to extend this example to update the whole `GradientStops` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `Grid_MouseMove` event handling method that was attached to
    the `rootGrid` variable in the `OnApplyTemplate` method. In it, we check that
    the mouse is currently over the grid and that the `glowBrush` variable is not
    `null`. If these conditions are true, we call the `GetPosition` method on the
    `MouseEventArgs` input parameter to get the current position of the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mouse position and the current value of the `GlowMode` property, we
    determine the movement mode and update the position of the `glowBrush` field's
    `Center` and/or `GradientOrigin` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has the effect of moving the center and/or the focal point of the gradient
    with the mouse cursor when it is over our glow button. Let''s see the XAML in
    the `Generic.xaml` file now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Inside this `ControlTemplate`, we see the `Grid` named `PART_Root`, and, inside
    it, we see a number of resources declared in its `Resources` section. Much of
    this XAML is taken up by the same resources that we used in our layered button
    background example, so we can skip their explanation.
  prefs: []
  type: TYPE_NORMAL
- en: There is however, one new resource of type `RadialGradientBrush` and named `GlowBrush`.
    This is the brush that puts the color into our button. In particular, note that
    its `RelativeTransform` property is set to a `ScaleTransform` element named `ScaleTransform`
    and that its third `GradientStop` object is data bound to the `GlowColor` property
    from our control.
  prefs: []
  type: TYPE_NORMAL
- en: In the actual template, we see our double `Border` elements with their `SnapsToDevicePixels`
    properties set to true to ensure a sharp, rendered image. Again, the outer border
    has a larger `CornerRadius` value than the inner border, to ensure their tight
    fit together, and the inner border's background is painted with the `LayeredButtonBackground`
    visual brush that we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the inner border, we have a `Grid` panel that contains a `Rectangle`
    element and the required `ContentPresenter` object. We use the `GlowBrush` resource
    to paint the background of the rectangle and set its `IsHitTestVisible` property
    to `false`, so that it takes no part in user interaction. Note that in this example,
    we set its `Opacity` property to zero to make it initially invisible.
  prefs: []
  type: TYPE_NORMAL
- en: We data bind the button's `Content` and `Padding` properties to the `Content`
    and `Margin` properties of the `ContentPresenter` element, respectively, and center
    it within the control. That completes the visual markup for our glow button and
    now, we reach the all-important `Grid.Triggers` collection, where we declare three
    `EventTrigger` objects to trigger our mouse over effects.
  prefs: []
  type: TYPE_NORMAL
- en: The first trigger starts its associated storyboard when the `MouseEnter` event
    is raised. Its associated `DoubleAnimation` object animates the "glowing" rectangle's
    `Opacity` property to `1.0` over half a second. Note that we omit the `From` property
    here, so that the `Opacity` value will start animating from its current value,
    rather than jumping back to `0.0` each time it starts the animation.
  prefs: []
  type: TYPE_NORMAL
- en: The second trigger starts its storyboard when the `MouseLeave` event is raised.
    Its `DoubleAnimation` object animates the rectangle's `Opacity` property back
    to `0.0` over a whole second. Note that we also omit the `From` property here
    so that the `Opacity` value will start animating from its current value, rather
    than jumping to `1.0` each time it starts its animation. This ensures a smoother
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: The third trigger starts its storyboard when the `MouseDown` event is raised
    and it contains two `DoubleAnimation` objects. They animate the `ScaleX` and `ScaleY`
    properties of the `ScaleTransform` object from `10.0` to their usual values over
    one hundred and fifty milliseconds, which produces an interesting effect when
    the user clicks the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `GlowColor` and `GlowMode` properties, we can produce a wide range
    of buttons and interaction effects. After defining the relevant XAML namespace
    in our View, we can use this glow button example in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When our example is run, it can produce mouse over effects, which vary depending
    on the position of the mouse cursor, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7db5a27-60f6-4860-bdfc-b8e067842d25.png)'
  prefs: []
  type: TYPE_IMG
- en: The top left button illustrates the `HorizontalCenterMovement` mode, the top
    right shows the `FullCenterMovement` mode and the bottom two highlight two mouse
    positions when using the `NoCenterMovement` mode. The top two use the default
    color and the bottom two were rendered using a `GlowColor` of `Red`. This reveals
    the differences between the various `GlowMode` values in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we investigated a number of techniques that we can use to improve
    the look of our applications, from simply adding shadows to implementing far more
    complicated layered visuals. We saw the importance of remaining consistent throughout
    our application and how to get that professional look.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at more advanced techniques for making our application stand
    out from the crowd and saw further examples of how to create a variety of custom
    controls. We finished with a look at how we can incorporate animations into our
    everyday controls, in order to bring about a sense of exclusivity to our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we're going to investigate a number of ways that we
    can validate the data in our applications. We'll examine the various validation
    interfaces that are available to us in WPF and work on extending our application
    framework with a complete validation system using data annotations.
  prefs: []
  type: TYPE_NORMAL
