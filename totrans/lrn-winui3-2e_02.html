<html><head></head><body>
		<div><h1 id="_idParaDest-44" class="chapter-number"><a id="_idTextAnchor044"/>2</h1>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Configuring the Development Environment and Creating the Project</h1>
			<p>To get started with WinUI and Windows App SDK development, it is important to install and configure Visual Studio for Windows desktop development. A WinUI developer must also understand the<a id="_idIndexMarker119"/> basics of application<strong class="bold"> </strong>development with <strong class="bold">Extensible Application Markup Language</strong> (<strong class="bold">XAML</strong>) and<a id="_idIndexMarker120"/> C#, which we started learning in <a href="B20908_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to WinUI</em>. However, the best way to understand the development concept is to get your hands on a real project. We will do that in this chapter.</p>
			<p>After setting up your Visual Studio development environment, you will create the beginnings of a project that we will be building throughout the rest of the book.</p>
			<p>In this chapter, you will learn the following topics:</p>
			<ul>
				<li>How to set up a new Visual Studio installation for Windows desktop application development</li>
				<li>How to create a new WinUI project, add a few controls, and run the project for the first time</li>
				<li>The anatomy of a new WinUI project and why each part is important</li>
				<li>How XAML can be used to build flexible, performant <strong class="bold">user </strong><strong class="bold">interfaces</strong> (<strong class="bold">UIs</strong>)</li>
				<li>How WinUI fits with .NET and the role of each layer in the overall application architecture</li>
				<li>How to work with WinUI controls and customize them through changes in the XAML markup or C# code</li>
				<li>How to handle some basic UI events</li>
			</ul>
			<p>If you are new to WinUI and other XAML-based development platforms, by the end of this chapter, you should be starting to feel comfortable working with WinUI projects.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, the following software is required:</p>
			<ul>
				<li>Windows 10, version 1809 (build 17763) or newer or Windows 11</li>
				<li>Visual Studio 2022 version 17.1 or later with the <strong class="bold">.NET desktop development</strong> workload and <strong class="bold">Windows App SDK C# Templates</strong> selected during installation</li>
			</ul>
			<p>The source code for this chapter is available on GitHub at this URL: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Installing Visual Studio and Windows desktop development workloads</h1>
			<p>The<a id="_idIndexMarker121"/> first step to follow when starting with WinUI development is to install Microsoft’s Visual <a id="_idIndexMarker122"/>Studio <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>). You can download the current version of Visual Studio 2022<a id="_idIndexMarker123"/> from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>. Visual Studio 2022 Community Edition<a id="_idIndexMarker124"/> is free for personal use and has all the features you will need to build WinUI applications.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to try new Visual Studio features before they are released, you can install the latest<a id="_idIndexMarker125"/> Visual Studio Preview version from <a href="https://visualstudio.microsoft.com/vs/preview/">https://visualstudio.microsoft.com/vs/preview/</a>. The Preview version is not recommended for the development of production applications as some features are unstable.</p>
			<p>During<a id="_idIndexMarker126"/> installation, you can select workloads for any type of application that you want to create. For WinUI <a id="_idIndexMarker127"/>development, you must start by selecting the <strong class="bold">.NET desktop development</strong> workload. An overview of the <strong class="bold">Workloads</strong> section is shown in the following screenshot:</p>
			<div><div><img src="img/B20908_02_01.jpg" alt="Figure 2.1 – Visual Studio Installer workload selection"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Visual Studio Installer workload selection</p>
			<p>After the <strong class="bold">.NET desktop development</strong> workload has been selected, select the <strong class="bold">Windows App SDK C# Templates</strong> component from the <strong class="bold">Installation details</strong> pane. These templates, required for building WinUI apps, are not installed by default with the workload.</p>
			<div><div><img src="img/B20908_02_02.jpg" alt="Figure 2.2 – Selecting the Windows App SDK C# Templates component for installation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Selecting the Windows App SDK C# Templates component for installation</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are a C++ developer and would like to build WinUI apps with C++, you must select the <strong class="bold">Desktop development with C++</strong> workload and the optional <strong class="bold">Windows App SDK C++ Templates</strong> component within the <strong class="bold">Desktop development with C++</strong> workload. However, building WinUI applications with C++ is beyond the scope of this book.</p>
			<p>When <a id="_idIndexMarker128"/>continuing to the next step, the Visual Studio Installer will download and install all selected workloads and components. When setup is complete, launch Visual Studio. The <a id="_idIndexMarker129"/>first time you run Visual Studio, you will be prompted to sign in with a Microsoft account. Linking Visual Studio to your account will enable Visual Studio to sync your settings, link any available licenses, and link your Microsoft Store account after it has been created. We will discuss more about the Microsoft Store and application distribution in <a href="B20908_14.xhtml#_idTextAnchor582"><em class="italic">Chapter 14</em></a>, <em class="italic">Packaging and Deploying </em><em class="italic">WinUI Applications</em>.</p>
			<p>Now, it’s time to start building our WinUI application.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Introducing the application idea</h1>
			<p>The application <a id="_idIndexMarker130"/>we’re going to build is a tool called <strong class="bold">My Media Collection</strong>. It’s a simple utility that can catalog your entire media library. Because digital media is becoming more popular as time goes on, we can design the application to support the inclusion of both physical and digital media. The application will be able to catalog different types of media, including music, video, and books. We’ll add some features that will only light up for certain media types. Physical media (books, DVDs, and CDs) are often loaned to friends. This application will help you remember who borrowed your favorite book at a recent family party.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>Reviewing the application features</h2>
			<p>Before we dive in and <a id="_idIndexMarker131"/>create the new project, let’s get organized. It helps to understand what you’re going to build so that you can track your progress while progressing through each chapter. If you’re tracking your development on GitHub, you could create an <strong class="bold">Issue</strong> for each feature. Let’s start with a high-level look at the application’s features, as follows:</p>
			<ul>
				<li>View all media</li>
				<li>Filter the media library by the following: <strong class="bold">Media Type</strong> (<strong class="bold">Music</strong>, <strong class="bold">Video</strong>, or <strong class="bold">Book</strong>), <strong class="bold">Medium</strong> (the available choices will vary by media type but will include <strong class="bold">CD</strong>, <strong class="bold">Record</strong>, <strong class="bold">DVD</strong>, <strong class="bold">Blu-Ray</strong>, <strong class="bold">Hardcover</strong>, <strong class="bold">Paperback</strong>, <strong class="bold">Digital</strong>), or <strong class="bold">Location</strong> (<strong class="bold">In Collection</strong> or <strong class="bold">Loaned</strong>)</li>
				<li>Add a new media item</li>
				<li>Edit a media item</li>
				<li>Mark an item as loaned or returned</li>
				<li>Application sign-in</li>
				<li>Back up (or restore) the collection data with OneDrive</li>
			</ul>
			<p>The application will use<a id="_idIndexMarker132"/> features of the <strong class="bold">Windows Community Toolkit</strong>, which can simplify things such as Microsoft account authentication and file access on<a id="_idIndexMarker133"/> OneDrive. You can read more about the toolkit on Microsoft Learn: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/windows/">https://learn.microsoft.com/dotnet/communitytoolkit/windows/</a>. The application’s data will be stored in a local <strong class="bold">SQLite</strong> database, allowing <a id="_idIndexMarker134"/>for online or offline access to the media collection. You’ll even be able to send email<a id="_idIndexMarker135"/> reminders if one of your friends is taking a little too long in returning one of the items in your collection.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>WinUI in Desktop projects</h2>
			<p>In this chapter, we will be building a Windows App SDK application with the <strong class="bold">WinUI in Desktop</strong> project template. A <strong class="bold">WinUI in Desktop</strong> project targets the .NET runtime while using the same XAML schema as a UWP project.</p>
			<p>A <strong class="bold">WinUI in Desktop</strong> project<a id="_idIndexMarker136"/> also includes a <strong class="bold">Windows Application Packaging</strong> project<a id="_idIndexMarker137"/> in the newly created solution. We will learn more about packaging WinUI applications in <a href="B20908_14.xhtml#_idTextAnchor582"><em class="italic">Chapter 14</em></a>, <em class="italic">Packaging and Deploying WinUI Applications</em>. Now, let’s get started with our first project.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Creating your first WinUI project</h1>
			<p>It’s <a id="_idIndexMarker138"/>time to start building the project. To do so, proceed as follows:</p>
			<ol>
				<li>Launch Visual Studio, and from the opening screen, select <strong class="bold">Create a new project</strong>, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B20908_02_03.jpg" alt="Figure 2.3 – The initial Visual Studio dialog"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – The initial Visual Studio dialog</p>
			<ol>
				<li value="2">On <a id="_idIndexMarker139"/>the <code>winui</code> in the <strong class="bold">Search for templates</strong> field, select the <strong class="bold">Blank App, Packaged (WinUI 3 in Desktop)</strong> C# template, and click <strong class="bold">Next</strong>, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B20908_02_04.jpg" alt="Figure 2.4 – Selecting the project template"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Selecting the project template</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Be sure to select the <strong class="bold">C#</strong> project template and not <strong class="bold">C++</strong>. You can filter the project types to show only C# projects by changing the <strong class="bold">Language</strong> filter from <strong class="bold">All languages</strong> to <strong class="bold">C#</strong>.</p>
			<ol>
				<li value="3">Name<a id="_idIndexMarker140"/> the project <code>MyMediaCollection</code>, leave the rest of the fields set to their default values, and click <strong class="bold">Create</strong>. You may be prompted to select the Windows versions to target with your app. You can leave these set to their default values for this project.</li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">It is up to you whether you want to change these versions for your app, but you will be limiting the versions of Windows that can install your app. If you are using a control or feature that you know is only available in specific versions of Windows, you must select that version as the <strong class="bold">Minimum version</strong>. The <strong class="bold">Target version</strong> must be equal to or greater than the <strong class="bold">Minimum version</strong>. If you are unsure of what to choose, you should stick with the default values.</p>
			<ol>
				<li value="4">Now, the <a id="_idIndexMarker141"/>project has been created and Visual Studio has loaded, it’s always a best practice to build and run the project. Run the application and see what the template has provided for <code>MainWindow</code>. You should see an empty window hosting a few controls. Next, we will see what Visual Studio has created to get us started.</li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">To run and debug WinUI apps on Windows, you must update your Windows settings to enable <strong class="bold">Developer Mode</strong>. To do this, follow these steps:</p>
			<p class="callout">1. Open <strong class="bold">Settings</strong> from the <strong class="bold">Start</strong> menu.</p>
			<p class="callout">2. Type <code>Developer</code> in the search bar and select the <strong class="bold">For Developers</strong> settings from the search results.</p>
			<p class="callout">3. On the <strong class="bold">For developers</strong> page that appears, switch the <strong class="bold">Developer Mode</strong> toggle switch on, if it is not already turned on. Enabling this allows developers to sideload, run, and debug unsigned apps, and enables some other developer-focused Windows settings. You can get more information here: <a href="https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development">https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development</a>.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Anatomy of a WinUI in Desktop project</h1>
			<p>Now that we have a<a id="_idIndexMarker142"/> new empty WinUI project loaded in Visual Studio, let’s examine the different components. In <code>App.xaml</code> and <code>MainWindow.xaml</code>. We will start by discussing the purpose of each of these. Both files can be seen in the following screenshot of <strong class="bold">Solution Explorer</strong>:</p>
			<div><div><img src="img/B20908_02_05.jpg" alt="Figure 2.5 – The new WinUI solution in Solution Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – The new WinUI solution in Solution Explorer</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Reviewing App.xaml</h2>
			<p>The <code>App.xaml</code> file, as its <a id="_idIndexMarker143"/>name implies, stores resources available across the entire application. If you have any templates or styles that will need to be used across multiple windows, they should be added at the <code>Application</code> level.</p>
			<p>The new project’s <code>App.xaml</code> file will contain some initial markup, as illustrated in the following code snippet:</p>
			<pre class="source-code">
&lt;Application
    x:Class="MyMediaCollection.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/
  presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:MyMediaCollection"&gt;
    &lt;Application.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;ResourceDictionary.MergedDictionaries&gt;
                &lt;XamlControlsResources
                  xmlns="using:Microsoft.UI
                    .Xaml.Controls" /&gt;
                &lt;!-- Other merged dictionaries here --&gt;
            &lt;/ResourceDictionary.MergedDictionaries&gt;
            &lt;!-- Other app resources here --&gt;
        &lt;/ResourceDictionary&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;</pre>			<p>We will cover some XAML basics in the next section. For now, you should know that the <code>Application.Resources</code> section will contain all the resources to be shared across an application. Within this section, the <code>ResourceDictionary.MergedDictionaries</code> section contains references to other XAML files whose resources will be shared with the entire application. This allows developers to organize shared content into multiple resource files, leading to better-organized and more maintainable XAML. This also enables the sharing of third-party resources across the application. For example, this file merges <code>XamlControlsResources</code> from the <code>Microsoft.UI.Xaml.Controls</code> namespace. These<a id="_idIndexMarker144"/> are the resources for the WinUI controls that we will be using to build our app.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>Reviewing App.xaml.cs</h2>
			<p>In <code>App.xaml</code> file’s node, and you will see there is another file named <code>App.xaml.cs</code> nested underneath. This is referred to as a <code>Application</code> class. If you open the C# file, you will see that it already contains some code. This is where you will handle any application-wide events. This is the event handler added by default: <code>OnLaunched</code>. If you need to execute any specific logic when your app is first launched, it should be<a id="_idIndexMarker147"/> added here. This is also where any application arguments passed to the app can be handled.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Reviewing MainWindow.xaml</h2>
			<p>The <code>MainWindow.xaml</code> file <a id="_idIndexMarker148"/>contains the <code>MainWindow</code> WinUI window that will be displayed when the application launches. You can see this in the <code>OnLaunched</code> event handler in <code>App.xaml.cs</code>, as illustrated in the following code snippet:</p>
			<pre class="source-code">
m_window = new MainWindow();
m_window.Activate();</pre>			<p>In a new blank WinUI app, <code>Window</code> will contain an empty <code>StackPanel</code> layout control. Try replacing <code>StackPanel</code>’s child controls with <code>TextBlock</code> with a <code>Text</code> property of <code>Media</code> and replace <code>StackPanel</code> with <code>Grid</code>. The result should look like this:</p>
			<pre class="source-code">
&lt;Window
    x:Class="MyMediaCollection.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/
      presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:MyMediaCollection"
    xmlns:d="http://schemas.microsoft.com/expression/blend/
      2008"
    xmlns:mc="http://schemas.openxmlformats.org/
      markup-compatibility/2006"
    mc:Ignorable="d"&gt;
<strong class="bold">    &lt;Grid&gt;</strong>
<strong class="bold">        &lt;TextBlock Text="Media"/&gt;</strong>
<strong class="bold">    &lt;/Grid&gt;</strong>
&lt;/Page&gt;</pre>			<p>To prevent<a id="_idIndexMarker149"/> exceptions at runtime, remove the event handler for the <code>Button.Click</code> event in <code>MainWindow.xaml.cs</code>. Now run the app with the <strong class="bold">Debug</strong> | <strong class="bold">Start Debugging</strong> menu item or the <strong class="bold">Start Debugging</strong> button on the Visual Studio toolbar, and you should see something like this:</p>
			<div><div><img src="img/B20908_02_06.jpg" alt="Figure 2.6 – MainWindow with TextBlock added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – MainWindow with TextBlock added</p>
			<p>We’ll make this window a bit more functional later in the chapter. For now, let’s finish our review of the project structure.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>Reviewing MainWindow.xaml.cs</h2>
			<p>The code-behind file<a id="_idIndexMarker150"/> for the <code>MainWindow.xaml.cs</code> window now contains only a call to <code>InitializeComponent()</code> in the constructor because we removed the event handler for the original <code>Button</code> control. Later, we will add some code here to populate some sample data and handle events on the page. In a well-designed MVVM app, the code-behind files for your pages will have very little code. Most of the code will reside in the <code>ViewModel</code> classes.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Reviewing the project references</h2>
			<p>All your<a id="_idIndexMarker151"/> project’s references<a id="_idIndexMarker152"/> to <code>Packages</code> folder under <strong class="bold">Dependencies</strong> in <strong class="bold">Solution Explorer</strong>. Your WinUI project will reference the following NuGet packages:</p>
			<ul>
				<li><code>Microsoft.WindowsAppSDK</code>: The Windows App SDK components, which include WinUI</li>
				<li><code>Microsoft.Windows.SDK.BuildTools</code>: The Windows SDK components required to build a WinUI solution</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Do not modify or remove any of these references.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>Reviewing the project properties</h2>
			<p>If you right-click the<a id="_idIndexMarker154"/> project in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Properties</strong> from the context menu, you can view and modify the project properties. You won’t often need to make any changes here. These are a couple of properties you might need to modify from time to time:</p>
			<ul>
				<li><strong class="bold">Assembly Name</strong>: You can change the name of the output assembly that is compiled by the project</li>
				<li><strong class="bold">Min Version</strong> and <strong class="bold">Target Version</strong>: The Windows versions that were selected when creating the project can be modified here</li>
			</ul>
			<p>The primary difference between a new UWP project and a new WinUI 3 project is the controls and other objects that are referenced in the <code>Windows.UI.Xaml.*</code> namespaces are now referenced in the Windows App SDK’s <code>Microsoft.UI.Xaml.*</code> namespaces. One other difference is that in the <code>App.xaml</code> file of the UWP project, it’s not necessary to import the controls’ resources. The remaining differences are mostly hidden from app developers in the project file.</p>
			<p>Now that you’ve become familiar with the WinUI project, let’s start building the UI for <code>MainWindow</code>. We will start with some of the more common XAML controls and concepts.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>XAML basics</h1>
			<p>It’s time to start<a id="_idIndexMarker155"/> building the main screen of the <strong class="bold">My Media Collection</strong> application. The focal point of the application will be the media items in the collection. To display that list, we are going to need a few things, as follows:</p>
			<ul>
				<li>A <code>Model</code> class that defines an item in the collection</li>
				<li>Some code to bind the collection of items to the UI</li>
				<li>A XAML control to display the items</li>
			</ul>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/>Building the model</h2>
			<p>We will start by<a id="_idIndexMarker156"/> building the model for the <strong class="bold">My Media Collection</strong> application. A <strong class="bold">model</strong> defines an entity and its attributes. Earlier in the chapter, we discussed <a id="_idIndexMarker157"/>some of the items’ attributes we want to display in the UI. To display and (eventually) persist this information, we must create the model.</p>
			<p>The initial version of our model will consist of two enumerations (<code>ItemType</code> and <code>LocationType</code>) in an <code>Enums</code> folder, and two classes (<code>Medium</code> and <code>MediaItem</code>) in a <code>Model</code> folder, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B20908_02_07.jpg" alt="Figure 2.7 – Solution Explorer displays the new Model and Enum files"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Solution Explorer displays the new Model and Enum files</p>
			<ol>
				<li>To add a <a id="_idIndexMarker158"/>new folder to the project, right-click on the <code>Enums</code> as the folder name and hit <em class="italic">Enter</em>. Repeat this process to add a <code>Model</code> folder.</li>
				<li>Next, right-click the project file and select <code>ItemType</code>, and click the <strong class="bold">Add</strong> button, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B20908_02_08.jpg" alt="Figure 2.8 – The Add New Item dialog"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – The Add New Item dialog</p>
			<ol>
				<li value="3">The code for <code>ItemType</code> is created and displayed. Change the <code>class</code> definition to <code>enum</code> and change the <code>internal</code> keyword to <code>public</code>. The <code>ItemType</code> enum contains<a id="_idIndexMarker159"/> three possible values named <code>Music</code>, <code>Video</code>, and <code>Book</code>. When you’re finished, the definition of the <code>ItemType</code> enum will look like this:<pre class="source-code">
public enum ItemType
{
    Music,
    Video,
    Book
}</pre></li>				<li>Repeat the steps to create a <code>LocationType</code> enum, defined as follows:<pre class="source-code">
public enum LocationType
{
    InCollection,
    Loaned
}</pre></li>				<li>Using what you have<a id="_idIndexMarker160"/> learned, create two classes named <code>Medium</code> and <code>MediaItem</code> in the <code>Model</code> folder. The <code>Medium</code> class represents a specific medium such as <em class="italic">hardcover</em> or <em class="italic">paperback</em>, while the <code>MediaType</code> property assigns an <code>ItemType</code> to which the <code>Medium</code> class belongs. For these, the valid <code>ItemType</code> would be <code>Book</code>. When you are finished, the two new classes will look like this:<pre class="source-code">
public class Medium
{
    public int Id { get; set; }
    public string Name { get; set; }
    public ItemType MediaType { get; set; }
}
public class MediaItem
{
    public int Id { get; set; }
    public string Name { get; set; }
    public ItemType MediaType { get; set; }
    public Medium MediumInfo { get; set; }
    public LocationType Location { get; set; }
}</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">To reference the enum types in the <code>Enums</code> folder from the two classes, a <code>using</code> declaration will need to be added at the top of each new class, like this: <code>using MyMediaCollection.Enums;</code>.</p>
			<p>In addition<a id="_idIndexMarker161"/> to the properties discussed earlier in the chapter, an <code>Id</code> property has been added to the <code>MediaItem</code> class to uniquely identify each item in the collection. This will be useful later when we start persisting data.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>Creating sample data</h2>
			<p>With the <a id="_idIndexMarker162"/>model classes in place, we’re ready to add some code that will create three media items to display in the UI. This will help us visualize things as we start creating our list of items on the main screen. When this step is complete and we’re ready to move on to enabling the ability to add items through the app, this code will be removed.</p>
			<p>For now, we are going to add this code in the <code>MainWindow.xaml.cs</code> code-behind file. Later, in <a href="B20908_03.xhtml#_idTextAnchor073"><em class="italic">Chapter 3</em></a>, <em class="italic">MVVM for Maintainability and Testability</em>, this type of code will be added in a <code>ViewModel</code> file. The <code>MainWindow</code> will contain only presentation logic and will not be responsible for creating or fetching the data that populates the UI:</p>
			<ol>
				<li>First, open <code>MainWindow.xaml.cs</code> and create a method named <code>PopulateData</code>. This method will contain the code that creates three <code>MediaItem</code> objects (a CD, a book, and a Blu-ray) and adds them to a private <code>List</code> named <code>_items</code>, as illustrated in the following code snippet:<pre class="source-code">
public void PopulateData()
{
    if (_isLoaded) return;
    _isLoaded = true;
    var cd = new MediaItem
    {
        Id = 1,
        Name = "Classical Favorites",
        MediaType = ItemType.Music,
        MediumInfo = new Medium { Id = 1,
          MediaType = ItemType.Music, Name = "CD" }
    };
    Var book = new MediaItem
    {
        Id = 2,
        Name = "Classic Fairy Tales",
        MediaType = ItemType.Book,
        MediumInfo = new Medium { Id = 2,
          MediaType = ItemType.Book, Name = "Book" }
    };
    var bluRay = new MediaItem
    {
        Id = 3,
        Name = "The Mummy",
        MediaType = ItemType.Video,
        MediumInfo = new Medium { Id = 3,
          MediaType = ItemType.Video, Name = "Blu Ray" }
    };
    _items = new List&lt;MediaItem&gt;
    {
        cd,
        book,
        bluRay
    };
}</pre><p class="list-inset">You will need to add the <code>using</code> statements to <code>MainWindow</code> for the <code>MyMediaCollection.Model</code> and <code>MyMediaCollection.Enums</code> namespaces.</p></li>				<li>Define <code>_items</code> <code>IList</code> and <code>isLoaded</code> <code>bool</code> as private class members. We will later<a id="_idIndexMarker163"/> change the collection of items to an <code>ObservableCollection</code>. <code>ObservableCollection</code> is a special collection that notifies data-bound items on the UI when items have been added or removed from the collection. For now, an <code>IList</code> will suit our needs. The code can be seen in the following snippet:<pre class="source-code">
private IList&lt;MediaItem&gt; _items { get; set; }
private bool _isLoaded;</pre></li>				<li>Next, add a line of code to the <code>MainWindow</code> constructor, after the call to <code>Initialize</code><code> Component</code>, to call the new <code>PopulateData</code> method. Any code added to a <code>Window</code> or <code>UserControl</code> constructor must be added after this initialization code. This is where all the XAML code in <code>MainWindow.xaml</code> is initialized. If you attempt to reference any of those elements before the call to <code>InitializeComponent</code>, it will result in an error. The constructor should now look like this:<pre class="source-code">
public MainWindow()
{
    this.InitializeComponent();
    PopulateData();
}</pre></li>			</ol>
			<p>We will<a id="_idIndexMarker164"/> return to this file to add some data-binding logic after creating some UI components in the XAML file. Let’s go and do that now.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>Building the initial UI</h2>
			<p>Earlier in the <a id="_idIndexMarker165"/>chapter, we added a single <code>TextBlock</code> to the <code>MainWindow.xaml</code> file with the <code>Text</code> property set to <code>Media</code>. We are going to add a <code>ListView</code> control beneath the existing <code>TextBlock</code>. A <code>ListView</code> control is a powerful and flexible control to display a list of items in a vertical list. It is like the <code>ListBox</code> control in basic list functionality (item selection, multi-selection, and automatic scroll bars), but each list item can be templated to display in just about any way imaginable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information about<a id="_idIndexMarker166"/> the <code>ListView</code> class, documentation with sample code and markup is available on Microsoft Learn: <a href="https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview">https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview</a>.</p>
			<ol>
				<li>First, add some markup to create two rows inside the top-level <code>Grid</code> control. <code>RowDefinitions</code> should be added before the existing <code>TextBlock</code> element. <code>TextBlock</code> will remain in the first row, and we’ll add the <code>ListView</code> control to the second row. Create <code>RowDefinitions</code> as illustrated in the following code snippet:<pre class="source-code">
&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    &lt;RowDefinition Height="*"/&gt;
&lt;/Grid.RowDefinitions&gt;</pre><p class="list-inset">As you can see, we’re automatically sizing the first <code>RowDefinition</code> to the size of the <code>TextBlock</code> and allocating the remaining space inside the <code>Grid</code> to the <code>ListView</code> control’s <code>RowDefinition</code> by using <code>"*"</code>. If you assign more than one row with <code>"*"</code>, those rows will split the remaining available space equally. This is the default value for the <code>Height</code> attribute. It would be sized the same if <code>"*"</code> were omitted, but most XAML developers explicitly include it for completeness and<a id="_idIndexMarker167"/> improved readability.</p></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information about <a id="_idIndexMarker168"/>row sizing, see the following Microsoft Learn documentation: <a href="https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height">https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height</a>.</p>
			<ol>
				<li value="2">Next, add a <code>ListView</code> control to the <code>Grid</code>, setting <code>Grid.Row</code> equal to <code>1</code> (row numbering is 0-based, meaning the first row is row <code>0</code>), and name it <code>ItemList</code>. It is not necessary to name your XAML elements. This is only required if you either want to reference them by <code>ElementName</code> in XAML data binding or as a variable in the code-behind file. Naming a control causes a variable to be created in the <code>InitializeComponent</code> call, and to optimize performance, you should only name your controls if you need to reference them elsewhere. The markup can be seen in the following snippet:<pre class="source-code">
&lt;ListView Grid.Row="1" x:Name="ItemList"
  Background="LightGoldenrodYellow"/&gt;</pre></li>			</ol>
			<p>By setting the background color to <code>LightGoldenrodYellow</code>, we can see the <code>ListView</code> in the application’s main window before we populate any data. Depending on whether you are using a <em class="italic">Light</em> or <em class="italic">Dark</em> Windows theme, you can choose a color that works best for you. Run the app, and it should look something like this:</p>
			<div><div><img src="img/B20908_02_09.jpg" alt="Figure 2.9 – A ListView added to the UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – A ListView added to the UI</p>
			<p>Let’s return to <a id="_idIndexMarker169"/>the code-behind file to start wiring up the data binding.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are new to data binding concepts in XAML programming, Microsoft Learn has a great overview of data binding for Windows App SDK developers<a id="_idIndexMarker170"/> at the following web page: <a href="https://learn.microsoft.com/windows/apps/develop/data-binding/">https://learn.microsoft.com/windows/apps/develop/data-binding/</a>.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Completing the data-binding initialization</h2>
			<p>Return to the <code>MainWindow.xaml.cs</code> file<a id="_idIndexMarker171"/> and add a line of code before the <code>PopulateData()</code> method call, as follows:</p>
			<pre class="source-code">
ItemList.Loaded += ItemList_Loaded;</pre>			<p>After typing <code>+=</code>, Visual Studio <code>ItemList_Loaded</code> event handler, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B20908_02_010.jpg" alt="Figure 2.10 – Inserting the ItemList_Loaded event handler"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Inserting the ItemList_Loaded event handler</p>
			<p>Alternatively, if <a id="_idIndexMarker172"/>you type the entire line and press <em class="italic">Ctrl</em> +, you’ll be prompted to create the new method.</p>
			<p>To keep the <code>MainWindow</code> constructor simple and keep our data-loading code together, move the <code>PopulateData</code> call to the <code>ItemList_Loaded</code> method. Then, add the two other lines of code to the new event handler, as follows:</p>
			<pre class="source-code">
private void ItemList_Loaded(object sender,
  Microsoft.UI.Xaml.RoutedEventArgs e)
{
    var listView = (ListView)sender;
    PopulateData();
    listView.ItemsSource = _items;
}</pre>			<p>This code is called after the <code>ItemsList</code> control has completed loading in the UI. We’re getting the instance of the control from the <code>sender</code> parameter and setting the <code>ItemsSource</code> of the list to the <code>_items</code> collection that was loaded in <code>PopulateData()</code>. Now, we have data in the list, but things don’t look quite right, as can be seen from the following screenshot:</p>
			<div><div><img src="img/B20908_02_011.jpg" alt="Figure 2.11 – A ListView with three rows of data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – A ListView with three rows of data</p>
			<p>The <code>ListView</code> is <a id="_idIndexMarker173"/>displaying three rows for our three sample data items, but it’s displaying the data type for each item instead of the data. That’s because we haven’t told the <code>ListView</code> which properties it should display for the items in the collection. By default, the list will display whatever is returned by an object’s <code>ToString()</code> method. If <code>ToString()</code> is not overridden, the data type name of the class is returned.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>Creating the DataTemplate and binding the UI</h2>
			<p>Let’s return<a id="_idIndexMarker174"/> to <code>MainWindow.xaml</code> and tell <a id="_idIndexMarker175"/>the <code>ListView</code> which data we want to display for each item in the list. Try making this change with the application still running. Thanks to Visual Studio’s <strong class="bold">XAML Hot Reload</strong> feature, you<a id="_idIndexMarker176"/> should see the UI reload without having to restart the debugging session.</p>
			<p>Customizing the appearance of each <code>ListView</code> item is accomplished by defining a <code>DataTemplate</code> inside <code>ListView.ItemTemplate</code>. A <code>DataTemplate</code> can contain any WinUI controls we need to define the layout of each list item. Let’s keep it simple and add a <code>Grid</code> containing two columns. Each column will contain a <code>TextBlock</code>. The <code>ListView</code> should now look like this:</p>
			<pre class="source-code">
&lt;ListView Grid.Row="1"
          x:Name="ItemList"
          Background="LightGoldenrodYellow"&gt;
<strong class="bold">    &lt;ListView.ItemTemplate&gt;</strong>
<strong class="bold">        &lt;DataTemplate x:DataType="model:MediaItem"&gt;</strong>
<strong class="bold">            &lt;Grid&gt;</strong>
<strong class="bold">                &lt;Grid.ColumnDefinitions&gt;</strong>
<strong class="bold">                    &lt;ColumnDefinition Width="100"/&gt;</strong>
<strong class="bold">                    &lt;ColumnDefinition Width="*"/&gt;</strong>
<strong class="bold">                &lt;/Grid.ColumnDefinitions&gt;</strong>
<strong class="bold">                &lt;TextBlock Text="{x:Bind</strong>
<strong class="bold">                  Path=MediumInfo.Name}"/&gt;</strong>
<strong class="bold">                &lt;TextBlock Grid.Column="1"</strong>
<strong class="bold">                   Text="{x:Bind Path=Name}"/&gt;</strong>
<strong class="bold">            &lt;/Grid&gt;</strong>
<strong class="bold">        &lt;/DataTemplate&gt;</strong>
<strong class="bold">    &lt;/ListView.ItemTemplate&gt;</strong>
&lt;/ListView&gt;</pre>			<p>We are<a id="_idIndexMarker177"/> beginning to create some more complex <a id="_idIndexMarker178"/>XAML and need to keep formatting in mind to optimize its readability.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To quickly reformat your XAML, you can use the <em class="italic">Ctrl</em> + <em class="italic">K | D</em> keyboard shortcut. There is also an extension on the <strong class="bold">Visual Studio Marketplace</strong> called <strong class="bold">XAML Styler</strong>. You can search for it in Visual Studio’s <strong class="bold">Manage Extensions</strong> dialog or <a id="_idIndexMarker179"/>get more information on the Marketplace here: <a href="https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022">https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022</a>.</p>
			<p>To <a id="_idIndexMarker180"/>enable each <code>TextBlock</code> to bind to the properties of <code>MediaItem</code>, we must set an <code>x:DataType</code> property on the <code>DataTemplate</code>. To resolve <code>MediaItem</code>, a namespace declaration needs to be added to the <code>Window</code> definition, like this:</p>
			<pre class="source-code">
xmlns:model="using:MyMediaCollection.Model"</pre>			<p>A shortcut to add this <code>using</code> statement is to place your cursor in <code>x:DataType</code> and press <em class="italic">Ctrl</em> +. Visual Studio will suggest adding the missing namespace to the file. We now have access to objects in the <code>MyMediaCollection.Model</code> namespace by using the <code>model</code> prefix, and <code>x:DataType="model:MediaItem"</code> will resolve <code>MediaItem</code> when we build and run the app.</p>
			<p>Each <code>TextBlock</code> has its <code>Text</code> property <a id="_idIndexMarker181"/>bound to a property of <code>MediaItem</code>, using the <code>x:Bind</code> <strong class="bold">markup extension</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Using <code>x:Bind</code> instead of the <code>Binding</code> markup extension to bind data to the UI has the benefit of compile-time validation and increased performance. The previously noted data-binding overview on Microsoft Learn covers the differences in depth. I prefer to use <code>x:Bind</code> where possible. One important difference between <code>Binding</code> and <code>x:Bind</code> you should note is that while <code>Binding</code> defaults to <code>OneWay</code> mode, <code>x:Bind</code> defaults to <code>OneTime</code>. This change to the default binding behavior was made for performance considerations. <code>OneWay</code> binding requires more code behind the scenes to wire up the change detection needed for monitoring changes to the source value. You can still explicitly update your <code>x:Bind</code> usages to be <code>OneWay</code> or <code>TwoWay</code>. For more information about <code>x:Bind</code>, see this <a id="_idIndexMarker182"/>Microsoft Learn article: <a href="https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension">https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension</a>.</p>
			<p class="callout">For more information on <a id="_idIndexMarker183"/>markup extensions in XAML, you can read this .NET article:  <a href="https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview">https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview</a>.</p>
			<p>Now, when<a id="_idIndexMarker184"/> you run the application, you can see the <code>MediumType</code> name and the item name for each item in the <code>ListView</code>, as illustrated<a id="_idIndexMarker185"/> in the following screenshot:</p>
			<div><div><img src="img/B20908_02_012.jpg" alt="Figure 2.12 – The ListView with two columns of sample data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – The ListView with two columns of sample data</p>
			<p>That’s some pretty good progress! Before we expand on the functionality, let’s talk a little about how WinUI, the Windows App SDK, and .NET fit together in terms of the app development process.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Understanding WinUI and Windows App SDK</h1>
			<p>Let’s review the WinUI controls <a id="_idIndexMarker186"/>available to use in our project and see how they can help us build the <code>Microsoft.WindowsAppSDK</code> package we saw in <strong class="bold">Solution Explorer</strong> earlier in the chapter contains these controls and<a id="_idIndexMarker187"/> much more.</p>
			<p>To view the contents of this package, open the <strong class="bold">Object Browser</strong> window from Visual Studio’s <strong class="bold">View</strong> menu. The controls will be listed here under several namespaces inside the <strong class="bold">Microsoft.WinUI</strong> tree node, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B20908_02_013.jpg" alt="Figure 2.13 – WinUI controls in Object Browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – WinUI controls in Object Browser</p>
			<p>The majority of <a id="_idIndexMarker188"/>WinUI controls we will be using can be found inside the <strong class="bold">Microsoft.UI.Xaml.Controls</strong> namespace under <strong class="bold">Microsoft.WinUI</strong>, along with other related classes and interfaces.</p>
			<p>So far, we have used in our <a id="_idIndexMarker189"/>application the <code>Grid</code>, <code>TextBlock</code>, and <code>ListView</code> controls. Open the <code>ListView</code> class, expand <code>ListViewBase</code> class. This base class contains the methods, properties, and events available to the <code>ListView</code>. The members of <code>ListViewBase</code> will display in the right pane. Take some time to review these members and see whether you recognize any of them from your use of the control so far.</p>
			<p>Clear <code>ListView</code> from your search, scroll down in the left pane of <code>TextBlock</code> control. Select it and, in the right pane, find and select the <strong class="bold">Text</strong> property. The bottom-right pane <a id="_idIndexMarker190"/>displays details of the property, as illustrated in the <a id="_idIndexMarker191"/>following screenshot:</p>
			<div><div><img src="img/B20908_02_014.jpg" alt="Figure 2.14 – Details of the TextBlock.Text property in Object Browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Details of the TextBlock.Text property in Object Browser</p>
			<p>The <strong class="bold">Object Browser</strong> window can be a valuable resource when familiarizing yourself with a new library or project. All referenced projects, NuGet packages, and other references will appear here.</p>
			<p>The controls and other components you have reviewed here make up the UI layer of Windows App SDK applications. The underlying application framework for the Windows App SDK is .NET.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Understanding the .NET app model</h2>
			<p>You may have heard <a id="_idIndexMarker192"/>that the underlying app model for WinUI apps can be Win32 for C++ apps or .NET for desktop apps. So, what exactly is the <strong class="bold">.NET </strong><strong class="bold">app model</strong>?</p>
			<p>The .NET app model in WinUI apps describes how applications are packaged and deployed. It also defines the following behaviors and capabilities:</p>
			<ul>
				<li>Data storage</li>
				<li>State management</li>
				<li>Lifecycle events (<strong class="bold">Startup</strong> and <strong class="bold">Shutdown</strong>)</li>
				<li>Multitasking</li>
				<li>Resource management</li>
				<li>Inter-app communication</li>
			</ul>
			<p>WinUI 3<a id="_idIndexMarker193"/> is one component of the<a id="_idIndexMarker194"/> Windows App SDK, the UI layer. Although the WinUI controls are decoupled from the Windows SDK, the underlying .NET app platform is still dependent on it when using the Windows App SDK. Selecting a target and minimum Windows version is one of the side effects of this dependency.</p>
			<p>Now that you have a better understanding of WinUI controls and how they relate to the Windows App SDK and the .NET app platform, let’s use a few more of them in our application.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Working with WinUI controls, properties, and events</h1>
			<p>It’s time to enhance the UI of the application. Currently, the main page only consists of a <code>Media</code> label over a <code>ListView</code>, with columns for the media type and the name of the media item. The following are the enhancements we will add in this section:</p>
			<ul>
				<li>A header row for the <code>ListView</code></li>
				<li>A <code>ComboBox</code> to filter the rows based on the media type</li>
				<li>A <code>Button</code> to add a new item to the collection</li>
			</ul>
			<p>We will start by enhancing the <code>ListView</code> for our media collection.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Adding a ListView header</h2>
			<p>Before we create the<a id="_idIndexMarker195"/> header, let’s change the background color of the <code>ListView</code>. The <code>Aqua</code> color worked well to highlight the control, but it would be distracting when the application is used by our customers. We will discuss WinUI theme brushes and look at <code>Background="Aqua"</code> from the <code>ListView</code> definition in the <code>MainWindow.xaml</code> file.</p>
			<p>Creating the header row for the media collection is relatively simple. To define the rows for each item, we created a <code>ListView.ItemTemplate</code> block containing a <code>DataTemplate</code>. To create the header, we do the same inside a <code>ListView.HeaderTemplate</code> block.</p>
			<p>Just as with the item rows, the<a id="_idIndexMarker196"/> header row will consist of a <code>Grid</code> with two columns, with the same <code>Width</code> definitions. We again want to use two <code>TextBlock</code> controls inside the <code>Grid</code>, but to add some separation between the header and the items, we will add <code>Border</code> controls. Let’s look at the markup for the header and then discuss the differences in more detail. Take some time to review the following markup:</p>
			<pre class="source-code">
&lt;ListView.HeaderTemplate&gt;
    &lt;DataTemplate&gt;
        &lt;Grid&gt;
            &lt;Grid.ColumnDefinitions&gt;
                &lt;ColumnDefinition Width="100"/&gt;
                &lt;ColumnDefinition Width="*"/&gt;
            &lt;/Grid.ColumnDefinitions&gt;
            &lt;Border BorderBrush="BlueViolet"
                    BorderThickness="0,0,0,1"&gt;
                &lt;TextBlock Text="Medium"
                           Margin="5,0,0,0"
                           FontWeight="Bold"/&gt;
            &lt;/Border&gt;
            &lt;Border Grid.Column="1"
                    BorderBrush="BlueViolet"
                    BorderThickness="0,0,0,1"&gt;
                &lt;TextBlock Text="Title"
                           Margin="5,0,0,0"
                           FontWeight="Bold"/&gt;
            &lt;/Border&gt;
        &lt;/Grid&gt;
    &lt;/DataTemplate&gt;
&lt;/ListView.HeaderTemplate&gt;</pre>			<p>As you can see, each <code>TextBlock</code> is nested inside a <code>Border</code> element. This will wrap the text in a border<a id="_idIndexMarker197"/> with a <code>BlueViolet</code> color. However, by setting <code>BorderThickness="0,0,0,1"</code>, the border color will only appear on the bottom of the header row items. Here is how that appears in the application:</p>
			<div><div><img src="img/B20908_02_015.jpg" alt="Figure 2.15 – The ListView with a header row added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – The ListView with a header row added</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The same bottom border could be achieved by nesting the entire <code>Grid</code> inside a <code>Border</code> instead of putting one around each header item. However, by doing it this way, we have more control over the appearance of each column’s border style. When we implement sorting later, the border’s color can be modified to highlight the column on which sorting has been applied.</p>
			<p>You probably<a id="_idIndexMarker198"/> also noticed that the header row text stands out from the rows in the grid. The <code>FontWeight="Bold"</code> property set inside each <code>TextBlock</code> in the <code>HeaderTemplate</code> helps to highlight the header row.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>Creating the ComboBox filter</h2>
			<p>One of the requirements for the <a id="_idIndexMarker199"/>application is to allow users to filter several of the collection items’ properties. Let’s start simple, by adding a filter only on the medium (<strong class="bold">Book</strong>, <strong class="bold">Music</strong>, or <strong class="bold">Movie</strong>). The list also needs an <strong class="bold">All</strong> option, which will be the default selection when users open the application:</p>
			<ol>
				<li>First, add some XAML to <code>MainWindow</code> to add a filter to the right of the <code>Media</code> label. Replace <code>Media</code> <code>TextBlock</code> with the following markup:<pre class="source-code">
&lt;Grid&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="*"/&gt;
        &lt;ColumnDefinition Width="Auto"/&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;TextBlock Text="Media Collection"
               Margin="4"
               FontWeight="Bold"
               VerticalAlignment="Center"/&gt;
    &lt;StackPanel Grid.Column="1"
                Orientation="Horizontal"
                HorizontalAlignment="Right"&gt;
        &lt;TextBlock Text="Media Type:" Margin="4"
                   FontWeight="Bold"
                   VerticalAlignment="Center"/&gt;
        &lt;ComboBox x:Name="ItemFilter"
                  MinWidth="120" Margin="0,2,6,4"/&gt;
    &lt;/StackPanel&gt;
&lt;/Grid&gt;</pre><p class="list-inset">The single <code>TextBlock</code> label has been replaced with a two-column <code>Grid</code>. The first column contains the <code>TextBlock</code>, with a few modifications. First, the <code>Text</code> property has been updated to <code>"Media Collection"</code>. <code>FontWeight</code> has been changed to <code>"Bold"</code> and some margin has been added. Finally, the element is vertically centered.</p><p class="list-inset">The second column contains a new <code>StackPanel</code> (a container control that stacks its contents horizontally or vertically). The default orientation is <code>Vertical</code>. In our case, we want a horizontal stack, which is why the <code>Orientation</code> property has been set.</p></li>			</ol>
			<p><code>StackPanel</code> contains a <code>TextBlock</code> label and a <code>ComboBox</code> for the filter selection. The <code>ComboBox</code> filter has been given an <code>x:Name</code> so we can reference it from the C# code-behind file when initializing its contents. We have also configured a <code>MinWidth</code> value of <code>120</code>. If the contents of the <code>ComboBox</code> filter require more than 120 <strong class="bold">pixels</strong> (<strong class="bold">px</strong>), it can grow larger, but<a id="_idIndexMarker200"/> its width cannot be less than the value set here.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The pixels being referenced in XAML are effective pixels. To read more about responsive layouts and sizing with XAML, see this <a id="_idIndexMarker201"/>Microsoft Learn article: <a href="https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml">https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml</a>.</p>
			<ol>
				<li>In the <code>MainWindow.xaml.cs</code> file, add a new variable to hold the list of mediums, as follows:<pre class="source-code">
private IList&lt;string&gt; _mediums { get; set; }</pre><p class="list-inset">This collection can be an <code>IList</code> rather than <code>ObservableCollection</code> because we don’t expect its contents to change while the application is running.</p></li>				<li>Inside the <code>PopulateData()</code> method, add some code at the end of the method to populate the <code>_mediums</code> list, as follows:<pre class="source-code">
_mediums = new List&lt;string&gt;
{
    "All",
    nameof(ItemType.Book),
    nameof(ItemType.Music),
    nameof(ItemType.Video)
};</pre><p class="list-inset">We’re adding an item to the collection for each of the possible values in our <code>ItemType</code> enum, plus the default <code>"</code><code>All"</code> value.</p></li>				<li>The <code>ComboBox</code> filter will be bound to the collection after it has loaded, so add a <code>Loaded</code> event handler in the <code>MainWindow</code> constructor, as we did for the <code>ItemList</code> earlier, like this:<pre class="source-code">
ItemFilter.Loaded += ItemFilter_Loaded;</pre></li>				<li>The <code>ItemFilter_Loaded</code> event handler will look much like the <code>ItemList_Loaded</code> handler. Use <a id="_idIndexMarker202"/>the following code:<pre class="source-code">
private void ItemFilter_Loaded(object sender,
  Microsoft.UI.Xaml.RoutedEventArgs e)
{
    var filterCombo = (ComboBox)sender;
    PopulateData();
    filterCombo.ItemsSource = _mediums;
    filterCombo.SelectedIndex = 0;
}</pre></li>			</ol>
			<p>The code casts the sender to the <code>ComboBox</code> data type and sets its <code>ItemSource</code> to the list we populated in the previous step. Finally, an additional step is needed to default the <code>ComboBox</code> filter to default to the <code>"All"</code> item. This is accomplished by setting <code>SelectedIndex</code> equal to <code>0</code>.</p>
			<p>Let’s run the <a id="_idIndexMarker203"/>application and see how it looks now. You can see the result in the following screenshot:</p>
			<div><div><img src="img/B20908_02_016.jpg" alt="Figure 2.16 – Media Collection with the Media Type filter added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Media Collection with the Media Type filter added</p>
			<p>Pretty sharp! If you click the <strong class="bold">Media Type</strong> filter, you can see the four values available for selection, as illustrated here:</p>
			<div><div><img src="img/B20908_02_017.jpg" alt="Figure 2.17 – Media Type values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Media Type values</p>
			<p>Notice how the dropdown of <code>ComboBox</code> has picked up the Windows style with some transparency without having to add any additional code or markup. Select one of the other values in the list and see what happens. Nothing! That’s because we haven’t added any code<a id="_idIndexMarker204"/> to do the filtering when the selection changes on the filter. We can add a little bit of extra code to fix that, as follows:</p>
			<ol>
				<li>First, create a new <code>_allItems</code> collection to store a list of all available media items, regardless of the current filter, like this:<pre class="source-code">
private IList&lt;MediaItem&gt; _allItems { get; set; }</pre></li>				<li>Next, in the <code>PopulateData()</code> method, after populating the <code>_items</code> collection, add the same items to <code>_allItems</code>, like this:<pre class="source-code">
_allItems = new List&lt;MediaItem&gt;
{
    cd,
    book,
    bluRay
};</pre></li>				<li>Now, we need to do some filtering when the filter selection changes. We want to handle the <code>SelectionChanged</code> event on the <code>ComboBox</code> control, but we don’t want to hook it up until after the entire page has loaded. This will prevent the event from being handled while the <code>ComboBox</code> filter is initially being populated.</li>
				<li>At the end of the implementation of <code>ItemFilter_Loaded</code>, add an event handler for the <code>SelectionChanged</code> event on the <code>ComboBox</code> control:<pre class="source-code">
ItemFilter.SelectionChanged +=
    ItemFilter_SelectionChanged;</pre></li>				<li>In the new <code>ItemFilter_SelectionChanged</code> event handler, we will iterate through the <code>_allItems</code> list and determine which of the items to include in the filtered list, based on their <code>MediaType</code> property, as follows:<pre class="source-code">
private void ItemFilter_SelectionChanged(
  object sender,Microsoft.UI.Xaml.Controls.
    SelectionChangedEventArgs e)
{
        var updatedItems =
          (from item in _allItems
          where
            string.IsNullOrWhiteSpace(ItemFilter.
              SelectedValue.ToString()) ||
            ItemFilter.SelectedValue.ToString() ==
              "All" ||
            ItemFilter.SelectedValue.ToString() ==
              item.MediaType.ToString()
          select item).ToList();
       ItemList.ItemsSource = updatedItems;
}</pre></li>			</ol>
			<p>If the filter value is <a id="_idIndexMarker205"/>empty or <code>MediaType</code>. Otherwise, we check whether the <code>MediaType</code> matches the selection in <code>ItemFilter</code> <code>ComboBox</code>. When there is a match, we add it to the <code>updatedItems</code> list. Then, we set <code>updatedItems</code> as <code>ItemsSource</code> on the <code>ListView</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A filter should never be empty unless there is an error while initializing the data. This condition is only a safeguard for unforeseen scenarios.</p>
			<p>Now, run the app again and select <strong class="bold">Book</strong> in the filter, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B20908_02_018.jpg" alt="Figure 2.18 – Media Collection filtered to display only books"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Media Collection filtered to display only books</p>
			<p>That <a id="_idIndexMarker206"/>takes care of the filter implementation for the time being. Let’s finish up this part of the UI design with a <code>Button</code>.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Adding a new item button</h2>
			<p>We are not quite ready to<a id="_idIndexMarker207"/> start working with multiple windows or navigation yet. You should have some understanding of the <code>Button</code> to the current page and add some code to ensure everything is hooked up correctly.</p>
			<p>Open the <code>MainWindow.xaml</code> file and add a third <code>RowDefinition</code> to the top-level <code>Grid</code> on the <code>Window</code>, as follows:</p>
			<pre class="source-code">
&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    &lt;RowDefinition Height="*"/&gt;
<strong class="bold">    </strong><strong class="bold">&lt;RowDefinition Height="Auto"/&gt;</strong>
&lt;/Grid.RowDefinitions&gt;</pre>			<p>The new row will have a height of <code>Auto</code> so that it sizes itself to fit the <code>Button</code>. We still want the <code>ListView</code> to take up most of the screen.</p>
			<p>Now, after the closing tag of the <code>ListView</code> control, add the new <code>Button</code>, as follows:</p>
			<pre class="source-code">
&lt;Button x:Name="AddButton" Content="Add Item"
  HorizontalAlignment="Right" Grid.Row="2" Margin="8"/&gt;</pre>			<p>As discussed in the previous<a id="_idIndexMarker208"/> chapter, the <code>Button</code> control does not have a <code>Text</code> property. Instead, if you only want a <code>Button</code> control to contain text, you assign it to the <code>Content</code> property. We are also assigning the <code>Button</code> control to the third row of the <code>Grid</code>, setting the margin, and aligning it to the right side of the <code>Grid</code>.</p>
			<p>Let’s see how the app looks now, as follows:</p>
			<div><div><img src="img/B20908_02_019.jpg" alt="Figure 2.19 – My Media Collection with an Add Item button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – My Media Collection with an Add Item button</p>
			<p>The button doesn’t do anything yet. Because we’re not yet ready to add an additional window to the application to add items, let’s open a message popup to inform the user that this function is not available.</p>
			<p>In <code>MainWindow.xaml</code>, wire up a new event handler inside <code>AddButton</code>. You can also remove the <code>x:Name</code> attribute. We’re able to remove the name because we do not need to reference it in the code-behind file. The code is shown in the following snippet:</p>
			<pre class="source-code">
&lt;Button Content="Add Item"
   HorizontalAlignment="Right"
     Grid.Row="2" Margin="8" Click="AddButton_Click"/&gt;</pre>			<p>You can create the event <a id="_idIndexMarker209"/>handler by placing the cursor on the name of the handler, <code>AddButton_Click</code>, and pressing <em class="italic">F12</em>. This will create the handler and navigate to it in the <code>MainWindow.xaml.cs</code> file. Inside the <code>AddButton_Click</code> event handler, we will create a new <code>ContentDialog</code> with the message we want to display to the user.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The call to <code>dialog.ShowAsync()</code> must be awaited, so remember to add the <code>async</code> directive to the event handler, as shown next.</p>
			<p>The <code>async</code> directive is highlighted in the following code snippet for the new event handler:</p>
			<pre class="source-code">
private <strong class="bold">async</strong> void AddButton_Click(object sender,
  RoutedEventArgs e)
{
    var dialog = new ContentDialog
        {
            Title = "My Media Collection",
            Content = "Adding items to the collection is
                not yet supported.",
            CloseButtonText = "OK",
            XamlRoot = Content.XamlRoot
        };
    await dialog.ShowAsync();
}</pre>			<p>Now, run the application <a id="_idIndexMarker210"/>again and click the <strong class="bold">Add Item</strong> button, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B20908_02_020.jpg" alt="Figure 2.20 – Displaying a ContentDialog popup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Displaying a ContentDialog popup</p>
			<p>That’s all there is to adding a functional <code>Button</code> to a WinUI page. As we have discussed, some of this code will change and be moved to a <code>ViewModel</code> in the next chapter, but you should now have a good idea of how to work with some basic <code>Button</code> properties and events.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Summary</h1>
			<p>We have made some great initial progress on the <strong class="bold">My Media Collection</strong> application in this chapter. Along the way, you have learned how to use several common WinUI controls. You have also learned how to change the appearance, layout, and behavior of WinUI controls by using different layout controls and updating control properties in XAML. Finally, you saw how to leverage data binding and events to add and update data displayed to the user.</p>
			<p>Next, we will learn how to decouple some of the logic we have been writing in the code-behind files to build testable and maintainable applications.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Questions</h1>
			<ol>
				<li>How do you add or remove features to or from Visual Studio?</li>
				<li>What is the lowest minimum version of Windows that must be targeted when creating a new WinUI 3 project?</li>
				<li>Where can you add XAML resources that can be shared by components in a whole application?</li>
				<li>What is the default name of the first window loaded in a new WinUI app?</li>
				<li>Which XAML container control allows you to define rows and columns to lay out its contents?</li>
				<li>Which XAML container control stacks its contents horizontally or vertically?</li>
				<li>What is the name of the message box that WinUI apps can use to display simple messages to users?</li>
				<li>Challenge: What type of layout panel in WinUI allows its contents to be positioned absolutely?</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	</body></html>