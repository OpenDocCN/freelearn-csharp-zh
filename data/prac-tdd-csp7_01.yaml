- en: Why TDD is Important
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么TDD很重要
- en: You've picked up this book because you want to learn more about **Test-Driven
    Development** (**TDD**). Maybe you've heard the term before. Perhaps you've known
    software developers who write unit tests and want to learn more. We'll introduce
    you to the terms, the structure, and the ideology around TDD. By the end of this
    book, you'll have sufficient knowledge to re-enter the world as a Test-Driven
    Developer and feel confident about using your skills throughout your long and
    prosperous career.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择这本书是因为你想了解更多关于**测试驱动开发（TDD**）的知识。也许你之前听说过这个术语。也许你认识编写单元测试的软件开发者，并想了解更多。我们将向你介绍TDD相关的术语、结构和理念。到这本书的结尾，你将拥有足够的知识重新进入这个世界，作为一个测试驱动开发者，并在你漫长而繁荣的职业生涯中自信地使用你的技能。
- en: Why this book? Certainly, there are many other books on the topic of TDD. We
    have written this book with the hope that it provides you, the reader, with low-level
    insight into the mindset we use when doing TDD. We also hope that this book provides
    an updated view of some of the concepts and lessons we have learned while doing
    TDD over the last 10 years.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这本书？当然，关于TDD主题的书籍有很多。我们写这本书的目的是希望它能为你，读者，提供关于我们在进行TDD时所使用的思维方式的深入了解。我们也希望这本书能提供一些关于我们在过去10年进行TDD时所学到的一些概念和教训的更新观点。
- en: So, why is TDD so important? As more businesses and industries rely on software
    solutions, it's increasingly important that those solutions be robust and error-free.
    The cheaper and more consistent, they are the better. Applications developed with
    TDD in mind are inherently more testable, easier to maintain, and demonstrate
    a certain level of correctness not easily achieved otherwise.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么TDD如此重要？随着越来越多的企业和行业依赖软件解决方案，确保这些解决方案稳健且无错误变得越来越重要。它们越便宜、越一致，就越好。以TDD为目标的开发的应用程序本质上更容易测试、更容易维护，并显示出在其他情况下难以达到的某种正确性水平。
- en: 'In this chapter, we will gain an understanding of:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解以下内容：
- en: Defining TDD and exploring the basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义TDD并探索基础知识
- en: Creating our first tests in C# and JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#和JavaScript中创建我们的第一个测试
- en: Exploring the basic steps of Red, Green, Refactor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索红、绿、重构的基本步骤
- en: Growing complexity through tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测试增长复杂性
- en: First, a little background
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先，一些背景信息
- en: It's possible that you've had some exposure to unit tests in your career. It's
    highly likely that you've written a test or two. Many developers, unfortunately,
    haven't had the opportunity to experience the joys of Test-Driven Development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的职业生涯中，你可能已经接触过单元测试。你很可能已经编写过一个或两个测试。不幸的是，许多开发者还没有机会体验到测试驱动开发（Test-Driven
    Development）的乐趣。
- en: John's story on TDD
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约翰关于测试驱动开发（TDD）的故事
- en: I was first introduced to TDD about five years ago. I was interviewing for a
    lead developer position for a small startup. During the interview process, the
    CTO mentioned that the development team was practicing TDD. I informed him that
    I didn't have any practical TDD experience, but that I was sure I could adapt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触TDD是在大约五年前。我正在面试一个小型初创公司的首席开发者职位。在面试过程中，CTO提到开发团队正在实践TDD。我告诉他我没有实际的TDD经验，但我确信我可以适应。
- en: In all honesty, I was bit nervous. Up to that point, I had never even written
    a single unit test! What had I gotten myself into? An offer was extended and I
    accepted. Once I joined the small company I was told that, while TDD was the goal,
    they weren't quite there yet. Phew; crisis averted. However, I was still intrigued.
    It wasn't until a few months later that the team delved into the world of TDD,
    and the rest, as they say, is history.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实话实说，我有点紧张。到那时，我甚至从未写过单个单元测试！我把自己带进了什么境地？一个提议被提出，我接受了。一旦我加入了这家小公司，我就被告知，虽然TDD是目标，但他们还没有完全达到。谢天谢地；危机解除。然而，我仍然很感兴趣。直到几个月后，团队才深入TDD的世界，正如人们所说，其余的就是历史了。
- en: Clayton's story on TDD
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克莱顿关于TDD的故事
- en: My introduction to TDD is a little different from John's. I have been writing
    code since I was in middle school in the early 1990s. From then until 2010, I
    always struggled with writing applications that didn't require serious architectural
    changes when new requirements were introduced. In 2010, I finally got fed up with
    the constant rewrites and began researching tools and techniques to help me with
    my problem. I quickly found TekPub, an e-learning site that was, at the time,
    owned and operated by Rob Conery. Through TekPub I began learning the SOLID principles
    and TDD. After banging my head against the wall for close to six months, I started
    to grasp what TDD was and how I could use those principles. Coupled with the SOLID
    principles, TDD helped me to write easy to understand code that was flexible enough
    to stand up to any requirements the business could throw at me. I eventually ended
    up at the same company where John was employed and worked with him and, as he
    said, the rest is history.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我对TDD的介绍与约翰的不同。我在20世纪90年代初上初中时就开始写代码了。从那时起直到2010年，我总是挣扎于在引入新需求时编写不需要进行重大架构更改的应用程序。2010年，我终于厌倦了不断的重写，并开始研究工具和技术来帮助我解决这个问题。我很快发现了TekPub，这是一个当时由Rob
    Conery拥有和运营的在线学习网站。通过TekPub我开始学习SOLID原则和TDD。在几乎六个月的时间里不断碰壁后，我开始理解TDD是什么以及如何使用这些原则。结合SOLID原则，TDD帮助我编写易于理解的代码，这些代码足够灵活，可以应对业务可能提出的任何需求。我最终来到了约翰工作的同一家公司，与他一起工作，正如他所说，其余的就是历史了。
- en: The SOLID principles, which will be explained in detail later, are guiding principles
    that help produce clean, maintainable, and flexible code. They help reduce rigidity,
    fragility, and complexity. Generally thought of as object-oriented principles,
    I have found them to be applicable in all coding paradigms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则（稍后将会详细解释），是帮助产生干净、可维护和灵活代码的指导原则。它们有助于减少僵化、脆弱和复杂性。通常被认为是面向对象的原则，我发现它们适用于所有编程范式。
- en: So, what is TDD?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，TDD究竟是什么呢？
- en: Searching online, you will certainly find that TDD is an acronym for Test-Driven
    Development. In fact, the title of this book will tell you that. We, however,
    use a slightly more meaningful definition. So, what *is* TDD? In the simplest
    terms, TDD is an approach to software development that is intended to reduce errors
    and enable flexibility within the application. If done correctly, TDD is a building
    block for rapid, accurate, and fearless application development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索，你肯定会发现TDD是Test-Driven Development的缩写。事实上，这本书的标题也会告诉你这一点。然而，我们使用一个稍微更有意义的定义。那么，TDD究竟是什么呢？用最简单的话说，TDD是一种软件开发方法，旨在减少错误并使应用程序内部具有灵活性。如果做得正确，TDD是快速、准确和无所畏惧的应用程序开发的基石。
- en: Test-Driven Development is a means of letting your tests drive the design of
    the system. What does that mean, exactly? It means that you mustn't start with
    a solution in mind, you must let your tests drive the code being written. This
    helps minimize needless complexity and avoid over-architected solutions. The rules
    of Test-Driven Development
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种让测试驱动系统设计的方法。这究竟意味着什么呢？这意味着你不能带着解决方案开始，你必须让测试驱动正在编写的代码。这有助于最小化不必要的复杂性，并避免过度架构的解决方案。测试驱动开发的规则
- en: Staunch proponents of TDD dictate that you may not write a single line of production
    code without writing a failing unit test, and failing to compile is a failure.
    This means that you write a simple test, watch it fail, then write some code to
    make it pass. The system slowly evolves as the tests and the production application
    grow in functionality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的坚定支持者规定，在没有编写一个失败的单元测试的情况下，你甚至不能写一行生产代码，编译失败也是一种失败。这意味着你先写一个简单的测试，然后观察它失败，接着编写一些代码让它通过。随着测试和生产应用功能的增长，系统会逐渐演变。
- en: TDD is not about testing, it's about design.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TDD不是关于测试的，它是关于设计的。
- en: Many would argue that TDD is about testing, and by extension, about test coverage
    of an application. While these are great side-effects of TDD, they are not the
    driving force behind the practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人会争论说，TDD是关于测试的，进而也是关于应用程序的测试覆盖率。虽然这些都是TDD的绝佳副作用，但它们并不是实践背后的驱动力。
- en: Additionally, if code coverage and metrics become the goal, then there is a
    risk that developers will introduce meaningless tests just to inflate the numbers.
    Perhaps it is less a risk and more a guarantee that this will happen. Let delivered
    functionality and happy customers be the metrics with which you measure success.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果代码覆盖率和指标成为目标，那么开发者可能会引入无意义的测试，只是为了增加数字。也许这与其说是一个风险，不如说是一个保证会发生的事情。让交付的功能和满意的客户成为衡量成功的指标。
- en: TDD is about design. Through TDD, an application will grow in functionality
    without introducing needless complexity. It's incredibly difficult to introduce
    complexity if you write small tests and only enough production code to make the
    test pass. Refactoring, modifying the structure of the code without adding or
    changing behavior, should not introduce complexity, either.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是关于设计的。通过 TDD，应用程序的功能将增长，而不会引入不必要的复杂性。如果你只编写小的测试和足够的生产代码来使测试通过，那么引入复杂性是非常困难的。重构，即在不添加或更改行为的情况下修改代码结构，也不应该引入复杂性。
- en: An approach to TDD
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种 TDD 方法
- en: 'TDD is also referred to as Test First Development. In both names, the key aspect
    is that the test must be written before the application code. Robert C. Martin,
    affectionately called "Uncle Bob" by the developer community, has created *The
    Three Laws of TDD*. They are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 也被称为测试优先开发。在两个名称中，关键方面是测试必须在应用程序代码之前编写。被开发社区亲切地称为“Uncle Bob”的 Robert C.
    Martin 创建了 *TDD 的三条法则*。它们如下：
- en: You are not allowed to write any production code unless it is to make a failing
    unit test pass
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非是为了使失败的单元测试通过，否则不允许编写任何生产代码
- en: You are not allowed to write any more of a unit test than is sufficient to fail,
    and compilation failures are failures
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不允许编写比足够使失败的单元测试失败更多的单元测试，编译失败也是失败。
- en: You are not allowed to write any more production code than is sufficient to
    pass the one failing unit test
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不允许编写比足够通过一个失败的单元测试更多的生产代码。
- en: You can learn more about these laws at [http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd)
    上了解更多关于这些法则的信息。
- en: By following these rules, you will ensure that you have a very tight feedback
    loop between your test code and your production code. One of the main components
    of Agile software development is working to reduce the feedback cycle. A small
    feedback cycle allows the project to make a course correction at the first sign
    of trouble. The same applies to the testing feedback cycle. The smaller you can
    make your tests, the better the end result will be.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些规则，你将确保你的测试代码和生产代码之间有一个非常紧密的反馈循环。敏捷软件开发的主要组成部分之一是努力减少反馈周期。反馈周期越小，项目在出现问题的第一个迹象时就能进行纠正。同样，这也适用于测试反馈周期。你的测试越小，最终结果就越好。
- en: For a video on Agile, check out *Getting Started with Agile* by Martin Esposito
    and Massimo Fascinari ([https://www.packtpub.com/application-development/getting-started-agile-video](https://www.packtpub.com/application-development/getting-started-agile-video)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解敏捷的视频，可以查看 Martin Esposito 和 Massimo Fascinari 的 *Getting Started with Agile*（[https://www.packtpub.com/application-development/getting-started-agile-video](https://www.packtpub.com/application-development/getting-started-agile-video)）。
- en: An alternative approach
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种替代方法
- en: The original approach to TDD has caused some confusion over the years. The problem
    is that the principles and approaches just weren't structured enough. In 2006,
    Dan North wrote an article in Better Software magazine ([https://www.stickyminds.com/better-software-magazine/behavior-modification](https://www.stickyminds.com/better-software-magazine/behavior-modification)).
    The purpose of the article was to clear up some of this confusion and help to
    reduce the pitfalls that developers fell into while learning the TDD process.
    This new approach to TDD is called **Behavior Driven Development** (**BDD**).
    BDD provides a structure for testing, and a means of communicating between business
    requirements and unit tests, that is almost seamless.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的原始方法在多年以来引起了一些混淆。问题在于原则和方法的结构性不够。2006 年，Dan North 在《Better Software》杂志上发表了一篇文章（[https://www.stickyminds.com/better-software-magazine/behavior-modification](https://www.stickyminds.com/better-software-magazine/behavior-modification)）。这篇文章的目的是消除一些混淆，并帮助减少开发者在学习
    TDD 流程时遇到的陷阱。这种新的 TDD 方法被称为 **行为驱动开发**（**BDD**）。BDD 为测试提供了一个结构，以及业务需求和单元测试之间沟通的一种几乎无缝的方式。
- en: The process
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程
- en: It's difficult to start any journey without a goal in mind. There are a few
    tips and tricks that can be used to help get you started in TDD. The first is
    *red*, *green*, *refactor*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有目标开始任何旅程都是困难的。有一些技巧和窍门可以帮助你开始TDD。首先是“红色”，“绿色”，“重构”。
- en: Red, green, and refactor
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红色，绿色，重构
- en: We already discussed writing a failing test before writing production code.
    The goal is to build the system slowly through a series of tiny improvements.
    This is often referred to as *red*, *green*, *refactor*. We write a small test
    (red), then we make it pass by writing some production code (green), then we refactor
    our code (refactor) before we start the process again.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在编写生产代码之前编写失败的测试。目标是通过对一系列微小改进的逐步构建系统。这通常被称为“红色”，“绿色”，“重构”。我们编写一个小测试（红色），然后通过编写一些生产代码使其通过（绿色），然后在我们再次开始之前重构我们的代码（重构）。
- en: Many TDD practitioners advocate an *It Exists* test first. This will help determine
    that your environment is set up properly and you won't receive false positives.
    If you write an *It Exists* test and don't receive a failure right off the bat,
    you know something is wrong. Once you receive your first failure, you're safe
    to create the class, method, or function under test. This will also ensure that
    you don't dive in too deeply right off the bat with lines and lines of code before
    you're sure your system is working properly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 许多TDD实践者提倡先进行“存在性”测试。这将有助于确定你的环境设置是否正确，你不会收到错误的阳性结果。如果你编写了一个“存在性”测试并且一开始没有失败，你就知道有问题。一旦你收到第一个失败，你就可以安全地创建正在测试的类、方法或函数。这也会确保你在确定系统正常工作之前，不会一头扎进代码中，写下一行又一行的代码。
- en: Once you have your first failure and the first working example, it's time to
    grow the application, slowly. Choose the next most interesting step and write
    a failing test to cover this step.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了第一个失败和第一个工作示例，就是时候缓慢地扩展应用程序了。选择下一个最有趣的步骤，并编写一个失败的测试来覆盖这一步骤。
- en: At each iteration, you should pause and evaluate whether there is any cleanup
    that can happen. Can you simplify a code block? Perhaps a more descriptive variable
    name is in order? Can any sins committed in the code be corrected, safely, at
    this time? It's important that you evaluate both the production code and the test
    suite. Both should be clean, accurate, and maintainable. After all, if it's such
    a mess that no one would be able to make head or tail of it, what good is the
    code?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，你应该暂停并评估是否可以进行任何清理工作。你能简化代码块吗？或许需要一个更具描述性的变量名？是否可以在此时安全地纠正代码中的错误？评估生产代码和测试套件都很重要。两者都应该是干净、准确且可维护的。毕竟，如果代码如此混乱，以至于没有人能够理解，那么代码还有什么价值？
- en: Coder's block
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序员阻塞
- en: TDD will also help you avoid what writers often call *writer's block* and what
    we're calling *coder's block*. Coder's block happens when you sit down at the
    keyboard in an attempt to solve a problem but don't know where to begin. We begin
    at the beginning. Write the easiest, simplest test you can imagine. Write *It
    Exists*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TDD也会帮助你避免作家们常说的“作家阻塞”和我们所称的“程序员阻塞”。程序员阻塞发生在你坐在键盘前试图解决问题，但不知道从何开始的时候。我们从开始的地方开始。写下你能想象的最简单、最简单的测试。写“存在性”。
- en: Why should we care?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么要关心？
- en: We're professionals. We want to do a good job. We feel bad if someone finds
    fault with our code. If QA finds a bug, it makes us sad. If a user of our system
    encounters an error, we may cry. We should strive to deliver quality, error-free
    code and a fully functional, feature-rich application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是专业人士。我们希望做好工作。如果有人发现我们的代码有问题，我们会感到难过。如果QA发现了一个错误，我们会感到悲伤。如果我们的系统用户遇到了错误，我们可能会哭泣。我们应该努力交付高质量的、无错误的代码和一个功能齐全、特性丰富的应用程序。
- en: We're also lazy, but it's the good kind of lazy. We don't want to have to run
    the entire application just to validate that a simple function returns the proper
    value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也很懒惰，但这是好懒惰。我们不想不得不运行整个应用程序来验证一个简单的函数是否返回正确的值。
- en: Arguments against TDD
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的反对意见
- en: There are arguments against TDD, some valid and some not. It's quite possible
    that you've heard some of them before, and likely that you've repeated some of
    these yourself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对TDD的反对意见，有些是合理的，有些则不然。很可能你已经听说过一些，而且很可能你自己也重复过其中的一些。
- en: Testing takes time
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试需要时间
- en: Of course, testing takes time. Writing unit tests takes time. Adhering to the
    *red, green, refactor* cycle of TDD does take time. But, how else do you check
    your work if not through tests?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测试需要时间。编写单元测试需要时间。遵循TDD的 *红、绿、重构* 循环确实需要时间。但是，如果不通过测试，你还能如何检查你的工作呢？
- en: Do you validate that the code you wrote works? How do you do this without tests?
    Do you manually run the application? How long does that take? Are there conditional
    scenarios that you need to account for within the application? Do you have to
    set up those scenarios while manually testing the application? Do you skip some
    and just *trust that they work*?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你验证了你编写的代码是否工作吗？没有测试你怎么做这件事？你是手动运行应用程序吗？这需要多长时间？在应用程序中有没有需要考虑的条件场景？你需要在手动测试应用程序时设置这些场景吗？你会跳过一些并只是
    *相信它们会工作* 吗？
- en: What about regression testing? What if you make a change a day, a week, or a
    month later? Do you have to manually regression-test the entire application? What
    if someone else makes a change? Do you trust that they were also as thorough in
    their testing, *as I’m sure you are*?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于回归测试呢？如果你在一天、一周或一个月后进行更改怎么办？你是否必须手动回归测试整个应用程序？如果其他人进行了更改呢？你会信任他们像你一样彻底地进行测试，*我相信你会的*？
- en: How much time would you save if your code were covered by a test suite that
    you could run at the click of a button?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码被一个你可以点击按钮运行的测试套件所覆盖，你会节省多少时间？
- en: Testing is expensive
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试是昂贵的
- en: By writing tests, you're effectively doubling the amount of code you're writing,
    right? Well, yes and no. Okay, in an extreme case, you might approach double the
    code. Again, *in an extreme case*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写测试，你实际上是在增加你正在编写的代码量，对吧？好吧，是的，也不是。好吧，在极端情况下，你可能会接近双倍代码。再次强调，*在极端情况下*。
- en: Don't make tests a line item.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不要把测试作为一项单独的条款。
- en: In some instances, consulting companies have written unit tests into a contract
    with a line item and dollar amount attached. Inevitably, this allows the customer
    the chance to argue to have this line item removed, thus saving them money. This
    is absolutely the wrong approach. Testing will be done, period, whether manually
    by the developer running the application to validate her work, by a QA tester,
    or by an automated suite of tests. Testing is not a line item that can be negotiated
    or removed (yikes!).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，咨询公司已经将单元测试写入合同中，并附有条款和金额。不可避免的是，这给了客户机会争论删除这一条款，从而节省他们的钱。这是绝对错误的方法。测试将会进行，这是肯定的，无论是手动由开发者运行应用程序来验证其工作，还是由QA测试人员，或者由自动化测试套件。测试不是一个可以协商或删除的条款（哎呀！）。
- en: You would never buy an automobile that didn’t pass quality control. Light bulbs
    must pass inspection. A client, customer, or company will never, ever, save money
    by foregoing testing. The question becomes, do you write the tests early, while
    the code is being authored, or manually, at a later date?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不会购买一个没有通过质量控制检验的汽车。灯泡必须通过检验。客户、客户或公司永远不会通过放弃测试来节省钱。问题变成了，你是早期在编写代码时编写测试，还是稍后手动编写？
- en: Testing is difficult
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试是困难的
- en: Testing can be difficult. This is especially true with an application that was
    not written with testability in mind. If you have static methods and implementations
    using concrete references scattered throughout your code, you will have difficulty
    adding tests at a later date.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能是困难的。这尤其适用于没有考虑到可测试性的应用程序。如果你在代码中使用了静态方法和散布着具体引用的实现，你将在以后添加测试时遇到困难。
- en: We don't know how
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们不知道怎么做
- en: '*I don''t know how to test* is really the only acceptable answer, assuming
    it is quickly followed by, *but I''m willing to learn*. We''re developers. We''re
    the experts in the room. We''re paid to know the answers. It''s scary to admit
    that we don''t know something. It''s even scarier to start something new. Rest
    assured, it will be OK. Once you get the hang of TDD, you’ll wonder how you managed
    before. You''ll refer to those times as *the dark ages, before the discovery of
    the wheel*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不知道怎么测试* 真的是唯一可以接受的回答，前提是它很快就被 *但我愿意学习* 所跟随。我们是开发者。我们是房间里专家。我们被付钱来知道答案。承认自己不知道某事是可怕的。开始新事物更是如此。请放心，一切都会好起来的。一旦你掌握了TDD，你会
    wonder 你以前是怎么做到的。你会把那些时光称为 *黑暗时代，在轮子的发现之前*。'
- en: Arguments in favor of TDD
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的支持性论点
- en: What we would like to focus on here are the positives, the arguments in favor
    of TDD.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想关注的是积极的方面，是支持TDD的论点。
- en: Reduces the effort of manual testing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少了手动测试的劳动强度
- en: We already mentioned that we, as professionals, will not ship anything without
    first determining that it works. Throwing something over the wall to QA, to our
    users, or to the general public and hoping that it all works as expected just
    isn't how we do business. We will verify that our code and our applications work
    as expected. In the beginning, while the application is small and has little functionality,
    we can manually test everything we can think of. But, as the application grows
    in size and complexity, it just isn't feasible for developers or anyone else to
    manually test an entire application. It’s too time-consuming and costly to do
    this manually. We can save ourselves time and our clients and companies money
    by automating our testing. We can do so quite easily, from the beginning, through
    TDD.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，作为专业人士，我们不会在没有首先确定它是否工作的情况下发布任何东西。把东西扔给质量保证团队、用户或公众，并希望一切按预期工作，这并不是我们的业务方式。我们将验证我们的代码和应用程序是否按预期工作。在开始时，当应用程序规模小且功能有限时，我们可以手动测试我们能想到的一切。但是，随着应用程序规模和复杂性的增长，开发者或其他人手动测试整个应用程序是不切实际的。手动做这件事既耗时又昂贵。我们可以通过自动化测试来节省时间和我们的客户以及公司的金钱。我们可以从开始就通过TDD轻松地做到这一点。
- en: Reduces bug count
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少错误数量
- en: 'As our application grows, so do our tests. Or shall we say, our test suite
    has grown, and by making our tests pass, our application has grown. As both have
    grown, we''ve covered the happy path (for example: 2 + 2 = 4) as well as potential
    failures (for example: 2 + banana = exception). If the method or function under
    test can accept an input parameter, there is a potential for failure. You can
    reduce the potential for unexpected behavior, bugs, and exceptions by writing
    code to guard against these scenarios. As you write tests to express potential
    failures, your production code will inherently become more robust and less prone
    to errors. If a bug does slip by and make it to QA, or even to a production environment,
    then it''s easy enough to add a new test to cover the newly discovered defect.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序增长，我们的测试也在增长。或者说，我们的测试套件已经增长，通过使我们的测试通过，我们的应用程序也在增长。随着两者的增长，我们已经覆盖了快乐路径（例如：2
    + 2 = 4）以及潜在的失败（例如：2 + 香蕉 = 异常）。如果正在测试的方法或函数可以接受输入参数，那么存在失败的可能性。通过编写代码来防范这些场景，您可以减少意外行为、错误和异常的可能性。当您编写测试来表示潜在的失败时，您的生产代码将自然而然地变得更加健壮，并且更不容易出错。如果某个错误悄悄溜过并进入质量保证阶段，甚至进入生产环境，那么添加一个新的测试来覆盖新发现的缺陷是非常容易的。
- en: The added benefit of approaching bugs in this fashion is that the same bug rarely
    crops up again at some later date, as the new tests guard against this. If the
    same bug does appear, you know that, while the same result has happened, the bug
    occurred in a new and different way. With the addition of another test to cover
    this new scenario, this will likely be the last time you see the same old bug.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理错误的附加好处是，相同的错误很少会在以后的某个时间再次出现，因为新的测试可以防止这种情况。如果相同的错误确实出现了，您知道，尽管发生了相同的结果，但错误是以新的和不同的方式发生的。通过添加另一个测试来覆盖这个新场景，这很可能是您最后一次看到这个老问题。
- en: Ensures some level of correctness
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保一定程度的正确性
- en: With a comprehensive suite of tests, you can demonstrate some level of correctness.
    At some point, someone somewhere will ask you whether you are done. How will you
    show that you have added the desired functionality to an application?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一套全面的测试套件，您可以展示一定程度的正确性。在某个时候，某个地方的人会问您是否已经完成。您将如何展示您已经向应用程序添加了所需的功能？
- en: Removes the fear of refactoring
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除了重构的恐惧
- en: Let's face it, we've all worked on legacy applications that we were scared to
    touch. Imagine if the class you were tasked with modifying were covered by a comprehensive
    set of unit tests. Picture how easy it would be to make a change and know that
    all was right with the world because all of the unit tests still passed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实，我们所有人都曾参与过我们不敢触碰的遗留应用程序的开发工作。想象一下，如果您负责修改的类被一套全面的单元测试所覆盖，那会多么容易。想象一下，做出改变后，知道一切如常，因为所有的单元测试仍然通过，这是多么简单。
- en: A better architecture
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的架构
- en: Writing unit tests tends to push your code towards a decoupled design. Tightly
    coupled code quickly becomes burdensome to test, and so, to make one's life easier,
    a Test-Driven Developer will begin to decouple the code. Decoupled code is easier
    to swap in and out, which means that, instead of modifying a tangled knot of production
    code, often all that a developer needs to do to make the necessary changes is
    swap out a subcomponent with a new module of code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试往往会推动你的代码向解耦设计发展。紧密耦合的代码很快就会变得难以测试，因此，为了使生活更轻松，测试驱动开发者会开始解耦代码。解耦的代码更容易替换，这意味着，而不是修改一团糟的生产代码，开发者通常只需要替换一个子组件的新模块代码，就能做出必要的更改。
- en: Faster development
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的开发
- en: It may not feel like it at first (in fact, it definitely will not feel like
    it at first), but writing unit tests is an excellent way to speed up development.
    Traditionally, a developer receives requirements from the business, sits down,
    and begins shooting lightning from her fingertips, allowing the code to pour out
    until an executable application has been written. Before TDD, a developer would
    write code for a few minutes and then launch the application so that she could
    see if the code worked or not. When a mistake was found, the developer would fix
    it and launch the application once again to check whether the fix worked. Often,
    a developer would find that her fix had broken something else and would then have
    to chase down what she had broken and write another fix. The process described
    is likely one that you and every other developer in the world are familiar with.
    Imagine how much time you have lost fixing bugs that you found while doing developer
    testing. This does not even include the bugs found by QA or in production by the
    customer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能感觉不到（事实上，一开始肯定感觉不到），但编写单元测试是加快开发速度的绝佳方式。传统上，开发者从业务那里接收需求，坐下来，开始从指尖发射闪电，让代码倾泻而出，直到编写出一个可执行的应用程序。在TDD之前，开发者会写几分钟代码，然后启动应用程序，看看代码是否工作。当发现错误时，开发者会修复它，再次启动应用程序以检查修复是否有效。通常，开发者会发现她的修复破坏了其他东西，然后她必须追查她破坏了什么，并编写另一个修复。描述的过程可能是你以及世界上每个其他开发者都熟悉的过程。想象一下，你在进行开发者测试时发现并修复的bug浪费了多少时间。这还不包括由QA或客户在生产中发现的bug。
- en: Now, let's picture another scenario. After learning TDD, when we receive requirements
    from the business, we quickly convert those requirements directly into tests.
    As each test passes we know that, as per the requirements, our code does exactly
    what has been asked of it. We might discover some edge cases along the way and
    create tests to ensure the code has the correct behavior for each one. It would
    be rare to discover that a test is failing after having made it pass. But, when
    we do cause a test to fail, we can quickly fix it by using the undo command in
    our editor. This allows us to hardly even run the application until we are ready
    to submit our changes to QA and the business. Still, we try to verify that the
    application behaves as required before submitting, but now we don't do this manually,
    every few minutes. Instead, let your unit tests verify your code each time you
    save a file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象另一个场景。在学习TDD之后，当我们从业务那里收到需求时，我们会迅速将这些需求直接转换为测试。随着每个测试通过，我们知道根据需求，我们的代码确实做了它被要求做的事情。我们可能会在过程中发现一些边缘情况，并创建测试来确保代码对每个边缘情况都有正确的行为。在测试通过后才发现测试失败的情况是很少见的。但是，当我们导致测试失败时，我们可以通过使用编辑器中的撤销命令快速修复它。这使我们几乎不需要运行应用程序，直到我们准备好将更改提交给QA和业务。尽管如此，我们仍然试图在提交之前验证应用程序的行为是否符合要求，但现在我们不是每几分钟手动做这件事。相反，每次你保存文件时，让你的单元测试验证你的代码。
- en: Different types of test
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的测试
- en: Over the course of this book, we will be leaning towards a particular style of
    testing, but it is important to understand the terminology that others will use
    so that you can relate when they speak about a certain type of test.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们将倾向于一种特定的测试风格，但了解其他人将使用的术语很重要，这样你才能在他们谈论某种类型的测试时建立联系。
- en: Unit tests
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Let's jump right in with the most misused and least understood test type. In
    Kent Beck's book, *Test-Driven Development by Example*, he defines a unit test
    as simply a test that runs in isolation from the other tests. All that means is
    that for a test to be a unit test, all that has to happen is that the test must
    not be affected by the side-effects of the other tests. Some common misconceptions
    are that a unit test must not hit the database, or that it must not use code outside
    the method or function being tested. These simply aren't true. We tend to draw
    the line in our testing at third-party interactions. Any time that your tests
    will be accessing code that is outside the application you are writing, you should
    abstract that interaction. We do this for maximum flexibility in the design of
    the test, not because it wouldn't be a unit test. It is the opinion of some that
    unit tests are the only tests that should ever be written. This is based on the
    original definition, and not on the common usage of the term.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入最被误用和最不被理解的测试类型。在Kent Beck的书籍《通过示例进行测试驱动开发》中，他定义单元测试为一个简单地在与其他测试隔离的情况下运行的测试。这意味着，为了使一个测试成为单元测试，唯一必须发生的事情是测试不能受到其他测试副作用的影响。一些常见的误解是，单元测试不能击中数据库，或者它不能使用被测试的方法或函数之外的代码。这些说法并不正确。我们在测试中通常在第三方交互上划线。任何你的测试将要访问你正在编写的应用程序之外代码的情况，你应该抽象出这种交互。我们这样做是为了在测试设计上获得最大的灵活性，并不是因为它不是一个单元测试。有些人认为单元测试是唯一应该编写的测试。这是基于原始定义，而不是基于术语的常见用法。
- en: Acceptance tests
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试
- en: Tests that are directly affected by business requirements, such as those suggested
    in BDD, are generally referred to as acceptance tests. These tests are at the
    outermost limit of the application and exercise a large swathe of your code. To
    reduce the coupling of tests and production code, you could write this style of
    test almost exclusively. Our opinion is, if a result cannot be observed outside
    the application, then it is not valuable as a test.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 直接受业务需求影响的测试，如BDD中建议的，通常被称为验收测试。这些测试位于应用程序的最外层，并测试了大量的代码。为了减少测试和产品代码之间的耦合，你可以几乎完全编写这种风格的测试。我们的观点是，如果结果不能在应用程序外部观察到，那么它作为测试的价值就不大。
- en: Integration tests
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests are those that integrate with an external system. For instance,
    a test that interacts with a database would be considered an integration test.
    The external system doesn't have to be a third-party product; however, sometimes,
    the external system is just an imported library that was developed independently
    from the application you are working on but is still considered in-house software.
    Another example that most don't consider is interactions with the system or language
    framework. You could consider any test that uses the functions of C#'s `DateTime` object
    to be an integration test.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是与外部系统集成的测试。例如，与数据库交互的测试将被视为集成测试。外部系统不必是第三方产品；然而，有时外部系统只是独立于你正在开发的应用程序开发的库，但仍被视为内部软件。另一个大多数人不考虑的例子是与系统或语言框架的交互。你可以将任何使用C#的`DateTime`对象功能的测试视为集成测试。
- en: End to end tests
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: These tests validate the entire configuration and usage of your application.
    Starting from the user interface, an end to end test will programmatically click
    a button or fill out a form. The UI will call into the business logic of the application,
    executing all the way down to the data source for the application. These tests
    serve the purpose of ensuring that all external systems are configured and operating
    correctly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试验证了应用程序的整个配置和使用情况。从用户界面开始，端到端测试将程序性地点击按钮或填写表单。UI将调用应用程序的业务逻辑，一直执行到应用程序的数据源。这些测试的目的是确保所有外部系统都已配置并正常运行。
- en: Quantity of each test type
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每种测试类型的数量
- en: 'Many developers ask the question: How many of each type of test should be used?
    Every test should be a unit test, as per Kent Beck''s definition. We will cover
    variations on testing later that will have some impact on specific quantities
    of each type; but, generally, you might expect an application to have very few end
    to end tests, slightly more integration tests, and to consist mostly of acceptance
    tests.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都会问这样一个问题：每种类型的测试应该使用多少个？根据Kent Beck的定义，每个测试都应该是一个单元测试。我们将在稍后讨论测试的变体，这些变体会对每种类型的具体数量产生影响；但一般来说，你可能期望一个应用程序只有很少的端到端测试，稍微多一点集成测试，主要由验收测试组成。
- en: Parts of a unit test
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试的各个部分
- en: The simplest way to get started and ensure that you have human-readable code
    is to structure your tests using *Arrange*, *Act*, and *Assert*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始并确保你有可读性强的代码，最简单的方法是使用*安排*、*行动*和*断言*来结构化你的测试。
- en: Arrange
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排
- en: Also known as the context of a unit test, *Arrange* includes anything that exists
    as a prerequisite of the test. This includes everything from parameter values,
    stored in variables to improve readability, all the way to configuring values
    in a mock database to be injected into your application when the test is run.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为单元测试的上下文，*安排*包括作为测试先决条件的任何存在的事物。这包括从存储在变量中以改善可读性的参数值，到在测试运行时配置模拟数据库中的值以注入到你的应用程序中的所有内容。
- en: For more information on Mocking, see [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    Up the JavaScript Environment*, the *Abstract Third Party Software* and *Test
    Double Types* sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模拟的更多信息，请参阅[第3章](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195)，“设置JavaScript环境”，*抽象第三方软件*和*测试双倍类型*部分。
- en: Act
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动
- en: An action, as part of a unit test, is simply the piece of production code that
    is being tested. Usually, this is a single method or function in your code. Each
    test should have only a single action. Having more than one action will lead to
    messier tests and less certainty about where the code should change to make the
    test pass.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 动作，作为单元测试的一部分，仅仅是正在被测试的生产代码的一部分。通常，这可能是你代码中的一个单独的方法或函数。每个测试应该只有一个动作。有多个动作会导致测试更加混乱，并且对代码应该更改以使测试通过的位置的确定性更少。
- en: Assert
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: The result, or *assertion* (the expected result), is exactly what it sounds
    like. If you expect that the method being tested will return a 3, then you write
    an assertion that validates that expectation. The Single Assert Rule states that
    there should be only one assertion made per test. This does not mean that you
    can only assert once; instead, it means that your assertions should only confirm
    one logical expectation. As a quick example, you might have a method that returns
    a list of items after applying a filter. After setting up the test context, calling
    the method will result in a list of only one item, and that item will match the
    filter that we have defined. In this case, you will have a programmatic assert
    for the count of items in the list and one programmatic assert for the filter
    criterion we are testing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，或*断言*（预期的结果），正如其名。如果你期望被测试的方法将返回3，那么你将编写一个验证该期望的断言。单一断言规则指出，每个测试应该只有一个断言。这并不意味着你只能断言一次；相反，这意味着你的断言应该只确认一个逻辑期望。作为一个快速示例，你可能有一个方法，在应用过滤器后返回一个项目列表。在设置测试上下文后调用该方法将导致只包含一个项目的列表，并且该项目将匹配我们定义的过滤器。在这种情况下，你将有一个针对列表中项目数量的程序性断言，以及一个针对我们正在测试的过滤器准则的程序性断言。
- en: Requirements
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: While this book is not about business analysis or requirement generation, requirements
    will have a huge impact on your ability to effectively test-drive an application. We
    will be providing requirements for this book in a format that lends itself very
    well to high-quality tests. We will also cover some scenarios where the requirements
    are less than optimal, but for most of this book the requirements have been labored
    over to ensure a high-quality definition of the systems we are testing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书不是关于业务分析或需求生成的，但需求将对你的有效测试驱动应用程序的能力产生巨大影响。我们将以适合高质量测试的格式提供这本书的需求。我们还将涵盖一些需求不太理想的情况，但在这本书的大部分内容中，需求都经过仔细推敲，以确保我们测试的系统有高质量的定义。
- en: Why are they important?
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么它们很重要？
- en: We firmly believe that quality requirements are essential to a well-developed
    solution. The requirements inform the tests and the tests shape the code. This
    axiom means that with poor requirements, the application will result in a lower
    quality architecture and overall design. With haphazard requirements, the resulting
    tests and application will be chaotic and poorly factored. On the bright side,
    even poorly thought out or written requirements aren't the death knoll for your
    code. It is our responsibility, as professional software developers, to correct
    bad requirements. It is our task to ask questions that will lead to better requirements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们坚信，高质量的需求对于良好的解决方案至关重要。需求通知测试，而测试塑造代码。这个公理意味着，如果需求不佳，应用程序将导致质量较低的架构和整体设计。如果需求杂乱无章，产生的测试和应用程序将混乱且因素不佳。从积极的一面来看，即使考虑不周或书写不佳的需求，也不会是代码的终结。作为专业的软件开发人员，我们有责任纠正不良需求。我们的任务是提出问题，这些问题将导致更好的需求。
- en: User stories
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户故事
- en: 'User stories are commonly used in Agile software development for requirement
    definitions. The format for a user story is fairly simple and consists of three
    parts: `Role`, `Request`, and `Reason`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事通常在敏捷软件开发中用于需求定义。用户故事的形式相对简单，包括三个部分：`角色`、`请求`和`原因`。
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Role
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: The role of the user story can provide a lot of information. When specifying
    the role, we have the ability to imply the capabilities of the user. Can the user
    access certain functionalities, or are they physically impaired in such a way
    that requires an alternate form of interaction with the system? We can also communicate
    the user's mindset. Having a new user could have an impact on the design of the
    user interface, in contrast to what an experienced user might expect. The role
    can be a generic user, a specific role, a persona, or a specific user.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事的角色可以提供很多信息。在指定角色时，我们有能力暗示用户的能力。用户能否访问某些功能，或者他们是否因为身体残疾而需要以不同的方式与系统交互？我们还可以传达用户的心态。新用户可能会影响用户界面的设计，这与经验用户可能期望的相反。角色可以是通用用户、特定角色、角色或特定用户。
- en: Generic users are probably the most used and, at the same time, the least useful.
    Having a story that provides no insight into the user limits our decision making
    for this story by not restricting our context. If possible, ask your business
    analyst or product owner for a more specific definition of who the requirement
    is for.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通用用户可能是最常用同时也是最不实用的。如果一个故事不能提供对用户的洞察，那么它通过不限制我们的上下文来限制我们对这个故事的决策。如果可能的话，请向你的业务分析师或产品负责人询问对需求对象更具体的定义。
- en: Defining a specific role, such as Admin, User, or Guest, can be very helpful.
    Specific roles provide user capability information. With a specific role, we can
    determine if a user should even be allowed into the section of the application
    we are defining functionality for. It is possible that a user story will cause
    the modification of a user's rights within the system, simply because we specified
    a role instead of a generic user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个特定的角色，例如管理员、用户或访客，可能非常有帮助。特定的角色提供了用户能力信息。有了特定的角色，我们可以确定用户是否应该被允许进入我们正在定义功能的应用程序部分。可能一个用户故事会导致用户在系统中的权限修改，仅仅因为我们指定了一个角色而不是一个通用的用户。
- en: Using a persona is the most telling of the wide-reaching role types. A persona
    is a full definition of an imaginary user. It includes a name, any important physical
    attributes, preferences, familiarity with the subject of the application, familiarity
    with computers, and anything else that might have an impact on the imaginary user's
    interactions with the software. By having all this information, we can start to
    roleplay the user's actions within the system. We can start to make assumptions
    or decisions about how that user would approach or feel about a suggested feature
    and we can design the user interface with that user in mind.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个角色是广泛的角色类型中最具说明性的。角色是对一个虚构用户的完整定义。它包括一个名字，任何重要的生理特征，偏好，对应用程序主题的熟悉程度，对计算机的熟悉程度，以及可能影响虚构用户与软件交互的其他任何事物。通过拥有所有这些信息，我们可以开始模拟用户在系统中的行为。我们可以开始做出假设或决定，关于该用户会如何接近或对建议的功能有何感受，并且我们可以从这个用户的角度来设计用户界面。
- en: Request
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求
- en: The request portion of the user story is fairly simple. We should have a single
    feature or a small addition to functionality that is being requested. Generally,
    the request is too large if it includes any joining words, such as *and* or *or*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事中的请求部分相对简单。我们应该有一个单独的功能或对请求的功能的小幅增加。通常，如果包括任何连接词，如*and*或*or*，请求就太大了。
- en: Reason
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reason
- en: The reason is where the business need is stated. This is the opportunity to
    explain how the feature will add value to the company. By connecting the reason
    to the role, we can enhance the impact of the feature's usefulness.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是陈述业务需求的地方。这是解释功能如何为公司增加价值的机会。通过将原因与角色联系起来，我们可以增强功能的有用性的影响。
- en: 'A complete user story might look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的用户故事可能看起来如下：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Gherkin
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gherkin
- en: Gherkin is a style of requirements definitions that is often used for acceptance
    criteria. We can turn these requirements directly into code, and QA can turn them
    directly into test cases. The Gherkin format is generally associated with BDD,
    and it is used in Dan North's original article on the subject.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin是一种常用于验收标准的需求定义风格。我们可以直接将这些需求转换为代码，QA可以直接将它们转换为测试用例。Gherkin格式通常与BDD相关联，并在Dan
    North关于该主题的原始文章中使用。
- en: 'The Gherkin format is just as simple as the user story format. It consists
    of three parts: `Given`, `When`, and `Then`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin格式与用户故事格式一样简单。它由三个部分组成：`Given`、`When`和`Then`。
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Givens
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Givens
- en: Because the Gherkin format is fairly simple, givens are broken out to one per
    contextual criterion. As part of specifying the context, we want to see any and
    all preconditions of this scenario. Is the user logged in? Does the user have
    any special rights? Does this scenario require any settings to be put into force
    before execution? Has the user provided any input on this scenario? One more thing
    to consider is that there should only be a small number of givens.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gherkin格式相对简单，因此givens被拆分为每个上下文标准一个。在指定上下文的部分，我们希望看到这个场景的所有和任何先决条件。用户是否已登录？用户是否有任何特殊权限？这个场景是否需要在执行前设置任何设置？用户是否对这个场景提供了任何输入？还有一个需要考虑的问题是，应该只有少数几个givens。
- en: The more givens that are present in a scenario, the more likely it is that the
    scenario is too big or that the givens can somehow be logically grouped to reduce
    the count.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个场景中存在的givens越多，这个场景太大或givens可以以某种方式逻辑分组以减少数量的可能性就越大。
- en: When we start writing our tests, a Given is analogous to the Arrange section
    of a test.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写测试时，givens相当于测试的Arrange部分。
- en: When
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: When
- en: The when is the action taken by the user. There should be one action and only
    one action. This action will depend on the context defined by the Given and output the
    result expected by the Then. In our applications, this is equivalent to a function
    or method call.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 是用户执行的动作。应该只有一个动作，只有一个动作。这个动作将取决于Given定义的上下文，并输出Then期望的结果。在我们的应用程序中，这相当于一个函数或方法调用。'
- en: When we start writing our tests, a When is analogous to the Act section of a
    test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写测试时，When相当于测试的Act部分。
- en: Then
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Then
- en: '*Thens *equate to the output of the action. *Thens* describe what can be verified and
    tested from the output of a method or function, not only by developers but also
    by QA.  Just like with the Givens, we want our *Thens* to be singular in their
    expectation. Also like Givens, if we find too many *Thens,* it is either a sign
    that this scenario is getting too big, or that we are over-specifying our expectations.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*Thens* 等同于动作的输出。*Thens* 描述了可以从方法或函数的输出中验证和测试的内容，不仅限于开发者，还包括QA。就像givens一样，我们希望我们的*Thens*在期望上是单一的。同样，如果我们发现太多的*Thens*，这可能是一个迹象，表明这个场景太大，或者我们过度指定了我们的期望。'
- en: When we start writing our tests, a Then is analogous to the Assert section of
    a test.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写测试时，Then相当于测试的Assert部分。
- en: 'Complete acceptance criteria based on the user story presented earlier might
    look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前提出的用户故事的完整验收标准可能看起来如下：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like in life, not everything in this book is going to be perfect. Do you
    see anything wrong with the preceding acceptance criteria? Go on and take a few
    minutes to examine it; we'll wait.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在生活中一样，这本书中并不是所有内容都会完美。你看到前面验收标准中的任何问题吗？继续，花几分钟时间检查它；我们会等待。
- en: If you've given up, we'll tell you. The above acceptance criteria are just too
    long. There are too many Givens and too many Thens. How did this happen? How could
    we have created such a mistake? When we wrote the user story, we accidentally included
    too much information for the reason that we specified. If you go back and look
    at the user story, you will see that we threw `nearby` in the request. Adding `nearby` seemed
    harmless; it even seemed more correct. I, as the user, wasn't so interested in
    traveling too far for my speaking engagements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经放弃了，我们会告诉你。上面的验收标准太长了。有太多的前提条件和太多的结果。这是怎么发生的？我们怎么能犯这样的错误呢？当我们编写用户故事时，我们无意中包含了太多信息，因为我们指定的原因。如果你回顾一下用户故事，你会看到我们无意中在请求中加入了“附近”。添加“附近”似乎无害；甚至似乎更正确。作为用户，我对为了我的演讲活动走得太远并不感兴趣。
- en: When you start to see user stories or acceptance criteria getting out of hand
    like this, it is your responsibility to speak with the business analyst or product
    owner and work with them to reduce the scope of the requirements. In this case,
    we can extract two user stories and several acceptance criteria.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始看到用户故事或验收标准像这样失控时，你有责任与业务分析师或产品所有者交谈，并与他们合作以缩小需求范围。在这种情况下，我们可以提取两个用户故事和几个验收标准。
- en: 'Here is a full example of the requirements we have been examining:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们一直在审查的要求的完整示例：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One thing that we have not discussed is the approach to the content of the user
    stories and acceptance criteria. It is our belief that requirements should be
    as agnostic about the user interface and data storage mechanism as possible. For
    that reason, in the requirement examples, you'll notice that there is no reference
    to any kind of buttons, tables, modals/popups, clicking, or typing. For all we
    know, this application is running in a Virtual Reality Helmet with a Natural User
    Interface. Then again, it could be running as a RESTful web API, or maybe a phone
    application. The requirements should specify the system interactions, not the
    deployment environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论过用户故事和验收标准的内容方法。我们相信，需求应该尽可能不涉及用户界面和数据存储机制。因此，在需求示例中，你会发现没有任何关于按钮、表格、模态/弹出窗口、点击或输入的引用。据我们所知，这个应用程序可能正在虚拟现实头盔中运行，具有自然用户界面。同样，它也可能作为一个RESTful
    Web API运行，或者可能是一个手机应用程序。需求应该指定系统交互，而不是部署环境。
- en: In software development, it is everyone's responsibility to ensure high-quality
    requirements. If you find the requirements you have received to be too large, vague,
    user interface-dependent, or just unhelpful, it is your responsibility to work
    with your business analyst or product owner to make the requirements better and
    ready for development and QA.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，确保高质量需求是每个人的责任。如果你发现你收到的需求太大、太模糊、依赖于用户界面或只是无用的，你有责任与你的业务分析师或产品所有者合作，使需求更好，并准备好开发和质量保证。
- en: Our first tests in C#
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一组C#测试
- en: 'Have you ever created a new MVC project in Visual Studio? Have you noticed
    the checkbox towards the bottom of the dialog box? Have you ever selected, Create
    Unit Test Project? The tests created with this Unit Test Project are largely of
    little use. They do little more than validate that the default MVC controllers
    return the proper type. This is perhaps one step beyond, `ItExists`. Let''s look
    at the first set of tests created for us:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾在Visual Studio中创建过新的MVC项目？你注意到对话框底部的复选框了吗？你是否曾经选择过“创建单元测试项目”？使用此单元测试项目创建的测试在很大程度上几乎无用。它们所做的只是验证默认的MVC控制器返回正确的类型。这也许比“存在”多了一步。让我们看看为我们创建的第一组测试：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see the basics of a test class, and the test cases contained within.
    Out of the box, Visual Studio ships with MSTest, which is what we can see here.
    The test class must be decorated with the `[TestClass]` attribute. Individual
    tests must likewise also be decorated with the `[TestMethod]` attribute. This
    allows the test runner to determine which tests to execute. We'll cover these
    attributes and more in future chapters. Other testing frameworks use similar approaches
    that we'll discuss later, as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到测试类的基本结构，以及其中包含的测试用例。Visual Studio默认提供MSTest，这就是我们在这里看到的内容。测试类必须用`[TestClass]`属性装饰。单个测试同样也必须用`[TestMethod]`属性装饰。这允许测试运行程序确定要执行哪些测试。我们将在未来的章节中介绍这些属性以及更多内容。其他测试框架使用类似的方法，我们将在稍后讨论。
- en: For now, we can see that the `HomeController` is being tested. Each of the public
    methods has a single test, for which you may want to create additional tests and/or
    extract tests to separate files in the future. Later we'll be covering options
    and best practices to help you arrange your files in a much more manageable fashion.
    All of this should be part of your *refactor* step in your *red, green, refactor*
    cycle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以看到 `HomeController` 正在被测试。每个公共方法都有一个单独的测试，你可能想要创建额外的测试，或者将来将测试提取到单独的文件中。稍后我们将介绍选项和最佳实践，帮助你以更可管理的方式组织文件。所有这些都应该是你
    *red, green, refactor* 循环中的 *refactor* 步骤的一部分。
- en: Growing the application with tests
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试增长应用程序
- en: 'Perhaps you want to accept a parameter for one of your endpoints. Maybe you
    will take a visitor''s name to display a friendly greeting. Let''s take a look
    at how we might make that happen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你想要接受你的端点之一的一个参数。也许你会接受访客的名字来显示友好的问候。让我们看看我们如何实现这一点：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We start by creating a test to allow for the `About` method to accept an optional
    string parameter. We''re starting with the idea that the parameter is optional
    since we don''t want to break any existing tests. Let''s see the modified method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个测试，允许 `About` 方法接受一个可选的字符串参数。我们开始的想法是这个参数是可选的，因为我们不希望破坏任何现有的测试。让我们看看修改后的方法：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s use the `name` parameter and just append it to our `ViewBag.Message`.
    Wait, not the controller. We need a new test first:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `name` 参数并将其附加到我们的 `ViewBag.Message` 上。等等，不是控制器。我们需要先添加一个新的测试：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And now we''ll make this test pass:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使这个测试通过：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our first tests in JavaScript
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在 JavaScript 中的第一个测试
- en: 'To get the ball rolling in JavaScript, we are going to write a `Simple Calculator`
    class. Our calculator only has the requirement to add or subtract a single set
    of numbers. Much of the code you write in TDD will start very simply, just like
    this example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 JavaScript 中启动，我们将编写一个 `Simple Calculator` 类。我们的计算器只有一个要求，即添加或减去一组数字。你用
    TDD 编写的许多代码都将从非常简单开始，就像这个例子一样：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the preceding code doesn't make sense right now, don't worry; this is only
    intended to be a quick example of some working test code. The testing framework
    used here is Mocha, and the assertion library used is `chai`. In the JavaScript
    community, most testing frameworks are built with BDD in mind. Each described
    in the code sample above represents a scenario or a higher-level requirements
    abstraction; whereas, each `it` represents a specific test. Within the tests,
    the only required element is the expect, without which the test will not deliver
    a valuable result.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的代码现在看起来不太明白，不要担心；这只是一个快速示例，展示一些正在工作的测试代码。这里使用的测试框架是 Mocha，使用的断言库是 `chai`。在
    JavaScript 社区中，大多数测试框架都是基于行为驱动开发（BDD）构建的。上面代码示例中描述的每个都代表一个场景或更高层次的抽象需求；而每个 `it`
    都代表一个特定的测试。在测试中，唯一必需的元素是 `expect`，没有它测试将不会产生有价值的结果。
- en: Continuing this example, say that we receive a requirement that the add and
    subtract methods must be allowed to chain. How would we tackle that requirement?
    There are many ways, but in this case, I think I would like to do a quick redesign
    and then add some new tests. First, we will do the redesign, again driven by tests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个例子，假设我们收到一个需求，即加法和减法方法必须允许链式调用。我们将如何应对这个需求？有很多方法，但在这个情况下，我认为我想要快速重新设计，然后添加一些新的测试。首先，我们将进行重新设计，再次由测试驱动。
- en: 'By placing `only` on a `describe` or a `test`, we can isolate that `describe`/`test`.
    In this case, we want to isolate our `add` tests and begin making our change here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `describe` 或 `test` 上放置 `only`，我们可以隔离那个 `describe`/`test`。在这种情况下，我们想要隔离我们的
    `add` 测试，并从这里开始做出更改：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Previously, we have changed the test to use a constructor that takes a number.
    We have also reduced the number of parameters of the `add` function to a single
    parameter. Lastly, we have added a result value that must be used to evaluate
    the result of adding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们已经将测试更改为使用一个接受数字的构造函数。我们还减少了 `add` 函数的参数数量到一个。最后，我们添加了一个必须用于评估加法结果的结果值。
- en: 'The test will fail because it does not use the same interface as the class,
    so now we must make a change to the class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将失败，因为它没有使用与类相同的接口，所以现在我们必须对类进行更改：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This change should cause our test to pass. Now, it''s time to make a similar
    change for the `subtract` method. First, remove the `only` that was placed in
    the previous example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改应该会使我们的测试通过。现在，是时候为 `subtract` 方法做出类似的变化了。首先，移除上一个例子中放置的 `only`：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now for the appropriate change in the class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是类中适当的更改：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Out tests now pass again. The next thing we should do is create a test that
    verifies everything works together. We will leave this test up to you as an exercise,
    should you want to attempt it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的测试又通过了。接下来我们应该做的是创建一个测试来验证一切是否正常工作。如果你想要尝试，我们将把这个测试留给你作为练习。
- en: Why does it matter?
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么这很重要？
- en: So, why does all this matter? Why write more code than we have to? Because it's
    worth it. And to be honest, most of the time it isn't more code. As you take the
    time to grow your application with tests, simple solutions are produced. Simple
    solutions are almost always less code than the slick solution you might have come
    up with otherwise. And inevitably, slick solutions are error-prone, difficult
    to maintain, and often just plain wrong.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切为什么很重要？为什么我们要编写比必需的更多的代码？因为它值得。说实话，大多数时候这并不是更多的代码。当你花时间用测试来扩展你的应用时，会产生简单的解决方案。简单的解决方案通常比你可能想出的光滑解决方案要少很多代码。而且不可避免的是，光滑的解决方案容易出错，难以维护，并且往往只是完全错误。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you didn't before, you should now have a good idea of what TDD is and why
    it is important. You have been exposed to unit tests in C# and JavaScript and
    how writing tests first can help grow an application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有，你现在应该对TDD是什么以及为什么它很重要有一个很好的了解。你已经接触到了C#和JavaScript中的单元测试，以及编写测试如何有助于应用的增长。
- en: As we continue, we'll learn more about TDD. We'll explore what it means to write
    testable code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将更多地了解TDD。我们将探讨编写可测试代码的含义。
- en: In [Chapter 2](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195), *Setting
    Up the .NET Test Environment*, we'll set up your development environment and explore
    additional aspects of a unit test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195) *设置.NET测试环境* 中，我们将设置你的开发环境并探索单元测试的更多方面。
