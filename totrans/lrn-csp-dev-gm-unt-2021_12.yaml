- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Saving, Loading, and Serializing Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存、加载和序列化数据
- en: Every game you've ever played works with data, whether it's your player stats,
    game progress, or online multiplayer scoreboards. Your favorite game also manages
    internal data, meaning the programmers used hardcoded information to build levels,
    keep track of enemy stats, and write helpful utilities. In other words, data is
    everywhere.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你玩过的每一款游戏都使用数据，无论是你的玩家统计数据、游戏进度，还是在线多人排行榜。你最喜欢的游戏也管理内部数据，这意味着程序员使用了硬编码的信息来构建关卡、跟踪敌人统计数据，并编写有用的工具。换句话说，数据无处不在。
- en: 'In this chapter, we''re going to start with how both C# and Unity handle the
    filesystem on your computer, and move on to reading, writing, and serializing
    our game data. Our focus is on working with the three most common data formats
    you''ll likely come across: text files, XML, and JSON.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从C#和Unity如何处理你电脑上的文件系统开始，然后继续介绍读取、写入和序列化我们的游戏数据。我们的重点是处理你可能会遇到的最常见的三种数据格式：文本文件、XML和JSON。
- en: By the end of this chapter, you'll have a foundational understanding of your
    computer's filesystem, data formats, and basic read-write functionality. This
    will be the foundation you build your game data on, creating a more enriching
    and engaging experience for your players. You'll also be in a good position to
    start thinking about what game data is important enough to save, and how your
    C# classes and objects will look in different data formats.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对你电脑的文件系统、数据格式和基本读写功能有一个基础的了解。这将是你构建游戏数据的基础，为你的玩家创造更加丰富和吸引人的体验。你也将处于一个很好的位置来思考哪些游戏数据足够重要，值得保存，以及你的C#类和对象在不同数据格式中的样子。
- en: 'Along the way, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将涵盖以下主题：
- en: Introducing text, XML, and JSON formats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍文本、XML和JSON格式
- en: Understanding the filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解文件系统
- en: Working with different stream types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不同的流类型
- en: Reading and writing game data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读和写入游戏数据
- en: Serializing objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Introducing data formats
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍数据格式
- en: 'Data can take different forms in programming, but the three formats you should
    be familiar with at the beginning of your data journey are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，数据可以采取不同的形式，但在你数据之旅的开始阶段，你应该熟悉以下三种格式：
- en: '**Text**, which is what you''re reading right now'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**，就是你现在正在阅读的内容'
- en: '**XML** (**Extensible Markup Language**), which is a way of encoding document
    information so it''s readable for you and a computer'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**（**可扩展标记语言**），是一种编码文档信息的方式，使其对你和电脑都是可读的'
- en: '**JSON** (**JavaScript Object Notation**), which is a human-readable text format
    made up of attribute-value pairs and arrays'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**（**JavaScript对象表示法**），是一种由属性值对和数组组成的人可读文本格式'
- en: Each of these data formats has its own strengths and drawbacks, as well as applications
    in programming. For instance, text is generally used to store simpler, non-hierarchical,
    or nested information. XML is better at storing information in a document format,
    while JSON has a more diverse range of capabilities, specifically with database
    information and server communication with applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据格式各自都有其优势和劣势，以及在编程中的应用。例如，文本通常用于存储更简单、非层次结构化或嵌套的信息。XML在存储文档格式信息方面做得更好，而JSON具有更广泛的功能，特别是在数据库信息和应用程序与服务器通信方面。
- en: You can find more information about XML at [https://www.xml.com](https://www.xml.com)
    and JSON at [https://www.json.org](https://www.json.org).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.xml.com](https://www.xml.com)找到更多关于XML的信息，以及[https://www.json.org](https://www.json.org)关于JSON的信息。
- en: Data is a big topic in any programming language, so let's start off by breaking
    down what XML and JSON formats actually look like in the next two sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在任何编程语言中都是一个很大的主题，所以让我们从下一两个部分中实际了解XML和JSON格式开始。
- en: Breaking down XML
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML的分解
- en: 'A typical XML file has a standardized format. Each element of the XML document
    has an opening (`<element_name>`), a closing tag (`</element_name>`), and supports
    tag attributes (`<element_name attribute= "attribute_name"></element_name>`).
    A basic file will start with the version and encoding being used, then the starting
    or root element, followed by a list of element items, and finally the closing
    element. As a blueprint, it would look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的XML文件具有标准化的格式。XML文档的每个元素都有一个开标签（`<element_name>`），一个闭标签（`</element_name>`），并支持标签属性（`<element_name
    attribute= "attribute_name"></element_name>`）。一个基本的文件将从使用的版本和编码开始，然后是起始或根元素，接着是一系列元素项，最后是闭元素。作为一个蓝图，它看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'XML data can also store more complex objects by using child elements. For example,
    we''ll be turning a list of weapons into XML using the `Weapon` class we wrote
    earlier in the book. Since each weapon has properties for its name and damage
    value, that will look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: XML 数据也可以通过使用子元素来存储更复杂的对象。例如，我们将使用本书中早些时候编写的 `Weapon` 类将武器列表转换为 XML。由于每个武器都有名称和伤害值属性，它看起来会是这样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the example above to make sure we''ve got it right:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解上面的例子，以确保我们理解正确：
- en: The XML document starts with the version being used
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XML 文档以正在使用的版本开始
- en: The root element is declared with an opening tag named `ArrayOfWeapon`, which
    will hold all our element items
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根元素使用名为 `ArrayOfWeapon` 的开标签声明，它将包含所有元素项
- en: A weapon item is created with an opening tag named `Weapon`
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为 `Weapon` 的开标签创建了一个武器项目
- en: Its child properties are added with opening and closing tags on a single line
    for `name` and `damage`
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其子属性通过在单行上使用开闭标签添加，用于 `name` 和 `damage`
- en: The weapon item is closed, and two more weapon items are added
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 武器项目关闭，并添加了两个更多武器项目
- en: The array is closed, marking the end of the document
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组关闭，标志着文档的结束
- en: The good news is our application doesn't have to manually write our data in
    this format. C# has an entire library of classes and methods to help us translate
    simple text and class objects directly into XML.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们的应用程序不需要手动以这种格式写入数据。C# 有一个完整的类库和用于帮助我们直接将简单的文本和类对象转换为 XML 的方法和类。
- en: We'll dive into practical code examples a little later on, but first we need
    to understand how JSON works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后深入实际代码示例，但首先我们需要了解 JSON 的工作原理。
- en: Breaking down JSON
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解 JSON
- en: 'The JSON data format is similar to XML, but without the tags. Instead, everything
    is based on attribute-value pairs, like the **Dictionary** collection type we
    worked with back in *Chapter 4*, *Control Flow and Collection Types*. Each JSON
    document starts with a parent dictionary that holds as many attribute-value pairs
    as you need. Dictionaries use open and closed curly braces ( `{ }` ), a colon
    separates each attribute and value, and each attribute-value pair is separated
    by a comma:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数据格式与 XML 类似，但没有标签。相反，一切都是基于属性-值对，就像我们在 *第 4 章*，*控制流和集合类型* 中使用的 **Dictionary**
    集合类型。每个 JSON 文档都以一个父字典开始，该字典包含您需要的属性-值对。字典使用开闭花括号（`{}`），冒号分隔每个属性和值，每个属性-值对由逗号分隔：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'JSON can also have child or nested structures by setting the value of an attribute-value
    pair to an array of attribute-value pairs. For instance, if we want to store a
    weapon, it would look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 也可以通过将属性-值对的值设置为属性-值对的数组来具有子结构或嵌套结构。例如，如果我们想存储一个武器，它看起来会是这样：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, JSON data is often made up of lists, or arrays, or objects. Continuing
    our example, if we wanted to store a list of all the weapons our player could
    choose, we would use a pair of square brackets to denote an array:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JSON 数据通常由列表、数组或对象组成。继续我们的例子，如果我们想存储玩家可以选择的所有武器的列表，我们会使用一对方括号来表示一个数组：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can mix and match any of these techniques to store any kind of complex data
    you need, which is one of JSON's main strengths. But just like with XML, don't
    be overtaken by the new syntax – C# and Unity both have helper classes and methods
    to translate text and class objects into JSON without us having to do any heavy
    lifting. Reading XML and JSON is sort of like learning a new language—the more
    you use it the more familiar it becomes. Soon it'll be second nature!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合使用这些技术来存储任何需要的复杂数据，这是 JSON 的主要优势之一。但就像 XML 一样，不要被新的语法所压倒——C# 和 Unity 都有辅助类和方法，可以在不进行任何繁重操作的情况下将文本和类对象转换为
    JSON。阅读 XML 和 JSON 类似于学习一门新语言——您使用得越多，就越熟悉。很快，它就会变得像本能一样！
- en: Now that we've dipped our toes into data formatting basics, we can start talking
    about how the filesystem on your computer works and what properties we can access
    from our C# code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涉猎了数据格式化的基础知识，我们可以开始讨论计算机文件系统的工作原理以及我们可以从我们的 C# 代码中访问哪些属性。
- en: Understanding the filesystem
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件系统
- en: When we say filesystem, we're talking about something you're already familiar
    with – how files and folders are created, organized, and stored on your computer.
    When you create a new folder on your computer, you can name it and put files or
    other folders inside it. It's also represented by an icon, which is both a visual
    cue and a way to drag, drop, and move it anywhere you like.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到文件系统时，我们谈论的是你已经熟悉的东西——文件和文件夹在你的计算机上是如何创建、组织和存储的。当你你在计算机上创建一个新的文件夹时，你可以给它命名，并在其中放置文件或其他文件夹。它还由一个图标表示，这个图标既是视觉提示，也是拖放和移动到任何你想要的位置的方式。
- en: Everything you can do on your desktop you can do in code. All you need is the
    name of the folder, or directory as it's called, and a location to store it. Anytime
    you want to add a file or subfolder, you reference the parent directory and add
    your new content.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中做的一切，你都可以在桌面上做。你所需要的是文件夹的名称，或者称为目录，以及一个存储位置。任何时候你想添加文件或子文件夹，你引用父目录并添加你的新内容。
- en: 'To drive the filesystem home, let''s start building out the `DataManager` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使文件系统更加清晰，让我们开始构建`DataManager`类：
- en: Right-click in the **Hierarchy** and choose **Create Empty**, then name it **Data_Manager**:![](img/B17573_12_01.png)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**层次结构**并选择**创建空文件**，然后命名为**数据管理器**：![图片](img/B17573_12_01.png)
- en: 'Figure 12.1: Data_Manager in the Hierarchy'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.1：数据管理器在层次结构中
- en: Select the **Data_Manager** object in the **Hierarchy** and drag the `DataManager`
    script we created in *Chapter 10*, *Revisiting Types, Methods, and Classes*, from
    the **Scripts** folder into the **Inspector**:![](img/B17573_12_02.png)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**数据管理器**对象，并将我们在第10章“回顾类型、方法和类”中创建的`DataManager`脚本从**脚本**文件夹拖放到**检查器**中：![图片](img/B17573_12_02.png)
- en: 'Figure 12.2: Data_Manager in the Inspector'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.2：数据管理器在检查器中
- en: 'Open the `DataManager` script and update it with the following code to print
    out a few filesystem properties:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DataManager`脚本，并使用以下代码更新它以打印出一些文件系统属性：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s break down the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, we add the `System.IO` namespace, which has all the classes and methods
    we need to work with the filesystem.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加了`System.IO`命名空间，其中包含我们与文件系统一起工作所需的所有类和方法。
- en: We call the `FilesystemInfo` method we create in the next step.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用我们在下一步中创建的`FilesystemInfo`方法。
- en: 'We create the `FilesystemInfo` method to print out a few filesystem properties.
    Every operating system handles its filesystem paths differently—a path is the
    location of a directory or file written in a string. On Macs:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了`FilesystemInfo`方法来打印出一些文件系统属性。每个操作系统处理其文件系统路径的方式都不同——路径是目录或文件在字符串中的位置。在Mac上：
- en: Paths are separated by a colon (`:`)
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径由冒号(`:`)分隔
- en: Directories are separated by a forward slash (`/`)
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录由正斜杠(`/`)分隔
- en: The current directory path is where the *Hero Born* project is stored
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前目录路径是存储*英雄诞生*项目的地方
- en: The temporary path is the location of your filesystem's temporary folder
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时路径是文件系统临时文件夹的位置
- en: If you're on other platforms and operating systems, make sure to check the `Path`
    and `Directory` methods for yourself before working with the filesystem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他平台和操作系统，在处理文件系统之前，请确保自己检查`Path`和`Directory`方法。
- en: 'Run the game and take a look at the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并查看输出：
- en: '![](img/B17573_12_03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_12_03.png)'
- en: 'Figure 12.3: Console messages from Data Manager'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：数据管理器的控制台消息
- en: The `Path` and `Directory` classes are the foundation we're going to be building
    on to store our data in the following sections. However, they're both large classes,
    so I encourage you to look into their documentation as you continue your data
    journey.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`和`Directory`类是我们将在以下部分构建的基础，我们将使用它们来存储数据。然而，它们都是大型类，所以我鼓励你在继续你的数据之旅时查看它们的文档。'
- en: You can find more documentation for the Path class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.path](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)
    and the Directory class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.directory](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/dotnet/api/system.io.path](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)找到关于`Path`类的更多文档，以及在[https://docs.microsoft.com/en-us/dotnet/api/system.io.directory](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory)找到关于`Directory`类的更多文档。
- en: Now that we have a simple example of filesystem properties printed out in our
    `DataManager` script, we can create a filesystem path to the location where we
    want to save our data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`DataManager`脚本中打印出了简单的文件系统属性示例，我们可以创建一个文件系统路径到我们想要保存数据的位置。
- en: Working with asset paths
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理资产路径
- en: In a purely C# application, you would have to choose what folder to save your
    files in and write out the folder path in a string. However, Unity provides a
    handy pre-configured path as part of the `Application` class where you can store
    persistent game data. Persistent data means the information is saved and kept
    each time the program runs, which makes it ideal for this kind of player information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个纯 C# 应用程序中，你必须选择保存文件的文件夹，并将文件夹路径以字符串形式写出来。然而，Unity 提供了一个方便的预配置路径，作为 `Application`
    类的一部分，你可以在这里存储持久游戏数据。持久数据意味着信息在每次程序运行时都会保存并保留，这使得它非常适合此类玩家信息。
- en: It's important to know that the path to Unity's persistent data directory is
    cross-platform, meaning that it's different whether you're building a game for
    iOS, Android, Windows, and more. You can find out more information in the Unity
    documentation at [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Unity 持久数据目录的路径是跨平台的，这意味着如果你为 iOS、Android、Windows 等构建游戏，它是不同的。你可以在 Unity
    文档中找到更多信息，请参阅 [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)。
- en: The only update we need to make to `DataManager` is creating a private variable
    to hold our path string. We're making this private because we don't want any other
    script to be able to access or change the value. That way, `DataManager` is responsible
    for all data-related logic and nothing else.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新 `DataManager` 的唯一操作是创建一个私有变量来保存我们的路径字符串。我们将其设置为私有，因为我们不希望任何其他脚本能够访问或更改该值。这样，`DataManager`
    负责所有与数据相关的逻辑，而不会涉及其他方面。
- en: 'Add the following variable to `DataManager.cs`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下变量添加到 `DataManager.cs` 文件中：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s break down our code update:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的代码更新：
- en: We created a private variable to hold the data path string
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个私有变量来保存数据路径字符串
- en: 'We set the data path string to the application''s `persistentDataPath` value,
    added a new folder name called **Player_Data** using open and closed forward slashes,
    and printed out the complete path:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将数据路径字符串设置为应用程序的 `persistentDataPath` 值，使用开放和闭合的斜杠添加了一个名为 **Player_Data**
    的新文件夹名称，并打印出了完整的路径：
- en: It's important to note that `Application.persistentDataPath` can only be used
    in a `MonoBehaviour` method like `Awake()`, `Start()`, `Update()`, and so on and
    the game needs to be running for Unity to return a valid path.![](img/B17573_12_04.png)
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要注意，`Application.persistentDataPath` 只能在 `MonoBehaviour` 方法（如 `Awake()`、`Start()`、`Update()`
    等）中使用，并且游戏需要运行，Unity 才能返回一个有效的路径。![img/B17573_12_04.png](img/B17573_12_04.png)
- en: 'Figure 12.4: File path for Unity persistent data files'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.4：Unity 持久数据文件的文件路径
- en: Since I'm using a Mac, my persistent data folder is nested inside my `/Users`
    folder. Remember to check out [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)
    to find out where your data is stored if you're using a different device.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我使用的是 Mac，我的持久数据文件夹嵌套在我的 `/Users` 文件夹中。如果你使用的是不同设备，请记住查看 [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)
    以了解你的数据存储位置。
- en: 'When you''re not working with a predefined asset path like Unity''s persistent
    data directory, C# has a handy method called `Combine` in the `Path` class for
    automatically configuring path variables. The `Combine()` method can take up to
    four strings as input parameters or an array of strings representing the path
    components. For example, a path to your `User` directory might look like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不在使用预定义的资产路径，如 Unity 的持久数据目录时，C# 中的 `Path` 类提供了一个方便的 `Combine` 方法来自动配置路径变量。`Combine()`
    方法可以接受最多四个字符串作为输入参数，或者是一个表示路径组件的字符串数组。例如，你的 `User` 目录的路径可能看起来像这样：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This takes care of any potential cross-platform issues with separating characters
    and back or forward slashes in paths and directories.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了路径和目录中分隔字符以及前后斜杠的任何潜在跨平台问题。
- en: Now that we have a path to store our data, let's create a new directory, or
    folder, in the filesystem. This will let us store our data securely and between
    game runs, as opposed to temporary storage where it would be deleted or overwritten.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储数据的路径，让我们在文件系统中创建一个新的目录或文件夹。这将使我们能够安全地存储数据，并在游戏运行之间保持数据，而不是在临时存储中，那里数据会被删除或覆盖。
- en: Creating and deleting directories
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和删除目录
- en: Creating a new directory folder is straightforward—we check to see if one already
    exists with the same name at the same path, and if not, we tell C# to create it
    for us. Everyone has their own ways of dealing with duplicates in their files
    and folders, so we'll be repeating a fair bit of duplicate checking code in the
    rest of the chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的目录文件夹很简单——我们检查是否在相同的路径上已经存在具有相同名称的目录，如果没有，我们告诉C#为我们创建它。每个人在处理文件和文件夹中的重复项都有自己的方法，所以在本章的其余部分，我们将重复大量的重复检查代码。
- en: 'I''d still recommend following the **DRY** (**Don''t Repeat Yourself**) principle
    in real-world applications; the duplicate checking code is only repeated here
    to make the examples complete and easy to understand:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然建议在现实世界的应用中遵循**DRY**（**不要重复自己**）原则；重复检查代码在这里只重复是为了使示例完整且易于理解：
- en: 'Add the following method to `DataManager`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到`DataManager`中：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Call the new method inside `Initialize()`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break down what we did:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们所做的：
- en: First, we check if the directory folder already exists using the path we created
    in the last step
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用上一步创建的路径检查目录文件夹是否已经存在
- en: If it's already been created, we send ourselves a message in the console and
    use the `return` keyword to exit the method without going any further
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它已经被创建，我们在控制台中发送给自己一条消息，并使用`return`关键字退出方法，不再继续
- en: If the directory folder doesn't exist, we pass the `CreateDirectory()` method
    our data path and log that it's been created
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目录文件夹不存在，我们将数据路径传递给`CreateDirectory()`方法，并记录它已被创建
- en: Run the game and make sure that you see the right debug logs in the console,
    as well as the new directory folder in your persistent data folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并确保你在控制台中看到正确的调试日志，以及在你持久化数据文件夹中的新目录文件夹。
- en: If you can't find it, use the `_dataPath` value we printed out in the previous
    step.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到，请使用我们在上一步中打印出的`_dataPath`值。
- en: '![](img/B17573_12_05.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_05.png)'
- en: 'Figure 12.5: Console message for new directory creation'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：创建新目录的控制台消息
- en: '![](img/B17573_12_06.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_06.png)'
- en: 'Figure 12.6: New directory created on the desktop'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：在桌面上创建的新目录
- en: If you run the game a second time, no duplicate directory folder will be created,
    which is exactly the kind of safe code we want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行游戏，将不会创建重复的目录文件夹，这正是我们想要的类型的安全代码。
- en: '![](img/B17573_12_07.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_07.png)'
- en: 'Figure 12.7: Console message for duplicate directory folders'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：重复目录文件夹的控制台消息
- en: Deleting a directory is very similar to how we created it – we check if it exists,
    then we use the `Directory` class to delete whatever folder is at the path we
    pass in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 删除目录与创建目录非常相似——我们检查它是否存在，然后使用`Directory`类删除我们传递的路径上的任何文件夹。
- en: 'Add the following method to `DataManager`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到`DataManager`中：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we want to keep the directory we just created, you don't have to call
    this function right now. However, if you want to try it out all you need to do
    is replace `NewDirectory()` with `DeleteDirectory()` in the `Initialize()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要保留刚刚创建的目录，你现在不需要调用这个函数。然而，如果你想尝试它，你只需要在`Initialize()`函数中将`NewDirectory()`替换为`DeleteDirectory()`。
- en: An empty directory folder isn't super useful, so let's create our first text
    file and save it in our new location.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 空的目录文件夹并不特别有用，所以让我们创建我们的第一个文本文件，并将其保存在我们的新位置。
- en: Creating, updating, and deleting files
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建、更新和删除文件
- en: Working with files is similar to creating and deleting a directory, so we already
    have the basic building blocks we need. To make sure we don't duplicate data,
    we'll check if the file already exists, and if not, we'll create a new one in
    our new directory folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件一起工作与创建和删除目录相似，所以我们已经有了需要的所有基本构建块。为了确保我们不重复数据，我们将检查文件是否已经存在，如果没有，我们将在新的目录文件夹中创建一个新的文件。
- en: We'll be working with the `File` class for this section, which has a ton of
    helpful methods to help us implement our features. You can find the entire list
    at [https://docs.microsoft.com/en-us/dotnet/api/system.io.file](https://docs.microsoft.com/en-us/dotnet/api/system.io.file).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`File`类，它包含许多有用的方法来帮助我们实现我们的功能。你可以在这里找到完整的列表：[https://docs.microsoft.com/en-us/dotnet/api/system.io.file](https://docs.microsoft.com/en-us/dotnet/api/system.io.file)。
- en: An important point to drive home about files before we start is that they need
    to be opened before you can add text, and they need to be closed after you're
    finished. If you don't close the file you're programmatically working with, it
    will stay open in the program's memory. This both uses computation power for something
    you're not actively editing and can create potential memory leaks. More on them
    later in the chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理文件之前，有一个重要的问题需要强调，那就是在添加文本之前需要打开文件，在完成操作后需要关闭文件。如果你没有关闭你正在程序中处理的文件，它将保持在程序的内存中。这不仅会消耗计算资源，用于你未积极编辑的内容，还可能创建潜在的内存泄漏。关于这些内容，我们将在本章后面进行更多介绍。
- en: We're going to be writing individual methods for each action we want to perform
    (create, update, and delete). We're also going to check if the files we're working
    with exist or not in each case, which is repetitive. I've structured this part
    of the book so you can get a solid grasp of each of the procedures. However, you
    can absolutely combine them into more economical methods after you've learned
    the basics.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个要执行的操作（创建、更新和删除）编写单独的方法。我们还将检查我们正在处理的文件是否存在，这在每种情况下都是重复的。我已经将本书的这一部分结构化，以便你可以牢固掌握每个程序。然而，在你掌握了基础知识之后，你可以绝对地将它们合并成更经济的方法。
- en: 'Take the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Add a new private string path for the new text file and set its value in `Awake`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新文本文件添加一个新的私有字符串路径，并在`Awake`中设置其值：
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`中添加一个新方法：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Call the new method in `Initialize()`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s break down our new code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析我们的新代码：
- en: 'We check if the file already exists, and if it does we `return` out of the
    method to avoid duplicates:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查文件是否已存在，如果存在，我们`return`出方法以避免重复：
- en: It's worth noting that this approach works well for new files that aren't going
    to be changed. We'll cover updating and overwriting data to files in the next
    exercise.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，这种方法对于不会更改的新文件效果很好。我们将在下一项练习中介绍如何更新和覆盖文件中的数据。
- en: 'We use the `WriteAllText()` method because it does everything we need all in
    one:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`WriteAllText()`方法，因为它将我们需要的所有操作都集成在一个方法中：
- en: A new file is created using our `_textFile` path
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的`_textFile`路径创建了一个新文件
- en: We add a title string that says `<SAVE DATA>` and add two new lines with the
    `\n` characters
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加一个标题字符串，表示`<SAVE DATA>`，并添加两个带有`\n`字符的新行
- en: Then the file is closed for us automatically
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后文件会自动为我们关闭
- en: We print out a log message to let us know everything went smoothly
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印一条日志消息，让我们知道一切顺利
- en: 'When you play the game now, you''ll see the debug log in the console and the
    new text file in your persistent data folder location:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你玩游戏时，你将在控制台中看到调试日志，并在你的持久数据文件夹位置看到新的文本文件：
- en: '![](img/B17573_12_08.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_08.png)'
- en: 'Figure 12.8: Console messages for new file creation'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：创建新文件的控制台消息
- en: '![](img/B17573_12_09.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_09.png)'
- en: 'Figure 12.9: New file created on desktop'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：在桌面上创建的新文件
- en: 'To update our new text file, we''ll do a similar set of operations. It''s always
    nice to know when a new game is started, so your next task is to add a method
    to write that information to our save data file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新我们的新文本文件，我们将执行一系列类似的操作。知道何时开始新游戏总是很令人愉快，因此你的下一个任务是添加一个方法，将此信息写入我们的存档数据文件：
- en: 'Add a new `using` directive to the top of `DataManager`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`的顶部添加一个新的`using`指令：
- en: '[PRE14]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`中添加一个新方法：
- en: '[PRE15]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call the new method in `Initialize()`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s break down the above code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析上述代码：
- en: If the file exists, we don't want to duplicate it so we just exit out of the
    method without any further action
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们不希望重复它，所以我们只需退出方法而不采取任何进一步的操作
- en: 'If the file does exist, we use another all-in-one method called `AppendAllText()`
    to add the game''s start time:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件确实存在，我们使用另一个名为`AppendAllText()`的集成方法来添加游戏开始时间：
- en: This method opens the file
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法打开文件
- en: It adds a new line of text that's passed in as a method parameter
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加一个新行文本，该文本作为方法参数传入
- en: It closes the file
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它关闭文件
- en: Print out a log message to let us know everything went smoothly
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一条日志消息，让我们知道一切顺利
- en: 'Play the game again and you''ll see our console message and a new line in our
    text file with the new game''s date and time:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次玩游戏，你将看到我们的控制台消息和文本文件中的新行，包含新游戏的日期和时间：
- en: '![](img/B17573_12_10.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_10.png)'
- en: 'Figure 12.10: Console messages for updating the text file'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：更新文本文件的控制台消息
- en: '![](img/B17573_12_11.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_11.png)'
- en: 'Figure 12.11: Text file data updated'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：文本文件数据已更新
- en: 'In order to read our new file data, we need a method to grab all the file''s
    text and hand it back to us in a string. Luckily, the `File` class has methods
    to do just that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取我们新的文件数据，我们需要一个方法来获取所有文件文本并将其作为字符串返回给我们。幸运的是，`File` 类有方法可以做到这一点：
- en: 'Add a new method to `DataManager`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `DataManager` 添加一个新方法：
- en: '[PRE17]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Call the new method in `Initialize()` and pass in the `_textFile` as a parameter:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Initialize()` 中调用新方法，并将 `_textFile` 作为参数传入：
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s break down the new method''s code below:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下新方法的代码：
- en: We create a new method that takes in a string parameter for the file we want
    to read
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新方法，该方法接受一个字符串参数，用于指定我们想要读取的文件
- en: If the file doesn't exist, there's no action needed so we exit out of the method
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，则不需要采取任何操作，所以我们退出方法
- en: We use the `ReadAllText()` method to get all the file's text data as a string
    and print it out to the console
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `ReadAllText()` 方法获取所有文件文本数据作为字符串，并将其打印到控制台。
- en: Play the game and you'll see a console message with our previous save and a
    new one!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏，你会在控制台中看到一个包含我们之前保存的新保存的控制台消息！
- en: '![](img/B17573_12_12.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_12.png)'
- en: 'Figure 12.12: Console message with saved text data read from file'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12：从文件读取保存的文本数据的控制台消息
- en: 'Lastly, let''s add a method to delete our text file if we wanted. We''re not
    actually going to use this method, as we want to keep our text file as is, but
    you can always try it out for yourself:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想删除我们的文本文件，我们可以添加一个方法。实际上我们不会使用这个方法，因为我们想保留我们的文本文件不变，但你可以自己尝试一下：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we've dipped our toes a little deeper into the filesystem waters, it's
    time to talk about a slightly upgraded way of working with information — data
    streams!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经稍微深入了解了文件系统，是时候讨论一种稍微升级的信息处理方式了——数据流！
- en: Working with streams
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理流
- en: So far, we've been letting the `File` class do all of the heavy lifting with
    our data. What we haven't talked about is how the `File` class, or any other class
    that deals with reading and writing data, does that work under the hood.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直让 `File` 类为我们处理数据中的繁重工作。我们还没有讨论的是，`File` 类，或者任何处理读取和写入数据的类，是如何在底层完成这些工作的。
- en: For computers, data is made up of bytes. Think of bytes as the computer's atoms,
    they make up everything—there's even a C# `byte` type. When we read, write, or
    update a file, our data is converted into an array of bytes, which are then streamed
    to or from the file using a `Stream`. The data stream is responsible for carrying
    the data as a sequence of bytes to or from a file, acting as a translator or intermediary
    for us between our game application and the data files themselves.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '对于计算机来说，数据由字节组成。将字节想象成计算机的原子，它们构成了所有东西——甚至有一个 C# 的 `byte` 类型。当我们读取、写入或更新文件时，我们的数据被转换成一个字节数组，然后通过
    `Stream` 流向或从文件传输。数据流负责将数据作为字节序列传输到或从文件，作为我们游戏应用程序和数据文件之间的翻译者或中介。 '
- en: '![](img/B17573_12_13.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_13.png)'
- en: 'Figure 12.13: Diagram of streaming data to a file'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13：将流数据写入文件的示意图
- en: 'The `File` class uses `Stream` objects for us automatically, and there are
    different `Stream` subclasses for different functionality:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 类会自动为我们使用 `Stream` 对象，并且有不同功能的 `Stream` 子类：'
- en: Use a `FileStream` to read and write data to your files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FileStream` 读取和写入文件中的数据
- en: Use a `MemoryStream` to read and write data to memory
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `MemoryStream` 读取和写入内存中的数据
- en: Use a `NetworkStream` to read and write data to other networked computers
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `NetworkStream` 读取和写入其他网络计算机的数据
- en: Use a `GZipStream` to compress data for easier storage and downloading
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GZipStream` 压缩数据以便于存储和下载
- en: In the coming sections, we'll get into managing stream resources, using helper
    classes called `StreamReader`and `StreamWriter` to create, read, update, and delete
    files. You'll also learn how to format XML more easily using the `XmlWriter` class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何管理流资源，使用名为 `StreamReader` 和 `StreamWriter` 的辅助类来创建、读取、更新和删除文件。你还将学习如何使用
    `XmlWriter` 类更轻松地格式化 XML。
- en: Managing your Stream resources
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理你的流资源
- en: One important topic we haven't talked about yet is resource allocation. What
    that means is some processes in your code will put computing power and memory
    on a sort of layaway plan where you can't touch it. These processes will wait
    until you explicitly tell your program or game to close and return the layaway
    resources to you so you're back to full power. Streams are one such process, and
    they need to be closed after you're done using them. If you don't properly close
    your streams, your program will keep using those resources even though you're
    not.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的一个重要主题是资源分配。这意味着你的代码中的一些进程会将计算能力和内存放在一种类似分期付款的计划中，你无法触及它。这些进程将等待你明确告诉程序或游戏关闭并返回分期付款的资源，这样你就能恢复到全功率状态。流就是这样一种进程，使用完毕后需要关闭。如果你没有正确关闭你的流，即使你不再使用，程序也会继续使用这些资源。
- en: Luckily, C# has a handy interface called `IDisposable` that all `Stream` classes
    implement. This interface only has one method, `Dispose()`, which tells the stream
    when to give you back the resources it's been using.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C#有一个名为`IDisposable`的方便接口，所有`Stream`类都实现了这个接口。这个接口只有一个方法，即`Dispose()`，它告诉流何时将资源归还给你。
- en: You don't have to worry too much about this, as we'll cover an automatic way
    to make sure your streams are always closed correctly. Resource management is
    just a good programming concept to understand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必过于担心这个问题，因为我们将介绍一种自动确保你的流始终正确关闭的方法。资源管理只是理解良好的编程概念。
- en: We'll be using a `FileStream` for the rest of the chapter, but we'll be doing
    so with convenience classes called `StreamWriter` and `StreamReader`. These classes
    leave out the manual conversion of data to bytes, but still use `FileStream` objects
    themselves.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将使用`FileStream`，但我们将使用名为`StreamWriter`和`StreamReader`的便利类。这些类省略了手动将数据转换为字节的步骤，但仍然使用`FileStream`对象本身。
- en: Using a StreamWriter and StreamReader
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用StreamWriter和StreamReader
- en: Both the `StreamWriter` and `StreamReader` classes serve as helpers for using
    objects belonging to `FileStream` to write and read text data to a specific file.
    These classes are a big help because they create, open, and return a stream you
    can use with minimal boilerplate code. The example code we've covered so far is
    fine for small data files, but streams are the way to go if you're dealing with
    large and complex data objects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamWriter`和`StreamReader`类都作为使用属于`FileStream`的对象来写入和读取特定文件的辅助工具。这些类非常有帮助，因为它们创建、打开并返回一个你可以使用的流，而无需编写大量的样板代码。我们之前讨论的示例代码对于小型数据文件来说是可以的，但如果你处理的是大型和复杂的数据对象，流就是最佳选择。'
- en: 'All we need is the name of the file we want to write to or read from and we''re
    all set. Your next task is to use a stream to write text to a new file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要知道我们想要写入或读取的文件名，然后我们就可以设置了。你的下一个任务是使用流将文本写入新文件：
- en: 'Add a new private string path for the new streaming text file and set its value
    in `Awake()`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的流文本文件添加一个新的私有字符串路径，并在`Awake()`中设置其值：
- en: '[PRE20]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`DataManager`添加一个新方法：
- en: '[PRE21]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Delete or comment out the methods in `Initialize()` that we used in the previous
    section and add in our new code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或注释掉上一节中使用的`Initialize()`方法，并添加我们的新代码：
- en: '[PRE22]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s break down the new method in the above code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析上面代码中的新方法：
- en: First, we check if the file doesn't exist
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否存在
- en: If the file hasn't been created yet, we add a new `StreamWriter` instance called
    `newStream`, which uses the `CreateText()` method to create and open the new file
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件尚未创建，我们添加一个新的`StreamWriter`实例，称为`newStream`，它使用`CreateText()`方法创建和打开新文件
- en: Once the file is open, we use the `WriteLine()` method to add a header, close
    the stream, and print out a debug message
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件打开，我们使用`WriteLine()`方法添加一个标题，关闭流，并打印出调试信息
- en: If the file already exists and we just want to update it, we grab our file through
    a new `StreamWriter` instance using the `AppendText()` method so our existing
    data doesn't get overwritten
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件已经存在，我们只想更新它，我们通过一个新的`StreamWriter`实例使用`AppendText()`方法来获取我们的文件，这样我们的现有数据就不会被覆盖
- en: Finally, we write a new line with our game data, close the stream, and print
    out a debug message:![](img/B17573_12_14.png)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们写入一行包含游戏数据的新行，关闭流，并打印出调试信息![图片](img/B17573_12_14.png)
- en: 'Figure 12.14: Console messages for writing and updating text with a stream'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.14：使用流写入和更新文本的控制台消息
- en: '![](img/B17573_12_15.png)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B17573_12_15.png)'
- en: 'Figure 12.15: New file created and updated with a stream'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.15：使用流创建和更新新文件
- en: 'Reading from a stream is almost exactly like the `ReadFromFile()` method we
    created in the last section. The only difference is that we''ll use a `StreamReader`
    instance to open and read the information. Again, you want to use streams when
    you''re dealing with big data files or complex objects instead of manually creating
    and writing to files with the `File` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从流中读取几乎与我们在上一节中创建的 `ReadFromFile()` 方法完全相同。唯一的区别是我们将使用 `StreamReader` 实例来打开和读取信息。同样，当你处理大型数据文件或复杂对象时，你想要使用流而不是使用
    `File` 类手动创建和写入文件：
- en: 'Add a new method to `DataManager`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `DataManager` 添加一个新方法：
- en: '[PRE23]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call the new method in `Initialize()` and pass in the `_streamingTextFile`
    as a parameter:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Initialize()` 中调用新方法，并将 `_streamingTextFile` 作为参数传递：
- en: '[PRE24]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s break down our new code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的新代码：
- en: First, we check if the file doesn't exist, and if it doesn't then we print out
    a console message and exit the method
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否存在，如果不存在，则打印控制台消息并退出方法
- en: If the file does exist, we create a new `StreamReader` instance with the name
    of the file we want to access and print out the entire contents using the `ReadToEnd`
    method:![](img/B17573_12_16.png)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们创建一个新的 `StreamReader` 实例，其名称是我们想要访问的文件，并使用 `ReadToEnd` 方法打印出整个内容！![图
    12.16：控制台打印从流中读取的保存数据](img/B17573_12_16.png)
- en: 'Figure 12.16: Console printing out saved data read from a stream'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.16：控制台打印出从流中读取的保存数据
- en: As you'll start to notice, a lot of our code is starting to look the same. The
    only difference is our use of stream classes to do the actual reading-writing
    work. However, it's important to keep in mind how different use cases will determine
    which route you take. Refer back to the beginning of this section to review how
    each stream type is different.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如您将开始注意到的那样，我们的大部分代码开始看起来很相似。唯一的区别是我们使用流类来执行实际的读写工作。然而，重要的是要记住不同的用例将决定你选择哪种路线。回顾本节的开头，了解每种流类型的不同之处。
- en: So far, we've covered the basic features of a **CRUD** (**Creating**, **Reading**,
    **Updating**, **and** **Deleting**) application using text files. But text files
    aren't the only data format you'll be using in C# games and applications. You're
    likely to see lots of XML and JSON in the wild once you start working with databases
    and your own complex data structures, which text can't compare to in efficiency
    or storage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了使用文本文件的基本 CRUD（**创建**、**读取**、**更新**和**删除**）应用程序的功能。但在 C# 游戏 和应用程序中，您将使用不止一种数据格式。一旦您开始与数据库和您自己的复杂数据结构一起工作，您很可能会看到大量的
    XML 和 JSON，这在效率或存储方面是文本无法比拟的。
- en: In the next section, we'll work with some basic XML data, then talk about an
    easier way to manage streams.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将处理一些基本的 XML 数据，然后讨论管理流的一种更简单的方法。
- en: Creating an XMLWriter
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 XMLWriter
- en: Sometimes you won't just have plain old text to write and read from a file.
    Your project might require XML-formatted documents, in which case you'll need
    to know how to use a regular `FileStream` to save and load XML data.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你不仅要从文件中写入和读取普通文本。您的项目可能需要 XML 格式的文档，在这种情况下，您需要了解如何使用常规的 `FileStream` 来保存和加载
    XML 数据。
- en: Writing XML data to a file isn't all that different from what we've been doing
    with text and streams. The only difference is we'll explicitly create a `FileStream`
    and use it to create an instance of an `XmlWriter`. Think of the `XmlWriter` class
    as a wrapper that takes our data stream, applies XML formatting, and spits out
    our information as an XML file. Once we have that, we can structure the document
    in the proper XML format using methods from the `XmlWriter` class and close the
    file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将 XML 数据写入文件与我们在文本和流中做过的事情并没有太大的不同。唯一的区别是我们将显式创建一个 `FileStream` 并使用它来创建一个 `XmlWriter`
    实例。将 `XmlWriter` 类想象成一个包装器，它接受我们的数据流，应用 XML 格式化，并将我们的信息作为 XML 文件输出。一旦我们有了这个，我们就可以使用
    `XmlWriter` 类的方法来以正确的 XML 格式结构化文档，并关闭文件。
- en: 'Your next task is to create a file path for a new XML document and add the
    ability to write XML data to that file using the `DataManager` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个任务是创建一个新 XML 文档的文件路径，并使用 `DataManager` 类添加将 XML 数据写入该文件的能力：
- en: 'Add the highlighted `using` directive to the top of the `DataManager` class:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将高亮的 `using` 指令添加到 `DataManager` 类的顶部：
- en: '[PRE25]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的 XML 文件添加一个新的私有字符串 path 并在 `Awake()` 中设置其值：
- en: '[PRE26]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DataManager` 类的底部添加一个新方法：
- en: '[PRE27]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Call the new method in `Initialize()` and pass in `_xmlLevelProgress` as a
    parameter:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Initialize()` 中调用新方法，并将 `_xmlLevelProgress` 作为参数传递：
- en: '[PRE28]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s break down our XML writing method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的XML编写方法：
- en: First, we check if the file already exists
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否已经存在
- en: If the file doesn't exist, we create a new `FileStream` using the new path variable
    we created
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们使用我们创建的新路径变量创建一个新的`FileStream`
- en: We then create a new `XmlWriter` instance and pass it our new `FileStream`
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后创建一个新的`XmlWriter`实例，并将我们的新`FileStream`传递给它
- en: Next, we use the `WriteStartDocument` method to specify XML version 1.0
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`WriteStartDocument`方法指定XML版本1.0
- en: Then we call the `WriteStartElement` method to add the opening root element
    tag named `level_progress`
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`WriteStartElement`方法来添加名为`level_progress`的开根元素标签
- en: Now we can add individual elements to our document using the `WriteElementString`
    method, passing in `level` as the element tag and the level number using a `for`
    loop and its index value of `i`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`WriteElementString`方法将单个元素添加到我们的文档中，将`level`作为元素标签，使用`for`循环及其索引值`i`来指定层级编号
- en: To close the document, we use the `WriteEndElement` method to add a closing
    `level` tag
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭文档，我们使用`WriteEndElement`方法添加一个关闭的`level`标签
- en: Finally, we close the writer and stream to release the stream resources we've
    been using
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭写入器和流以释放我们一直在使用的流资源
- en: 'If you run the game now, you''ll see a new `.xml` file in our **Player_Data**
    folder with the level progress information:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会在我们的**Player_Data**文件夹中看到一个名为`.xml`的新文件，其中包含关卡进度信息：
- en: '![](img/B17573_12_17.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_17.png)'
- en: 'Figure 12.17: New XML file created with document data'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：使用文档数据创建的新XML文件
- en: You'll notice that there is no indenting or formatting, which is expected because
    we didn't specify any output formatting. We're not going to use any of them in
    this example because we'll be talking about a more efficient way of writing XML
    data in the next section, on serialization.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到没有缩进或格式化，这是预期的，因为我们没有指定任何输出格式。在这个例子中，我们不会使用任何格式化，因为在下一节中，我们将讨论一种更有效的方法来编写XML数据，即序列化。
- en: You can find the list of output formatting properties at [https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format](https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format](https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format)找到输出格式化属性的列表。
- en: 'The good news is that reading an XML file is no different than reading any
    other file. You can call either the `readfromfile()` or `readfromstream()` methods
    inside `initialize()` and get the same console output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，读取XML文件与读取任何其他文件没有区别。你可以在`initialize()`方法中调用`readfromfile()`或`readfromstream()`方法，并得到相同的控制台输出：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/B17573_12_18.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_18.png)'
- en: 'Figure 12.18: Console output from reading the XML file data'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：读取XML文件数据的控制台输出
- en: Now that we've written a few methods using streams, let's take a look at how
    to efficiently, and more importantly automatically, close any stream.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用流编写了一些方法，让我们看看如何高效地，更重要的是自动地关闭任何流。
- en: Automatically closing streams
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动关闭流
- en: When you're working with streams, wrapping them in a `using` statement automatically
    closes the stream for you by calling the `Dispose()` method from the `IDisposable`
    interface we mentioned earlier.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用流工作时，通过将它们包裹在`using`语句中，会自动为你调用我们之前提到的`IDisposable`接口中的`Dispose()`方法来关闭流。
- en: This way, you never have to worry about unused allocated resources your program
    might be keeping open for no reason.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你永远不必担心你的程序可能出于无理由的原因保留的未使用分配的资源。
- en: 'The syntax is almost exactly the same as what we''ve already done, except we
    use the `using` keyword at the beginning of the line, then reference a new stream
    inside a pair of parentheses, followed by a set of curly braces. Anything we want
    the stream to do, like read or write data, is done inside the curly braces block
    of code. For example, creating a new text file as we did in the `WriteToStream()`
    method would look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 语法几乎与我们之前所做的完全相同，只是我们在行首使用`using`关键字，然后在括号内引用一个新的流，后面跟着一组大括号。我们想要流执行的操作，如读取或写入数据，都在代码的大括号块内完成。例如，创建一个新文本文件，就像我们在`WriteToStream()`方法中所做的那样，看起来会是这样：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As soon as the stream logic is inside the code block, the outer `using` statement
    automatically closes the stream and returns the allocated resources to your program.
    From here on out, I'd recommend always using this syntax to write your streaming
    code. It's more efficient, much safer, and will demonstrate your understanding
    of basic resource management!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦流逻辑在代码块内部，外部的 `using` 语句会自动关闭流并将分配的资源返回到你的程序。从现在开始，我建议始终使用这种语法来编写你的流代码。它更高效，更安全，并将展示你对基本资源管理的理解！
- en: With our text and XML stream code working, it's time to move on. If you're wondering
    why we didn't stream any JSON data, it's because we need to add one more tool
    to our data toolbox—serialization!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的文本和 XML 流代码已经工作，现在是时候继续前进了。如果你想知道为什么我们没有流任何 JSON 数据，那是因为我们需要向我们的数据工具箱中添加一个额外的工具——序列化！
- en: Serializing data
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化数据
- en: When we talk about serializing and deserializing data, what we're really talking
    about is translation. While we've been translating our text and XML piecemeal
    in previous sections, being able to take an entire object and translate it in
    one shot is a great tool to have.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论序列化和反序列化数据时，我们实际上在谈论的是转换。虽然在前面的章节中我们已经逐块转换了文本和 XML，但能够一次性将整个对象转换成另一种格式是一个非常有用的工具。
- en: 'By definition:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义：
- en: The act of **serializing** an object translates the object's entire state into
    another format
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化**一个对象将对象的整个状态转换成另一种格式'
- en: The act of **deserializing** is the reverse, taking the data from a file and
    restoring it to its former object state
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反序列化**的行为是相反的，即从文件中获取数据并将其恢复到其原始对象状态'
- en: '![](img/B17573_12_19.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_12_19.png)'
- en: 'Figure 12.19: Example of serializing an object into XML and JSON'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19：将对象序列化为 XML 和 JSON 的示例
- en: Let's take a practical example from the above image — an instance of our `Weapon`
    class. Each weapon has its own name and damage properties and associated values,
    which is called its state. The state of an object is unique, which allows the
    program to tell them apart.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个上面的图像中的实际例子入手——我们的 `Weapon` 类的一个实例。每种武器都有自己的名称和伤害属性以及相关值，这被称为其状态。对象的状态是唯一的，这使得程序能够区分它们。
- en: An object's state also includes properties or fields that are reference types.
    For instance, if we had a `Character` class that had a `Weapon` property, C# would
    still recognize the weapon's `name` and `damage` properties when serializing and
    deserializing. You might hear objects with reference properties referred to as
    object graphs out in the programming world.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的状态还包括属性或字段，它们是引用类型。例如，如果我们有一个具有 `Weapon` 属性的 `Character` 类，在序列化和反序列化时，C#
    仍然会识别武器的 `name` 和 `damage` 属性。在编程世界中，你可能听到具有引用属性的物体被称为对象图。
- en: Before we jump in, it's worth noting that serializing objects can be tricky
    if you're not keeping a close eye on making sure the object properties match the
    data from a file, and vice versa. For example, if there's a mismatch between your
    class object properties and the data being deserialized, the serializer will return
    an empty object. We'll cover this in more detail when we try to serialize a C#
    list into JSON later in the chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，值得注意的是，如果你没有密切注意确保对象属性与文件中的数据匹配，序列化对象可能会变得很棘手。例如，如果你的类对象属性与正在反序列化的数据不匹配，序列化器将返回一个空对象。我们将在本章后面尝试将
    C# 列表序列化为 JSON 时更详细地介绍这一点。
- en: To really get the hang of this, let's take our `Weapon` example and turn it
    into working code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正掌握这个，让我们将我们的 `Weapon` 示例转换为工作代码。
- en: Serializing and deserializing XML
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化和反序列化 XML
- en: Your task for the rest of this chapter is to serialize and deserialize a list
    of weapons into XML and JSON, with XML going first!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的任务是将武器列表序列化和反序列化为 XML 和 JSON，XML 需要先进行！
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DataManager` 类的顶部添加一个新的 `using` 指令：
- en: '[PRE31]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add a serializable attribute to the `Weapon` class so Unity and C# know the
    object can be serialized:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Weapon` 类中添加一个可序列化属性，以便 Unity 和 C# 知道该对象可以序列化：
- en: '[PRE32]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add two new variables, one for the XML file path and one for the list of weapons:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个新变量，一个用于 XML 文件路径，一个用于武器列表：
- en: '[PRE33]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Set the XML file path value in `Awake`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Awake` 中设置 XML 文件路径值：
- en: '[PRE34]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DataManager` 类的底部添加一个新的方法：
- en: '[PRE35]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Call the new method in `Initialize`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Initialize` 中调用新方法：
- en: '[PRE36]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s break down our new method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的新方法：
- en: 'First, we create an `XmlSerializer` instance and pass in the type of data we''re
    going to be translating. In this case, the _`weaponInventory` is of type `List<Weapon>`,
    which is what we use in the `typeof` operator:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`XmlSerializer`实例，并传入我们将要转换的数据类型。在这种情况下，`_weaponInventory`是`List<Weapon>`类型，这是我们使用`typeof`运算符的地方：
- en: The `XmlSerializer` class is another helpful formatting wrapper, just like the
    `XmlWriter` class we used earlier
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlSerializer`类是另一个有用的格式化包装器，就像我们之前使用的`XmlWriter`类一样'
- en: Then, we create a `FileStream` using the `_xmlWeapons` file path and wrapped
    in a `using` code block to make sure it's closed properly.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`_xmlWeapons`文件路径创建一个`FileStream`，并用`using`代码块包装，以确保它被正确关闭。
- en: Finally, we call the `Serialize()` method and pass in the stream and the data
    we want to translate.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`Serialize()`方法，并传入流以及我们想要转换的数据。
- en: Run the game again and take a look at the new XML document we created without
    having to specify any additional formatting!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，看看我们创建的新XML文档，而无需指定任何额外的格式！
- en: '![](img/B17573_12_20.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20](img/B17573_12_20.png)'
- en: 'Figure 12.20: XML output in the weapon inventory file'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：武器库存文件中的XML输出
- en: 'To read back our XML into a list of weapons, we set up everything almost exactly
    same except we use the `Deserialize()` method from the `XmlSerializer` class instead:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的XML读回到武器列表中，我们设置了一切几乎完全相同，只是我们使用`XmlSerializer`类的`Deserialize()`方法代替：
- en: 'Add the following method to the bottom of the `DataManager` class:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到`DataManager`类的底部：
- en: '[PRE37]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call the new method in `Initialize` and pass in the `_xmlWeapons` as a parameter:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize`中调用新方法，并将`_xmlWeapons`作为参数传递：
- en: '[PRE38]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s break down the `deserialize()` method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下`deserialize()`方法：
- en: First, we check if the file exists
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否存在
- en: If the file exists, we create an `XmlSerializer` object and specify that we're
    going to put the XML data back into a `List<Weapon>` object
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们创建一个`XmlSerializer`对象，并指定我们将XML数据放回一个`List<Weapon>`对象中
- en: 'Then, we open up a `FileStream` with the `_xmlWeapons` file name:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开一个名为`_xmlWeapons`的`FileStream`：
- en: We're using `File.OpenRead()` to specify that we want to open the file for reading,
    not writing
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`File.OpenRead()`来指定我们想要打开文件进行读取，而不是写入
- en: 'Next, we create a variable to hold our deserialized list of weapons:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个变量来保存我们的反序列化武器列表：
- en: We put the explicit `List<Weapon>` cast in front of the call to `Deserialize()`
    so that we get the correct type back from the serializer
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`Deserialize()`之前，我们在前面明确地进行了`List<Weapon>`的强制类型转换，以确保从序列化器返回正确的类型
- en: Finally, we use a `foreach` loop to print out each weapon's name and damage
    values in the console
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`foreach`循环在控制台打印出每件武器的名称和伤害值
- en: When you run the game once again, you'll see that we get a console message for
    each weapon we deserialized from the XML list.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行游戏时，你会看到我们为从XML列表中反序列化的每一件武器在控制台得到一条消息。
- en: '![](img/B17573_12_21.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图12.21](img/B17573_12_21.png)'
- en: 'Figure 12.21: Console output from deserializing XML'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：反序列化XML的控制台输出
- en: That's all we need to do for XML data, but before we finish out the chapter
    we still need to learn how to work with JSON!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们处理XML数据所需做的全部工作，但在我们完成本章之前，我们仍然需要学习如何处理JSON！
- en: Serializing and deserializing JSON
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化和反序列化JSON
- en: When it comes to serializing and deserializing JSON, Unity and C# aren't completely
    in sync. Essentially, C# has its own `JsonSerializer` class that works the exact
    same way as the `XmlSerializer` class we used in the previous examples.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到序列化和反序列化JSON时，Unity和C#并不完全同步。本质上，C#有一个自己的`JsonSerializer`类，它的工作方式与我们在前例中使用的`XmlSerializer`类完全相同。
- en: In order to access the JSON serializer, you need the `System.Text.Json` `using`
    directive. Here's the rub—Unity doesn't support that namespace. Instead, Unity
    uses the `System.Text` namespace and implements its own JSON serializer class
    called `JsonUtility`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问JSON序列化器，你需要`System.Text.Json`的`using`指令。这里的问题是——Unity不支持该命名空间。相反，Unity使用`System.Text`命名空间，并实现了自己的JSON序列化器类，称为`JsonUtility`。
- en: Because our project is in Unity, we're going to work with Unity's supported
    serialization class. However, if you're working with a non-Unity C# project, the
    concepts are the same as the XML code we just wrote.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目在Unity中，我们将使用Unity支持的序列化类。然而，如果你在非Unity的C#项目中工作，这些概念与我们所写的XML代码相同。
- en: You can find a complete how-to that includes code from Microsoft at [https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Microsoft的文档中找到一个完整的指南，包括代码：[https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize)。
- en: 'Your next task is to serialize a single weapon to get the hang of the `JsonUtility`
    class:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是序列化单个武器，以熟悉`JsonUtility`类：
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的顶部添加一个新的`using`指令：
- en: '[PRE39]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的XML文件添加一个新的私有字符串路径，并在`Awake()`中设置其值：
- en: '[PRE40]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的底部添加一个新的方法：
- en: '[PRE41]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Call the new method in `Initialize()` and pass in the `_jsonWeapons` as a parameter:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法，并将`_jsonWeapons`作为参数传递：
- en: '[PRE42]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here''s the breakdown of the serialize method:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是序列化方法的分解：
- en: First, we need a weapon to work with, so we create one with our class initializer
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个武器来操作，所以我们使用我们的类初始化器创建一个
- en: 'Then we declare a variable to hold the translated JSON data when it''s formatted
    as a string and call the `ToJson()` method:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们声明一个变量来保存当JSON数据格式化为字符串时的翻译数据，并调用`ToJson()`方法：
- en: The `ToJson()` method we're using takes in the `sword` object we want to serialize
    and a Boolean value of `true` so the string is pretty printed with proper indenting.
    If we didn't specify a `true` value, the JSON would still print out, it would
    just be a regular string, which isn't easily readable.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的`ToJson()`方法接受我们想要序列化的`sword`对象和一个布尔值`true`，这样字符串将以适当的缩进格式化。如果我们没有指定`true`值，JSON仍然会打印出来，但它将是一个普通的字符串，这并不容易阅读。
- en: Now that we have a text string to write to a file, we create a `StreamWriter`
    stream and pass in the `_jsonWeapons` file name
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个要写入文件的文本字符串，我们创建一个`StreamWriter`流并将`_jsonWeapons`文件名传递给它
- en: Finally, we use the `WriteLine()` method and pass it the `jsonString` value
    to write to the file
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`WriteLine()`方法并将`jsonString`值传递给它来写入文件
- en: Run the program and look at the new JSON file we created and wrote data into!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并查看我们创建并写入数据的新JSON文件！
- en: '![](img/B17573_12_22.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_22.png)'
- en: 'Figure 12.22: JSON file with weapon properties serialized'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：序列化武器属性的JSON文件
- en: Now let's try and serialize our list of weapons we used in the XML examples
    and see what happens.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试将我们在XML示例中使用的武器列表序列化，看看会发生什么。
- en: 'Update the `SerializeJSON()` method to use the existing list of weapons instead
    of the single `sword` instance:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`SerializeJSON()`方法，使用现有的武器列表而不是单个`sword`实例：
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you run the game again, you''ll see the JSON file data was overwritten
    and all we ended up with is an empty array:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行游戏时，你会看到JSON文件数据被覆盖，我们最终得到的是一个空数组：
- en: '![](img/B17573_12_23.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_23.png)'
- en: 'Figure 12.23: JSON file with an empty object after serialization'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：序列化后的JSON文件，其中包含一个空对象
- en: Again, this is because the way Unity handles JSON serialization doesn't support
    lists or arrays by themselves. Any list or array needs to be part of a class object
    for Unity's `JsonUtility` class to recognize and handle it correctly.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Unity处理JSON序列化的方式不支持列表或数组本身。任何列表或数组都需要成为类对象的一部分，以便Unity的`JsonUtility`类能够识别并正确处理它。
- en: Don't panic, if we think about this, it's a fairly intuitive fix—we just need
    to create a class that has a weapons list property and use that when we serialize
    our data into JSON!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 不要慌张，如果我们思考这个问题，这是一个相当直观的修复——我们只需要创建一个具有武器列表属性的类，并在我们将数据序列化为JSON时使用它！
- en: 'Open `Weapon.cs` and add the following serializable `WeaponShop` class to the
    bottom of the file. Be super careful to put the new class outside the `Weapon`
    class curly braces:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Weapon.cs`文件，并将以下可序列化的`WeaponShop`类添加到文件底部。请务必将新类放在`Weapon`类的大括号之外：
- en: '[PRE44]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Back in the `DataManager` class, update the `SerializeJSON()` method with the
    following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类中，使用以下代码更新`SerializeJSON()`方法：
- en: '[PRE45]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s break down the changes we just made:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们刚刚所做的更改：
- en: First, we create a new variable called `shop`, which is an instance of the `WeaponShop`
    class
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的变量`shop`，它是`WeaponShop`类的一个实例
- en: Then we set the `inventory` property to the `weaponInventory` list of weapons
    we already declared
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将`inventory`属性设置为已经声明的`weaponInventory`武器列表
- en: Finally, we pass the `shop` object to the `ToJson()` method and write the new
    string data to the JSON file
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`shop`对象传递给`ToJson()`方法，并将新的字符串数据写入JSON文件
- en: 'Run the game again and look at the pretty printed list of weapons we''ve created:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏并查看我们创建的漂亮打印的武器列表：
- en: '![](img/B17573_12_24.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_12_24.png)'
- en: 'Figure 12.24: List object properly serialized into JSON'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：正确序列化到JSON的列表对象
- en: 'Deserializing JSON text back into an object is the reverse process of what
    we just did:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON文本反序列化为对象是我们刚才做的过程的逆过程：
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的底部添加一个新方法：
- en: '[PRE46]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Call the new method in `Initialize()` and pass `_jsonWeapons` in as a parameter:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法，并将`_jsonWeapons`作为参数传递：
- en: '[PRE47]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s break down the `DeserializeJSON()` method below:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解下面的`DeserializeJSON()`方法：
- en: First, we check if the file exists
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否存在
- en: If it does exist, we create a stream with the `_jsonWeapons` file path wrapped
    in a `using` code block
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们使用`using`代码块将`_jsonWeapons`文件路径包装起来创建一个流
- en: Then, we use the stream's `ReadToEnd()` method to grab the entire JSON text
    from the file
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用流的`ReadToEnd()`方法从文件中获取整个JSON文本
- en: 'Next, we create a variable to hold our deserialized list of weapons and call
    the `FromJson()` method:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个变量来保存我们的反序列化武器列表，并调用`FromJson()`方法：
- en: Notice that we specify that we want to turn our JSON into a `WeaponShop` object
    with the `<WeaponShop>` syntax before passing in the JSON string variable
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我们在将JSON字符串变量传递之前，使用`<WeaponShop>`语法指定我们想要将JSON转换为`WeaponShop`对象
- en: Finally, we loop through the weapon shop's `inventory` list property and print
    out each weapon's name and damage values in the console
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们遍历武器店的`inventory`列表属性，并在控制台打印出每个武器的名称和伤害值
- en: 'Run the game one last time and you''ll see a console message printed out for
    each weapon in our JSON data:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您将在控制台消息中看到我们JSON数据中的每个武器的打印信息：
- en: '![](img/B17573_12_25.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_12_25.png)'
- en: 'Figure 12.25: Console output from deserializing a list of JSON objects'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：反序列化JSON对象的控制台输出
- en: Data roundup
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据汇总
- en: Every individual module and topic we've covered in this chapter can be used
    by itself or combined to suit your project's needs. For example, you could use
    text files to store character dialogue and only load it when you need to. This
    would be more efficient than having the game keep track of it every time it runs,
    even when the information isn't being used.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们涵盖的每个模块和主题都可以单独使用或组合使用以满足您项目的需求。例如，您可以使用文本文件来存储角色对话，并且只有在需要时才加载它。这将比游戏每次运行时都跟踪信息更有效率。
- en: You could also put character data or enemy statistics into either an XML or
    JSON file and read from the file anytime you need to level up a character or spawn
    a new monster. Finally, you could fetch data from a third-party database and serialize
    it into your own custom classes. This is a super common scenario with storing
    player accounts and external game data.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将角色数据或敌人统计数据放入XML或JSON文件中，并在需要提升角色或生成新怪物时从文件中读取。最后，您可以从第三方数据库获取数据并将其序列化到您自己的自定义类中。这是一个非常常见的场景，用于存储玩家账户和外部游戏数据。
- en: You can find a list of data types that can be serialized in C# at [https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer).
    Unity handles serialization a little differently, so make sure you check the available
    types at [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer)找到可以序列化的数据类型列表。Unity处理序列化的方式略有不同，所以请确保您检查[https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html)中可用的类型。
- en: The point I'm trying to make is that data is everywhere, and it's your job to
    create a system that handles it the way your game needs, brick by brick.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图说明的是，数据无处不在，而您的任务是创建一个系统来以游戏所需的方式处理它，一块砖接一块砖。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: And that's a wrap on the basics of working with data! Congratulations on making
    it through this monster chapter intact. Data in any programming context is a big
    topic, so take everything you've learned in this chapter as a jumping-off point.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了数据操作基础的学习！恭喜你完整地通过了这一章。在任何编程环境中，数据都是一个很大的话题，所以将本章学到的所有内容作为一个起点。
- en: You already know how to navigate the filesystem, and create, read, update, and
    delete files. You also learned how to effectively work with text, XML, and JSON
    data formats, as well as data streams. And you know how to take an entire object's
    state and serialize or deserialize it into both XML and JSON. All in all, learning
    these skills was no small feat. Don't forget to review and revisit this chapter
    more than once; there's a lot here that might not become second nature on the
    first run-through.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何导航文件系统，以及如何创建、读取、更新和删除文件。你还学习了如何有效地处理文本、XML和JSON数据格式，以及数据流。你知道如何将整个对象的状态序列化或反序列化成XML和JSON。总的来说，学习这些技能并非易事。不要忘记多次复习和回顾这一章；这里有很多内容可能不会在第一次阅读时变得自然而然。
- en: In the next chapter, we'll discuss the basics of generic programming, get a
    little hands-on experience with delegates and events, and wrap up with an overview
    of exception handling.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论泛型编程的基础，获得一些关于委托和事件的实践经验，并以异常处理概述结束。
- en: Pop quiz – data management
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验 - 数据管理
- en: Which namespace gives you access to the `Path` and `Directory` classes?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命名空间可以让你访问`Path`和`Directory`类？
- en: In Unity, what folder path do you use to save data between runs of your game?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，你使用哪个文件夹路径在游戏运行之间保存数据？
- en: What data type do `Stream` objects use to read and write information to files?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stream`对象使用什么数据类型来读取和写入文件中的信息？'
- en: What happens when you serialize an object into JSON?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将对象序列化为JSON时，会发生什么？
- en: JOIN us on Discord!
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和哈里森·费罗尼一起阅读这本书。提问，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，以及更多。
- en: Join Now!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
