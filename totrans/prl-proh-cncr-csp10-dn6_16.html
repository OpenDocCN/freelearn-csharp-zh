<html><head></head><body>
<div><div><h1 id="_idParaDest-195"><a id="_idTextAnchor194"/>Assessments</h1>
<p>This section contains answers to questions from all chapters.</p>
<h1 id="_idParaDest-196"><em class="italic"><a id="_idTextAnchor195"/></em><a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, Managed Threading Concepts </h1>
<ol>
<li>A managed thread is a thread that is created in .NET-managed code with the <code>System.Threading.Thread</code> object. </li>
<li>Set the <code>Thread.IsBackground</code> property to <code>true</code> before calling <code>Thread.Start()</code>. </li>
<li>.NET will throw a <code>ThreadStateException</code> exception. </li>
<li>.NET prioritizes managed threads mostly based on their <code>Thread.Priority</code> value. </li>
<li><code>ThreadPriority.Highest</code>.</li>
<li><code>Thread.Abort()</code> is not supported by .NET 6. The code will not compile. </li>
<li>Add an object parameter to the method to be started by the new thread, and pass the data when calling <code>Thread.Start(data)</code>. </li>
<li>Pass the delegate to the cancellation token’s <code>Register</code> method. </li>
</ol>
<h1 id="_idParaDest-197"><em class="italic"><a id="_idTextAnchor196"/></em><a href="B18552_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, Evolution of Multithreaded Programming 
in .NET </h1>
<ol>
<li value="1"><code>ThreadPool </code></li>
<li>C# 5.0 </li>
<li>.NET Framework 4.5 </li>
<li>.NET Core 3.0 </li>
<li><code>Task</code>, <code>Task&lt;T&gt;</code>, <code>ValueTask</code>, or <code>ValueTask&lt;T&gt;</code> </li>
<li><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> </li>
<li><code>BlockingCollection&lt;T&gt;</code> </li>
<li><strong class="bold">Parallel LINQ</strong> (<strong class="bold">PLINQ</strong>) </li>
</ol>
<h1 id="_idParaDest-198"><em class="italic"><a id="_idTextAnchor197"/></em><a href="B18552_03_ePub.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, Best Practices for Managed Threading </h1>
<ol>
<li value="1">Singleton.</li>
<li><code>ThreadStatic</code>. </li>
<li>A deadlock occurs when multiple threads are all waiting to access a locked resource and cannot proceed. </li>
<li><code>Monitor.TryEnter</code>.</li>
<li><code>Interlocked</code>.</li>
<li><code>Interlocked.Add</code>.</li>
<li><code>MaxDegreeOfParallelism</code>.</li>
<li>Use the <code>WithDegreeOfParallelism</code> extension method.</li>
<li><code>ThreadPool.GetMinThreads()</code>.</li>
</ol>
<h1 id="_idParaDest-199"><em class="italic"><a id="_idTextAnchor198"/></em><a href="B18552_04_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, User Interface Responsiveness and Threading </h1>
<ol>
<li value="1"><code>Task</code> or <code>Task&lt;T&gt;</code>.</li>
<li><code>Task.WhenAll</code>.</li>
<li><code>Task.Factory.StartNew</code>.</li>
<li>A background thread on <code>ThreadPool</code>.</li>
<li><code>Application.Current.Dispatcher.Invoke</code>.</li>
<li><code>this.BeginInvoke</code>.</li>
<li>Check the <code>this.InvokeRequired</code> property.</li>
</ol>
<h1 id="_idParaDest-200"><em class="italic"><a id="_idTextAnchor199"/></em><a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>, Asynchronous Programming with C# </h1>
<ol>
<li value="1"><code>Task.Result</code>.</li>
<li><code>Task.WhenAll()</code>.</li>
<li><code>Task.WaitAll()</code>.</li>
<li><code>Task</code>, <code>Task&lt;TResult&gt;</code>, <code>ValueTask</code>, or <code>ValueTask&lt;TResult&gt;</code>.</li>
<li>I/O-bound operations such as a file or network access are best suited for async methods. </li>
<li>False. It is a best practice to always suffix async methods with <code>Async</code>. </li>
<li><code>Task.Run</code>.</li>
</ol>
<h1 id="_idParaDest-201"><em class="italic"><a id="_idTextAnchor200"/></em><a href="B18552_06_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, Parallel Programming Concepts </h1>
<ol>
<li value="1"><code>Parallel.For</code>.</li>
<li><code>Parallel.ForEachAsync</code>. </li>
<li><code>Parallel.Invoke</code>. </li>
<li><code>TaskCreationOptions.AttachToParent</code>. </li>
<li><code>TaskCreationOptions.DenyAttach</code>. </li>
<li><code>Task.Run</code> will always deny child tasks from attaching. Also, <code>Task.Run</code> has no overloaded methods to provide <code>TaskCreationOptions</code>. </li>
<li>No, regular <code>for</code> and <code>foreach</code> loops can be faster if each loop iteration is fast-running and/or there are only a few iterations of the loop.</li>
</ol>
<h1 id="_idParaDest-202"><em class="italic"><a id="_idTextAnchor201"/></em><a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, Task Parallel Library (TPL) and Dataflow</h1>
<p>The following are the answers to this chapter’s questions:</p>
<ol>
<li value="1"><code>JoinBlock</code>.</li>
<li><code>BufferBlock</code> is a propagator block.</li>
<li><code>BufferBlock</code>.</li>
<li><code>JoinTo()</code>.</li>
<li><code>Complete()</code>.</li>
<li><code>SendAsync()</code>.</li>
<li><code>ReceiveAsync()</code>.</li>
</ol>
<h1 id="_idParaDest-203"><em class="italic"><a id="_idTextAnchor202"/></em><a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, Parallel Data Structures and Parallel LINQ </h1>
<ol>
<li value="1"><code>AsParallel()</code>. </li>
<li><code>AsSequential()</code>. </li>
<li><code>AsOrdered()</code>. </li>
<li><code>ForAll()</code>.</li>
<li><code>AsOrdered()</code> can significantly decrease performance for a query. </li>
<li><code>OrderBy</code> and <code>OrderByDescending</code>. They will default to <code>ParallelMergeOptions.FullyBuffered</code>. </li>
<li>No. PLINQ has additional overhead that can cause queries on smaller datasets or simple queries to be slower. </li>
<li><code>ParallelMergeOptions.NotBuffered</code>.</li>
</ol>
<h1 id="_idParaDest-204"><em class="italic"><a id="_idTextAnchor203"/></em><a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, Working with Concurrent Collections in .NET</h1>
<ol>
<li value="1"><code>BlockingCollection&lt;T&gt;</code>. </li>
<li><code>ConcurrentQueue&lt;T&gt;</code>. </li>
<li><code>BlockingCollection&lt;T&gt;</code>. </li>
<li><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>. </li>
<li><code>Enqueue()</code>. </li>
<li><code>TryAdd()</code> and <code>TryGetValue()</code>. </li>
<li>No. Always add your own synchronization mechanisms when using extension methods with concurrent collections, including standard LINQ operators. </li>
</ol>
<h1 id="_idParaDest-205"><em class="italic"><a id="_idTextAnchor204"/></em><a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a>, Debugging Multithreaded Applications with Visual Studio </h1>
<ol>
<li value="1">Use the <strong class="bold">Attach to Process</strong> window or set multiple startup projects in the solution file. </li>
<li>They are grouped by process. </li>
<li>Right-click in the window and select <strong class="bold">Columns</strong>. </li>
<li>The <strong class="bold">Parallel Stacks</strong> window. </li>
<li><code>.PNG</code> files. </li>
<li>Four. </li>
<li>The <strong class="bold">Debug Location</strong> toolbar. </li>
<li>Click the <strong class="bold">Flag Just My Code</strong> button. </li>
</ol>
<h1 id="_idParaDest-206"><em class="italic"><a id="_idTextAnchor205"/></em><a href="B18552_11_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>, Canceling Asynchronous Work </h1>
<ol>
<li value="1"><code>CancellationToken.IsCancellationRequested</code> </li>
<li><code>CancellationTokenSource</code> </li>
<li><code>OperationCanceledException</code> </li>
<li>Register callback </li>
<li><code>ManualResetEventSlim</code> </li>
<li><code>ManualResetEventSlim.Reset</code> </li>
<li><code>CancellationTokenSource.CreateLinkedTokenSource</code> </li>
</ol>
<h1 id="_idParaDest-207"><em class="italic"><a id="_idTextAnchor206"/></em><a href="B18552_12_ePub.xhtml#_idTextAnchor186"><em class="italic">Chapter 12</em></a>, Unit Testing Async, Concurrent, and Parallel Code</h1>
<ol>
<li value="1"><code>Fact</code> </li>
<li><code>SpinLock.WaitUntil</code> </li>
<li><code>AggregateException</code> </li>
<li><code>Exception</code> </li>
<li><code>Assert.NotNull</code> </li>
<li><strong class="bold">Test Explorer </strong></li>
<li>MSTest, NUnit, and xUnit .NET </li>
<li>ReSharper, Rider, and the dotMemory Unit standalone console runner </li>
</ol>
</div>
</div>
</body></html>