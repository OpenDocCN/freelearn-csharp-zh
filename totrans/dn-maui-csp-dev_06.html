<html><head></head><body>
		<div><h1 id="_idParaDest-110" class="chapter-number"><a id="_idTextAnchor115"/>6</h1>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor116"/>Layout</h1>
			<p>In the previous two chapters, we looked at controls – the widgets that ask for and display data – but widgets need to be positioned on the page, with a process called the layout. Layout is the difference between<a id="_idIndexMarker269"/> an ugly app and a professional-looking one.</p>
			<p>There are several layout controls available to you, which we will cover in this chapter:</p>
			<ul>
				<li>Vertical and horizontal stack layouts</li>
				<li><code>Grid</code></li>
				<li>Scrolling</li>
				<li>Flex layout</li>
			</ul>
			<p class="callout-heading">I am not a designer</p>
			<p class="callout">For a page to look professional, a designer must work with the developer, specifying not only where to put the controls but also the font size, font, margins, and so on. I am not a designer, and the pages we’ll create are for illustration purposes only; they will not be pretty.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor117"/>Technical requirements</h1>
			<p>The source code for this chapter can be found in the GitHub repository under this branch: <a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Layouts">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Layouts</a></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor118"/>Stack layouts</h1>
			<p>Stack layouts allow you to stack one <a id="_idIndexMarker270"/>control on top of another or next to one another. They come in three flavors:</p>
			<ul>
				<li><code>StackLayout</code></li>
				<li><code>VerticalStackLayout</code></li>
				<li><code>HorizontalStackLayout</code></li>
			</ul>
			<p>The first of these is for backward compatibility with <code>Xamarin.Forms</code> and is effectively deprecated; the other two are far more performant.</p>
			<p>We’ve seen <code>VerticalStackLayout</code> and <code>HorizontalStackLayout</code> at work already. As the name indicates, <code>VerticalStackLayout</code> places one control <em class="italic">on top of</em> another, while <code>HorizontalStackLayout</code> places them side by side. Using <code>margins</code> (the space between objects) and <code>padding</code> (the space around an object), you can tweak a nice enough<a id="_idIndexMarker271"/> layout with just these controls:</p>
			<pre class="source-code">
&lt;VerticalStackLayout x:Name="LoginStackLayout"&gt;
    &lt;HorizontalStackLayout WidthRequest="300"&gt;
        &lt;Label
            Style="{StaticResource LargeLabel}"
            Text="User Name" /&gt;
        &lt;Entry
            HorizontalOptions="End"
            Placeholder="User Name"
            Text="{Binding Name}"
            WidthRequest="150" /&gt;
    &lt;/HorizontalStackLayout&gt;
    &lt;HorizontalStackLayout WidthRequest="300"&gt;
        &lt;Label
            Style="{StaticResource SmallLabel}"
            Text="Password" /&gt;
        &lt;Entry
            HorizontalOptions="End"
            IsPassword="True"
            Placeholder="Password"
            Text="{Binding Password}"
            WidthRequest="150" /&gt;
    &lt;/HorizontalStackLayout&gt;
    &lt;BoxView
        Color="Red"
        HeightRequest="2"
        Margin="0,20"
        WidthRequest="400" /&gt;</pre>
			<p>Here, on the <code>LoginPage</code> page, we start with a <code>VerticalStackLayout</code> object, which will contain everything below it until the closing <code>&lt;/VerticalStackLayout&gt;</code> tag. Immediately, we<a id="_idIndexMarker272"/> declare a <code>HorizontalStackLayout</code> object, which contains a <code>Label</code> (acting as a prompt) and an <code>Entry</code> (gathering the name from the user).</p>
			<p>Below <code>HorizontalStackLayout</code> is a second <code>HorizontalStackLayout</code> and below that is a <code>BoxView</code>. In short, <code>VerticalStackLayout</code> continues to stack views on top of each other.</p>
			<p>While this is fine for a very simple layout, it has its limitations. Working with <code>VerticalStackLayout</code> and <code>HorizontalStackLayout</code> on complicated layouts becomes difficult after a short while.</p>
			<p>Enter the most powerful layout of them all: <code>Grid</code>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor119"/>Grid</h1>
			<p>Nothing comes close to <code>Grid</code> for<a id="_idIndexMarker273"/> flexibility, although its basic use is dead simple. A grid consists of rows and columns. You define the size of each and then fill in the resulting boxes.</p>
			<p>By default, all the columns are the same width, and all the rows are the same height. Rows and columns are identified (by default) by their offset starting at column 0, row 0. You can leave out the 0 (it is the default <a id="_idIndexMarker274"/>value) but I advise against doing so for readability. (This is the same reason I mark private methods and classes with the <code>private</code> keyword.)</p>
			<p>We can recreate the <code>LoginPage</code> page using <code>Grid</code>. Let’s look at the first approximation in full (I’ve left out the resources section, as it is unchanged):</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
    Title="Login Page"
    x:Class="ForgetMeNotDemo.View.LoginPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:behaviors="http://schemas.microsoft.com/dotnet
     /2022/maui/toolkit"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"&gt;
    &lt;VerticalStackLayout x:Name="LoginStackLayout"&gt;   [1]
        &lt;Grid  [2]
            ColumnDefinitions="*,*,*"  [3]
            RowDefinitions="*,*,*,*,*"  [4]
            x:Name="LoginGrid"&gt;
            &lt;Label
                Grid.Column="0"  [5]
                Grid.Row="0"  [6]
                HorizontalOptions="End" [7]
                Margin="5,20,0,10"
                Text="User Name"
                VerticalOptions="Center" [8] /&gt;
            &lt;Entry
                Grid.Column="1"
                Grid.ColumnSpan="2" [9]
                Grid.Row="0"
                HorizontalOptions="Center"
                Margin="5,20,0,10"
                Placeholder="User Name"
                Text="{Binding Name}"
                VerticalOptions="End"
                WidthRequest="150" /&gt;
            &lt;Label                     [10]
                Grid.Column="0"
                Grid.Row="1"
                HorizontalOptions="End"
                Margin="5,10"
                Text="Password"
                VerticalOptions="Center" /&gt;
            &lt;Entry
                Grid.Column="1"
                Grid.ColumnSpan="2"
                Grid.Row="1"
                HorizontalOptions="Center"
                IsPassword="True"
                Placeholder="Password"
                Text="{Binding Password}"
                VerticalOptions="Start"
                WidthRequest="150" /&gt;
            &lt;BoxView
                Color="Red"
                Grid.Column="0"
                Grid.ColumnSpan="3" [11]
                Grid.Row="2"
                HeightRequest="2"
                Margin="0,10"
                WidthRequest="400" /&gt;</pre>
			<p>The next thing to add<a id="_idIndexMarker275"/> is the frames:</p>
			<pre class="source-code">
            &lt;Frame
                BorderColor="Blue"
                CornerRadius="10"
                Grid.Column="0"
                Grid.Row="3"
                HasShadow="True"
                HeightRequest="50"
                WidthRequest="50"&gt;
                &lt;Frame.Background&gt;
                    &lt;LinearGradientBrush EndPoint="1,0"&gt;
                        &lt;GradientStop Color="Yellow" Offset="0.2" /&gt;
                        &lt;GradientStop Color="Red"
                            Offset="0.1" /&gt;
                    &lt;/LinearGradientBrush&gt;
                &lt;/Frame.Background&gt;
            &lt;/Frame&gt;
            &lt;Frame
                BorderColor="Blue"
                CornerRadius="10"
                Grid.Column="1"
                Grid.ColumnSpan="2"
                Grid.Row="3"
                HasShadow="True"
                HeightRequest="50"
                WidthRequest="100"&gt;
                &lt;Frame.Background&gt;
                    &lt;RadialGradientBrush&gt;
                        &lt;GradientStop Color="Yellow"
                            Offset="0.2" /&gt;
                        &lt;GradientStop Color="Red"
                            Offset="0.1" /&gt;
                    &lt;/RadialGradientBrush&gt;
                &lt;/Frame.Background&gt;
            &lt;/Frame&gt;</pre>
			<p>With that in place, we can add the <a id="_idIndexMarker276"/>three buttons and then close <code>Grid</code> and <code>VerticalStackLayout</code>:</p>
			<pre class="source-code">
            &lt;Button
                BackgroundColor="Gray"
                Command="{Binding SubmitCommand}"
                Grid.Column="0"
                Grid.Row="4"
                Margin="5"
                Text="Submit" /&gt;
            &lt;Button
                BackgroundColor="Gray"
                Command="{Binding CreateCommand}"
                Grid.Column="1"
                Grid.Row="4"
                Margin="5"
                Text="Create Account" /&gt;
            &lt;Button
                BackgroundColor="Gray"
                Clicked="OnForgotPassword"
                Grid.Column="2"
                Grid.Row="4"
                Margin="5"
                Text="Forgot Password" /&gt;
            &lt;Label
                Grid.Column="0"
                Grid.ColumnSpan="3"
                Grid.Row="5"
                Text="
                x:Name="CreateAccount" /&gt;
        &lt;/Grid&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre>
			<p>[1] We’ll put <code>Grid</code> inside a <code>VerticalStackLayout</code> so that we can add the <code>ProgressBar</code> below the grid (adding it to <code>VerticalStackLayout</code>’s <code>Children</code> collection, which will have <a id="_idIndexMarker277"/>only two members: <code>Grid</code> and <code>ProgressBar</code>).</p>
			<p>[2] We declare <code>Grid</code> with the keyword.</p>
			<p>[3] We declare three columns of equal size (<code>*,*,*</code>).</p>
			<p class="callout-heading">“Some have stars upon thars” – Dr. Seuss</p>
			<p class="callout">Stars don’t make much difference when they are all the same size, but if, for example, we wanted the first to be twice as big as the others, we would write the following:</p>
			<p class="callout"><code>ColumnDefinitions="2*,*,*"</code></p>
			<p class="callout">In that case, the column would be divided into four equal parts and the first column would get two of them and the other columns one each. The result is that the first column would be twice as wide as the others.</p>
			<p>[4] Similarly, we declare five rows of equal size.</p>
			<p>[5] We place the Label inside column 0.</p>
			<p>[6] We place the Label inside row 0.</p>
			<p>[7] The horizontal option is with respect to the column the control is in.</p>
			<p>[8] The vertical option is with respect to the row the control is in.</p>
			<p>[9] A control can span across more than one column. In this case, the entry begins at column 1 and runs for a column span of 2 (that is, it occupies both column 1 and 2).</p>
			<p>[10] Notice that we don’t need a <code>HorizontalStackLayout</code> because the position of the prompt with respect to the entry is determined by what columns they are in and their horizontal options (for example, start, center, or end).</p>
			<p>[11] <code>BoxView</code> wants to stretch<a id="_idIndexMarker278"/> across the entire grid and so starts at column 0 and has a column span of 3.</p>
			<p>Notice that nothing else needs to change. I manipulated the margins and vertical options to get the <em class="italic">pixel-perfect</em> alignment I was looking for, but other than that, the XAML remains the same.</p>
			<p>One other thing to note is that we have an opportunity to factor out the vertical and horizontal options and the margins into the styles.</p>
			<p>The result of converting the <code>StackLayout</code> into this grid is shown in <em class="italic">Figure 6</em><em class="italic">.1</em>.</p>
			<div><div><img src="img/Figure_6.1_B19723.jpg" alt="Figure 6.1 – First grid layout&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – First grid layout</p>
			<p>Notice that the <code>ProgressBar</code> is still shown. It is added to <code>VerticalStackLayout</code> in the code-behind as it <a id="_idIndexMarker279"/>was previously.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor120"/>Sizing rows and columns</h2>
			<p><code>RowHeight</code> and <code>ColumnWidth</code> can be <a id="_idIndexMarker280"/>defined in one of three ways:</p>
			<ol>
				<li><em class="italic">absolute</em>: A value in DIUs</li>
				<li><em class="italic">auto</em>: Auto-sized based on the cell contents</li>
				<li><em class="italic">Stars</em>: As shown earlier, with proportional allocation</li>
			</ol>
			<p>Currently, the top of the <code>Grid</code> looks like this:</p>
			<pre class="source-code">
        &lt;Grid  [2]
            ColumnDefinitions="*,*,*"
            RowDefinitions="*,*,*,*,*"</pre>
			<p>We could have used <code>auto</code> to say that <a id="_idIndexMarker281"/>each control will take up the amount of room it needs on each row:</p>
			<pre class="source-code">
        &lt;Grid  [2]
            ColumnDefinitions="*,*,*"
            RowDefinitions="auto,auto,auto,auto,auto"</pre>
			<p>Let’s also set the height of the frames to <code>150</code>. <code>auto</code> allocates enough room for the newly enlarged frames, as illustrated in <em class="italic">Figure 6</em><em class="italic">.2</em>.</p>
			<div><div><img src="img/Figure_6.2_B19723.jpg" alt="Figure 6.2 – Using auto-sizing&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Using auto-sizing</p>
			<p class="callout-heading">Best practice – minimize use of auto</p>
			<p class="callout">Microsoft recommends minimizing the use of <code>auto</code> as it is less performant (the layout engine has to perform<a id="_idIndexMarker282"/> additional calculations). That being said, at times, it is very useful, especially when the size of the<a id="_idIndexMarker283"/> object will be determined at runtime.</p>
			<p>We could rewrite the rows shown before as follows:</p>
			<pre class="source-code">
&lt;Grid
    ColumnDefinitions="*,*,*"
    RowDefinitions="*,*,auto,auto,50,auto"</pre>
			<p>The calculation now would be to find the actual size of the three <code>auto</code> rows and add <code>50</code> Device-Independent Units, for the fifth row. Then, we take what is left in the grid size, and divide it equally between the <a id="_idIndexMarker284"/>first and second rows. The result is shown in the following figure:</p>
			<div><div><img src="img/Figure_6.3_B19723.jpg" alt="Figure 6.3 – Combining stars, absolute, and auto&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Combining stars, absolute, and auto</p>
			<p>As you can see, by mixing and<a id="_idIndexMarker285"/> matching, you can create an awful-looking UI. On the other hand, given to a designer, these three options (<code>absolute</code>, stars, and <code>auto</code>) can be used to create beautiful UIs with precise control over sizing.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor121"/>Named rows and columns</h2>
			<p>In the preceding code, we referred to each row and column by its zero-based offset. Thus, the frames were in <code>Grid.row[3]</code> in <code>Grid.column[0]</code> and <code>Grid.column[1]</code>. With large grids, this can become confusing and difficult to manage.</p>
			<p>In C#, .NET MAUI offers you the <a id="_idIndexMarker286"/>option of naming your rows and columns using an enumeration. To see this, let’s create an alternative login page, entirely in C#, and then take a look at it.</p>
			<p>We’ll simplify the page slightly, taking out <code>BoxView</code> and <code>Frame</code>, to keep our focus on the manipulation of the rows and columns.</p>
			<p>First, we are going to define enumerations, which will serve as the names of our rows and columns, respectively:</p>
			<pre class="source-code">
enum Row
{
  Username,
  Password,
  Buttons
}
enum Column
{
  Submit,
  Create,
  Forgot
}</pre>
			<p>What you use for these names is entirely up to you; typically, you’ll use something that describes what goes into those rows and columns. Thus, here, my first row will hold <code>Username</code>, my second row will hold <code>Password</code>, and my third row will hold our three <code>Buttons</code>.</p>
			<p>Notice that the columns are named after the type of buttons. That makes it difficult (or confusing) to use those <a id="_idIndexMarker287"/>columns with these rows. We’ll solve that by falling back to using offsets on those rows.</p>
			<p>Here is the complete class, which I named <code>LoginCS.cs</code>:</p>
			<pre class="source-code">
class LoginCS : ContentPage
{
  public LoginCS()  [1]
  {
    BindingContext = new LoginViewModel();
    Content = new VerticalStackLayout() [2]
    {
      Children =
                {
                    new Grid()  [3]
                    {
                        RowDefinitions = GridRowsColumns
                           .Rows.Define(
                            (Row.Username,Auto), [4]
                            (Row.Password,Auto),
                            (Row.Buttons, Auto)
                            ),
                        ColumnDefinitions = GridRowsColumns
                            .Columns.Define(
                            (Column.Submit,Star), [5]
                            (Column.Create, Star),
                            (Column.Forgot, Star)
                            ),
                        Children =
                        {
                            new Label()
                                .Text("User name")
                                .Row(Row.Username)
                                    .Column(0), [6]
                            new Entry()
                                .Placeholder("User name")
                                .Bind(Entry.TextProperty,
                                  nameof(LoginViewModel
                                   .Name))
                                .Row(Row.Username)
                                   .Column(1)
                                .ColumnSpan(2),
                            new Label()
                                .Text("Password")
                                .Row(Row.Password)
                                  .Column(0),
                            new Entry {IsPassword = true}
                                .Placeholder("Password")
                                .Bind(Entry.TextProperty,
                                    nameof(LoginViewModel
                                      .Password))
                                .Row(Row.Password)
                                  .Column(1)
                                .ColumnSpan(2),
                            new Button()
                                .Text("Submit")
                                .Row(Row.Buttons).Column
                                  (Column.Submit) [7]
                                .Margin(5)
                                .BindCommand(nameof
                                 (LoginViewModel
                                   .SubmitCommand)),
                            new Button()
                                .Text("Create Account")
                                .Margin(5)
                <a id="_idTextAnchor122"/>                .Row(Row.Buttons).Column
                                  (Column.Create)
                                .BindCommand(nameof
                                (LoginViewModel
                                  .CreateCommand)),
                            new Button()
                                .Margin(5)
                                .Text("Forgot Password")
                                .Row(Row.Buttons)
                                   .Column(Column.Forgot)
                        }
                    }
                }
    };
  }
}</pre>
			<p>[1] The work is done in the constructor</p>
			<p>[2] As in the XAML, we start with <code>VerticalStackLayout</code></p>
			<p>[3] <code>Grid</code> is a child of <code>VerticalStackLayout</code></p>
			<p>[4] We define the first row to use the enumerated name and the sizing of <code>auto</code></p>
			<p>[5] We define the first column to<a id="_idIndexMarker288"/> use the enumerated column name and the sizing of a <em class="italic">star</em> (equivalent to 1 <code>*</code>)</p>
			<p>[6] Notice that while the row name is meaningful and I therefore use it, the column name would not be meaningful and so I just use the offset</p>
			<p>[7] Here, both the row name and the column name are meaningful, and it is much easier to figure out what is going on by using these names rather than the offsets</p>
			<p>There is no doubt that <code>.Row(Row.Buttons).Column(Column.Create)</code> is much easier to understand than <code>Row[4].Column[1]</code>.</p>
			<p>If you want to use this page, don’t forget to point to your new page, <code>LoginCS.cs</code>, in <code>AppShell.xaml</code>.</p>
			<p class="callout-heading">Oops</p>
			<p class="callout">The <code>Submit</code> button will crash the program as the <code>Submit</code> command in <code>LoginViewModel</code> is looking for <code>LoginPage.LoginProgressBar</code>. We could fix this, but the goal here was to show that you can re-write <code>LoginPage</code> in C#.</p>
			<p>We’ll stay with the<a id="_idIndexMarker289"/> original <code>LoginPage.xaml</code> for the rest of this book, as that is more complete.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor123"/>ScrollView</h1>
			<p>Often, you will have more data to show than can fit on the page. This is especially frequent when working with lists, but can also be true for a form. The <code>ScrollView</code> control wraps around your other <a id="_idIndexMarker290"/>controls and allows them to be scrolled.</p>
			<p>We saw the use of <code>ScrollView</code> in <code>PreferencesPage</code>, where we wrapped <code>VerticalStackLayout</code> in a <code>ScrollView</code> control:</p>
			<pre class="source-code">
&lt;ScrollView&gt;
    &lt;VerticalStackLayout&gt;</pre>
			<p>The number of preferences was just more than would show on a phone screen all at once. You can see the scroll effect a bit more if you add some more preferences to <code>PreferenceService</code>.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor124"/>FlexLayout</h1>
			<p><code>FlexLayout</code> is similar to <code>VerticalStackLayout</code> and <code>HorizontalStackLayout</code> with one crucial distinction: if you are using one of the stack layouts and the items extend past the end<a id="_idIndexMarker291"/> of the page (and you don’t use <code>ScrollView</code>), anything that doesn’t fit won’t be rendered.</p>
			<p class="callout-heading">FlexLayout – seem familiar?</p>
			<p class="callout"><code>FlexLayout</code> might be familiar if you’ve worked with CSS. <code>FlexLayout</code> is very similar to the Flexible Box Layout and, in fact, was based on the CSS module.</p>
			<p>You can see the effect of <code>FlexLayout</code> by removing <code>ScrollView</code> from <code>PreferencesPage</code>. All of the remaining preferences are inaccessible.</p>
			<p>With <code>FlexLayout</code>, the items are wrapped to the next row or column. You define which by setting the direction in <code>FlexLayout</code>. The possible directions are as follows:</p>
			<ul>
				<li><code>Row</code>: Stacks children horizontally</li>
				<li><code>Row-reverse</code>: Stacks horizontally in reverse order</li>
				<li><code>Column</code>: Stacks children <a id="_idIndexMarker292"/>vertically</li>
				<li><code>Column-reverse</code>: Stacks vertically in reverse order</li>
			</ul>
			<p>Remove <code>VerticalStackLayout</code> and replace it with <code>FlexLayout</code>. Set the direction to <code>Row</code>:</p>
			<pre class="source-code">
&lt;FlexLayout
    Direction="Row"&gt;</pre>
			<p><em class="italic">Figure 6</em><em class="italic">.4</em> shows the result. It is ugly but it conveys what is happening. The excess items are wrapped horizontally.</p>
			<div><div><img src="img/Figure_6.4_B19723.jpg" alt="Figure 6.4 – Mangling your screen with FlexLayout&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Mangling your screen with FlexLayout</p>
			<p>Let’s see whether we can come up with a better, less ugly example.</p>
			<p class="callout-heading">Wrap</p>
			<p class="callout">One of the properties of <code>FlexLayout</code> is <code>Wrap</code>, which defaults to <em class="italic">no-wrap</em>. Most of the time, however, you will want it to wrap, and you will end up with this wonderful syntax:</p>
			<p class="callout"><code>Wrap = "</code><code>Wrap"</code></p>
			<p>We’ll return to the <code>Login</code> page <a id="_idIndexMarker293"/>and, just before the end, we’ll add a <code>HorizontalStackLayout</code> containing four buttons that won’t quite fit, as shown in <em class="italic">Figure 6</em><em class="italic">.5</em>.</p>
			<div><div><img src="img/Figure_6.5_B19723.jpg" alt="Figure 6.5 – The buttons don’t fit in the row&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The buttons don’t fit in the row</p>
			<p>Now, we’ll replace <code>HorizontalStackLayout</code> with <code>FlexLayout</code> with <code>Wrap</code> set to <code>Wrap</code>:</p>
			<pre class="source-code">
&lt;FlexLayout
    Direction="Row"
    Wrap="Wrap"&gt;</pre>
			<p><code>FlexLayout</code> <em class="italic">sees</em> that the fourth<a id="_idIndexMarker294"/> button won’t fit and wraps it to the next row, as shown in the following figure:</p>
			<div><div><img src="img/Figure_6.6_B19723.jpg" alt="Figure 6.6 – FlexLayout wraps the buttons&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – FlexLayout wraps the buttons</p>
			<p>.NET MAUI has added a <code>BindableLayout</code> object, which, frankly, I don’t find terribly useful.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor125"/>Summary</h1>
			<p>In this chapter, we looked at the principal layouts used in designing .NET MAUI apps. The most powerful and flexible of these is <code>Grid</code>, although <code>HorizontalStackLayout</code> and <code>VerticalStackLayout</code> are often used for somewhat simpler layouts.</p>
			<p>In the next chapter, we will examine how to move from page to page and how to send data as we move. We will look at the Shell and at routing, the essential aspects of page navigation.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor126"/>Quiz</h1>
			<ol>
				<li>What are the three ways you can define the width of a column in a grid?</li>
				<li>If a grid’s column definition looks like this – <code>(2*, auto, *, 100)</code> – how will the space be divided?</li>
				<li>If a <code>Button</code> object is defined like this:<pre class="source-code">
new Button()</pre><pre class="source-code">
    .Margin(5)</pre><pre class="source-code">
    .Text("Forgot Password")</pre><pre class="source-code">
    .Row(Row.Buttons).Column(Column.Forgot)</pre></li>
			</ol>
			<p>What do we know about its position?</p>
			<ol>
				<li value="4">What is the advantage of <code>Grid</code> over using <code>VerticalStackLayout</code> and <code>HorizontalStackLayout</code>?</li>
				<li>Why is <code>BindableLayout</code> less useful than, for example, <code>CollectionView</code>?</li>
			</ol>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor127"/>You try it</h1>
			<p>Create a page that looks like a standard four-function calculator. Use the layout shown in <em class="italic">Figure 6</em><em class="italic">.7</em>. Extra credit: implement the functionality and display the result in a <code>Label</code>.</p>
			<div><div><img src="img/Figure_6.7_B19723.jpg" alt="Figure 6.7 – Four-function calculator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Four-function calculator</p>
		</div>
	

		<div><h1 id="_idParaDest-122"><a id="_idTextAnchor128"/>Part 2 – Intermediate Topics</h1>
			<p>With the basics under our belt, we’ll go on to look at a number of intermediate topics, including how you navigate from one page to the next and how you store data, both for a user’s preferences and in a relational database. We’ll end with the most important topic – creating unit tests.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B19723_07.xhtml#_idTextAnchor129"><em class="italic">Chapter 7</em></a>, <em class="italic">Understanding Navigation</em></li>
				<li><a href="B19723_08.xhtml#_idTextAnchor144"><em class="italic">Chapter 8</em></a>, <em class="italic">Storing and Retrieving Data</em></li>
				<li><a href="B19723_09.xhtml#_idTextAnchor160"><em class="italic">Chapter 9</em></a>, <em class="italic">Unit Testing</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>