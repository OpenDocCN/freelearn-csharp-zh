- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerization of Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After building clients and services with the previous chapters, now is the time
    to make the services ready for publishing. With Docker, we can prepare images
    that have everything included to run the complete solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll start learning the most important parts of Docker, building
    Docker images, running containers, and using .NET Aspire to run a solution consisting
    of multiple services locally on your developer system, including SQL Server running
    in a Docker container, as well as making use of native **ahead-of-time** (**AOT**)
    to create platform-specific native applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the solution with .NET Aspire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using native AOT with ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What you need to go through this chapter is **Docker Desktop**. Docker Desktop
    is free for individual developers and education and open source communities. You
    can download Docker Desktop from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/),
    best used with the **Windows Subsystem for Linux** (**WSL**). Check the README
    file of this chapter to install WSL 2 and Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `dotnet publish` command supports building and publishing Docker images.
    While some features of `dotnet publish` can be used without Docker Desktop being
    installed, we start using Docker directly, as this also helps in understanding
    what can be done using the .NET CLI, and often you need a lot more in regard to
    Docker than offered by the .NET CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ch05` source code folder contains the code samples for this chapter. For
    different sections of this chapter, different subfolders are available. For a
    start, working through the instructions, you can use the `StartXX` folders. `StartDocker`
    contains the projects before creating Docker containers have been added and the
    `FinalDocker` folder contains the project in the final state after building the
    Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: The `StartAspire` folder contains multiple projects that the .NET Aspire-specific
    projects we created in the previous chapters are already part of. Use this as
    a starting point to work through the .NET Aspire part of this chapter. `FinalAspire`
    contains the complete result, which you can use as a reference. The `NativeAOT`
    folder contains the code for the games API that compiles with .NET native AOT.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the subfolders of the `ch05` folder, you’ll see these projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs` – The games API project we used in the previous chapter
    from our client application. In this chapter, we make minor updates to specify
    the connection string to the SQL Server database. This project has a reference
    to NuGet packages with implementations of the `IGamesRepository` interface for
    SQL Server and Azure Cosmos DB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Bot` – This is a new project that implements a REST API and calls
    the games API to automatically play games with random game moves. This project
    makes use of the client library we created in [*Chapter 4*](B21217_04.xhtml#_idTextAnchor092)
    – it has a reference to the `CNinnovation.Codebreaker.Client` NuGet package to
    call the games API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost` – This project is enhanced to orchestrate the different
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.ServiceDefaults` – This project is unchanged in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs.NativeAOT` – A new project that offers the same games
    API with some changes to support native AOT with .NET 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although nowadays, it’s possible just to work with .NET tools to create microservices
    and run Docker containers, it helps to know about Docker. Thus, here, we look
    at the most important concepts about Docker, starting up a SQL Server instance
    running within a Docker container, creating a Dockerfile to build a Docker image
    for the games API service, and running these containers on the local system. In
    case you already know all about Docker, you can skip and move over to the *.NET
    Aspire* section, which does not need the Docker containers created here.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into building Docker images, why do we need containers at all?
    When deploying an application, it often occurs that the application fails to run.
    Often, a reason for this is a missing runtime on the target system or wrong or
    missing configuration settings. One way to resolve this is to prepare **virtual
    machines** (**VMs**) where everything is preinstalled. The disadvantage of this
    is the resources that the VM needs. A VM comes with an operating system and allocates
    CPU and memory resources. Docker is a lot more lightweight. A Docker image can
    be small as an operating system is not part of the image – and multiple Docker
    containers can share the same CPU and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief list of important terms when using Docker before going into
    the details:'
  prefs: []
  type: TYPE_NORMAL
- en: A Docker **image** is an executable package that contains everything to run
    an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One image might have different versions, which are identified by Docker **tags**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Dockerfile** is a text file with instructions to build a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker **container** is the running instance of a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker **registry** is where Docker images are stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker **repository** is a collection of different versions of a Docker image
    in the registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Desktop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker Desktop for Windows offers an environment to build Docker images and
    run Docker containers on Windows. You can configure it to use Windows or Linux
    containers. With a previous edition of Docker Desktop for Windows, it was required
    to install Hyper-V. Docker Desktop then used a Linux VM to run all Linux containers
    on this VM. Because Windows now supports Linux more natively with WSL, Docker
    Desktop can use WSL and doesn’t need a VM. With the Docker Desktop configuration,
    you can select WSL distros (see *Figure 5**.1*) that should use the same Docker
    environment as on the Windows system itself. Using these Linux distributions,
    you can use the same Docker commands to manage your Docker environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – WSL integration in Docker Desktop](img/B21217_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – WSL integration in Docker Desktop
  prefs: []
  type: TYPE_NORMAL
- en: Instead of configuring a VM with the amount of CPU and memory you allocate,
    WSL shares CPU and memory with Windows – but there are some limits for WSL. With
    the Windows build version 20176 and later, the memory is limited to 50% and 8
    GB (whichever is less); with builds before that, WSL can use 80% of the total
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: For the number of logical processors, by default, all available can be used.
    You can change memory and CPU limits globally for the complete subsystem but also
    define different limits for each Linux distribution you install. Check the settings
    configuration in WSL at [https://learn.microsoft.com/windows/wsl/wsl-config](https://learn.microsoft.com/windows/wsl/wsl-config).
  prefs: []
  type: TYPE_NORMAL
- en: Running a Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you’ve installed Docker Desktop and you are running Windows, you can select
    to run Windows or Linux containers. While Windows containers are great for legacy
    applications that only run on Windows (for example, using .NET Framework), Linux
    containers offer more features, and Linux Docker images are smaller. The solution
    we build will run with Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Desktop environment needs to be started, then to run the first container,
    use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the first run, the `hello-world` Docker image is downloaded from the Docker
    registry and started. This container just writes a message to the screen to verify
    that everything is running. Starting it a second time, you’ll see that the image
    is no longer downloaded but started immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all images downloaded, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To see running containers, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also a shorthand notation to show all running containers: `docker ps`.'
  prefs: []
  type: TYPE_NORMAL
- en: You will not see the `hello-world` container because this already stopped immediately
    after writing the output.
  prefs: []
  type: TYPE_NORMAL
- en: Running an image again and again, you start fresh again. But there’s also a
    state kept with a running image. This allows you to continue a previously stopped
    container with the same state as before. The `docker container ls -a` command
    not only shows running but also stopped containers. Using `docker container prune`,
    you can delete the state from all stopped containers.
  prefs: []
  type: TYPE_NORMAL
- en: Running SQL Server in a Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we used SQL Server and an
    Azure Cosmos DB emulator on the local system to access it from the games service.
    Instead of installing these products on your local system, you can also use Docker
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start downloading the Docker image for SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we used `docker run` to start a container and implicitly download
    it from a registry. `docker pull` just downloads the image from the registry.
    `mcr.microsoft.com` is the Microsoft repository where Microsoft stores images.
    `mssql/server` is the name of the image. You can read information about this image
    at [https://hub.docker.com/_/microsoft-mssql-server](https://hub.docker.com/_/microsoft-mssql-server).
    This is an Ubuntu-based image. `2022-latest` is a tag name. This is the actual
    version of SQL Server 2022\. With SQL Server, other tags are `2019-latest`, `2017-latest`,
    and `latest`. These correspond to SQL Server 2019 and 2017\. The `latest` tag
    is the latest version of SQL Server. At the time of this writing, the image is
    the same with both the `2022-latest` and the `latest` tags. If you download both
    images, a second download is not needed, and you will see images with the same
    image ID but with different tags.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration to use SQL Server with the Docker image is the SQL
    Server Developer Edition. You can also configure to use the Express, Standard,
    Enterprise, and Enterprise Core editions by setting an environmental variable.
    Pay attention to required licenses with non-developer editions. Read the image
    documentation for setting environment variables for the different editions.
  prefs: []
  type: TYPE_NORMAL
- en: Another option to use a SQL Server edition within a Docker environment is Azure
    SQL Edge. Check [https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment](https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment)
    for running Azure SQL Edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the SQL Server image, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, these options are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e` specifies an environmental variable. With the two variables, the license
    is accepted, and a password for the `sa` account is defined. `sa` is a privileged
    account configured, and a short name for *system administrator*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` option maps the port from the host to the container. On the target
    host, the same port cannot be used for multiple applications; for example, by
    having a local SQL Server running, the first value cannot use 1433\. Make sure
    to use an available port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--name` option specifies a name for the container. By default, a random
    name combined from two lists is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--hostname` option specifies the hostname for the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-d` option runs the container in the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For some useful information to find out what the container does, use `docker`
    `container logs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command needs the name of the container. To connect and wait for all the
    logs to come, add the `-f` option (for *follow*).
  prefs: []
  type: TYPE_NORMAL
- en: To open a command prompt within the container and see what’s there, use `docker
    exec -it sql1 bash`, which allocates a terminal, keeps `stdin` open (interactive
    mode), and executes the Bash shell within the container.
  prefs: []
  type: TYPE_NORMAL
- en: After the container with SQL Server is running, we can publish the database
    we created in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063).
  prefs: []
  type: TYPE_NORMAL
- en: Using volumes with a Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker container for SQL Server contains state (the database files). We
    can start a previous running container again (using `docker start`). When using
    `docker run`, we start fresh again, and the previous state is not used. Using
    `docker commit`, you can create a new image from a container. This keeps the database
    and the state together, and the Docker images grow in size. A better practice
    is to keep the state outside of the Docker container. You can mount external directories,
    files, and Docker volumes within a container. Docker volumes are completely managed
    by Docker. Let’s use this for SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates a volume with the name `gamessqlstorage`. To check the volumes
    available, use `docker volume ls`. To get more information about a volume, execute
    `docker` `volume inspect`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the container with the database using this volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-v` option mounts the `/var/opt/mssql` folder within the container to the
    `gamessqlstorage` volume. All data written by SQL Server to this folder now goes
    into this volume. The state is now kept externally from the container. So, let’s
    create a database next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When creating backups of the database, you should also use volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database in the Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the container is running, you can access it with a tool such as **SQL Server
    Object Explorer** from Visual Studio or **SQL Server Management Studio**. The
    connection string you can use is shown in the following .NET configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With the `appsettings.json` file, you also need to change the `DataStore` key
    to the `SqlServer` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Docker with a Linux host system, you can use the IP address of the Docker
    container with the port number to access services within the Docker container.
    This might not work with Windows. That’s why the `host.docker.internal` hostname
    was introduced: to map to the service via a gateway using the local port number.
    With the connection string to the database, you need to add the port number after
    the hostname, separated by a comma. To pass the user and password, use the `user
    id` and `password` keys. Because the certificate from the server Docker container
    might not be from a trusted authority on the Windows system, add the `TrustServerCertificate`
    setting to the connection string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we published a database
    using the `dotnet ef` command line. Now is the time to create this database within
    the Docker container. With the following command, your current directory needs
    to be the directory of the games API service (`Codebreaker.GameAPIs`), the `DataStorage`
    configuration value in `appsettings` set to `SqlServer`, and the connection string
    specified as shown before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this, the database is created – or migrated to the latest version. The
    `-p` option is needed because the EF Core context is in a different project than
    the `-c`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With the games service project, you have another option to create the database.
    For an easier way to create a SQL Server database, the `/createsql` API is offered
    now in addition to the other APIs. Sending a `POST` request creates or upgrades
    the database (if SQL Server is configured) using the EF Core `MigrateAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a custom Docker image for the games API service. *Figure
    5**.2* shows a C4 container diagram to give you an overview picture of the containers
    we use. The first container we create is the one on the right, hosting SQL Server.
    Next, we create a Docker image for the game APIs, which accesses the SQL Server
    container. The container on the left is the new bot project, which invokes the
    services running in the game APIs’ container to automatically play games:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – C4 container diagram](img/B21217_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – C4 container diagram
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET CLI `dotnet publish` command supports creating Docker images without
    using a Dockerfile. However, to understand Docker, we need to know about Dockerfiles.
    That’s why we start building a Docker image defining a Dockerfile first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dockerfile for the games API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a Docker image using the Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the games API with a Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Docker image using `dotnet publish`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker images are created using instructions in Dockerfiles. Using Visual Studio,
    you can easily create a Dockerfile from Solution Explorer, using `Codebreaker.GamesAPI`
    project creates a multi-stage Dockerfile. A multi-stage Dockerfile creates interim
    images for different stages.
  prefs: []
  type: TYPE_NORMAL
- en: Base stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the following code snippets, the different stages are explained. The first
    stage prepares a Docker image for the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Every Dockerfile starts with a `FROM` instruction. The `FROM` instruction defines
    the base image that is used. `mcr.microsoft.com/dotnet/aspnet` is an image optimized
    for production. With .NET 8, this image is based on Debian 12 (Bookworm). The
    `Debian:12-slim` image is defined by a Dockerfile with `FROM scratch`, so this
    is the root of the hierarchy of instructions. The `dotnet/aspnet` image contains
    the .NET runtime and the ASP.NET Core runtime. The .NET SDK is not available with
    this image. The `AS` instruction defines a name that allows using the result of
    this stage with another stage. The `USER` instruction defines the user that should
    be used with the instructions of the stage. The `WORKDIR` instruction sets the
    working directory for following instructions. If the directory does not exist
    in the image, it’s created. The last step in the first stage is the `EXPOSE` instruction.
    With `EXPOSE`, you define the ports that the application is listening to. By default,
    `TCP` is used, but you can also specify to have an `UDP` receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '.NET 8 has some changes with Docker image generation: the default container
    images run with non-root users (the app user), and the default port is no longer
    port 80\. Port 80 is a privileged port that requires the root user. The new default
    port is now 8080.'
  prefs: []
  type: TYPE_NORMAL
- en: Build stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second stage builds the ASP.NET Core application:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the second stage, we ignore the first stage for a moment and use a different
    base image: `dotnet/sdk`. This image contains the .NET SDK and is used to build
    the application. First, a `src` directory is created, and the current directory
    is set to `src`. The `ARG` instruction specifies an argument that can be passed
    when invoking building the Docker image. If this argument is not passed, the default
    value is `Release`. Next, you’ll see multiple `COPY` instructions to copy the
    project files to subfolders within the current directory. The project files contain
    the package references. In case the `dotnet restore` command that is started using
    the `RUN` instruction fails, there’s no need to continue with the next steps.
    `dotnet restore` downloads the NuGet packages. In case you use a different NuGet
    feed, the Dockerfile needs some changes to copy `nuget.config` as well. When `dotnet
    restore` succeeds, the complete source code from `.` is copied to the current
    directory (which is `src` at this time) with the `COPY` instruction. Next, the
    working directory is changed to the directory of the games API project, and the
    `dotnet build` command is invoked to create release code for the application.
    With `dotnet build`, the `BUILD_CONFIGURATION` argument is used, which was specified
    with `ARG`. Having the release build in the `src/app/build` folder is the result
    for the interim image after the last command.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that unnecessary files are not copied with instructions such as
    `COPY . .`, the `.dockerignore` file is used. Similar to the `.gitignore` file
    where files are specified to be ignored, with a `.dockerignore` file, you specify
    what files should not be copied to the image.
  prefs: []
  type: TYPE_NORMAL
- en: Publish stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, the second stage is used as a base for the third stage:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `FROM build` instruction uses the result from the previous stage and continues
    here. The `dotnet publish` command results in code that’s needed to publish the
    application. The files needed for publication are copied to the `/src/app/publish`
    folder. While the working directory was configured with the previous stage, continuing
    on the build image, the working directory is still set.
  prefs: []
  type: TYPE_NORMAL
- en: Final stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the final stage, we continue with the first stage, which was named `base`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first instruction with this stage is to set the working directory to `app`.
    Then, referencing the third state with `--from=publish`, the `/app/publish` directory
    from the `publish` stage is copied to the current directory. The `ENTRYPOINT`
    instruction defines what should be done on running the image: the `dotnet bootstrapper`
    command starts and receives `Codebreaker.GameAPIs.dll` as an argument. You can
    do this from the command line as well: `dotnet Codebreaker.GameAPIs.dll` starts
    the entry point of the application to kick off the Kestrel server, and the application
    is available to receive requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Before building the Dockerfile, make sure the `DataStore` configuration in `appsettings.json`
    is set to `InMemory` to use the in-memory provider by default when starting the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image with a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build the image, set the current directory to the directory of the solution,
    and use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With simple Dockerfiles, using just `docker build` can be enough to build the
    image. However, the Dockerfile we use contains references to other projects. With
    this, we need to pay attention to the context. With the games API service, multiple
    projects need to be compiled, and the paths used as specified with the Dockerfile
    use the parent directory. Setting the current directory to the directory of the
    solution, the context is set to this directory with the first argument after the
    build command (`.`). The `-f` option next references the location of the Dockerfile.
    With the `-t` option, the image is tagged. The repository name (`codebreaker/gamesapi`)
    needs to be lowercase, followed by the `3.5.3` tag name and the `latest` tag name.
    Tag names can be strings; there’s no requirement on the version. It’s just a good
    practice to always tag the latest version with the `latest` tag. Specifying the
    `-t` option two times, we get two image names that reference the same image with
    the same image identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the images built, use `docker images`. To restrict the output to `codebreaker`
    images, you can define a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To check a Docker image for how it was built, we can use the `docker` `history`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5**.3* shows the result of the `docker history` command. This shows
    every instruction from the Dockerfile that was used to build the image. Of course,
    what you don’t see with the `codebreaker/gamesapi` image is the `dotnet build`
    and `dotnet restore` commands. The `build` and `publish` stages have only been
    used for interim images to build the application and to create the files needed.
    Comparing the output to the Dockerfile we created, you see `ENTRYPOINT` on top,
    followed by `COPY`, `WORKDIR`, and so on. With each of these instructions, you
    can also see the size result of the instruction. The `COPY` command copied 3,441
    MB into the image. The `USER` instruction was the first instruction coming from
    our Dockerfile; the instructions before that (in the lines below the `USER` instruction)
    show the instructions when the base image was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Result of docker history command](img/B21217_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Result of docker history command
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the exposed ports, environmental variables, the entry point, and more
    of an image, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The result is presented in JSON information and shows information such as exposed
    ports, environment variables, the entry point, the operating system, and the architecture
    this image is based on. When running the image, it helps to know what port number
    needs to be mapped and which environment variables could be useful to override.
  prefs: []
  type: TYPE_NORMAL
- en: Running the games API using Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can start the Docker image of the games API service with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can check the log output using `docker logs <container-id>` (get
    the ID of the running container with `docker ps`). You can interact with the games
    service using any client using the following HTTP address: `http://localhost:8080`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the default configuration of the data store, games are just stored in
    memory. To change this, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure a network to let multiple Docker containers directly communicate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Docker container for the SQL Server instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass configuration values to the Docker container for the games API to use the
    SQL Server instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring a network for Docker containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To let containers communicate with each other, we create a network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Docker supports multiple network types, which can be set using the `--driver`
    option. The default is a `docker network ls` to show all networks.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Docker container with SQL Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start the Docker container for SQL Server where the database already exists,
    you can either use the Docker image we committed or access the state of the previous
    running container. Here, we do the latter, where we define the name `sql1` as
    the name of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Use `docker ps` to check for the running container and see the port mapping
    as it was defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the command adds the running container to the `codebreakernet` network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Starting the Docker container with the games API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we need to start the games API but override the configuration values.
    This can be done by setting environmental variables. Passing environmental variables
    at the start of a Docker container can not only be done by setting the `-e` option
    but also by using `--env-file` and passing a file with environmental variables.
    This is the content of the `gameapis.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: gameapis.env
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating the DI container of the application with the default container registers
    multiple configuration providers. A provider that uses environmental variables
    wins against the JSON file providers because of the order the providers are configured
    with the `WebApplicationBuilder` class (or the `Host` class). The `DataStore`
    key is used to select the storage provider. `GamesSqlServerConnection` is a key
    within the hierarchy of `ConnectionStrings`. Using command-line arguments to pass
    configuration values, you can specify a hierarchy of configuration values using
    `:` as a separator; for example, pass `ConnectionStrings:GamesSqlServerConnection`.
    Using `:` does not work everywhere; for example, with environmental variables
    on Linux. Using `__` translates to this hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: With the environment variables file, the connection to the SQL Server Docker
    container is using the hostname of the Docker container and the port that is used
    by SQL Server. Being in the same network, the containers can communicate directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting the container, the environmental variables file is passed using `--env-file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case you get an error that the container name is already in use, you can
    stop running containers with `docker container stop <containername>`. To remove
    the state of the container, you can use `docker container rm <containername>`
    or the `docker rm <containername>` shorthand notation. To delete the state of
    all stopped containers, use `docker container prune`. When starting a new container
    with `dotnet run`, you can also add the `--rm` option to remove a container after
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the name of the `gamesapi` container, the container is added to the
    `codebreakernet` network. Now, we have two containers running communicating with
    each other, and can play games using the games service.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create another Docker image, but this time without using a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image using dotnet publish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we use multiple containers running at the same time. A project
    we didn’t use in previous chapters is `Codebreaker.Bot`. This project offers an
    API and is also a client to the games service – to automatically play games in
    the background after requested by some API calls. In this section, we’ll build
    a Docker image for this project – but without creating a Dockerfile first.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 7, the `dotnet publish` command directly supports creating Docker
    images without a Dockerfile. Using the `docker build` command, we had to pay attention
    to some specific .NET behaviors, such as the need to compile multiple projects.
    With this, it was necessary to specify the context when building the image. The
    .NET CLI knows about the solutions and project structure. The .NET CLI also knows
    about the default Docker base images that are used to build an application with
    ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options to configure the generation can be specified in the project file and
    using the parameters of `dotnet publish`. Here are some of the configurations
    specified in the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`ContainerImageTags` and `ContainerPort` are just two of the elements that
    are used by `dotnet publish`. You can change the base image with `ContainerBaseImage`,
    specify container runtime identifiers (`ContainerRuntimeIdentifier`), name the
    registry (`ContainerRegistry`), define environmental variables, and more. See
    [https://learn.microsoft.com//dotnet/core/docker/publish-as-container](https://learn.microsoft.com//dotnet/core/docker/publish-as-container)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `dotnet publish`, the name of the repository is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The bot API service communicates with the games service, and the games service
    uses a container running SQL Server. Now, we already have three Docker containers
    collaborating. The games API needs a connection to the database, and the bot needs
    a link to the games API.
  prefs: []
  type: TYPE_NORMAL
- en: Running the solution with .NET Aspire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031), we added .NET Aspire to
    the solution, which contained only the games API service. In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063),
    we added a SQL Server database running in a Docker container without keeping state.
    Here, we’ll extend the .NET Aspire configuration by using SQL Server running in
    a Docker container using a volume and configure the bot service to access the
    games API.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Docker container for SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a Docker container with .NET Aspire can be orchestrated using .NET code
    – with extension methods of the `IDistributedApplication` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `AddSqlServer` method adds SQL Server as a .NET Aspire resource to the app
    model. On the developer system, a Docker container is used to run SQL Server.
    When we created the container before in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063),
    we assigned a password using the default password configuration. Here we explicitly
    create an app model parameter using the `AddParameter` method. With this, parameters
    are retrieved from the Parameters configuration section. Thus, the parameter named
    `SqlConfiguration` is retrieved from `Paramters:SqlConfiguration`. This parameter
    resource is passed with the second parameter of `AddSqlServer`. If the password
    is not assigned, and a parameter named with the resource (sql) postfixed with
    -password does not exist, a random password is created. This is great if no volume
    mounts are used, and the database is created newly every time the container starts
    up. Using a persistent volume, the same password needs to be used with every run
    of the container. This is done by supplying the password configuration. The password
    is needed with the database connection string to access the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `WithDataVolume` method defines the use of a Docker volume for the SQL Server
    container. Within the container, the database is stored within the `/var/opt/mssql`
    folder. Remember – without using a volume, the database is stored within the container
    itself, and the state is not kept when running a new container instance. While
    invoking `WithDataVolume`, there's no need to know what directories of the container
    need to mapped. This is known by the WithDataVolume method. We just pass the optional
    name of the volume, and if the volume should be read-only. With this volume, the
    database files are written to, thus it’s not read-only. In [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263),
    when adding Grafana and Prometheus Docker containers, we’ll use read-only mounts.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddDatabase` method adds the SQL Server database as a child resource to
    SQL Server. The name passed here defines the name of the resource and the name
    of the database.
  prefs: []
  type: TYPE_NORMAL
- en: So that .NET Aspire adds implicit service discovery, the database is referenced
    from the game APIs project using the `WithReference` method. With this, the `CodebreakerSql`
    database name can be used to reference the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `AddSqlServer` method, there’s no need to know the Docker image name
    for SQL Server or the environment variables that need to be specified, as we’ve
    done this earlier using the SQL Server Docker image. All this is done within the
    implementation of this method. To see how any Docker image can be added to the
    .NET Aspire app model, let’s look at the implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this code, an endpoint is defined to map a passed port number to the port
    number `1433` that is used by SQL Server running in the container; the container
    registry, image name, and tag values are specified, and environment variables
    are created to accept the `AddSqlServer` method. Using .NET Aspire, we don’t need
    to know this with available components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting the application, make sure to set configuration via a user
    secret to store the password for SQL Server within the `Codebreaker.AppHost` project;
    for example, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to configure the .NET Aspire SQL Server component.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the .NET Aspire SQL Server component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the games API, the EF Core context is configured with the DI container
    using the .NET Aspire SQL Server EF Core component:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the configuration is just the usual .NET EF Core configuration
    to specify the EF Core database provider and the connection string. Just make
    sure to use the connection string key that was used with the app model definition.
    The connection string is forwarded from the `AppHost` project to the games API
    service. The parameter with the value `CodebreakerSql` matches the name of the
    database that has been configured with the app model. Using .NET Aspire orchestration
    (which uses `Microsoft.Extensions.ServiceDiscovery`) gets the connection string
    with this name from the orchestrator configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The `EnrichSqlServerDbContext` method adds .NET Aspire configuration for retries,
    logging, and metrics.
  prefs: []
  type: TYPE_NORMAL
- en: With this, the games API service with the database configuration is in place.
    Next, add interaction between the bot service and the games API service.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interaction with multiple services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both the games API service and the bot service are configured by adding a project
    to the distributed application:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The SQL Server Docker container was added using the `AddSqlServer` method. All
    .NET projects that should be orchestrated with .NET Aspire need to be added using
    the `AddProject` method. The class definition for the project is created from
    a source generator when adding a project reference to the `AppHost` project. Adding
    a reference to the `Codebreaker.Bot` project created a class named `Codebreaker_Bot`.
    All project classes are defined within the `Projects` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The bot service needs a reference to the games API, thus the `WithReference`
    method is used to generate implicit service discovery. The bot can use the name
    `http://gameapis` to reference the games API service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration to retrieve the link to the games API is configured with
    the `HttpClient` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Bot/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseAddress` of `HttpClient` is configured with the name of the games API,
    as defined with the `gameapis` orchestration configuration – prefixed with `http://`.
    There’s no need to specify .NET configuration to configure the link.
  prefs: []
  type: TYPE_NORMAL
- en: With just these few updates in place, we can start the `Codebreaker.AppHost`
    project in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Running the solution with .NET Aspire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `dotnet run` to build and run the `Codebreaker.AppHost` project starts
    up the Docker container for SQL Server, the games API, the bot service, and the
    .NET Aspire dashboard. *Figure 5**.4* shows all started resources in the .NET
    Aspire dashboard. From here, you can see if services started successfully and
    access configured environment variables for services, logs, as well as accessible
    endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – .NET Aspire resources in the dashboard](img/B21217_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – .NET Aspire resources in the dashboard
  prefs: []
  type: TYPE_NORMAL
- en: With resources, make sure to open the **Details** column to see the environment
    variables configured. When checking logs with the SQL Server Docker container,
    you can see issues when using an invalid password – for example, a password that
    doesn’t fulfill the requirements or a password that doesn’t match the volume that
    was initially set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the endpoint of the bot to show the OpenAPI test page, you can
    start multiple game runs, as shown in *Figure 5**.5*. Specify the number of games
    the bot should play in a sequence, the delay time between the games, and the delay
    time with every move, and click the **Execute** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – OpenAPI test page for the bot service](img/B21217_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – OpenAPI test page for the bot service
  prefs: []
  type: TYPE_NORMAL
- en: 'With the logs of the bot service, you can monitor live information about games
    played by the bot. With every move set, the bot logs information about how good
    the result from the move was and how many possible options are remaining to find
    the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Structured logging of the bot service](img/B21217_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Structured logging of the bot service
  prefs: []
  type: TYPE_NORMAL
- en: After the services are running, you can also access the games API service, see
    the games played today, and use the client created in the previous chapter to
    play some games. Monitor the running Docker container using the Docker CLI, and
    also check the volume created.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get into an exciting feature with .NET 8 – native AOT – next.
  prefs: []
  type: TYPE_NORMAL
- en: Using native AOT with ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparing Docker images with VM images, Docker images are a lot smaller as they
    don’t need to contain the operating system. With ASP.NET Core applications, the
    Docker image contains the application – and the .NET runtime. Over the last years,
    images have become smaller because more and more optimization has been done. Having
    smaller images means faster startup of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 7, it’s possible to create native applications with C# using **native
    AOT**. With this, many changes are required with .NET. With .NET 7, the native
    AOT functionality was very limited. With .NET 8, we can already create ASP.NET
    Core services, which results in faster startup and less memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Using native AOT, an AOT compiler is used to compile `dotnet publish`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all applications can be changed to use native AOT: libraries cannot be
    dynamically loaded, runtime code generation is not possible… With native AOT,
    the code is trimmed, and all libraries need to be native AOT compatible. With
    .NET 8, EF Core is not part of the libraries supporting native AOT. It’s on the
    roadmap, and partial support is planned with EF Core 9.'
  prefs: []
  type: TYPE_NORMAL
- en: By creating a solution based on microservices, it’s possible to differentiate
    technologies with different services. What are the most used services where native
    AOT can give improvements?
  prefs: []
  type: TYPE_NORMAL
- en: With the `codebreaker` solution, the games service can be enhanced with faster
    startup and less memory footprint. This is the most important service of the solution
    where the users should have a fast response at every point in time. However, with
    the lack of support in EF Core, using .NET 8, this is only possible with the in-memory
    games provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an API project to support native AOT, a template is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The most important difference with this project generated is the `<PublishAot>true</PublishAot>`
    setting in the project file. With this, using `dotnet publish` compiles the application
    to native platform-specific code. Because the compiler needs more time to compile
    native code, during development time, IL code is still generated, and the .NET
    runtime is used. As help during development to build native code, analyzers run
    and give compiler errors and warnings if code might not be compatible with native
    AOT.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Codebreaker.GameAPIs.NativeAOT` project, you can start copying the
    code from the `Codebreaker.GameAPIs` project, but some changes are required. We’ll
    focus on the changes needed for native AOT here.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI document generation is removed – including methods to enhance OpenAPI
    documentation. This feature makes use of reflection and dynamic code generation,
    which is not supported. The EF Core SQL Server and Cosmos providers are removed
    from this project as well. Instead, the project only uses the in-memory games
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: .NET 7 included an extremely limited functionality for native AOT. .NET 8 brings
    many more features, but many libraries are not supported yet. With .NET 8, you
    can’t use ASP.NET Core controllers, OpenAPI documentation is not available, the
    authentication library cannot be used, and most EF Core providers don’t support
    native AOT. Over time, more features will be added to support native AOT.
  prefs: []
  type: TYPE_NORMAL
- en: Native AOT doesn’t allow the creation of code dynamically at runtime. Here,
    source generators are of big use. Instead of using reflection emit to create code
    at runtime, with source generators, code is created at compile time. This is not
    only an advantage with native AOT; even without using native AOT, source generators
    can improve the runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the slim builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Native AOT services make use of a slim application builder, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.NativeAOT/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Contrary to the default builder, the number of services registered with the
    DI container is reduced. Logging is reduced as well. The only logging provider
    that is configured with the slim builder is the simple console logging provider.
    In case more functionality is needed, additional services can be added. To reduce
    the number of registered services even further, the `CreateEmptyBuilder` method
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JSON serializer source generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of the `System.Text.Json` serializer needs to be changed to use a source
    generator. Without a source generator, the serializer uses reflection and creates
    code at runtime. This is not supported with native AOT. To generate code at compile
    time, source generators are used. To use the `System.Text.Json` source generator,
    the `AppJsonSerializerContext` class is added:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.NativeAOT/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The class is declared partial to allow the source generator to create additional
    sources to extend the class with additional members. For every type that’s serialized
    with JSON, the `JsonSerializable` attribute is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is used with the DI configuration of the JSON serialization:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.NativeAOT/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this code, the default instance of the context class is added to the type
    resolvers of the `System.Text.Json` serializer.
  prefs: []
  type: TYPE_NORMAL
- en: Building for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After removing the code for the OpenAPI, removing SQL Server and Cosmos library
    references, and adding the `PublishAot` element to the project file, after a successful
    build, `dotnet publish` can be used to create a native application. This is the
    command to create a native image for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using `dotnet publish` with the `win-x64` runtime identifier starts the native
    compiler and writes the binary to the `pubwin` directory. The code is trimmed
    to remove not-used types and members from the binary. As a result, you receive
    a trimmed native executable that doesn’t need to have the .NET runtime installed
    on the target system. Starting the application, you can use any client to play
    games with the in-memory provider.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Linux Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the new Dockerfile we need for the native AOT games service:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.NativeAOT/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the application to native code, using the same SDK-included base
    image, the `clang` and `zlib1g-dev` dependencies need to be installed with the
    Linux environment. This is done as the first step before copying the project files.
    For production, a different base image is used: `dotnet/runtime-deps`. This is
    the new base image containing native dependencies needed by .NET. This image does
    not include the .NET runtime; instead, it can be used for self-contained applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Building the Docker image can be done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Running the solution with the native AOT container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After building the image, you can start the Docker container and use different
    clients (for example, the bot service, the HTTP files, and the client from the
    previous chapter) to test the service. With this, you can also do some performance
    comparisons – but remember that some features have been removed to be native AOT
    compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 8, native AOT is in its early stages. I expect many libraries to be
    updated to support native AOT in time. With a microservices architecture, for
    services that can improve from fast startup times, it can be useful to already
    use native AOT. A native AOT service can make use of gRPC (covered in [*Chapter
    14*](B21217_14.xhtml#_idTextAnchor330), *gRPC for Binary Communication*), and
    the service accessible via gRPC can access the database. In any case, non-AOT
    services can also get improvements from features you’ve seen here, such as the
    slim builder or the JSON serializer source generator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the foundation of Docker, pulling, creating, and
    running Docker images. You used containers that store state with volumes running
    databases in Docker containers, passed environmental variables and secrets to
    running Docker containers, and used .NET Aspire to run multiple containers at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET Aspire, you configured orchestration for multiple services – including
    the configuration of a SQL Server Docker container. Comparing this to the work
    needed with Docker, this was an easy task – but it’s still useful to understand
    the foundations.
  prefs: []
  type: TYPE_NORMAL
- en: With native AOT, you reduced startup times and the memory footprint, which you
    might be able to use with some of your services.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, using the bot, you can now easily play
    thousands of games. The bot uses a simple algorithm to set random moves from a
    list of possible moves. Using the games query, check the number of moves the bot
    needs to find the result. Try to play a game using the client you created in the
    previous chapter to access the Docker container from this chapter. Can you solve
    games in fewer moves?
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter, you can run databases in Docker containers.
    With this, you still need to manage your database in the same way as you manage
    your natively installed on-premises database. Another option you’ll see in the
    next chapter is to use **platform-as-a-service** (**PaaS**) cloud services such
    as Azure Cosmos DB. In the next chapter, we’ll create Azure resources and publish
    Docker images we created in this chapter to **Azure Container Registry** (**ACR**)
    and Azure Container Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Get started with Docker remote containers on WSL* *2*: [https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers](https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How does Docker generate container names?*: [https://frightanic.com/computers/docker-default-container-names/](https://frightanic.com/computers/docker-default-container-names/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configure and customize SQL Server Docker* *containers*: [https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure](https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure SQL Edge Docker image: [https://hub.docker.com/_/microsoft-azure-sql-edge](https://hub.docker.com/_/microsoft-azure-sql-edge)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the Azure Cosmos DB emulator on Docker for Linux: [https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux](https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dockerfile instructions: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Containerize a .NET app with dotnet* *publish*: [https://learn.microsoft.com/dotnet/core/docker/publish-as-container](https://learn.microsoft.com/dotnet/core/docker/publish-as-container)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET service discovery: [https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery](https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Aspire* *documentation*: [https://learn.microsoft.com/en-us/dotnet/aspire](https://learn.microsoft.com/en-us/dotnet/aspire)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Native AOT* *deployment*: [https://learn.microsoft.com/dotnet/core/deploying/native-aot/](https://learn.microsoft.com/dotnet/core/deploying/native-aot/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
